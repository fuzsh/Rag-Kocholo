{
    "id": "dbpedia_4957_1",
    "rank": 81,
    "data": {
        "url": "https://lore.kernel.org/netdev/8864d2741c9bc595d9470041fca3d44beb15a7e0.camel%40redhat.com/T/",
        "read_more_link": "",
        "language": "en",
        "title": "next 0/2] net: Use SMP threads for backlog NAPI.",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "netdev.vger.kernel.org archive mirror help / color / mirror / Atom feed* [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI. @ 2023-08-14 9:35 Sebastian Andrzej Siewior 2023-08-14 9:35 ` [RFC PATCH net-next 1/2] \" Sebastian Andrzej Siewior ` (2 more replies) 0 siblings, 3 replies; 26+ messages in thread From: Sebastian Andrzej Siewior @ 2023-08-14 9:35 UTC (permalink / raw To: linux-kernel, netdev Cc: David S. Miller, Eric Dumazet, Jakub Kicinski, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa The RPS code and \"deferred skb free\" both send IPI/ function call to a remote CPU in which a softirq is raised. This leads to a warning on PREEMPT_RT because raising softiqrs from function call led to undesired behaviour in the past. I had duct tape in RT for the \"deferred skb free\" and Wander Lairson Costa reported the RPS case. Patch #1 creates per-CPU threads for the backlog NAPI. It follows the threaded NAPI model and solves the issue and simplifies the code. Patch #2 gets rid of the warning. Since the ksoftirqd changes the situtation isn't as bad as it was. Still, it would be better to keep it in the context where it originated. Sebastian ^ permalink raw reply [flat|nested] 26+ messages in thread* [RFC PATCH net-next 1/2] net: Use SMP threads for backlog NAPI. 2023-08-14 9:35 [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI Sebastian Andrzej Siewior @ 2023-08-14 9:35 ` Sebastian Andrzej Siewior 2023-08-21 8:32 ` kernel test robot 2023-08-23 13:35 ` Paolo Abeni 2023-08-14 9:35 ` [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush() Sebastian Andrzej Siewior 2023-08-14 18:24 ` [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI Jakub Kicinski 2 siblings, 2 replies; 26+ messages in thread From: Sebastian Andrzej Siewior @ 2023-08-14 9:35 UTC (permalink / raw To: linux-kernel, netdev Cc: David S. Miller, Eric Dumazet, Jakub Kicinski, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Sebastian Andrzej Siewior Backlog NAPI is a per-CPU NAPI struct only (with no device behind it) used by drivers which don't do NAPI them self and RPS. The non-NAPI driver use the CPU local backlog NAPI. If RPS is enabled then a flow for the skb is computed and based on the flow the skb can be enqueued on a remote CPU. Scheduling/ raising the softirq (for backlog's NAPI) on the remote CPU isn't trivial because the softirq is only scheduled on the local CPU and performed after the hardirq is done. In order to schedule a softirq on the remote CPU, an IPI is sent to the remote CPU which schedules the backlog-NAPI on the then local CPU. On PREEMPT_RT interrupts are force-threaded. The soft interrupts are raised within the interrupt thread and processed after the interrupt handler completed still within the context of the interrupt thread. The softirq is handled in the context where it originated. With force-threaded interrupts enabled, ksoftirqd is woken up if a softirq is raised from hardirq context. This is the case if it is raised from an IPI. Additionally there is a warning on PREEMPT_RT if the softirq is raised from the idle thread. This was done for two reasons: - With threaded interrupts the processing should happen in thread context (where it originated) and ksoftirqd is the only thread for this context if raised from hardirq. Using the currently running task instead would \"punish\" a random task. - Once ksoftirqd is active it consumes all further softirqs until it stops running. This changed recently and is no longer the case. Instead of keeping the backlog NAPI in ksoftirqd (in force-threaded/ PREEMPT_RT setups) I am proposing NAPI-threads for backlog. The \"proper\" setup with threaded-NAPI is not doable because the threads are not pinned to an individual CPU and can be modified by the user. Additionally a dummy network device would have to be assigned. Also CPU-hotplug has to be considered if additional CPUs show up. All this can be probably done/ solved but the smpboot-threads already provide this infrastructure. Create NAPI-threads for backlog. The thread runs the inner loop from napi_threaded_poll(), the wait part is different. Since there are now per-CPU threads for backlog the remote IPI for signaling is not needed and can be removed. The NAPI for backlog can always be scheduled as it ends in waking the corresponding thread. Since \"deferred skb free\" use a similar IPI mechanism for signaling, it is also using the backlog threads. This makes NAPI threads mandatory for backlog and it can not be disabled. The other visibile part with RPS (or backlog usage in general) is that it becomes now visible in `top' while earlier it would remain unaccounted. Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de> --- include/linux/netdevice.h | 8 -- net/core/dev.c | 226 +++++++++++++------------------------- net/core/net-procfs.c | 2 +- net/core/skbuff.c | 2 +- 4 files changed, 79 insertions(+), 159 deletions(-) diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h index 0896aaa91dd7b..17e31a68e725e 100644 --- a/include/linux/netdevice.h +++ b/include/linux/netdevice.h @@ -3190,9 +3190,6 @@ struct softnet_data { /* stats */ unsigned int processed; unsigned int time_squeeze; -#ifdef CONFIG_RPS - struct softnet_data *rps_ipi_list; -#endif bool in_net_rx_action; bool in_napi_threaded_poll; @@ -3221,12 +3218,8 @@ struct softnet_data { unsigned int input_queue_head ____cacheline_aligned_in_smp; /* Elements below can be accessed between CPUs for RPS/RFS */ - call_single_data_t csd ____cacheline_aligned_in_smp; - struct softnet_data *rps_ipi_next; - unsigned int cpu; unsigned int input_queue_tail; #endif - unsigned int received_rps; unsigned int dropped; struct sk_buff_head input_pkt_queue; struct napi_struct backlog; @@ -3236,7 +3229,6 @@ struct softnet_data { int defer_count; int defer_ipi_scheduled; struct sk_buff *defer_list; - call_single_data_t defer_csd; }; static inline void input_queue_head_incr(struct softnet_data *sd) diff --git a/net/core/dev.c b/net/core/dev.c index 636b41f0b32d6..40103238ac0a1 100644 --- a/net/core/dev.c +++ b/net/core/dev.c @@ -153,6 +153,7 @@ #include <linux/prandom.h> #include <linux/once_lite.h> #include <net/netdev_rx_queue.h> +#include <linux/smpboot.h> #include \"dev.h\" #include \"net-sysfs.h\" @@ -4658,57 +4659,8 @@ bool rps_may_expire_flow(struct net_device *dev, u16 rxq_index, EXPORT_SYMBOL(rps_may_expire_flow); #endif /* CONFIG_RFS_ACCEL */ - -/* Called from hardirq (IPI) context */ -static void rps_trigger_softirq(void *data) -{ - struct softnet_data *sd = data; - - ____napi_schedule(sd, &sd->backlog); - sd->received_rps++; -} - #endif /* CONFIG_RPS */ -/* Called from hardirq (IPI) context */ -static void trigger_rx_softirq(void *data) -{ - struct softnet_data *sd = data; - - __raise_softirq_irqoff(NET_RX_SOFTIRQ); - smp_store_release(&sd->defer_ipi_scheduled, 0); -} - -/* - * After we queued a packet into sd->input_pkt_queue, - * we need to make sure this queue is serviced soon. - * - * - If this is another cpu queue, link it to our rps_ipi_list, - * and make sure we will process rps_ipi_list from net_rx_action(). - * - * - If this is our own queue, NAPI schedule our backlog. - * Note that this also raises NET_RX_SOFTIRQ. - */ -static void napi_schedule_rps(struct softnet_data *sd) -{ - struct softnet_data *mysd = this_cpu_ptr(&softnet_data); - -#ifdef CONFIG_RPS - if (sd != mysd) { - sd->rps_ipi_next = mysd->rps_ipi_list; - mysd->rps_ipi_list = sd; - - /* If not called from net_rx_action() or napi_threaded_poll() - * we have to raise NET_RX_SOFTIRQ. - */ - if (!mysd->in_net_rx_action && !mysd->in_napi_threaded_poll) - __raise_softirq_irqoff(NET_RX_SOFTIRQ); - return; - } -#endif /* CONFIG_RPS */ - __napi_schedule_irqoff(&mysd->backlog); -} - #ifdef CONFIG_NET_FLOW_LIMIT int netdev_flow_limit_table_len __read_mostly = (1 << 12); #endif @@ -4781,7 +4733,7 @@ static int enqueue_to_backlog(struct sk_buff *skb, int cpu, * We can use non atomic operation since we own the queue lock */ if (!__test_and_set_bit(NAPI_STATE_SCHED, &sd->backlog.state)) - napi_schedule_rps(sd); + __napi_schedule_irqoff(&sd->backlog); goto enqueue; } reason = SKB_DROP_REASON_CPU_BACKLOG; @@ -5896,63 +5848,12 @@ static void flush_all_backlogs(void) cpus_read_unlock(); } -static void net_rps_send_ipi(struct softnet_data *remsd) -{ -#ifdef CONFIG_RPS - while (remsd) { - struct softnet_data *next = remsd->rps_ipi_next; - - if (cpu_online(remsd->cpu)) - smp_call_function_single_async(remsd->cpu, &remsd->csd); - remsd = next; - } -#endif -} - -/* - * net_rps_action_and_irq_enable sends any pending IPI's for rps. - * Note: called with local irq disabled, but exits with local irq enabled. - */ -static void net_rps_action_and_irq_enable(struct softnet_data *sd) -{ -#ifdef CONFIG_RPS - struct softnet_data *remsd = sd->rps_ipi_list; - - if (remsd) { - sd->rps_ipi_list = NULL; - - local_irq_enable(); - - /* Send pending IPI's to kick RPS processing on remote cpus. */ - net_rps_send_ipi(remsd); - } else -#endif - local_irq_enable(); -} - -static bool sd_has_rps_ipi_waiting(struct softnet_data *sd) -{ -#ifdef CONFIG_RPS - return sd->rps_ipi_list != NULL; -#else - return false; -#endif -} - static int process_backlog(struct napi_struct *napi, int quota) { struct softnet_data *sd = container_of(napi, struct softnet_data, backlog); bool again = true; int work = 0; - /* Check if we have pending ipi, its better to send them now, - * not waiting net_rx_action() end. - */ - if (sd_has_rps_ipi_waiting(sd)) { - local_irq_disable(); - net_rps_action_and_irq_enable(sd); - } - napi->weight = READ_ONCE(dev_rx_weight); while (again) { struct sk_buff *skb; @@ -5977,7 +5878,7 @@ static int process_backlog(struct napi_struct *napi, int quota) * We can use a plain write instead of clear_bit(), * and we dont need an smp_mb() memory barrier. */ - napi->state = 0; + napi->state = BIT(NAPI_STATE_THREADED); again = false; } else { skb_queue_splice_tail_init(&sd->input_pkt_queue, @@ -6634,6 +6535,8 @@ static void skb_defer_free_flush(struct softnet_data *sd) if (!READ_ONCE(sd->defer_list)) return; + smp_store_release(&sd->defer_ipi_scheduled, 0); + spin_lock(&sd->defer_lock); skb = sd->defer_list; sd->defer_list = NULL; @@ -6647,39 +6550,42 @@ static void skb_defer_free_flush(struct softnet_data *sd) } } +static void napi_threaded_poll_loop(struct napi_struct *napi) +{ + struct softnet_data *sd; + + for (;;) { + bool repoll = false; + void *have; + + local_bh_disable(); + sd = this_cpu_ptr(&softnet_data); + sd->in_napi_threaded_poll = true; + + have = netpoll_poll_lock(napi); + __napi_poll(napi, &repoll); + netpoll_poll_unlock(have); + + sd->in_napi_threaded_poll = false; + barrier(); + + skb_defer_free_flush(sd); + local_bh_enable(); + + if (!repoll) + break; + + cond_resched(); + } +} + static int napi_threaded_poll(void *data) { struct napi_struct *napi = data; - struct softnet_data *sd; - void *have; while (!napi_thread_wait(napi)) { - for (;;) { - bool repoll = false; - local_bh_disable(); - sd = this_cpu_ptr(&softnet_data); - sd->in_napi_threaded_poll = true; - - have = netpoll_poll_lock(napi); - __napi_poll(napi, &repoll); - netpoll_poll_unlock(have); - - sd->in_napi_threaded_poll = false; - barrier(); - - if (sd_has_rps_ipi_waiting(sd)) { - local_irq_disable(); - net_rps_action_and_irq_enable(sd); - } - skb_defer_free_flush(sd); - local_bh_enable(); - - if (!repoll) - break; - - cond_resched(); - } + napi_threaded_poll_loop(napi); } return 0; } @@ -6714,8 +6620,6 @@ static __latent_entropy void net_rx_action(struct softirq_action *h) */ if (!list_empty(&sd->poll_list)) goto start; - if (!sd_has_rps_ipi_waiting(sd)) - goto end; } break; } @@ -6744,8 +6648,7 @@ static __latent_entropy void net_rx_action(struct softirq_action *h) else sd->in_net_rx_action = false; - net_rps_action_and_irq_enable(sd); -end:; + local_irq_enable(); } struct netdev_adjacent { @@ -11157,7 +11060,7 @@ static int dev_cpu_dead(unsigned int oldcpu) struct sk_buff **list_skb; struct sk_buff *skb; unsigned int cpu; - struct softnet_data *sd, *oldsd, *remsd = NULL; + struct softnet_data *sd, *oldsd; local_irq_disable(); cpu = smp_processor_id(); @@ -11189,22 +11092,13 @@ static int dev_cpu_dead(unsigned int oldcpu) poll_list); list_del_init(&napi->poll_list); - if (napi->poll == process_backlog) - napi->state = 0; - else + if (!WARN_ON(napi->poll == process_backlog)) ____napi_schedule(sd, napi); } raise_softirq_irqoff(NET_TX_SOFTIRQ); local_irq_enable(); -#ifdef CONFIG_RPS - remsd = oldsd->rps_ipi_list; - oldsd->rps_ipi_list = NULL; -#endif - /* send out pending IPI's on offline CPU */ - net_rps_send_ipi(remsd); - /* Process offline CPU's input_pkt_queue */ while ((skb = __skb_dequeue(&oldsd->process_queue))) { netif_rx(skb); @@ -11457,6 +11351,43 @@ static struct pernet_operations __net_initdata default_device_ops = { * */ +static DEFINE_PER_CPU(struct task_struct *, backlog_napi); + +static int backlog_napi_should_run(unsigned int cpu) +{ + struct softnet_data *sd = per_cpu_ptr(&softnet_data, cpu); + struct napi_struct *napi = &sd->backlog; + + if (READ_ONCE(sd->defer_list)) + return 1; + + return test_bit(NAPI_STATE_SCHED, &napi->state); +} + +static void run_backlog_napi(unsigned int cpu) +{ + struct softnet_data *sd = per_cpu_ptr(&softnet_data, cpu); + + napi_threaded_poll_loop(&sd->backlog); +} + +static void backlog_napi_setup(unsigned int cpu) +{ + struct softnet_data *sd = per_cpu_ptr(&softnet_data, cpu); + struct napi_struct *napi = &sd->backlog; + + napi->thread = this_cpu_read(backlog_napi); + set_bit(NAPI_STATE_THREADED, &napi->state); +} + +static struct smp_hotplug_thread backlog_threads = { + .store = &backlog_napi, + .thread_should_run = backlog_napi_should_run, + .thread_fn = run_backlog_napi, + .thread_comm = \"backlog_napi/%u\", + .setup = backlog_napi_setup, +}; + /* * This is called single threaded during boot, so no need * to take the rtnl semaphore. @@ -11497,17 +11428,14 @@ static int __init net_dev_init(void) #endif INIT_LIST_HEAD(&sd->poll_list); sd->output_queue_tailp = &sd->output_queue; -#ifdef CONFIG_RPS - INIT_CSD(&sd->csd, rps_trigger_softirq, sd); - sd->cpu = i; -#endif - INIT_CSD(&sd->defer_csd, trigger_rx_softirq, sd); spin_lock_init(&sd->defer_lock); init_gro_hash(&sd->backlog); sd->backlog.poll = process_backlog; sd->backlog.weight = weight_p; + INIT_LIST_HEAD(&sd->backlog.poll_list); } + smpboot_register_percpu_thread(&backlog_threads); dev_boot_phase = 0; diff --git a/net/core/net-procfs.c b/net/core/net-procfs.c index 09f7ed1a04e8a..086283cc8d47b 100644 --- a/net/core/net-procfs.c +++ b/net/core/net-procfs.c @@ -180,7 +180,7 @@ static int softnet_seq_show(struct seq_file *seq, void *v) sd->processed, sd->dropped, sd->time_squeeze, 0, 0, 0, 0, 0, /* was fastroute */ 0, /* was cpu_collision */ - sd->received_rps, flow_limit_count, + 0 /* was received_rps */, flow_limit_count, input_qlen + process_qlen, (int)seq->index, input_qlen, process_qlen); return 0; diff --git a/net/core/skbuff.c b/net/core/skbuff.c index 33fdf04d4334d..265a8aa6b3228 100644 --- a/net/core/skbuff.c +++ b/net/core/skbuff.c @@ -6802,7 +6802,7 @@ nodefer: __kfree_skb(skb); * if we are unlucky enough (this seems very unlikely). */ if (unlikely(kick) && !cmpxchg(&sd->defer_ipi_scheduled, 0, 1)) - smp_call_function_single_async(cpu, &sd->defer_csd); + __napi_schedule(&sd->backlog); } static void skb_splice_csum_page(struct sk_buff *skb, struct page *page, -- 2.40.1 ^ permalink raw reply related [flat|nested] 26+ messages in thread* [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush(). 2023-08-14 9:35 [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI Sebastian Andrzej Siewior 2023-08-14 9:35 ` [RFC PATCH net-next 1/2] \" Sebastian Andrzej Siewior @ 2023-08-14 9:35 ` Sebastian Andrzej Siewior 2023-08-15 12:08 ` Jesper Dangaard Brouer 2023-08-14 18:24 ` [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI Jakub Kicinski 2 siblings, 1 reply; 26+ messages in thread From: Sebastian Andrzej Siewior @ 2023-08-14 9:35 UTC (permalink / raw To: linux-kernel, netdev Cc: David S. Miller, Eric Dumazet, Jakub Kicinski, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Sebastian Andrzej Siewior Once ksoftirqd become active, all softirqs which were raised, would not be processed immediately but delayed to ksoftirqd. On PREEMPT_RT this means softirqs, which were raised in a threaded interrupt (at elevated process priority), would not be served after the interrupt handler completed its work but will wait until ksoftirqd (normal priority) becomes running on the CPU. On a busy system with plenty of RT tasks this could be delayed for quite some time and leads to problems in general. This is an undesired situation and it has been attempted to avoid the situation in which ksoftirqd becomes scheduled. This changed since commit d15121be74856 (\"Revert \"softirq: Let ksoftirqd do its job\"\") and now a threaded interrupt handler will handle soft interrupts at its end even if ksoftirqd is pending. That means that they will be processed in the context in which they were raised. Unfortunately also all other soft interrupts which were raised (or enqueued) earlier and are not yet handled. This happens if a thread with higher priority is raised and has to catch up. This isn't a new problem and the new high priority thread will PI-boost the current sofitrq owner or start from scratch if ksoftirqd wasn't running yet. Since pending ksoftirqd no longer blocks other interrupt threads from handling soft interrupts I belive the warning can be disabled. The pending softirq work has to be solved differently. Remove the warning and update the comment. Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de> --- include/linux/interrupt.h | 4 ++-- kernel/smp.c | 4 +--- kernel/softirq.c | 12 +++++------- 3 files changed, 8 insertions(+), 12 deletions(-) diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h index a92bce40b04b3..5143ae0ea9356 100644 --- a/include/linux/interrupt.h +++ b/include/linux/interrupt.h @@ -590,9 +590,9 @@ asmlinkage void do_softirq(void); asmlinkage void __do_softirq(void); #ifdef CONFIG_PREEMPT_RT -extern void do_softirq_post_smp_call_flush(unsigned int was_pending); +extern void do_softirq_post_smp_call_flush(void); #else -static inline void do_softirq_post_smp_call_flush(unsigned int unused) +static inline void do_softirq_post_smp_call_flush(void) { do_softirq(); } diff --git a/kernel/smp.c b/kernel/smp.c index 385179dae360e..cd7db5ffe95ab 100644 --- a/kernel/smp.c +++ b/kernel/smp.c @@ -554,7 +554,6 @@ static void __flush_smp_call_function_queue(bool warn_cpu_offline) */ void flush_smp_call_function_queue(void) { - unsigned int was_pending; unsigned long flags; if (llist_empty(this_cpu_ptr(&call_single_queue))) @@ -562,10 +561,9 @@ void flush_smp_call_function_queue(void) local_irq_save(flags); /* Get the already pending soft interrupts for RT enabled kernels */ - was_pending = local_softirq_pending(); __flush_smp_call_function_queue(true); if (local_softirq_pending()) - do_softirq_post_smp_call_flush(was_pending); + do_softirq_post_smp_call_flush(); local_irq_restore(flags); } diff --git a/kernel/softirq.c b/kernel/softirq.c index 807b34ccd7973..aa299cb3ff47b 100644 --- a/kernel/softirq.c +++ b/kernel/softirq.c @@ -281,15 +281,13 @@ static inline void invoke_softirq(void) /* * flush_smp_call_function_queue() can raise a soft interrupt in a function - * call. On RT kernels this is undesired and the only known functionality - * in the block layer which does this is disabled on RT. If soft interrupts - * get raised which haven't been raised before the flush, warn so it can be - * investigated. + * call. On RT kernels this is undesired because the work is no longer processed + * in the context where it originated. It is not especially harmfull but best to + * be avoided. */ -void do_softirq_post_smp_call_flush(unsigned int was_pending) +void do_softirq_post_smp_call_flush(void) { - if (WARN_ON_ONCE(was_pending != local_softirq_pending())) - invoke_softirq(); + invoke_softirq(); } #else /* CONFIG_PREEMPT_RT */ -- 2.40.1 ^ permalink raw reply related [flat|nested] 26+ messages in thread* Re: [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI. 2023-08-14 9:35 [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI Sebastian Andrzej Siewior 2023-08-14 9:35 ` [RFC PATCH net-next 1/2] \" Sebastian Andrzej Siewior 2023-08-14 9:35 ` [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush() Sebastian Andrzej Siewior @ 2023-08-14 18:24 ` Jakub Kicinski 2023-08-17 13:16 ` Sebastian Andrzej Siewior 2 siblings, 1 reply; 26+ messages in thread From: Jakub Kicinski @ 2023-08-14 18:24 UTC (permalink / raw To: Sebastian Andrzej Siewior Cc: linux-kernel, netdev, David S. Miller, Eric Dumazet, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa On Mon, 14 Aug 2023 11:35:26 +0200 Sebastian Andrzej Siewior wrote: > The RPS code and \"deferred skb free\" both send IPI/ function call > to a remote CPU in which a softirq is raised. This leads to a warning on > PREEMPT_RT because raising softiqrs from function call led to undesired > behaviour in the past. I had duct tape in RT for the \"deferred skb free\" > and Wander Lairson Costa reported the RPS case. Could you find a less invasive solution? backlog is used by veth == most containerized environments. This change has a very high risk of regression for a lot of people. ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush(). 2023-08-14 9:35 ` [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush() Sebastian Andrzej Siewior @ 2023-08-15 12:08 ` Jesper Dangaard Brouer 2023-08-15 22:31 ` Yan Zhai 2023-08-16 14:48 ` Jesper Dangaard Brouer 0 siblings, 2 replies; 26+ messages in thread From: Jesper Dangaard Brouer @ 2023-08-15 12:08 UTC (permalink / raw To: Sebastian Andrzej Siewior, linux-kernel, netdev Cc: hawk, David S. Miller, Eric Dumazet, Jakub Kicinski, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, kernel-team, Yan Zhai On 14/08/2023 11.35, Sebastian Andrzej Siewior wrote: > This is an undesired situation and it has been attempted to avoid the > situation in which ksoftirqd becomes scheduled. This changed since > commit d15121be74856 (\"Revert \"softirq: Let ksoftirqd do its job\"\") > and now a threaded interrupt handler will handle soft interrupts at its > end even if ksoftirqd is pending. That means that they will be processed > in the context in which they were raised. $ git describe --contains d15121be74856 v6.5-rc1~232^2~4 That revert basically removes the \"overload\" protection that was added to cope with DDoS situations in Aug 2016 (Cc. Cloudflare). As described in https://git.kernel.org/torvalds/c/4cd13c21b207 (\"softirq: Let ksoftirqd do its job\") in UDP overload situations when UDP socket receiver runs on same CPU as ksoftirqd it \"falls-off-an-edge\" and almost doesn't process packets (because softirq steals CPU/sched time from UDP pid). Warning Cloudflare (Cc) as this might affect their production use-cases, and I recommend getting involved to evaluate the effect of these changes. I do realize/acknowledge that the reverted patch caused other latency issues, given it was a \"big-hammer\" approach affecting other softirq processing (as can be seen by e.g. the watchdog fixes patches). Thus, the revert makes sense, but how to regain the \"overload\" protection such that RX networking cannot starve processes reading from the socket? (is this what Sebastian's patchset does?) --Jesper Thread link for people Cc'ed: https://lore.kernel.org/all/20230814093528.117342-1-bigeasy@linutronix.de/#r ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush(). 2023-08-15 12:08 ` Jesper Dangaard Brouer @ 2023-08-15 22:31 ` Yan Zhai 2023-08-16 14:48 ` Jesper Dangaard Brouer 1 sibling, 0 replies; 26+ messages in thread From: Yan Zhai @ 2023-08-15 22:31 UTC (permalink / raw To: Jesper Dangaard Brouer Cc: Sebastian Andrzej Siewior, linux-kernel, netdev, David S. Miller, Eric Dumazet, Jakub Kicinski, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, kernel-team On Tue, Aug 15, 2023 at 7:08 AM Jesper Dangaard Brouer <hawk@kernel.org> wrote: > > > > On 14/08/2023 11.35, Sebastian Andrzej Siewior wrote: > > This is an undesired situation and it has been attempted to avoid the > > situation in which ksoftirqd becomes scheduled. This changed since > > commit d15121be74856 (\"Revert \"softirq: Let ksoftirqd do its job\"\") > > and now a threaded interrupt handler will handle soft interrupts at its > > end even if ksoftirqd is pending. That means that they will be processed > > in the context in which they were raised. > > $ git describe --contains d15121be74856 > v6.5-rc1~232^2~4 > > That revert basically removes the \"overload\" protection that was added > to cope with DDoS situations in Aug 2016 (Cc. Cloudflare). As described > in https://git.kernel.org/torvalds/c/4cd13c21b207 (\"softirq: Let > ksoftirqd do its job\") in UDP overload situations when UDP socket > receiver runs on same CPU as ksoftirqd it \"falls-off-an-edge\" and almost > doesn't process packets (because softirq steals CPU/sched time from UDP > pid). Warning Cloudflare (Cc) as this might affect their production > use-cases, and I recommend getting involved to evaluate the effect of > these changes. > > I do realize/acknowledge that the reverted patch caused other latency > issues, given it was a \"big-hammer\" approach affecting other softirq > processing (as can be seen by e.g. the watchdog fixes patches). > Thus, the revert makes sense, but how to regain the \"overload\" > protection such that RX networking cannot starve processes reading from > the socket? (is this what Sebastian's patchset does?) > Thanks for notifying us. We will need to evaluate if this is going to change the picture under serious floods. Yan > --Jesper > > Thread link for people Cc'ed: > https://lore.kernel.org/all/20230814093528.117342-1-bigeasy@linutronix.de/#r ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush(). 2023-08-15 12:08 ` Jesper Dangaard Brouer 2023-08-15 22:31 ` Yan Zhai @ 2023-08-16 14:48 ` Jesper Dangaard Brouer 2023-08-16 15:15 ` Yan Zhai 2023-08-16 15:22 ` Sebastian Andrzej Siewior 1 sibling, 2 replies; 26+ messages in thread From: Jesper Dangaard Brouer @ 2023-08-16 14:48 UTC (permalink / raw To: Sebastian Andrzej Siewior, netdev, Paolo Abeni Cc: hawk, David S. Miller, Eric Dumazet, Jakub Kicinski, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, linux-kernel, kernel-team, Yan Zhai On 15/08/2023 14.08, Jesper Dangaard Brouer wrote: > > > On 14/08/2023 11.35, Sebastian Andrzej Siewior wrote: >> This is an undesired situation and it has been attempted to avoid the >> situation in which ksoftirqd becomes scheduled. This changed since >> commit d15121be74856 (\"Revert \"softirq: Let ksoftirqd do its job\"\") >> and now a threaded interrupt handler will handle soft interrupts at its >> end even if ksoftirqd is pending. That means that they will be processed >> in the context in which they were raised. > > $ git describe --contains d15121be74856 > v6.5-rc1~232^2~4 > > That revert basically removes the \"overload\" protection that was added > to cope with DDoS situations in Aug 2016 (Cc. Cloudflare). As described > in https://git.kernel.org/torvalds/c/4cd13c21b207 (\"softirq: Let > ksoftirqd do its job\") in UDP overload situations when UDP socket > receiver runs on same CPU as ksoftirqd it \"falls-off-an-edge\" and almost > doesn't process packets (because softirq steals CPU/sched time from UDP > pid). Warning Cloudflare (Cc) as this might affect their production > use-cases, and I recommend getting involved to evaluate the effect of > these changes. > I did some testing on net-next (with commit d15121be74856 (\"Revert \"softirq: Let ksoftirqd do its job\"\") using UDP pktgen + udp_sink. And I observe the old overload issue occur again, where userspace process (udp_sink) process very few packets when running on *same* CPU as the NAPI-RX/IRQ processing. The perf report \"comm\" clearly shows that NAPI runs in the context of the \"udp_sink\" process, stealing its sched time. (Same CPU around 3Kpps and diff CPU 1722Kpps, see details below). What happens are that NAPI takes 64 packets and queue them to the udp_sink process *socket*, the udp_sink process *wakeup* process 1 packet from socket queue and on exit (__local_bh_enable_ip) runs softirq that starts NAPI (to again process 64 packets... repeat). > I do realize/acknowledge that the reverted patch caused other latency > issues, given it was a \"big-hammer\" approach affecting other softirq > processing (as can be seen by e.g. the watchdog fixes patches). > Thus, the revert makes sense, but how to regain the \"overload\" > protection such that RX networking cannot starve processes reading from > the socket? (is this what Sebastian's patchset does?) > I'm no expert in sched / softirq area of the kernel, but I'm willing to help out testing different solution that can regain the \"overload\" protection e.g. avoid packet processing \"falls-of-an-edge\" (and thus opens the kernel to be DDoS'ed easily). Is this what Sebastian's patchset does? > > Thread link for people Cc'ed: > https://lore.kernel.org/all/20230814093528.117342-1-bigeasy@linutronix.de/#r --Jesper (some testlab results below) [udp_sink] https://github.com/netoptimizer/network-testing/blob/master/src/udp_sink.c When udp_sink runs on same CPU and NAPI/softirq - UdpInDatagrams: 2,948 packets/sec $ nstat -n && sleep 1 && nstat #kernel IpInReceives 2831056 0.0 IpInDelivers 2831053 0.0 UdpInDatagrams 2948 0.0 UdpInErrors 2828118 0.0 UdpRcvbufErrors 2828118 0.0 IpExtInOctets 130206496 0.0 IpExtInNoECTPkts 2830576 0.0 When udp_sink runs on another CPU than NAPI-RX. - UdpInDatagrams: 1,722,307 pps $ nstat -n && sleep 1 && nstat #kernel IpInReceives 2318560 0.0 IpInDelivers 2318562 0.0 UdpInDatagrams 1722307 0.0 UdpInErrors 596280 0.0 UdpRcvbufErrors 596280 0.0 IpExtInOctets 106634256 0.0 IpExtInNoECTPkts 2318136 0.0 ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush(). 2023-08-16 14:48 ` Jesper Dangaard Brouer @ 2023-08-16 15:15 ` Yan Zhai 2023-08-16 21:02 ` Jesper Dangaard Brouer 2023-08-16 15:22 ` Sebastian Andrzej Siewior 1 sibling, 1 reply; 26+ messages in thread From: Yan Zhai @ 2023-08-16 15:15 UTC (permalink / raw To: Jesper Dangaard Brouer Cc: Sebastian Andrzej Siewior, netdev, Paolo Abeni, David S. Miller, Eric Dumazet, Jakub Kicinski, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, linux-kernel, kernel-team On Wed, Aug 16, 2023 at 9:49 AM Jesper Dangaard Brouer <hawk@kernel.org> wrote: > > > > On 15/08/2023 14.08, Jesper Dangaard Brouer wrote: > > > > > > On 14/08/2023 11.35, Sebastian Andrzej Siewior wrote: > >> This is an undesired situation and it has been attempted to avoid the > >> situation in which ksoftirqd becomes scheduled. This changed since > >> commit d15121be74856 (\"Revert \"softirq: Let ksoftirqd do its job\"\") > >> and now a threaded interrupt handler will handle soft interrupts at its > >> end even if ksoftirqd is pending. That means that they will be processed > >> in the context in which they were raised. > > > > $ git describe --contains d15121be74856 > > v6.5-rc1~232^2~4 > > > > That revert basically removes the \"overload\" protection that was added > > to cope with DDoS situations in Aug 2016 (Cc. Cloudflare). As described > > in https://git.kernel.org/torvalds/c/4cd13c21b207 (\"softirq: Let > > ksoftirqd do its job\") in UDP overload situations when UDP socket > > receiver runs on same CPU as ksoftirqd it \"falls-off-an-edge\" and almost > > doesn't process packets (because softirq steals CPU/sched time from UDP > > pid). Warning Cloudflare (Cc) as this might affect their production > > use-cases, and I recommend getting involved to evaluate the effect of > > these changes. > > > > I did some testing on net-next (with commit d15121be74856 (\"Revert > \"softirq: Let ksoftirqd do its job\"\") using UDP pktgen + udp_sink. > > And I observe the old overload issue occur again, where userspace > process (udp_sink) process very few packets when running on *same* CPU > as the NAPI-RX/IRQ processing. The perf report \"comm\" clearly shows > that NAPI runs in the context of the \"udp_sink\" process, stealing its > sched time. (Same CPU around 3Kpps and diff CPU 1722Kpps, see details > below). > What happens are that NAPI takes 64 packets and queue them to the > udp_sink process *socket*, the udp_sink process *wakeup* process 1 > packet from socket queue and on exit (__local_bh_enable_ip) runs softirq > that starts NAPI (to again process 64 packets... repeat). > I think there are two scenarios to consider: 1. Actual DoS scenario. In this case, we would drop DoS packets through XDP, which might actually relieve the stress. According to Marek's blog XDP can indeed drop 10M pps [1] so it might not steal too much time. This is also something I would like to validate again since I cannot tell if those tests were performed before or after the reverted commit. 2. Legit elephant flows (so it should not be just dropped). This one is closer to what you tested above, and it is a much harder issue since packets are legit and should not be dropped early at XDP. Let the scheduler move affected processes away seems to be the non-optimal but straight answer for now. However, I suspect this would impose an overload issue for those programmed with RFS or ARFS, since flows would \"follow\" the processes. They probably have to force threaded NAPI for tuning. [1] https://blog.cloudflare.com/how-to-drop-10-million-packets/ > > > I do realize/acknowledge that the reverted patch caused other latency > > issues, given it was a \"big-hammer\" approach affecting other softirq > > processing (as can be seen by e.g. the watchdog fixes patches). > > Thus, the revert makes sense, but how to regain the \"overload\" > > protection such that RX networking cannot starve processes reading from > > the socket? (is this what Sebastian's patchset does?) > > > > I'm no expert in sched / softirq area of the kernel, but I'm willing to > help out testing different solution that can regain the \"overload\" > protection e.g. avoid packet processing \"falls-of-an-edge\" (and thus > opens the kernel to be DDoS'ed easily). > Is this what Sebastian's patchset does? > > > > > > Thread link for people Cc'ed: > > https://lore.kernel.org/all/20230814093528.117342-1-bigeasy@linutronix.de/#r > > --Jesper > (some testlab results below) > > [udp_sink] > https://github.com/netoptimizer/network-testing/blob/master/src/udp_sink.c > > > When udp_sink runs on same CPU and NAPI/softirq > - UdpInDatagrams: 2,948 packets/sec > > $ nstat -n && sleep 1 && nstat > #kernel > IpInReceives 2831056 0.0 > IpInDelivers 2831053 0.0 > UdpInDatagrams 2948 0.0 > UdpInErrors 2828118 0.0 > UdpRcvbufErrors 2828118 0.0 > IpExtInOctets 130206496 0.0 > IpExtInNoECTPkts 2830576 0.0 > > When udp_sink runs on another CPU than NAPI-RX. > - UdpInDatagrams: 1,722,307 pps > > $ nstat -n && sleep 1 && nstat > #kernel > IpInReceives 2318560 0.0 > IpInDelivers 2318562 0.0 > UdpInDatagrams 1722307 0.0 > UdpInErrors 596280 0.0 > UdpRcvbufErrors 596280 0.0 > IpExtInOctets 106634256 0.0 > IpExtInNoECTPkts 2318136 0.0 > > -- Yan ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush(). 2023-08-16 14:48 ` Jesper Dangaard Brouer 2023-08-16 15:15 ` Yan Zhai @ 2023-08-16 15:22 ` Sebastian Andrzej Siewior 1 sibling, 0 replies; 26+ messages in thread From: Sebastian Andrzej Siewior @ 2023-08-16 15:22 UTC (permalink / raw To: Jesper Dangaard Brouer Cc: netdev, Paolo Abeni, David S. Miller, Eric Dumazet, Jakub Kicinski, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, linux-kernel, kernel-team, Yan Zhai On 2023-08-16 16:48:56 [+0200], Jesper Dangaard Brouer wrote: > I'm no expert in sched / softirq area of the kernel, but I'm willing to help > out testing different solution that can regain the \"overload\" protection > e.g. avoid packet processing \"falls-of-an-edge\" (and thus opens the kernel > to be DDoS'ed easily). > Is this what Sebastian's patchset does? I was going to respond but didn't know what so far. Can you figure out if you are using backlog or not. If you do, could try my patch. If not could you try to enable napi-thread and see? Either way I will re-read it again. Sebastian ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush(). 2023-08-16 15:15 ` Yan Zhai @ 2023-08-16 21:02 ` Jesper Dangaard Brouer 2023-08-18 15:49 ` Yan Zhai 0 siblings, 1 reply; 26+ messages in thread From: Jesper Dangaard Brouer @ 2023-08-16 21:02 UTC (permalink / raw To: Yan Zhai, Jesper Dangaard Brouer Cc: brouer, Sebastian Andrzej Siewior, netdev, Paolo Abeni, David S. Miller, Eric Dumazet, Jakub Kicinski, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, linux-kernel, kernel-team On 16/08/2023 17.15, Yan Zhai wrote: > On Wed, Aug 16, 2023 at 9:49 AM Jesper Dangaard Brouer <hawk@kernel.org> wrote: >> >> On 15/08/2023 14.08, Jesper Dangaard Brouer wrote: >>> >>> >>> On 14/08/2023 11.35, Sebastian Andrzej Siewior wrote: >>>> This is an undesired situation and it has been attempted to avoid the >>>> situation in which ksoftirqd becomes scheduled. This changed since >>>> commit d15121be74856 (\"Revert \"softirq: Let ksoftirqd do its job\"\") >>>> and now a threaded interrupt handler will handle soft interrupts at its >>>> end even if ksoftirqd is pending. That means that they will be processed >>>> in the context in which they were raised. >>> >>> $ git describe --contains d15121be74856 >>> v6.5-rc1~232^2~4 >>> >>> That revert basically removes the \"overload\" protection that was added >>> to cope with DDoS situations in Aug 2016 (Cc. Cloudflare). As described >>> in https://git.kernel.org/torvalds/c/4cd13c21b207 (\"softirq: Let >>> ksoftirqd do its job\") in UDP overload situations when UDP socket >>> receiver runs on same CPU as ksoftirqd it \"falls-off-an-edge\" and almost >>> doesn't process packets (because softirq steals CPU/sched time from UDP >>> pid). Warning Cloudflare (Cc) as this might affect their production >>> use-cases, and I recommend getting involved to evaluate the effect of >>> these changes. >>> >> >> I did some testing on net-next (with commit d15121be74856 (\"Revert >> \"softirq: Let ksoftirqd do its job\"\") using UDP pktgen + udp_sink. >> >> And I observe the old overload issue occur again, where userspace >> process (udp_sink) process very few packets when running on *same* CPU >> as the NAPI-RX/IRQ processing. The perf report \"comm\" clearly shows >> that NAPI runs in the context of the \"udp_sink\" process, stealing its >> sched time. (Same CPU around 3Kpps and diff CPU 1722Kpps, see details >> below). >> What happens are that NAPI takes 64 packets and queue them to the >> udp_sink process *socket*, the udp_sink process *wakeup* process 1 >> packet from socket queue and on exit (__local_bh_enable_ip) runs softirq >> that starts NAPI (to again process 64 packets... repeat). >> > I think there are two scenarios to consider: > > 1. Actual DoS scenario. In this case, we would drop DoS packets > through XDP, which might actually relieve the stress. According to > Marek's blog XDP can indeed drop 10M pps [1] so it might not steal too > much time. This is also something I would like to validate again since Yes, using XDP to drop packet will/should relieve the stress, as it basically can discard some of the 64 packets processed by NAPI vs the 1 packet received by userspace (that re-trigger NAPI), giving a better balance. > I cannot tell if those tests were performed before or after the > reverted commit. Marek's tests will likely contain the patch 4cd13c21b207 (\"softirq: Let ksoftirqd do its job\") as blog is from 2018 and patch from 2016, but shouldn't matter much. > 2. Legit elephant flows (so it should not be just dropped). This one > is closer to what you tested above, and it is a much harder issue > since packets are legit and should not be dropped early at XDP. Let > the scheduler move affected processes away seems to be the non-optimal > but straight answer for now. However, I suspect this would impose an > overload issue for those programmed with RFS or ARFS, since flows > would \"follow\" the processes. They probably have to force threaded > NAPI for tuning. > True, this is the case I don't know how to solve. For UDP packets it is NOT optimal to let the process \"follow\"/run on the NAPI-RX CPU. For TCP traffic it is faster to run on same CPU, which could be related to GRO effect, or simply that tcp_recvmsg gets a stream of data (before it invokes __local_bh_enable_ip causing do_softirq). I have also tested with netperf UDP packets[2] in a scenario that doesn't cause \"overload\" and CPU have idle cycles. When UDP-netserver is running on same CPU as NAPI then I see approx 38% (82020/216362) UdpRcvbufErrors [3] (and separate CPUs 2.8%). Sure, I could increase buffer size, but the point is NAPI can enqueue 64 packet and UDP receiver dequeue 1 packet. This reminded me that kernel have a recvmmsg (extra \"m\") syscall for multiple packets. I tested this (as udop_sink have support), but no luck. This is because internally in the kernel (do_recvmmsg) is just a loop over ___sys_recvmsg/__skb_recv_udp, which have a BH-spinlock per packet that invokes __local_bh_enable_ip/do_softirq. I guess, we/netdev could fix recvmmsg() to bulk-dequeue from socket queue (BH-socket unlock is triggering __local_bh_enable_ip/do_softirq) and then have a solution for UDP(?). [2] netperf -H 198.18.1.1 -D1 -l 1200 -t UDP_STREAM -T 0,0 -- -m 1472 -N -n [3] $ nstat -n && sleep 1 && nstat #kernel IpInReceives 216362 0.0 IpInDelivers 216354 0.0 UdpInDatagrams 134356 0.0 UdpInErrors 82020 0.0 UdpRcvbufErrors 82020 0.0 IpExtInOctets 324600000 0.0 IpExtInNoECTPkts 216400 0.0 > [1] https://blog.cloudflare.com/how-to-drop-10-million-packets/ > >> >>> I do realize/acknowledge that the reverted patch caused other latency >>> issues, given it was a \"big-hammer\" approach affecting other softirq >>> processing (as can be seen by e.g. the watchdog fixes patches). >>> Thus, the revert makes sense, but how to regain the \"overload\" >>> protection such that RX networking cannot starve processes reading from >>> the socket? (is this what Sebastian's patchset does?) >>> >> >> I'm no expert in sched / softirq area of the kernel, but I'm willing to >> help out testing different solution that can regain the \"overload\" >> protection e.g. avoid packet processing \"falls-of-an-edge\" (and thus >> opens the kernel to be DDoS'ed easily). >> Is this what Sebastian's patchset does? >> >> >>> >>> Thread link for people Cc'ed: >>> https://lore.kernel.org/all/20230814093528.117342-1-bigeasy@linutronix.de/#r >> >> --Jesper >> (some testlab results below) >> >> [udp_sink] >> https://github.com/netoptimizer/network-testing/blob/master/src/udp_sink.c >> >> >> When udp_sink runs on same CPU and NAPI/softirq >> - UdpInDatagrams: 2,948 packets/sec >> >> $ nstat -n && sleep 1 && nstat >> #kernel >> IpInReceives 2831056 0.0 >> IpInDelivers 2831053 0.0 >> UdpInDatagrams 2948 0.0 >> UdpInErrors 2828118 0.0 >> UdpRcvbufErrors 2828118 0.0 >> IpExtInOctets 130206496 0.0 >> IpExtInNoECTPkts 2830576 0.0 >> >> When udp_sink runs on another CPU than NAPI-RX. >> - UdpInDatagrams: 1,722,307 pps >> >> $ nstat -n && sleep 1 && nstat >> #kernel >> IpInReceives 2318560 0.0 >> IpInDelivers 2318562 0.0 >> UdpInDatagrams 1722307 0.0 >> UdpInErrors 596280 0.0 >> UdpRcvbufErrors 596280 0.0 >> IpExtInOctets 106634256 0.0 >> IpExtInNoECTPkts 2318136 0.0 >> >> > > ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI. 2023-08-14 18:24 ` [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI Jakub Kicinski @ 2023-08-17 13:16 ` Sebastian Andrzej Siewior 2023-08-17 15:30 ` Jakub Kicinski 2023-08-18 14:43 ` Yan Zhai 0 siblings, 2 replies; 26+ messages in thread From: Sebastian Andrzej Siewior @ 2023-08-17 13:16 UTC (permalink / raw To: Jakub Kicinski Cc: linux-kernel, netdev, David S. Miller, Eric Dumazet, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Yan Zhai, Jesper Dangaard Brouer On 2023-08-14 11:24:21 [-0700], Jakub Kicinski wrote: > On Mon, 14 Aug 2023 11:35:26 +0200 Sebastian Andrzej Siewior wrote: > > The RPS code and \"deferred skb free\" both send IPI/ function call > > to a remote CPU in which a softirq is raised. This leads to a warning on > > PREEMPT_RT because raising softiqrs from function call led to undesired > > behaviour in the past. I had duct tape in RT for the \"deferred skb free\" > > and Wander Lairson Costa reported the RPS case. > > Could you find a less invasive solution? > backlog is used by veth == most containerized environments. > This change has a very high risk of regression for a lot of people. Looking at the cloudflare ppl here in the thread, I doubt they use backlog but have proper NAPI so they might not need this. There is no threaded NAPI for backlog and RPS. This was suggested as the mitigation for the highload/ DoS case. Can this become a problem or - backlog is used only by old drivers so they can move to proper NAPI if it becomes a problem. - RPS spreads the load across multiple CPUs so it unlikely to become a problem. Making this either optional in general or mandatory for threaded interrupts or PREEMPT_RT will probably not make the maintenance of this code any simpler. I've been looking at veth. In the xdp case it has its own NAPI instance. In the non-xdp it uses backlog. This should be called from ndo_start_xmit and user's write() so BH is off and interrupts are enabled at this point and it should be kind of rate-limited. Couldn't we bypass backlog in this case and deliver the packet directly to the stack? Sebastian ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI. 2023-08-17 13:16 ` Sebastian Andrzej Siewior @ 2023-08-17 15:30 ` Jakub Kicinski 2023-08-18 9:03 ` Sebastian Andrzej Siewior 2023-08-18 14:43 ` Yan Zhai 1 sibling, 1 reply; 26+ messages in thread From: Jakub Kicinski @ 2023-08-17 15:30 UTC (permalink / raw To: Sebastian Andrzej Siewior Cc: linux-kernel, netdev, David S. Miller, Eric Dumazet, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Yan Zhai, Jesper Dangaard Brouer, Daniel Borkmann, Martin KaFai Lau On Thu, 17 Aug 2023 15:16:12 +0200 Sebastian Andrzej Siewior wrote: > I've been looking at veth. In the xdp case it has its own NAPI instance. > In the non-xdp it uses backlog. This should be called from > ndo_start_xmit and user's write() so BH is off and interrupts are > enabled at this point and it should be kind of rate-limited. Couldn't we > bypass backlog in this case and deliver the packet directly to the > stack? The backlog in veth eats measurable percentage points of RPS of real workloads, and I think number of people looked at getting rid of it. So worthy goal for sure, but may not be a trivial fix. To my knowledge the two main problems are: - we don't want to charge the sending application the processing for both \"sides\" of the connection and all the switching costs. - we may get an AA deadlock if the packet ends up looping in any way. Or at least that's what I remember the problem being at 8am in the morning :) Adding Daniel and Martin to CC, Paolo would also know this better than me but I think he's AFK for the rest of the week. ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI. 2023-08-17 15:30 ` Jakub Kicinski @ 2023-08-18 9:03 ` Sebastian Andrzej Siewior 0 siblings, 0 replies; 26+ messages in thread From: Sebastian Andrzej Siewior @ 2023-08-18 9:03 UTC (permalink / raw To: Jakub Kicinski Cc: linux-kernel, netdev, David S. Miller, Eric Dumazet, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Yan Zhai, Jesper Dangaard Brouer, Daniel Borkmann, Martin KaFai Lau On 2023-08-17 08:30:25 [-0700], Jakub Kicinski wrote: > On Thu, 17 Aug 2023 15:16:12 +0200 Sebastian Andrzej Siewior wrote: > > I've been looking at veth. In the xdp case it has its own NAPI instance. > > In the non-xdp it uses backlog. This should be called from > > ndo_start_xmit and user's write() so BH is off and interrupts are > > enabled at this point and it should be kind of rate-limited. Couldn't we > > bypass backlog in this case and deliver the packet directly to the > > stack? > > The backlog in veth eats measurable percentage points of RPS of real > workloads, and I think number of people looked at getting rid of it. > So worthy goal for sure, but may not be a trivial fix. We could separate RPS from backlog but then we still process RPS after backlog so not sure if this gains anything. Letting veth always use its NAPI in this case would probably do that. Not sure if it helps… > To my knowledge the two main problems are: > - we don't want to charge the sending application the processing for > both \"sides\" of the connection and all the switching costs. The packet is injected by the user and softirq is served once BH gets back to 0. So it is served within the task's context and might be accounted on softirq/ system (might as I think it needs to be observed by the timer interrupt for the accounting). > - we may get an AA deadlock if the packet ends up looping in any way. Right, forgot about that one. > Or at least that's what I remember the problem being at 8am in the > morning :) Adding Daniel and Martin to CC, Paolo would also know this > better than me but I think he's AFK for the rest of the week. Sebastian ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI. 2023-08-17 13:16 ` Sebastian Andrzej Siewior 2023-08-17 15:30 ` Jakub Kicinski @ 2023-08-18 14:43 ` Yan Zhai 2023-08-18 14:57 ` Sebastian Andrzej Siewior 1 sibling, 1 reply; 26+ messages in thread From: Yan Zhai @ 2023-08-18 14:43 UTC (permalink / raw To: Sebastian Andrzej Siewior Cc: Jakub Kicinski, linux-kernel, netdev, David S. Miller, Eric Dumazet, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Jesper Dangaard Brouer On Thu, Aug 17, 2023 at 8:16 AM Sebastian Andrzej Siewior <bigeasy@linutronix.de> wrote: > > On 2023-08-14 11:24:21 [-0700], Jakub Kicinski wrote: > > On Mon, 14 Aug 2023 11:35:26 +0200 Sebastian Andrzej Siewior wrote: > > > The RPS code and \"deferred skb free\" both send IPI/ function call > > > to a remote CPU in which a softirq is raised. This leads to a warning on > > > PREEMPT_RT because raising softiqrs from function call led to undesired > > > behaviour in the past. I had duct tape in RT for the \"deferred skb free\" > > > and Wander Lairson Costa reported the RPS case. > > > > Could you find a less invasive solution? > > backlog is used by veth == most containerized environments. > > This change has a very high risk of regression for a lot of people. > > Looking at the cloudflare ppl here in the thread, I doubt they use > backlog but have proper NAPI so they might not need this. > Cloudflare does have backlog usage. On some veths we have to turn GRO off to cope with multi-layer encapsulation, and there is also no XDP attached on these interfaces, thus the backlog is used. There are also other usage of backlog, tuntap, loopback and bpf-redirect ingress. Frankly speaking, making a NAPI instance \"threaded\" itself is not a concern. We have threaded NAPI running on some veth for quite a while, and it performs pretty well. The concern, if any, would be the maturity of new code. I am happy to help derisk with some lab tests and dogfooding if generic agreement is reached to proceed with this idea. Yan > There is no threaded NAPI for backlog and RPS. This was suggested as the > mitigation for the highload/ DoS case. Can this become a problem or > - backlog is used only by old drivers so they can move to proper NAPI if > it becomes a problem. > - RPS spreads the load across multiple CPUs so it unlikely to become a > problem. > > Making this either optional in general or mandatory for threaded > interrupts or PREEMPT_RT will probably not make the maintenance of this > code any simpler. > > I've been looking at veth. In the xdp case it has its own NAPI instance. > In the non-xdp it uses backlog. This should be called from > ndo_start_xmit and user's write() so BH is off and interrupts are > enabled at this point and it should be kind of rate-limited. Couldn't we > bypass backlog in this case and deliver the packet directly to the > stack? > > Sebastian -- Yan ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI. 2023-08-18 14:43 ` Yan Zhai @ 2023-08-18 14:57 ` Sebastian Andrzej Siewior 2023-08-18 16:21 ` Jakub Kicinski 2023-08-18 16:56 ` Yan Zhai 0 siblings, 2 replies; 26+ messages in thread From: Sebastian Andrzej Siewior @ 2023-08-18 14:57 UTC (permalink / raw To: Yan Zhai Cc: Jakub Kicinski, linux-kernel, netdev, David S. Miller, Eric Dumazet, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Jesper Dangaard Brouer On 2023-08-18 09:43:08 [-0500], Yan Zhai wrote: > > Looking at the cloudflare ppl here in the thread, I doubt they use > > backlog but have proper NAPI so they might not need this. > > > Cloudflare does have backlog usage. On some veths we have to turn GRO Oh. Okay. > off to cope with multi-layer encapsulation, and there is also no XDP > attached on these interfaces, thus the backlog is used. There are also > other usage of backlog, tuntap, loopback and bpf-redirect ingress. > Frankly speaking, making a NAPI instance \"threaded\" itself is not a > concern. We have threaded NAPI running on some veth for quite a while, > and it performs pretty well. The concern, if any, would be the > maturity of new code. I am happy to help derisk with some lab tests > and dogfooding if generic agreement is reached to proceed with this > idea. If you have threaded NAPI for veth then you wouldn't be affected by this code. However, if you _are_ affected by this and you use veth it would be helpful to figure out if you have problems as of net-next and if this helps or makes it worse. As of now Jakub isn't eager to have it and my testing/ convincing is quite limited. If nobody else yells that something like that would be helpful I would simply go and convince PeterZ/tglx to apply 2/2 of this series. > Yan Sebastian ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH 2/2] softirq: Drop the warning from do_softirq_post_smp_call_flush(). 2023-08-16 21:02 ` Jesper Dangaard Brouer @ 2023-08-18 15:49 ` Yan Zhai 0 siblings, 0 replies; 26+ messages in thread From: Yan Zhai @ 2023-08-18 15:49 UTC (permalink / raw To: Jesper Dangaard Brouer Cc: Jesper Dangaard Brouer, brouer, Sebastian Andrzej Siewior, netdev, Paolo Abeni, David S. Miller, Eric Dumazet, Jakub Kicinski, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, linux-kernel, kernel-team On Wed, Aug 16, 2023 at 4:02 PM Jesper Dangaard Brouer <jbrouer@redhat.com> wrote: > > > > On 16/08/2023 17.15, Yan Zhai wrote: > > On Wed, Aug 16, 2023 at 9:49 AM Jesper Dangaard Brouer <hawk@kernel.org> wrote: > >> > >> On 15/08/2023 14.08, Jesper Dangaard Brouer wrote: > >>> > >>> > >>> On 14/08/2023 11.35, Sebastian Andrzej Siewior wrote: > >>>> This is an undesired situation and it has been attempted to avoid the > >>>> situation in which ksoftirqd becomes scheduled. This changed since > >>>> commit d15121be74856 (\"Revert \"softirq: Let ksoftirqd do its job\"\") > >>>> and now a threaded interrupt handler will handle soft interrupts at its > >>>> end even if ksoftirqd is pending. That means that they will be processed > >>>> in the context in which they were raised. > >>> > >>> $ git describe --contains d15121be74856 > >>> v6.5-rc1~232^2~4 > >>> > >>> That revert basically removes the \"overload\" protection that was added > >>> to cope with DDoS situations in Aug 2016 (Cc. Cloudflare). As described > >>> in https://git.kernel.org/torvalds/c/4cd13c21b207 (\"softirq: Let > >>> ksoftirqd do its job\") in UDP overload situations when UDP socket > >>> receiver runs on same CPU as ksoftirqd it \"falls-off-an-edge\" and almost > >>> doesn't process packets (because softirq steals CPU/sched time from UDP > >>> pid). Warning Cloudflare (Cc) as this might affect their production > >>> use-cases, and I recommend getting involved to evaluate the effect of > >>> these changes. > >>> > >> > >> I did some testing on net-next (with commit d15121be74856 (\"Revert > >> \"softirq: Let ksoftirqd do its job\"\") using UDP pktgen + udp_sink. > >> > >> And I observe the old overload issue occur again, where userspace > >> process (udp_sink) process very few packets when running on *same* CPU > >> as the NAPI-RX/IRQ processing. The perf report \"comm\" clearly shows > >> that NAPI runs in the context of the \"udp_sink\" process, stealing its > >> sched time. (Same CPU around 3Kpps and diff CPU 1722Kpps, see details > >> below). > >> What happens are that NAPI takes 64 packets and queue them to the > >> udp_sink process *socket*, the udp_sink process *wakeup* process 1 > >> packet from socket queue and on exit (__local_bh_enable_ip) runs softirq > >> that starts NAPI (to again process 64 packets... repeat). > >> > > I think there are two scenarios to consider: > > > > 1. Actual DoS scenario. In this case, we would drop DoS packets > > through XDP, which might actually relieve the stress. According to > > Marek's blog XDP can indeed drop 10M pps [1] so it might not steal too > > much time. This is also something I would like to validate again since > > Yes, using XDP to drop packet will/should relieve the stress, as it > basically can discard some of the 64 packets processed by NAPI vs the 1 > packet received by userspace (that re-trigger NAPI), giving a better > balance. > > > I cannot tell if those tests were performed before or after the > > reverted commit. > > Marek's tests will likely contain the patch 4cd13c21b207 (\"softirq: Let > ksoftirqd do its job\") as blog is from 2018 and patch from 2016, but > shouldn't matter much. > > > > 2. Legit elephant flows (so it should not be just dropped). This one > > is closer to what you tested above, and it is a much harder issue > > since packets are legit and should not be dropped early at XDP. Let > > the scheduler move affected processes away seems to be the non-optimal > > but straight answer for now. However, I suspect this would impose an > > overload issue for those programmed with RFS or ARFS, since flows > > would \"follow\" the processes. They probably have to force threaded > > NAPI for tuning. > > > > True, this is the case I don't know how to solve. > > For UDP packets it is NOT optimal to let the process \"follow\"/run on the > NAPI-RX CPU. For TCP traffic it is faster to run on same CPU, which > could be related to GRO effect, or simply that tcp_recvmsg gets a stream > of data (before it invokes __local_bh_enable_ip causing do_softirq). > To maximize single flow throughput, it is not optimal to run RX on the same CPU with the receiver, regardless of TCP or UDP. The difference is that TCP does not have tput issue until 10+ Gbps thanks to GRO. In some internal benchmarking effort, I found that pinning iperf server on the same RX would yield ~13-14 Gbps TCP while running on different cores would have 25G NIC saturated (for both same or different NUMA case). Despite single flow throughput upper bound getting hit when running on the same core, CPU cycles to process each packet is actually reduced. So it is likely more friendly to the production environment we are dealing with where there are a lot more smaller flows. It is something I planned to test more (in the past we had major services pinned on dedicated cores, but recently we start to unpin to improve tail latency of other services). But with the protection gone, it adds quite some uncertainty to the picture. > I have also tested with netperf UDP packets[2] in a scenario that > doesn't cause \"overload\" and CPU have idle cycles. When UDP-netserver > is running on same CPU as NAPI then I see approx 38% (82020/216362) > UdpRcvbufErrors [3] (and separate CPUs 2.8%). Sure, I could increase > buffer size, but the point is NAPI can enqueue 64 packet and UDP > receiver dequeue 1 packet. > > This reminded me that kernel have a recvmmsg (extra \"m\") syscall for > multiple packets. I tested this (as udop_sink have support), but no > luck. This is because internally in the kernel (do_recvmmsg) is just a > loop over ___sys_recvmsg/__skb_recv_udp, which have a BH-spinlock per > packet that invokes __local_bh_enable_ip/do_softirq. I guess, we/netdev > could fix recvmmsg() to bulk-dequeue from socket queue (BH-socket unlock > is triggering __local_bh_enable_ip/do_softirq) and then have a solution > for UDP(?). > recvmmsg does help getting more packets in a batch, but it has an issue of buffer allocation upfront: when there are millions of connections, preallocate too many buffers can mount up memory pressure a lot. On an alternative view, enable UDP GRO seems a direct help in this context, to bring UDP on par with TCP, and reduce the RX overhead. We already have quite some UDP GRO/GSO use cases for virtual machines and QUIC handling, time to persuade engineers to add more maybe. Yan > > [2] netperf -H 198.18.1.1 -D1 -l 1200 -t UDP_STREAM -T 0,0 -- -m 1472 -N -n > > [3] > $ nstat -n && sleep 1 && nstat > #kernel > IpInReceives 216362 0.0 > IpInDelivers 216354 0.0 > UdpInDatagrams 134356 0.0 > UdpInErrors 82020 0.0 > UdpRcvbufErrors 82020 0.0 > IpExtInOctets 324600000 0.0 > IpExtInNoECTPkts 216400 0.0 > > > > [1] https://blog.cloudflare.com/how-to-drop-10-million-packets/ > > > >> > >>> I do realize/acknowledge that the reverted patch caused other latency > >>> issues, given it was a \"big-hammer\" approach affecting other softirq > >>> processing (as can be seen by e.g. the watchdog fixes patches). > >>> Thus, the revert makes sense, but how to regain the \"overload\" > >>> protection such that RX networking cannot starve processes reading from > >>> the socket? (is this what Sebastian's patchset does?) > >>> > >> > >> I'm no expert in sched / softirq area of the kernel, but I'm willing to > >> help out testing different solution that can regain the \"overload\" > >> protection e.g. avoid packet processing \"falls-of-an-edge\" (and thus > >> opens the kernel to be DDoS'ed easily). > >> Is this what Sebastian's patchset does? > >> > >> > >>> > >>> Thread link for people Cc'ed: > >>> https://lore.kernel.org/all/20230814093528.117342-1-bigeasy@linutronix.de/#r > >> > >> --Jesper > >> (some testlab results below) > >> > >> [udp_sink] > >> https://github.com/netoptimizer/network-testing/blob/master/src/udp_sink.c > >> > >> > >> When udp_sink runs on same CPU and NAPI/softirq > >> - UdpInDatagrams: 2,948 packets/sec > >> > >> $ nstat -n && sleep 1 && nstat > >> #kernel > >> IpInReceives 2831056 0.0 > >> IpInDelivers 2831053 0.0 > >> UdpInDatagrams 2948 0.0 > >> UdpInErrors 2828118 0.0 > >> UdpRcvbufErrors 2828118 0.0 > >> IpExtInOctets 130206496 0.0 > >> IpExtInNoECTPkts 2830576 0.0 > >> > >> When udp_sink runs on another CPU than NAPI-RX. > >> - UdpInDatagrams: 1,722,307 pps > >> > >> $ nstat -n && sleep 1 && nstat > >> #kernel > >> IpInReceives 2318560 0.0 > >> IpInDelivers 2318562 0.0 > >> UdpInDatagrams 1722307 0.0 > >> UdpInErrors 596280 0.0 > >> UdpRcvbufErrors 596280 0.0 > >> IpExtInOctets 106634256 0.0 > >> IpExtInNoECTPkts 2318136 0.0 > >> > >> > > > > > -- Yan ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI. 2023-08-18 14:57 ` Sebastian Andrzej Siewior @ 2023-08-18 16:21 ` Jakub Kicinski 2023-08-18 16:40 ` Eric Dumazet 2023-08-23 6:57 ` Sebastian Andrzej Siewior 2023-08-18 16:56 ` Yan Zhai 1 sibling, 2 replies; 26+ messages in thread From: Jakub Kicinski @ 2023-08-18 16:21 UTC (permalink / raw To: Sebastian Andrzej Siewior Cc: Yan Zhai, linux-kernel, netdev, David S. Miller, Eric Dumazet, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Jesper Dangaard Brouer On Fri, 18 Aug 2023 16:57:34 +0200 Sebastian Andrzej Siewior wrote: > As of now Jakub isn't eager to have it and my testing/ convincing is > quite limited. If nobody else yells that something like that would be > helpful I would simply go and convince PeterZ/tglx to apply 2/2 of this > series. As tempting as code removal would be, we can still try to explore the option of letting backlog processing run in threads - as an opt-in on normal kernels and force it on RT? But it would be good to wait ~2 weeks before moving forward, if you don't mind, various core folks keep taking vacations.. ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI. 2023-08-18 16:21 ` Jakub Kicinski @ 2023-08-18 16:40 ` Eric Dumazet 2023-08-23 6:57 ` Sebastian Andrzej Siewior 1 sibling, 0 replies; 26+ messages in thread From: Eric Dumazet @ 2023-08-18 16:40 UTC (permalink / raw To: Jakub Kicinski Cc: Sebastian Andrzej Siewior, Yan Zhai, linux-kernel, netdev, David S. Miller, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Jesper Dangaard Brouer On Fri, Aug 18, 2023 at 6:21 PM Jakub Kicinski <kuba@kernel.org> wrote: > > On Fri, 18 Aug 2023 16:57:34 +0200 Sebastian Andrzej Siewior wrote: > > As of now Jakub isn't eager to have it and my testing/ convincing is > > quite limited. If nobody else yells that something like that would be > > helpful I would simply go and convince PeterZ/tglx to apply 2/2 of this > > series. > > As tempting as code removal would be, we can still try to explore the > option of letting backlog processing run in threads - as an opt-in on > normal kernels and force it on RT? +1 Patch 1/2 as presented is really scary, we would need to test it extensively on various platforms. > > But it would be good to wait ~2 weeks before moving forward, if you > don't mind, various core folks keep taking vacations.. ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH net-next 0/2] net: Use SMP threads for backlog NAPI. 2023-08-18 14:57 ` Sebastian Andrzej Siewior 2023-08-18 16:21 ` Jakub Kicinski @ 2023-08-18 16:56 ` Yan Zhai 1 sibling, 0 replies; 26+ messages in thread From: Yan Zhai @ 2023-08-18 16:56 UTC (permalink / raw To: Sebastian Andrzej Siewior Cc: Jakub Kicinski, linux-kernel, netdev, David S. Miller, Eric Dumazet, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Jesper Dangaard Brouer On Fri, Aug 18, 2023 at 9:57 AM Sebastian Andrzej Siewior <bigeasy@linutronix.de> wrote: > > On 2023-08-18 09:43:08 [-0500], Yan Zhai wrote: > > > Looking at the cloudflare ppl here in the thread, I doubt they use > > > backlog but have proper NAPI so they might not need this. > > > > > Cloudflare does have backlog usage. On some veths we have to turn GRO > > Oh. Okay. > > > off to cope with multi-layer encapsulation, and there is also no XDP > > attached on these interfaces, thus the backlog is used. There are also > > other usage of backlog, tuntap, loopback and bpf-redirect ingress. > > Frankly speaking, making a NAPI instance \"threaded\" itself is not a > > concern. We have threaded NAPI running on some veth for quite a while, > > and it performs pretty well. The concern, if any, would be the > > maturity of new code. I am happy to help derisk with some lab tests > > and dogfooding if generic agreement is reached to proceed with this > > idea. > > If you have threaded NAPI for veth then you wouldn't be affected by this > code. However, if you _are_ affected by this and you use veth it would > be helpful to figure out if you have problems as of net-next and if this > helps or makes it worse. > yes we are still impacted on non-NAPI veths and other scenarios. But net-next sounds good, still plenty of time to evaluate if it has any negative impact. Yan > As of now Jakub isn't eager to have it and my testing/ convincing is > quite limited. If nobody else yells that something like that would be > helpful I would simply go and convince PeterZ/tglx to apply 2/2 of this > series. > > > Yan > > Sebastian ^ permalink raw reply [flat|nested] 26+ messages in thread* Re: [RFC PATCH net-next 1/2] net: Use SMP threads for backlog NAPI. 2023-08-14 9:35 ` [RFC PATCH net-next 1/2] \" Sebastian Andrzej Siewior @ 2023-08-21 8:32 ` kernel test robot 2023-08-23 13:35 ` Paolo Abeni 1 sibling, 0 replies; 26+ messages in thread From: kernel test robot @ 2023-08-21 8:32 UTC (permalink / raw To: Sebastian Andrzej Siewior Cc: oe-lkp, lkp, netdev, ying.huang, feng.tang, fengwei.yin, linux-kernel, David S. Miller, Eric Dumazet, Jakub Kicinski, Paolo Abeni, Peter Zijlstra, Thomas Gleixner, Wander Lairson Costa, Sebastian Andrzej Siewior, oliver.sang Hello, kernel test robot noticed a -17.5% regression of phoronix-test-suite.netperf.localhost.UDPRequestResponse.10Seconds.transaction_rate_per_second on: commit: e9dc861c8b3c291826d6cc1a8674ec0b148cd82d (\"[RFC PATCH net-next 1/2] net: Use SMP threads for backlog NAPI.\") url: https://github.com/intel-lab-lkp/linux/commits/Sebastian-Andrzej-Siewior/net-Use-SMP-threads-for-backlog-NAPI/20230814-173835 base: https://git.kernel.org/cgit/linux/kernel/git/davem/net-next.git 83b5f0253b1ef352f4333c4fb2d24eff23045f6b patch link: https://lore.kernel.org/all/20230814093528.117342-2-bigeasy@linutronix.de/ patch subject: [RFC PATCH net-next 1/2] net: Use SMP threads for backlog NAPI. testcase: phoronix-test-suite test machine: 96 threads 2 sockets Intel(R) Xeon(R) Gold 6252 CPU @ 2.10GHz (Cascade Lake) with 512G memory parameters: test: netperf-1.0.4 cpufreq_governor: performance In addition to that, the commit also has significant impact on the following tests: +------------------+-------------------------------------------------------------------------------------------------+ | testcase: change | stress-ng: stress-ng.udp.ops_per_sec -40.3% regression | | test machine | 36 threads 1 sockets Intel(R) Core(TM) i9-10980XE CPU @ 3.00GHz (Cascade Lake) with 128G memory | | test parameters | class=os | | | cpufreq_governor=performance | | | disk=1HDD | | | fs=ext4 | | | nr_threads=1 | | | test=udp | | | testtime=60s | +------------------+-------------------------------------------------------------------------------------------------+ | testcase: change | qperf: qperf.udp.send_bw -24.2% regression | | test machine | 8 threads 1 sockets Intel(R) Core(TM) i7-4770K CPU @ 3.50GHz (Haswell) with 8G memory | | test parameters | cluster=cs-localhost | | | cpufreq_governor=performance | | | runtime=600s | +------------------+-------------------------------------------------------------------------------------------------+ | testcase: change | uperf: uperf.Runstat_master_Mbps -16.5% regression | | test machine | 64 threads 2 sockets Intel(R) Xeon(R) Gold 6346 CPU @ 3.10GHz (Ice Lake) with 256G memory | | test parameters | cluster=cs-localhost | | | cpufreq_governor=performance | | | datasize=64 | | | nr_threads=1 | | | protocol=UDP | | | runtime=30s | | | winsize=32k | +------------------+-------------------------------------------------------------------------------------------------+ | testcase: change | stress-ng: stress-ng.dccp.ops_per_sec -16.0% regression | | test machine | 36 threads 1 sockets Intel(R) Core(TM) i9-10980XE CPU @ 3.00GHz (Cascade Lake) with 128G memory | | test parameters | class=os | | | cpufreq_governor=performance | | | disk=1HDD | | | fs=ext4 | | | nr_threads=1 | | | test=dccp | | | testtime=60s | +------------------+-------------------------------------------------------------------------------------------------+ If you fix the issue in a separate patch/commit (i.e. not just a new version of the same patch/commit), kindly add following tags | Reported-by: kernel test robot <oliver.sang@intel.com> | Closes: https://lore.kernel.org/oe-lkp/202308211627.8b869c6e-oliver.sang@intel.com Details are as below: --------------------------------------------------------------------------------------------------> The kernel config and materials to reproduce are available at: https://download.01.org/0day-ci/archive/20230821/202308211627.8b869c6e-oliver.sang@intel.com ========================================================================================= compiler/cpufreq_governor/kconfig/rootfs/tbox_group/test/testcase: gcc-12/performance/x86_64-rhel-8.3/debian-x86_64-phoronix/lkp-csl-2sp7/netperf-1.0.4/phoronix-test-suite commit: 83b5f0253b (\"net: phy: Introduce PSGMII PHY interface mode\") e9dc861c8b (\"net: Use SMP threads for backlog NAPI.\") 83b5f0253b1ef352 e9dc861c8b3c291826d6cc1a867 ---------------- --------------------------- %stddev %change %stddev \\ | \\ 12507317 -10.7% 11173853 cpuidle..usage 23.00 ± 14% +42.0% 32.67 ± 7% perf-c2c.DRAM.local 3.91 ±101% -2.3 1.64 ±149% perf-profile.children.cycles-pp.asm_sysvec_apic_timer_interrupt 116234 -17.5% 95851 phoronix-test-suite.netperf.localhost.UDPRequestResponse.10Seconds.transaction_rate_per_second 237948 +67.3% 398178 vmstat.system.cs 0.22 -0.1 0.10 mpstat.cpu.all.soft% 0.53 +0.1 0.63 mpstat.cpu.all.sys% 20688 +7.4% 22214 proc-vmstat.nr_kernel_stack 53103 +1.4% 53861 proc-vmstat.nr_slab_unreclaimable 1991060 ± 8% +55.7% 3100058 turbostat.C1 0.14 ± 6% +0.2 0.31 ± 4% turbostat.C1% 0.29 ± 4% +0.1 0.42 ± 3% turbostat.C1E% 5063449 ± 4% -46.3% 2720011 ± 2% turbostat.POLL 0.26 ± 4% -0.1 0.17 ± 2% turbostat.POLL% 114.60 +1.6% 116.47 turbostat.PkgWatt 48.25 ± 4% -4.8% 45.93 ± 2% perf-stat.i.MPKI 7.498e+08 ± 2% +8.2% 8.113e+08 perf-stat.i.branch-instructions 85554181 -4.4% 81810261 perf-stat.i.cache-references 255667 ± 2% +66.2% 425026 perf-stat.i.context-switches 3.23 ± 3% -4.4% 3.09 perf-stat.i.cpi 106.09 +172.8% 289.40 ± 22% perf-stat.i.cpu-migrations 3590 -7.0% 3340 ± 2% perf-stat.i.cycles-between-cache-misses 0.47 ± 5% -0.1 0.42 ± 2% perf-stat.i.dTLB-load-miss-rate% 1930027 ± 2% -11.0% 1717629 ± 3% perf-stat.i.dTLB-load-misses 9.746e+08 ± 2% +7.7% 1.05e+09 perf-stat.i.dTLB-loads 0.08 ± 7% -0.0 0.07 ± 2% perf-stat.i.dTLB-store-miss-rate% 172760 ± 4% -11.6% 152755 perf-stat.i.dTLB-store-misses 5.334e+08 +7.8% 5.749e+08 perf-stat.i.dTLB-stores 81.38 -7.8 73.60 perf-stat.i.iTLB-load-miss-rate% 4442067 ± 2% -34.2% 2922023 perf-stat.i.iTLB-load-misses 869196 ± 6% +32.5% 1151689 ± 2% perf-stat.i.iTLB-loads 3.764e+09 ± 2% +6.7% 4.014e+09 perf-stat.i.instructions 1237 ± 5% +26.3% 1563 ± 2% perf-stat.i.instructions-per-iTLB-miss 0.49 ± 2% +8.8% 0.53 perf-stat.i.ipc 23.38 ± 2% +7.9% 25.24 perf-stat.i.metric.M/sec 120711 ± 5% +29.5% 156269 ± 14% perf-stat.i.node-load-misses 22.77 ± 3% -10.4% 20.40 ± 2% perf-stat.overall.MPKI 3.25 ± 2% -0.2 3.04 perf-stat.overall.branch-miss-rate% 2.86 ± 2% +0.2 3.07 ± 3% perf-stat.overall.cache-miss-rate% 1.91 ± 2% -7.9% 1.75 perf-stat.overall.cpi 2928 ± 2% -4.2% 2804 ± 2% perf-stat.overall.cycles-between-cache-misses 0.20 ± 4% -0.0 0.16 ± 3% perf-stat.overall.dTLB-load-miss-rate% 0.03 ± 4% -0.0 0.03 perf-stat.overall.dTLB-store-miss-rate% 83.63 -11.9 71.73 perf-stat.overall.iTLB-load-miss-rate% 847.76 ± 2% +62.0% 1373 perf-stat.overall.instructions-per-iTLB-miss 0.52 +8.6% 0.57 perf-stat.overall.ipc 7.356e+08 ± 2% +8.2% 7.957e+08 perf-stat.ps.branch-instructions 84014375 -4.4% 80324771 perf-stat.ps.cache-references 250660 ± 2% +66.3% 416753 perf-stat.ps.context-switches 7.033e+09 -1.8% 6.906e+09 perf-stat.ps.cpu-cycles 104.17 +172.6% 283.93 ± 22% perf-stat.ps.cpu-migrations 1896175 ± 2% -11.0% 1687140 ± 3% perf-stat.ps.dTLB-load-misses 9.562e+08 ± 2% +7.7% 1.03e+09 perf-stat.ps.dTLB-loads 169740 ± 4% -11.6% 150033 perf-stat.ps.dTLB-store-misses 5.232e+08 +7.8% 5.639e+08 perf-stat.ps.dTLB-stores 4356522 ± 2% -34.2% 2866282 perf-stat.ps.iTLB-load-misses 852611 ± 6% +32.5% 1129564 ± 2% perf-stat.ps.iTLB-loads 3.693e+09 ± 2% +6.6% 3.937e+09 perf-stat.ps.instructions 118546 ± 5% +29.4% 153343 ± 14% perf-stat.ps.node-load-misses 2.069e+11 +5.0% 2.173e+11 perf-stat.total.instructions *************************************************************************************************** lkp-csl-d02: 36 threads 1 sockets Intel(R) Core(TM) i9-10980XE CPU @ 3.00GHz (Cascade Lake) with 128G memory ========================================================================================= class/compiler/cpufreq_governor/disk/fs/kconfig/nr_threads/rootfs/tbox_group/test/testcase/testtime: os/gcc-12/performance/1HDD/ext4/x86_64-rhel-8.3/1/debian-11.1-x86_64-20220510.cgz/lkp-csl-d02/udp/stress-ng/60s commit: 83b5f0253b (\"net: phy: Introduce PSGMII PHY interface mode\") e9dc861c8b (\"net: Use SMP threads for backlog NAPI.\") 83b5f0253b1ef352 e9dc861c8b3c291826d6cc1a867 ---------------- --------------------------- %stddev %change %stddev \\ | \\ 12790365 ± 2% +32.0% 16887592 ± 3% cpuidle..usage 4.74 -8.6% 4.33 iostat.cpu.system 17.33 ± 19% -45.2% 9.50 ± 28% perf-c2c.DRAM.local 1.15 ± 2% -1.1 0.07 mpstat.cpu.all.soft% 3.06 ± 2% +0.6 3.71 mpstat.cpu.all.sys% 0.47 ± 9% +0.1 0.55 mpstat.cpu.all.usr% 3451432 +12.0% 3864232 vmstat.memory.cache 412424 ± 3% +198.2% 1230008 vmstat.system.cs 93962 ± 6% +21.0% 113707 ± 4% vmstat.system.in 19785 ± 5% +1026.7% 222913 ± 5% turbostat.C1 0.06 ± 9% +0.1 0.12 ± 6% turbostat.C1% 6268454 ± 6% +19.8% 7509215 ± 3% turbostat.IRQ 9630603 ± 3% +40.8% 13558028 ± 4% turbostat.POLL 0.25 ± 4% +0.2 0.46 turbostat.POLL% 3347 ± 4% +6.5e+05% 21761039 stress-ng.time.involuntary_context_switches 121.33 -21.4% 95.33 stress-ng.time.percent_of_cpu_this_job_got 71.34 -22.6% 55.23 stress-ng.time.system_time 12757669 +40.4% 17909736 ± 2% stress-ng.time.voluntary_context_switches 36420509 -40.3% 21760688 stress-ng.udp.ops 607006 -40.3% 362677 stress-ng.udp.ops_per_sec 471964 +81.1% 854856 meminfo.Active 453420 +85.0% 838688 meminfo.Active(anon) 3355258 +12.2% 3764944 meminfo.Cached 1009405 +41.2% 1425669 meminfo.Committed_AS 57926 +19.5% 69211 ± 2% meminfo.Mapped 4156253 +9.9% 4569409 meminfo.Memused 502429 +82.5% 916869 meminfo.Shmem 113354 +85.0% 209672 proc-vmstat.nr_active_anon 842826 +12.2% 945267 proc-vmstat.nr_file_pages 87951 +8.9% 95743 proc-vmstat.nr_inactive_anon 8798 +6.2% 9348 proc-vmstat.nr_kernel_stack 14481 +19.5% 17312 ± 2% proc-vmstat.nr_mapped 125608 +82.5% 229221 proc-vmstat.nr_shmem 113354 +85.0% 209672 proc-vmstat.nr_zone_active_anon 87951 +8.9% 95743 proc-vmstat.nr_zone_inactive_anon 1222387 -22.1% 952448 proc-vmstat.numa_hit 1220389 -22.0% 952356 proc-vmstat.numa_local 172618 +61.8% 279233 ± 3% proc-vmstat.pgactivate 2049577 -32.9% 1375385 proc-vmstat.pgalloc_normal 228482 +10.4% 252349 proc-vmstat.pgfault 1847715 -44.3% 1029148 proc-vmstat.pgfree 0.00 ± 27% -68.8% 0.00 ± 44% perf-sched.sch_delay.avg.ms.do_task_dead.do_exit.do_group_exit.__x64_sys_exit_group.do_syscall_64 0.01 ± 41% -74.5% 0.00 perf-sched.sch_delay.avg.ms.smpboot_thread_fn.kthread.ret_from_fork.ret_from_fork_asm 0.00 -58.3% 0.00 ± 44% perf-sched.sch_delay.avg.ms.wait_for_partner.fifo_open.do_dentry_open.do_open 0.00 ±223% +900.0% 0.00 ± 33% perf-sched.sch_delay.max.ms.exit_to_user_mode_loop.exit_to_user_mode_prepare.irqentry_exit_to_user_mode.asm_exc_page_fault 0.00 ± 48% +130.4% 0.01 ± 13% perf-sched.sch_delay.max.ms.exit_to_user_mode_loop.exit_to_user_mode_prepare.irqentry_exit_to_user_mode.asm_sysvec_reschedule_ipi 0.71 ± 2% -51.3% 0.35 ± 4% perf-sched.total_wait_and_delay.average.ms 648341 +176.4% 1792232 perf-sched.total_wait_and_delay.count.ms 0.71 ± 2% -51.5% 0.35 ± 4% perf-sched.total_wait_time.average.ms 273.60 ± 7% -34.3% 179.63 ± 28% perf-sched.wait_and_delay.avg.ms.do_task_dead.do_exit.do_group_exit.__x64_sys_exit_group.do_syscall_64 49.49 -43.6% 27.89 ± 3% perf-sched.wait_and_delay.avg.ms.schedule_hrtimeout_range_clock.do_poll.constprop.0.do_sys_poll 0.00 +200.0% 0.01 perf-sched.wait_and_delay.avg.ms.schedule_timeout.__skb_wait_for_more_packets.__skb_recv_udp.udp_recvmsg 303.03 ± 4% -99.8% 0.64 ± 4% perf-sched.wait_and_delay.avg.ms.smpboot_thread_fn.kthread.ret_from_fork.ret_from_fork_asm 474.17 ± 3% +18.8% 563.18 ± 5% perf-sched.wait_and_delay.avg.ms.worker_thread.kthread.ret_from_fork.ret_from_fork_asm 1.50 ± 74% +322.2% 6.33 ± 23% perf-sched.wait_and_delay.count.__cond_resched.__alloc_pages.__folio_alloc.vma_alloc_folio.shmem_alloc_folio 2.67 ± 63% +731.2% 22.17 ± 14% perf-sched.wait_and_delay.count.__cond_resched.generic_perform_write.generic_file_write_iter.vfs_write.ksys_write 1.00 ± 81% +666.7% 7.67 ± 32% perf-sched.wait_and_delay.count.__cond_resched.mutex_lock.perf_poll.do_poll.constprop 337.67 +62.6% 549.17 ± 2% perf-sched.wait_and_delay.count.schedule_hrtimeout_range_clock.do_poll.constprop.0.do_sys_poll 734.00 ± 3% +77846.9% 572130 perf-sched.wait_and_delay.count.smpboot_thread_fn.kthread.ret_from_fork.ret_from_fork_asm 1491 ± 32% -33.0% 1000 perf-sched.wait_and_delay.max.ms.do_task_dead.do_exit.do_group_exit.__x64_sys_exit_group.do_syscall_64 0.08 ± 44% -94.7% 0.00 ± 17% perf-sched.wait_time.avg.ms.__cond_resched.aa_sk_perm.security_socket_sendmsg.sock_sendmsg.__sys_sendto 0.07 ± 28% -87.0% 0.01 ± 15% perf-sched.wait_time.avg.ms.__cond_resched.kmem_cache_alloc_node.__alloc_skb.alloc_skb_with_frags.sock_alloc_send_pskb 273.60 ± 7% -34.3% 179.63 ± 28% perf-sched.wait_time.avg.ms.do_task_dead.do_exit.do_group_exit.__x64_sys_exit_group.do_syscall_64 0.00 ±223% +15780.0% 0.13 ± 26% perf-sched.wait_time.avg.ms.exit_to_user_mode_loop.exit_to_user_mode_prepare.irqentry_exit_to_user_mode.asm_exc_page_fault 0.09 ± 42% +2947.0% 2.74 ± 19% perf-sched.wait_time.avg.ms.exit_to_user_mode_loop.exit_to_user_mode_prepare.irqentry_exit_to_user_mode.asm_sysvec_apic_timer_interrupt 0.08 ± 81% +72717.2% 56.43 ± 69% perf-sched.wait_time.avg.ms.exit_to_user_mode_loop.exit_to_user_mode_prepare.irqentry_exit_to_user_mode.asm_sysvec_reschedule_ipi 0.07 ± 30% -92.0% 0.01 ± 44% perf-sched.wait_time.avg.ms.exit_to_user_mode_loop.exit_to_user_mode_prepare.syscall_exit_to_user_mode.do_syscall_64 49.49 -43.6% 27.89 ± 3% perf-sched.wait_time.avg.ms.schedule_hrtimeout_range_clock.do_poll.constprop.0.do_sys_poll 0.00 +150.0% 0.01 perf-sched.wait_time.avg.ms.schedule_timeout.__skb_wait_for_more_packets.__skb_recv_udp.udp_recvmsg 0.32 ± 3% -34.2% 0.21 ± 14% perf-sched.wait_time.avg.ms.schedule_timeout.__wait_for_common.wait_for_completion_state.kernel_clone 303.02 ± 4% -99.8% 0.63 ± 4% perf-sched.wait_time.avg.ms.smpboot_thread_fn.kthread.ret_from_fork.ret_from_fork_asm 0.00 ±223% +1300.0% 0.00 ± 20% perf-sched.wait_time.avg.ms.wait_for_partner.fifo_open.do_dentry_open.do_open 474.16 ± 3% +18.8% 563.18 ± 5% perf-sched.wait_time.avg.ms.worker_thread.kthread.ret_from_fork.ret_from_fork_asm 0.26 ± 25% -97.0% 0.01 ± 80% perf-sched.wait_time.max.ms.__cond_resched.aa_sk_perm.security_socket_sendmsg.sock_sendmsg.__sys_sendto 0.44 ± 55% -91.1% 0.04 ± 76% perf-sched.wait_time.max.ms.__cond_resched.kmem_cache_alloc_node.__alloc_skb.alloc_skb_with_frags.sock_alloc_send_pskb 1491 ± 32% -33.0% 1000.00 perf-sched.wait_time.max.ms.do_task_dead.do_exit.do_group_exit.__x64_sys_exit_group.do_syscall_64 0.00 ±223% +73360.0% 0.61 ± 6% perf-sched.wait_time.max.ms.exit_to_user_mode_loop.exit_to_user_mode_prepare.irqentry_exit_to_user_mode.asm_exc_page_fault 0.28 ± 35% +6429.9% 18.23 ± 14% perf-sched.wait_time.max.ms.exit_to_user_mode_loop.exit_to_user_mode_prepare.irqentry_exit_to_user_mode.asm_sysvec_apic_timer_interrupt 0.24 ±113% +4.2e+05% 1000 perf-sched.wait_time.max.ms.exit_to_user_mode_loop.exit_to_user_mode_prepare.irqentry_exit_to_user_mode.asm_sysvec_reschedule_ipi 3.43 ±180% +19504.1% 672.98 ± 68% perf-sched.wait_time.max.ms.exit_to_user_mode_loop.exit_to_user_mode_prepare.syscall_exit_to_user_mode.do_syscall_64 1.548e+09 ± 2% +18.9% 1.84e+09 perf-stat.i.branch-instructions 22847886 ± 4% +6.2% 24254832 perf-stat.i.branch-misses 2.69 ± 6% +0.4 3.06 ± 3% perf-stat.i.cache-miss-rate% 77034877 ± 3% -5.8% 72570665 perf-stat.i.cache-references 431302 ± 3% +199.0% 1289755 perf-stat.i.context-switches 8.536e+09 +4.6% 8.93e+09 perf-stat.i.cpu-cycles 99.38 +247.5% 345.39 ± 4% perf-stat.i.cpu-migrations 14408 ± 11% +133.1% 33584 ± 11% perf-stat.i.cycles-between-cache-misses 2.218e+09 +11.8% 2.481e+09 perf-stat.i.dTLB-loads 1.366e+09 ± 2% +8.2% 1.477e+09 perf-stat.i.dTLB-stores 91.20 -1.8 89.40 perf-stat.i.iTLB-load-miss-rate% 11898638 -33.9% 7865700 perf-stat.i.iTLB-load-misses 998370 ± 7% -15.0% 848296 ± 7% perf-stat.i.iTLB-loads 8.146e+09 ± 2% +12.6% 9.171e+09 perf-stat.i.instructions 848.55 ± 4% +55.5% 1319 perf-stat.i.instructions-per-iTLB-miss 0.95 +8.1% 1.02 perf-stat.i.ipc 0.31 ± 44% -84.8% 0.05 ± 82% perf-stat.i.major-faults 0.24 +4.6% 0.25 perf-stat.i.metric.GHz 144.65 ± 2% +12.7% 163.06 perf-stat.i.metric.M/sec 2104 ± 2% +19.6% 2516 perf-stat.i.minor-faults 221343 ± 3% -18.6% 180275 ± 2% perf-stat.i.node-stores 2104 ± 2% +19.6% 2516 perf-stat.i.page-faults 9.46 ± 2% -16.3% 7.91 ± 2% perf-stat.overall.MPKI 1.48 ± 3% -0.2 1.32 perf-stat.overall.branch-miss-rate% 2.26 ± 4% +0.2 2.50 ± 3% perf-stat.overall.cache-miss-rate% 1.05 -7.1% 0.97 perf-stat.overall.cpi 92.26 -2.0 90.27 perf-stat.overall.iTLB-load-miss-rate% 684.71 +70.3% 1166 perf-stat.overall.instructions-per-iTLB-miss 0.95 +7.6% 1.03 perf-stat.overall.ipc 1.524e+09 ± 2% +18.9% 1.811e+09 perf-stat.ps.branch-instructions 22493006 ± 4% +6.1% 23874609 perf-stat.ps.branch-misses 75835384 ± 3% -5.8% 71429667 perf-stat.ps.cache-references 424565 ± 3% +199.0% 1269435 perf-stat.ps.context-switches 8.403e+09 +4.6% 8.79e+09 perf-stat.ps.cpu-cycles 97.83 +247.5% 339.96 ± 4% perf-stat.ps.cpu-migrations 2.184e+09 +11.8% 2.442e+09 perf-stat.ps.dTLB-loads 1.345e+09 +8.1% 1.454e+09 perf-stat.ps.dTLB-stores 11713146 -33.9% 7742064 perf-stat.ps.iTLB-load-misses 982805 ± 7% -15.0% 834974 ± 7% perf-stat.ps.iTLB-loads 8.019e+09 ± 2% +12.6% 9.027e+09 perf-stat.ps.instructions 0.31 ± 44% -84.8% 0.05 ± 82% perf-stat.ps.major-faults 2071 ± 2% +19.6% 2477 perf-stat.ps.minor-faults 217934 ± 3% -18.5% 177518 ± 2% perf-stat.ps.node-stores 2072 ± 2% +19.6% 2477 perf-stat.ps.page-faults 5.177e+11 +11.4% 5.769e+11 perf-stat.total.instructions 32.52 ± 6% -20.3 12.19 ± 2% perf-profile.calltrace.cycles-pp.__x64_sys_sendto.do_syscall_64.entry_SYSCALL_64_after_hwframe.sendto 32.28 ± 6% -20.2 12.05 ± 2% perf-profile.calltrace.cycles-pp.__sys_sendto.__x64_sys_sendto.do_syscall_64.entry_SYSCALL_64_after_hwframe.sendto 30.73 ± 6% -19.6 11.12 ± 2% perf-profile.calltrace.cycles-pp.sock_sendmsg.__sys_sendto.__x64_sys_sendto.do_syscall_64.entry_SYSCALL_64_after_hwframe 30.02 ± 6% -19.2 10.82 ± 2% perf-profile.calltrace.cycles-pp.udp_sendmsg.sock_sendmsg.__sys_sendto.__x64_sys_sendto.do_syscall_64 33.44 ± 6% -17.6 15.84 ± 2% perf-profile.calltrace.cycles-pp.entry_SYSCALL_64_after_hwframe.sendto 33.10 ± 6% -17.5 15.60 ± 2% perf-profile.calltrace.cycles-pp.do_syscall_64.entry_SYSCALL_64_after_hwframe.sendto 34.40 ± 6% -16.8 17.62 ± 2% perf-profile.calltrace.cycles-pp.sendto 14.33 ± 6% -14.3 0.00 perf-profile.calltrace.cycles-pp.__local_bh_enable_ip.__dev_queue_xmit.ip_finish_output2.ip_send_skb.udp_send_skb 14.25 ± 6% -14.2 0.00 perf-profile.calltrace.cycles-pp.do_softirq.__local_bh_enable_ip.__dev_queue_xmit.ip_finish_output2.ip_send_skb 18.23 ± 6% -14.2 4.02 ± 3% perf-profile.calltrace.cycles-pp.udp_send_skb.udp_sendmsg.sock_sendmsg.__sys_sendto.__x64_sys_sendto 14.11 ± 6% -14.1 0.00 perf-profile.calltrace.cycles-pp.__do_softirq.do_softirq.__local_bh_enable_ip.__dev_queue_xmit.ip_finish_output2 17.78 ± 6% -13.9 3.85 ± 4% perf-profile.calltrace.cycles-pp.ip_send_skb.udp_send_skb.udp_sendmsg.sock_sendmsg.__sys_sendto 16.84 ± 6% -13.4 3.39 ± 4% perf-profile.calltrace.cycles-pp.ip_finish_output2.ip_send_skb.udp_send_skb.udp_sendmsg.sock_sendmsg 16.36 ± 6% -13.2 3.19 ± 4% perf-profile.calltrace.cycles-pp.__dev_queue_xmit.ip_finish_output2.ip_send_skb.udp_send_skb.udp_sendmsg 13.08 ± 7% -13.1 0.00 perf-profile.calltrace.cycles-pp.net_rx_action.__do_softirq.do_softirq.__local_bh_enable_ip.__dev_queue_xmit 12.78 ± 7% -12.8 0.00 perf-profile.calltrace.cycles-pp.__napi_poll.net_rx_action.__do_softirq.do_softirq.__local_bh_enable_ip 12.74 ± 7% -12.7 0.00 perf-profile.calltrace.cycles-pp.process_backlog.__napi_poll.net_rx_action.__do_softirq.do_softirq 11.96 ± 6% -12.0 0.00 perf-profile.calltrace.cycles-pp.__netif_receive_skb_one_core.process_backlog.__napi_poll.net_rx_action.__do_softirq 11.06 ± 6% -11.1 0.00 perf-profile.calltrace.cycles-pp.ip_local_deliver_finish.__netif_receive_skb_one_core.process_backlog.__napi_poll.net_rx_action 8.47 ± 6% -3.4 5.02 perf-profile.calltrace.cycles-pp.ip_make_skb.udp_sendmsg.sock_sendmsg.__sys_sendto.__x64_sys_sendto 5.81 ± 7% -2.4 3.37 ± 2% perf-profile.calltrace.cycles-pp.__ip_append_data.ip_make_skb.udp_sendmsg.sock_sendmsg.__sys_sendto 10.99 ± 6% -2.4 8.57 ± 5% perf-profile.calltrace.cycles-pp.ip_protocol_deliver_rcu.ip_local_deliver_finish.__netif_receive_skb_one_core.process_backlog.__napi_poll 10.64 ± 6% -2.2 8.41 ± 4% perf-profile.calltrace.cycles-pp.__udp4_lib_rcv.ip_protocol_deliver_rcu.ip_local_deliver_finish.__netif_receive_skb_one_core.process_backlog 4.35 ± 10% -2.0 2.37 ± 6% perf-profile.calltrace.cycles-pp.ioctl 9.63 ± 6% -1.8 7.87 ± 4% perf-profile.calltrace.cycles-pp.udp_unicast_rcv_skb.__udp4_lib_rcv.ip_protocol_deliver_rcu.ip_local_deliver_finish.__netif_receive_skb_one_core 3.48 ± 10% -1.7 1.82 ± 4% perf-profile.calltrace.cycles-pp.entry_SYSCALL_64_after_hwframe.ioctl 3.37 ± 9% -1.6 1.75 ± 5% perf-profile.calltrace.cycles-pp.do_syscall_64.entry_SYSCALL_64_after_hwframe.ioctl 9.38 ± 7% -1.6 7.78 ± 4% perf-profile.calltrace.cycles-pp.udp_queue_rcv_one_skb.udp_unicast_rcv_skb.__udp4_lib_rcv.ip_protocol_deliver_rcu.ip_local_deliver_finish 3.19 ± 10% -1.6 1.63 ± 4% perf-profile.calltrace.cycles-pp.__x64_sys_ioctl.do_syscall_64.entry_SYSCALL_64_after_hwframe.ioctl 1.83 ± 12% -1.6 0.27 ±100% perf-profile.calltrace.cycles-pp.sk_ioctl.inet_ioctl.sock_do_ioctl.sock_ioctl.do_vfs_ioctl 2.23 ± 12% -1.4 0.78 ± 9% perf-profile.calltrace.cycles-pp.sock_do_ioctl.sock_ioctl.do_vfs_ioctl.__x64_sys_ioctl.do_syscall_64 2.84 ± 11% -1.4 1.42 ± 6% perf-profile.calltrace.cycles-pp.do_vfs_ioctl.__x64_sys_ioctl.do_syscall_64.entry_SYSCALL_64_after_hwframe.ioctl 2.10 ± 12% -1.4 0.71 ± 10% perf-profile.calltrace.cycles-pp.inet_ioctl.sock_do_ioctl.sock_ioctl.do_vfs_ioctl.__x64_sys_ioctl 2.45 ± 12% -1.4 1.08 ± 26% perf-profile.calltrace.cycles-pp.sock_ioctl.do_vfs_ioctl.__x64_sys_ioctl.do_syscall_64.entry_SYSCALL_64_after_hwframe 3.02 ± 8% -1.3 1.76 ± 4% perf-profile.calltrace.cycles-pp.sock_alloc_send_pskb.__ip_append_data.ip_make_skb.udp_sendmsg.sock_sendmsg 1.58 ± 13% -1.0 0.62 ± 10% perf-profile.calltrace.cycles-pp.udp_rmem_release.__skb_recv_udp.udp_recvmsg.inet_recvmsg.sock_recvmsg 2.24 ± 5% -1.0 1.29 ± 5% perf-profile.calltrace.cycles-pp.ip_generic_getfrag.__ip_append_data.ip_make_skb.udp_sendmsg.sock_sendmsg 2.89 ± 7% -0.9 1.96 ± 6% perf-profile.calltrace.cycles-pp._copy_to_iter.udp_recvmsg.inet_recvmsg.sock_recvmsg.__sys_recvfrom 2.70 ± 7% -0.9 1.80 ± 6% perf-profile.calltrace.cycles-pp.copyout._copy_to_iter.udp_recvmsg.inet_recvmsg.sock_recvmsg 1.97 ± 4% -0.9 1.08 ± 4% perf-profile.calltrace.cycles-pp.ip_route_output_flow.udp_sendmsg.sock_sendmsg.__sys_sendto.__x64_sys_sendto 2.35 ± 7% -0.9 1.47 ± 3% perf-profile.calltrace.cycles-pp.__ip_make_skb.ip_make_skb.udp_sendmsg.sock_sendmsg.__sys_sendto 7.34 ± 7% -0.8 6.49 ± 4% perf-profile.calltrace.cycles-pp.__udp_enqueue_schedule_skb.udp_queue_rcv_one_skb.udp_unicast_rcv_skb.__udp4_lib_rcv.ip_protocol_deliver_rcu 2.58 ± 7% -0.8 1.74 ± 7% perf-profile.calltrace.cycles-pp.rep_movs_alternative.copyout._copy_to_iter.udp_recvmsg.inet_recvmsg 1.87 ± 7% -0.8 1.07 ± 6% perf-profile.calltrace.cycles-pp.alloc_skb_with_frags.sock_alloc_send_pskb.__ip_append_data.ip_make_skb.udp_sendmsg 1.67 ± 5% -0.8 0.92 ± 3% perf-profile.calltrace.cycles-pp.__mkroute_output.ip_route_output_flow.udp_sendmsg.sock_sendmsg.__sys_sendto 1.78 ± 7% -0.8 1.03 ± 5% perf-profile.calltrace.cycles-pp.__alloc_skb.alloc_skb_with_frags.sock_alloc_send_pskb.__ip_append_data.ip_make_skb 3.44 ± 10% -0.7 2.76 ± 5% perf-profile.calltrace.cycles-pp.asm_sysvec_apic_timer_interrupt.cpuidle_enter_state.cpuidle_enter.cpuidle_idle_call.do_idle 1.76 ± 8% -0.6 1.10 ± 2% perf-profile.calltrace.cycles-pp.__ip_select_ident.__ip_make_skb.ip_make_skb.udp_sendmsg.sock_sendmsg 3.19 ± 10% -0.6 2.54 ± 5% perf-profile.calltrace.cycles-pp.sysvec_apic_timer_interrupt.asm_sysvec_apic_timer_interrupt.cpuidle_enter_state.cpuidle_enter.cpuidle_idle_call 1.43 ± 6% -0.6 0.80 ± 7% perf-profile.calltrace.cycles-pp.__check_object_size.ip_generic_getfrag.__ip_append_data.ip_make_skb.udp_sendmsg 1.07 ± 11% -0.6 0.46 ± 71% perf-profile.calltrace.cycles-pp.__irq_exit_rcu.sysvec_apic_timer_interrupt.asm_sysvec_apic_timer_interrupt.cpuidle_enter_state.cpuidle_enter 1.02 ± 11% -0.6 0.42 ± 72% perf-profile.calltrace.cycles-pp.__do_softirq.__irq_exit_rcu.sysvec_apic_timer_interrupt.asm_sysvec_apic_timer_interrupt.cpuidle_enter_state 1.07 ± 7% -0.6 0.49 ± 45% perf-profile.calltrace.cycles-pp.check_heap_object.__check_object_size.ip_generic_getfrag.__ip_append_data.ip_make_skb 1.54 ± 7% -0.6 0.98 ± 9% perf-profile.calltrace.cycles-pp.__consume_stateless_skb.udp_recvmsg.inet_recvmsg.sock_recvmsg.__sys_recvfrom 1.51 ± 7% -0.5 0.97 ± 9% perf-profile.calltrace.cycles-pp.skb_release_data.__consume_stateless_skb.udp_recvmsg.inet_recvmsg.sock_recvmsg 1.02 ± 11% -0.4 0.61 ± 6% perf-profile.calltrace.cycles-pp.skb_set_owner_w.sock_alloc_send_pskb.__ip_append_data.ip_make_skb.udp_sendmsg 1.10 ± 8% -0.4 0.70 ± 9% perf-profile.calltrace.cycles-pp.__slab_free.skb_release_data.__consume_stateless_skb.udp_recvmsg.inet_recvmsg 0.98 ± 8% -0.4 0.60 ± 12% perf-profile.calltrace.cycles-pp.ipv4_pktinfo_prepare.udp_queue_rcv_one_skb.udp_unicast_rcv_skb.__udp4_lib_rcv.ip_protocol_deliver_rcu 0.85 ± 9% -0.2 0.61 ± 8% perf-profile.calltrace.cycles-pp.move_addr_to_user.__sys_recvfrom.__x64_sys_recvfrom.do_syscall_64.entry_SYSCALL_64_after_hwframe 0.74 ± 13% +0.2 0.92 ± 9% perf-profile.calltrace.cycles-pp.enqueue_entity.enqueue_task_fair.activate_task.ttwu_do_activate.sched_ttwu_pending 0.73 ± 15% +0.2 0.98 ± 12% perf-profile.calltrace.cycles-pp.asm_sysvec_call_function_single.poll_idle.cpuidle_enter_state.cpuidle_enter.cpuidle_idle_call 0.48 ± 47% +0.3 0.75 ± 14% perf-profile.calltrace.cycles-pp.sysvec_call_function_single.asm_sysvec_call_function_single.poll_idle.cpuidle_enter_state.cpuidle_enter 0.96 ± 12% +0.3 1.28 ± 8% perf-profile.calltrace.cycles-pp.enqueue_task_fair.activate_task.ttwu_do_activate.sched_ttwu_pending.__flush_smp_call_function_queue 1.06 ± 12% +0.3 1.39 ± 8% perf-profile.calltrace.cycles-pp.ttwu_do_activate.sched_ttwu_pending.__flush_smp_call_function_queue.flush_smp_call_function_queue.do_idle 0.99 ± 12% +0.3 1.33 ± 8% perf-profile.calltrace.cycles-pp.activate_task.ttwu_do_activate.sched_ttwu_pending.__flush_smp_call_function_queue.flush_smp_call_function_queue 0.18 ±141% +0.4 0.56 ± 4% perf-profile.calltrace.cycles-pp._raw_spin_lock_irqsave.__wake_up_common_lock.sock_def_readable.__udp_enqueue_schedule_skb.udp_queue_rcv_one_skb 0.19 ±142% +0.5 0.65 ± 14% perf-profile.calltrace.cycles-pp.__sysvec_call_function_single.sysvec_call_function_single.asm_sysvec_call_function_single.poll_idle.cpuidle_enter_state 1.43 ± 7% +0.5 1.90 ± 6% perf-profile.calltrace.cycles-pp.__schedule.schedule_idle.do_idle.cpu_startup_entry.start_secondary 1.52 ± 8% +0.5 2.00 ± 6% perf-profile.calltrace.cycles-pp.schedule_idle.do_idle.cpu_startup_entry.start_secondary.secondary_startup_64_no_verify 0.10 ±223% +0.5 0.64 ± 15% perf-profile.calltrace.cycles-pp.__flush_smp_call_function_queue.__sysvec_call_function_single.sysvec_call_function_single.asm_sysvec_call_function_single.poll_idle 1.00 ± 9% +0.5 1.54 ± 5% perf-profile.calltrace.cycles-pp.dequeue_entity.dequeue_task_fair.__schedule.schedule.schedule_timeout 1.76 ± 11% +0.6 2.34 ± 13% perf-profile.calltrace.cycles-pp.sched_ttwu_pending.__flush_smp_call_function_queue.flush_smp_call_function_queue.do_idle.cpu_startup_entry 0.00 +0.6 0.59 ± 6% perf-profile.calltrace.cycles-pp.enqueue_entity.enqueue_task_fair.activate_task.ttwu_do_activate.try_to_wake_up 0.00 +0.6 0.60 ± 5% perf-profile.calltrace.cycles-pp.set_next_entity.pick_next_task_fair.__schedule.schedule.smpboot_thread_fn 1.14 ± 9% +0.6 1.75 ± 5% perf-profile.calltrace.cycles-pp.dequeue_task_fair.__schedule.schedule.schedule_timeout.__skb_wait_for_more_packets 2.36 ± 10% +0.7 3.02 ± 9% perf-profile.calltrace.cycles-pp.__flush_smp_call_function_queue.flush_smp_call_function_queue.do_idle.cpu_startup_entry.start_secondary 0.00 +0.7 0.69 ± 7% perf-profile.calltrace.cycles-pp.dequeue_task_fair.__schedule.schedule.smpboot_thread_fn.kthread 2.58 ± 10% +0.7 3.32 ± 9% perf-profile.calltrace.cycles-pp.flush_smp_call_function_queue.do_idle.cpu_startup_entry.start_secondary.secondary_startup_64_no_verify 0.00 +0.8 0.79 ± 7% perf-profile.calltrace.cycles-pp.__switch_to_asm 0.00 +0.8 0.81 ± 7% perf-profile.calltrace.cycles-pp.put_prev_entity.pick_next_task_fair.__schedule.schedule.exit_to_user_mode_loop 0.00 +0.8 0.84 ± 7% perf-profile.calltrace.cycles-pp.enqueue_task_fair.activate_task.ttwu_do_activate.try_to_wake_up.enqueue_to_backlog 0.00 +0.9 0.86 ± 7% perf-profile.calltrace.cycles-pp.update_sg_lb_stats.update_sd_lb_stats.find_busiest_group.load_balance.newidle_balance 0.00 +0.9 0.88 ± 7% perf-profile.calltrace.cycles-pp.activate_task.ttwu_do_activate.try_to_wake_up.enqueue_to_backlog.netif_rx_internal 0.00 +0.9 0.92 ± 6% perf-profile.calltrace.cycles-pp.update_sd_lb_stats.find_busiest_group.load_balance.newidle_balance.pick_next_task_fair 0.00 +0.9 0.94 ± 6% perf-profile.calltrace.cycles-pp.find_busiest_group.load_balance.newidle_balance.pick_next_task_fair.__schedule 0.00 +0.9 0.94 ± 4% perf-profile.calltrace.cycles-pp.pick_next_task_fair.__schedule.schedule.smpboot_thread_fn.kthread 0.00 +1.1 1.06 ± 7% perf-profile.calltrace.cycles-pp.load_balance.newidle_balance.pick_next_task_fair.__schedule.schedule 0.65 ± 10% +1.1 1.72 ± 2% perf-profile.calltrace.cycles-pp.clock_nanosleep 0.47 ± 45% +1.2 1.63 ± 2% perf-profile.calltrace.cycles-pp.do_syscall_64.entry_SYSCALL_64_after_hwframe.clock_nanosleep 0.48 ± 45% +1.2 1.64 ± 2% perf-profile.calltrace.cycles-pp.entry_SYSCALL_64_after_hwframe.clock_nanosleep 0.00 +1.2 1.19 ± 6% perf-profile.calltrace.cycles-pp.newidle_balance.pick_next_task_fair.__schedule.schedule.do_nanosleep 0.00 +1.2 1.20 ± 6% perf-profile.calltrace.cycles-pp.pick_next_task_fair.__schedule.schedule.do_nanosleep.hrtimer_nanosleep 0.37 ± 71% +1.3 1.62 ± 2% perf-profile.calltrace.cycles-pp.__x64_sys_clock_nanosleep.do_syscall_64.entry_SYSCALL_64_after_hwframe.clock_nanosleep 2.29 ± 7% +1.3 3.57 ± 5% perf-profile.calltrace.cycles-pp.__schedule.schedule.schedule_timeout.__skb_wait_for_more_packets.__skb_recv_udp 0.00 +1.3 1.29 ± 5% perf-profile.calltrace.cycles-pp.pick_next_task_fair.__schedule.schedule.exit_to_user_mode_loop.exit_to_user_mode_prepare 0.27 ±100% +1.3 1.59 ± 2% perf-profile.calltrace.cycles-pp.common_nsleep.__x64_sys_clock_nanosleep.do_syscall_64.entry_SYSCALL_64_after_hwframe.clock_nanosleep 0.27 ±100% +1.3 1.59 ± 2% perf-profile.calltrace.cycles-pp.hrtimer_nanosleep.common_nsleep.__x64_sys_clock_nanosleep.do_syscall_64.entry_SYSCALL_64_after_hwframe 0.00 +1.3 1.32 ± 5% per"
    }
}