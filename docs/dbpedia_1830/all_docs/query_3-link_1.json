{
    "id": "dbpedia_1830_3",
    "rank": 1,
    "data": {
        "url": "https://stackoverflow.com/questions/385132/proper-best-type-for-storing-latitude-and-longitude",
        "read_more_link": "",
        "language": "en",
        "title": "proper/best type for storing latitude and longitude",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/6757caf55de0413ae0994293e001d465?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/2f364c2e36b52bc80296cbf23da8b231?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/QC7QK.jpg?s=64",
            "https://i.sstatic.net/B2vUR.jpg?s=64",
            "https://www.gravatar.com/avatar/88dcd9a1b56c02e905ac3a352e43ba81?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/cb4498d2fe6dcc935993e249a0360bc2?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/3fdb8518473ec145645e5925e7f08598?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/cf8c5e3c346c7734cb1ff728264f6cfb?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/0b722a5f7d2d809629ee40c63cc8576b?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/747ffa5da3538e66840ebc0548b8fd58?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/65c83f38d0c346ea55b926bf6de41b49?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/584c7d6d4ecf4a878b184ea583a06510?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/d4df3d19d4f89cc9a151275748b1877b?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/34c17107407e779765444c11d197345f?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/71828e3594c57e13f477c0db81b36e25?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/d1474f3efab3b897d297ef12b7654a31?s=64&d=identicon&r=PG",
            "https://stackoverflow.com/posts/385132/ivc/f78e?prg=3861dc04-32e7-4fea-9838-3419be33260c"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2008-12-21T23:07:48",
        "summary": "",
        "meta_description": "In a system level programming language like C, C++ or D, what is the best type/encoding for storing latitude and longitude?\n\nThe options I see are:\r\nIEEE-754 FP as degrees or radians\ndegrees or rad...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/385132/proper-best-type-for-storing-latitude-and-longitude",
        "text": "The easiest way is just to store it as a float/double in degrees. Positive for N and E, negative for S and W. Just remember that minutes and seconds are out of 60 (so 31 45'N is 31.75). Its easy to understand what the values are by looking at them and, where necessary, conversion to radians is trivial.\n\nCalculations on latitudes and longitudes such as the Great Circle distance between two coordinates rely heavily on trigonometric functions, which typically use doubles. Any other format is going to rely on another implementation of sine, cosine, atan2 and square root, at a minimum. Arbitrary precision numbers (eg BigDecimal in Java) won't work for this. Something like the int where 2^32 is spread uniformly is going to have similar issues.\n\nThe point of uniformity has come up in several comments. On this I shall simply note that the Earth, with respect to longitude, isn't uniform. One arc-second longitude at the Arctic Circle is a shorter distance than at the Equator. Double precision floats give sub-millimetre precision anywhere on Earth. Is this not sufficient? If not, why not?\n\nIt'd also be worth noting what you want to do with that information as the types of calculations you require will have an impact on what storage format you use.\n\nGreat question!\n\nI know this question is 9 years old now, and I only know a part of the answer you were seeking, but I just came here having a similar question, and many things have changed since that question was asked, such as hardware and GPSes available. I work with this subject frequently in firmware dealing with different kinds of GPSes in different kinds of applications, and have lost count of the hours (and days) I have spent working out \"the best design\" for different applications that I have worked with or developed.\n\nAs always, different solutions are going to provide benefits and costs, and ultimately, a \"best design\" is always going to be a \"best fit\" of the benefits and costs against system requirements. Here are some things that I have to consider when I ask the same question:\n\nCPU Time Cost\n\nIf CPU does not have a built-in floating-point co-processor (as is the case with many microcontrollers), then dealing with 'float', 'double', and 'long double' can be extremely costly. For example, with one 16-bit microcontroller I work with regularly, a multiplication using 'double' values costs 326 CPU clock cycles, and a division costs 1193 clock cycles. Very expensive!\n\nAccuracy Trade-Off\n\nAt the equator, a 'float' (IEEE-754 32-bit floating point value), needing to represent a signed degree value, assuming 7 \"clean\" significant decimal digits able to be represented, the change of one least-significant decimal digit (e.g. from 179.9999 to 180.0000) is going to represent a distance of about 11.12 meters. This may or may not meet hard system accuracy requirements. Whereas a 'double' (with 15 \"clean\" significant decimal digits represented, thus a change from 179.999999999999 to 180.000000000000) represents about 0.00011 mm.\n\nInput Accuracy Limitations\n\nIf you're dealing with input from a GPS, how many digits of real accuracy are you getting, and how many do you need to preserve?\n\nDevelopment Time Costs\n\nAn IEEE-754 64-bit double-precision value ('double') and 32-bit single-precision value ('float') are VERY convenient to deal with in the C language since math libraries for both come with virtually every C compiler, and are usually very reliable. If your CPU comes with a hardware floating-point processor, this is an easy choice.\n\nRAM and Storage Costs\n\nIf you have to keep a large number of these values in RAM (or storage e.g. MYSQL), available RAM (and storage space) might have an impact on the workability of the solution.\n\nAvailable Data vs Required Data\n\nOne example I'm dealing with at this writing (the reason I came here to this question) is that I am dealing with a u-blox M8 GPS which is able to give me binary GPS information (saving the CPU overhead of translating ASCII NMEA sentences). In this binary format (called \"UBX Protocol\") latitude and longitude are represented as signed 32-bit integers, which representation is able to represent accuracy (at the equator) of down to about 1.11 cm. For example, -105.0269805 degrees longitude is represented as -1050269805 (using all 32 bits) and one LSb change represents about 1.11 cm change in latitude anywhere, and 1.11 cm longitude at the equator (and less at higher latitudes, in proportion to the cosine of the latitude). The application this GPS is in does navigation tasks, which (already existing and well-tested code) requires 'double' data types. Unfortunately, converting this integer to an IEEE-754 64-bit 'double' cannot be easily done just by moving the base-2 bits of the integer into the internal representation bits of the 'double' since the decimal shift to be performed is a base-10 decimal shift. Were it a base-2 decimal shift instead, then the base-2 bits of the integer could be moved into the bit-fields of the 'double' with very little translation required. But alas, this is not the case with the signed integer I have. So it is going to cost me a multiplication on a CPU that doesn't have a hardware floating-point processor: 326 CPU clock cycles.\n\ndouble ldLatitude; int32_t li32LatFromGps; ldLatitude = (double)li32LatFromGps * 0.0000001;\n\nNote this multiplication was chosen over this:\n\nldLatitude = (double)li32LatFromGps / 10000000.0;\n\nbecause 'double' multiplication is about 3.6X faster than 'double' division on the CPU that I'm dealing with. Such is life in the microcontroller world. :-)\n\nWhat would have been BRILLIANT (and may be in the future if I can spare the time on weekends) is if the navigation tasks could be done directly with the 32-bit signed integer! Then no conversion would be needed.... But would it cost more to do the navigation tasks with such an integer? CPU costs, probably much more efficient. Development time costs? That's another question, especially with a well-tested system already in place, that uses IEEE-754 64-bit 'double' values! Plus there is already-existing software that provides map data (using 'double' degree values), which software would have to be converted to use the signed integer as well -- not an overnight task!\n\nOne VERY interesting option is to directly (without translation) represent intersections between approximations of \"rectangles\" (actually trapezoids, which become triangles at the poles) using the raw latitude/longitude integers. At the equator these rectangles would have dimensions of approximately 1.11 cm east-west by 1.11 cm north-south, whereas at a latitude of say London, England, the dimensions would be approximately 0.69 cm east-west by 1.11 cm north-south. That may or may not be easy to deal with, depending on what the application needs.\n\nAnyway, I hope these thoughts and discussion help others who are looking at this topic for \"the best design\" for their system.\n\nKind regards, Vic\n\nWhat encoding is \"best\" really depends on your goals/requirements.\n\nIf you are performing arithmetic, floating point latitude,longitude is often quite convenient. Other times cartesian coordinates (ie x,y,z) can be more convenient. For example, if you only cared about points on the surface of earth, you could use an n-vector.\n\nAs for longer term storage, IEEE floating point will waste bits for ranges you don't care about (for lat/lon) or for precision you may not care about in the case of cartesian coordinates (unless you want very good precision at the origin for whatever reason). You can of course map either type of coordinates to ints of your preferred size, such that the entire range of said ints covers the range you are interested in at the resolution you care about.\n\nThere are of course other things to think about than merely not wasting bits in the encoding. For example, (Geohashes)[https://en.wikipedia.org/wiki/Geohash] have the nice property that it is easy to find other geohashes in the same area. (Most will have the same prefix, and you can compute the prefix the others will have.) Unfortunately, they maintain the same precision in degrees longitude near the equator as near the poles. I'm currently using 64-bit geohashes for storage, which gives about 3 m resolution at the equator.\n\nThe Maidenhead Locator System has some similar characteristics, but seems more optimized for communicating locations between humans rather than storing on a computer. (Storing MLS strings would waste a lot of bits for some rather trivial error detection.)\n\nThe one system I found that does handle the poles differently is the Military Grid Reference System, although it too seems more human-communications oriented. (And it seems like a pain to convert from or to lat/lon.)\n\nDepending on what you want exactly, you could use something similar to the Universal polar sereographic coordinate system near the poles along with something more computationally sane than UTM for the rest of the world, and use at most one bit to indicate which of the two systems you're using. I say at most one bit, because it's unlikely most of the points you care about would be near the poles. For example, you could use \"half a bit\" by saying 11 indicates use of the polar system, while 00, 01, and 10 indicate use of the other system, and are part of the representation.\n\nSorry this is a bit long, but I wanted to save what I had learned recently. Sadly I have not found any standard, sane, and efficient way to represent a point on earth with uniform precision.\n\nEdit: I found another approach which looks a lot more like what you wanted, since it more directly takes advantage of the lower precision needed for longitude closer to the poles. It turns out there is a lot of research on storing normal vectors. Encoding Normal Vectors using Optimized Spherical Coordinates describes such a system for encoding normal vectors while maintaining a minimum level of accuracy, but it could just as well be used for geographical coordinates.\n\nAfter coming across this question after searching for an answer myself, here is another possible scheme based on some precedent.\n\nThe Network Working Group, RFC 3825 proposed a coordinate-based geographic location option for DHCP (ie the system that hands out IP addresses on a network). See https://tools.ietf.org/rfc/rfc3825.txt\n\nIn this scheme, latitude and longitude are encoded in degrees with fixed-point values where the first 9 bits are the signed degrees, 25 bits are fractional degrees, and 6 bits are used for the accuracy. The value of the accuracy bits indicates the number of the 25 fractional bits that are considered to be accurate (e.g. coordinates collected via a consumer GPS vs a high-precision surveyor's GPS). Using WGS84, the accuracy is 8 decimal digits which is good to about a millimeter regardless of where you are on the globe.\n\nAs a couple of others have posted, floating point encoding really isn't good for this type of thing. Yes, it can represent a very large number of decimal places but the accuracy is either ignored or has to be dealt with somewhere else. For example, printing a float or a double with full floating-point precision results in a number with decimal digits very very unlikely to be remotely accurate. Likewise, simply outputting a float or a double with 8 or 10 decimal digits of precision many not be a true representation of the source values based on how floating point numbers are computed (e.g. why 1.2-1.0 does not equal 0.2 using floating point arithmetic).\n\nFor for a humorous example of why you should care about coordinate-system precision, see https://xkcd.com/2170/.\n\nGranted, the 40-bit encoding used in RFC 3825 is hardly convenient in a 32 or 64-bit world but this style can be easily extended to a 64-bit number where 9 bits are used for the signed degree, 6 bits are used for the accuracy, leaving 49 bits for the decimal portion. This results in 15 decimal digits of precision which is more than basically anyone will ever need (see humorous example)."
    }
}