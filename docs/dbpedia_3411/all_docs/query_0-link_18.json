{
    "id": "dbpedia_3411_0",
    "rank": 18,
    "data": {
        "url": "https://stackoverflow.com/questions/200721/most-interesting-non-mainstream-language",
        "read_more_link": "",
        "language": "en",
        "title": "Most interesting non-mainstream language?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://stackoverflow.com/posts/200721/ivc/fe89?prg=35529c07-b836-4993-921e-c0fccd03bb10"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2008-10-14T10:59:06",
        "summary": "",
        "meta_description": "I'm interested in compilers, interpreters and languages.\n\nWhat is the most interesting, but forgotten or unknown, language you know about? And more importantly, why? \n\nI'm interested both in compil...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/200721/most-interesting-non-mainstream-language",
        "text": "I love compilers and VMs, and I love Lua.\n\nLua is not as well supported as many other scripting languages, but from a mindset like yours I'm sure you will fall in love with Lua too. I mean it's like lisp, (can do anything lisp can as far as I know), has lots of the main features from ADA, plus it's got meta programming built right in, with functional programming and object oriented programming loose enough to make any type of domain language you might want. Besides the VM's code is simple C which means you can easily dig right into it to appreciate even at that level.\n\n(And it's open-source MIT license)\n\nI am a fan of the D programming language. Here is a wikipedia article and and intro from the official site.\n\nSome snippets from the wikipedia article:\n\nThe D programming language, also known simply as D, is an object-oriented, imperative, multiparadigm system programming language by Walter Bright of Digital Mars. It originated as a re-engineering of C++, but even though it is predominantly influenced by that language, it is not a variant of C++. D has redesigned some C++ features and has been influenced by concepts used in other programming languages, such as Java, C# and Eiffel. A stable version, 1.0, was released on January 2, 2007. An experimental version, 2.0, was released on June 17, 2007.\n\non features:\n\nD is being designed with lessons learned from practical C++ usage rather than from a theoretical perspective. Even though it uses many C/C++ concepts it also discards some, and as such is not strictly backward compatible with C/C++ source code. It adds to the functionality of C++ by also implementing design by contract, unit testing, true modules, garbage collection, first class arrays, associative arrays, dynamic arrays, array slicing, nested functions, inner classes, closures[2], anonymous functions, compile time function execution, lazy evaluation and has a reengineered template syntax. D retains C++'s ability to do low-level coding, and adds to it with support for an integrated inline assembler. C++ multiple inheritance is replaced by Java style single inheritance with interfaces and mixins. D's declaration, statement and expression syntax closely matches that of C++.\n\nI would suggest having a look at Erlang - it's been getting a bit of press recently, so some of the learning resources are excellent. If you've used OO and/or procedural languages, Erlang will definitely bend your mind in new and exciting ways.\n\nErlang is a pure functional language, with ground-up support for concurrent, distributed and fault-tolerant programs. It has a number of interesting features, including the fact that variables aren't really variables at all - they cannot be changed once declared, and are in fact better understood as a form of pattern.\n\nThere is some talk around the blogosphere about building on top of the Erlang platform (OTP) and machine support for other languages like Ruby - Erlang would then become a kind of virtual machine for running concurrent apps, which would be a pretty exciting possibility.\n\nI've recently fallen in love with Ocaml and functional languages in general.\n\nOcaml, for instance, offers the best of all possible worlds. You get code that compiles to executable native machine language as fast as C, or universally portable byte code. You get an interpreter to bring REPL-speed to development. You get all the power of functional programming to produce perfectly orthogonal structures, deep recursion, and true polymorphism. Atop all of this is support for Object-Orientation, which in the context of a functional language that already provides everything OOP promises (encapsulation, modularization, orthogonal functions, and polymorphic recyclability), means OOP that is forced to actually prove itself.\n\nHaskell and REBOL are both fascinating languages, for very different reasons.\n\nHaskell can really open your eyes as a developer, with concepts like monads, partial application, pattern matching, algebraic types, etc. It's a smorgasbord for the curious programmer.\n\nREBOL is no slouch either. It's deceptively simple at first, but when you begin to delve into concepts like contexts, PARSE dialects, and Bindology, you realize there's much more than meets the eye. The nice thing about REBOL is that it's much easier to get started with it than with Haskell.\n\nI can't decide which I like better.\n\nI find constraint languages interesting, but it is hard to know what constitutes forgotten or unknown. Here are some languages I know about (this is certainly not an exhaustive list of any kind):\n\nCiao, YAP, SWI-Prolog, and GNU Prolog are all Prolog implementations. I think they are all open source. Ciao, gnu prolog, and probably the others also, as is common in Prolog implementations, support other constraint types. Integer programming for example.\n\nMozart and Mercury are both, as I understand it, alternative logic programming languages.\n\nAlice is more in the ML family, but supports constraint programming using the GECODE C++ library.\n\nDrifting a little bit off topic....\n\nMaude is an interesting term rewrite language.\n\nHOL and COQ are both mechanized proof systems which are commonly used in the languages community.\n\nLambda-the-Ultimate is a good place to talk about and learn more about programming languages.\n\nHave a look at Io at http://www.iolanguage.com/ or Lisaac at: https://gna.org/projects/isaac/ or Self at: http://self.sourceforge.net/ or Sather (now absolutly forgotten) or Eiffel http://www.eiffel.com\n\nWhy here are a few reasons. Io is absolutly minimalistic and does not even have \"control flow elements\" as syntacit entities. Lisaad is a follow-up to Eiffel with many simplifications AFAIKT. Self is a followup to Smalltalk and Io has taken quite alot from Self also. The base thing is that the distinction between Class and Object has been given up. Sather is a anwer to Eiffel with a few other rules and better support for functional programming (right from the start).\n\nAnd Eiffel is definitly a hallmark for statically typed OO-languages. Eiffel was the first langauge whith support for Design by contract, generics (aka templates) and one of the best ways to handle inheritance. It was and is one of the simpler languages still. I for my part found the best libraries for Eiffel.....\n\nIt's creator just has one problem, he did not accept other contributions to the OO field.....\n\nRegards\n\nI recently learned of the existence of Icon from this question. I have since used it in answers to several questions. (1, 2, 3, 4)\n\nIt's interesting because of its evaluation strategy - it is the only imperative language I know that supports backtracking. It allows some nice succinct code for many things :)\n\nLearning any language that requires you to rethink your programming habits is a must. A sure sign is the pace at which you skim through the documentation of a language's core (not library). Fast meaning fruitless here.\n\nMy short list would be, in my order of exposure and what were the concepts I learned from them:\n\nAssembly, C: great for learning pointers and their arithmetic.\n\nC++: same as C with an introduction to generics, as long as you can stand the incredibly verbose syntax.\n\nRuby/Lua: scripting languages, dynamically typed, writing bindings for existing C libraries.\n\nPython/C#/Java: skipped, these languages look to me as a rehash of notions originating elsewhere with a huge standard library. Sure the whole packages are nice, but you won't learn new concepts here.\n\nOCaml: type infererence done right, partial application, compiler infered genericity, immutability as a default, how to handle nulls elegantly.\n\nHaskell: laziness by default, monads.\n\nMy â‚¬.02.\n\nFirst answer - Scheme. It's not too widely used, but definitely seems like a solid language to use, especially considering the robustness of DrScheme (which in fact compiles Scheme programs to native binary code).\n\nAfter that - Haskell is incredibly interesting. It's a language which does lazy evaluation right, and the consequences are incredible (including such things as a one-line definition of the fibonnaci sequence).\n\nGoing more mainstream, Python is still not really widely accepted in the business circles, but it definitely should be, by now...\n\nThe first major (non-BASIC) language that I learned was Dream Maker, from http://www.byond.com. It's somewhat similar to C++ or Java, but it's largely pre-built for designing multiplayer online games. It's very much based on inheritance. It's an intersting language especially as a starting language, it gets gratifying results quicker, and lets be honest, most people who are first learning to program are interested in one thing... games.\n\nI've recently looked up a lot about Windows PowerShell.\n\nWhile not necessarily just a language. It's an awesome shell that has a built-in scripting language. It's basically a super-beefed up command line shell.\n\nUnlike Unix shells, where everything is string text (which definitely has it's benefits), PowerShell commands (cmdlets) use objects. It's based on the .Net framework so you guys who are familiar with that will have probably already figured out that anything PowerShell returns can be piped and the properties and methods of that object can be used. It's fun to say \"everything is an object!\" again just like when OOP was getting big.\n\nVery neat stuff. For the first time, Windows is implementing some of the Unix command-line interface tools similar to grep and the whole bunch."
    }
}