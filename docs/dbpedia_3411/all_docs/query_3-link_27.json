{
    "id": "dbpedia_3411_3",
    "rank": 27,
    "data": {
        "url": "https://andrewbegel.com/mit/begel-meng-thesis.html",
        "read_more_link": "",
        "language": "en",
        "title": "1. Abstract",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://andrewbegel.com/mit/begel-meng-thesis_files/image001.png",
            "https://andrewbegel.com/mit/begel-meng-thesis_files/image002.png",
            "https://andrewbegel.com/mit/begel-meng-thesis_files/image003.png",
            "https://andrewbegel.com/mit/begel-meng-thesis_files/image004.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "3. Related Computational Construction Kits\n\nThis chapter discusses several different types of computational construction kits. By no means a complete listing, this selection of examples is presented here to illustrate various design considerations that other researchers have taken in their research.\n\nThe first section, “General-purpose Construction Kits,” discusses Logo, Boxer, Agentsheets, and Cocoa and illustrates how these kits have been used with children, and advantages and disadvantages to each of their approaches to learning. The second section, “Construction Games,” introduces several games that use a construction metaphor to engage children in design. Rocky’s Boots, Robot Odyssey, The Incredible Machine, and Widget Workshop are all widely varying examples of construction games that have been popular with kids in the past. The last section, “Video Games,” specifically talks about video game construction kits and how these kits approach the task of enabling children to easily create their own video games.\n\n3.1 General-purpose Construction Kits\n\n3.1.1 Logo\n\nLogo, designed in the 1960’s, was one of the first programming languages created for children. A team of researchers at BBN and MIT, including Seymour Papert and Wally Feurzeig, created this variant of Lisp to meet specific design goals. They wanted to make Lisp more accessible to non-programmers, especially children. They achieved this in several ways. First, they simplified Lisp’s syntax, removing parentheses, reducing the number of syntactic forms and shrinking the primitive sets. They did, however, keep Lisp’s dynamically-scoped, procedural semantics.\n\nAnother approach to enhance Logo’s understandability was to leverage it off natural language. Whenever a child tried to ask Logo to do something it didn’t understand, Logo would respond, “I don’t know how to do that.” Children could then teach the Logo interpreter how to do different tasks by saying “to make-a-square” and writing a procedure that told the computer how to make a square.\n\nOne of the overall results of Logo was that its accessibility provided a gateway through which children could reach many different problem domains where interesting questions lay. In the programming domain itself, children might discover recursion as a way to tell a procedure to repeat over and over again. They could learn new debugging skills when the computer executed a procedure differently than they had thought it would. They could also actively explore the Logo environment by interacting through a command center. Here, they could try out new commands and receive instant feedback about what they did. This helped immensely in debugging efforts, since children could try procedures with many different inputs to understand its complete behavior.\n\nOutside of the programming domain, the introduction of the Logo Turtle (Papert, 1980) allowed kids to reach “Mathland.” Mathland was a metaphor for a place where children could use math as fluently as they used language. The Logo Turtle enabled children to think about mathematics and geometry using body syntonics. Children could envision themselves as the turtle, moving around on the ground to draw geometrical figures. This enabled children to think about computational geometry, instead of the more traditional Euclidean or Aristotelian geometry.\n\nLogo became very popular in elementary schools, and with the help of Mindstorms (Papert, 1980), Turtle Geometry (Abelson and diSessa, 1986), and other educational books, many people thought that the children would easily make it to Mathland. Unfortunately, for all of the powerful ideas that Logo might help children to reach, it didn’t achieve the epistemological success that Papert sought. This was due to several problems: the inertia of the school system to resist change, the paucity of computers in schools, and the tendency of teachers to lecture to children, instead of letting them learn on their own. Others thought that some problems were due to Logo itself, rather than how it was deployed and used. They thought that Logo was too low-level and that domain-specific tools might be better to engage kids in learning (O’Shea, in press).\n\n3.1.1.1 Variants of Logo\n\nSince the 1960’s, the Logo turtle has been used in many different types of Logo programming environments, including moving from robotic form to screen form in the very popular Apple Logo, written by LCSI (Logo Computer Systems Inc). For many years, Apple Logo was used in elementary schools to teach geometry and math. In the mid 1980’s, LCSI introduced Logo Writer. This version opened up the design space further by adding turtle shapes and multiple turtles. Children could assign turtles different shapes and create stories using the new characters they made. Kids could also create video games, for example, by using a turtle for the enemy, a turtle for the hero and some turtles for the bullets.\n\nAt this point in Logo’s history, the technology could not yet match the kids’ expectations. Some of Kafai's students would come to school with grandiose plans about what they would work on that day, but then run up against technological limitations in Logo Writer. Kids wanted more turtles so they could have more than four characters at a time. There was also no multi-threading, so it was not easy to tell all of the turtles to do different things at the same time (Kafai, 1993).\n\nThe next Logo by LCSI was MicroWorlds. This version, introduced in 1992, included support for modern computer features like multimedia, sprite animation, sounds, movies, and paint tools. It introduced multiple processes, so kids could more easily program turtles independently and not worry about managing multi-threaded program flow.\n\nMicroWorlds’ use of multiple processes was inspired by MultiLogo and StarLogo, both created by Mitchel Resnick (Resnick, 1991, 1994). StarLogo, written for the Connection Machine 2 parallel computer, added many more turtles to the Logo canvas. Users could have up to 16,000 turtles, instead of merely one or two. It opened up a whole new design space where children could model ant colonies, flocks of birds, or even create ideal gas molecular simulations. StarLogo suffered from one disadvantage, however. CM2s cost about one million dollars, so anyone who wanted to use StarLogo had to come to MIT.\n\nIn order to alleviate the access problem, StarLogo was ported to the Macintosh. A very lightweight process switcher enabled the serial processor of the Macintosh to emulate the 16,384 processors of the Connection Machine. A SPMD architecture (single program, multiple data: many turtles each running one program, but each with their own program counter) was also adopted. This provided an advantage over the SIMD model of computation (single instruction multiple data: many turtles, each running one program in sync) on the CM2 because now each turtle was now free to run separate pieces of code at the same time. The move to the Macintosh also enabled the addition of extra graphics and user interface features that were impossible on the CM2, such as sprites, paint tools and an interface builder.\n\nThe sprite graphics, combined with breeds, a turtle grouping feature, turned out to be an interesting addition to StarLogo, that allowed users to more easily identify with the simulations they were creating. During the summer of 1996, MIT undergraduates David Feinberg and Carlos Mochon used StarLogo to recreate two classic video games, Pacman and Frogger. The games looked and felt just like the originals and were fun to play. They were also unexpectedly easy to program. These video games were the inspiration for the work described in this thesis.\n\n3.1.2 Boxer\n\nBoxer is a unique programming environment that embodies the ideals of Logo, Lisp and Smalltalk (diSessa and Abelson, 1986). Invented by Andy diSessa and Hal Abelson, it explores the transformation of Logo from a procedural text-based environment into an object-oriented hybrid graphical-textual environment.\n\nBefore the 80’s, Logo never really concentrated on the programming environment in which the children created their projects. At best, children could hope for a split screen approach, where they could see the turtle or the procedures, but never both at the same time. Boxer, in the Smalltalk tradition, integrated the procedures page with the graphics page and created a multimedia graphical approach to programming. Boxer actually foreshadowed the World Wide Web and document-based computing because it turned all data, including multimedia, into first-class manipulable objects on the screen.\n\nBoxer’s basic building block is the box. Boxes can contain programs, data, text, pictures, and even other boxes (thereby supporting hierarchical structures and abstraction). Boxer’s display of its collapsible boxes (which visually indicate black boxing) “encourage programmers to interpret the organization of the computational system in terms of spatial relationships” (diSessa and Abelson, 1986). Children can also analyze dynamic program flow by employing the “Little Man” explanation of structural programming. Whenever a procedure calls another one, it appears as a box inside the first procedure call. When that procedure is finished, the box collapses and the original procedure regains control (diSessa, 1986).\n\n3.1.3 Agentsheets\n\nAgentsheets is a visual programming construction kit created by Alex Repenning at the University of Colorado (Repenning, 1994). The first version of Agentsheets used a purely graphical approach to programming agents (similar to Logo turtles) that occupy cells in a grid. Using graphical rewrite rules to illustrate transitions from one picture state to the next, the agents can be programmed to move around the grid and interact with each other. This model of computation is very similar to the Turing machine model. But, like the Turing model, it suffers from an exponential rule growth.\n\nRepenning writes that programming via graphical manipulation lowers the threshold for beginning programmers, especially kids. He has also experimented with a form of physical programming involving a robot and LEGO road base plates. Children programmed the car to always stay on the road, and could meta-program the robot by putting different road plates in front of it. This way they could make the robot go anywhere they wanted without ever typing a single command (Eden, et. al. 1996).\n\nRecently, with the development of Visual Agentalk, Repenning has shifted his model of programming from graphical rewrite rules to a more programmable, direct manipulation approach (Repenning and Ambach, 1996a,b). Using command and sensor blocks in a stimulus-response framework, programmers can create behaviors using parameterized blocks. This alleviates much of the problem with the explosion of rules because it raises the abstraction level of programming above the Turing model. In addition, the user can try out commands or stimulus-response rules directly by dragging them on top of the agents. This allows the user to test and debug commands and rules interactively while programming.\n\n3.1.4 Cocoa (Kidsim)\n\nCocoa, a product from Apple Computer, is similar to the first version of Agentsheets. Created by Alan Cypher and David Smith, Cocoa’s programming style is an extreme experiment in pure graphical rewrite rule programming (Smith, Cypher, Spohrer, 1994). Intended as an introduction to programming for young children, kids can create their own simple projects by defining characters from a palette and placing them on a playfield. Similar to Agentsheets, the children can define transitions between before and after graphics to control the characters on the field.\n\nCocoa suffers from the same exponential blowup of rules as Agentsheets, but the designers feel that the increased usability and understandability of the simple rules allow children to more easily express themselves. Rather than working to raise Cocoa’s ceiling, they feel that adding more modalities and breadth of I/O to Cocoa is a better way to entice more children to program. (Cypher, 1996)\n\nApple has invested quite a bit of time and money into the background support of Cocoa. They recently introduced a Cocoa plug-in for Netscape, which allows kids to play their games (but not create them) on the Web. Apple also maintains a web site that allows kids to publish their projects and even participate in a best game contest. This web site is an important step in widening the audience for kids’ projects. Prior to the Web, children could create projects, but could only show them off to their friends in the same room. With the Web, however, children can publish their projects to a much wider audience and enjoy the benefits of this new interaction.\n\n3.2 Construction Games\n\n3.2.1 Rocky’s Boots\n\nThere were a number of games introduced in the early 1980’s that incorporated the construction kit metaphor in the activity itself. Rocky’s Boots, designed by Warren Robinett, allowed kids to learn logic and circuit design by constructing digital circuits. Each level of the game had challenging problems where children would wire up block sensors to various types of digital gates in order to recognize and “boot” a certain pattern of blocks. For example, if there were six blocks on the screen, and you were instructed to “boot” the red triangles, you could connect up a triangle shape sensor and a red color sensor to an AND gate which would then connect to the Boot. Whenever the sensors were both triggered by the red triangles, the Boot would kick the block out of the way and you would earn some points. There were also more complex sequence problems such as recognizing a red triangle only after seeing a blue square.\n\nA graphical programming approach was used in this environment, as well as an electric data flow model. Similar to Widget Workshop (which is a much more recent game and is described below), children could connect wires between various logic gates and flip-flops in order to create a circuit. The kit had some facilities to aid debugging these circuits. When the power was turned on, you could watch the action of your digital circuit as the current flowed through the machine. You could also turn a dial to control the speed of the electric flow. Rocky’s Boots contained different rooms in its world where you could quickly try out different circuit combinations. It was also a modifiable environment. Children could build their own variants of Rocky’s Boots games and challenge their friends with difficult sequences of blocks.\n\n3.2.2 Robot Odyssey\n\nRobot Odyssey, a game from the Learning Company, followed in Rocky’s Boots footsteps. It continued the use of the electric data flow model, but applied it to a robot’s brain. Children could program a robot to move around and interact with objects in a virtual world on the computer screen. Inside the robot’s head were a variety of sensors and actuators that could be wired together through logic gates, flip-flops and IC’s. To make a robot that followed the wall, a child would wire the left wall bumper to the right and rear thruster, thus keeping the robot against the wall and moving it forward at the same time.\n\nRobot Odyssey also used a graphical environment, but expanded on the spatial metaphor by constructing an elaborate virtual world with puzzles to solve in every room. The child could try out a variety of robots in each room and test different circuits to see which would work the best. The instruction manual included with the game also gave quite a few example challenge problems. These ranged from wall-following to finding a key in a maze of stairways.\n\nWhile the environment supported active exploration of various circuit ideas, it wasn’t easy to create a circuit that would work. This problem isn’t particular to this game, however; it is a problem that plagues robot designers to this day. Fred Martin, a researcher in the Epistemology and Learning Group, helped create the 6.270 LEGO Robot Design Contest at MIT. Students had to build a robot out of LEGO and program it to perform autonomously in a sixty-second contest against another robot. Often, the MIT students had problems overcoming noisy sensors, incorrect assumptions of environmental conditions, and problems learning exactly what the actuators could and could not do. On the other hand, students learned system theory related to control and feedback, bottom-up design, and programming techniques for unpredictable, non-ideal, noisy, environmental conditions (Martin, 1994).\n\nRobot Odyssey supports black boxing. Children’s circuits often get large, gangly and unwieldy, turning into tangles of wires. Robot Odyssey’s circuit metaphor extends to IC chips, which provide an good metaphor for black boxing large programs. By moving the robot to the chip burning room, children can take a snapshot of a its “brain” (disconnected from its inputs and outputs) and burn a new chip with the program inside. Then they can put this chip inside the robot head and wire it directly to the sensors and actuators with very little mess. This works well, except that children sometimes forget what the input and output pins of a particular IC do. To help avoid this problem, Robot Odyssey provides a documentation tool to record the description of the inputs and outputs of the chips.\n\n3.2.3 The Incredible Machine\n\nThe Incredible Machine, published by Sierra On-Line, is a construction kit in which kids put together a Rube-Goldberg contraption to solve a puzzle. By connecting pianos, traps, levers and guns, kids can solve each new level of the game. The Incredible Machine uses a direct manipulation style interface, where each element in the parts palette can be dragged out onto the screen. The user can easily test out different configurations of parts to see if it would solve the puzzle.\n\nOne problem with this game is that sometimes the parts needed to be perfectly aligned in order for them to work, and there are no visual clues other than running the simulation to find this out. The game is also not customizable; the parts are static. The user can not extend the game to include more parts or modify existing ones to exhibit different behaviors. Sometimes the machines that are created get quite complex, so a facility for abstraction and black boxing a particular machine would be helpful, too. The next version of The Incredible Machine adds the ability to create new puzzles, so the user can devise their own challenges for their friends.\n\n3.2.4 Widget Workshop\n\nWidget Workshop is a product published by Maxis, the company that makes SimCity and other popular simulation games. Using Widget Workshop, children can make complicated machines from timers, switches, gates, and other graphical objects that perform different tasks. Children are challenged to create the right machine to achieve a particular goal, such as turning on a light, or making a Rube-Goldberg contraption work correctly.\n\nWidget Workshop uses a data flow metaphor. Using wires to connect different parts together, children wire up inputs to outputs and create large information flow graphs. Widget Workshop is also graphical, so children use the mouse to directly manipulate the parts on the screen to place them in their proper locations. When the children have finished building a machine, they turn on the power and the machine starts to compute. If they have connected everything together correctly, a light goes on and a bell rings. The designers of this construction kit were very aware of the importance of good graphics and sound in keeping the child’s attention.\n\nThere are some problems with this program, however. There is a large library of parts, and none of them are identified with any text labels. Sometimes the icons are not plain enough to decode what they do. To a beginner using this program, this might be intimidating. There also is no facility for abstracting or black boxing a machine that a child has made. Some of their challenge problems require a large array of parts to be strung together, and without any means of black boxing, the screen quickly becomes a tangled mess of data flow wires. There also are no debugging tools in the programming environment. The only evidence that a machine didn’t work is that the light and sound didn’t go on. Some animation of data flow through the wires might be a plausible way to illustrate this, in addition to a testbed where the child could try out different configurations of parts to produce intermediate outputs.\n\n3.3 Video Games\n\n3.3.1 Pinball Construction Set\n\nPinball Construction Set, written by Bill Budge, is a design kit that lets kids build pinball machines and play with them. Children can choose parts from a palette of bumpers, pins, racks, and flippers to create the ultimate pinball game. Users use direct manipulation to drag parts off the palette and place them on the playing field. They can also paint a background on the game. The set allows users to control system parameters like gravity, elasticity of the bumpers, and the speed of the game itself. An advanced feature allows users to use Boolean logic to specify how points are scored based on the particular bumpers and knobs that the ball hit during play. Once the user is done constructing their game, they can press the “Make Game” button which saves the completed game on the disk for people to play. This saved version does not include the development environment, however, so finished games are not modifiable. In addition, without the original “source code,” you can not reverse engineer a pinball game to see how it was constructed.\n\nWhile Pinball Construction Set made it easy for children to create interesting pinball games for themselves and their friends, it did have some problems. It did not have any intelligence about where you were allowed to put pinball game pieces on the screen. You could easily make a structure that the ball could never reach, or a pocket where the ball would always become trapped. Fischer and Lemke argue that construction kits should have semantic knowledge of their programming domain and help the user avoid these dynamic “run-time” errors. (Fischer and Lemke, 1987-88).\n\n3.3.2 Klik & Play / The Game Factory\n\nIn a totally different genre of building tool, Klik and Play (from Maxis) and its big brother, The Game Factory (from Europress), are video game construction kits that allow kids to create Nintendo-style video games easily. Employing a form of visual programming, Klik and Play gives the programmer a large palette of characters, backgrounds and props. The user may define different scenes, or may define a large world that scrolls as the player moves around in it. The programming environment uses drag and drop to allow the programmer to directly manipulate the characters on the screen (i.e. to define a path for a particular character to run, you right-click on the character, click on the Define Path menu item and drag the character around the screen). The game uses the right mouse button to pull up context sensitive menus to affect the characteristics of an object. Once you have defined your game, you can press a button, and it turns into a standalone application, playable without the construction environment.\n\nThe Game Factory contains a large library of shapes and animations. The library is almost too large, since there isn’t much organization to its parts. Example characters and parts are only divided by their inherent types and not by their purposes in particular games. On the other hand, The Game Factory comes with several pre-built games that can be opened and edited just like any other game. This gives the beginning user a base on which to start learning how to program in the environment.\n\n4. Design Space of Video Game Construction Kits\n\nThe creation of a new construction environment for children is no easy task. One would hope to build off the lessons learned from past construction kits, as well as incorporate the latest ideas from the research in children’s learning and cognition. There have been quite a few researchers interested in children’s cognitive understanding of programming environments (Papert, 1980, 1993, 1996, diSessa and Abelson, 1986, Fischer and Lemke, 1987, Harel, 1988, Kafai, 1993, Resnick, 1994, Smith, Cypher, Spohrer, 1994, Repenning, 1994, 1996, Sargent, 1995, Umaschi, 1997).\n\nBased on this research, I have selected several broad principles for creating computational construction kits for children: understandability, uniformity and elegance, interactivity, functionality, transparency, powerful ideas, and reflection and audience.\n\nThis chapter discusses these overall design criteria for construction kits, and then speaks specifically about those issues that affect video game construction sets in particular. The next chapter proposes a new type of video game construction kit based on the conclusions of this discussion.\n\n4.1 Design Principles of Construction Kits\n\n4.1.1 Understandability\n\nThe most important task of any construction kit designer is to choose metaphors, languages, and tools that enhance the environment’s understandibility. Since non-expert users have a limited mental model of the system, the construction kit is the tool that creates an abstraction layer between the problem domain and its implementation.\n\nThe different metaphors chosen by the designer allow the users to connect the design environment to familiar objects and experiences. Logo employed body syntonicity to allow children to relate the Logo turtle’s action to their own body’s movements. Direct manipulation interfaces are used in many systems to minimize the distance between a user’s actions and their effects on the screen. Video games employ joystick controllers to directly control characters on the screen (Schneiderman, 1992). Though some abstract concepts are difficult to express, direct manipulation interfaces generally enhance understandability when used appropriately.\n\nDesign environments should also have knowledge about how their own pieces fit together, and as a result of this information, they should be able to guide the user into putting these parts together in a logical and rational way (Fischer and Lemke, 1987-88). One common pitfall for construction kits designers is to provide only the construction materials, and forget to include the instructions on how the materials are supposed to go together. Using the “view source” option, Web browsers allows users to gain access to author’s “source code.” This ability to see the underlying “real” representation of the page gives users examples of correct usage of HTML that allow them to extend their own work in new creative dimensions.\n\n4.1.2 Uniformity and Elegance\n\nUniformity and elegance are the same idea viewed from two different perspectives. Uniformity is seen by the user of system. When users encounter a consistent, uniform user interface, it enables them to learn better and reduce mistakes (Schneiderman, 1992). In a structured user interface, the users expect that each level will behave similarly—that the same gestures and commands will produce equivalent effects.\n\nElegance is uniformity seen from the programmer’s point of view. Programmers strive to achieve elegance in their design and coding. Often, this involves many code revisions, but when the finished product is done, it can often be admired as a work of art.\n\nThese two concepts may not seem connected at all, but in a construction kit, they are tied together intimately. A construction kit designer must combine a uniform interface and programming metaphors to allow the user to understand their system easily. But since the user is also going to use the kit as a construction tool, the kit must allow the user/programmer to create elegant code.\n\nUniformity and elegance are not always easy to achieve, even though they are often desired. In some cases, non-uniformity may actually aid in comprehension by exposing flaws in the programming metaphor. These flaws reveal actual implementation details that must be surfaced to the user in order to give them a clear picture of what is really going on inside the computer. For example, in Boxer, every UI element is a box or contained within one. However, when two boxes need to reference the same object (a common occurrence in most traditional programs), two linked ports are used. Ports are like boxes, but are linked, so that a change in one port is immediately seen in the other. This port is necessary to achieve a standard effect in computer programming, but violates the “naive realism” of the interface.\n\n4.1.3 Interactivity\n\n“User interfaces are often considered to be separable from programming language semantics and almost an afterthought in language design. Worse, most present languages assume only character-stream input and output. A useful medium must be much more flexibly interactive.” (diSessa and Abelson, 1986). diSessa and Abelson lamented on the state of programming environments in the mid 1980’s and the situation hasn’t gotten much better for the programming community.\n\nFor special audiences, however, construction kits being created today find ways to become more interactive with their users. The systems might support direct manipulation which allows the user to affect the objects and metaphors present in the interface as if they were concrete objects. They also might talk back to the user and suggest possible courses of action, or give the user help when they notice there might be a problem. They may support interactive program development where a child can receive instant feedback about a program change and be able to debug the program while it is running.\n\nSmallTalk and Boxer pioneered the idea of the combined user interface and programming language. Apple’s language, Dylan, had a programming environment that was a logical successor and upgrade to the SmallTalk-80 environment (Palmen, 1995). It incorporated color graphics and drag-and-drop direct manipulation, but Apple closed the project several years ago due to excessive delays in shipping. Kansas, a research project from Sun Microsystems, is a collaborative shared environment where many users can interact with each other and the system to create projects. A derivative of Self, itself a derivative of SmallTalk, Kansas supports interactive shared debugging in its networked environment by actively transporting its users to Oz, a shared graphical debugger, whenever a serious problem occurs (Smith, Wolczko, Ungar, 1997).\n\nIn programming, a construction environment that supports interactive development is necessary. If active exploration, undo/redo, direct manipulation, and feedback are part of the interface experience, then in the tradition of Boxer and SmallTalk, why shouldn’t they be also a part of the programming experience as well? These concepts would make programming easier, less frightening (since a child could try out lots of things quickly without fear of breaking the system) and bring it closer to the actual domain in which the child is working. A challenge for general-purpose construction kits is to provide some type of general direct manipulation interface without becoming too abstract in the actual problem domain that the child wishes to explore.\n\n4.1.4 Functionality\n\nThere are several different degrees of functionality that a construction environment must support. First, it must be capable enough to create a variety of outputs in the domain in which it operates. In the video game realm, it must be capable of producing a video game that supports graphics, animation, and some form of player control.\n\nOnce the basic formula has been created, what then? What extra functionality does the system support? A system could provide more interesting inputs and outputs or more modalities with which the user might control the system and receive information from it. Agentsheets and Cocoa have explored these types of functionalities quite extensively. Other systems could branch out in orthogonal directions, incorporating 3D graphics, animation creation and scripting, and complex character behavior generation.\n\nRandy Sargent explored how multiple input and output modalities affect the kinds of projects you can make. He found that the variety of activities does not increase linearly with the number of things the program can connect to, but grows exponentially. Most of the simple and interesting applications of a program can be found at the intersections between things the program can read in and things that the program can output. Since complex applications will involve more than one input/output pair, and each modality can interface to many different things in the world, the number of possible activities grows at a very high rate (Sargent, 1995).\n\nThere is a tradeoff between usability and expressiveness in domain-specific and general-purpose systems (Repenning, 1996). A domain-specific system can be used to provide highly specialized tools which are capable of producing very polished projects. Since the author of the kit understands everything about the particular domain, he may provide a complete set of tools with which to work. On the other hand, a general-purpose system is flexible enough to explore multiple domains, especially those that the designer hadn’t intended. Indeed, a creative user might use a general-purpose design kit to explore a particular domain of interest as deeply as a domain-specific tool, though the threshold might be higher.\n\n4.1.5 Transparency\n\n“Is the system made from turtles all the way down?” This Logo cliché is often used to describe systems that are created in their own programming environments. Systems like Lisp and SmallTalk are written in earlier versions of themselves and serve as platforms for programming new features. Thus, when a programmer doesn’t understand how a certain Lisp procedure works, he/she may search through the source code and read how it was done.\n\nA similar principle could be at work in construction kits for non-expert programmers. If the system is powerful and general enough to be written in itself, then when the user doesn’t understand how a piece works, he/she can choose to look at the “source code.” Some systems, like Agentsheets are not written in themselves. To create a new graphical agent or new type of rule, you must program it in Lisp. Clearly, for the person who is a perfectly comfortable user of Agentsheets and not a Lisp programmer, the system will not be extensible without having an expert programmer on call.\n\n4.1.6 Powerful Ideas\n\nConstruction kit designers have a vested interest in making a fun toolkit that children can use to explore a large design space. In order to capture the children’s interest, the scope of the design space must include topics that are personally meaningful. Video games have been in the “kid culture” since the late 1970’s, and serve as a very compelling medium for exploration.\n\nWhile a toolkit can merely be a vehicle for designing video games, it could also be utilized as a way to learn while designing. It can provide children the means to reach powerful ideas. Seymour Papert used the phrase powerful ideas to describe fundamental concepts that, when realized or learned, provide leverage for exploring new domains (Papert, 1980). Some of these concepts, like logic, probability, feedback and abstraction can be encountered while designing and implementing a video game. Comprehension of these concepts is valuable since they directly apply to many different domains, but as cognitive tools, they provide the leverage to explore and design in new domains. Life is about exploring different domains of knowledge and creating new knowledge in each of them. A person’s personal interests guide them through life’s design space and enable them to learn about new domains that are personally meaningful.\n\n4.1.7 Reflection and Audience\n\nReflection upon the design process and its result is an extremely important part of any design experience. Construction kits should support reflection in its many forms. One such form, iterative design, allows programmers to create and refine their ideas about the system they are building. Harel and Kafai asked all the children participating in their project to keep a notebook log of what they had accomplished each day. Reflection is an important part of this design process; without it, there would be no checks or bounds on the direction of the project.\n\nAnother aspect of reflection is the evaluation of the final design and product. Did it perform up to its expectations? Is there anything else to add? What modifications could be made to make it different or better? Other people might also take a look at the final product and offer suggestions. In the past, most school projects were shown off to children’s friends, or to parents on Parent-Teacher night. But, with the rise of the Web, a child can post their project for everyone to see. They can also advertise it in schools newsgroups or via mailing lists. People that the child doesn’t even know can stop by to take a look. They can comment on the work through email, perhaps suggesting new ideas or different implementations. Children can also surf the Web and see other kids’ games on the net and get new ideas for projects of their own. The Web opens up and diversifies the audience for a child’s project.\n\n4.2 Design Issues for Video Game Construction Kits\n\nThere are quite a few specific design issues for video game construction kits. Some are involved with game construction; others have to do with the programming environment and language that the child programs in. Each of the different issues affects the process of creating games and determines what kinds of games can be constructed. Through the prior analysis of both general-purpose and domain-specific construction kits, this section hopes to make clear some good directions and tradeoffs in the construction kit design.\n\n4.2.1 Game Construction\n\nThis section covers several different areas that affect how children sit down and create games. The first part examines what happens to the design process when either one or more children interact to create a project. The second part explores how the quantity and type of examples included in the kit affect the children’s exploration of design space.\n\n4.2.1.1 One Constructor or Collaborative Construction?\n\nWhile there are many different considerations for construction kit design, one that affects the programming environment the most is whether the toolkit is geared toward one constructor or a community of constructors. A one constructor model allows an easier and less complex design, since many problems that come with coordinating multiple programmers just do not occur in a single user environment. On the other hand, many children tend to work in groups on projects, whether due to lack of computer resources or while working on group activities. A construction kit that supported a collaborative video game creation environment could be quite desirable.\n\nIn a one constructor model, the construction kit designer must take care to engage the user. The environment should be simple enough to be understood by one person working alone, but support a deep enough experience that the child won’t get bored quickly. The system can also make the assumption that the single creator knows everything about the project on which they are working. It doesn’t have to resolve design conflicts that come from having more than one programmer. On the other hand, some researchers feel that the system should then take an active role in guiding the programmer towards interesting areas of the video game domain, or invite them to explore little-used, but interesting features (Fischer, 1993).\n\nA single user system can also take advantage of the multiple modalities of today’s modern user interfaces. In many computers, there are keyboard, mouse, joystick, sound, and sometimes pen inputs. Since the user is always sitting in front of the computer, the system may use all of these to create a complete user interface.\n\nAll of the early construction environments were geared towards one child construction because networking was not widespread enough. If a joint effort was desired, two kids would get behind the computer, one controlling the keyboard, and the other controlling the mouse. A few more would gather behind them and “drive” by shouting commands to them. “Move the mouse over there!” “Tell that turtle to go forward 1!”\n\nAnother more common type of collaboration occurs in classrooms where children are working on programming projects. One child will look at the other’s screen and copy anything that seems interesting. Over the course of a few hours, quite a few ideas could spread throughout the entire classroom in a form of low-tech networking.\n\nIf networking is available, then instead of asking “how many people can you fit around one computer?” you might ask “will people working at their own computers construct the same project together or work on different projects separately?” In addition, you might ask if these people will work asynchronously or synchronously with each other. Asynchronous environments like the Web enable off-line construction. People create projects by themselves and then publish them on-line. Synchronous environments allow multiple people to collaborate together in real-time to develop a project.\n\nSome existing environments have taken different stances on the above two questions, but many support more than one style of construction. MOOSE Crossing, a MOO created for kids by Amy Bruckman, supports children working on separate projects in a shared world (Bruckman, 1997). However, since MOO’s are object-oriented, children’s projects are usually related by parent-child-sibling inheritance relationships. In Kansas, a shared graphical programming environment written by Smith, Wolczko and Ungar at Sun Microsystems, researchers work together to debug problems that cause part of the system to crash (Smith, Wolczko, Ungar 1997). In Castle Infinity, an adventure game published by Starwave Corp., children must work together to solve puzzles and finish a quest in a shared graphical world.\n\nIn a collaborative environment, kit designers should consider a few policy decisions that can affect the rest of the environment and the construction process. How do the children divide up the labor? How do they assign access control and permissions on objects? How are they able to communicate with each other while working on a project? And, finally, when they are all done, how do they publish and advertise their project to everyone else?\n\nHow do the children divide up the labor?\n\nIn a shared project, children are required to work together to construct something. How should they decide how to divide up the labor? In a video game project, they each might work on the behaviors for a different character. Then they could all work together to integrate the characters into the game and help each other in the debugging. For example, if three children wanted to work on a game of Space Invaders, they might split up the three characters, aliens, hero and bullets among them. Then, when the behaviors have been completed, they can all work together to place the characters in the game. When they begin to play, each might notice some bugs or strange effects and go back and fix them.\n\nHow do they assign permissions?\n\nPermissions come into play when a child wishes to create a new object. There are many different types of permission structures. For example, in an object-oriented environment, a child may have seen some other interesting object in the system and want to make their own version. Who determines whether a child should be allowed to look inside another person’s object? The object could be controlled by no one, in an open system, or by the owner of the object, usually its creator. A child might not even need to open up an object in order to copy or subclass it. Again, the owner might allow or deny this attempt to examine the object. Generally, it is probably a good idea to let children get practice arbitrating their own privacy and permission issues, since these are pervasive policy questions in the adult world.\n\nHow do they communicate to each other while they are working?\n\nThere are several modes of communication available in a networked environment. The simplest is a small IRC-like chat window at the bottom of the screen where children can send messages back and forth. A more integrated system might take the form of a MOO, where textual interactions with other users and objects are the dominant working mode. If asynchronous communication is desired, one could support email or a public bulletin board system where children can ask each other questions and get answers. One interesting implementation of a bulletin board is an electronic white board. Every person gets a pen and can write messages to each on a shared graphical board. Taking this one step further, in a truly shared virtual world, all of the children get a mouse pointer and may manipulate shared objects in real-time. Since there is only one world, all children would be able to view any piece of it whenever they wanted. Thus, they could use the world to leave messages or objects that they have created for each other.\n\nHow do children publish and advertise their finished projects?\n\nOn many systems, designers have taken care to manage their collaborative worlds to foster a sense of community between the users. This includes providing opportunities to show off children’s work and providing the means to expose children to things that they normally wouldn’t have come across.\n\nEvery winter in MOOSE Crossing, there is a public pet show, where children who have created new an interesting pet objects come to show them off. This usually leads to a flurry of new construction activity where everyone tries to integrate the new and interesting features that they have seen into their own pet projects. While the pet show sparks some new activity, the more common social conversations on the system also provide ideas to children from each other. When one child comes to another and says, “Look at my new pet purple ostrich!” a link is formed through which ideas, feedback and suggestions may flow.\n\nIn Kansas, whenever anyone makes a big enough mistake in their program to crash the system, all of the users are transported together to Oz where they can work together to fix the problem. The users might not have known each other otherwise, but in these times of crisis, people may work together to fix someone’s project (Smith, Wolczko, Ungar, 1997).\n\nThe WWW created a new form of public bulletin board for publishing projects. Since a net connection is quite cheap, and most schools have already been wired up to the Internet, children can get their own home page without difficulty. Suitable construction media, such as Cocoa or Java, and now Bongo, allow programs to run inside web browsers. Children may use these tools to construct various projects and show them to the world. While most children’s web pages aren’t heavily trafficked, enough people will stop by and give comments on the projects and offer suggestions for improvements. This kind of anonymous feedback is very interesting. It might even be taken more seriously than feedback from a person the child knows because this anonymous person could be an “expert” in project’s domain.\n\n4.2.1.2 Construction Kit Examples\n\nExamples help the user figure out the syntax and semantics of your particular system, as well as show them examples of good style and successful designs of projects (Fischer, 1993). It is also easier to modify existing projects when you are learning than to come up with new ideas on your own. For example, 6.001, the introductory computer science class at MIT, teaches freshman and sophomore students about programming by asking them to modify or complete partially written programs.\n\nHow many examples should be distributed with the construction kit? How are they distributed? Are they modifiable? Can someone open them and understand how they were created? Examples can be packaged either as components in a library or pre-built projects. How many components should ship in the library? If the design space of this construction kit allows wide ranging exploration, then a library with just few sample objects for each category in the design space should be sufficient. But how much is enough? If too many components are in the library, the users might feel lost in a sea of possibilities. At this point, the organization of the components becomes critical. Components should be organized in multiple hierarchies, not just by object type. Users should be able to search through the component sets and easily find what they need.\n\nHow are the example projects distributed? Usually, most construction kit designers would include a few pre-built examples with their kits. However, with the rise of the Internet and the WWW as a free publishing medium, many designers have started to put new and updated projects on Web pages. Interested programmers can surf to these pages and download them. This publishing medium gives the kit creator the ability to update and add new examples over time, and it allows the programmer to gain access to new and interesting projects. Programmers can even use the Web as a transfer medium to trade projects with each other. Klik and Play and The Game Factory have a Web bulletin board where children not only share finished projects, but also help each other find and fix bugs. In addition, the public pooling of knowledge about programming techniques is valuable for beginners and experienced programmers alike. Kit designers can also use this medium as a way to get feedback on their example projects and distribution techniques.\n\nIn 1994, the 6.270 LEGO Robot Design competition was started by Fred Martin and Randy Sargent. Students, undergraduates including myself, had to build Robo-Pirates. These robots had to capture pirate treasure (pick up foam blocks) and drink pirate punch (pick up sawed off plastic soda bottles). Students could take either a defensive strategy by collecting their own treasure and punch, or take an offensive strategy, and raid the other pirate’s treasure. Most people started out with their own ideas about what to do. A few days into the contest however, one team created a robot that ran around to the back of its own pirate ship, and one by one, knocked the bottles into its basket. As soon as everyone saw this, 20 teams switched their strategies to this one. Only five teams remained on any offensive strategy, and eventually one of these won the contest.\n\nStudents in this contest were easily swayed to making simple modifications on one simple strategy, rather than branching off to make unique projects. While modifying standard projects can be a great learning activity, it stifles creativity if the design experience does not provide opportunity to create more than one iteration of a project. Had the students in the contest the opportunity to try it again, more of them would have investigated offensive strategies.\n\n4.2.2 Programming Environment\n\nThe programming environment of a game construction kit is the place where the user encounters the metaphors, functionality, and style of use that are appropriate for their task. There are some fundamental questions to ask that determine the course of the environment. The following sections give a small discussion of each issue and touch upon some advantages and disadvantages of different approaches.\n\n4.2.2.1 What can you make with it?\n\nWhat can you make with the system? How much can it do? This is ultimately tied into the architecture of the kit, whether it is general-purpose or domain-specific. There is no black and white distinction between these two, however. Each construction kit can exist on a continuum between low-level and high-level programming. Often, the designer of such a kit must help build a bridge from the bottom level implementation details of a system to the high-level domain-specific knowledge that the user will have. The real issue is how far to make each side go before deciding where exactly on the bridge they will meet.\n\nGeneral-purpose programming environments allow users and programmers to explore many personally meaningful domains of interest without getting in their way. Traditional programming languages, like C, Lisp, Logo, and Smalltalk are general-purpose enough to allow programmers to write applications in any domain that want. Some even provide enough flexibility to define themselves recursively! These languages are also Turing complete, which means that they can compute anything that any possible Turing machine (or program) can compute.\n\nEven though the designer of a general-purpose environment only has a limited idea of what to do with it, it may be used in many more domains. This gives programmers enough flexibility to create anything that they want to make, instead of limiting themselves to the environments’ authors’ imaginations. With this flexibility, however, comes some tradeoffs. Since these environments enable programmers to explore a very large design space, it becomes easy to get lost without any guidance. Usually, programmers must have a good idea of the type of project that they want to create before they sit down at the computer. Exploratory environments like Logo and Smalltalk make the conceptual development of a project easier by supporting interactive development.\n\nAnother technique for easing the cognitive burden in general-purpose construction kits is to create a situated subset environment, or microworld, in which the programmer can explore interesting ideas and problems (Papert, 1980). This new environment is limited enough to be explored completely, but complex enough to give the user a sense of understanding of powerful ideas. But, one should not create too many microworlds and present them all to the user as parts of a larger general-purpose kit. Lisp, to pick one example, has extended itself to match a number of specialized high-level domains. Due to this, it is more of a whole system than simple language. As more and more functionality is layered upon Lisp, the whole system gets more and more complicated, the documentation gets longer and longer, and the whole system becomes more difficult to learn (Hutchins, et. al. 1986)\n\nA domain-specific programming environment provides tools to support more in-depth exploration in a specific set of topics than a general-purpose kit. Good domain-specific embedded programming environments allow the programmer to deal with only the content of their work and not be bothered with the mechanics of the environment (Fischer, 1993). If one is designed well, each of its metaphors will be intuitive enough to a person skilled in the application’s domain.\n\nA good example of one of these kits is Macromedia Director. Specifically designed for creating movies, animations, and presentations, Director is highly specialized for the video domain. It contains a programming language called Lingo which is designed to make scheduling and coordination between many different media streams not just possible, but easy.\n\nAnother interesting domain-specific toolkit is SAGE (Storytelling Agent Generation Environment) (Umaschi, 1997). SAGE allows children to created embedded communication models of turn-taking-based storytelling conversations. Children can script a conversation between the computer and another child about any topic. SAGE’s programming environment allows children to create characters and describe them, create the conversation structure in a graphical form, and write stories and record them in their own voices. One interesting piece of the environment is the conversation editor. It uses a state diagram metaphor to control conversation flow between the storyteller, a story assistant and the user. State transitions or communication actions are illustrated by arrows between the states.\n\nDomain-specific languages are great to use when you don’t want the user to have to decompose their high level intentions into a long series of low-level actions in order to accomplish a task. Since the author of the environment has knowledge about their programming domain, they may write the program to take on the task of translating these high-level structures and concepts into the low-level details for the user. However, the author of a kit must watch out that the system doesn’t get too overspecified. “Beware the over-specialized system where operations are easy, but little of interest is possible” (Hutchins, et. al, 1986). A system that becomes over-specific loses what little generality it had and only becomes useful in situations for which the author has provided support. User intentions that don’t decompose into actions supported by the kit could become very hard to achieve, if not impossible.\n\n4.2.2.2 Interpreted or Compiled\n\nIs the environment in which the game is created the same environment in which it is played? If so, then the process of game development changes, as well as the possibilities for the environment’s use when the project is done. If not, then the environment behaves more like traditional compiled programming environments. (Note: I am using the terms interpreted and compiled not as references to the mechanics of the underlying language implementation, but as references to certain styles of programming. Interpreted stands in for interactive development, and compiled stands in for batch-style development where the compile/run cycle is not instantaneous.)\n\nIn an interpreted programming environment a child can actively explore different options and see how these choices might affect the outcome of the game. These environments should have support for undo and redo operations which make the price for any program change drop to almost nothing (Fischer and Lemke, 1987-88). Since the line between the program world and the runtime world is blurred, the programmer may use the environment as a laboratory, testing and playing with each piece separately, even before it is worked into the final project.\n\nA good example of an interpreted environment is Logo. Logo carried the concept of the Lisp Listener to the kids’ realm and allowed children to try out their commands interactively. When there was a problem, an interactive debugger could be invoked to help find the source of the bug. In addition, once the Logo turtle was introduced, children had a way to see the direct effect of their programs as they were run. If there was a problem in a triangle drawing routine, they could easily see the incorrect behavior as the turtle moved around on the screen.\n\nOnce a game is “finished” in a interpreted environment, nothing more must be done to make it playable. This means that the programming environment is carried along with each project. If a program has a bug, the child can debug it wherever it is being used, regardless of where it was created.\n\nAnother advantage of keeping the development environment with the finished product is support for extensibility. A game may be modified at anytime and examined by anyone. If children were working on their own games, they could examine someone else’s game to see how it was created and what kinds of algorithms it used. If the children liked a particular character, they might even be able to copy that character into their own game! Alex Repenning has a working version of a trading post on the Web where children can swap agents for their Agentsheets programs. Sometimes it is very interesting to see what happens when a piano agent is dropped in a fish tank project. Will the fish ignore the piano? Or will they try to play some jazzy tune?\n\nBy contrast, a compiled programming environment implies a different design style. For example, in a programming environment like Pascal, programmers must conceptualize large chunks of their program and write them down all at once. Then they can compile what they’ve written and test it out in a separate play environment. Children can identify bugs and problems in this environment, but must switch back to the development environment to make changes because the run-time environment is not modifiable. Since it is not easy to test out different modules before they are integrated into the whole program (professional programmers use stubs for this), children must spend significant amounts of time planning ahead. When there is such a large time and energy price in the compile/debug cycle, unbounded exploration is curtailed.\n\n4.2.2.3 Direct Manipulation\n\nDirect manipulation interfaces allow users to interact with a system through metaphors that match the way that one thinks about the system. Instead of using text-based commands to manipulate objects on the screen, a mouse can be used to drag icons representing these objects around. MacOS and Windows 95 both have direct manipulation desktop metaphors for their file systems which allow users to think of files and directories directly as icons and folders on the graphical desktop.\n\nBen Schneiderman, the researcher who coined the phrase “direct manipulation,” stipulated that these interfaces all have three properties: continuous representation of the object of interest, physical actions or labeled button presses instead of complex syntax, and rapid, incremental, reversible operations whose impact on the object of interest is immediately visible (Schneiderman, 1982).\n\nThe first real direct manipulation interface was introduced by Sutherland in 1963. His Sketchpad, a graphical design system where people could “converse rapidly through the medium of line drawing,” was a landmark because it was the first use of graphical interfaces, pointing devices, and the use of the screen as a sheet of paper (Sutherland, 1963). However, due to hardware limitations, it took about 20 years before anyone else could do anything significant with graphical direct manipulation interfaces.\n\nSince then, many advances have been made in the field, many of which have manifested themselves as commercial products. Many of the construction kits mentioned in the Chapter Three make extensive use of direct graphical interfaces to make metaphors more clear to the user. Bill Budge’s Pinball Construction Set was one of the first construction kits for PCs in the mid 1980’s. It allowed people to move pinball game parts from a palette onto a blank pinball game. Users could customize their game with their own sets of bumpers and flashers that could themselves be reshaped by a simple tug of the mouse. Since there was a direct match between the graphical kit and the problem domain, there were no syntax errors. If a part could not be placed in a particular position, then it would not let itself be dropped there.\n\nThe root of the cognitive argument for direct manipulation is to provide the user a sense of “directness” about the interface and their task. This is not a definable term, but through the exploration of various examples which have been presented above, designers can get a feel for which metaphors are direct, and which are not.\n\nOne key aspect of this directness is instant feedback. Direct manipulation interfaces should provide visual feedback for every step that the user takes in manipulating objects on the screen. In the MacOS when the user drags a file from one folder to another, a visual representation of the file moves with the mouse until the button is released and the file drops into its new folder.\n\nAnother aspect should be direct engagement with the problem domain. “Are we playing a game? Then we should be manipulating directly the game world, touching and controlling the objects in that world, with the output of the system responding directly to our actions, and in a form compatible with them” (Hutchins, et. al. 1986). Control interfaces to video games are another example of direct manipulation. A movement of a joystick or a mouse sends characters in the game moving around in their virtual world. This mapping of controller to character has been taken for granted in every video game since Spacewar! Designers of game construction kits should think carefully about the input modalities of a system to make them intuitive and directly applicable to the games.\n\nSometimes, however, direct manipulation is not appropriate. For actions that induce abstract results, perhaps no mapping of physical or virtual reality onto these domains would work. Applications that are inherently “invisible,” such as hidden state updates, might not be represented very well by physical actions of the mouse. Repetitive operations, such as sowing the field of pellets into Pac Man, can be quite tedious if no other form of abstract pellet “sprouting” is available. Direct manipulation interfaces also do not lend themselves to accurate placement of objects on the screen. Applications which require precise motion need to provide extra alternative approaches to tweaking the results to get the desired effects. It isn’t easy to line up the aliens in Space Invaders without a ruler; a more clever mathematical approach uses div and mod to place each alien in its correct place within a block formation.\n\n4.2.2.4 Abstraction\n\nAny programming system must support abstraction and blackboxing in order to reduce complexity to a reasonable level. Human beings can only think of several things at a time (Minsky, 1985). When people try to comprehend a problem, they often break it up into subproblems that are easier to solve. If the programming language does not support this method of problem solving, then users will quickly grow tired of the language and the problem itself. At the very least, the ability to name procedures and use them as building blocks for other procedures is a requirement. There are several implementations of this black boxing in the kits discussed in Chapter Three: Logo, which uses procedural lambda calculus; Boxer, which uses graphical boxes on the screen to encapsulate procedures; and Robot Odyssey, which uses a chip burning metaphor to encapsulate a data flow circuit.\n\nData flow and instruction flow systems implement black boxing in different ways. In data flow systems, black boxing enables the user to draw an interface around specific I/O ports and declare the new interface as a new basic block. One does have to be careful about documenting the I/O ports so the block does not have to be opened in order to be understood. In most traditional instruction flow architectures, a procedure is named, and separated out with documentation that specifies what it does, what kind of inputs it takes and what kind of outputs and side effects it produces.\n\nIn a video game construction kit, abstraction and black boxing take on special meaning, since usually there are several different types of characters that wish to share some common behaviors. These behaviors, if referred to in simple discrete blocks, are easily moved in and out of characters. Creating discrete blocks with no dangling pointers, however, is not easy and requires a lot of redesign. Care usually has to be taken that dangling pointers to other objects are capped with either the original objects, or instructions telling how to attach a suitable replacement once the block enters the new space.\n\n4.2.2.5 Debugging\n\nDebugging features have not been adequately thought out in current game construction kits. Debugging is still a major issue for the advanced programmer community, so this state of affairs is not surprising. What should the debugging features be and when should they be active and available?\n\nDifferent types of bugs include syntax bugs, logic bugs, and timing bugs. Syntax bugs are the easiest to fix. Usually the compiler or interpreter can flag these down as they show up and point them out to the programmer. Often, the reason for the bug is known to the compiler and a suggested fix could be offered. (I hope someday for a compiler that fixes these obvious bugs for you instead of forcing you to correct something as simple as a misplaced parenthesis.) Graphical programming helps to alleviate a lot of syntactical problems by eliminating the need for text syntax in the first place. The graphics can also provide context clues (i.e. holes for procedure arguments) about what kind of syntactic graphics can be placed in different spots.\n\nLogic bugs occur when the behavior of a running system is not what was expected. Once the code is running and the characters are moving around on the screen, perhaps you notice that the power pellet is eating Pac Man instead of the other way around. Finding these logic bugs is easy when the y are directly produced by a code error. However, in many cases, the bug might cause a nested chain of events to occur that produce a visible bug much later than the original error.\n\nThe timing bug is perhaps the most annoying of all bugs. When you have many characters on the screen that need to interact deterministically, timing issues can really get in your way. If character A is walking across the screen at 4 steps per second and character B is walking from the other side of the screen at 5 steps every other second, at what time does A need to start walking in order to make A meet B 3/4 of the way across the screen on B’s side? Debugging these timing errors is difficult since the tools for debugging dynamic run-time information such as tracing or inserting print statements alter the timing of the very code you’re trying to test!\n\nIn either interpreted or compiled programming environments, the ability to run an arbitrary piece of code with arbitrary inputs is very important in learning how a piece of code went wrong. In some cases you may want to “set up” a situation in which multiple characters are in a certain state, let the system go, and then watch it unfold in order to find out where it went wrong. Perhaps a system that records all state transitions and is able to play them back (data flow transitions + dynamic instruction flow transitions) would be useful. Football coaches tape scrimmages and games in order to reflect on them in a port-mortem attempt to identify flaws and errors that weren’t noticed during play.\n\nSometimes you don’t want your debugging to stop the rest of the system. It would be good if you could extract a malfunctioning character from a game, examine it under “laboratory” conditions and put it back in the game when you’ve corrected the problem. You could also use these laboratory conditions to alter a particular creature’s behavior in order to force a situation to occur.\n\nDarwin’s Pond, by Jeffrey Ventrella, is a laboratory for evolving many-legged locomoting creatures. If you like, you can let evolution take its course and let the system self-select for the fastest creature. But, if the budding scientist in you takes over, you may pluck a creature from the pond, tweak its genes in a beaker, and then put it back to spread the new genes throughout the gene pool.\n\n4.2.3 Programming Language\n\nThe programming model and language help shape the users’ cognitive models of the system. The first part of this section discusses different cognitive models of computation and how they affect the programs that are written. The second section discusses the influence of graphical programming on the game construction kit world. The third section explores the difference between data flow and instruction flow languages and identifies situations in which each is appropriate. The last section talks about object-oriented programming and how this can help lower the threshold for understanding how a complicated video game might work.\n\n4.2.3.1 Models of Computation\n\nThere are several different models of computation in use in the field of computer science today. While all of these are computationally equivalent to the Turing machine, they afford the user different cognitive models that have direct influences on the types of programs that may be created.\n\nThe most basic model is the Turing machine. This model uses a transition relation to define state changes in a program. Some construction kits, such as Cocoa and Agentsheets, use the Turing model as their model of programming. To make a ball fall in space, the programmer simply describes the state transition from the ball in one position to one where the ball occupies a position with lower potential energy. To make this model complete, one might also include some hidden state showing how much kinetic energy is in the ball.\n\nOne problem with the Turing model shows up when your problems get more complex. In a Turing machine, the more states you have, the bigger your transition relation. For every new object, new position, or hidden state, you need another state in your machine. There are 2n entries in a complete transition relation with n states. Clearly, this blowup has many implications on the types of projects that can be created. Simple things which don’t have much state are easy to write. But, as soon as you make your model a little more complex, the number of transitions you have to specify grows exponentially, and leads to cognitive and practical intractability very quickly.\n\nOne abstraction that improves the Turing machine is parameterized state. An example of this might be a predicate which says “if there is a ball to the left of me.” This predicate could easily stand in for quite a few states where the object in question could be in any position, with any internal state, as long as any ball is situated to the left of it. AgentSheets’ support for Visual AgenTalk is Repenning’s implementation of parameterized state machines, and in practice, affords a much higher level of control over the agents in the system.\n\nAssembly language is the fundamental language of digital computers. FUNdaMENTAL is a general-purpose construction kit that uses an extended assembly language model of programming. Conceived of and written by Justin Kitch, it was introduced as a way to allow children to build all abstractions by themselves. This technique was used as a way to make transparent all of the computation steps that a high level language tries so hard to cover.\n\nThere are several models of computation that can take over when you have many different elements in your game that act in parallel. SIMD (single instruction, multiple data), SPMD (single program, multiple instruction, multiple data) and MIMD (multiple program, multiple instruction, multiple data) provide very good abstract models for parallel computing. SIMD allows the programmer to reason about single-threaded instruction flow that acts on multiple objects. This is often called vector processing, since the multiple objects all tend to be related in some way. These multiple objects could be characters in a game. Each character is programmed the same way with the single program, though since they could have different internal state at any point they might appear to act differently.\n\nThe SIMD model is appropriate for parallel procedural programming. When you add in object-orientation to the parallelism, however, MIMD programming becomes a better model. MIMD models the same multiple objects, but each object executes its own program at its own pace, rather than all executing in lockstep. Object-oriented approaches help alleviate the hierarchical pressure on the structure of the program by providing convenient interface and black boxes around abstractions.\n\nSPMD is a simpler version of the MIMD model that enables different processes to execute independently, but removes the object-orientation from the system. This allows the programmer to write one large program that all processes may share. This model is good for the parallelization of procedural programming languages like Logo if object-orientation is not desired.\n\n4.2.3.2 Graphical or Textual Programming?\n\nIn the 1970’s, most games were written in assembly language and had to fit into very tight memory constraints. These games also required special video hardware to support this highly space efficient code. In the 1980’s, professional games were still being coded in assembly, but authors started turning to C and more platform-independent text programming languages. Once the PC was firmly entrenched, video game construction kits (which themselves were written in Assembler and C) started to appear.\n\nThe first kits embodied the same textual programming style as their authors preferred. Logo was a popular one for kids. They could program turtles to move around the screen and interact with each other. Using LogoWriter, kids could easily program simple shoot-em-up games with rudimentary sprite graphics. Since the code was in text form, children had to master syntax (already reduced in difficulty due to Logo’s designers), understanding of procedures, and the interpretation of system events in text form. MicroWorlds, the latest incarnation of Logo from LCSI, improves the graphics, sound, multimedia and parallelism of LogoWriter, and enables children to easily create good video games.\n\nSince Logo, there have been quite a few game construction kits that moved toward a more graphical programming style. The early kits ran on the Apple II with limited resolution graphics and used joysticks for a pointer. Users could choose from many different metaphors for programming, but one of the popular kits, Rocky’s Boots, involved wiring up circuits. Kids could connect up wires between inputs and outputs and see the resulting program as a large circuit.\n\nOther types of graphical programming involved translating textual languages to a graphical form to reduce syntactical programming difficulties. Logo was translated to LogoBlocks (Begel, 1996) in this way; each primitive was turned into a toy block on the screen that could be dragged around and snapped together to form a program. If a primitive needed to take an argument, there would be a hole in the block in which the argument would be the correct shape to fit. While removing the syntactical problems of programming, it still retained the sequential programming style of a textual programming language, though since programs could flow in two dimensions, branching programming flow was better revealed.\n\nAnother way to translate the textual programming into graphical form was Agentsheets, where the primitive blocks could be dropped into a stimulus-response block to build up rules. Each stimulus-response block could be dropped into another one, supporting hierarchy and nesting.\n\nOne of the latest forms of graphical programming in game construction kits is very object-oriented. Objects on the screen are containers for their attributes, such as sounds, graphics, animations and movements. The programmer can drag and drop new attributes on top of the object to give it new behaviors. Movement behaviors are illustrated by-example, where the user can draw a path for the object to follow, or are programmatically represented by defining simple motions with arrows. Collision behaviors, however, are not supported well, since there are n2 interactions between n characters. In this container-style environment, it is also not clear in which object these interaction relations should reside.\n\nAnother unresolved problem is the issue of debugging a graphical program. Graphical debugging tools are almost nonexistent, and those that do exist are in very primitive states, utilizing very little graphics and a lot of text. Are teachers able to look at students’ work to quickly see the problem and offer help? In addition, it is unclear whether graphical programming gives the programmer an enhanced understanding of program flow, data flow, or the operation of their program in any real sense.\n\nGraphical programming has its flaws, but current research in the field offers many promises. Textual programming is still here to stay, however, which is why many researchers are now looking into hybrid text/graphics programming environments that try to incorporate the best aspects of each.\n\n4.2.3.3 Data Flow or Instruction Flow?\n\nMost textual programs follow an instruction flow architecture. Sequences of code are written to be evaluated in order. The conditionals and procedure calls form the dynamic instruction scheduling of the program, so the key to understanding it is through tracing the control flow. Some graphical environments also present instruction flow models. Often, these are just graphical translations of textual programming languages, but others use the graphical nature to their advantage to help illustrate control flow through the program using tree structures on the screen. In addition, while the program is running, instruction flow can be illustrated by highlighting pieces of the program as the computation reaches them.\n\nData flow, on the other hand, has been used in limited cases in the textual world, usually through spreadsheets, where cells are linked to each other via equations. Systems that solve constraint equations are also modeling data flow. However, data flow works well in the graphical world. Borrowing from a circuit metaphor, programmers can connect computation blocks together via wires to create a data flow network. The direction of the wires determines the constraints in the program’s flow. Each computation block may either be a sequential computation or may be part of the I/O system. For instance, in Robot Odyssey, children program the robot’s head by connecting sensor inputs to motor outputs via wires. Along the way might be several computation blocks, like digital logic gates, which can control the data flowing through the wires.\n\nIn instruction flow, it is often hard to track data values or state variables as they change through the computation. Often, these state variables can be affected by numerous sources throughout the code, which makes questions like “how did that xcor get to be 5?” difficult to answer. Data flow helps alleviate this problem by making visible all of the factors that can affect a state variable or any other piece of the calculation.\n\nData flow also helps to present parallel execution. By merely expressing the constraints between the data values and not the control flow, the system is free to execute any part of the program at any time as long as the constraints are met. While this makes it difficult to visualize the algorithmic flow of the program, it alleviates the programmer and the kit implementor from having to state a specific ordering for an inherently parallel computation.\n\nInstruction flow, though, has its own method for dealing with parallel constructs. If each program were represented by a stack of blocks which execute sequentially, the parallel program could be represented by a geometrically parallel array of these stacks. These parallel stacks also fit the object-orientation model, since each stack could reside in the object that it affects!\n\n4.2.3.4 Object-Oriented Programming\n\nThe question of programming style is also an open one in the programming community. Lisp started the procedural style of programming as an implementation of the lambda calculus. It is a convenient style for expressing mathematical functions and for expressing program flow in functional style. All action takes place in disembodied procedures that take arguments as inputs on which to specialize their action.\n\nObject-oriented programming started with SmallTalk, and puts the procedures inside the objects for which they are associated. Instead of having walk and run functions that only check their input for what to do with a human or a dog, walk and run are embedded inside the creatures that support them. Dog and human can now be containers for those methods.\n\nContainer-based programming in object-oriented style is semantically equivalent to procedural programming and can be reduced to lambda calculus. But it does give many affordances to the programmer’s mental model of computation. Any object can be a container for some variables and some methods. This fits the style of most video game construction sets, since the characters in the game have some attributes and know how to perform certain tasks. Most video game construction sets are object-oriented in this way. In a game kit, objects might be implemented with two public methods: time-step and display. A global clock would send each object a time-step message and the object would update its internal state. Then a display message would be sent and any objects that had modified their visible state would be redrawn.\n\nAnother benefit to object-oriented programming is inheritance. Since dog and human both know how to walk and run, they could both inherit these methods from a mammal that knows how to do both. The methods are customized, of course, to use each instances’ unique form of locomotion. This is called shadowing, and lets each instance override methods inherited from its parent.\n\nObject-oriented programming helps reduce complexity by adding hierarchy, modularity and abstraction. Objects can choose to be transparent or opaque and expose as much or as little of their internal structure as they want to the world.\n\nOne area in which OO programming breaks down is in the interfaces between objects. When two objects collide and interact, where do the methods that control their behaviors go? In a symmetric interaction, there should be only one procedure to describe this. But, in an asymmetric encounter, different behaviors might be programmed for whether the object ran into another, or was run into by another.\n\n4.2.4 Game Structure\n\nThis section talks about the structure of the games that can be built by children. What kind of video game can you make with the kit? Is there any storyboarding involved in the game? Can the toolkit support a story-based game? How many players will there be at a time? And how are input events handled by the system?\n\n4.2.4.1 What Kind of Video Game?\n\nWith all of the discussion centered around issues in construction kit design, it might be easy to overlook the actual reason for creating the construction kit. The purpose is to create video games. But what is a video game? Are there different types? What will the scope of the kit be?\n\nIn Chapter Three, there was a discussion of several different construction kits, both general-purpose and game specific. If we could define what kinds of video games we are talking about, we might get a better idea about what specific features should be included.\n\nThere are several different types of video games, ranging from the original Pong-like arcade games of the 1960’s and 1970’s to the current Doom and Diablo. We can actually categorize games based on their chronology. Arcade games were first, beginning with SpaceWar! Video arcades grew up around the culture of playing video games and in the late 1970’s and early 1980’s this new culture took off. A new generation of children, including myself, grew up playing Space Invaders, Pac Man and Frogger. One particular favorite of mine was Moon Buggy, where you had to drive a moon rover along a bumpy landscape and avoid getting caught in the craters. These games helped kids develop a lot of hand-eye coordination, but did not do much for their mental agility.\n\nThe home gaming market took off with the Atari 2600 and continued with Nintendo’s game kit. This kit introduced the world to the Mario Brothers, who were to star in every version of Nintendo’s game kit, even up until today. With Nintendo, game designers could make goal-oriented video games. The Legend of Zelda was a particularly good game, where you had to maneuver your character through mazes and enemies to find the six crystals and put them together to defeat the evil Ganon. These games consisted of many different levels, each one bringing their own challenges.\n\nThe next type of game, the role-playing game, or RPG, was originally a personal role-playing game where several people would get together and take characters through an adventure moderated by a dungeon master. Ultima brought this game to the Apple II and enabled players to roll many different characters and play games over and over again without the hassle of finding other people or a dungeon master to play along. Players had their group of characters explore a fantasy environment to kill creatures for gold and experience. With enough experience, characters went up in levels and could learn new skills. These games took advantage of the general-purpose computer’s power to create truly complex games that took many hours to win.\n\nFor a long time, Nintendo and RPG games were just variations of earlier ones. But in 1991, Doom was introduced by Id Software. This was the first first-person viewpoint 3D adventure game. It combined great 3D graphics, rendering, and animation with a shoot-em-up atmosphere that swept homes across the country. Currently, the most popular game of this type is Quake, which added networking features so people could play each other from their own houses.\n\nGame construction kits co-evolved with these games. Soon after the first games came out on the personal computer, Bill Budge introduced his very popular Pinball Construction Set. Allowing children to create their own pinball games proved very popular, since kids could customize their own game and show off their creativity to their friends. Recently, Klik and Play, by Maxis, came out to enable kids to program their own real Nintendo-style video games. Soon, Europress Inc. will come out with The Game Factory 3D, a toolkit for creating Doom-like games.\n\n4.2.4.2 Storyboarding or Instant Play?\n\nWhile the programming of games is much simplified with construction kits, the task of figuring out what to make is still difficult. Nintendo style games include so many levels, characters and story lines that a child needs to be an accomplished writer to come up with everything. How can this cognitive load be lessened, or if not, how can the kit support complex storyboarding?\n\nFirst, let’s assume there are two types of games that the child wants to create: the shoot-em-up game and the Nintendo-style game. A construction kit may support one or both of these types of games. A shoot-em-up game requires thinking about a scenario and a background for the characters in the game. Perhaps the toolkit could provide suggestive components in its library or sample projects that could lead the child to creating certain types of games. Having a library filled with space ships and aliens would lead naturally to space adventures where the characters can shoot and kill aliens for points. One or two games could be represented in the library, which would provide enough direction for the child to easily come up with ideas for games, but wouldn’t stifle any creative ideas the child may get when they want to combine ideas from different sources into a mosaic game.\n\nIf a Nintendo-style goal-oriented game is desired, then there are issues like storyboarding, scenery, and character development involved. Before a child even sits down at the computer, they should be thinking about the game and what they would like in it. Is there a hero on a quest to save a princess? Is there gold and glory to be had? What is the reason for a person to play this game? What puzzles and challenges await the hero along the way? How are these puzzles organized? Must they be completed in order, or can the hero pick and choose the easiest ones to solve first? Are there any special tools or magic items that can help the character out during its quest? Are there any enemies or aliens to fight and get in the hero’s way?\n\nA construction kit could provide some storyboarding support for children who wish to design their game in front of the computer. Macromedia Director contains a type of storyboarding tool which uses a film based metaphor to scripts scenes and segues. Artificial intelligence systems have used thematic role frames to help computers understand scripted actions. A form of these could be used by the child to script major events in a story line. Then, the computer could help the child fill in the required details along the way.\n\nA painting system might be required for users to paint their own scenery in the game. Each screen of the game may contain similar scenery, so perhaps a morphing or graphical mutation system might be included to slightly alter each screen with respect to another. SimCity and Populous allow users to design their own landscape, complete with mountains, plains, rivers and oceans. Populous takes the metaphor that the author is a god, and can make mountains rise from the seas, or cause groundbreaking earthquakes to make the desired landscapes.\n\nA goal oriented kit should also support large-scale production. Games like Legend of Zelda are not small; they involve scores of scenes, and many different transitions. If a kit supported scene cloning, or random monster generation, a child could concentrate on the story line and not get bogged down in boring details.\n\n4.2.4.3 One Player or Many Players?\n\nA multi-player game requires more ingenuity of design than a single-player game. Obviously, the controls for the game need to be duplicated or extended to support the second player. A more subtle problem might be synchronization between different characters and different players trying to affect them.\n\nWhere do the players physically reside? They can either all play at one computer, or play at many computers. If they are on one computer, they must contend for resources. There is only one mouse, one joystick and one keyboard. Often, each player will get a few keys on the keyboard to themselves. Are the keys customizable?\n\nPlaying on multiple computers requires networking support. It brings up questions of where the game lives. Is it client-server based, or is it distributed? In games like Quake and Diablo, there is a central server hosted by the game manufacturer that is a clearinghouse for distributed localized game servers. Your version of Diablo connects to the main server to find out where a local server is and then connects to the local one to join the game. dMOO, a distributed MOO from Intel explores object architecture issues in distributed systems. User’s objects may contain several replicated copies that exist on many servers. Actions that affect each object are transmitted through to each copy in a lazy consistency model.\n\nHow much interaction will the players have? If multiple people are in the world, the object might be creative collaborative construction, as in MOOSE Crossing. It might be Diablo’s model, where players can band together to kill monsters, or kill each other. Is it easy for kids to design games that require collaboration? This question remains to be explored.\n\n4.2.4.4 Environmental Events\n\nOnce the programming paradigms have been chosen, how should the system react to the player? In most video games, the interaction comes from a joystick, mouse, keyboard, or network. The system can either embed these interactions in an interaction object, or the user could embed these interactions in each object that needs to react to them.\n\nIt makes sense to embed procedures inside objects. But what happens when the object causing the interaction is not “in” the game? External events come in asynchronously and affect the characters of the game. If the characters don’t expect them, then the action could interrupt whatever they might be doing at the time. If characters instead poll for the events, they will never be interrupted unless they are ready to receive an event.\n\nThe event could be embedded inside its own “breed” of objects. When a key-up event comes in, it might affect two or three different characters. Inside the event, there must be several places to identify the characters to that will be affected and what to do to them. This approach, while linking the action to the effect, in fact disembodies the effect from the characters it is affecting. There is also another disadvantage. A key-up event and a joystick-up event should rightly go into separate objects, but they might have the same semantic effect on the characters of the game.\n\nThe other approach is to embed the event polling inside the character that wishes to receive it. If the system notices an event comes in, on the next time-step message, it would include an event. If the key-up event came into the character and the character wished to respond, it could do anything it wanted. All characters would receive their own key-up notification at the same time, and all effects would be localized to the character which they were affecting. This option allows the kit designer to abstract the lexically different events into semantic groupings and provide the characters with ways to recognize these semantic groups. This reduces duplication of code and brings the programmer closer to the semantic meaning of the program they are writing.\n\n5. Bongo: Video Game Construction Kit\n\n5.1 Overview\n\nNow that many of the design considerations for creating construction kits for children have been enumerated and discussed, is it possible to create a construction kit that has all or many of the desirable qualities? This chapter describes a design and implementation for a video game construction kit that was designed around the discussion from the previous chapter and attempts to achieve the seven goals of understandability, uniformity and elegance, interactivity, functionality, transparency, powerful ideas, and reflection and audience.\n\nThis video game kit’s scope includes Atari 2600 style arcade games, like Pac Man, Frogger and Space Invaders. There are other game construction kits which attempt a broader scope to make Nintendo and Doom-like games, but we feel that there is enough creative design space open for children to make very interesting arcade games. In addition, since arcade games usually don’t get very complex, they would give an easy-to-learn game model that could be modified easily.\n\nThe video game kit produces standalone web pages with the games inside. This allows kids to publish their games on the Web, and allows other children to use them and share them. This publication takes place on a central server, so children can easily get access to a large quantity of sample projects and projects created by other children for inspiration and help in their own games. Currently, game design takes place off-line and involves one or more children sitting in front of one computer. In the future, this toolkit could be attached to a web site, and children who surf by will be able to not only play, but also create their own games on-line.\n\nThe programming environment for the video game toolkit is a text/graphics hybrid. Drag and drop is used in the high-level movement of objects in the interface, but text-based procedural programming in the Video Game StarLogo language is used for programming behaviors for the characters in a game. There also is a command center, where users can interactively try out commands with their characters and see the results run instantly. This makes this kit very similar in feel to Logo. But it is more domain-specific, since it allows users to easily create breeds of characters that can respond to the user and execute code on every clock-tick. It is not so specific, however, that it could not be used for normal Logo or StarLogo programming. Actually, this kit merely implements a different interface to the StarLogo kernel.\n\nObject-orientation is very important in the design of this kit. It uses a container-based form of object-orientation, similar to Boxer, where most objects are containers for other things. For example, in the game character container, there are several sub-containers: a shape container, a sound container, an event code container, a time-step code container, and an auxiliary code container. Each of those sub-containers holds other objects like shapes, sounds and code. This contai"
    }
}