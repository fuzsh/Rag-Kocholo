{
    "id": "dbpedia_3411_0",
    "rank": 16,
    "data": {
        "url": "https://comp.lang.lisp.narkive.com/LAHwUxoz/yet-another-smalltalk-or-lisp-discussion-windows-centric",
        "read_more_link": "",
        "language": "en",
        "title": "Yet another Smalltalk or Lisp discussion (Windows Centric)",
        "top_image": "https://narkive.net/favicon.ico",
        "meta_img": "https://narkive.net/favicon.ico",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "https://narkive.net/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Ken Tilton\n\nPost by Chris Uppal\n\nPost by Ken Tilton\n\nSo the macro issue gets swept under the rug with \"OO for ST, macros for\n\nLisp\"?\n\nUp until that point I had imagined that your post was intended to contribute to\n\na sensible discussion of these options and issues. I see that I was wrong.\n\nFunny, it was at the same point in your article that i was disappointed\n\nto see the hand-waving in which ST's lack of macros got excused as \"hey,\n\nwe use OO, they use macros\". I appreciated the artfulness of that\n\ndodge, but felt it needed exposing: all that feel-good,\n\ndifferent-strokes stuff distills to: \"ST does not have macros\".\n\nthe \"abstraction\" fig leaf will not stretch far enough to cover ST's\n\nlack of macros. I happen to be a big a fan of OO as well as macros and\n\nleverage OO all over the place, and OO simply does different things.\n\nLet's look at some code:\n\n(c? (bwhen (mp (mouse-pos .og.)) ;; mouse-pos is a function\n\n(without-c-dependency\n\n(find-ix-under self mp)))) ;; find-ix is a function\n\nInside out on the macrology:\n\n(c? (bwhen (mp (mouse-pos .og.))\n\n(let (cells::*call-stack*) ;; wo-c-d hid implementation\n\n(find-ix-under self mp))))\n\nNext we look at bwhen, which simply extends CL to include a frequent\n\npattern in my coding:\n\n(c? (let ((mp (mouse-pos .og.))) ;; BWHEN condenses a bind-test pattern\n\n(when mp\n\n(let (cells::*call-stack*)\n\n(find-ix-under self mp)))))\n\nOh, hang on, I just noticed .og. That expands to:\n\n(or (clo::ogl-context self)\n\n(setf (clo::ogl-context self) (upper self togl)))\n\nOpenGL contexts are not around during window startup, and my frameworks\n\ndo an awful lot during startup (and I try to make coding easier by not\n\nhaving to worry about order).\n\nUpper? I love that one, use it all the time in GUI hierarchies:\n\n(container-typed self 'togl)\n\nPut it all together and:\n\n(c? (let ((mp (mouse-pos (or (clo::ogl-context self)\n\n(setf (clo::ogl-context self)\n\n(container-typed self 'togl))))))\n\n(when mp\n\n(let (cells::*call-stack*)\n\n(find-ix-under self mp)))))\n\nC? That is the key macro in my Cells framework (see sig). That hides a\n\n/lot/ of implementation boilerplate (two diff things worth hiding):\n\n(cells::make-c-dependent\n\n:value-state :unevaluated\n\n:rule (lambda (cells::slot-c\n\n&aux\n\n(self (cells::c-model cells::slot-c))\n\n(.cache (cells::c-value cells::slot-c)))\n\n(declare (ignorable .cache self))\n\n(let ((mp (mouse-pos .og.))) ;; .og. back in for brevity\n\n(when mp (let (cells::*call-stack*)\n\n(find-ix-under self mp))))))\n\nInstead of:\n\n(c? (bwhen (mp (mouse-pos .og.))\n\n(without-c-dependency\n\n(find-ix-under self mp))))\n\nSince I write a ton of code using these macros, one can see the\n\nadvantages in writing, reading, and refactoring. And I subscribe to the\n\nrule \"no unecessary macros\", so if this kind of thing could be done with\n\nOO or functions or lambdas (blocks) it would have been.\n\nHope that is \"sensible\" enough for you. :)\n\nken\n\n--\n\nCells: http://common-lisp.net/project/cells/\n\n\"I'll say I'm losing my grip, and it feels terrific.\"\n\n-- Smiling husband to scowling wife, New Yorker cartoon\n\nKen Tilton\n\nPost by Chris Uppal\n\nAnd also there's my feeling that Lisp is just not as suitable a target for an\n\ninteractive environment as a pure OO language like Smalltalk -- the issue being\n\nthat there is nothing sensible to interact /with/ (so you end up with a\n\ntarted-up version of a read-eval-print loop).\n\n? One interacts with Lisp. The GUI is just a surface manifestation (I\n\nassume you have heard of MVC). Add Tk or GTk to a Lisp and away you go.\n\nThe idea that Lisp applications (and an IDE is just another application)\n\nare limited to the REPL is ridiculous. The AllegroCL IDE includes a REPL\n\nwindow, I just never use it.\n\nPost by Chris Uppal\n\nThat problem would not occur if\n\nthe environment committed itself fully to the OO approach to Lisp,...\n\nTalk about a category error. What has OO got to do with it? My only\n\nguess is that you have been doing all-objects-all-the-time too long and\n\nsomehow think that that is the only way to program and/or build GUIs\n\nhence IDEs.\n\nYou need to get out more. Even commercial Lisp GUIs such as CAPI and\n\nCommon Graphics are powerful enough to build an ST IDE. Same with C GUIs\n\nused from Lisp, such as Tk and GTk.\n\nAnd thanks to all the other power of Lisp, when confonted with\n\nespecially dynamic GUI requirements I almost accidentally developed a\n\ndataflow hack (see sig) that makes insanely dynamic and interactive GUIs\n\na breeze to develop even atop toolkits developed with (yes) a static\n\nmindset. All that macrology I expanded last time was from that library\n\n(Cells).\n\nST developers have given ST programmers a lot of good stuff for dynamic\n\nGUI development, but only those things the ST environment developers\n\nhave seen fit to support. Start hand-rolling a more sophisticated scheme\n\nlike Cells and the results are awful because there are no macros with\n\nwhich to hide the boilerplate.\n\nPost by Chris Uppal\n\nand\n\nbasically said \"if you aren't using CLOS for everything then we don't give a\n\ndamn about you\"\n\nOK, so you /do/ misunderstand OO to be somehow necessary to an IDE. The\n\nAllegroCL IDE also let's me manage symbols, a backtrace, and generic\n\nfunctions as well as objects. And I almost never use the object browser\n\nbecause it is much easier to use the \"find symbol definition\" keychord\n\nto get to the source (and because the information shown in object\n\nbrowsers other than method source is rarely what I am looking for).\n\nPost by Chris Uppal\n\n-- but I can't imagine that being very popular ;-) (And in\n\nany case, if you want that kind of environment, why not just use Smalltalk ?)\n\nMy reasons are: no macros, no multiple-inheritance, and I do not like an\n\nIDE getting between me and editing when i am refactoring and touching\n\ndozens of bits of source at once.\n\nkt\n\n--\n\nCells: http://common-lisp.net/project/cells/\n\n\"I'll say I'm losing my grip, and it feels terrific.\"\n\n-- Smiling husband to scowling wife, New Yorker cartoon\n\nM***@gmail.com\n\nPost by Chris Uppal\n\nPost by M***@gmail.com\n\nIt looks like right now, the best way forward is for SBLC to get the\n\nwindows port done, a 1.0 release, a modern, fast crossplatform gui, and\n\nthen someone(s) can start developing a modern, highly-interactive,\n\ndevelopment environment for it.\n\nI don't want to knock the SBCL people, and I admit that I know very little\n\nabout the whole thing, but still I doubt whether that will ever happen. The\n\nprinciple problem any such effort would face is the fact that it has started in\n\nthe wrong place -- on Unix-like systems[*].\n\nIt's my understanding that the windows port is getting there. How fast\n\nI don't know. I think they would have to realize the importance of a\n\nwindows port by now.\n\nI don't see any reason in\n\nPost by Chris Uppal\n\nprinciple why the various cross-platform UI toolkits couldn't be used to create\n\na /good/ environment, but I have never seen anything that even remotely came\n\nclose to putting that idea into practice. (I speculate that one reason may be\n\nthat many such toolkits -- or rather, the few which are capable of producing\n\ndecent results -- have been produced by programmers with a very static\n\nmind-set.)\n\nI had an idea of taking the native C libraries of SWT and working with\n\nthat. At least you have nice looking GUIs on Windows and Unix.\n\nPost by Chris Uppal\n\nThat's in addition to the observation that many programmers have never /seen/ a\n\ndecent interactive environment, and so have no idea what they are missing or\n\ncould be building. (I may as well be explicit -- in addition to my early\n\ndisclaimer -- that I have no idea whether this observation applies to the SBCL\n\npeople.)\n\nAnd also there's my feeling that Lisp is just not as suitable a target for an\n\ninteractive environment as a pure OO language like Smalltalk -- the issue being\n\nthat there is nothing sensible to interact /with/ (so you end up with a\n\ntarted-up version of a read-eval-print loop). That problem would not occur if\n\nthe environment committed itself fully to the OO approach to Lisp, and\n\nbasically said \"if you aren't using CLOS for everything then we don't give a\n\ndamn about you\" -- but I can't imagine that being very popular ;-) (And in\n\nany case, if you want that kind of environment, why not just use Smalltalk ?)\n\nIt seems that CLOS would be a natural fit for a development enviornment\n\n(at least the presentation parts). Personally, I have nothing against\n\nSmalltalk. In fact i have this thing called Vista Smalltalk that can\n\nrun in a browser up right now, but I'd rather have the full power of CL\n\nalong with the environments preferably.\n\nPost by Chris Uppal\n\n-- chris\n\n[*] I am very fond of Unix, btw, but GUI stuff on Unix is pretty uniformly\n\nterrible -- or if there are any counterexamples, then /I/ haven't seen 'em.\n\nPascal Costanza\n\nPost by Chris Uppal\n\nPost by Pascal Costanza\n\nThe characterization of macros for performance or for getting around\n\nlanguage restriction is definitely wrong.\n\n[...]\n\nA very simple example is a while-loop. With a functional abstraction,\n\nyou can basically express this as a higher-order function that accepts\n\nThen why is it that Smalltalk's while loops[*] and other control structures\n\n(including the many user-defined ones) are implemented without macros ?\n\n(I did read the rest of your post, btw, so I know that you know about\n\nSmalltalk's blocks)\n\nI didn't say that macros are required to implement control structures. I\n\nsaid that macros are required to abstract over certain implementation\n\ndetails of such control structures.\n\nPost by Chris Uppal\n\nPut it like this. If Lisp had (mabe it has, for all I know) a simple and clear\n\nsyntax for indicating deferred evaluation, then are there any cases where\n\nmacros are used that could not be replaced by an combination of ordinary\n\nfunctional evaluation (possibly introspective), and the application of that\n\nsyntax ?\n\nIn the book \"On Lisp\", Paul Graham lists the following uses for macros:\n\n+ Implicit quoting. For example, creating a function definition could be\n\naccomplished with a function, roughly like this:\n\n(define-function 'display (lambda (object) ...))\n\nThe need to use a quote in front of 'display instead of just leaving it\n\nout is inconvenient. (And there are more interesting cases for this.)\n\n+ Cosmetics. The idea here is that sometimes, a macro can just help to\n\nmake the code look nicer. This is especially interesting for embedding\n\ndomain-specific languages where it may make sense to tweak the syntax\n\nsuch that it gets closer to known notations from the problem domain.\n\n+ Controlling evaluation. This is basically the example we have already\n\ndiscussed.\n\n+ Side effects. It's not possible to express side effects in terms of\n\nfunctions. So for example, functionality like pushing and popping\n\nelements to/from a list that's stored in a variable can only be\n\nexpressed as a macro. In Smalltalk, this is not evident because there\n\nyou get an implicit indirection by storing such data inside objects, but\n\nit wouldn't be possible to express more \"direct\" manipulations in terms\n\nof blocks either. (Maybe you don't care, but this doesn't invalidate\n\nthis observation.)\n\n+ Efficiency. However, this is actually one of the worst reasons to use\n\na macro. If you express something as a macro that could as well be\n\nexpressed as a function, it's better to indeed express it as a function.\n\nOtherwise, you lose the ability to pass it around as a first-class\n\nvalue. Macros are not available as first-class entities at runtime in\n\nthis sense.\n\nThe two better means to achieve better efficiency are:\n\n- Declaring that a function may be inlined. This is a standard\n\ndeclaration in Common Lisp, so you can just say something like (declaim\n\n(inline foo)).\n\n- Providing a compiler macro. This allows you to define a function as\n\nbefore, but additionally give hints to the compiler how it can be\n\ntranslated differently when it is directly called. With compiler macros,\n\nyou can also perform ad-hoc partial evaluation, and other nifty things.\n\nEspecially because of compiler macros, one can safely claim that macros\n\nshould actually _never_ be used for efficiency.\n\nThere are probably other uses for macros, but these are the most\n\nimportant. In general, \"syntactic abstractions\" is a good umbrella term\n\nfor these uses.\n\nPost by Chris Uppal\n\nIf not, then the only reason for using them (in this hypothetical\n\nnear-lisp) would be to optimise runtime computation into compile-time\n\ncomputation. My personal feeling is that such optimsation should be done by\n\nthe compiler (partial evaluation perhaps) not by the programmer.\n\nCompilers and virtual machines can only perform optimizations up to a\n\ncertain extent. For example, they can indeed detect typical usage\n\npatterns and generate specific code for such cases. Virtual machines\n\nhave actually very far in this regard (and Strongtalk is a pretty\n\nimpressive example here). However, for more domain-specific or less\n\ntypical uses of a language, it is probably better to also provide ad hoc\n\nhints to a compiler / runtime system.\n\nPost by Chris Uppal\n\nPost by Pascal Costanza\n\nThere is a problem with this code, though. The problem is that the\n\nwhile/function definition leaks an implementation detail, which is the\n\nrequirement that client code explicitly uses blocks / lambda expression.\n\nHowever, as a programmer of client code I am actually not interested in\n\nthat detail.\n\nNow this I don't agree with. It is simply not the case that the time when code\n\nis executed is an implementation detail. E.g. in the following code (in C for\n\nneutrality ;-)\n\nif (x == NULL)\n\nkaBoom(\"!!!!\");\n\nit is vital for understanding the code that you can see that kaBoom() is not\n\nexecuted except under certain circumstances. In C, with its fixed set of\n\ncontrol structures, there is no need for special syntax to communicate that\n\n(either to the reader or the compiler); but in languages where\n\nprogrammer-defined control structures are the rule rather than the exception, I\n\nthink that syntactic uniformity between always-evaluated expressions and\n\ndeferred evaluations is /not/ an advantage.\n\nWell, let's just agree that we disagree here. ;)\n\nPost by Chris Uppal\n\n(BTW, and wandering off-topic, I have met C/C++/Java programmers who consider\n\nthe short-circuit evaluation rules of && and || to be a \"detail\" -- even to the\n\npoint of recommending that programmers don't rely on it ! They are, of\n\ncourse, completely wrong ;-)\n\nAhh, it's good to know that we Lispers and Smalltalkers can always agree\n\nwhen it comes to Java-bashing. ;-)\n\nPost by Chris Uppal\n\nAnyway, that's why I say that Lisp's macros should be thought of as a fix for\n\nwhat would otherwise be problems in the language. I'm not at all suggesting\n\nthat they aren't a /good/ fix, nor that they are not a very valuable feature of\n\nLisp. But I /am/ suggesting that for someone to denigrate another (any other)\n\nlanguage for lacking them would only be valid if that language had similar\n\n\"problems\". All languages have their own toolkits for doing various kinds of\n\nabstraction. When deciding which languages best suit you (or a given task) the\n\nquestion to ask is not \"what tools are available?\" but \"what kinds of\n\nabstraction are available?\". And then the next questions is whether the kinds\n\nof abstraction are the ones that you want (or need) to use. I have no problem\n\nat all with the idea that some people want to use abstractions which don't fit\n\ninto the Smalltalk way, and it is perfectly possible that the OP is one of\n\nthose people. But what I /do/ think is a mistake is to dismiss Smalltalk\n\nwithout knowing what kinds of abstraction /it/ provides, let alone trying them\n\nfor long enough to know how well they fit with one's own way of thinking.\n\nI am not dismissing Smalltalk because it lacks macros. I have other\n\nreasons for preferring Lisp over Smalltalk. I actually think there are\n\nfeatures in Smalltalk that work better than in Lisp, but they weigh less\n\nin my personal opinion than the advantages that Lisp has. (Especially, I\n\nthink the image-based development model works better in Smalltalk.)\n\nPost by Chris Uppal\n\nPost by Pascal Costanza\n\nIn this context it is worthwhile to note that a Smalltalk compiler\n\ninternally recognizes its implementation-provided iteration constructs\n\nand treats them specially such that the blocks are actually transformed\n\ninto \"direct\" code.\n\nJust for completeness, that isn't quite true. Most Smalltalk compilers do\n\nrecognise, and special-case, a small number of fixed control-flow messages\n\n(#ifTrue:ifFalse: #whileTrue: and some others), but the bulk of uses of blocks\n\n(e.g. iterating over a collection) do exactly what they look as if they are\n\ndoing.\n\nHm, maybe my wording wasn't clear enough, but I actually meant exactly\n\nthese special cases.\n\nPascal\n\n--\n\nMy website: http://p-cos.net\n\nCommon Lisp Document Repository: http://cdr.eurolisp.org\n\nCloser to MOP & ContextL: http://common-lisp.net/project/closer/"
    }
}