{
    "id": "dbpedia_3411_3",
    "rank": 76,
    "data": {
        "url": "https://nedbatchelder.com/blog/200910/the_scalability_of_programming_languages.html",
        "read_more_link": "",
        "language": "en",
        "title": "The scalability of programming languages",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.gravatar.com/avatar/441f241b6c51d8a0525d1cf8a39060e2.jpg?default=https://nedbatchelder.com/pix/avatar/a237.jpg&size=80",
            "https://www.gravatar.com/avatar/75e9a11371cbe1566607180863efdf4c.jpg?default=https://nedbatchelder.com/pix/avatar/a107.jpg&size=80",
            "https://www.gravatar.com/avatar/7d073489131f94706eb9b768d1496416.jpg?default=https://nedbatchelder.com/pix/avatar/a141.jpg&size=80",
            "https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e.jpg?default=https://nedbatchelder.com/pix/avatar/a218.jpg&size=80",
            "https://www.gravatar.com/avatar/75e9a11371cbe1566607180863efdf4c.jpg?default=https://nedbatchelder.com/pix/avatar/a107.jpg&size=80",
            "https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e.jpg?default=https://nedbatchelder.com/pix/avatar/a218.jpg&size=80",
            "https://www.gravatar.com/avatar/434aee9ad675384a9e745c7217ac4abe.jpg?default=https://nedbatchelder.com/pix/avatar/a56.jpg&size=80",
            "https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e.jpg?default=https://nedbatchelder.com/pix/avatar/a218.jpg&size=80",
            "https://www.gravatar.com/avatar/fc4e87404460de85f5317c60f73e6a5e.jpg?default=https://nedbatchelder.com/pix/avatar/a114.jpg&size=80",
            "https://www.gravatar.com/avatar/8655af306af892b159b576979134b70b.jpg?default=https://nedbatchelder.com/pix/avatar/a94.jpg&size=80",
            "https://www.gravatar.com/avatar/4f2ee6ab1eb6cfc7fe2097d5df875ac1.jpg?default=https://nedbatchelder.com/pix/avatar/a110.jpg&size=80",
            "https://www.gravatar.com/avatar/f4443b09ffb634fb76994d519521b047.jpg?default=https://nedbatchelder.com/pix/avatar/a269.jpg&size=80",
            "https://www.gravatar.com/avatar/108534f65d8d2d7de6995973c1f49889.jpg?default=https://nedbatchelder.com/pix/avatar/a64.jpg&size=80",
            "https://www.gravatar.com/avatar/4eddef6a78dad0b44ccd255e5ccc3dff.jpg?default=https://nedbatchelder.com/pix/avatar/a167.jpg&size=80",
            "https://www.gravatar.com/avatar/e04ba8565a82423fc6b401d092bc5a39.jpg?default=https://nedbatchelder.com/pix/avatar/a21.jpg&size=80",
            "https://www.gravatar.com/avatar/e3300c2b45ba7e55043ebf00207c4e49.jpg?default=https://nedbatchelder.com/pix/avatar/a68.jpg&size=80",
            "https://www.gravatar.com/avatar/aec7ecc679a19ea6db7e4d73dfb2d627.jpg?default=https://nedbatchelder.com/pix/avatar/a187.jpg&size=80",
            "https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e.jpg?default=https://nedbatchelder.com/pix/avatar/a218.jpg&size=80",
            "https://www.gravatar.com/avatar/7d073489131f94706eb9b768d1496416.jpg?default=https://nedbatchelder.com/pix/avatar/a141.jpg&size=80",
            "https://www.gravatar.com/avatar/4f2ee6ab1eb6cfc7fe2097d5df875ac1.jpg?default=https://nedbatchelder.com/pix/avatar/a110.jpg&size=80",
            "https://www.gravatar.com/avatar/e8cd8792905e2bbcabc53c718959fb4c.jpg?default=https://nedbatchelder.com/pix/avatar/a95.jpg&size=80",
            "https://www.gravatar.com/avatar/cb09f569d2572bd00baec8da68a88201.jpg?default=https://nedbatchelder.com/pix/avatar/a9.jpg&size=80",
            "https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e.jpg?default=https://nedbatchelder.com/pix/avatar/a218.jpg&size=80",
            "https://www.gravatar.com/avatar/4f2ee6ab1eb6cfc7fe2097d5df875ac1.jpg?default=https://nedbatchelder.com/pix/avatar/a110.jpg&size=80",
            "https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e.jpg?default=https://nedbatchelder.com/pix/avatar/a218.jpg&size=80",
            "https://www.gravatar.com/avatar/4f2ee6ab1eb6cfc7fe2097d5df875ac1.jpg?default=https://nedbatchelder.com/pix/avatar/a110.jpg&size=80",
            "https://www.gravatar.com/avatar/75e9a11371cbe1566607180863efdf4c.jpg?default=https://nedbatchelder.com/pix/avatar/a107.jpg&size=80",
            "https://www.gravatar.com/avatar/7d073489131f94706eb9b768d1496416.jpg?default=https://nedbatchelder.com/pix/avatar/a141.jpg&size=80",
            "https://www.gravatar.com/avatar/75e9a11371cbe1566607180863efdf4c.jpg?default=https://nedbatchelder.com/pix/avatar/a107.jpg&size=80",
            "https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e.jpg?default=https://nedbatchelder.com/pix/avatar/a218.jpg&size=80"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-10-24T08:33:23",
        "summary": "",
        "meta_description": "<a href=\"http://tabblo.com\" rel=\"external noopener\">Tabblo</a> is written on the Django framework, and therefore, in Python. Ever since we were acquired by Hewlett-Packard two and a half years ago, there’s been a debate about whether we should start working in Java, a far more common implementation language within HP.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://nedbatchelder.com/blog/200910/the_scalability_of_programming_languages.html",
        "text": "Tabblo is written on the Django framework, and therefore, in Python. Ever since we were acquired by Hewlett-Packard two and a half years ago, there’s been a debate about whether we should start working in Java, a far more common implementation language within HP. These debates come and go, with varying degrees of seriousness.\n\nThe latest wave of “Java?” debating is upon us, and Mike Vanier’s The Scalability of Programming Languages has been entered into evidence. I found it a very interesting read, especially about static vs. dynamic typing. At one point, Mike says,\n\nWhat typically happens in large projects written in these languages is that extensive unit tests are written to catch type errors as well as logical errors ...\n\nI think Mike meant this as a negative, but I don’t see how it is. Extensive unit tests are a good thing, especially since they catch logical errors as well as type errors. The static type people either don’t have such tests, in which case nothing is catching their logic errors, or they do have such tests, in which case they didn’t need the static type checking in the first place.\n\nStatic type adherents claim that their type declarations give them both documentation of what’s expected, and automatic checking of code. But it only gives you a small amount of either.\n\nFor example, a parameter to a function has to be a string, so you declare it as String, and the compiler can guarantee that it is a String. But that’s just one small aspect of the rules about the parameter. Can it be NULL? Can it be empty? What’s it supposed to represent? An IP address? Can it be a wild-carded IP address? Can it be a comma-separated list of such addresses?\n\nThe questions beyond “String” go on and on, and static type checking gives us help with none of them. There’s the temptation to slice the universe ever more finely to get the type system to carry some of this information. So you’ll end up with IpAddress types, and WildcardableIpAddress, and so on. Those are good things, since you will likely have methods on IP addresses that you want to perform, so building classes will help. But there are always distinctions between instances that can’t be expressed in the type system. The only way to get at them is at run time. You can decide which run time you want to find them: in tests or in real use. Tests are the better answer.\n\nThe rest of the essay is interesting, especially Mike’s postscripts where his changes of viewpoint are recorded. It’s worth a read, if only for its exposition of the considerations that go into programming language design. He doesn’t get caught up in shallow issues like syntax, but gets at the deeper factors in programming languages that affect the outcome of projects that use them."
    }
}