{
    "id": "dbpedia_108_3",
    "rank": 44,
    "data": {
        "url": "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/",
        "read_more_link": "",
        "language": "en",
        "title": "CSS Fonts Module Level 3",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.w3.org/StyleSheets/TR/2016/logos/W3C",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/aaaaaa.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/serifvssansserif.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/minchovsgothic.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/aaaaaa-diacritics.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/final-ligature.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/lamaleflig.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/weightwidthvariations.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/familyvsfacename.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/localizedfamilynames.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/serifexamples.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/sansserifexamples.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/cursiveexamples.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/fantasyexamples.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/monospaceexamples.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/optimaweights.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/hiraginoweights.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/universwidths.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/realvsfakeitalics.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/fontsizeadjust.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/beforefontsizeadjust.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/fiddlesticks-regular.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/fiddlesticks-synitalics.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/fiddlesticks-italics.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/locl-1.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/locl-2.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/locl-3.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/liga.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/dlig.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/hlig.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/calt.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/realsubscripts.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/superscript-alt-synth.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/smcp.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/synthetic-vs-real-small-caps.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/small-capitals-variations.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/acronym-laden-text.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/numberstyles.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/frac.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/afrc.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/ordinals.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/zero.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/jp78.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/trad.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/pwid.png",
            "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/rubyshinkansen.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/",
        "text": "Abstract\n\nThis CSS3 module describes how font properties are specified and how font resources are loaded dynamically. The contents of this specification are a consolidation of content previously divided into CSS3 Fonts and CSS3 Web Fonts modules. The description of font load events was moved into the CSS Font Loading module.\n\nStatus of this Document\n\nThis section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at https://www.w3.org/TR/.\n\nThis document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.\n\nThis document was produced by the CSS Working Group as a W3C Recommendation..\n\nThis document was produced by a group operating under the W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.\n\nThis document is governed by the 1 February 2018 W3C Process Document.\n\nA test suite and implementation report are available.\n\n1. Introduction\n\nA font provides a resource containing the visual representation of characters [CHARMOD][UNICODE]. At the simplest level it contains information that maps character codes to shapes (called glyphs) that represent these characters. Fonts sharing a common design style are commonly grouped into font families classified by a set of standard font properties. Within a family, the shape displayed for a given character can vary by stroke weight, slant or relative width, among others. An individual font face is described by a unique combination of these properties. For a given range of text, CSS font properties are used to select a font family and a specific font face within that family to be used when rendering that text. As a simple example, to use the bold form of Helvetica one could use:\n\nbody { font-family: Helvetica; font-weight: bold; }\n\nFont resources may be installed locally on the system on which a user agent is running or downloadable. For local font resources descriptive information can be obtained directly from the font resource. For downloadable font resources (sometimes referred to as web fonts), the descriptive information is included with the reference to the font resource.\n\nFamilies of fonts typically don't contain a single face for each possible variation of font properties. The CSS font selection mechanism describes how to match a given set of CSS font properties to a single font face.\n\n2. Typography Background\n\nThis section is non-normative.\n\nTypographic traditions vary across the globe, so there is no unique way to classify all fonts across languages and cultures. For even common Latin letters, wide variations are possible:\n\nDifferences in the anatomy of letterforms is one way to distinguish fonts. For Latin fonts, flourishes at the ends of a character's main strokes, or serifs, can distinguish a font from those without. Similar comparisons exist in non-Latin fonts between fonts with tapered strokes and those using primarily uniform strokes:\n\nFonts contain letterforms and the data needed to map characters to these letterforms. Often this may be a simple one-to-one mapping, but more complex mappings are also possible. The use of combining diacritic marks creates many variations for an underlying letterform:\n\nA sequence of characters can be represented by a single glyph known as a ligature:\n\nVisual transformations based on textual context are often stylistic option in European languages. They are required to correctly render languages like [ARABIC-TYPO], the lam and alef characters below must be combined when they exist in sequence:\n\nThe relative complexity of these shaping transformations requires additional data within the font.\n\nSets of font faces with various stylistic variations are often grouped together into font families. In the simplest case a regular face is supplemented with bold and italic faces, but much more extensive groupings are possible. Variations in the thickness of letterform strokes, the weight, and the overall proportions of the letterform, the width, are most common. In the example below, each letter uses a different font face within the Univers font family. The width used increases from top to bottom and the weight increases from left to right:\n\nCreating fonts that support multiple scripts is a difficult task; designers need to understand the cultural traditions surrounding the use of type in different scripts and come up with letterforms that somehow share a common theme. Many languages often share a common script and each of these languages may have noticeable stylistic differences. For example, the Arabic script, when used for Persian and Urdu, exhibits significant and systematic differences in letterforms, as does Cyrillic when used with languages such as Serbian and Russian.\n\nThe character map of a font defines the mapping of characters to glyphs for that font. If a document contains characters not supported by the character maps of the fonts contained in a font family list, a user agent may use a system font fallback procedure to locate an appropriate font that does. If no appropriate font can be found, some form of \"missing glyph\" character will be rendered by the user agent. System fallback can occur when the specified list of font families does not include a font that supports a given character.\n\nAlthough the character map of a font maps a given character to a glyph for that character, modern font technologies such as OpenType [OPENTYPE] and AAT (Apple Advanced Typography) [AAT-FEATURES] provide ways of mapping a character to different glyphs based upon feature settings. Fonts in these formats allow these features to be embedded in the font itself and controlled by applications. Common typographic features which can be specified this way include ligatures, swashes, contextual alternates, proportional and tabular figures, and automatic fractions, to list just a few. For a visual overview of OpenType features, see the [OPENTYPE-FONT-GUIDE].\n\n3. Basic Font Properties\n\nThe particular font face used to render a character is determined by the font family and other font properties that apply to a given element. This structure allows settings to be varied independent of each other.\n\n3.1. Font family: the font-family property\n\nName: font-family Value: [ <family-name> | <generic-family> ] # Initial: depends on user agent Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: no\n\nThis property specifies a prioritized list of font family names or generic family names. A font family defines a set of faces that vary in weight, width or slope. CSS uses the combination of a family name with other style attributes to select an individual face. Using this selection mechanism, rather than selecting a face via the style name as is often done in design applications, allows some degree of regularity in textual display when fallback occurs.\n\nDesigners should note that the CSS definition of font attributes used for selection are explicitly not intended to define a font taxonomy. A type designer's idea of a family may often extend to a set of faces that vary along axes other than just the standard axes of weight, width and slope. A family may extend to include both a set of serif faces and a set of sans-serif faces or vary along axes that are unique to that family. The CSS font selection mechanism merely provides a way to determine the “closest” substitute when substitution is necessary.\n\nUnlike other CSS properties, component values are a comma-separated list indicating alternatives. A user agent iterates through the list of family names until it matches an available font that contains a glyph for the character to be rendered. This allows for differences in available fonts across platforms and for differences in the range of characters supported by individual fonts.\n\nA font family name only specifies a name given to a set of font faces, it does not specify an individual face. For example, given the availability of the fonts below, Futura would match but Futura Medium would not:\n\nConsider the example below:\n\nbody { font-family: Helvetica, Verdana, sans-serif; }\n\nIf Helvetica is available it will be used when rendering. If neither Helvetica nor Verdana is present, then the user-agent-defined sans serif font will be used.\n\nThere are two types of font family names:\n\n<family-name>\n\nThe name of a font family of choice such as Helvetica or Verdana in the previous example.\n\n<generic-family>\n\nThe following generic family keywords are defined: ‘serif’, ‘sans-serif’, ‘cursive’, ‘fantasy’, and ‘monospace’. These keywords can be used as a general fallback mechanism when an author's desired font choices are not available. As keywords, they must not be quoted. Authors are encouraged to append a generic font family as a last alternative for improved robustness.\n\nFont family names other than generic families must either be given quoted as strings, or unquoted as a sequence of one or more identifiers. This means most punctuation characters and digits at the start of each token must be escaped in unquoted font family names.\n\nTo illustrate this, the following declarations are invalid:\n\nfont-family: Red/Black, sans-serif; font-family: \"Lucida\" Grande, sans-serif; font-family: Ahem!, sans-serif; font-family: test@foo, sans-serif; font-family: #POUND, sans-serif; font-family: Hawaii 5-0, sans-serif;\n\nIf a sequence of identifiers is given as a font family name, the computed value is the name converted to a string by joining all the identifiers in the sequence by single spaces.\n\nTo avoid mistakes in escaping, it is recommended to quote font family names that contain white space, digits, or punctuation characters other than hyphens:\n\nbody { font-family: \"New Century Schoolbook\", serif } <BODY STYLE=\"font-family: '21st Century', fantasy\">\n\nFont family names that happen to be the same as keyword value (‘inherit’, ‘serif’, etc.) must be quoted to prevent confusion with the keywords with the same names. UAs must not consider these keywords as matching the <family-name> type. This applies to any keyword across all of CSS.\n\nThe precise way a set of fonts are grouped into font families varies depending upon the platform font management API's. The Windows GDI API only allows four faces to be grouped into a family while the DirectWrite API and API's on OSX and other platforms support font families with a variety of weights, widths and slopes (see Appendix A for more details).\n\nSome font formats allow fonts to carry multiple localizations of the family name. User agents must recognize and correctly match all of these names independent of the underlying platform localization, system API used or document encoding:\n\nThe details of localized font family name matching and the corresponding issues of case sensitivity are described below in the font matching section.\n\n3.1.1. Generic font families\n\nAll five generic font families must always result in at least one matched font face, for all CSS implementations. However, the generics may be composite faces (with different typefaces based on such things as the Unicode range of the character, the language of the containing element, user preferences and system settings, among others). They are also not guaranteed to always be different from each other.\n\nUser agents should provide reasonable default choices for the generic font families, which express the characteristics of each family as well as possible, within the limits allowed by the underlying technology. User agents are encouraged to allow users to select alternative choices for the generic fonts.\n\nserif\n\nSerif fonts represent the formal text style for a script. This often means but is not limited to glyphs that have finishing strokes, flared or tapering ends, or have actual serifed endings (including slab serifs). Serif fonts are typically proportionately-spaced. They often display a greater variation between thick and thin strokes than fonts from the ‘sans-serif’ generic font family. CSS uses the term ‘serif’ to apply to a font for any script, although other names may be more familiar for particular scripts, such as Mincho (Japanese), Sung or Song (Chinese), Batang (Korean). For Arabic, the Naskh style would correspond to ‘serif’ more due to its typographic role rather than its actual design style. Any font that is so described may be used to represent the generic ‘serif’ family.\n\nsans-serif\n\nGlyphs in sans-serif fonts, as the term is used in CSS, are generally low contrast (vertical and horizontal stems have the close to the same thickness) and have stroke endings that are plain — without any flaring, cross stroke, or other ornamentation. Sans-serif fonts are typically proportionately-spaced. They often have little variation between thick and thin strokes, compared to fonts from the ‘serif’ family. CSS uses the term ‘sans-serif’ to apply to a font for any script, although other names may be more familiar for particular scripts, such as Gothic (Japanese), Hei (Chinese), or Gulim (Korean). Any font that is so described may be used to represent the generic ‘sans-serif’ family.\n\ncursive\n\nGlyphs in cursive fonts generally use a more informal script style, and the result looks more like handwritten pen or brush writing than printed letterwork. CSS uses the term ‘cursive’ to apply to a font for any script, although other names such as Chancery, Brush, Swing and Script are also used in font names.\n\nfantasy\n\nFantasy fonts are primarily decorative or expressive fonts that contain decorative or expressive representations of characters. These do not include Pi or Picture fonts which do not represent actual characters.\n\nmonospace\n\nThe sole criterion of a monospace font is that all glyphs have the same fixed width. This is often used to render samples of computer code.\n\n3.2. Font weight: the font-weight property\n\nName: font-weight Value: normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 Initial: normal Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: numeric weight value (see description) Animatable: as font weight\n\nThe ‘font-weight’ property specifies the weight of glyphs in the font, their degree of blackness or stroke thickness.\n\nValues have the following meanings:\n\n100 to 900\n\nThese values form an ordered sequence, where each number indicates a weight that is at least as dark as its predecessor. These roughly correspond to the commonly used weight names below:\n\n100 - Thin\n\n200 - Extra Light (Ultra Light)\n\n300 - Light\n\n400 - Normal\n\n500 - Medium\n\n600 - Semi Bold (Demi Bold)\n\n700 - Bold\n\n800 - Extra Bold (Ultra Bold)\n\n900 - Black (Heavy)\n\nnormal\n\nSame as ‘400’.\n\nbold\n\nSame as ‘700’.\n\nbolder\n\nSpecifies a bolder weight than the inherited value.\n\nlighter\n\nSpecifies a lighter weight than the inherited value.\n\nFont formats that use a scale other than a nine-step scale should map their scale onto the CSS scale so that 400 roughly corresponds with a face that would be labeled as Regular, Book, Roman and 700 roughly matches a face that would be labeled as Bold. Or weights may be inferred from the style names, ones that correspond roughly with the scale above. The scale is relative, so a face with a larger weight value must never appear lighter. If style names are used to infer weights, care should be taken to handle variations in style names across locales.\n\nQuite often there are only a few weights available for a particular font family. When a weight is specified for which no face exists, a face with a nearby weight is used. In general, bold weights map to faces with heavier weights and light weights map to faces with lighter weights (see the font matching section below for a precise definition). The examples here illustrate which face is used for different weights, grey indicates a face for that weight does not exist so a face with a nearby weight is used:\n\nAlthough the practice is not well-loved by typographers, bold faces are often synthesized by user agents for faces that lack actual bold faces. For the purposes of style matching, these faces must be treated as if they exist within the family. Authors can explicitly avoid this behavior by using the ‘font-synthesis’ property.\n\nSpecified values of ‘bolder’ and ‘lighter’ indicate weights relative to the weight of the parent element. The computed weight is calculated based on the inherited ‘font-weight’ value using the chart below.\n\nInherited value bolder lighter 100 400 100 200 400 100 300 400 100 400 700 100 500 700 100 600 900 400 700 900 400 800 900 700 900 900 700\n\nThe table above is equivalent to selecting the next relative bolder or lighter face, given a font family containing normal and bold faces along with a thin and a heavy face. Authors who desire finer control over the exact weight values used for a given element may use numerical values instead of relative weights.\n\n3.3. Font width: the font-stretch property\n\nName: font-stretch Value: normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded Initial: normal Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: as font stretch\n\nThe ‘font-stretch’ property selects a normal, condensed, or expanded face from a font family. Absolute keyword values have the following ordering, from narrowest to widest:\n\nultra-condensed extra-condensed condensed semi-condensed normal semi-expanded expanded extra-expanded ultra-expanded\n\nWhen a face does not exist for a given width, normal or condensed values map to a narrower face, otherwise a wider face. Conversely, expanded values map to a wider face, otherwise a narrower face. The figure below shows how the nine font-stretch property settings affect font selection for font family containing a variety of widths, grey indicates a width for which no face exists and a different width is substituted:\n\nAnimation of font stretch: Font stretch is interpolated in discrete steps. The interpolation happens as though the ordered values are equally spaced real numbers. The interpolation result is rounded to the nearest value, with values exactly halfway between two values rounded towards the later value in the list above.\n\n3.4. Font style: the font-style property\n\nName: font-style Value: normal | italic | oblique Initial: normal Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: no\n\nThe ‘font-style’ property allows italic or oblique faces to be selected. Italic forms are generally cursive in nature while oblique faces are typically sloped versions of the regular face. Oblique faces can be simulated by artificially sloping the glyphs of the regular face. Compare the artificially sloped renderings of Palatino ‘a’ and Baskerville ‘N’ in grey with the actual italic versions:\n\nValues have the following meanings:\n\nnormal\n\nselects a face that is classified as a normal face, one that is neither italic or obliqued\n\nitalic\n\nselects a font that is labeled as an italic face, or an oblique face if one is not\n\noblique\n\nselects a font that is labeled as an oblique face, or an italic face if one is not\n\nIf no italic or oblique face is available, oblique faces can be synthesized by rendering non-obliqued faces with an artificial obliquing operation. The use of these artificially obliqued faces can be disabled using the ‘font-synthesis’ property. The details of the obliquing operation are not explicitly defined.\n\nAuthors should also be aware that synthesized approaches may not be suitable for scripts like Cyrillic, where italic forms are very different in shape. It is always better to use an actual italic font rather than rely on a synthetic version.\n\nMany scripts lack the tradition of mixing a cursive form within text rendered with a normal face. Chinese, Japanese and Korean fonts almost always lack italic or oblique faces. Fonts that support a mixture of scripts will sometimes omit specific scripts such as Arabic from the set of glyphs supported in the italic face. User agents should be careful about making character map assumptions across faces when implementing support for system font fallback.\n\n3.5. Font size: the font-size property\n\nName: font-size Value: <absolute-size> | <relative-size> | <length-percentage> Initial: medium Applies to: all elements Inherited: yes Percentages: refer to parent element's font size Media: visual Computed value: absolute length Animatable: as length\n\nThis property indicates the desired height of glyphs from the font. For scalable fonts, the font-size is a scale factor applied to the EM unit of the font. (Note that certain glyphs may bleed outside their EM box.) For non-scalable fonts, the font-size is converted into absolute units and matched against the declared ‘font-size’ of the font, using the same absolute coordinate space for both of the matched values. Values have the following meanings:\n\n<absolute-size>\n\nAn <absolute-size> keyword refers to an entry in a table of font sizes computed and kept by the user agent. Possible values are:\n\n[ xx-small | x-small | small | medium | large | x-large | xx-large ]\n\n<relative-size>\n\nA <relative-size> keyword is interpreted relative to the table of font sizes and the computed ‘font-size’ of the parent element. Possible values are:\n\n[ larger | smaller ]\n\nFor example, if the parent element has a font size of ‘medium’, a value of ‘larger’ will make the font size of the current element be ‘large’. If the parent element's size is not close to a table entry, the user agent is free to interpolate between table entries or round off to the closest one. The user agent may have to extrapolate table values if the numerical value goes beyond the keywords.\n\n<length-percentage>\n\nA length value [CSS-VALUES] specifies an absolute font size (independent of the user agent's font table). Negative lengths are invalid.\n\nA percentage value specifies an absolute font size relative to the parent element's font size. Use of percentage values, or values in ems, leads to more robust and cascadable style sheets. Negative percentages are invalid.\n\nThe following table provides user agent guidelines for the absolute-size scaling factor and their mapping to HTML heading and absolute font-sizes. The ‘medium’ value is used as the reference middle value. The user agent may fine-tune these values for different fonts or different types of display devices.\n\nCSS absolute-size values xx-small x-small small medium large x-large xx-large scaling factor 3/5 3/4 8/9 1 6/5 3/2 2/1 3/1 HTML headings h6 h5 h4 h3 h2 h1 HTML font sizes 1 2 3 4 5 6 7\n\nNote 1. To preserve readability, an UA applying these guidelines should nevertheless avoid creating font-size resulting in less than 9 device pixels per EM unit on a computer display.\n\nNote 2. In CSS1, the suggested scaling factor between adjacent indexes was 1.5 which user experience proved to be too large. In CSS2, the suggested scaling factor for computer screen between adjacent indexes was 1.2 which still created issues for the small sizes. The new scaling factor varies between each index to provide a better readability.\n\nThe actual value of this property may differ from the computed value due a numerical value on ‘font-size-adjust’ and the unavailability of certain font sizes.\n\nChild elements inherit the computed ‘font-size’ value (otherwise, the effect of ‘font-size-adjust’ would compound).\n\nExample(s):\n\np { font-size: 12pt; } blockquote { font-size: larger } em { font-size: 150% } em { font-size: 1.5em }\n\n3.6. Relative sizing: the font-size-adjust property\n\nName: font-size-adjust Value: none | <number> Initial: none Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: as number\n\nFor any given font size, the apparent size and legibility of text varies across fonts. For scripts such as Latin or Cyrillic that distinguish between upper and lowercase letters, the relative height of lowercase letters compared to their uppercase counterparts is a determining factor of legibility. This is commonly referred to as the aspect value. Precisely defined, it is equal to the x-height of a font divided by the font size.\n\nIn situations where font fallback occurs, fallback fonts may not share the same aspect value as the desired font family and will thus appear less readable. The ‘font-size-adjust’ property is a way to preserve the readability of text when font fallback occurs. It does this by adjusting the font-size so that the x-height is the same regardless of the font used.\n\nThe style defined below defines Verdana as the desired font family, but if Verdana is not available Futura or Times will be used.\n\np { font-family: Verdana, Futura, Times; } <p>Lorem ipsum dolor sit amet, ...</p>\n\nVerdana has a relatively high aspect value, lowercase letters are relatively tall compared to uppercase letters, so at small sizes text appears legible. Times has a lower aspect value and so if fallback occurs, the text will be less legible at small sizes than Verdana.\n\nHow text rendered in each of these fonts compares is shown below, the columns show text rendered in Verdana, Futura and Times. The same font-size value is used across cells within each row and red lines are included to show the differences in x-height. In the upper half each row is rendered in the same font-size value. The same is true for the lower half but in this half the ‘font-size-adjust’ property is also set so that the actual font size is adjusted to preserve the x-height across each row. Note how small text remains relatively legible across each row in the lower half.\n\nThis property allows authors to specify an aspect value for an element that will effectively preserve the x-height of the first choice font, whether it is substituted or not. Values have the following meanings:\n\nnone\n\nDo not preserve the font's x-height.\n\n<number>\n\nSpecifies the aspect value used in the calculation below to calculate the adjusted font size:\n\nc = ( a / a' ) s\n\nwhere:\n\ns = font-size value a = aspect value as specified by the 'font-size-adjust' property a' = aspect value of actual font c = adjusted font-size to use\n\nNegative values are invalid.\n\nThis value applies to any font that is selected but in typical usage it should be based on the aspect value of the first font in the font-family list. If this is specified accurately, the (a/a') term in the formula above is effectively 1 for the first font and no adjustment occurs. If the value is specified inaccurately, text rendered using the first font in the family list will display differently in older user agents that don't support ‘font-size-adjust’.\n\nThe value of ‘font-size-adjust’ affects the used value of ‘font-size’ but does not affect the computed value. It affects the size of relative units that are based on font metrics of the first available font such as ex and ch but does not affect the size of em units. Since numeric values of ‘line-height’ refer to the computed size of ‘font-size’, ‘font-size-adjust’ does not affect the used value of ‘line-height’.\n\nIn CSS, authors often specify ‘line-height’ as a multiple of the ‘font-size’. Since the ‘font-size-adjust’ property affects the used value of ‘font-size’, authors should take care setting the line height when ‘font-size-adjust’ is used. Setting the line height too tightly can result in overlapping lines of text in this situation.\n\nAuthors can calculate the aspect value for a given font by comparing spans with the same content but different ‘font-size-adjust’ properties. If the same font-size is used, the spans will match when the ‘font-size-adjust’ value is accurate for the given font.\n\n3.7. Shorthand font property: the font property\n\nName: font Value: [ [ <‘font-style’> || <font-variant-css21> || <‘font-weight’> || <‘font-stretch’> ]? <‘font-size’> [ / <‘line-height’> ]? <‘font-family’> ] | caption | icon | menu | message-box | small-caption | status-bar Initial: see individual properties Applies to: all elements Inherited: yes Percentages: see individual properties Media: visual Computed value: see individual properties Animatable: see individual properties\n\nThe ‘font’ property is, except as described below, a shorthand property for setting ‘font-style’, ‘font-variant’, ‘font-weight’, ‘font-stretch’, ‘font-size’, ‘line-height’, ‘font-family’ at the same place in the stylesheet. Values for the ‘font-variant’ property may also be included but only those supported in CSS 2.1, none of the ‘font-variant’ values added in this specification can be used in the ‘font’ shorthand:\n\n<font-variant-css21> = [normal | small-caps]\n\nThe syntax of this property is based on a traditional typographical shorthand notation to set multiple properties related to fonts.\n\nAll subproperties of the ‘font’ property are first reset to their initial values, including those listed above plus ‘font-size-adjust’, ‘font-kerning’, all subproperties of ‘font-variant’, and ‘font-feature-settings’, but not ‘font-synthesis’. Then, those properties that are given explicit values in the ‘font’ shorthand are set to those values. For a definition of allowed and initial values, see the previously defined properties. For reasons of backwards compatibility, it is not possible to set ‘font-size-adjust’ to anything other than its initial value using the ‘font’ shorthand property; instead, use the individual property.\n\nSince the ‘font-stretch’ property was not defined in CSS 2.1, when using ‘font-stretch’ values within ‘font’ rules, authors should include a extra version compatible with older user agents:\n\np { font: 80% sans-serif; /* for older user agents */ font: condensed 80% sans-serif; }\n\nThe following values refer to system fonts:\n\ncaption\n\nThe font used for captioned controls (e.g., buttons, drop-downs, etc.).\n\nicon\n\nThe font used to label icons.\n\nmenu\n\nThe font used in menus (e.g., dropdown menus and menu lists).\n\nmessage-box\n\nThe font used in dialog boxes.\n\nsmall-caption\n\nThe font used for labeling small controls.\n\nstatus-bar\n\nThe font used in window status bars.\n\nSystem fonts may only be set as a whole; that is, the font family, size, weight, style, etc. are all set at the same time. These values may then be altered individually if desired. If no font with the indicated characteristics exists on a given platform, the user agent should either intelligently substitute (e.g., a smaller version of the ‘caption’ font might be used for the ‘small-caption’ font), or substitute a user agent default font. As for regular fonts, if, for a system font, any of the individual properties are not part of the operating system's available user preferences, those properties should be set to their initial values.\n\nThat is why this property is \"almost\" a shorthand property: system fonts can only be specified with this property, not with ‘font-family’ itself, so ‘font’ allows authors to do more than the sum of its subproperties. However, the individual properties such as ‘font-weight’ are still given values taken from the system font, which can be independently varied.\n\nNote that the keywords used for the system fonts listed above are only treated as keywords when they occur in the initial position, in other positions the same string is treated as part of the font family name:\n\nfont: menu; /* use the font settings for system menus */ font: large menu; /* use a font family named \"menu\" */\n\n3.8. Controlling synthetic faces: the font-synthesis property\n\nName: font-synthesis Value: none | [ weight || style ] Initial: weight style Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: no\n\nThis property controls whether user agents are allowed to synthesize bold or oblique font faces when a font family lacks bold or italic faces. If ‘weight’ is not specified, user agents must not synthesize bold faces and if ‘style’ is not specified user agents must not synthesize italic faces. A value of ‘none’ disallows all synthetic faces.\n\nThe style rule below disables the use of synthetically obliqued Arabic:\n\n*:lang(ar) { font-synthesis: none; }\n\n4. Font Resources\n\n4.1. The @font-face rule\n\nThe @font-face rule allows for linking to fonts that are automatically fetched and activated when needed. This allows authors to select a font that closely matches the design goals for a given page rather than limiting the font choice to a set of fonts available on a given platform. A set of font descriptors define the location of a font resource, either locally or externally, along with the style characteristics of an individual face. Multiple @font-face rules can be used to construct font families with a variety of faces. Using CSS font matching rules, a user agent can selectively download only those faces that are needed for a given piece of text.\n\nThe @font-face rule consists of the @font-face at-keyword followed by a block of descriptor declarations. In terms of the grammar, this specification defines the following productions:\n\nfont_face_rule : FONT_FACE_SYM S* '{' S* descriptor_declaration? [ ';' S* descriptor_declaration? ]* '}' S* ; descriptor_declaration : property ':' S* expr ;\n\nThe following new definitions are introduced:\n\n- -|\\\\0{0,4}2d(\\r\\n|[ \\t\\r\\n\\f])? F f|\\\\0{0,4}(46|66)(\\r\\n|[ \\t\\r\\n\\f])?\n\nThe following new token is introduced:\n\n@{F}{O}{N}{T}{-}{F}{A}{C}{E} {return FONT_FACE_SYM;}\n\nEach @font-face rule specifies a value for every font descriptor, either implicitly or explicitly. Those not given explicit values in the rule take the initial value listed with each descriptor in this specification. These descriptors apply solely within the context of the @font-face rule in which they are defined, and do not apply to document language elements. There is no notion of which elements the descriptors apply to or whether the values are inherited by child elements. When a given descriptor occurs multiple times in a given @font-face rule, only the last descriptor declaration is used and all prior declarations for that descriptor are ignored.\n\nTo use a downloadable font called Gentium:\n\n@font-face { font-family: Gentium; src: url(http://example.com/fonts/Gentium.woff); } p { font-family: Gentium, serif; }\n\nThe user agent will download Gentium and use it when rendering text within paragraph elements. If for some reason the site serving the font is unavailable, the default serif font will be used.\n\nA given set of @font-face rules define a set of fonts available for use within the documents that contain these rules. When font matching is done, fonts defined using these rules are considered before other available fonts on a system.\n\nDownloaded fonts are only available to documents that reference them. The process of activating these fonts must not make them available to other applications or to documents that don't directly link to the same font. User agent implementers might consider it convenient to use downloaded fonts when rendering characters in other documents for which no other available font exists as part of the system font fallback procedure. However, this would cause a security leak since the contents of one page would be able to affect other pages, something an attacker could use as an attack vector. These restrictions do not affect caching behavior, fonts are cached the same way other web resources are cached.\n\nThis at-rule follows the forward-compatible parsing rules of CSS. Like properties in a declaration block, declarations of any descriptors that are not supported by the user agent must be ignored. @font-face rules require a font-family and src descriptor; if either of these are missing, the @font-face rule must not be considered when performing the font matching algorithm.\n\nIn cases where user agents have limited platform resources or implement the ability to disable downloadable font resources, @font-face rules must simply be ignored; the behavior of individual descriptors as defined in this specification should not be altered.\n\n4.2. Font family: the font-family descriptor\n\nName: font-family Value: <family-name> Initial: N/A\n\nThis descriptor defines the font family name that will be used in all CSS font family name matching. It is required for the @font-face rule to be valid. It overrides the font family names contained in the underlying font data. If the font family name is the same as a font family available in a given user's environment, it effectively hides the underlying font for documents that use the stylesheet. This permits a web author to freely choose font-family names without worrying about conflicts with font family names present in a given user's environment. Likewise, platform substitutions for a given font family name must not be used.\n\n4.3. Font reference: the src descriptor\n\nName: src Value: [ <url> [format(<string> #)]? | <font-face-name> ] # Initial: N/A\n\nThis descriptor specifies the resource containing font data. It is required for the @font-face rule to be valid. Its value is a prioritized, comma-separated list of external references or locally-installed font face names. When a font is needed the user agent iterates over the set of references listed, using the first one it can successfully activate. Fonts containing invalid data or local font faces that are not found are ignored and the user agent loads the next font in the list.\n\nAs with other URLs in CSS, the URL may be relative, in which case it is resolved relative to the location of the style sheet containing the @font-face rule. In the case of SVG fonts, the URL points to an element within a document containing SVG font definitions. If the element reference is omitted, a reference to the first defined font is implied. Similarly, font container formats that can contain more than one font must load one and only one of the fonts for a given @font-face rule. Fragment identifiers are used to indicate which font to load; these use the PostScript name of the font as defined in [RFC8081]. Conformant user agents must skip downloading a font resource if the fragment identifier is unknown or unsupported. For example, older user agents which do not support OpenType collections will skip to the next url in the list.\n\nsrc: url(fonts/simple.woff); /* load simple.woff relative to stylesheet location */ src: url(/fonts/simple.woff); /* load simple.woff from absolute location */ src: url(fonts/coll.otc#foo); /* load font foo from collection coll.otc src: url(fonts/coll.woff2#foo); /* load font foo from woff2 collection coll.woff2 src: url(fonts.svg#simple); /* load SVG font with id 'simple' */\n\nExternal references consist of a URL, followed by an optional hint describing the format of the font resource referenced by that URL. The format hint contains a comma-separated list of format strings that denote well-known font formats. Conformant user agents must skip downloading a font resource if the format hints indicate only unsupported or unknown font formats. If no format hints are supplied, the user agent should download the font resource.\n\n/* load WOFF2 font if possible, otherwise WOFF, else use OpenType font */ @font-face { font-family: bodytext; src: url(ideal-sans-serif.woff2) format(\"woff2\"), url(good-sans-serif.woff) format(\"woff\"), url(basic-sans-serif.ttf) format(\"opentype\"); }\n\nFormat strings defined by this specification:\n\nString Font Format Common extensions \"woff\" WOFF 1.0 (Web Open Font Format) .woff \"woff2\" WOFF 2.0 (Web Open Font Format) .woff2 \"truetype\" TrueType .ttf \"opentype\" OpenType .ttf, .otf \"embedded-opentype\" Embedded OpenType .eot \"svg\" SVG Font .svg, .svgz\n\nGiven the overlap in common usage between TrueType and OpenType [OPENTYPE], the format hints \"truetype\" and \"opentype\" must be considered as synonymous; a format hint of \"opentype\" does not imply that the font contains Postscript CFF style glyph data or that it contains OpenType layout information (see Appendix A for more background on this).\n\nWhen authors would prefer to use a locally available copy of a given font and download it if it's not, local() can be used. The locally-installed <font-face-name> argument to local() is a format-specific string that uniquely identifies a single font face within a larger family. The syntax for a <font-face-name> is a unique font face name enclosed by \"local(\" and \")\". The name can optionally be enclosed in quotes. If unquoted, the unquoted font family name processing conventions apply; the name must be a sequence of identifiers separated by whitespace which is converted to a string by joining the identifiers together separated by a single space.\n\n/* regular face of Gentium */ @font-face { font-family: MyGentium; src: local(Gentium), /* use locally available Gentium */ url(Gentium.woff); /* otherwise, download it */ }\n\nFor OpenType and TrueType fonts, this string is used to match only the Postscript name or the full font name in the name table of locally available fonts. Which type of name is used varies by platform and font, so authors should include both of these names to assure proper matching across platforms. Platform substitutions for a given font name must not be used.\n\n/* bold face of Gentium */ @font-face { font-family: MyGentium; src: local(Gentium Bold), /* full font name */ local(Gentium-Bold), /* Postscript name */ url(GentiumBold.woff); /* otherwise, download it */ font-weight: bold; }\n\nJust as a @font-face rule specifies the characteristics of a single font within a family, the unique name used with local() specifies a single font, not an entire font family. Defined in terms of OpenType font data, the Postscript name is found in the font's name table, in the name record with nameID = 6 (see [OPENTYPE] for more details). The Postscript name is the commonly used key for all fonts on OSX and for Postscript CFF fonts under Windows. The full font name (nameID = 4) is used as a unique key for fonts with TrueType glyphs on Windows.\n\nFor OpenType fonts with multiple localizations of the full font name, the US English version is used (language ID = 0x409 for Windows and language ID = 0 for Macintosh) or the first localization when a US English full font name is not available (the OpenType specification recommends that all fonts minimally include US English names). User agents that also match other full font names, e.g. matching the Dutch name when the current system locale is set to Dutch, are considered non-conformant. This is done not to prefer English but to avoid matching inconsistencies across font versions and OS localizations, since font style names (e.g. \"Bold\") are frequently localized into many languages and the set of localizations available varies widely across platform and font version. User agents that match a concatenation of family name (nameID = 1) with style name (nameID = 2) are considered non-conformant.\n\nThis also allows for referencing faces that belong to larger families that cannot otherwise be referenced.\n\n4.4. Font property descriptors: the font-style, font-weight, font-stretch descriptors\n\nName: font-style Value: normal | italic | oblique Initial: normal\n\nName: font-weight Value: normal | bold | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 Initial: normal\n\nName: font-stretch Value: normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded Initial: normal\n\nThese descriptors define the characteristics of a font face and are used in the process of matching styles to specific faces. For a font family defined with several @font-face rules, user agents can either download all faces in the family or use these descriptors to selectively download font faces that match actual styles used in document. The values for these descriptors are the same as those for the corresponding font properties except that relative keywords are not allowed, ‘bolder’ and ‘lighter’. If these descriptors are omitted, initial values are assumed.\n\nThe value for these font face style attributes is used in place of the style implied by the underlying font data. This allows authors to combine faces in flexible combinations, even in situations where the original font data was arranged differently. User agents that implement synthetic bolding and obliquing must only apply synthetic styling in cases where the font descriptors imply this is needed, rather than based on the style attributes implied by the font data.\n\n4.5. Character range: the unicode-range descriptor\n\nName: unicode-range Value: <urange> # Initial: U+0-10FFFF\n\nThis descriptor defines the set of Unicode [UNICODE] codepoints that may be supported by the font face for which it is declared. The descriptor value is a comma-delimited list of Unicode range (<urange>) values. The union of these ranges defines the set of codepoints that serves as a hint for user agents when deciding whether or not to download a font resource for a given text run.\n\nEach <urange> value is a UNICODE-RANGE token made up of a \"U+\" or \"u+\" prefix followed by a codepoint range in one of the three forms listed below. Ranges that do not fit one of the these forms are invalid and cause the declaration to be ignored.\n\nsingle codepoint (e.g. U+416)\n\na Unicode codepoint, represented as one to six hexadecimal digits\n\ninterval range (e.g. U+400-4ff)\n\nrepresented as two hyphen-separated Unicode codepoints indicating the inclusive start and end codepoints of a range\n\nwildcard range (e.g. U+4??)\n\ndefined by the set of codepoints implied when trailing ‘?’ characters signify any hexadeximal digit\n\nIndividual codepoints are written using hexadecimal values that correspond to Unicode character codepoints [UNICODE]. Unicode codepoint values must be between 0 and 10FFFF inclusive. Digit values of codepoints are ASCII case-insensitive. For interval ranges, the start and end codepoints must be within the range noted above and the end codepoint must be greater than or equal to the start codepoint.\n\nWildcard ranges specified with ‘?’ that lack an initial digit (e.g. \"U+???\") are valid and equivalent to a wildcard range with an initial zero digit (e.g. \"U+0???\" = \"U+0000-0FFF\"). Wildcard ranges that extend beyond the range of Unicode codepoints are invalid. Because of this, the maximum number of trailing ‘?’ wildcard characters is five, even though the UNICODE-RANGE token accepts six.\n\nWithin the comma-delimited list of Unicode ranges in a ‘unicode-range’ descriptor declaration, ranges may overlap. The union of these ranges defines the set of codepoints for which the corresponding font may be used. User agents must not download or use the font for codepoints outside this set. User agents may normalize the list of ranges into a list that is different but represents the same set of codepoints.\n\nThe associated font might not contain glyphs for the entire set of codepoints defined by the ‘unicode-range’ descriptor. When the font is used, the effective character map is the intersection of the codepoints defined by ‘unicode-range’ with the font's character map. This allows authors to define supported ranges in terms of broad ranges without worrying about the precise codepoint ranges supported by the underlying font.\n\n4.6. Using character ranges to define composite fonts\n\nMultiple @font-face rules with different unicode ranges for the same family and style descriptor values can be used to create composite fonts that mix the glyphs from different fonts for different scripts. This can be used to combine fonts that only contain glyphs for a single script (e.g. Latin, Greek, Cyrillic) or it can be used by authors as a way of segmenting a font into fonts for commonly used characters and less frequently used characters. Since the user agent will only pull down the fonts it needs this helps reduce page bandwidth.\n\nIf the unicode ranges overlap for a set of @font-face rules with the same family and style descriptor values, the rules are ordered in the reverse order they were defined; the last rule defined is the first to be checked for a given character.\n\nExample ranges for specific languages or characters:\n\nunicode-range: U+A5;\n\na single code point, the yen/yuan symbol\n\nunicode-range: U+0-7F;\n\ncode range for basic ASCII characters\n\nunicode-range: U+590-5ff;\n\ncode range for Hebrew characters\n\nunicode-range: U+A5, U+4E00-9FFF, U+30??, U+FF00-FF9F;\n\ncode range for Japanese kanji, hiragana and katakana characters plus yen/yuan symbol\n\nTechnical documents often require a wide range of symbols. The STIX Fonts project is one project aimed at providing fonts to support a wide range of technical typesetting in a standardized way. The example below shows the use of a font that provides glyphs for many of the mathematical and technical symbol ranges within Unicode:\n\n@font-face { font-family: STIXGeneral; src: local(STIXGeneral), url(/stixfonts/STIXGeneral.otf); unicode-range: U+000-49F, U+2000-27FF, U+2900-2BFF, U+1D400-1D7FF; }\n\nThis example shows how an author can override the glyphs used for Latin characters in a Japanese font with glyphs from a different font. The first rule specifies no range so it defaults to the entire range. The range specified in the second rule overlaps but takes precedence because it is defined later.\n\n@font-face { font-family: JapaneseWithGentium; src: local(MSMincho); /* no range specified, defaults to entire range */ } @font-face { font-family: JapaneseWithGentium; src: url(../fonts/Gentium.woff); unicode-range: U+0-2FF; }\n\n4.7. Font features: the font-feature-settings descriptor\n\nName: font-feature-settings Value: normal | <feature-tag-value> # Initial: normal\n\nThis descriptor defines initial settings that apply when the font defined by an @font-face rule is rendered. It does not affect font selection. Values are identical to those defined for the corresponding ‘font-feature-settings’ property defined below except that the value ‘inherit’ is omitted. When multiple font feature descriptors or properties are used, the cumulative effect on text rendering is detailed in the section Font Feature Resolution below.\n\n4.8. Font loading guidelines\n\nThe @font-face rule is designed to allow lazy loading of font resources that are only downloaded when used within a document. A stylesheet can include @font-face rules for a library of fonts of which only a select set are used; user agents must only download those fonts that are referred to within the style rules applicable to a given page. User agents that download all fonts defined in @font-face rules without considering whether those fonts are in fact used within a page are considered non-conformant. In cases where a font might be downloaded in character fallback cases, user agents may download a font if it's contained within the computed value of ‘font-family’ for a given text run.\n\n@font-face { font-family: GeometricModern; src: url(font.woff); } p { /* font will be downloaded for pages with p elements */ font-family: GeometricModern, sans-serif; } h2 { /* font may be downloaded for pages with h2 elements, even if Futura is available locally */ font-family: Futura, GeometricModern, sans-serif; }\n\nIn cases where textual content is loaded before downloadable fonts are available, user agents may render text as it would be rendered if downloadable font resources are not available or they may render text transparently with fallback fonts to avoid a flash of text using a fallback font. In cases where the font download fails user agents must display text, simply leaving transparent text is considered non-conformant behavior. Authors are advised to use fallback fonts in their font lists that closely match the metrics of the downloadable fonts to avoid large page reflows where possible.\n\n4.9. Font fetching requirements\n\nFor font loads, user agents must use the potentially CORS-enabled fetch method defined by the [FETCH] specification for URL's defined within @font-face rules. When fetching, user agents must use \"Anonymous\" mode, set the referrer source to the stylesheet's URL and set the origin to the URL of the containing document.\n\nThe implications of this for authors are that fonts will typically not be loaded cross-origin unless authors specifically takes steps to permit cross-origin loads. Sites can explicitly allow cross-site loading of font data using the Access-Control-Allow-Origin HTTP header. For other schemes, no explicit mechanism to allow cross-origin loading, beyond what is permitted by the potentially CORS-enabled fetch method, is defined or required.\n\nFor the examples given below, assume that a document is located at https://example.com/page.html and all URL's link to valid font resources supported by the user agent. Fonts defined with the ‘src’ descriptor values below will be loaded:\n\n/* same origin (i.e. domain, scheme, port match document) */ src: url(fonts/simple.woff); /* data url's with no redirects are treated as same origin */ src: url(\"data:application/font-woff;base64,...\"); /* cross origin, different domain */ /* Access-Control-Allow-Origin response header set to '*' */ src: url(http://another.example.com/fonts/simple.woff);\n\nFonts defined with the ‘src’ descriptor values below will fail to load:\n\n/* cross origin, different scheme */ /* no Access-Control-xxx headers in response */ src: url(https://example.com/fonts/simple.woff); /* cross origin, different domain */ /* no Access-Control-xxx headers in response */ src: url(http://another.example.com/fonts/simple.woff);\n\n5. Font Matching Algorithm\n\nThe algorithm below describes how fonts are associated with individual runs of text. For each character in the run a font family is chosen and a particular font face is selected containing a glyph for that character.\n\n5.1. Case sensitivity of font family names\n\nAs part of the font matching algorithm outlined below, user agents must match font family names used in style rules with actual font family names contained in fonts available in a given environment or with font family names defined in @font-face rules. User agents must match these names case insensitively, using the \"Default Caseless Matching\" algorithm outlined in the Unicode specification [UNICODE]. This algorithm is detailed in section 3.13 entitled \"Default Case Algorithms\". Specifically, the algorithm must be applied without normalizing the strings involved and without applying any language-specific tailorings. The case folding method specified by this algorithm uses the case mappings with status field ‘C’ or ‘F’ in the CaseFolding.txt file of the Unicode Character Database [UNICODE].\n\nFor authors this means that font family names are matched case insensitively, whether those names exist in a platform font or in the @font-face rules contained in a stylesheet. Authors should take care to ensure that names use a character sequence consistent with the actual font family name, particularly when using combining characters such as diacritical marks. For example, a family name that contains a lowercase a (U+0061) followed by a combining ring (U+030A) will not match a name that looks identical but which uses the precomposed lowercase a-ring character (U+00E5) instead of the combining sequence.\n\nImplementors should take care to verify that a given caseless string comparison implementation uses this precise algorithm and not assume that a given platform string matching routine follows it, as many of these have locale-specific behavior or use some level of string normalization [UAX15].\n\n5.2. Matching font styles\n\nThe procedure for choosing a font for a given character in a run of text consists of iterating over the font families named by the ‘font-family’ property, selecting a font face with the appropriate style based on other font properties and then determining whether a glyph exists for the given character. This is done using the character map of the font, data which maps characters to the default glyph for that character. A font is considered to support a given character if (1) the character is contained in the font's character map and (2) if required by the containing script, shaping information is available for that character.\n\nSome legacy fonts may include a given character in the character map but lack the shaping information (e.g. OpenType layout tables or Graphite tables) necessary for correctly rendering text runs containing that character.\n\nCodepoint sequences consisting of a base character followed by a sequence of combining characters are treated slightly differently, see the section on cluster matching below.\n\nFor this procedure, the default face for a given font family is defined to be the face that would be selected if all font style properties were set to their initial value.\n\nUsing the computed font property values for a given element, the user agent starts with the first family name specified by the ‘font-family’ property.\n\nIf the family name is a generic family keyword, the user agent looks up the appropriate font family name to be used. User agents may choose the generic font family to use based on the language of the containing element or the Unicode range of the character.\n\nFor other family names, the user agent attempts to find the family name among fonts defined via @font-face rules and then among available system fonts, matching names with a case-insensitive comparison as outlined in the section above. On systems containing fonts with multiple localized font family names, user agents must match any of these names independent of the underlying system locale or platform API used. If the font resources defined for a given face in an @font-face rule are either not available or contain invalid font data, then the face should be treated as not present in the family. If no faces are present for a family defined via @font-face rules, the family should be treated as missing; matching a platform font with the same name must not occur in this case.\n\nIf a font family match occurs, the user agent assembles the set of font faces in that family and then narrows the set to a single face using other font properties in the order given below. A group of faces defined via @font-face rules with identical font descriptor values but differing ‘unicode-range’ values are considered to be a single composite face for this step:\n\n‘font-stretch’ is tried first. If the matching set contains faces with width values matching the ‘font-stretch’ value, faces with other width values are removed from the matching set. If there is no face that exactly matches the width value the nearest width is used instead. If the value of ‘font-stretch’ is ‘normal’ or one of the condensed values, narrower width values are checked first, then wider values. If the value of ‘font-stretch’ is one of the expanded values, wider values are checked first, followed by narrower values. Once the closest matching width has been determined by this process, faces with other widths are removed from the matching set. ‘font-style’ is tried next. If the value of ‘font-style’ is ‘italic’, italic faces are checked first, then oblique, then normal faces. If the value is ‘oblique’, oblique faces are checked first, then italic faces and then normal faces. If the value is ‘normal’, normal faces are checked first, then oblique faces, then italic faces. Faces with other style values are excluded from the matching set. User agents are permitted to distinguish between italic and oblique faces within platform font families but this is not required, so all italic or oblique faces may be treated as italic faces. However, within font families defined via @font-face rules, italic and oblique faces must be distinguished using the value of the ‘font-style’ descriptor. For families that lack any italic or oblique faces, user agents may create artificial oblique faces, if this is permitted by the value of the ‘font-synthesis’ property. ‘font-weight’ is matched next, so it will always reduce the matching set to a single font face. If bolder/lighter relative weights are used, the effective weight is calculated based on the inherited weight value, as described in the definition of the ‘font-weight’ property. Given the desired weight and the weights of faces in the matching set after the steps above, if the desired weight is available that face matches. Otherwise, a weight is chosen using the rules below:\n\nIf the desired weight is less than 400, weights below the desired weight are checked in descending order followed by weights above the desired weight in ascending order until a match is found.\n\nIf the desired weight is greater than 500, weights above the desired weight are checked in ascending order followed by weights below the desired weight in descending order until a match is found.\n\nIf the desired weight is 400, 500 is checked first and then the rule for desired weights less than 400 is used.\n\nIf the desired weight is 500, 400 is checked first and then the rule for desired weights less than 400 is used.\n\n‘font-size’ must be matched within a UA-dependent margin of tolerance. (Typically, sizes for scalable fonts are rounded to the nearest whole pixel, while the tolerance for bitmapped fonts could be as large as 20%.) Further computations, e.g., by ‘em’ values in other properties, are based on the ‘font-size’ value that is used, not the one that is specified.\n\nIf the matched face is defined via @font-face rules, user agents must use the procedure below to select a single font:\n\nIf the font resource has not been loaded and the range of characters defined by the ‘unicode-range’ descriptor value includes the character in question, load the font.\n\nAfter downloading, if the effective character map supports the character in question, select that font.\n\nWhen the matched face is a composite face, user agents must use the procedure above on each of the faces in the composite face in reverse order of @font-face rule definition.\n\nWhile the download occurs, user agents may either wait until the font is downloaded or render once with substituted font metrics and render again once the font is downloaded.\n\nIf no matching face exists or the matched face does not contain a glyph for the character to be rendered, the next family name is selected and the previous three steps repeated. Glyphs from other faces in the family are not considered. The only exception is that user agents may optionally substitute a synthetically obliqued version of the default face if that face supports a given glyph and synthesis of these faces is permitted by the value of the ‘font-synthesis’ property. For example, a synthetic italic version of the regular face may be used if the italic face doesn't support glyphs for Arabic.\n\nIf there are no more font families to be evaluated and no matching face has been found, then the user agent performs a system font fallback procedure to find the best match for the character to be rendered. The result of this procedure may vary across user agents.\n\nIf a particular character cannot be displayed using any font, the user agent should indicate by some means that a character is not being displayed, displaying either a symbolic representation of the missing glyph (e.g. using a Last Resort Font) or using the missing character glyph from a default font.\n\nOptimizations of this process are allowed provided that an implementation behaves as if the algorithm had been followed exactly. Matching occurs in a well-defined order to ensure that the results are as consistent as possible across user agents, given an identical set of available fonts and rendering technology.\n\nThe first available font, used for example in the definition of font-relative lengths such as ‘ex’ and ‘ch’ or in the definition of the ‘line-height’ property, is defined to be the first available font that would match the U+0020 (space) character given font families in the ‘font-family’ list (or a user agent's default font if none are available).\n\n5.3. Cluster matching\n\nWhen text contains characters such as combining marks, ideally the base character should be rendered using the same font as the mark, this assures proper placement of the mark. For this reason, the font matching algorithm for clusters is more specialized than the general case of matching a single character by itself. For sequences containing variation selectors, which indicate the precise glyph to be used for a given character, user agents always attempt system font fallback to find the appropriate glyph before using the default glyph of the base character.\n\nA sequence of codepoints containing combining mark or other modifiers is termed a grapheme cluster (see [CSS-TEXT-3] and [UAX29] for a more complete description). For a given cluster containing a base character, b and a sequence of combining characters c1, c2…, the entire cluster is matched using these steps:\n\nFor each family in the font list, a face is chosen using the style selection rules defined in the previous section.\n\nIf all characters in the sequence b + c1 + c2 … are completely supported by the font, select this font for the sequence.\n\nIf a sequence of multiple codepoints is canonically equivalent to a single character and the font supports that character, select this font for the sequence and use the glyph associated with the canonically equiavlent character for the entire cluster.\n\nIf no font was found in the font list in step 1:\n\nIf c1 is a variation selector, system fallback must be used to find a font that supports the full sequence of b + c1. If no font on the system supports the full sequence, match the single character b using the normal procedure for matching single characters and ignore the variation selector. Note: a sequence with more than one variation selector must be treated as an encoding error and the trailing selectors must be ignored. [UNICODE]\n\nOtherwise, the user agent may optionally use system font fallback to match a font that supports the entire cluster.\n\nIf no font is found in step 2, use the matching sequence from step 1 to determine the longest sequence that is completely supported by a font in the font list and attempt to match the remaining combining characters separately using the rules for single characters.\n\n5.4. Character handling issues\n\nCSS font matching is always performed on text runs containing Unicode characters [UNICODE], so documents using legacy encodings are assumed to have been transcoded before matching fonts. For fonts containing character maps for both legacy encodings and Unicode, the contents of the legacy encoding character map must have no effect on the results of the font matching process.\n\nThe font matching process does not assume that text runs are in either normalized or denormalized form (see [CHARMOD-NORM] for more details). Fonts may only support precomposed forms and not the decomposed sequence of base character plus combining marks. Authors should always tailor their choice of fonts to their content, including whether that content contains normalized or denormalized character streams.\n\nIf a given character is a Private-Use Area Unicode codepoint, user agents must only match font families named in the ‘font-family’ list that are not generic families. If none of the families named in the ‘font-family’ list contain a glyph for that codepoint, user agents must display some form of missing glyph symbol for that character rather than attempting system font fallback for that codepoint. When matching the replacement character U+FFFD, user agents may skip the font matching process and immediately display some form of missing glyph symbol, they are not required to display the glyph from the font that would be selected by the font matching process.\n\nIn general, the fonts for a given family will all have the same or similar character maps. The process outlined here is designed to handle even font families containing faces with widely variant character maps. However, authors are cautioned that the use of such families can lead to unexpected results.\n\n5.5. Font matching changes since CSS 2.1\n\nThe algorithm above is different from CSS 2.1 in a number of key places. These changes were made to better reflect actual font matching behavior across user agent implementations.\n\nDifferences compared to the font matching algorithm in CSS 2.1:\n\nThe algorithm includes font-stretch matching.\n\nAll possible font-style matching scenarios are delineated.\n\nSmall-caps fonts are not matched as part of the font matching process, they are now handled via font features.\n\nUnicode variation selector matching is required.\n\nCluster sequences are matched as a unit.\n\n5.6. Font matching examples\n\nIt's useful to note that the CSS selector syntax may be used to create language-sensitive typography. For example, some Chinese and Japanese characters are unified to have the same Unicode code point, although the abstract glyphs are not the same in the two languages.\n\n*:lang(ja) { font: 900 14pt/16pt \"Heisei Mincho W9\", serif; } *:lang(zh-Hant-TW) { font: 800 14pt/16.5pt \"Li Sung\", serif; }\n\nThis selects any element that has the given language — Japanese or Traditional Chinese as used in Taiwan — and uses the appropriate font.\n\n6. Font Feature Properties\n\nModern font technologies support a variety of advanced typographic and language-specific font features. Using these features, a single font can provide glyphs for a wide range of ligatures, contextual and stylistic alternates, tabular and old-style figures, small capitals, automatic fractions, swashes, and alternates specific to a given language. To allow authors control over these font capabilities, the ‘font-variant’ property has been expanded for CSS3. It now functions as a shorthand for a set of properties that provide control over stylistic font features.\n\n6.1. Glyph selection and positioning\n\nThis section is non-normative\n\nSimple fonts used for displaying Latin text use a very basic processing model. Fonts contain a character map which maps each character to a glyph for that character. Glyphs for subsequent characters are simply placed one after the other along a run of text. Modern font formats such as OpenType and AAT (Apple Advanced Typography) use a richer processing model. The glyph for a given character can be chosen and positioned not just based on the codepoint of the character itself, but also on adjacent characters as well as the language, script, and features enabled for the text. Font features may be required for specific scripts, or recommended as enabled by default or they might be stylistic features meant to be used under author control. The point at which font selection and positioning happens in the overall order of text processing operations (such as text transformation, text orientation and text alignment) is described in [CSS-TEXT-3], § Text Processing Order of Operations.\n\nFor a good visual overview of these features, see the [OPENTYPE-FONT-GUIDE]. For a detailed description of glyph processing for OpenType fonts, see [WINDOWS-GLYPH-PROC].\n\nStylistic font features can be classified into two broad categories: ones that affect the harmonization of glyph shapes with the surrounding context, such as kerning and ligature features, and ones such as the small-caps, subscript/superscript and alternate features that affect shape selection.\n\nThe subproperties of ‘font-variant’ listed below are used to control these stylistic font features. They do not control features that are required for displaying certain scripts, such as the OpenType features used when displaying Arabic or Indic language text. They affect glyph selection and positioning, but do not affect font selection as described in the font matching section (except in cases required for compatibility with CSS 2.1).\n\nTo assure consistent behavior across user agents, the equivalent OpenType property settings are listed for individual properties and are normative. When using other font formats these should be used as a guideline to map CSS font feature property values to specific font features.\n\n6.2. Language-specific display\n\nOpenType also supports language-specific glyph selection and positioning, so that text can be displayed correctly in cases where the language dictates a specific display behavior. Many languages share a common script, but the shape of certain letters can vary across those languages. For example, certain Cyrillic letters have different shapes in Russian text than in Bulgarian. In Latin text, it's common to render \"fi\" with an explicit fi-ligature that lacks a dot on the \"i\". However, in languages such as Turkish which uses both a dotted-i and a dotless-i, it's important to not use this ligature or use a specialized version that contains a dot over the \"i\". The example below shows language-specific variations based on stylistic traditions found in Spanish, Italian and French orthography:\n\nIf the content language of the element is known according to the rules of the document language, user agents are required to infer the OpenType language system from the content language and use that when selecting and positioning glyphs using an OpenType font.\n\n6.3. Kerning: the font-kerning property\n\nName: font-kerning Value: auto | normal | none Initial: auto Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: no\n\nKerning is the contextual adjustment of inter-glyph spacing. This property controls metric kerning, kerning that utilizes adjustment data contained in the font.\n\nauto\n\nSpecifies that kerning is applied at the discretion of the user agent\n\nnormal\n\nSpecifies that kerning is applied\n\nnone\n\nSpecifies that kerning is not applied\n\nFor fonts that do not include kerning data this property will have no visible effect. When rendering with OpenType fonts, the [OPENTYPE] specification suggests that kerning be enabled by default. When kerning is enabled, the OpenType kern feature is enabled (for vertical text runs the vkrn feature is enabled instead). User agents must also support fonts that only support kerning via data contained in a kern font table, as detailed in the OpenType specification. If the ‘letter-spacing’ property is defined, kerning adjustments are considered part of the default spacing and letter spacing adjustments are made after kerning has been applied.\n\nWhen set to ‘auto’, user agents can determine whether to apply kerning or not based on a number of factors: text size, script, or other factors that influence text processing speed. Authors who want proper kerning should use ‘normal’ to explicitly enable kerning. Likewise, some authors may prefer to disable kerning in situations where performance is more important than precise appearance. However, in well-designed modern implementations the use of kerning generally does not have a large impact on text rendering speed.\n\n6.4. Ligatures: the font-variant-ligatures property\n\nName: font-variant-ligatures Value: normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ] Initial: normal Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: no\n\nLigatures and contextual forms are ways of combining glyphs to produce more harmonized forms.\n\n<common-lig-values> = [ common-ligatures | no-common-ligatures ]\n\n<discretionary-lig-values> = [ discretionary-ligatures | no-discretionary-ligatures ]\n\n<historical-lig-values> = [ historical-ligatures | no-historical-ligatures ]\n\n<contextual-alt-values> = [ contextual | no-contextual ]\n\nIndividual values have the following meanings:\n\nnormal\n\nA value of ‘normal’ specifies that common default features are enabled, as described in detail in the next section. For OpenType fonts, common ligatures and contextual forms are on by default, discretionary and historical ligatures are not.\n\nnone\n\nSpecifies that all types of ligatures and contextual forms covered by this property are explicitly disabled. In situations where ligatures are not considered necessary, this may improve the speed of text rendering.\n\ncommon-ligatures\n\nEnables display of common ligatures (OpenType features: liga, clig). For OpenType fonts, common ligatures are enabled by default.\n\nno-common-ligatures\n\nDisables display of common ligatures (OpenType features: liga, clig).\n\ndiscretionary-ligatures\n\nEnables display of discretionary ligatures (OpenType feature: dlig). Which ligatures are discretionary or optional is decided by the type designer, so authors will need to refer to the documentation of a given font to understand which ligatures are considered discretionary.\n\nno-discretionary-ligatures\n\nDisables display of discretionary ligatures (OpenType feature: dlig).\n\nhistorical-ligatures\n\nEnables display of historical ligatures (OpenType feature: hlig).\n\nno-historical-ligatures\n\nDisables display of historical ligatures (OpenType feature: hlig).\n\ncontextual\n\nEnables display of contextual alternates (OpenType feature: calt). Although not strictly a ligature feature, like ligatures this feature is commonly used to harmonize the shapes of glyphs with the surrounding context. For OpenType fonts, this feature is on by default.\n\nno-contextual\n\nDisables display of contextual alternates (OpenType feature: calt).\n\nRequired ligatures, needed for correctly rendering complex scripts, are not affected by the settings above, including ‘none’ (OpenType feature: rlig).\n\n6.5. Subscript and superscript forms: the font-variant-position property\n\nName: font-variant-position Value: normal | sub | super Initial: normal Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: no\n\nThis property is used to enable typographic subscript and superscript glyphs. These are alternate glyphs designed within the same em-box as default glyphs and are intended to be laid out on the same baseline as the default glyphs, with no resizing or repositioning of the baseline. They are explicitly designed to match the surrounding text and to be more readable without affecting the line height.\n\nIndividual values have the following meanings:\n\nnormal\n\nNone of the features listed below are enabled.\n\nsub\n\nEnables display of subscript variants (OpenType feature: subs).\n\nsuper\n\nEnables display of superscript variants (OpenType feature: sups).\n\nBecause of the semantic nature of subscripts and superscripts, when the value is either ‘sub’ or ‘super’ for a given contiguous run of text, if a variant glyph is not available for all the characters in the run, simulated glyphs should be synthesized for all characters using reduced forms of the glyphs that would be used without this feature applied. This is done per run to avoid a mixture of variant glyphs and synthesized ones that would not align correctly. In the case of OpenType fonts that lack subscript or superscript glyphs for a given character, user agents must synthesize appropriate subscript and superscript glyphs.\n\nIn situations where text decorations are only applied to runs of text containing superscript or subscript glyphs, the synthesized glyphs may be used, to avoid problems with the placement of decorations.\n\nIn the past, user agents have used font-size and vertical-align to simulate subscripts and superscripts for the sub and sup elements. To allow a backwards compatible way of defining subscripts and superscripts, it is recommended that authors use conditional rules [CSS3-CONDITIONAL] so that older user agents will still render subscripts and superscripts via the older mechanism.\n\nBecause font-size: smaller is often used for these elements, the effective scaling factor applied to subscript and superscript text varies depending upon the size. For larger text, the font size is often reduced by a third but for smaller text sizes, the reduction can be much less. This allows subscripts and superscripts to remain readable even within elements using small text sizes. User agents should consider this when deciding how to synthesize subscript and superscript glyphs.\n\nThe OpenType font format defines subscript and superscript metrics in the OS/2 table [OPENTYPE] but these are not always accurate in practice and so cannot be relied upon when synthesizing subscript and superscript glyphs.\n\nAuthors should note that fonts typically only provide subscript and superscript glyphs for a subset of all characters supported by the font. For example, while subscript and superscript glyphs are often available for Latin numbers, glyphs for punctuation and letter characters are less frequently provided. The synthetic fallback rules defined for this property assure that subscripts and superscripts will always appear but the appearance may not match author expectations if the font used does not provide the appropriate alternate glyph for all characters contained in a subscript or superscript.\n\nThis property is not cumulative. Applying it to elements within a subscript or superscript won't nest the placement of a subscript or superscript glyph. Images contained within text runs where the value of this property is ‘sub’ or ‘super’ will be drawn just as they would if the value was ‘normal’.\n\nBecause of these limitations, ‘font-variant-position’ is not recommended for use in user agent stylesheets. Authors should use it in cases where subscripts or superscripts will only contain the narrow range of characters supported by the fonts specified.\n\nThe variant glyphs use the same baseline as the default glyphs would use. There is no shift in the placement along the baseline, so the use of variant glyphs doesn't affect the height of the inline box or alter the height of the linebox. This makes superscript and subscript variants ideal for situations where it's important that leading remain constant, such as in multi-column layout.\n\n6.6. Capitalization: the font-variant-caps property\n\nName: font-variant-caps Value: normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps Initial: normal Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: no\n\nThis property allows the selection of alternate glyphs used for small or petite capitals or for titling. These glyphs are specifically designed to blend well with the surrounding normal glyphs, to maintain the weight and readability which suffers when text is simply resized to fit this purpose.\n\nIndividual values have the following meanings:\n\nnormal\n\nNone of the features listed below are enabled.\n\nsmall-caps\n\nEnables display of small capitals (OpenType feature: smcp). Small-caps glyphs typically use the form of uppercase letters but are reduced to the size of lowercase letters.\n\nall-small-caps\n\nEnables display of small capitals for both upper and lowercase letters (OpenType features: c2sc, smcp).\n\npetite-caps\n\nEnables display of petite capitals (OpenType feature: pcap).\n\nall-petite-caps\n\nEnables display of petite capitals for both upper and lowercase letters (OpenType features: c2pc, pcap).\n\nunicase\n\nEnables display of mixture of small capitals for uppercase letters with normal lowercase letters (OpenType feature: unic).\n\ntitling-caps\n\nEnables display of titling capitals (OpenType feature: titl). Uppercase letter glyphs are often designed for use with lowercase letters. When used in all uppercase titling sequences they can appear too strong. Titling capitals are designed specifically for this situation.\n\nThe availability of these glyphs is based on whether a given feature is defined or not in the feature list of the font. User agents can optionally decide this on a per-script basis but should explicitly not decide this on a per-character basis.\n\nSome fonts may only support a subset or none of the features described for this property. For backwards compatibility with CSS 2.1, if ‘small-caps’ or ‘all-small-caps’ is specified but small-caps glyphs are not available for a given font, user agents should simulate a small-caps font, for example by taking a normal font and replacing the glyphs for lowercase letters with scaled versions of the glyphs for uppercase characters (replacing the glyphs for both upper and lowercase letters in the case of ‘all-small-caps’).\n\nThe ‘font-feature-settings’ property does not affect the decision of whether or not to use a simulated small-caps font.\n\n#example1 { font-variant-caps: small-caps; } #example2 { font-variant-caps: small-caps; font-feature-settings: 'smcp' 0; }\n\nFor fonts which don't support small caps, both #example1 and #example2 should be rendered with synthesized small caps. However, for fonts which do support small caps, #example1 should be rendered with native small caps, while #example2 should be rendered without any small-caps (native or synthesized).\n\nTo match the surrounding text, a font may provide alternate glyphs for caseless characters when these features are enabled but when a user agent simulates small capitals, it must not attempt to simulate alternates for codepoints which are considered caseless.\n\nIf either ‘petite-caps’ or ‘all-petite-caps’ is specified for a font that doesn't support these features, the property behaves as if ‘small-caps’ or ‘all-small-caps’, respectively, had been specified. If ‘unicase’ is specified for a font that doesn't support that feature, the property behaves as if ‘small-caps’ was applied only to lowercased uppercase letters. If ‘titling-caps’ is specified with a font that does not support this feature, this property has no visible effect. When simulated small capital glyphs are used, for scripts that lack uppercase and lowercase letters, ‘small-caps’, ‘all-small-caps’, ‘petite-caps’, ‘all-petite-caps’ and ‘unicase’ have no visible effect.\n\nWhen casing transforms are used to simulate small capitals, the casing transformations must match those used for the ‘text-transform’ property.\n\nAs a last resort, unscaled uppercase letter glyphs in a normal font may replace glyphs in a small-caps font so that the text appears in all uppercase letters.\n\nQuotes rendered italicised, with small-caps on the first line:\n\nblockquote { font-style: italic; } blockquote:first-line { font-variant: small-caps; } <blockquote>I'll be honor-bound to slap them like a haddock.</blockquote>\n\n6.7. Numerical formatting: the font-variant-numeric property\n\nName: font-variant-numeric Value: normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ] Initial: normal Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: no\n\nSpecifies control over numerical forms. The example below shows how some of these values can be combined to influence the rendering of tabular data with fonts that support these features. Within normal paragraph text, proportional numbers are used while tabular numbers are used so that columns of numbers line up properly:\n\nPossible combinations:\n\n<numeric-figure-values> = [ lining-nums | oldstyle-nums ]\n\n<numeric-spacing-values> = [ proportional-nums | tabular-nums ]\n\n<numeric-fraction-values> = [ diagonal-fractions | stacked-fractions ]\n\nIndividual values have the following meanings:\n\nnormal\n\nNone of the features listed below are enabled.\n\nlining-nums\n\nEnables display of lining numerals (OpenType feature: lnum).\n\noldstyle-nums\n\nEnables display of old-style numerals (OpenType feature: onum).\n\nproportional-nums\n\nEnables display of proportional numerals (OpenType feature: pnum).\n\ntabular-nums\n\nEnables display of tabular numerals (OpenType feature: tnum).\n\ndiagonal-fractions\n\nEnables display of lining diagonal fractions (OpenType feature: frac).\n\nstacked-fractions\n\nEnables display of lining stacked fractions (OpenType feature: afrc).\n\nordinal\n\nEnables display of letter forms used with ordinal numbers (OpenType feature: ordn).\n\nslashed-zero\n\nEnables display of slashed zeros (OpenType feature: zero).\n\nA simple flank steak marinade recipe, rendered with automatic fractions and old-style numerals:\n\n.amount { font-variant-numeric: oldstyle-nums diagonal-fractions; } <h4>Steak marinade:</h4> <ul> <li><span class=\"amount\">2</span> tbsp olive oil</li> <li><span class=\"amount\">1</span> tbsp lemon juice</li> <li><span class=\"amount\">1</span> tbsp soy sauce</li> <li><span class=\"amount\">1 1/2</span> tbsp dry minced onion</li> <li><span class=\"amount\">2 1/2</span> tsp italian seasoning</li> <li>Salt &amp; pepper</li> </ul> <p>Mix the meat with the marinade and let it sit covered in the refrigerator for a few hours or overnight.</p>\n\nNote that the fraction feature is only applied to values not the entire paragraph. Fonts often implement this feature using contextual rules based on the use of the slash (‘/’) character. As such, it's not suitable for use as a paragraph-level style.\n\n6.8. East Asian text rendering: the font-variant-east-asian property\n\nName: font-variant-east-asian Value: normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ] Initial: normal Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: no\n\nAllows control of glyph substitution and sizing in East Asian text.\n\n<east-asian-variant-values> = [ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]\n\n<east-asian-width-values> = [ full-width | proportional-width ]\n\nIndividual values have the following meanings:\n\nnormal\n\nNone of the features listed below are enabled.\n\njis78\n\nEnables rendering of JIS78 forms (OpenType feature: jp78).\n\njis83\n\nEnables rendering of JIS83 forms (OpenType feature: jp83).\n\njis90\n\nEnables rendering of JIS90 forms (OpenType feature: jp90).\n\njis04\n\nEnables rendering of JIS2004 forms (OpenType feature: jp04).\n\nThe various JIS variants reflect the glyph forms defined in different Japanese national standards. Fonts generally include glyphs defined by the most recent national standard but it's sometimes necessary to use older variants, to match signage for example.\n\nsimplified\n\nEnables rendering of simplified forms (OpenType feature: smpl).\n\ntraditional\n\nEnables rendering of traditional forms (OpenType feature: trad).\n\nThe ‘simplified’ and ‘traditional’ values allow control over the glyph forms for characters which have been simplified over time but for which the older, traditional form is still used in some contexts. The exact set of characters and glyph forms will vary to some degree by context for which a given font was designed.\n\nfull-width\n\nEnables rendering of full-width variants (OpenType feature: fwid).\n\nproportional-width\n\nEnables rendering of proportionally-spaced variants (OpenType feature: pwid).\n\nruby\n\nEnables display of ruby variant glyphs (OpenType feature: ruby). Since ruby text is generally smaller than the associated body text, font designers can design special glyphs for use with ruby that are more readable than scaled down versions of the default glyphs. Only glyph selection is affected, there is no associated font scaling or other change that affects line layout. The red ruby text below is shown with default glyphs (top) and with ruby variant glyphs (bottom). Note the slight difference in stroke thickness.\n\n6.9. Overall shorthand for font rendering: the font-variant property\n\nName: font-variant Value: normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby || [ sub | super ] ] Initial: normal Applies to: all elements Inherited: yes Percentages: see individual properties Media: visual Computed value: see individual properties Animatable: see individual properties\n\nThe ‘font-variant’ property is a shorthand for all font-variant subproperties. The value ‘normal’ resets all subproperties of ‘font-variant’ to their inital value. The ‘none’ value sets ‘font-variant-ligatures’ to ‘none’ and resets all other font feature properties to their initial value. Like other shorthands, using ‘font-variant’ resets unspecified ‘font-variant’ subproperties to their initial values. It does not reset the values of ‘font-feature-settings’.\n\n6.10. Low-level font feature settings control: the font-feature-settings property\n\nName: font-feature-settings Value: normal | <feature-tag-value> # Initial: normal Applies to: all elements Inherited: yes Percentages: N/A Media: visual Computed value: as specified Animatable: no\n\nThis property provides low-level control over OpenType font features. It is intended as a way of providing access to font features that are not widely used but are needed for a particular use case.\n\nAuthors should generally use ‘font-variant’ and its related subproperties whenever possible and only use this property for special cases where its use is the only way of accessing a particular infrequently used font feature.\n\n/* enable small caps and use second swash alternate */ font-feature-settings: \"smcp\", \"swsh\" 2;\n\nA value of ‘normal’ means that no change in glyph selection or positioning occurs due to this property.\n\nFeature tag values have the following syntax:\n\n<feature-tag-value> = <string> [ <integer> | on | off ]?\n\nThe <string> is a case-sensitive OpenType feature tag. As specified in the OpenType specification [OPENTYPE], feature tags contain four ASCII characters. Tag strings longer or shorter than four characters, or containing characters outside the U+20–7E codepoint range are invalid. Feature tags need only match a feature tag defined in the font, so they are not limited to explicitly registered OpenType features. Fonts defining custom feature tags should follow the tag name rules defined in the OpenType specification [OPENTYPE-FEATURES].\n\nFeature tags not present in the font are ignored; a user agent must not attempt to synthesize fallback behavior based on these feature tags. The one exception is that user agents may synthetically support the kern feature with fonts that contain kerning data in the form of a ‘kern’ table but lack kern feature support in the ‘GPOS’ table.\n\nIn general, authors should use the ‘font-kerning’ property to explicitly enable or disable kerning since this property always affects fonts with either type of kerning data.\n\nIf present, a value indicates an index used for glyph selection. An <integer> value must be 0 or greater. A value of 0 indicates that the feature is disabled. For boolean features, a value of 1 enables the feature. For non-boolean features, a value of 1 or greater enables the feature and indicates the feature selection index. A value of ‘on’ is synonymous with 1 and ‘off’ is synonymous with 0. If the value is omitted, a value of 1 is assumed.\n\nThe computed value of font-feature-settings is a map, so any duplicates in the specified value must not be preserved. If the same axis name appears more than once, the value associated with the last appearance supersedes any previous value for that axis.\n\nfont-feature-settings: \"dlig\" 1; /* dlig=1 enable discretionary ligatures */ font-feature-settings: \"smcp\" on; /* smcp=1 enable small caps */ font-feature-settings: 'c2sc'; /* c2sc=1 enable caps to small caps */ font-feature-settings: \"liga\" off; /* liga=0 no common ligatures */ font-feature-settings: \"tnum\", 'hist'; /* tnum=1, hist=1 enable tabular numbers and historical forms */ font-feature-settings: \"tnum\" \"hist\"; /* invalid, need a comma-delimited list */ font-feature-settings: \"silly\" off; /* invalid, tag too long */ font-feature-settings: \"PKRN\"; /* PKRN=1 enable custom feature */ font-feature-settings: dlig; /* invalid, tag must be a string */\n\nWhen values greater than the range supported by the font are specified, the behavior is explicitly undefined. For boolean features, in general these will enable the feature. For non-boolean features, out of range values will in general be equivalent to a 0 value. However, in both cases the exact behavior will depend upon the way the font is designed (specifically, which type of lookup is used to define the feature).\n\nAlthough specifically defined for OpenType feature tags, feature tags for other modern font formats that support font features may be added in the future. Where possible, features defined for other font formats should attempt to follow the pattern of registered OpenType tags.\n\nThe Japanese text below will be rendered with half-width kana characters:\n\nbody { font-feature-settings: \"hwid\"; /* Half-width OpenType feature */ } <p>毎日カレー食べてるのに、飽きない</p>\n\n7. Font Feature Resolution\n\nAs described in the previous section, font features can be enabled in a variety of ways, either via the use of ‘font-variant’ or ‘font-feature-settings’ in a style rule or within an @font-face rule. The resolution order for the union of these settings is defined below. Features defined via CSS properties are applied on top of layout engine default features.\n\n7.1. Default features\n\nFor OpenType fonts, user agents must enable the default features defined in the OpenType documentation for a given script and writing mode. Required ligatures, common ligatures and contextual forms must be enabled by default (OpenType features: rlig, liga, clig, calt), along with localized forms (OpenType feature: locl), and features required for proper display of composed characters and marks (OpenType features: ccmp, mark, mkmk). These features must always be enabled, even when the value of the ‘font-variant’ and ‘font-feature-settings’ properties is ‘normal’. Individual features are only disabled when explicitly overridden by the author, as when ‘font-variant-ligatures’ is set to ‘no-common-ligatures’. For handling complex scripts such as Arabic [ARABIC-TYPO], Khmer or Devanagari additional features are required. For upright text within vertical text runs, vertical alternates (OpenType feature: vert) must be enabled.\n\n7.2. Feature precedence\n\nGeneral and font specific font feature property settings are resolved in the order below, in ascending order of precedence. This ordering is used to construct a combined list of font features that affect a given text run.\n\nFont features enabled by default, including features required for a given script.\n\nIf the font is defined via an @font-face rule, the font features implied by the font-feature-settings descriptor in the @font-face rule.\n\nFont features implied by the value of the ‘font-variant’ property, the related ‘font-variant’ subproperties and any other CSS property that uses OpenType features (e.g. the ‘font-kerning’ property).\n\nFeature settings determined by properties other than ‘font-variant’ or ‘font-feature-settings’. For example, setting a non-default value for the ‘letter-spacing’ property disables common ligatures.\n\nFont features implied by the value of ‘font-feature-settings’ property.\n\nThis ordering allows authors to set up a general set of defaults for fonts within their @font-face rules, then override them with property settings for specific elements. General property settings override the settings in @font-face rules and low-level font feature settings override ‘font-variant’ property settings.\n\nFor situations where the combined list of font feature settings contains more than on"
    }
}