{
    "id": "dbpedia_108_3",
    "rank": 71,
    "data": {
        "url": "https://developer.android.com/guide/topics/resources/string-resource",
        "read_more_link": "",
        "language": "en",
        "title": "Android Developers",
        "top_image": "https://developer.android.com/static/images/social/android-developers.png",
        "meta_img": "https://developer.android.com/static/images/social/android-developers.png",
        "images": [
            "https://www.gstatic.com/devrel-devsite/prod/v80280542cfb431993d6ccf12e26a1c5862cffb314c3cfae3ff08e8374a93b7f7/android/images/lockup.svg",
            "https://www.gstatic.com/devrel-devsite/prod/v80280542cfb431993d6ccf12e26a1c5862cffb314c3cfae3ff08e8374a93b7f7/android/images/lockup.svg",
            "https://developer.android.com/static/guide/topics/resources/images/annotation-example-1.png",
            "https://developer.android.com/_static/android/images/logo-x.svg",
            "https://www.gstatic.com/images/icons/material/product/2x/youtube_48dp.png",
            "https://developer.android.com/_static/android/images/logo-linkedin.svg",
            "https://www.gstatic.com/devrel-devsite/prod/v80280542cfb431993d6ccf12e26a1c5862cffb314c3cfae3ff08e8374a93b7f7/android/images/lockup-google-for-developers.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://www.gstatic.com/devrel-devsite/prod/v80280542cfb431993d6ccf12e26a1c5862cffb314c3cfae3ff08e8374a93b7f7/android/images/favicon.svg",
        "meta_site_name": "Android Developers",
        "canonical_link": "https://developer.android.com/guide/topics/resources/string-resource",
        "text": "A string resource provides text strings for your application with optional text styling and formatting. There are three types of resources that can provide your application with strings:\n\nString\n\nXML resource that provides a single string.\n\nString Array\n\nXML resource that provides an array of strings.\n\nQuantity Strings (Plurals)\n\nXML resource that carries different strings for pluralization.\n\nAll strings are capable of applying some styling markup and formatting arguments. For information about styling and formatting strings, see the section about Formatting and Styling.\n\nString\n\nA single string that can be referenced from the application or from other resource files (such as an XML layout).\n\nNote: A string is a simple resource that is referenced using the value provided in the name attribute (not the name of the XML file). So, you can combine string resources with other simple resources in the one XML file, under one <resources> element.\n\nfile location:\n\nres/values/filename.xml\n\nThe filename is arbitrary. The <string> element's name is used as the resource ID.\n\ncompiled resource datatype:\n\nResource pointer to a String.\n\nresource reference:\n\nIn Java: R.string.string_name\n\nIn XML:@string/string_name\n\nsyntax:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <string name=\"string_name\" >text_string</string> </resources>\n\nelements:\n\n<resources>\n\nRequired. This must be the root node.\n\nNo attributes.\n\n<string>\n\nA string, which can include styling tags. Beware that you must escape apostrophes and quotation marks. For more information about how to properly style and format your strings see Formatting and Styling, below.\n\nattributes:\n\nname\n\nString. A name for the string. This name is used as the resource ID.\n\nexample:\n\nXML file saved at res/values/strings.xml:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <string name=\"hello\">Hello!</string> </resources>\n\nThis layout XML applies a string to a View:\n\n<TextView android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/hello\" />\n\nThis application code retrieves a string:\n\nKotlin\n\nval string: String = getString(R.string.hello)\n\nJava\n\nString string = getString(R.string.hello);\n\nYou can use either getString(int) or getText(int) to retrieve a string. getText(int) retains any rich text styling applied to the string.\n\nString array\n\nAn array of strings that can be referenced from the application.\n\nNote: A string array is a simple resource that is referenced using the value provided in the name attribute (not the name of the XML file). As such, you can combine string array resources with other simple resources in the one XML file, under one <resources> element.\n\nfile location:\n\nres/values/filename.xml\n\nThe filename is arbitrary. The <string-array> element's name is used as the resource ID.\n\ncompiled resource datatype:\n\nResource pointer to an array of Strings.\n\nresource reference:\n\nIn Java: R.array.string_array_name\n\nIn XML: @[package:]array/string_array_name\n\nsyntax:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <string-array name=\"string_array_name\"> <item >text_string</item> </string-array> </resources>\n\nelements:\n\n<resources>\n\nRequired. This must be the root node.\n\nNo attributes.\n\n<string-array>\n\nDefines an array of strings. Contains one or more <item> elements.\n\nattributes:\n\nname\n\nString. A name for the array. This name is used as the resource ID to reference the array.\n\n<item>\n\nA string, which can include styling tags. The value can be a reference to another string resource. Must be a child of a <string-array> element. Beware that you must escape apostrophes and quotation marks. See Formatting and Styling, below, for information about to properly style and format your strings.\n\nNo attributes.\n\nexample:\n\nXML file saved at res/values/strings.xml:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <string-array name=\"planets_array\"> <item>Mercury</item> <item>Venus</item> <item>Earth</item> <item>Mars</item> </string-array> </resources>\n\nThis application code retrieves a string array:\n\nKotlin\n\nval array: Array<String> = resources.getStringArray(R.array.planets_array)\n\nJava\n\nResources res = getResources(); String[] planets = res.getStringArray(R.array.planets_array);\n\nQuantity strings (plurals)\n\nDifferent languages have different rules for grammatical agreement with quantity. In English, for example, the quantity 1 is a special case. We write \"1 book\", but for any other quantity we'd write \"n books\". This distinction between singular and plural is very common, but other languages make finer distinctions. The full set supported by Android is zero, one, two, few, many, and other.\n\nThe rules for deciding which case to use for a given language and quantity can be very complex, so Android provides you with methods such as getQuantityString() to select the appropriate resource for you.\n\nAlthough historically called \"quantity strings\" (and still called that in API), quantity strings should only be used for plurals. It would be a mistake to use quantity strings to implement something like Gmail's \"Inbox\" versus \"Inbox (12)\" when there are unread messages, for example. It might seem convenient to use quantity strings instead of an if statement, but it's important to note that some languages (such as Chinese) don't make these grammatical distinctions at all, so you'll always get the other string.\n\nThe selection of which string to use is made solely based on grammatical necessity. In English, a string for zero is ignored even if the quantity is 0, because 0 isn't grammatically different from 2, or any other number except 1 (\"zero books\", \"one book\", \"two books\", and so on). Conversely, in Korean only the other string is ever used.\n\nDon't be misled either by the fact that, say, two sounds like it could only apply to the quantity 2: a language may require that 2, 12, 102 (and so on) are all treated like one another but differently to other quantities. Rely on your translator to know what distinctions their language actually insists upon.\n\nIf your message doesn't contain the quantity number, it is probably not a good candidate for a plural. For example, in Lithuanian the singular form is used for both 1 and 101, so \"1 book\" is translated as \"1 knyga\", and \"101 books\" is translated as \"101 knyga\". Meanwhile \"a book\" is \"knyga\" and \"many books\" is \"daug knygų\". If an English plural message contains \"a book\" (singular) and \"many books\" (plural) without the actual number, it can be translated as \"knyga\" (a book)/\"daug knygų\" (many books), but with Lithuanian rules, it will show \"knyga\" (a single book), when the number happens to be 101.\n\nIt's often possible to avoid quantity strings by using quantity-neutral formulations such as \"Books: 1\". This makes your life and your translators' lives easier, if it's an acceptable style for your application.\n\nOn API 24+ you can use the much more powerful ICU MessageFormat class instead.\n\nNote: A plurals collection is a simple resource that is referenced using the value provided in the name attribute (not the name of the XML file). As such, you can combine plurals resources with other simple resources in the one XML file, under one <resources> element.\n\nfile location:\n\nres/values/filename.xml\n\nThe filename is arbitrary. The <plurals> element's name is used as the resource ID.\n\nresource reference:\n\nIn Java: R.plurals.plural_name\n\nsyntax:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <plurals name=\"plural_name\"> <item quantity=[\"zero\" | \"one\" | \"two\" | \"few\" | \"many\" | \"other\"] >text_string</item> </plurals> </resources>\n\nelements:\n\n<resources>\n\nRequired. This must be the root node.\n\nNo attributes.\n\n<plurals>\n\nA collection of strings, of which, one string is provided depending on the amount of something. Contains one or more <item> elements.\n\nattributes:\n\nname\n\nString. A name for the pair of strings. This name is used as the resource ID.\n\n<item>\n\nA plural or singular string. The value can be a reference to another string resource. Must be a child of a <plurals> element. Beware that you must escape apostrophes and quotation marks. See Formatting and Styling, below, for information about to properly style and format your strings.\n\nattributes:\n\nquantity\n\nKeyword. A value indicating when this string should be used. Valid values, with non-exhaustive examples in parentheses:\n\nValueDescription zeroWhen the language requires special treatment of the number 0 (as in Arabic). oneWhen the language requires special treatment of numbers like one (as with the number 1 in English and most other languages; in Russian, any number ending in 1 but not ending in 11 is in this class). twoWhen the language requires special treatment of numbers like two (as with 2 in Welsh, or 102 in Slovenian). fewWhen the language requires special treatment of \"small\" numbers (as with 2, 3, and 4 in Czech; or numbers ending 2, 3, or 4 but not 12, 13, or 14 in Polish). manyWhen the language requires special treatment of \"large\" numbers (as with numbers ending 11-99 in Maltese). otherWhen the language does not require special treatment of the given quantity (as with all numbers in Chinese, or 42 in English).\n\nexample:\n\nXML file saved at res/values/strings.xml:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <plurals name=\"numberOfSongsAvailable\"> <!-- As a developer, you should always supply \"one\" and \"other\" strings. Your translators will know which strings are actually needed for their language. Always include %d in \"one\" because translators will need to use %d for languages where \"one\" doesn't mean 1 (as explained above). --> <item quantity=\"one\">%d song found.</item> <item quantity=\"other\">%d songs found.</item> </plurals> </resources>\n\nXML file saved at res/values-pl/strings.xml:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <plurals name=\"numberOfSongsAvailable\"> <item quantity=\"one\">Znaleziono %d piosenkę.</item> <item quantity=\"few\">Znaleziono %d piosenki.</item> <item quantity=\"other\">Znaleziono %d piosenek.</item> </plurals> </resources>\n\nUsage:\n\nKotlin\n\nval count = getNumberOfSongsAvailable() val songsFound = resources.getQuantityString(R.plurals.numberOfSongsAvailable, count, count)\n\nJava\n\nint count = getNumberOfSongsAvailable(); Resources res = getResources(); String songsFound = res.getQuantityString(R.plurals.numberOfSongsAvailable, count, count);\n\nWhen using the getQuantityString() method, you need to pass the count twice if your string includes string formatting with a number. For example, for the string %d songs found, the first count parameter selects the appropriate plural string and the second count parameter is inserted into the %d placeholder. If your plural strings do not include string formatting, you don't need to pass the third parameter to getQuantityString.\n\nFormat and style\n\nHere are a few important things you should know about how to properly format and style your string resources.\n\nHandle special characters\n\nWhen a string contains characters that have special usage in XML, you must escape the characters according to the standard XML/HTML escaping rules. If you need to escape a character that has special meaning in Android you should use a preceding backslash.\n\nBy default Android will collapse sequences of whitespace characters into a single space. You can avoid this by enclosing the relevant part of your string in double quotes. In this case all whitespace characters (including new lines) will get preserved within the quoted region. Double quotes will allow you to use regular single unescaped quotes as well.\n\nCharacter Escaped form(s) @ \\@ ? \\? New line \\n Tab \\t U+XXXX Unicode character \\uXXXX Single quote (')\n\nAny of the following:\n\n\\'\n\nEnclose the entire string in double quotes (\"This'll work\", for example)\n\nDouble quote (\") \\\"\n\nNote that surrounding the string with single quotes does not work.\n\nWhitespace collapsing and Android escaping happens after your resource file gets parsed as XML. This means that <string> &#32; &#8200; &#8195;</string> (space, punctuation space, Unicode Em space) all collapse to a single space (\" \"), because they are all Unicode spaces after the file is parsed as an XML. To preserve those spaces as they are, you can either quote them (<string>\" &#32; &#8200; &#8195;\"</string>) or use Android escaping (<string> \\u0032 \\u8200 \\u8195</string>).\n\nNote: From XML parser's perspective, there is no difference between <string>\"Test this\"</string> and <string>&quot;Test this&quot;</string> whatsoever. Both forms will not show any quotes but trigger Android whitespace-preserving quoting (that will have no practical effect in this case).\n\nFormatting strings\n\nIf you need to format your strings, then you can do so by putting your format arguments in the string resource, as demonstrated by the following example resource.\n\n<string name=\"welcome_messages\">Hello, %1$s! You have %2$d new messages.</string>\n\nIn this example, the format string has two arguments: %1$s is a string and %2$d is a decimal number. Then, format the string by calling getString(int, Object...). For example:\n\nStyling with HTML markup\n\nYou can add styling to your strings with HTML markup. For example:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <string name=\"welcome\">Welcome to <b>Android</b>!</string> </resources>\n\nThe following HTML elements are supported:\n\nBold: <b>\n\nItalic: <i>, <cite>, <dfn>, <em>\n\n25% larger text: <big>\n\n20% smaller text: <small>\n\nSetting font properties: <font face=”font_family“ color=”hex_color”>. Examples of possible font families include monospace, serif, and sans_serif.\n\nSetting a monospace font family: <tt>\n\nStrikethrough: <s>, <strike>, <del>\n\nUnderline: <u>\n\nSuperscript: <sup>\n\nSubscript: <sub>\n\nBullet points: <ul>, <li>\n\nLine breaks: <br>\n\nDivision: <div>\n\nCSS style: <span style=”color|background_color|text-decoration”>\n\nParagraphs: <p dir=”rtl | ltr” style=”…”>\n\nIf you aren't applying formatting, you can set TextView text directly by calling setText(java.lang.CharSequence). In some cases, however, you may want to create a styled text resource that is also used as a format string. Normally, this doesn't work because the format(String, Object...) and getString(int, Object...) methods strip all the style information from the string. The work-around to this is to write the HTML tags with escaped entities, which are then recovered with fromHtml(String), after the formatting takes place. For example:\n\nStore your styled text resource as an HTML-escaped string:\n\n<resources> <string name=\"welcome_messages\">Hello, %1$s! You have &lt;b>%2$d new messages&lt;/b>.</string> </resources>\n\nIn this formatted string, a <b> element is added. Notice that the opening bracket is HTML-escaped, using the &lt; notation.\n\nThen format the string as usual, but also call fromHtml(String) to convert the HTML text into styled text:\n\nKotlin\n\nval text: String = getString(R.string.welcome_messages, username, mailCount) val styledText: Spanned = Html.fromHtml(text, FROM_HTML_MODE_LEGACY)\n\nJava\n\nString text = getString(R.string.welcome_messages, username, mailCount); Spanned styledText = Html.fromHtml(text, FROM_HTML_MODE_LEGACY);\n\nBecause the fromHtml(String) method formats all HTML entities, be sure to escape any possible HTML characters in the strings you use with the formatted text, using htmlEncode(String). For instance, if you are formatting a string that contains characters such as \"<\" or \"&\", then they must be escaped before formatting, so that when the formatted string is passed through fromHtml(String), the characters come out the way they were originally written. For example:\n\nStyling with spannables\n\nA Spannable is a text object that you can style with typeface properties such as color and font weight. You use SpannableStringBuilder to build your text and then apply styles defined in the android.text.style package to the text.\n\nYou can use the following helper methods to set up much of the work of creating spannable text:\n\nThe following bold, italic, and color methods wrap the helper methods above and demonstrate specific examples of applying styles defined in the android.text.style package. You can create similar methods to do other types of text styling.\n\nHere's an example of how to chain these methods together to apply various styles to individual words within a phrase:\n\nThe core-ktx Kotlin module also contains extension functions that make working with spans even easier. You can check out the android.text package documentation on GitHub to learn more.\n\nFor more information on working with spans, see the following links:\n\nSpantastic text styling with Spans\n\nUnderstanding spans\n\nStyling with annotations\n\nYou can apply complex or custom styling by using the Annotation class along with the <annotation> tag in your strings.xml resource files. The annotation tag allows you to mark parts of the string for custom styling by defining custom key-value pairs in the XML that the framework then converts into Annotation spans. You can then retrieve these annotations and use the key and value to apply the styling.\n\nWhen creating annotations, make sure you add the <annotation> tag to all translations of the string in every strings.xml file.\n\nApplying a custom typeface to the word “text” in all languages\n\nExample - adding a custom typeface\n\nAdd the <annotation> tag, and define the key-value pair. In this case, the key is font, and the value is the type of font we want to use: title_emphasis\n\n// values/strings.xml <string name=\"title\">Best practices for <annotation font=\"title_emphasis\">text</annotation> on Android</string> // values-es/strings.xml <string name=\"title\"><annotation font=\"title_emphasis\">Texto</annotation> en Android: mejores prácticas</string>\n\nLoad the string resource and find the annotations with the font key. Then create a custom span and replace the existing span.\n\nKotlin\n\n// get the text as SpannedString so we can get the spans attached to the text val titleText = getText(R.string.title) as SpannedString // get all the annotation spans from the text val annotations = titleText.getSpans(0, titleText.length, Annotation::class.java) // create a copy of the title text as a SpannableString. // the constructor copies both the text and the spans. so we can add and remove spans val spannableString = SpannableString(titleText) // iterate through all the annotation spans for (annotation in annotations) { // look for the span with the key font if (annotation.key == \"font\") { val fontName = annotation.value // check the value associated to the annotation key if (fontName == \"title_emphasis\") { // create the typeface val typeface = getFontCompat(R.font.permanent_marker) // set the span at the same indices as the annotation spannableString.setSpan(CustomTypefaceSpan(typeface), titleText.getSpanStart(annotation), titleText.getSpanEnd(annotation), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) } } } // now, the spannableString contains both the annotation spans and the CustomTypefaceSpan styledText.text = spannableString\n\nJava\n\n// get the text as SpannedString so we can get the spans attached to the text SpannedString titleText = (SpannedString) getText(R.string.title); // get all the annotation spans from the text Annotation[] annotations = titleText.getSpans(0, titleText.length(), Annotation.class); // create a copy of the title text as a SpannableString. // the constructor copies both the text and the spans. so we can add and remove spans SpannableString spannableString = new SpannableString(titleText); // iterate through all the annotation spans for (Annotation annotation: annotations) { // look for the span with the key font if (annotation.getKey().equals(\"font\")) { String fontName = annotation.getValue(); // check the value associated to the annotation key if (fontName.equals(\"title_emphasis\")) { // create the typeface Typeface typeface = ResourcesCompat.getFont(this, R.font.roboto_mono); // set the span at the same indices as the annotation spannableString.setSpan(new CustomTypefaceSpan(typeface), titleText.getSpanStart(annotation), titleText.getSpanEnd(annotation), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); } } } // now, the spannableString contains both the annotation spans and the CustomTypefaceSpan styledText.text = spannableString;\n\nIf you’re using the same text multiple times, you should construct the SpannableString object once and reuse it as needed to avoid potential performance and memory issues.\n\nFor more examples of annotation usage, see Styling internationalized text in Android\n\nAnnotation spans and text parceling\n\nBecause Annotation spans are also ParcelableSpans, the key-value pairs are parceled and unparceled. As long as the receiver of the parcel knows how to interpret the annotations, you can use Annotation spans to apply custom styling to the parceled text.\n\nTo keep your custom styling when you pass the text to an Intent Bundle, you first need to add Annotation spans to your text. You can do this in the XML resources via the <annotation> tag, as shown in the example above, or in code by creating a new Annotation and setting it as a span, as shown below:\n\nRetrieve the text from the Bundle as a SpannableString and then parse the annotations attached, as shown in the example above.\n\nFor more information on text styling, see the following links:"
    }
}