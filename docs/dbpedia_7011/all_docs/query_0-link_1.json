{
    "id": "dbpedia_7011_0",
    "rank": 1,
    "data": {
        "url": "https://leanpub.com/lovinglisp/read",
        "read_more_link": "",
        "language": "en",
        "title": "Read Loving Common Lisp, or the Savvy Programmer's Secret Weapon",
        "top_image": "https://leanpub.com/assets/favicons/favicon-16x16-19545df363d1089bccdc59d17ee5b781.png",
        "meta_img": "https://leanpub.com/assets/favicons/favicon-16x16-19545df363d1089bccdc59d17ee5b781.png",
        "images": [
            "https://d2sofvawe08yqg.cloudfront.net/lovinglisp/s_shelf?1620384636",
            "https://leanpub.com/site_images/lovinglisp/test-plotlib.png",
            "https://leanpub.com/site_images/lovinglisp/solr1.png",
            "https://leanpub.com/site_images/lovinglisp/solr2.png",
            "https://leanpub.com/site_images/lovinglisp/solr3.png",
            "https://leanpub.com/site_images/lovinglisp/nn_backprop2d.png",
            "https://leanpub.com/site_images/lovinglisp/output_plot_000000000000.png",
            "https://leanpub.com/site_images/lovinglisp/output_plot_000000000400.png",
            "https://leanpub.com/site_images/lovinglisp/output_plot_000000002400.png",
            "https://leanpub.com/site_images/lovinglisp/nn_sigmoid.png",
            "https://leanpub.com/site_images/lovinglisp/output_plot_hopfield_nn_00002.png",
            "https://leanpub.com/site_images/lovinglisp/output_plot_hopfield_nn_00005.png",
            "https://leanpub.com/site_images/lovinglisp/output_plot_hopfield_nn_00007.png",
            "https://leanpub.com/site_images/lovinglisp/semantic_web_data.png",
            "https://leanpub.com/site_images/lovinglisp/neo4j.jpg",
            "https://leanpub.com/site_images/lovinglisp/neo4j_ex1.jpg",
            "https://leanpub.com/site_images/lovinglisp/GraphDB.jpg",
            "https://leanpub.com/site_images/lovinglisp/kgn1.png",
            "https://leanpub.com/site_images/lovinglisp/kgnpopup.png",
            "https://leanpub.com/site_images/lovinglisp/info-pane-browser.png",
            "https://leanpub.com/site_images/lovinglisp/wolfram1.jpg",
            "https://leanpub.com/site_images/lovinglisp/wolfram2.jpg",
            "https://leanpub.com/assets/logos/logo-white-96-67-2x-cbf54f68046da93161c6375a4d74259d.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://leanpub.com/assets/favicons/apple-touch-icon-57x57-3dc48b9be1873ac9bf6d580e7836e3e5.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Cover Material, Copyright, and License\n\nCopyright 2011-2023 Mark Watson. All rights reserved. This book may be shared using the Creative Commons âshare and share alike, no modifications, no commercial reuseâ license.\n\nThis eBook will be updated occasionally so please periodically check the leanpub.com web page for this book for updates.\n\nIf you read my eBooks free online then please consider tipping me https://markwatson.com/#tip.\n\nThis is the eighth edition released August 2022.\n\nPlease visit the authorâs website.\n\nIf you found a copy of this book on the web and find it of value then please consider buying a copy at leanpub.com/lovinglisp.\n\nIf you would like to support my work please consider purchasing my books on Leanpub and star my git repositories that you find useful on GitHub. You can also interact with me on social media on Mastodon and Twitter.\n\nPreface\n\nNotes on the Eighth Edition Published August 2022\n\nThe main change is splitting the Knowledge Graph Navigator (KGN) chapter that features the LispWorks CAPI UI APIs into three chapters for a library for KGN functionality, a text based (console) UI, and a CAPI based UI. I added examples using the OpenAI GPT-3 APIs. There are other small corrections and improvements.\n\nNotes on the Seventh Edition Published March 2021\n\nI added two short chapters to the previous edition: Knowledge Graph Sampler for Creating Small Custom Knowledge Graphs and Using Common Lisp With Wolfram/One.\n\nNotes on the Sixth Edition Published June 2020\n\nTwo examples optionally use the CAPI user interface toolkit provided with LispWorks Common Lisp and work with the free personal edition. The first CAPI application is Knowledge Graph Navigator and the second CAPI example is Knowledge Graph Creator. Both of these examples build up utilities for working with Knowledge Graphs and the Semantic Web.\n\nI expand the Plot Library chapter to generate either PNG graphics files or if you are using the free personal edition of LispWorks you can also direct plotting output to a new window in interactive programs.\n\nI added a new chapter on using the py4cl library to embed Python libraries and application code into a Common Lisp system. I provide new examples for embedding spaCy and TensorFlow applications in Common Lisp applications. In earlier editions, I used a web services interface to wrap Python code using spaCy and TensorFlow. I am leaving that chapter intact, renaming it from âUsing Python Deep Learning Models In Common Lispâ to âUsing Python Deep Learning Models In Common Lisp With a Web Services Interface.â The new chapter for this edition is âUsing the PY4CL Library to Embed Python in Common Lisp.â\n\nNotes on the Fifth Edition Published September 2019\n\nThere were two chapters added:\n\nA complete application for processing text to generate data for Knowledge Graphs (targeting the open source Neo4J graph database and also support RDF semantic web/linked data).\n\nA library for accessing the state of the art spaCy natural language processing (NLP) library and also a state of the art deep learning model. These models are implemented in thin Python wrappers that use Python libraries like spaCy, PyTorch, and TensorFlow. These examples replace a simple hybrid Java and Common Lisp example in previous editions.\n\nI have added text and explanations as appropriate throughout the book and I removed the CouchDB examples.\n\nI have made large changes to how the code for this book is packaged. I have reorganized the example code on GitHub by providing the examples as multiple Quicklisp libraries or applications. I now do this with all of my Common Lisp code and it makes it easier to write smaller libraries that can be composed into larger applications. In my own workflow, I also like to use Makefile targets to build standalone applications that can be run on other computers without installing Lisp development environments. Please follow the directions at the end of the Preface for configuring Quicklisp for easy builds and use of the example software for this book.\n\nWhy Use Common Lisp?\n\nWhy Common Lisp? Isnât Common Lisp an old language? Do many people still use Common Lisp?\n\nI believe that using Lisp languages like Common Lisp, Clojure, Racket, and Scheme are all secret weapons useful in agile software development. An interactive development process and live production updates feel like a breath of fresh air if you have development on heavy weight like Java Enterprise Edition (JEE).\n\nYes, Common Lisp is an old language but with age comes stability and extremely good compiler technology. There is also a little inconsistency between different Common Lisp systems in such things as handling threads but with a little up front knowledge you can choose which Common Lisp systems will support your requirements.\n\nA Request from the Author\n\nI spent time writing this book to help you, dear reader. I release this book under the Creative Commons License and set the minimum purchase price to $0.00 (free!) in order to reach the most readers. Under this license you can share a PDF version of this book with your friends and coworkers and I encourage you to do so. If you found this book on the web (or it was given to you) and if it provides value to you then please consider doing one of the following to support my future writing efforts and also to support future updates to this book:\n\nPurchase a copy of this book leanpub.com/lovinglisp/ or any other of my leanpub books at https://leanpub.com/u/markwatson\n\nHire me as a consultant\n\nI enjoy writing and your support helps me write new editions and updates for my books and to develop new book projects. Thank you!\n\nOlder Book Editions\n\nThe fourth edition of this book was released in May 2017 and the major changes were:\n\nAdded an example application KGCreator that processes text data to automatically generate data for Knowledge Graphs. This example application supports the Neo4J graph database as well as semantic web/linked data systems. The major changes were:\n\nAdded a backpropagation neural network example\n\nAdded a deep learning example using the Java based Armed Bear Common Lisp with the popular DeepLearning4j library\n\nAdded a heuristic search example\n\nAdded two machine learning examples (K-Means clustering and SVM classification) using the CLML library\n\nA few edits to the previous text\n\nThe third edition was released in October 2014. The major changes made in the 2014 edition are:\n\nI reworked the chapter Common Lisp Basics.\n\nI added material to the chapter on using QuickLisp.\n\nThe second edition was released in 2013 and was derived from the version that I distributed on my web site and I moved production of the book to leanpub.com.\n\nAcknowledgments\n\nI would like to thank Jans Aasman for contributing as technical editor for the fourth edition of this book. Jans is CEO of Franz.com which sells Allegro Common Lisp as well as tools for semantic web and linked data applications.\n\nI would like to thank the following people who made suggestions for improving previous editions of this book:\n\nSam Steingold, Andrew Philpot, Kenny Tilton, Mathew Villeneuve, Eli Draluk, Erik Winkels, Adam Shimali, and Paolo Amoroso.\n\nI would like to also thank several people who pointed out typo errors in this book and for specific suggestions: Martin Lightheart, Tong-Kiat Tan, Rainer Joswig, Gerold Rupprecht, HN member rurban, David Cortesi. I would like to thank the following Reddit /r/lisp readers who pointed out mistakes in the fifth edition of this book: arnulfslayer, rpiirp, and itmuckel. I would like to thank Ted Briscoe for pointing out a problem with the spacy web client example in the 6th edition.\n\nI would like to thank Paul Graham for coining the phrase âThe Secret Weaponâ (in his excellent paper âBeating the Averagesâ) in discussing the advantages of Lisp and giving me permission to reuse his phrase.\n\nI would especially like to thank my wife Carol Watson for her fine work in editing this book.\n\nSetting Up Your Common Lisp Development System and Quicklisp\n\nThese instructions assume the use of SBCL. See comments for LispWorks, Franz Common Lisp, and Closure Common List at the end of this section. I assume that you have installed SBCL and Quicklisp by following the instructions at lisp-lang.org/learn/getting-started. These instructions also guide you through installing the Slime extensions for Emacs. I use both Emacs + Slime and VSCode with Common Lisp plugins for editing Common Lisp. If you like VSCode then I recommend Yasuhiro Matsumotoâs Lisp plugin for syntax highlighting. For both Emacs and VSCode I usually run a separate REPL in a terminal window and donât run an editor-integrated REPL. I think that I am in the minority in using a separate REPL running in a shell.\n\nI have been using Common Lisp since about 1982 and Quicklisp (developed and maintained by Zach Beane) has been the most revolutionary change in my Common Lisp development (even more so than getting a hardware Lisp Machine and the availability of Coral Common Lisp on the Macintosh).\n\nYou can follow the directions on the main GitHub repository for this book: https://github.com/mark-watson/loving-common-lisp to get the examples set up to run on your computer. Starting with the 8th edition, I have a new scheme for distributing the book examples on GitHub:\n\nA few short example Common Lisp code snippets are still kept in the main repository for the book: https://github.com/mark-watson/loving-common-lisp.\n\nThe longer examples are now stored in separate GitHub repositories to facilitate using them as reusable Quicklisp libraries.\n\nClone the main GitHub repository and copy the Makefile to the directory ~/quicklisp/local-projects/ on your computer.\n\nChange directory to ~/quicklisp/local-projects/ and run the Makefile target make fetch to copy all separate GitHub repositories to subdirectories of ~/quicklisp/local-projects/.\n\nYou can now load any book example using Quicklisp, for example: (ql:quickload :sparql).\n\nFor example, the subdirectory loving-common-lisp/src/spacy-py4cl contains a package named spacy-py4cl that can now be accessed from any directory on your system using:\n\nThis example uses the deep learning NLP models in spaCy which is a Python library - see the chapter on NLP for details on installing the Python dependencies. Note that only a few examples in this book require Python dependencies.\n\nI have used the SBCL implementation of Common Lisp in this book. There are many fine Common Lisp implementations from Franz, LispWorks, Clozure Common Lisp, etc. I usually use LispWorks for my professional development work. If you have any great difficulty adopting the examples to your choice of Common Lisp implementations and performing web search does not suggest a solution then you can reach me through my web site, markwatson.com.\n\nIntroduction\n\nThis book is intended to get you, the reader, programming quickly in Common Lisp. Although the Lisp programming language is often associated with artificial intelligence, this introduction is on general Common Lisp programming techniques. Later we will look at general example applications and artificial intelligence examples.\n\nThe Common Lisp program examples are distributed on the github repo for this book.\n\nWhy Did I Write this Book?\n\nWhy the title âLoving Common Lispâ? Simple! I have been using Lisp for almost 40 years and seldom do I find a better match between a programming language and the programming job at hand. I am not a total fanatic on Lisp, however. I often use Python for deep learning. I like Ruby, Java and Javascript for server side programming, and the few years that I spent working on Nintendo video games and virtual reality systems for SAIC and Disney, I found C++ to be a good bet because of stringent runtime performance requirements. For some jobs, I find the logic-programming paradigm useful: I also enjoy the Prolog language.\n\nIn any case, I love programming in Lisp, especially the industry standard Common Lisp. As I wrote the second edition of this book over a decade ago, I had been using Common Lisp almost exclusively for an artificial intelligence project for a health care company and for commercial product development. While working on the third edition of this book, I was not using Common Lisp professionally but since the release of the Quicklisp Common Lisp package manager I have found myself enjoying using Common Lisp more for small side projects. I use Quicklisp throughout in the third edition example code so you can easily install required libraries. For the fourth and fifth editions of this book I have added more examples using neural networks and deep learning. In this new sixth edition I have added a complete application that uses CAP for the user interface.\n\nAs programmers, we all (hopefully) enjoy applying our experience and brains for tackling interesting problems. My wife and I recently watched a two-night 7-hour PBS special âJoseph Campbell, and the Power of Myths.â Campbell, a college professor for almost 40 years, said that he always advised his students to âfollow their blissâ and not to settle for jobs and avocations that are not what they truly want to do. That said I always feel that when a job calls for using Java, Python or other languages besides Lisp, that even though I may get a lot of pleasure from the job I am not following my bliss.\n\nMy goal in this book is to introduce you to one of my favorite programming languages, Common Lisp. I assume that you already know how to program in another language but if you are a complete beginner you can still master the material in this book with some effort. I challenge you to make this effort.\n\nThere are several Common Lisp compilers and runtime tools available for free on the web:\n\nCLISP â licensed under the GNU GPL and is available for Windows, Macintosh, and Linux/Unix\n\nClozure Common Lisp (CCL) â open source with good Mac OS X and Linux support\n\nCMU Common Lisp â open source implementation\n\nSBCL â derived from CMU Common Lisp\n\nECL â compiles using a separate C/C++ compiler\n\nABCL â Armed Bear Common Lisp for the JVM\n\nThere are also fine commercial Common Lisp products:\n\nLispWorks â high quality and reasonably priced system for Windows and Linux. No charge for distributing compiled applications lispworks.com\n\nAllegro Common Lisp - high quality, great support and higher cost. franz.com\n\nMCL â Macintosh Common Lisp. I used this Lisp environment in the late 1980s. MCL was so good that I gave away my Xerox 1108 Lisp Machine and switched to a Mac and MCL for my development work. Now open source but only runs on the old MacOS\n\nI currently (mostly) use SBCL, CCL, and LispWorks. The SBCL compiler produces very fast code and the compiler warning can be of great value in finding potential problems with your code. Like CCL because it compiles quickly so is often preferable for development.\n\nFor working through this book, I will assume that you are using SBCL or CCL. For the example in the last chapter you will need LispWorks and the free Personal edition is fine for the purposes of experimenting with the example application and the CAPI user interface library.\n\nMaking Book Examples Run Portably on Most Common Lisp Implementations\n\nMany of the book examples require making web service calls. In general when I am writing Common Lisp applications that require making REST calls I prefer using 3rd party Common Lisp libraries like Drakma or Dexador. However it is sometimes a little tricky to set up Common Lisp on different operating systems and CPU architectures with libopenssl, libcrypto, etc. Because of this, in book examples I run the external curl program using uiop:run-program and collect the output as a string that is then parsed as JSON or CSV data. The overhead of starting an external process is very small compared to calling a web service so in your own applications you can either follow my example of using curl or use the Drakma or Dexador libraries. Using the Apple M1 processor on macOS can be particularly problematic with OpenSSL issues.\n\nI also use the excellent Common Lisp to Python bridge library py4cl in a few book examples. Usually py4cl installs without problems.\n\nHow is Lisp Different from Languages like Java and C++?\n\nThis is a trick question! Lisp is slightly more similar to Java than C++ because of automated memory management so we will start by comparing Lisp and Java.\n\nIn Java, variables are strongly typed while in Common Lisp values are strongly typed. For example, consider the Java code:\n\nHere, in Java, variables are strongly typed so a variable x of type Float canât legally be assigned a string value: the code in line 5 would generate a compilation error. Lisp code can assign a value to a variable and then reassign another value of a different type.\n\nJava and Lisp both provide automatic memory management. In either language, you can create new data structures and not worry about freeing memory when the data is no longer used, or to be more precise, is no longer referenced.\n\nCommon Lisp is an ANSI standard language. Portability between different Common Lisp implementations and on different platforms is very good. I have used Clozure Common Lisp, SBCL, Allegro Lisp (from Franz Inc), LispWorks, and CLISP that all run well on Windows, Mac OS X, and Linux. As a Common Lisp developer you will have great flexibility in tools and platforms.\n\nANSI Common Lisp was the first object oriented language to become an ANSI standard language. The Common Lisp Object System (CLOS) is probably the best platform for object oriented programming.\n\nIn C++ programs, a common bug that affects a programâs efficiency is forgetting to free memory that is no longer used. In a virtual memory system, the effect of a programâs increasing memory usage is usually just poorer system performance but can lead to system crashes or failures if all available virtual memory is exhausted. A worse type of C++ error is to free memory and then try to use it. Can you say âprogram crashâ? C programs suffer from the same types of memory related errors.\n\nSince computer processing power is usually much less expensive than the costs of software development, it is almost always worth while to give up a few percent of runtime efficiency and let the programming environment of runtime libraries manage memory for you. Languages like Lisp, Ruby, Python, and Java are said to perform automatic garbage collection.\n\nI have written six books on Java, and I have been quoted as saying that for me, programming in Java is about twice as efficient (in terms of my time) as programming in C++. I base this statement on approximately ten years of C++ experience on projects for SAIC, PacBell, Angel Studios, Nintendo, and Disney. I find Common Lisp and other Lisp languages like Clojure and Scheme to be about twice as efficient (again, in terms of my time) as Java. That is correct: I am claiming a four times increase in my programming productivity when using Common Lisp vs. C++.\n\nWhat do I mean by programming productivity? Simple: for a given job, how long does it take me to design, code, debug, and later maintain the software for a given task.\n\nAdvantages of Working in a Lisp Environment\n\nWe will soon see that Lisp is not just a language; it is also a programming environment and runtime environment.\n\nThe beginning of this book introduces the basics of Lisp programming. In later chapters, we will develop interesting and non-trivial programs in Common Lisp that I argue would be more difficult to implement in other languages and programming environments.\n\nThe big win in programming in a Lisp environment is that you can set up an environment and interactively write new code and test new code in small pieces. We will cover programming with large amounts of data in the Chapter on Natural Language Processing, but let me share a a general use case for work that I do that is far more efficient in Lisp:\n\nMuch of my Lisp programming used to be writing commercial natural language processing (NLP) programs for my company www.knowledgebooks.com. My Lisp NLP code uses a large amount of memory resident data; for example: hash tables for different types of words, hash tables for text categorization, 200,000 proper nouns for place names (cities, counties, rivers, etc.), and about 40,000 common first and last names of various nationalities.\n\nIf I was writing my NLP products in C++, I would probably use a relational database to store this data because if I read all of this data into memory for each test run of a C++ program, I would wait 30 seconds every time that I ran a program test. When I start working in any Common Lisp environment, I do have to load the linguistic data into memory one time, but then can code/test/code/testâ¦ for hours with no startup overhead for reloading the data that my programs need to run. Because of the interactive nature of Lisp development, I can test small bits of code when tracking down errors and when writing new code.\n\nIt is a personal preference, but I find the combination of the stable Common Lisp language and an iterative Lisp programming environment to be much more productive than other languages and programming environments.\n\nCommon Lisp Basics\n\nThe material in this chapter will serve as an introduction to Common Lisp. I have attempted to make this book a self contained resource for learning Common Lisp and to provide code examples to perform common tasks. If you already know Common Lisp and bought this book for the code examples later in this book then you can probably skip this chapter.\n\nFor working through this chapter we will be using the interactive shell, or repl, built into SBCL and other Common Lisp systems. For this chapter it is sufficient for you to download and install SBCL. Please install SBCL right now, if you have not already done so.\n\nGetting Started with SBCL\n\nWhen we start SBCL, we see an introductory message and then an input prompt. We will start with a short tutorial, walking you through a session using SBCL repl (other Common LISP systems are very similar). A repl is an interactive console where you type expressions and see the results of evaluating these expressions. An expression can be a large block of code pasted into the repl, using the load function to load Lisp code into the repl, calling functions to test them, etc. Assuming that SBCL is installed on your system, start SBCL by running the SBCL program:\n\nWe started by defining a new variable x in line 11. Notice how the value of the defvar macro is the symbol that is defined. The Lisp reader prints X capitalized because symbols are made upper case (we will look at the exception later).\n\nIn Lisp, a variable can reference any data type. We start by assigning a floating point value to the variable x, using the + function to add 1 to x in line 17, using the setq function to change the value of x in lines 23 and 29 first to another floating point value and finally setting x to a string value. One thing that you will have noticed: function names always occur first, then the arguments to a function. Also, parenthesis is used to separate expressions.\n\nI learned to program Lisp in 1976 and my professor half-jokingly told us that Lisp was an acronym for âLots-of Irritating Superfluous Parenthesis.â There may be some truth in this when you are just starting with Lisp programming, but you will quickly get used to the parenthesis, especially if you use an editor like Emacs that automatically indents Lisp code for you and highlights the opening parenthesis for every closing parenthesis that you type. Many other editors support coding in Lisp but I personally use Emacs or sometimes VScode (with Common Lisp plugins) to edit Lisp code.\n\nBefore you proceed to the next chapter, please take the time to install SBCL on your computer and try typing some expressions into the Lisp listener. If you get errors, or want to quit, try using the quit function:\n\nIf you get an error you can enter help to get options for handling an error. When I get an error and have a good idea of what caused the error then I just enter :a: to abort out of the error).\n\nAs we discussed in the introduction, there are many different Lisp programming environments that you can choose from. I recommend a free set of tools: Emacs, Quicklisp, slime, and SBCL. Emacs is a fine text editor that is extensible to work well with many programming languages and document types (e.g., HTML and XML). Slime is an Emacs extension package that greatly facilitates Lisp development. SBCL is a robust Common Lisp compiler and runtime system that is often used in production.\n\nWe will cover the Quicklisp package manager and using Quicklisp to setup Slime and Emacs in a later chapter.\n\nI will not spend much time covering the use of Emacs as a text editor in this book since you can try most of the example code snippets in the book text by copying and then pasting them into a SBCL repl and by loading the book example source files directly into a repl. If you already use Emacs then I recommend that you do set up Slime sooner rather than later and start using it for development. If you are not already an Emacs user and do not mind spending the effort to learn Emacs, then search the web first for an Emacs tutorial. That said, you will easily be able to use the example code from this book using any text editor you like with a SBCL repl. I donât use the vi or vim editors but if vi is your weapon of choice for editing text then a web search for âcommon lisp vi vim replâ should get you going for developing Common Lisp code with vi or vim. If you are not already an Emacs or vi user then using VSCode with a Common Lisp plugin is recommended.\n\nHere, we will assume that under Windows, Unix, Linux, or Mac OS X you will use one command window to run SBCL and a separate editor that can edit plain text files.\n\nMaking the repl Nicer using rlwrap\n\nWhile reading the last section you (hopefully!) played with the SBCL interactive repl. If you havenât played with the repl, I wonât get too judgmental except to say that if you do not play with the examples as you read you will not get the full benefit from this book.\n\nDid you notice that the backspace key does not work in the SBCL repl? The way to fix this is to install the GNU rlwrap utility. On OS X, assuming that you have homebrew installed, install rlwrap with:\n\nIf you are running Ubuntu Linux, install rlwrap using:\n\nYou can then create an alias for bash or zsh using something like the following to define a command rsbcl:\n\nThis is fine, just remember to run sbcl if you donât need rlwrap command line editing or run rsbcl when you do need command line editing. That said, I find that I always want to run SBCL with command line editing, so I redefine sbcl on my computers using:\n\nThis alias is different on my laptops and servers, since I donât usually install SBCL in the default installation directory. For each of my computers, I add an appropriate alias in my .zshrc file (if I am running zsh) or my .bashrc file (if I am running bash).\n\nThe Basics of Lisp Programming\n\nAlthough we will use SBCL in this book, any Common Lisp environment will do fine. In previous sections, we saw the top-level Lisp prompt and how we could type any expression that would be evaluated:\n\nNotice that when we defined the function my-add-one in lines 7 and 8, we split the definition over two lines and on line 8 you donât see the â*â prompt from SBCL â this lets you know that you have not yet entered a complete expression. The top level Lisp evaluator counts parentheses and considers a form to be complete when the number of closing parentheses equals the number of opening parentheses and an expression is complete when the parentheses match. I tend to count in my head, adding one for every opening parentheses and subtracting one for every closing parentheses â when I get back down to zero then the expression is complete. When we evaluate a number (or a variable), there are no parentheses, so evaluation proceeds when we hit a new line (or carriage return).\n\nThe Lisp reader by default tries to evaluate any form that you enter. There is a reader macro â that prevents the evaluation of an expression. You can either use the â character or quote:\n\nLisp supports both global and local variables. Global variables can be declared using defvar:\n\nOne thing to be careful of when defining global variables with defvar: the declared global variable is dynamically scoped. We will discuss dynamic versus lexical scoping later, but for now a warning: if you define a global variable avoid redefining the same variable name inside functions. Lisp programmers usually use a global variable naming convention of beginning and ending dynamically scoped global variables with the * character. If you follow this naming convention and also do not use the * character in local variable names, you will stay out of trouble. For convenience, I do not always follow this convention in short examples in this book.\n\nLisp variables have no type. Rather, values assigned to variables have a type. In this last example, the variable x was set to a string, then to a floating-point number. Lisp types support inheritance and can be thought of as a hierarchical tree with the type t at the top. (Actually, the type hierarchy is a DAG, but we can ignore that for now.) Common Lisp also has powerful object oriented programming facilities in the Common Lisp Object System (CLOS) that we will discuss in a later chapter.\n\nHere is a partial list of types (note that indentation denotes being a subtype of the preceding type):\n\nWe can use the typep function to test the type of value of any variable or expression or use type-of to get type information of any value):\n\nA useful feature of all ANSI standard Common Lisp implementationsâ top-level listener is that it sets * to the value of the last expression evaluated. For example:\n\nAll Common Lisp environments set * to the value of the last expression evaluated. This example may be slightly confusing because * is also the prompt character in the SBCL repl that indicates that you can enter a new expression for evaluation. For example in line 3, the first * character is the repl prompt and the second * we type in to see that value of the previous expression that we typed into the repl.\n\nFrequently, when you are interactively testing new code, you will call a function that you just wrote with test arguments; it is useful to save intermediate results for later testing. It is the ability to create complex data structures and then experiment with code that uses or changes these data structures that makes Lisp programming environments so effective.\n\nCommon Lisp is a lexically scoped language that means that variable declarations and function definitions can be nested and that the same variable names can be used in nested let forms; when a variable is used, the current let form is searched for a definition of that variable and if it is not found, then the next outer let form is searched. Of course, this search for the correct declaration of a variable is done at compile time so there need not be extra runtime overhead. We should not nest defun special form inside each other or inside let expressions. Instead we use the special forms flet and labels to define functions inside a scoped environment. Functions defined inside a labels special form can be recursive while functions defined inside a flet special form cannot be recursive. Consider the following example in the file nested.lisp (all example files are in the src directory):\n\nWe define a top level flet special form in lines 1-5 that defines two nested functions add-one and add-two and then calls each nested function in the body of the flet special form. For many years I have used nested defun special forms inside let expressions for defining local functions but I now try to avoid doing this. Functions defined inside defun special forms have global visibility so they are not hidden in the local context where they are defined. The example of a nested defun in lines 7-12 shows that the function test2 has global visibility inside the current package.\n\nFunctions defined inside of a flet special form have access to variables defined in the outer scope containing the flet (also applies to labels). We see this in lines 14-24 where the local variables x and y defined in the let expression are visible inside the function nested-function defined inside the flet.\n\nThe final example in lines 26-31 shows a recursive function defined inside a labels special form.\n\nAssuming that we started SBCL in the src directory we can then use the Lisp load function to evaluate the contents of the file nested.lisp in the sub-directory code_snippets_for_book using the load function:\n\nThe function load returned a value of t (prints in upper case as T) after successfully loading the file.\n\nWe will use Common Lisp vectors and arrays frequently in later chapters, but will also briefly introduce them here. A singly dimensioned array is also called a vector. Although there are often more efficient functions for handling vectors, we will just look at generic functions that handle any type of array, including vectors. Common Lisp provides support for functions with the same name that take different argument types; we will discuss this in some detail when we cover this in the later chapter on CLOS. We will start by defining three vectors v1, v2, and v3:\n\nIn line 1, we are defining a one-dimensional array, or vector, with three elements. In line 3 we specify the default value assigned to each element of the array v2. In line 5 I use the form for specifying array literals using the special character #. The function aref can be used to access any element in an array:\n\nNotice how indexing of arrays is zero-based; that is, indices start at zero for the first element of a sequence. Also notice that array elements can be any Lisp data type. So far, we have used the special operator setq to set the value of a variable. Common Lisp has a generalized version of setq called setf that can set any value in a list, array, hash table, etc. You can use setf instead of setq in all cases, but not vice-versa. Here is a simple example:\n\nWhen writing new code or doing quick programming experiments, it is often easiest (i.e., quickest to program) to use lists to build interesting data structures. However, as programs mature, it is common to modify them to use more efficient (at runtime) data structures like arrays and hash tables.\n\nSymbols\n\nWe will discuss symbols in more detail the Chapter on Common Lisp Packages. For now, it is enough for you to understand that symbols can be names that refer to variables. For example:\n\nNote that the first defvar returns the defined symbol as its value. Symbols are almost always converted to upper case. An exception to this âupper case ruleâ is when we define symbols that may contain white space using vertical bar characters:\n\nOperations on Lists\n\nLists are a fundamental data structure of Common Lisp. In this section, we will look at some of the more commonly used functions that operate on lists. All of the functions described in this section have something in common: they do not modify their arguments.\n\nIn Lisp, a cons cell is a data structure containing two pointers. Usually, the first pointer in a cons cell will point to the first element in a list and the second pointer will point to another cons representing the start of the rest of the original list.\n\nThe function cons takes two arguments that it stores in the two pointers of a new cons data structure. For example:\n\nThe first form evaluates to a cons data structure while the second evaluates to a cons data structure that is also a proper list. The difference is that in the second case the second pointer of the freshly created cons data structure points to another cons cell.\n\nFirst, we will declare two global variables l1 and l2 that we will use in our examples. The list l1 contains five elements and the list l2 contains four elements:\n\nYou can also use the function list to create a new list; the arguments passed to function list are the elements of the created list:\n\nThe function car returns the first element of a list and the function cdr returns a list with its first element removed (but does not modify its argument):\n\nUsing combinations of car and cdr calls can be used to extract any element of a list:\n\nNotice that we can combine calls to car and cdr into a single function call, in this case the function cadr. Common Lisp defines all functions of the form cXXr, cXXXr, and cXXXXr where X can be either a or d.\n\nSuppose that we want to extract the value 5 from the nested list l1. Some experimentation with using combinations of car and cdr gets the job done:\n\nThe function last returns the last cdr of a list (i.e., the last element, in a list):\n\nCommon list supplies alternative functions to car and cdr that you might find more readable: first, second, third, fourth, and rest. Here are some examples:\n\nThe function nth takes two arguments: an index of a top-level list element and a list. The first index argument is zero based:\n\nThe function cons adds an element to the beginning of a list and returns as its value a new list (it does not modify its arguments). An element added to the beginning of a list can be any Lisp data type, including another list:\n\nThe function append takes two lists as arguments and returns as its value the two lists appended together:\n\nA frequent error that beginning Lisp programmers make is not understanding shared structures in lists. Consider the following example where we generate a list y by reusing three copies of the list x:\n\nWhen we change the shared structure referenced by the variable x that change is reflected three times in the list y. When we create the list stored in the variable z we are not using a shared structure.\n\nUsing Arrays and Vectors\n\nUsing lists is easy but the time spent accessing a list element is proportional to the length of the list. Arrays and vectors are more efficient at runtime than long lists because list elements are kept on a linked-list that must be searched. Accessing any element of a short list is fast, but for sequences with thousands of elements, it is faster to use vectors and arrays.\n\nBy default, elements of arrays and vectors can be any Lisp data type. There are options when creating arrays to tell the Common Lisp compiler that a given array or vector will only contain a single data type (e.g., floating point numbers) but we will not use these options in this book.\n\nVectors are a specialization of arrays; vectors are arrays that only have one dimension. For efficiency, there are functions that only operate on vectors, but since array functions also work on vectors, we will concentrate on arrays. In the next section, we will look at character strings that are a specialization of vectors.\n\nWe could use the generalized make-sequence function to make a singularly dimensioned array (i.e., a vector). Restart sbcl and try:\n\nIn this example, notice the print format for vectors that looks like a list with a proceeding # character. As seen in the last section, we use the function make-array to create arrays:\n\nNotice the print format of an array: it looks like a list proceeded by a # character and the integer number of dimensions.\n\nInstead of using make-sequence to create vectors, we can pass an integer as the first argument of make-array instead of a list of dimension values. We can also create a vector by using the function vector and providing the vector contents as arguments:\n\nThe function aref is used to access sequence elements. The first argument is an array and the remaining argument(s) are array indices. For example:\n\nUsing Strings\n\nIt is likely that even your first Lisp programs will involve the use of character strings. In this section, we will cover the basics: creating strings, concatenating strings to create new strings, for substrings in a string, and extracting substrings from longer strings. The string functions that we will look at here do not modify their arguments; rather, they return new strings as values. For efficiency, Common Lisp does include destructive string functions that do modify their arguments but we will not discuss these destructive functions here.\n\nWe saw earlier that a string is a type of vector, which in turn is a type of array (which in turn is a type of sequence). A full coverage of the Common Lisp type system is outside the scope of this tutorial introduction to Common Lisp; a very good treatment of Common Lisp types is in Guy Steeleâs âCommon Lisp, The Languageâ which is available both in print and for free on the web. Many of the built in functions for handling strings are actually more general because they are defined for the type sequence. The Common Lisp Hyperspec is another great free resource that you can find on the web. I suggest that you download an HTML version of Guy Steeleâs excellent reference book and the Common Lisp Hyperspec and keep both on your computer. If you continue using Common Lisp, eventually you will want to read all of Steeleâs book and use the Hyperspec for reference.\n\nThe following text was captured from input and output from a Common Lisp repl. First, we will declare two global variables s1 and space that contain string values:\n\nOne of the most common operations on strings is to concatenate two or more strings into a new string:\n\nNotice that the first argument of the function concatenate is the type of the sequence that the function should return; in this case, we want a string. Another common string operation is search for a substring:\n\nIf the search string (first argument to function search) is not found, function search returns nil, otherwise search returns an index into the second argument string. Function search takes several optional keyword arguments (see the next chapter for a discussion of keyword arguments):\n\nFor our discussion, we will just use the keyword argument :start2 for specifying the starting search index in the second argument string and the :from-end flag to specify that search should start at the end of the second argument string and proceed backwards to the beginning of the string:\n\nThe sequence function subseq can be used for strings to extract a substring from a longer string:\n\nHere, the second argument specifies the starting index; the substring from the starting index to the end of the string is returned. An optional third index argument specifies one greater than the last character index that you want to extract:\n\nIt is frequently useful to remove white space (or other) characters from the beginning or end of a string:\n\nThe character #\\space is the space character. Other common characters that are trimmed are #\\tab and #\\newline. There are also utility functions for making strings upper or lower case:\n\nWe have not yet discussed equality of variables. The function eq returns true if two variables refer to the same data in memory. The function eql returns true if the arguments refer to the same data in memory or if they are equal numbers or characters. The function equal is more lenient: it returns true if two variables print the same when evaluated. More formally, function equal returns true if the car and cdr recursively equal to each other. An example will make this clearer:\n\nFor strings, the function string= is slightly more efficient than using the function equal:\n\nCommon Lisp strings are sequences of characters. The function char is used to extract individual characters from a string:\n\nUsing Hash Tables\n\nHash tables are an extremely useful data type. While it is true that you can get the same effect by using lists and the assoc function, hash tables are much more efficient than lists if the lists contain many elements. For example:\n\nThe second argument to function assoc is a list of cons cells. Function assoc searches for a sub-list (in the second argument) that has its car (i.e., first element) equal to the first argument to function assoc. The perhaps surprising thing about this example is that assoc seems to work with an integer as the first argument but not with a string. The reason for this is that by default the test for equality is done with eql that tests two variables to see if they refer to the same memory location or if they are identical if they are numbers. In the last call to assoc we used â:test #âequalâ to make assoc use the function equal to test for equality.\n\nThe problem with using lists and assoc is that they are very inefficient for large lists. We will see that it is no more difficult to code with hash tables.\n\nA hash table stores associations between key and value pairs, much like our last example using the assoc function. By default, hash tables use eql to test for equality when looking for a key match. We will duplicate the previous example using hash tables:\n\nNotice that gethash returns multiple values: the first value is the value matching the key passed as the first argument to function gethash and the second returned value is true if the key was found and nil otherwise. The second returned value could be useful if hash values are nil.\n\nSince we have not yet seen how to handle multiple returned values from a function, we will digress and do so here (there are many ways to handle multiple return values and we are just covering one of them):\n\nAssuming that variables a and b are already declared, the variable a will be set to the first returned value from gethash and the variable b will be set to the second returned value.\n\nIf we use symbols as hash table keys, then using eql for testing for equality with hash table keys is fine:\n\nHowever, we saw that eql will not match keys with character string values. The function make-hash-table has optional key arguments and one of them will allow us to use strings as hash key values:\n\nHere, we are only interested in the first optional key argument :test that allows us to use the function equal to test for equality when matching hash table keys. For example:\n\nIt is often useful to be able to enumerate all the key and value pairs in a hash table. Here is a simple example of doing this by first defining a function my-print that takes two arguments, a key and a value. We can then use the maphash function to call our new function my-print with every key and value pair in a hash table:\n\nThe function my-print is applied to each key/value pair in the hash table. There are a few other useful hash table functions that we demonstrate here:\n\nThe function hash-table-count returns the number of key and value pairs in a hash table. The function remhash can be used to remove a single key and value pair from a hash table. The function clrhash clears out a hash table by removing all key and value pairs in a hash table.\n\nIt is interesting to note that clrhash and remhash are the first Common Lisp functions that we have seen so far that modify any of its arguments, except for setq and setf that are macros and not functions.\n\nUsing Eval to Evaluate Lisp Forms\n\nWe have seen how we can type arbitrary Lisp expressions in the Lisp repl listener and then they are evaluated. We will see in the Chapter on Input and Output that the Lisp function read evaluates lists (or forms) and indeed the Lisp repl uses function read.\n\nIn this section, we will use the function eval to evaluate arbitrary Lisp expressions inside a program. As a simple example:\n\nUsing the function eval, we can build lists containing Lisp code and evaluate generated code inside our own programs. We get the effect of âdata is codeâ. A classic Lisp program, the OPS5 expert system tool, stored snippets of Lisp code in a network data structure and used the function eval to execute Lisp code stored in the network. A warning: the use of eval is likely to be inefficient in non-compiled code. For efficiency, the OPS5 program contained its own version of eval that only interpreted a subset of Lisp used in the network.\n\nUsing a Text Editor to Edit Lisp Source Files\n\nI usually use Emacs, but we will briefly discuss the editor vi also. If you use vi (e.g., enter âvi nested.lispâ) the first thing that you should do is to configure vi to indicate matching opening parentheses whenever a closing parentheses is typed; you do this by typing â:set smâ after vi is running.\n\nIf you choose to learn Emacs, enter the following in your .emacs file (or your _emacs file in your home directory if you are running Windows):\n\nNow, whenever you open a file with the extension of âlispâ, âlspâ, or âclâ (for âCommon Lispâ) then Emacs will automatically use a Lisp editing mode. I recommend searching the web using keywords âEmacs tutorialâ to learn how to use the basic Emacs editing commands - we will not repeat this information here.\n\nI do my professional Lisp programming using free software tools: Emacs, SBCL, Clozure Common Lisp, and Clojure. I will show you how to configure Emacs and Slime in the last section of the Chapter on Quicklisp.\n\nRecovering from Errors\n\nWhen you enter forms (or expressions) in a Lisp repl listener, you will occasionally make a mistake and an error will be thrown. Here is an example where I am not showing all of the output when entering help when an error is thrown:\n\nHere, I first used the backtrace command :bt to print the sequence of function calls that caused the error. If it is obvious where the error is in the code that I am working on then I do not bother using the backtrace command. I then used the abort command :a to recover back to the top level Lisp listener (i.e., back to the greater than prompt). Sometimes, you must type :a more than once to fully recover to the top level greater than prompt.\n\nGarbage Collection\n\nLike other languages like Java and Python, Common Lisp provides garbage collection (GC) or automatic memory management.\n\nIn simple terms, GC occurs to free memory in a Lisp environment that is no longer accessible by any global variable (or function closure, which we will cover in the next chapter). If a global variable *variable-1* is first set to a list and then if we later then set *variable-1* to, for example nil, and if the data referenced in the original list is not referenced by any other accessible data, then this now unused data is subject to GC.\n\nIn practice, memory for Lisp data is allocated in time ordered batches and ephemeral or generational garbage collectors garbage collect recent memory allocations far more often than memory that has been allocated for a longer period of time.\n\nLoading your Working Environment Quickly\n\nWhen you start using Common Lisp for large projects, you will likely have many files to load into your Lisp environment when you start working. Most Common Lisp implementations have a function called defsystem that works somewhat like the Unix make utility. While I strongly recommend defsystem for large multi-person projects, I usually use a simpler scheme when working on my own: I place a file loadit.lisp in the top directory of each project that I work on. For any project, its loadit.lisp file loads all source files and initializes any global data for the project.\n\nThe last two chapters of this book provide example applications that are configured to work with Quicklisp, which we will study in the next chapter.\n\nAnother good technique is to create a Lisp image containing all the code and data for all your projects. There is an example of this in the first section of the Chapter on NLP. In this example, it takes a few minutes to load the code and data for my NLP (natural language processing) library so when I am working with it I like to be able to quickly load a SBCL Lisp image.\n\nAll Common Lisp implementations have a mechanism for dumping a working image containing code and data.\n\nFunctional Programming Concepts\n\nThere are two main styles for doing Common Lisp development. Object oriented programming is well supported (see the Chapter on CLOS) as is functional programming. In a nut shell, functional programming means that we should write functions with no side effects. First let me give you a non-functional example with side effects:\n\nThis example using CLOS is non-functional because we modify the value of an argument to the function. Some functional languages like the Lisp Clojure language and the Haskell language dissuade you from modifying arguments to functions. With Common Lisp you should make a decision on which approach you like to use.\n\nFunctional programming means that we avoid maintaining state inside of functions and treat data as immutable (i.e., once an object is created, it is never modified). We could modify the last example to be function by creating a new car object inside the function, copy the attributes of the car passed as an object, change the color to âredâ of the new car object, and return the new car instance as the value of the function.\n\nFunctional programming prevents many types of programming errors, makes unit testing simpler, and makes programming for modern multi-core CPUs easier because read-only objects are inherently thread safe. Modern best practices for the Java language also prefer immutable data objects and a functional approach.\n\nQuicklisp\n\nFor several decades managing packages and libraries was a manual process when developing Lisp systems. I used to package the source code for specific versions of libraries as part of my Common Lisp projects. Early package management systems mk-defsystem and ASDF were very useful, but I did not totally give up my practice keeping third party library source code with my projects until Zach Beane created the Quicklisp package system. You will need to have Quicklisp installed for many of the examples later in this book so please take the time to install it now as per the instructions on the Quicklisp web site.\n\nUsing Quicklisp to Find Packages\n\nWe will need the Common Lisp Hunchentoot library later in the Chapter on Network Programming so we will install it now using Quicklisp as an example for getting started with Quicklisp.\n\nWe already know the package name we want, but as an example of discovering packages letâs start by using Quicklisp to search for all packages with âhunchentootâ in the package name:\n\nWe want the base package seen in line 3 and we can install the base package as seen in the following example:\n\nIn line 1, I refer to the package name using a symbol :hunchentoot but using the string âhunchentootâ would have worked the same. The first time you ql:quickload a library you may see additional printout and it takes longer to load because the source code is downloaded from the web and cached locally in the directory ~/quicklisp/local-projects. In most of the rest of this book, when I install or use a package by calling the ql:quickload function I do not show the output from this function in the repl listings.\n\nNow, we can use the fantastically useful Common Lisp function apropos to see what was just installed:\n\nAs long as you are thinking about the new tool Quicklisp that is now in your tool chest, you should install most of the packages and libraries that you will need for working through the rest of this book. I will show the statements needed to load more libraries without showing the output printed in the repl as each package is loaded:\n\nYou need to have the Postgres and MySQL client developer libraries installed on your system for the clsql-postgresql and clsql-mysql installations to work. If you are unlikely to use relational databases with Common Lisp then you might skip the effort of installing Postgres and MySQL. The example in the Chapter on the Knowledge Graph Navigator uses the SQLite database for caching. You donât need any extra dependencies for the sqlite package.\n\nUsing Quicklisp to Configure Emacs and Slime\n\nI assume that you have Emacs installed on your system. In a repl you can setup the Slime package that allows Emacs to connect to a running Lisp environment:\n\nPay attention to the output in the repl. On my system the output contained the following:\n\nIf you installed rlwrap and defined an alias for running SBCL, make sure you set the inferior lisp program to the absolute path of the SBCL executable; on my system I set the following in my .emacs file:\n\nI am not going to cover using Emacs and Slime, there are many good tutorials on the web you can read.\n\nIn later chapters we will write libraries and applications as Quicklisp projects so that you will be able to load your own libraries, making it easier to write small libraries that you can compose into larger applications.\n\nDefining Lisp Functions\n\nIn the previous chapter, we defined a few simple functions. In this chapter, we will discuss how to write functions that take a variable number of arguments, optional arguments, and keyword arguments.\n\nThe special form defun is used to define new functions either in Lisp source files or at the top level Lisp listener prompt. Usually, it is most convenient to place function definitions in a source file and use the function load to load them into our Lisp working environment.\n\nIn general, it is bad form to use global variables inside Lisp functions. Rather, we prefer to pass all required data into a function via its argument list and to get the results of the function as the value (or values) returned from a function. Note that if we do require global variables, it is customary to name them with beginning and ending * characters; for example:\n\nThen in this example, if you see the variable *lexical-hash-table* inside a function definition, you will know that at least by naming convention, that this is a global variable.\n\nIn Chapter 1, we saw an example of using lexically scoped local variables inside a function definition (in the example file nested.lisp).\n\nThere are several options for defining the arguments that a function can take. The fastest way to introduce the various options is with a few examples.\n\nFirst, we can use the &aux keyword to declare local variables for use in a function definition:\n\nIt is considered better coding style to use the let special operator for defining auxiliary local variables; for example:\n\nYou will probably not use &aux very often, but there are two other options for specifying function arguments: &optional and &key.\n\nThe following code example shows how to use optional function arguments. Note that optional arguments must occur after required arguments.\n\nIn this example, the optional argument b was not given a default value so if unspecified it will default to nil. The optional argument c is given a default value of 123.\n\nWe have already seen the use of keyword arguments in built-in Lisp functions. Here is an example of how to specify key word arguments in your functions:\n\nUsing Lambda Forms\n\nIt is often useful to define unnamed functions. We can define an unnamed function using lambda; for example, letâs look at the example file src/lambda1.lisp. But first, we will introduce the Common Lisp function funcall that takes one or more arguments; the first argument is a function and any remaining arguments are passed to the function bound to the first argument. For example:\n\nIn the first two calls to funcall here, we simply quote the function name that we want to call. In the third example, we use a better notation by quoting with #â. We use the #â characters to quote a function name.\n\nConsider the following repl listing where we will look at a primary difference between quoting a symbol using â and with #â:\n\nOn line three we create a new symbol BARFOO531 that is interned as you can see from looking at all interned symbols containing the string âbarfooâ. Line 7 throws an error because #â does not intern a new symbol.\n\nHere is the example file src/lambda1.lisp:\n\nHere, we define a function using lambda and set the value of the local variable my-func to the unnamed functionâs value. Here is output from the function test:\n\nThe ability to use functions as data is surprisingly useful. For now, we will look at a simple example:\n\nNotice that the second call to function testfn prints â100â twice: the first time as a side effect of calling the function print and the second time as the returned value of testfn (the function print returns what it is printing as its value).\n\nUsing Recursion\n\nLater, we will see how to use special Common Lisp macros for programming repetitive loops. In this section, we will use recursion for both coding simple loops and as an effective way to solve a variety of problems that can be expressed naturally using recursion.\n\nAs usual, the example programs for this section are found in the src directory. In the file src/recursion1.lisp, we see our first example of recursion:\n\nThis example is simple, but it is useful for discussing a few points. First, notice how the function recursion1 calls itself with an argument value of one greater than its own input argument only if the input argument âvalueâ is less than 5. This test keeps the function from getting in an infinite loop. Here is some sample output:\n\nWhy did the call on line 24 not loop via recursion? Because the input argument is not less than 5, no recursion occurs.\n\nClosures\n\nWe have seen that functions can take other functions as arguments and return new functions as values. A function that references an outer lexically scoped variable is called a closure. The example file src/closure1.lisp contains a simple example:\n\nHere the function fortune is defined inside a let form. Because the local variable fortunes is referenced inside the function fortune, the variable fortunes exists after the let form is evaluated. It is important to understand that usually a local variable defined inside a let form âgoes out of scopeâ and can no longer be referenced after the let form is evaluated.\n\nHowever, in this example, there is no way to access the contents of the variable fortunes except by calling the function fortune. At a minimum, closures are a great way to hide variables. Here is some output from loading the src/closure1.lisp file and calling the function fortune several times:\n\nUsing the Function eval\n\nIn Lisp languages we often say that code is data. The function eval can be used to execute code that is stored as Lisp data. Letâs look at an example:\n\nI leave it up to you, dear reader, how often you are motivated to use eval. In forty years of using Lisp languages my principle use of eval has been in modifying the standard version of the Ops5 programming language for production systems to support things like multiple data worlds and new actions to spawn off new data worlds and to remove them. Ops5 works by finding common expressions in a set of production rules (also referred to as âexpert systemsâ) and factoring them into a network (a Rete network if you want to look it up) with common expressions in rules stored in just a single place. eval is used a lot in Ops5 and I used it for my extensions to Ops5.\n\nDefining Common Lisp Macros\n\nWe saw in the last chapter how the Lisp function eval could be used to evaluate arbitrary Lisp code stored in lists. Because eval is inefficient, a better way to generate Lisp code automatically is to define macro expressions that are expanded inline when they are used. In most Common Lisp systems, using eval requires the Lisp compiler to compile a form on-the-fly which is not very efficient. Some Lisp implementations use an interpreter for eval which is likely to be faster but might lead to obscure bugs if the interpreter and compiled code do not function identically.\n\nThe ability to add functionality and syntax to the Common Lisp language, to in effect extend the language as needed, is truly a super power of languages like Common Lisp and Scheme.\n\nExample Macro\n\nThe file src/macro1.lisp contains both a simple macro and a function that uses the macro. This macro example is a bit contrived since it could be just a function definition, but it does show the process of creating and using a macro. We are using the gensym function to define a new unique symbol to reference a temporary variable:\n\nThe backquote character seen at the beginning of line 5 is used to quote a list in a special way: nothing in the list is evaluated during macro expansion unless it is immediately preceded by a comma character. In this case, we specify ,a-list because we want the value of the macroâs argument a-list to be substituted into the specially quoted list. We will look at dolist in some detail in the next chapter but for now it is sufficient to understand that dolist is used to iterate through the top-level elements of a list, for example:\n\nNotice that the example macro double-list itself uses the macro dolist. It is common to nest macros in the same way functions can be nested.\n\nReturning to our macro example in the file src/macro1.lisp, we will try the function test that uses the macro double-list:\n\nUsing the Splicing Operator\n\nAnother similar example is in the file src/macro2.lisp:\n\nHere, the splicing operator ,@ is used to substitute in the list args in the macro double-args.\n\nUsing macroexpand-1\n\nThe function macroexpand-1 is used to transform macros with arguments into new Lisp expressions. For example:\n\nWriting macros is an effective way to extend the Lisp language because you can control the code passed to the Common Lisp compiler. In both macro example files, when the function test was defined, the macro expansion is done before the compiler processes the code. We will see in the next chapter several useful macros included in Common Lisp.\n\nWe have only âscratched the surfaceâ looking at macros; the interested reader is encouraged to search the web using, for example, âCommon Lisp macros.â There are two books in particular that I recommend that take a deep dive into Common Lisp macros: Paul Grahamâs âOn Lispâ and Doug Hoyteâs âLet Over Lambda.â Both are deep books and will change the way you experience software development. A good plan of study is spending a year absorbing âOn Lispâ before tackling âLet Over Lambda.â\n\nUsing Common Lisp Loop Macros\n\nIn this chapter, we will discuss several useful macros for performing iteration (we saw how to use recursion for iteration in Chapter 2):\n\ndolist â a simple way to process the elements of a list\n\ndotimes â a simple way to iterate with an integer valued loop variable\n\ndo â the most general looping macro\n\nloop â a complex looping macro that I almost never use in my own code because it does not look âLisp like.â I donât use the loop macro in this book. Many programmers do like the loop macro so you are likely to see it when reading other peopleâs code.\n\ndolist\n\nWe saw a quick example of dolist in the last chapter. The arguments of the dolist macro are:\n\nUsually, the dolist macro returns nil as its value, but we can add a third optional argument which will be returned as the generated expressionâs value; for example:\n\nThe first argument to the dolist macro is a local lexically scoped variable. Once the code generated by the dolist macro finishes executing, this variable is undefined.\n\ndotimes\n\nThe dotimes macro is used when you need a loop with an integer loop index. The arguments of the dotimes macro are:\n\nUsually, the dotimes macro returns nil as its value, but we can add a third optional argument that will be returned as the generated expressionâs value; for example:\n\nAs with the dolist macro, you will often use a let form inside a dotimes macro to declare additional temporary (lexical) variables.\n\ndo\n\nThe do macro is more general purpose than either dotimes or dolist but it is more complicated to use. Here is the general form for using the do looping macro:\n\nThere is a similar macro do* that is analogous to let* in that loop variable values can depend on the values or previously declared loop variable values.\n\nAs a simple example, here is a loop to print out the integers from 0 to 3. This example is in the file src/do1.lisp:\n\n;; example do macro use\n\nIn this example, we only declare one loop variable so we might as well as used the simpler dotimes macro.\n\nHere we load the file src/do1.lisp:\n\nYou will notice that we do not see the return value of the do loop (i.e., the string âvalue-of-do-loopâ) because the top-level form that we are evaluating is a call to the function load; we do see the return value of load printed. If we had manually typed this example loop in the Lisp listener, then you would see the final value value-of-do-loop printed.\n\nUsing the loop Special Form to Iterate Over Vectors or Arrays\n\nWe previousely used dolist to iterate over elements in lists. For efficiency we will often use vectors (one dimensional arrays) and we can use loop to similarly handle vectors:\n\nwhere testdata is a one dimensional array (a vector) and inside the do block the local variable td is assigned to each element in the vector.\n\nCommon Lisp Package System\n\nIn later chapters we will see two complete applications that are defined as Quicklisp projects: the chapter on the Knowledge Graph Creator and the chapter on the Knowledge Graph Navigator. Another example for setting up a Quicklib project can be seen in the chapter Plotting Data.\n\nWhile these later chapters provide practical examples for bundling up your own projects in packages, the material here will give you general background information that you should know.\n\nIn the simple examples that we have seen so far, all newly created Lisp symbols have been placed in the default package. You can always check the current package by evaluating the expression package:\n\nAs we will use in the following example, the package :cl is an alias for :common-lisp-user.\n\nWe will define a new package :my-new-package and two functions foo1 and foo2 inside the package. Externally to this package, assuming that it is loaded, we can access foo2 using my-new-package:foo2. foo1 is not exported so it cannot be accessed this way. However, we can always start a symbol name with a package name and two colon characters if we want to use a symbol defined in another package so we can use my-new-package::foo1. Using :: allows us access to symbols not explicitly exported.\n\nWhen I leave package :my-new-package in line 22 and return to package :cl, and try to access my-new-package:foo1 notice that an error is thrown.\n\nOn line 3 we define the alias :p1 for the package :my-new-package and we use this alias in line 44. The main point of the following example is that we define two functions in a package but only export one of these functions. By default the other function is not visible outside of the new package.\n\nSince we specified a nickname in the defpackage expression, Common Lisp allows the use of the nickname (in this case P1) in calling function foo2 that is exported from package :my-new-package.\n\nNear the end of the last example, we switched back to the default package COMMON-LISP-USER so we had to specify the package name for the function foo2 on line 42.\n\nWhat about the error on line 28 where my-new-package:foo1 is undefined because the function foo1 is not exported (see line 4)? It turns out that you can easily use symbols not exported from a package by using :: instead of a single :. Here, this would be defined: (my-new-package::foo1).\n\nWhen you are writing very large Common Lisp programs, it is useful to be able to break up the program into different modules and place each module and all its required data in different name spaces by creating new packages. Remember that all symbols, including variables, generated symbols, CLOS methods, functions, and macros are in some package.\n\nFor small packages I sometimes put a defpackage expression at the top of the file immediately followed by an in-package expression to switch to the new package. In the general case, please properly use separate project and asdf files as I do in the later chapters Knowledge Graph Creator and Knowledge Graph Navigator.\n\nInput and Output\n\nWe will see that the input and output of Lisp data is handled using streams. Streams are powerful abstractions that support common libraries of functions for writing to the terminal, files, sockets, and to strings.\n\nIn all cases, if an input or output function is called without specifying a stream, the default for input stream is *standard-input* and the default for output stream is *standard-output*. These default streams are connected to the Lisp listener that we discussed in Chapter 2. In the later chapter Knowledge Graph Navigator that supports a user interface, we will again use output streams bound to different scrolling output areas of the application window to write color-hilighted text. The stream formalism is general purpose, covering many common I/O use cases.\n\nThe Lisp read and read-line Functions\n\nThe function read is used to read one Lisp expression. Function read stops reading after reading one expression and ignores new line characters. We will look at a simple example of reading a file test.dat using the example Lisp program in the file read-test-1.lisp. Both of these files can be found in the directory src/code_snippets_for_book that came bundled with this web book. Start your Lisp program in the src directory. The contents of the file test.dat is:\n\nIn the function read-test-1, we use the macro with-open-file to read from a file. To write to a file (which we will do later), we can use the keyword arguments :direction :output. The first argument to the macro with-open-file is a symbol that is bound to a newly created input stream (or an output stream if we are writing a file); this symbol can then be used in calling any function that expects a stream argument.\n\nNotice that we call the function read with three arguments: an input stream, a flag to indicate if an error should be thrown if there is an I/O error (e.g., reaching the end of a file), and the third argument is the value that function read should return if the end of the file (or stream) is reached. When calling read with these three arguments, either the next expression from the file test.dat will be returned, or the value nil will be returned when the end of the file is reached. If we do reach the end of the file, the local variable x will be assigned the value nil and the function return will break out of the dotimes loop. One big advantage of using the macro with-open-file over using the open function (which we will not cover) is that the file stream is automatically closed when leaving the code generated by the with-open-file macro. The contents of file read-test-1.lisp is:\n\nHere is the output that you will see if you load the file read-test-1.lisp and execute the expression (read-test-1):\n\nNote: the string âthe cat bit the ratâ prints as a string (with quotes) because we used a ~S instead of a ~A in the format string in the call to function format.\n\nIn this last example, we passed the file name as a string to the macro with-open-file. This is not generally portable across all operating systems. Instead, we could have created a pathname object and passed that instead. The pathname function can take eight different keyword arguments, but we will use only the two most common in the example in the file read-test-2.lisp in the src directory. The following listing shows just the differences between this example and the last:\n\nHere, we are specifying that we want to use the file test.dat in the subdirectory testdata. Note: I almost never use pathnames. Instead, I specify files using a string and the character / as a directory delimiter. I find this to be portable for the Macintosh, Windows, and Linux operating systems using all Common Lisp implementations.\n\nThe file readline-test.lisp is identical to the file read-test-1.lisp except that we call function readline instead of the function read and we change the output format message to indicate that an entire line of text has been read\n\nWhen we execute the expression (readline-test), notice that the string contained in the second line of the input file has the quote characters escaped:\n\nWe can also create an input stream from the contents of a string. The file read-from-string-test.lisp is very similar to the example file read-test-1.lisp except that we use the macro with-input-from-string (notice how I escaped the quote characters used inside the test string):\n\nWe see the following output when we load the file read-from-string-test.lisp:\n\nWe have seen how the stream abstraction is useful for allowing the same operations on a variety of stream data. In the next section, we will see that this generality also applies to the Lisp printing functions.\n\nLisp Printing Functions\n\nAll of the printing functions that we will look at in this section take an optional last argument that is an output stream. The exception is the format function that can take a stream value as its first argument (or t to indicate *standard-output*, or a nil value to indicate that format should return a string value).\n\nHere is an example of specifying the optional stream argument:\n\nThe function print prints Lisp objects so that they can be read back using function read. The corresponding function princ is used to print for âhuman consumptionâ. For example:\n\nBoth print and princ return their first argument as their return value, which you see in the previous output. Notice that princ also does not print a new line character, so princ is often used with terpri (which also takes an optional stream argument).\n\nWe have also seen many examples in this book of using the format function. Here is a different use of format, building a string by specifying the value nil for the first argument:\n\nWe have not yet seen an example of writing to a file. Here, we will use the with-open-file macro with options to write a file and to delete any existing file with the same name:\n\nHere is the result of evaluating this expression (i.e., the contents of the newly created file test1.dat in the src directory):\n\nNotice that print generates a new line character before printing its argument.\n\nPlotting Data\n\nWe will use Zach Beaneâs vecto library for plotting data with the results written to files. Ideally we would like to have interactive plotting capability but for the purposes of this book I need to support the combinations of all Common Lisp implementations on multiple operating systems. Interactive plotting libraries are usually implementation and OS dependent. We will use the plotlib example we develop in the later chapter Backpropagation Neural Networks.\n\nImplementing the Library\n\nThe examples here are all contained in the directory src/plotlib and is packaged as a Quicklisp loadable library. This library will be used in later chapters.\n\nWhen I work on my macOS laptop, I leave the output graphics file open in the Preview App and whenever I rerun a program producing graphics in the REPL, making the preview App window active refreshes the graphics display.\n\nThe following listing shows the file plotlib.lisp that is a simple wrapper for the vecto Common Lisp plotting library. Please note that I only implemented wrappers for vecto functionality that I need for later examples in this book, so the following code is not particularly general but should be easy enough for you to extend for the specific needs of your projects.\n\nThis plot library is used in later examples in the chapters on search, backpropagation neural networks and Hopfield neural networks. I prefer using implementation and operating specific plotting libraires for generating interactive plots, but the advantage of writing plot data to a file using the vecto library is that the code is portable across operating systems and Common Lisp implementations.\n\nPackaging as a Quicklisp Project\n\nThe two files src/plotlib/plotlib.asd src/plotlib/package.lisp configure the library. The file package.lisp defines the required library vecto and lists the functions that are publicly exported from the library:\n\nTo run the test function provided with this library you load the library and preface exported function names with the package name plotlib: as in this example:\n\nIn addition to a package.lisp file we also use a file with the extension .asd\n\nIf you have specified a dependency that is not already downloaded to your computer, Quicklisp will install the dependency for you.\n\nCommon Lisp Object System - CLOS\n\nCLOS was the first ANSI standardized object oriented programming facility. While I do not use classes and objects as often in my Common Lisp programs as I do when using Java and Smalltalk, it is difficult to imagine a Common Lisp program of any size that did not define and use at least a few CLOS classes.\n\nThe example program for this chapter in the file src/loving_snippets/HTMLstream.lisp. I used this CLOS class about ten years ago in a demo for my commercial natural language processing product to automatically generate demo web pages.\n\nWe are going to start our discussion of CLOS somewhat backwards by first looking at a short test function that uses the HTMLstream class. Once we see how to use this example CLOS class, we will introduce a small subset of CLOS by discussing in some detail the implementation of the HTMLstream class and finally, at the end of the chapter, see a few more CLOS programming techniques. This book only provides a brief introduction to CLOS; the interested reader is encouraged to do a web search for âCLOS tutorialâ.\n\nThe macros and functions defined to implement CLOS are a standard part of Common Lisp. Common Lisp supports generic functions, that is, different functions with the same name that are distinguished by different argument types.\n\nExample of Using a CLOS Class\n\nThe file src/loving_snippets/HTMLstream.lisp contains a short test program at the end of the file:\n\nThe generic function make-instance takes the following arguments:\n\nThere are four generic functions used in the function test:\n\nset-header - required to initialize class and also defines the page title\n\nadd-element - used to insert a string that defines any type of HTML element\n\nadd-table - takes a list of lists and uses the list data to construct an HTML table\n\nget-html-string - closes the stream and returns all generated HTML data as a string\n\nThe first thing to notice in the function test is that the first argument for calling each of these generic functions is an instance of the class HTMLstream. You are free to also define a function, for example, add-element that does not take an instance of the class HTMLstream as the first function argument and calls to add-element will be routed correctly to the correct function definition.\n\nWe will see that the macro defmethod acts similarly to defun except that it also allows us to define many methods (i.e., functions for a class) with the same function name that are differentiated by different argument types and possibly different numbers of arguments.\n\nImplementation of the HTMLstream Class\n\nThe class HTMLstream is very simple and will serve as a reasonable introduction to CLOS programming. Later we will see more complicated class examples that use multiple inheritance. Still, this is a good example because the code is simple and the author uses this class frequently (some proof that it is useful!). The code fragments listed in this section are all contained in the file src/loving_snippets/HTMLstream.lisp. We start defining a new class using the macro defclass that takes the following arguments:\n\nThe class definition for HTMLstream is fairly simple:\n\nHere, the class name is HTMLstream, the list of super classes is an empty list (), the list of slot specifications contains only one slot specification for the slot named out and there is only one class specification: a documentation string. Slots are like instance variables in languages like Java and Smalltalk. Most CLOS classes inherit from at least one super class but we will wait until the next section to see examples of inheritance. There is only one slot (or instance variable) and we define an accessor variable with the same name as the slot name. This is a personal preference of mine to name read/write accessor variables with the same name as the slot.\n\nThe method set-header initializes the string output stream used internally by an instance of this class. This method uses convenience macro with-accessors that binds a local set of local variable to one or more class slot accessors. We will list the entire method then discuss it:\n\nThe first interesting thing to notice about the defmethod is the argument list: there are two arguments ho and title but we are constraining the argument ho to be either a member of the class HTMLstream or a subclass of HTMLstream. Now, it makes sense that since we are passing an instance of the class HTMLstream to this generic function (or method â I use the terms âgeneric functionâ and âmethodâ interchangeably) that we would want access to the slot defined for this class. The convenience macro with-accessors is exactly what we need to get read and write access to the slot inside a generic function (or method) for this class. In the term ((out out)), the first out is local variable bound to the value of the slot named out for this instance ho of class HTMLstream. Inside the with-accessors macro, we can now use setf to set the slot value to a new string output stream. Note: we have not covered the Common Lisp type string-output-stream yet in this book, but we will explain its use on the next page.\n\nBy the time a call to the method set-header (with arguments of an HTMLstream instance and a string title) finishes, the instance has its slot set to a new string-output-stream and HTML header information is written to the newly created string output stream. Note: this string output stream is now available for use by any class methods called after set-header.\n\nThere are several methods defined in the file src/loving_snippets/HTMLstream.lisp, but we will look at just four of them: add-H1, add-element, add-table, and get-html-string. The remaining methods are very similar to add-H1 and the reader can read the code in the source file.\n\nAs in the method set-header, the method add-H1 uses the macro with-accessors to access the stream output stream slot as a local variable out. In add-H1 we use the function princ that we discussed in Chapter on Input and Output to write HTML text to the string output stream:\n\nThe method add-element is very similar to add-H1 except the string passed as the second argument element is written directly to the stream output stream slot:\n\nThe method add-table converts a list of lists into an HTML table. The Common Lisp function princ-to-string is a useful utility function for writing the value of any variable to a string. The functions string-left-trim and string-right-trim are string utility functions that take two arguments: a list of characters and a string and respectively remove these characters from either the left or right side of a string. Note: another similar function that takes the same arguments is string-trim that removes characters from both the front (left) and end (right) of a string. All three of these functions do not modify the second string argument; they return a new string value. Here is the definition of the add-table method:\n\nThe method get-html-string gets the string stored in the string output stream slot by using the function get-output-stream-string:\n\nCLOS is a rich framework for object oriented programming, providing a superset of features found in languages like Java, Ruby, and Smalltalk. I have barely scratched the surface in this short CLOS example for generating HTML. Later in the book, whenever you see calls to make-instance, that lets you know we are using CLOS even if I donât specifically mention CLOS in the examples.\n\nUsing Defstruct or CLOS\n\nYou might notice from my own code that I use Common Lisp defstruct macros to define data structures more often than I use CLOS. The defclass macro used to create CLOS classes are much more flexible but for simple data structures I find that using defstruct is much more concise. In the simplest case, a defstruct can just be a name of the new type followed by slot names. For each slot like my-slot-1 accessor functions are generated automatically. Here is a simple example:\n\nWe defined a struct struct1 on line3 with two slots names s1 and s2, show the use of the automatically generated constructor make-struct1 on line 5, and one of the two automatically generated accessor functions struct1-s1 on line 7. The names of accessor functions are formed with the structure name and the slot name.\n\nNetwork Programming\n\nDistributed computing is pervasive: you need to look no further than the World Wide Web, Internet chat, etc. Of course, as a Lisp programmer, you will want to do at least some of your network programming in Lisp! The previous editions of this book provided low level socket network programming examples. I decided that for this new edition, I would remove those examples and instead encourage you to âmove further up the food chainâ and work at a higher level of abstraction that makes sense for the projects you will likely be developing. Starting in the 1980s, a lot of my work entailed low level socket programming for distributed networked applications. As I write this, it is 2013, and there are better ways to structure distributed applications.\n\nSpecifically, since many of the examples later in this book fetch information from the web and linked data sources, we will start be learning how to use Edi Weitzâs Drakma HTTP client library. In order to have a complete client server example we will also look briefly at Edi Weitzâs Hunchentoot web server that uses JSON as a data serialization format. I used to use XML for data serialization but JSON has many advantages: easier for a human to read and it plays nicely with Javascript code and some data stores like Postgres (new in versions 9.x), MongoDB, and CouchDB that support JSON as a native data format.\n\nThe code snippets in the first two sections of this chapter are derived from examples in the Drackma and Hunchentoot documentation.\n\nAn introduction to Drakma\n\nEdi Weitzâs Drakma library supports fetching data via HTTP requests. As you can see in the Drakma documentation, you can use this library for authenticated HTTP requests (i.e., allow you to access web sites that require a login), support HTTP GET and PUT operations, and deal with cookies. The top level API that we will use is drakma:http-request that returns multiple values. In the following example, I want only the first three values, and ignore the others like the original URI that was fetched and an IO stream object. We use the built-in Common Lisp macro multiple-value-setq:\n\nI manually formatted the last statement I entered in the last repl listing and I will continue to manually edit the repl listings in the rest of this book to make them more easily readable.\n\nThe following shows some of the data bound to the variables data, http-response-code, and headers:\n\nThe value of http-response-code is 200 which means that there were no errors:\n\nThe HTTP response headers will be useful in many applications; for fetching the home page of my web site the headers are:\n\nWe will use Drakma later in this book for several examples. In the next section we will write a web app using Hunchentoot and test it with a Drakma client.\n\nAn introduction to Hunchentoot\n\nEdi Weitzâs Hunchentoot project is a flexible library for writing web applications and web services. We will also use Ediâs CL-WHO library in this section for generating HTML from Lisp code. Hunchentoot will be installed the first time you quick load it in the example code for this section:\n\nI will use only easy handler framework in the Hunchentoot examples in this section. I leave it to you to read the documentation on using custom acceptors after you experiment with the examples in this section.\n\nThe following code will work for both multi-threading installations of SBCL and single thread installations (e.g., some default installations of SBCL on OS X):\n\nIn lines 5 through 9 we create an use a new package that includes support for generating HTML in Lisp code (CL-WHO) and the Hunchentoot library). On line 11 we create an instance of an easy acceptor on port 3000 that provides useful default behaviors for providing HTTP services.\n\nThe Hunchentoot macro define-easy-handler is used in lines 15 through 28 to define an HTTP request handler and add it to the easy acceptor instance. The first argument, my-greetings in this example, is an arbitrary name and the keyword :uri argument provides a URL pattern that the easy acceptor server object uses to route requests to this handler. For example, when you run this example on your computer, this URL routing pattern would handle requests like:\n\nIn lines 17 through 28 we are using the CL-WHO library to generate HTML for a web page. As you might guess, :html generates the outer <html></html> tags for a web page. Line 19 would generate HTML like:\n\nLines 22 through 27 generate an HTML input form and line 28 displays any value generated when the user entered text in the input filed and clicked the submit button. Notice the definition of the argument name in line 1 in the definition of the easy handler. If the argument name is not defined, the nil value will be displayed in line 28 as an empty string.\n\nYou should run this example and access the generated web page in a web browser, and enter text, submit, etc. You can also fetch the generated page HTML using the Drakma library that we saw in the last section. Here is a code snippet using the Drakma client library to access this last example:\n\nWe will use both Drackma and Hunchentoot in the next section.\n\nComplete REST Client Server Example Using JSON for Data Serialization\n\nA reasonable way to build modern distributed systems is to write REST web services that serve JSON data to client applications. These client applications might be rich web apps written in Javascript, other web services, and applications running on smartphones that fetch and save data to a remote web service.\n\nWe will use the cl-json Quicklisp package to encode Lisp data into a string representing JSON encoded data. Here is a quick example:\n\nThe following list shows the contents of the file src/web-hunchentoot-json.lisp:\n\nThis example is very similar to the web application example in the last section. The difference is that this application is not intended to be viewed on a web page because it returns JSON data as HTTP responses. The easy handler definition on line 8 specifies a handler argument name. In lines 12 and 19 we check to see if the value of the argument name is âcatâ or âdogâ and if it is, we return the appropriate JSON example data for those animals. If there is no match, the default cond clause starting on line 26 returns a warning string as a JSON encoded string.\n\nWhile running this test service, in one repl, you can ue the Drakma library in another repl to test it (not all output is shown in the next listing):\n\nYou can use the cl-json library to decode a string containing JSON data to Lisp data:\n\nFor most of my work, REST web services are âread-onlyâ in the sense that clients donât modify state on the server. However, there are use cases where a client application might want to; for example, letting clients add new animals to the last example.\n\nIn line 4 we are defining an additional easy handler with a handler argument json-data. This data is assumed to be a string encoding of JSON data which is decoded into Lisp data in lines 6 and 7. We save the data to the global variable animal-hash.\n\nIn this example, we are storing data sent from a client in an in-memory hash table. In a real application new data might be stored in a database.\n\nNetwork Programming Wrap Up\n\nYou have learned the basics for writing web services and writing clients to use web services. Later, we will use web services written in Python by writing Common Lisp clients: we will wrap retrained deep learning models and access them from Common Lisp.\n\nUsing the Brave Search APIs\n\nNote: I started using the Brave search APIs in June 2024 and replaced the Microsoft Bing search chapter in previous editions with the following material.\n\nYou will need to get a free API key at https://brave.com/search/api/ to use the following code examples. You can use the search API 2000 times a month for free or pay $5/month to get 20 million API calls a month.\n\nSetting an Environment Variable for the Access Key for Brave Search APIs\n\nOnce you get a key for https://brave.com/search/api/ set the following environment variable:\n\nThat is not my real subscription key!\n\nExample Search Script\n\nGet the code for this example using (change directory to your Quicklist local-projects directory):\n\nIt takes very little Common Lisp code to access the Brave search APIs. The function websearch makes a generic web search query. I will list the entire library with comments to follow:\n\nWe get the Brave access key and the search API endpoint in lines 8-9. Lines 10-16 create a complete call to the curl* command line utility. We spawn a process to run **curl and capture the string output in the variable response in lines 17-18. You might want to add a few print statements to see typical values for the variables command and response. The response data is JSON data encoded in a string, with straightforward code in lines 19-28 to parse out the values we want.\n\nThe following repl listing shows this library in use (most output not shown):\n\nAccessing Relational Databases\n\nThere are good options for accessing relational databases from Common Lisp. Personally I almost always use Postgres and in the past I used either native foreign client libraries or the socket interface to Postgres. Recently, I decided to switch to CLSQL which provides a common interface for accessing Postgres, MySQL, SQLite, and Oracle databases. There are also several recent forks of CLSQL on github. We will use CLSQL in examples in this book. Hopefully while reading the Chapter on Quicklisp you installed CLSQL and the back end for one or more databases that you use for your projects.\n\nFor some database applications when I know that I will always use the embedded SQLite database (i.e., that I will never want to switch to Postgres of another database) I will just use the sqlite library as I do in chapter Knowledge Graph Navigator.\n\nIf you have not installed CLSQL yet, then please install it now:\n\nYou also need to install one or more CLSQL backends, depending on which relational databases you use:\n\nThe directory src/clsql_examples contains the standalone example files for this chapter.\n\nWhile I often prefer hand crafting SQL queries, there seems to be a general movement in software development towards the data mapper or active record design patterns. CLSQL provides Object Relational Mapping (ORM) functionality to CLOS.\n\nYou will need to create a new database news in order to follow along with the examples in this chapter and later in this book. I will use Postgres for examples in this chapter and use the following to create a new database (my account is âmarkwâ and the following assumes that I have Postgres configured to not require a password for this account when accessing the database from âlocalhostâ):\n\nWe will use three example programs that you can find in the src/clsql_examples directory in the book repository on github:\n\nclsql_create_news_schema.lisp to create table âarticlesâ in database ânewsâ\n\nclsql_write_to_news.lisp to write test data to table âarticlesâ\n\nclsql_read_from_news.lisp to read from the table âarticlesâ\n\nThe following listing shows the file src/clsql_examples/clsql_create_news_schema.lisp:\n\nIn this repl lis"
    }
}