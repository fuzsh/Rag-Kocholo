{
    "id": "dbpedia_8581_1",
    "rank": 23,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/41883/why-are-most-browsers-developed-in-c",
        "read_more_link": "",
        "language": "en",
        "title": "Why are most browsers developed in C++",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://softwareengineering.stackexchange.com/posts/41883/ivc/3f38?prg=469b1860-81bc-4acb-bfff-a02378d03641"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2011-01-31T18:15:56",
        "summary": "",
        "meta_description": "It seems like most of common web browsers (Firefox, Chrome, Safari) are developed using C++. Whys is that so?",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/41883/why-are-most-browsers-developed-in-c",
        "text": "Another way to ask the question is what kind of support does a browser need? The short list is:\n\nSupport for parsing (needed to make sense of [X]HTML, CSS, and [ECMA/Java]Script)\n\nTree walking/interpreting features (part of parsing and building UI)\n\nSupport for accelerated graphics\n\nFast networking\n\nFor the more advanced browsers: control over processes and isolating memory between pages\n\nMust work on all supported platforms\n\nMost languages have some sort of parsing support. You have parser generators for C, C++, C#, Java, etc. However, C and C++ have quite a few years head start on the rest of the alternatives so the algorithms and implementations are more mature. Accessing accelerated graphics in Java is a no go, unless you have some native extensions to make it work. WPF on C# provides access to accelerated graphics, but it is too new to have a serious browser built with the technology.\n\nNetworking is actually the least of the reasons to choose C++ over Java or C#. The reason is that communication is many times slower than the rest of the processing that goes on to display the page. The raw speed of the wire is the limiting factor. Both Java and C# have non-blocking IO support, as does C++. So there really is no clear winner in this area.\n\nWhy not Java? Have you ever tried to build a UI with Java? It feels cumbersome and slow compared to anything else out there, because it is. No accelerated graphics is also a big negative here. Java's sandboxing is really good, and can help improve the security of a browser if it is used correctly, but it is a pain to configure and make work. Not to mention the graphics format support lags behind most modern browsers.\n\nWhy not C#? If your only target is Windows, C# might actually make a good representation. The problem comes when you want to support anything else. Mono hasn't caught up enough to be considered cross platform enough for this task--particularly with accelerated graphics support and WPF. Who knows how long that will take to change.\n\nWhy not C? There's a C compiler for just about every platform out there (including embedded devices). However, there's a lot that C does not do for you that you will have to be extra vigilant about. You have access to all the lowest levels of the APIs, but the majority of C developers don't do GUIs. Even the C GUI libraries are written in an object oriented manner. As soon as you start talking UI, an object oriented language starts making better sense.\n\nWhy not Objective C? If your only target is Apple, it makes a lot of sense. However, most developers don't know Objective-C, and the only reason to learn it is to work on NeXT or Apple boxes. Sure you can use any C library with Objective-C, and there are compilers for many platforms, but finding people to work on it will be a touch more difficult. Who knows? Maybe Apple can turn this perceived deficiency around.\n\nWhy C++? There's a C++ compiler for just about every platform out there. Almost every GUI library has a C++ interface, sometimes it's better and sometimes it's just different. For example, Microsoft's ATL is a lot better than win32 C function calls or even the MFC library. There's C++ wrappers for GTK on Unix, and I'd be surprised if someone didn't have a C++ wrapper around Apple's Objective-C GUI library. Process management is easier within C++ than Java or C# (those details are abstracted away for you). It's perceived speed comes more from hardware acceleration than it does raw performance. C++ does take care of more things for you than raw C (such as bounded strings), but still gives you freedom to tweak things. Not to mention a number of libraries needed to render web pages are also written in C or C++.\n\nFor the time being, C++ does edge out the alternatives.\n\nI've decided to write a novel about this in hopes that people will gloss over it and upvote me. No, no, just kidding! I suffered over every word. Every word, I tell you!\n\nAsk 'when' before 'why'\n\nAll major web browsers can trace their origins back to the 90s. Konqueror became Safari and Chrome; Netscape became Firefox; IE and Opera are still IE and Opera. These browsers all have a 15 year head start on incumbents.\n\nI suggest you even try to name an acceptable cross-platform (Windows/Mac/Unix and even worse) language that was available in around 1995 when modern browsers originated. To build the core in anything but C/C++, you'd probably have had to build or buy and modify a compiler and platform libraries.\n\nHow about today? What are the alternatives?\n\nJust for fun, let's think about the problem today. Yes, there are alternatives, but there are still major problems.\n\nLanguage choice presents at least these problems:\n\nKnowledge problems - Hiring/training developers or attracting contributors\n\nOrganizational/social problems - Language acceptance\n\nLanguage implementation: Speed, platform support, tooling\n\nLanguage power\n\n1: Knowledge problems\n\nWhere do you get people who know the language or can learn it? This is an obstacle for languages like OCaml, F#, Haskell, Common Lisp and D that are fast and high-level enough to write a browser in nicely, but have few followers (In the 10k-100k range, maybe) even if you liberally count all the hobbyists and academics.\n\n2: Social/Organizational problems\n\nCorollary to the cargo-cult answer above:\n\nAn open source browser not using C, C++, C# or Java will supposedly have difficulty with contributors.\n\nA proprietary browser not using C, C++, C# or Java will get project managers severely yelled at in most organizations.\n\n3. Technical problems\n\nEven in modern times, you need a fairly fast language for the computation intensive parts of rendering pages and running Javascript. You can choose to supplement that with a high-level language for building GUI elements, etc. (e.g. the Firefox approach of C++ and Javascript) but you have to have close integration between the languages; you can't just say \"Okay, C# and Lua.\" You'll probably have to build and debug that bridge yourself unless you choose C or C++ as the base language.\n\nCross-platform development is another bag of worms. You could use C# or F# and cross your fingers on GTK# and Mono being alive and well in the future. You could try Common Lisp, Haskell, OCaml... Good luck getting everything working on Windows and Mac and Linux.\n\n4. Language Power\n\nAfter all of that, you have to build an enormous amount of functionality, so if you choose a low-level language you need an even huger army of coders than before. Note that no one has really built a browser from scratch in about fifteen years. That's partly because (surprise!) it's hard.\n\nSpecifically, having a Javascript interpreter is problem 3 (acquire one) or problem 4 (build one).\n\nConclusion:\n\nIf you developed a three-platform (Windows/Mac/*nix) browser today (early 2011), what are some of the choices?\n\nC: See (2). Everyone's going to clamor for C++. Have fun selecting a cross-platform toolkit or building one (1, 2, 3 and 4). See also (4); have fun building a stable, secure browser in it.\n\nC++: Have fun selecting a cross-platform toolkit or building one (1, 2, 3 and 4). Have fun (4) building stable, secure browser in it.\n\nC or C++ and HLL: Your best bet. Pick your poison on the dynamic language; See (1) and (2). Too many good languages, too few followers of each. (1, 2, 3 and 4) on toolkit.\n\nJava: Second best bet, if you have to please middle management. See (4); building huge things in Java takes a lot more code than in anything else on this list but maybe C.\n\nScala: Beats Java on (4); (1) and (2) but it's catching on.\n\nC and Javascript: As a special case, this is appealing because you already have to build or acquire and assimilate Javascript interpreter. (Hence Firefox.) (1, 2, 3 and 4) on toolkit; the Mozilla people built their own IIRC.\n\nC#: Have fun on (3). You're probably stuck with GTK#, however good that is, or building your own layer and renderer above GTK# and Windows Forms.\n\nRuby/Python/Perl/Racket/Lua/Erlange etc.: You've got (3) on cross-platform widget libraries and speed. Moore's law is with you on (4); the growing demand on browsers is against you.\n\nOCaml, Haskell, Common Lisp, Smalltalk: (1) and (2) in spades. No speed issues, probably, but (3) for cross-platform development, and you'll have to build your own everything or bridge to C/C++ libraries somehow.\n\nObjective-C: (3) I'm not sure how cross-platform development would work out here.\n\nIf we see another major browser rise in the next few years, I would bet it will be written in C or C++ and a dynamic language (Like Firefox), whether open source or proprietary.\n\nEdit (July 31, 2013): Commenters on Hacker News seem to be mentioning Rust and Go (not specifically in connection with my answer), which fall vaguely into the \"miscellaneous fast\" bucket. Trying to keep this list of languages egalitarian and up to date will be a losing battle, so instead I'm calling it a representative sample as of the time of writing and leaving it alone.\n\n(I've been working on Firefox for about five years.)\n\nThe questioner is right that a lot of Firefox's code is C++, and in fact C++ is the majority if you count by lines of code (although that doesn't tell the whole story, since we have a lot of JavaScript, and JS is more concise than C++).\n\nBut in reality, Firefox is written in a lot of different languages:\n\nC++\n\nC (NSS, NSPR, various libraries we've imported)\n\nx86 and ARM assembly\n\nJavaScript\n\nXUL (an HTML-like markup language) and CSS\n\nObjective C (MacOS-only code)\n\nJava (Android-only code)\n\nMultiple custom interface-definition languages (XPIDL, IPDL)\n\nWebIDL (another interface-definition language, but this one isn't custom, although the code generator is)\n\nPython (code generators)\n\nI sure am forgetting some.\n\nThis list is important because it hints at the incredible complexity that sits behind a web browser.\n\nYes, Firefox has a lot of C++ code, and yes, that has something to do with the fact that C++ was the best language for this sort of thing when Netscape was founded. But I also contend that there exists no better language today for a lot of what we do.\n\nNo other language has as strong an ecosystem of libraries (we rely heavily on external code). Few other languages give you full-stack control like C++ (we regularly tweak our custom heap allocator and do all sorts of memory-unsafe things to be faster or use less memory). Few other languages let you re-implement most of the standard library in a sane way (we have our own strings and collections implementations, tuned to our needs). Few other languages let you implement your own garbage collector. And so on.\n\nAlthough C++ is the obvious choice for a lot of what we do, the people who suggest that we could write a browser in Java and write our own JVM if necessary are on to something. This is essentially what we do, but with JavaScript instead of Java. Of course, much of the browser isn't written in JavaScript. But a surprising amount is.\n\nBecause the browsers (e.g., HotJava, obviously enough written in Java) written in other languages have never been achieved any substantial degree of market acceptance/penetration.\n\nI can't say anything about the current iteration (or most recent--hasn't been updated in quite a while) of HotJava, but when I tried it, lack of market penetration seemed (at least to me) extremely easy to understand -- it was ugly, slow, and incompatible with quite a few web pages. Ultimately, it seemed to be based on a premise that never panned out: that the web would consist primarily of Java applets, with HTML as little more than a wrapper telling which applets to display where.\n\nPart of it is probably also historical: most of the big web browsers have been around a long time. When they were first written, the landscape was much different: C++ was a \"hot\" new language, so it was being used for a lot of new development. Browsers have become some of the most heavily used software around, while many others from the time have faded into oblivion.\n\nI think the displayed \"attitude\" of the language has an effect as well: C++ (like C before it) has always emphasized practicality and pragmatism. That basic attitude tends to attract programmers who are also pragmatic. Many other languages place a great deal more emphasis on things like elegance -- and in so doing, they attract programmers who think the same way. The problem with that is what I call the \"Lisp effect\". Symptoms include:\n\nEndless arguments over the most elegant implementation of the most trivial things.\n\nInability to freeze features and finish something that can be shipped (even with flaws)\n\nInability to compromise. Anybody who disagrees with me is not just wrong, but must be either stupid or evil.\n\nThere are more, but you get the general idea (and yes, I'm exaggerating to some degree--but only to a degree). Yes, some of the code you get will be astoundingly beautiful--but chances are that it's six months late, and mostly incompatible with every other piece of code in (what's supposed to be) the system, and by the time you receive it there's a pretty fair chance something else has changed enough that you can't use it at all.\n\nThere are also languages that would undoubtedly work just fine, but (rightly or wrongly) simply don't have (or at the crucial time, didn't have) the market share for anybody to have ever written a browser in them. Given the size and complexity of a complete browser, it takes a lot of people and quite a bit of time to develop one. With that kind of investment, many people get relatively conservative about things like development tools."
    }
}