{
    "id": "dbpedia_8581_1",
    "rank": 82,
    "data": {
        "url": "https://developer.apple.com/swift/",
        "read_more_link": "",
        "language": "en",
        "title": "Apple Developer",
        "top_image": "https://developer.apple.com/swift/images/swift-og.png",
        "meta_img": "https://developer.apple.com/swift/images/swift-og.png",
        "images": [
            "https://developer.apple.com/assets/elements/icons/stars.svg",
            "https://developer.apple.com/assets/elements/icons/xcode-12/xcode-12-96x96_2x.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Apple Inc"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Swift is a powerful and intuitive programming language for iOS, iPadOS, macOS, tvOS, and watchOS. Writing Swift code is interactive and fun, the syntax is concise yet expressive, and Swift includes modern features developers love.",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://developer.apple.com/swift/",
        "text": "Modern\n\nSwift is the result of the latest research on programming languages, combined with decades of experience building software that runs on billions of devices. Named parameters are expressed in a clean syntax that makes APIs in Swift easy to read and maintain. Even better, you donâ€™t even need to type semi-colons. Inferred types make code cleaner and less prone to mistakes, while modules eliminate headers and provide namespaces. To best support international languages and emoji, strings are Unicode-correct and use a UTF-8-based encoding to optimize performance for a wide variety of use cases. Memory is managed automatically using tight, deterministic reference counting, keeping memory usage to a minimum without the overhead of garbage collection. You can even write concurrent code with simple, built-in keywords that define asynchronous behavior, making your code more readable and less error prone.\n\nstruct Player { var name: String var highScore: Int = 0 var history: [Int] = [] init(_ name: String) { self.name = name } } var player = Player(\"Tomas\")\n\nDeclare new types with modern, straightforward syntax. Provide default values for instance properties and define custom initializers.\n\nextension Player { mutating func updateScore(_ newScore: Int) { history.append(newScore) if highScore < newScore { print(\"\\(newScore)! A new high score for \\(name)! ðŸŽ‰\") highScore = newScore } } } player.updateScore(50)\n\nAdd functionality to existing types using extensions, and cut down on boilerplate code with custom string interpolations.\n\nextension Player: Codable, Equatable {} import Foundation let encoder = JSONEncoder() try encoder.encode(player) print(player)\n\nQuickly extend your custom types to take advantage of powerful language features, such as automatic JSON encoding and decoding.\n\nlet players = getPlayers() let ranked = players.sorted(by: { player1, player2 in player1.highScore > player2.highScore }) let rankedNames = ranked.map { $0.name }\n\nPerform powerful custom transformations using streamlined closures.\n\nThese forward-thinking concepts result in a language thatâ€™s fun and easy to use.\n\nSwift has many other features to make your code more expressive:\n\nGenerics that are powerful and simple to use\n\nProtocol extensions that make writing generic code even easier\n\nFirst-class functions and a lightweight closure syntax\n\nFast and concise iteration over a range or collection\n\nTuples and multiple return values\n\nStructs that support methods, extensions, and protocols\n\nEnums can have payloads and support pattern matching\n\nFunctional programming patterns, e.g., map and filter\n\nMacros that help reduce boilerplate code\n\nBuilt-in error handling using try / catch / throw\n\nDesigned for safety\n\nSwift eliminates entire classes of unsafe code. Variables are always initialized before use, arrays and integers are checked for overflow, memory is automatically managed, and potential data races can be spotted at compile-time. Syntax is tuned to make it easy to define your intent â€” for example, simple three-character keywords define a variable ( var ) or constant ( let ). And Swift heavily leverages value types, especially for commonly used types like Arrays and Dictionaries. This means that when you make a copy of something with that type, you know it wonâ€™t be modified elsewhere.\n\nAnother safety feature is that by default Swift objects can never be nil. In fact, the Swift compiler will stop you from trying to make or use a nil object with a compile-time error. This makes writing code much cleaner and safer, and prevents a huge category of runtime crashes in your apps. However, there are cases where nil is valid and appropriate. For these situations Swift has an innovative feature known as optionals. An optional may contain nil, but Swift syntax ensures you to safely deal with it using the ? syntax to indicate to the compiler you understand the behavior and will handle it safely.\n\nextension Collection where Element == Player { func highestScoringPlayer() -> Player? { return self.max(by: { $0.highScore < $1.highScore }) } }\n\nUse optionals when you might have an instance to return from a function, or you might not.\n\nif let bestPlayer = players.highestScoringPlayer() { recordHolder = \"\"\" The record holder is \\(bestPlayer.name),\\ with a high score of \\(bestPlayer.highScore)! \"\"\" } else { recordHolder = \"No games have been played yet.\" } print(recordHolder) let highestScore = players.highestScoringPlayer()?.highScore ?? 0\n\nFeatures such as optional binding, optional chaining, and nil coalescing let you work safely and efficiently with optional values.\n\nFast and powerful\n\nFrom its earliest conception, Swift was built to be fast. Using the incredibly high-performance LLVM compiler technology, Swift code is transformed into optimized machine code that gets the most out of modern hardware. The syntax and standard library have also been tuned to make the most obvious way to write your code also perform the best whether it runs in the watch on your wrist or across a cluster of servers.\n\nSwift is a successor to the C, C++, and Objective-C languages. It includes low-level primitives such as types, flow control, and operators. It also provides object-oriented features such as classes, protocols, and generics.\n\nGreat first language\n\nSwift can open doors to the world of coding. In fact, it was designed to be anyoneâ€™s first programming language, whether youâ€™re still in school or exploring new career paths. For educators, Apple created free curriculum to teach Swift both in and out of the classroom. First-time coders can download Swift Playgrounds â€” an app for iPad and Mac that makes getting started with Swift code interactive and fun.\n\nAspiring app developers can access free courses to learn to build their first apps in Xcode. And Apple Stores around the world host Today at Apple Coding & Apps sessions where you can get practical experience with Swift code.\n\nLearn more about Swift education resources from Apple\n\nPlaygrounds and Read-Eval-Print-Loop (REPL)\n\nMuch like Swift Playgrounds for iPad and Mac, playgrounds in Xcode make writing Swift code incredibly simple and fun. Type a line of code and the result appears immediately. You can then Quick Look the result from the side of your code, or pin that result directly below. The result view can display graphics, lists of results, or graphs of a value over time. You can open the Timeline Assistant to watch a complex view evolve and animate, great for experimenting with new UI code, or to play an animated SpriteKit scene as you code it. When youâ€™ve perfected your code in the playground, simply move that code into your project. Swift is also interactive when you use it in Terminal or to the Xcode LLDB debugging console.\n\nPackage manager\n\nSwift Package Manager is a cross-platform tool for building, running, testing, and packaging your Swift libraries and executables. Swift packages are the best way to distribute libraries and source code to the Swift community. Configuration of packages is written in Swift itself, making it easy to configure targets, declare products, and manage package dependencies. Swift packages can also include custom commands that help build your projects and provide additional tooling. Swift Package Manager itself is actually built with Swift and included in the Swift open source project as a package.\n\nObjective-C and C++ interoperability"
    }
}