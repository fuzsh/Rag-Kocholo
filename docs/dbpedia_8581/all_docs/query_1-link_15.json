{
    "id": "dbpedia_8581_1",
    "rank": 15,
    "data": {
        "url": "https://www.perforce.com/blog/qac/misra-cpp-history",
        "read_more_link": "",
        "language": "en",
        "title": "History of C++",
        "top_image": "https://www.perforce.com/sites/default/files/styles/social_preview_image/public/image/2023-11/image-blog-sa-history-of-cpp-coding-standards.jpg?itok=nOQMLBgZ",
        "meta_img": "https://www.perforce.com/sites/default/files/styles/social_preview_image/public/image/2023-11/image-blog-sa-history-of-cpp-coding-standards.jpg?itok=nOQMLBgZ",
        "images": [
            "https://www.perforce.com/sites/default/themes/custom/perforce/logo.svg",
            "https://www.perforce.com/sites/default/files/styles/teaser_image/public/image/2024-08/vcs_helix-core_report_2024_state-of-game-technology-report_resource.jpg?itok=Yt8ggwcv",
            "https://www.perforce.com/sites/default/files/image/2023-11/image-blog-sa-history-of-cpp-coding-standards.jpg",
            "https://www.perforce.com/sites/default/files/image/2023-08/frank-van-den-beuken%20%28002%29.jpg",
            "https://www.perforce.com/sites/default/themes/custom/perforce/logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Frank van den Beuken"
        ],
        "publish_date": "2023-11-29T10:01:48-06:00",
        "summary": "",
        "meta_description": "C++ is a popular programming language for safety-critical applications in the automotive industry. Here, we take a look back at the history of C++ as we prepare for the new MISRA C++:2023 guidelines.",
        "meta_lang": "en",
        "meta_favicon": "/sites/default/themes/custom/perforce/images/favicons/favicon.ico",
        "meta_site_name": "Perforce Software",
        "canonical_link": "https://www.perforce.com/blog/qac/misra-cpp-history",
        "text": "MISRA C++:2023®, the next version of the MISRA C++ standard, is here! To help you prepare, we present the second installment of our MISRA C++:2023 blog series by Perforce Principal Technical Support Engineer, Dr. Frank van den Beuken.\n\nIn this blog, we dive into the history of C++, how the programming language has evolved over the years, and where it's headed next.\n\n➡️ Read Part 1: Intro to MISRA C++:2023®\n\nTraining Courses for the NEW MISRA C++:2023 - Register today!\n\nPerforce is offering 2 training courses to choose from in January 2024 to ensure that you are fully prepared for the new guidelines. Register today!\n\nIntroduction to MISRA C++:2023\n\nMISRA C++:2023 for Safety-Critical Software Development\n\nRead along or jump ahead to the section that interests you most:\n\nBack to top\n\nIntroduction: C++ History\n\nC++ is a much-used general purpose programming language with which highly efficient programs can be written.\n\nBecause of that, it is also popular in safety-critical application areas such as those in the automotive industry, where MISRA is one of the most popular coding standards.\n\nLet's take a look at the fascinating history of the language.\n\nBack to top\n\nHow C++ Began\n\nC++ was invented by Danish computer scientist Bjarne Stroustrup at AT&T Bell Labs in 1979. It originated from analysis of the UNIX kernel to investigate to what extent it can be distributed over a network.\n\nWhile Stroustrup was working on his Ph.D thesis in the Computing Laboratory of Cambridge University, he was impressed by the program organization and concurrency features of the Simula programming language, which he used to write a simulator. However, he discovered that the implementation did not scale well, so eventually the simulator was rewritten in BCPL.\n\nBack to top\n\nC with Classes\n\nFor his work at AT&T Bell Labs, Stroustrup decided to enhance the C programming language with language features like those he found so useful in Simula. He started writing a pre-processor Cpre that converted C programs with Simula-like classes into regular C code that could be compiled with existing compilers. The new language was initially simply named, \"C with Classes.\"\n\nFrom the start, the objective was that the new language could be used for everything that C could be used for, so that it was a general-purpose programming language. Also, because C compilers already were available for many platforms, it inherited C's portability, which to this day is one of its important quality attributes. Another objective of the language was to provide better alternatives for unsafe features of C, while maintaining its efficiency and direct access to underlying hardware features.\n\nC with Classes provided:\n\nClasses\n\nDerived classes\n\nPublic/private access control\n\nConstructors and destructors\n\nCall and return functions (soon removed due to lack of popularity)\n\nFriend classes\n\nType checking of function arguments\n\nInline functions\n\nDefault arguments\n\nOverloading of the assignment operator.\n\nBack to top\n\nC++\n\nAt this point in C++ history, the language needed a proper name. For some time, it had been called C84, but that was considered ugly and confusing. Eventually, it was computer scientist Rick Mascitti who suggested the name C++, which can be interpreted as the language being the successor of C.\n\nAs more features were added to the language, the Cpre pre-processor was no longer suitable, and a proper compiler name Cfront was written. It still produced C code for convenience, but it was a proper compiler in that it performed a complete check of syntax and semantics as well as produced an internal representation of the program with one symbol table per scope.\n\nThe new language features included:\n\nVirtual functions\n\nFunction name and operator overloading\n\nReferences\n\nConst\n\nUser-controlled free-store memory control\n\nImproved type checking and C++ style comments (which were actually taken from BCPL).\n\nIn 1986 the first revision of the \"C++ Programming Language\" book was published, describing the language according to the Cfront 1.0 compiler.\n\nBack to top\n\nC++ Release 2.0\n\nThe second version of the language was completed in 1989 and increased stability of its definition and implementation.\n\nC++ 2.0 added:\n\nMultiple inheritance\n\nType-safe linkage\n\nImproved resolution of overloaded functions\n\nRecursive definition of assignment and initialization\n\nImproved facilities for user-defined memory management\n\nAbstract classes\n\nStatic member functions\n\nConst member functions\n\nProtected members\n\nOverloading of operator -> and pointers to members.\n\nBack to top\n\nC++ Release 3.0\n\nThis was the final C++ version before the language was standardized. C++ 3.0 was completed in 1991 and added class and function templates. There was supposed to be a C++ 4.0 release in 1993, adding exception handling for which an initial implementation was done by Hewlett-Packard in 1992, but it was never completed.\n\nBack to top\n\nThe Annotated C++ Reference Manual\n\nAT&T plans for a new C++ compiler never materialized, while other C++ compilers, both commercial (including Borland, IBM, DEC, and Microsoft) and the open-source GNU compiler g++ emerged. As a result, the focus of Stroustrup shifted to developing and standardizing the language. The Annotated C++ Reference Manual, published in 1991, became the starting point for the language standard. The manual provided a complete definition of C++ instead of just the features implemented by Cfront 3.0, and was reviewed by many people from various organizations. The new features were namespaces, nested classes, and exception handling.\n\nBack to top\n\nC++98\n\nANSI standardization of C++ was started in 1989 by Hewlett-Packard in conjunction with AT&T, DEC, and IBM. Standardizing the language became necessary for a few reasons: adding important new features, and preventing the development of incompatible dialects. In 1991 ISO standardization commenced, and since then the committees hold joint meetings.\n\nAn important activity was the definition of the standard library, including the Standard Template Library (STL). Furthermore, it added:\n\nReal-time type information (RTTI: dynamic_cast, typeid)\n\nCovariant return types\n\nCast operators\n\nMutable\n\nBool\n\nDeclarations in conditions\n\nMember templates\n\nIn-class member initializers\n\nSeparate compilation of templates (export)\n\nTemplate partial specialization\n\nPartial ordering of overload function templates.\n\nBack to top\n\nC++03 and Embedded C++\n\nC++03 was a maintenance release of C++98 amended with the corrections approved for the technical corrigendum. The committee had also started thinking about C++0x.\n\nMeanwhile, a consortium of Japanese embedded systems tools developers, including Toshiba, Hitachi, Fujitsu, and NEC, had proposed the Embedded C++ (EC++) subset. This was intended for embedded systems programming. The subset removed language features that could hurt performance or were perceived as too complicated for developers, and thus considered as productivity or correctness hazards.\n\nThe banned features were multiple inheritance, templates, exceptions, RTTI, new-style casts and namespaces. Also, STL and locales were removed from the standard library and an alternative for iostreams was provided. Interestingly, EC++ has not been used a lot, and the \"Ectended EC++\" superset that added templates was more popular.\n\nIn response to EC++, the committee released the Performance Technical Report. The Performance Technical Report provided a model of the time and space overhead implied by the use of various C++ language and library features. In doing so, it addressed concerns about performance problems. Furthermore, it presented techniques for efficient implementation. Consequently, the ISO committee did not endorse EC++.\n\nBack to top\n\nC++11\n\nThis version introduced many new major features, so that for many programmers, it felt like a new language!\n\nC++11 added:\n\nMemory model\n\nConcurrency\n\nAuto and decltype\n\nRange-for\n\nMove semantics and rvalue references\n\nUniform initialization\n\nNullptr\n\nConstexpr functions\n\nUser-defined literals\n\nRaw string literals\n\nAttributes\n\nLambdas\n\nVariadic templates\n\nTemplate aliases (using)\n\nNoexcept\n\nOverride and final\n\nStatic_assert\n\nLong long\n\nDefault member initializers\n\nInitialization in a constructor\n\nEnum classes.\n\nThere were also major additions to the standard library. In 1998, the Boost organization was initiated, which provides free peer-reviewed portable C++ source libraries. The Boost library was important because various library features were available in it early, so that the ISO standard could benefit from the experience gained from their usage. The memory model was an important foundation for concurrency support, that provided threads and locks.\n\nMove semantics can improve efficiency because it eliminates unnecessary copies, which can be expensive for large objects. It completes the control of object lifetimes and resource management by allowing a developer to control if a resource is copied, or if its ownership should be transferred to another object.\n\nBack to top\n\nC++14\n\nThe ISO C++ committee intended to have an alteration of major and minor releases, so that C++14 was aimed at completing C++11. It added:\n\nBinary literals (0b)\n\nDigit separators\n\nVariable templates\n\nFunction return type deduction\n\nGeneric lambdas\n\nLocal variables in constexpr functions\n\nMove capture\n\nAccessing a tuple by type\n\nUser-defined literals in the standard library.\n\nBack to top\n\nC++17\n\nAfter the minor C++14 release, C++17 should have been a major update. Unfortunately some major expected features, such as concepts and coroutines, did not make it in this version.\n\nThe new major features that did make it include:\n\nClass template argument deduction (introducing deduction guides)\n\nStructured bindings\n\nInline variables\n\nFold expressions\n\nExplicit test in conditions\n\nGuaranteed copy elision\n\nStricter expression evaluation order\n\nAuto as a template argument type\n\nStandard attributes to catch common mistakes\n\nHexadecimal floating-point literals\n\n\"if constexpr\".\n\nSome of the new features are exemplary for the increasing support for a functional programming style. The key element for that was already provided by lambdas in C++11, but fold expressions (a convenient notation to reduce a list of arguments to a single value using an operator) and deduction guides increase the functional flavor of the language.\n\nBack to top\n\nC++20\n\nThe major features that did not make it in C++17 were added in C++20. As a result, this version is a bigger step forward, comparable with the step from C++03 to C++11, so we can say that this version is the major upgrade that C++17 was supposed to be.\n\nThe major new language features are:\n\nCoroutines\n\nConcepts\n\nModules.\n\nOther new language features are compile-time computation support, spaceship operator <=>, concurrency improvements, designated initializers, and class types in non-type template parameters (also allowing string literals as template parameters). Furthermore, the new standard library features are ranges, date, span, and format.\n\nModules finally provide a better way to express modularity than the pre-processor based, which include file mechanism inherited from C. Coroutines provide a stackless mechanism for asynchronous execution of sequential code. Concepts are named sets of requirements on template arguments and are part of the interface of a template. They make it possible to specify the intended use of templates and greatly improve clarity of compilation errors when a constraint is not satisfied. This is a significant improvement compared to the previous practice of using \"Substitution Failure Is Not An Error\" (SFINAE), which results in long and complex compilation errors when a constraint is violated.\n\nBack to top\n\nThe Future of C++\n\nC++ has come a long way since the first steps in 1979 and continues to evolve.\n\nC++23 will soon be released with small but significant adjustments, and work has already begun on C++26.\n\nC++ continues to rise in popularity, and its use is expanding — including creating applications for virtual reality (VR) via the Unreal Engine, and also in cryptocurrency applications.\n\nBack to top\n\nTrust Perforce Static Analysis for C++\n\nPerforce's Static Analysis tools Helix QAC and Klocwork have been trusted for over 30 years for safe, secure, and high-quality code in C, C++, and more. Our tools identify defects, vulnerabilities, and compliance issues as you code, and are certified for use in safety-critical applications.\n\nHelix QAC also provides Compliance Modules for the enforcement of the new MISRA C++:2023 guidelines. Perforce plans to have the full MISRA C++:2023 Compliance Module available on the release of the standard.\n\nSee why Helix QAC is the best static code analyzer for MISRA C and MISRA C++.\n\n➡️ Sign Up for a Free 7-Day Trial\n\nBack to top"
    }
}