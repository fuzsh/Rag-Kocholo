{
    "id": "correct_subsidiary_00051_3",
    "rank": 26,
    "data": {
        "url": "https://patents.google.com/patent/US6377911B1/en",
        "read_more_link": "",
        "language": "en",
        "title": "US6377911B1 - Apparatus for emulation of electronic hardware system - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/82/07/62/69607c00789863/US6377911-drawings-page-5.png",
            "https://patentimages.storage.googleapis.com/bc/05/d3/ddd55df50beca5/US6377911-drawings-page-6.png",
            "https://patentimages.storage.googleapis.com/6a/a2/ce/ce1c7be3587297/US6377911-drawings-page-7.png",
            "https://patentimages.storage.googleapis.com/75/14/c6/02ce98436c1353/US6377911-drawings-page-8.png",
            "https://patentimages.storage.googleapis.com/f8/8d/48/5114d2f677d754/US6377911-drawings-page-10.png",
            "https://patentimages.storage.googleapis.com/de/a9/1c/7795a9ee81e1ed/US6377911-drawings-page-11.png",
            "https://patentimages.storage.googleapis.com/22/a0/7c/1585c6f070d717/US6377911-drawings-page-12.png",
            "https://patentimages.storage.googleapis.com/e2/0c/ac/95b1a1c7e2a98d/US6377911-drawings-page-13.png",
            "https://patentimages.storage.googleapis.com/85/89/0c/a62af6df5256dd/US6377911-drawings-page-14.png",
            "https://patentimages.storage.googleapis.com/3d/05/48/5349e319e38c54/US6377911-drawings-page-15.png",
            "https://patentimages.storage.googleapis.com/18/a5/8c/ef9a31f54d87bd/US6377911-drawings-page-16.png",
            "https://patentimages.storage.googleapis.com/53/11/fc/183c8adfbd71ec/US6377911-drawings-page-17.png",
            "https://patentimages.storage.googleapis.com/57/39/f2/3c2cb2cab0e4f0/US6377911-drawings-page-18.png",
            "https://patentimages.storage.googleapis.com/ac/b0/96/c082457a26ba52/US6377911-drawings-page-19.png",
            "https://patentimages.storage.googleapis.com/34/13/78/e2d08f3a098b30/US6377911-drawings-page-20.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "1988-12-02T00:00:00",
        "summary": "",
        "meta_description": "A system for physical emulation of electronic circuits or systems includes a data entry workstation where a user may input data representing the circuit or system configuration. This data is converted to a form suitable for programming an array of programmable gate elements provided with a richly interconnected architecture. Provision is made for externally connecting VLSI devices or other portions of a user's circuit or system. A network of internal probing interconnections is made available by utilization of unused circuit paths in the programmable gate arrays.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US6377911B1/en",
        "text": "This application is a continuation of pending prior application Ser. No. 08/865,559 filed on May 29, 1997, now U.S. Pat. No. 5,963,735, which is a File Wrapper continuation of application Ser. No. 08/478,964 filed on Jun. 7, 1995 (now abandoned), wich is a continuation of application Ser. No. 08/273,513, filed Jul. 11, 1994, now U.S. Pat. No. 5,477,475, which is a continuation of application Ser. No. 08/171,348, filed Dec. 21, 1993, now U.S. Pat, No. 5,329,470, which is a continuation of application Ser. No. 08/071,033, filed May 28, 1993, (now abandoned), which is a continuation of application Ser. No. 07/824,341, filed Jan. 23, 1992 (now abandoned), which is a continuation of application Ser. No. 07/279,477, filed Dec. 2, 1988, now U.S. Pat. No. 5,109,353.\n\nFIELD OF THE INVENTION\n\nThe present invention relates to electronic hardware systems. More particularly, the present invention relates to apparatus for emulation of electronic hardware system.\n\nTHE PRIOR ART\n\nAs electronic components and electronic systems have become more complex, the design of these components and systems has become a more time consuming and demanding task. Recently software simulation of electronic components and systems has become an important tool for designers. Simulation of a design is the execution of an algorithm that models the behavior of the actual design. Simulation provides the ability to analyze and verify a design without actually constructing the design and has many benefits in the design process. However, simulation suffers from three major limitations: the speed of the simulation, the need for simulation models, and the inability to actually connect a simulation of one part of a design to an actual physical implementation of another part of the design.\n\nSimulation accelerators have come to be used to address the problems of the execution speed of simulation. A simulation accelerator uses special purpose hardware to execute simulation algorithms in order to achieve higher speeds than can be achieved using general purpose computers. None the less, simulation accelerators still execute an algorithm that models the actual design and consequently remain substantially slower than a real hardware implementation. Accelerators do not in any way obviate the need for software models of all devices to be simulated.\n\nPhysical modeling systems such as the Valid Real Chip or Daisy PMX address the problem of the lack of availability of software models for complex standard parts. They also address to some degree the speed of execution of complex software models. Physical modelers are used in conjunction with software simulators. The modeling engine and an actual part plugged into it are used in lieu of a model of that part and are connected to a simulator which can then use the actual responses of the part in lieu of a simulation model of the part. The primary innovations in the arena of physical modeling have been associated with this connection between the modeler and the simulator.\n\nSimilar design and verification problems that arise with the use of standard microprocessors have been addressed through the use of microprocessor in-circuit emulators supplied by a number of companies. A microprocessor in-circuit emulator uses an actual microprocessor, or a specially modified version of the standard microprocessor, combined with special purpose instrumentation logic to make the job of debugging a design easier. A microprocessor in-circuit emulator includes a cable which can be plugged into a system in lieu of the actual microprocessor so that the actual system can be run at or near real time during debugging.\n\nWhile all of these techniques provide advantages in the design and verification process, none satisfy all of the needs for designing and debugging including: near real time operation for non-standard parts, in-circuit emulation for other than standard parts, and freedom from the need for software models for all devices.\n\nBRIEF DESCRIPTION OF THE INVENTION\n\nAn apparatus is disclosed and claimed which aids in the development of integrated circuit and system design by quickly and automatically generating a hardware prototype of the integrated circuit or system to be designed from the user's schematics or net list. The prototype is electrically reconfigurable and may be modified to represent an indefinite number of designs with little or no manual wiring changes or device replacement. The prototype runs at real time or close to real time speed and may be plugged directly into a larger system. VLSI chips or ASIC devices may be plugged into the prototype and run as part as the emulated design.\n\nThe apparatus of the present invention includes an emulation array, which is an array of an electrically programmable gate arrays used to implement the necessary logic functions and connect them together into a complete design. The gate arrays provide both logic implementation and signal routing between fixed printed circuit board traces. Few or no manual steps such as wire wrapping, or replacement of PALs are required to modify the design.\n\nExternal cables along with a series of adaptor plugs allow the programmable breadboard to be connected directly to an existing system or printed circuit board. The apparatus of the present invention replaces a chip or board as a part of a larger system. Additional debugger hardware is included to allow internal nodes of the design to be probed and the resulting wave forms displayed without requiring the user to manually move wires. Internal nodes may also be stimulated.\n\nA user supplied netlist or schematic is converted into a correct configuration file for use by the apparatus.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nFIG. 1a is a block diagram of a presently-preferred embodiment of apparatus of the present invention.\n\nFIG. 1b is a block diagram of a programmable gate array used in the presently preferred embodiment, shown surrounded by eight of its immediate neighbors in the array matrix, illustrating I/O pin interconnections.\n\nFIG. 1c is a block diagram showing the interconnections between programmable gate arrays and probe programmable gate arrays in a presently-preferred embodiment of the present invention.\n\nFIG. 2 is a block diagram of a portion of the emulation array matrix of a presently-preferred embodiment showing four programmable gate arrays and showing how an exemplary circuit may be connected using those programmable gate array chips.\n\nFIG. 3 is a block diagram of a portion of the emulation array showing physical device emulation and provision for connecting external VLSI devices to the apparatus.\n\nFIG. 4 is a block diagram of a portion of the emulation array showing elements used for memory device emulation.\n\nFIG. 5 is a block diagram of the interface portion of the present apparatus which connects the apparatus of the present invention to the user's system.\n\nFIG. 6 is a block diagram of logic analyzer and pattern generator for use with the present invention.\n\nFIG. 7 is a block diagram of an example of the use of the probing logic of the present invention.\n\nFIG. 8 is a block diagram of the contents of configuration unit 14 of FIG. 1a.\n\nFIG. 9 is a flow diagram of a presently preferred routine for loading information into the programmable gate arrays.\n\nFIG. 10 is a diagram of the software routines which may be utilized in a presently-preferred embodiment.\n\nFIGS. 11a-e are flow diagrams of software routines for accomplishing system partitioning of circuit elements according to a presently-preferred embodiment of the present invention.\n\nDETAILED DESCRIPTION OF A PREFERRED EMBODIMENT\n\nA preferred embodiment of the apparatus of the present invention is depicted in FIG. 1a. Emulation apparatus 10 includes a data entry workstation 12, at which a user enters information describing the electronic circuit or system which it is desired to emulate. Configuration information created by the data entry work station 12 is passed to configuration unit 14. Configuration unit 14 contains the circuitry necessary to accomplish the programming of the programmable gate arrays which are contained within emulation array 16.\n\nThe heart of the system of the present invention is emulation array 16. Emulation array 16 includes a plurality of programmable gate array devices 18. The programmable gate array devices 18 are arranged in a matrix. For illustrative purposes only, emulation array 16 of FIG. 1 is shown as a 3Ã3 matrix containing 9 total gate arrays, denoted by reference numerals 18 a-18 i. Those of ordinary skill in the art will readily recognize that the 3Ã3 array depicted in FIG. 1 is for illustration only and that, in an actual embodiment, the size of emulation array 16 is limited only by simple design choice.\n\nIn an actual implementation, emulation array 16 may be a three dimensional array and, in a presently preferred embodiment, consists of a plurality of circuit boards each containing a matrix of individual programmable gate array integrated circuit devices 18. In a presently preferred embodiment, each card contains a 6Ã6 matrix of programmable gate arrays 18. In the presently-preferred embodiment, an additional row of 6 programmable gate arrays exists on each card for use in test probing.\n\nIn a presently preferred embodiment, programmable gate array integrated circuit devices 18 may be XC3090 integrated circuits manufactured by Xilinx Corporation of San Jose, Calif. These integrated circuits and their use are described in the publication Programmable Gate Array Data Book, Publication No. PN0010048 01 which is expressly incorporated herein by reference.\n\nThe I/O pin wiring in between programmable gate array chips 18 in the present invention is illustrated with respect to FIG. 1b. FIG 1 b shows six programmable gate arrays in a matrix. The programmable gate array in the center, reference numeral 18 x, is shown having connections to its neighbors.\n\nEach one of the programmable gate arrays 18 has a fixed number of its input/output (I/O) pins wired to a backplane. These I/O pins are used for intercard wiring, and inclusion of VLSI integrated circuits to be included in the emulated circuit. In a presently preferred embodiment, twenty-eight I/O pins on each gate array 18 x are wired to a back plane and are used for inclusion of VLSI devices in the emulated circuit. These same I/O pins may be connected, fourteen each, to corresponding programmable gate arrays (i.e., those in corresponding positions) on the circuit boards immediately above and below the board containing programmable gate array 18 x. These are denoted by the up and down arrows indicating fourteen lines, reference numerals 19 a and 19 b. Ten I/O pins on each gate array 18 are dedicated to the input/output lines of the emulated system, (not shown in FIG. 1b) and nine I/O pins are used for probing internal nodes (not shown in FIG. 1b).\n\nThe remaining ninety-six I/O pins on each gate array 18 are used to interconnect to input/output pins on other programmable gate arrays in the matrix. In a presently-preferred embodiment, eighteen I/O pins (reference numerals 19 c-f) are connected to each adjacent programmable gate array. Four I/O pins are connected to a global four bit bus connecting all gate arrays, four I/O pins are connected one each to the gate arrays in the comers of the matrix (reference numerals 19 g-j) and four I?O pins in each horizontal and vertical direction (reference numerals 19 k-n) leapfrog; i.e., are connected to the chip once removed.\n\nTo increase the richness of the interconnect possibilities of the emulation array of the present invention, the interchip connections are âwrapped aroundâ the ends of the matrix. This means that, for instance, I/O pins of the programmable gate array chip 18 a in FIG. 1a are connected to the I/O pins on the programmable gate array chip 18 c, I/O pins on the programmable gate array 18 d are connected to I/O pins on the programmable gate array chip 18 f, and I/O pins on the programmable gate array chip 18 g are connected to I/O pins on the programmable gate array chip 18 i.\n\nLikewise, I/O pins on the programmable gate array chip 18 a, are connected to I/O pins on the programmable gate array chip 18 g, I/O pins on the programmable gate array chip 18 b are connected to I/O pins on the programmable gate array chip 18 h, and I/O pins on the programmable gate array chip 18 c are connected to I/O pins on the programmable gate array chip 18 i.\n\nIn a preferred embodiment of the system of the present invention, the emulation array 16 is a three dimensional array, and is composed of a plurality of cards each containing a 6Ã6 matrix. The intercard technique is extended in the vertical third dimension such that I/O pins on the programmable gate arrays on one level of the matrix on a given card have connections to I/O pins on the corresponding programmable gate arrays on the cards immediately above and below. In addition, connections from the arrays on the top card are wrapped around to corresponding arrays on the bottom card. In this manner, the richest possibility of interconnects and routing choices is presented.\n\nData entry work station 12 may be a presently-available work station such as those manufactured by Daisy, Mentor, and Valid Logic. Data entry workstation 12 generates a gate level net list from data input by the user in the manner well known in the art. Using several software programs, the operation of which is disclosed infra, data entry workstation 12 produces a set of files necessary to program the interconnections and logic functions within each of the programmable gate array chips in emulation array 16, probing logic section 20, logic analyzer/pattern generator 22 and interface 25. Configuration unit 14 then configures the system using the files produced by data entry workstation 12.\n\nProbing logic section unit 20 includes a plurality of probing logic programmable gate arrays which, in a preferred embodiment, per circuit board, are equal in number to one of the dimensions of the matrix per card. As illustrated in FIG. 1c, six probing logic programmable gate arrays are utilized in the presently preferred embodiment where the matrix is a 6Ã6 matrix. These gate arrays have I/O pin interconnections to each of the programmable gate arrays in the matrix column located adjacent to these arrays. For example, the first probing logic array has a number of interconnections to programmable gate arrays 18 a, 18 d, and 18 g of FIG. 1a.\n\nIn a presently preferred embodiment, fifty-four I/O connections on each of the probing logic programmable gate arrays are provided to the six programmable gate arrays in the column of the matrix above it, nine of these connections per programmable gate array. In addition, each probing logic programmable gate array has connections to others. In this manner, a probing logic programmable gate array may be connected to any of the other programmable gate arrays in the entire matrix.\n\nProbing logic unit 20 provides a means of connecting the logic analyzer/pattern generator 22 to the desired nodes in the design contained in the emulation array 16. Configuration unit 14 makes the connections between probing logic 20 and logic analyzer/pattern generator 22. The pattern generator provides signals to the design configured in and running in emulation array 16 and the logic analyzer monitors circuit activity in the design.\n\nThe emulation array 16 connects to the user's external system 24, such that the portion of the external system which is being emulated by the emulation array 16 may actually be connected into the user's external system 24. One or more VLSI devices, shown at reference number 26, may also be incorporated into the design being emulated by system 10. In addition to VLSI devices, other circuit functions utilizing discrete components and/or integrated circuits, may be placed in reference numbers 26. Provision is made for incorporated these devices by providing a number of I/O pin connections from the programmable gate arrays 18 out to a circuit card upon which the one or more VLSI devices, such as microprocessors and the like may be located. Outboard devices placed at reference number 26 may be placed there because they cannot, for one or more reasons, be effectively implemented in the array. High speed or analog circuits are two such examples.\n\nAdditionally, memory devices shown at reference numeral 28 in FIG. 1 may be connected into the emulation array. The preferred configurations of the VLSI devices 26 and the memory devices 28 will be explained with respect to FIGS. 3 and 4 respectively.\n\nReferring now to FIG. 2, a portion of the emulation array 16 of the system 10 of the present invention is shown to include programmable gate array devices 18 a, 18 b, 18 d, and 18 e, interconnected as they would be in the matrix. In the example shown in FIG. 2, an AND-gate 30 is shown in programmable gate array 18 e, having its first input connected through conductor 32 on programmable gate array 18 a, conductor 34 in between gate arrays 18 a and 18 b conductor 33 in gate array 18 b, and conductor 36 in between gate arrays 18 b and 18 e. A second input to AND-gate 30 is connected via conductor 38 in programmable gate array 18 d and conductor 40 between programmable gate array 18 d and 18 e. The output of AND-gate 30 is connected to conductor 42 out of programmable gate array 18 e. The connections in between programmable gate array chips, i.e., 34, 36 and 40, are hard wired, preferably by means of printed circuit board traces, while internal connections in programmable gate array chips, i.e., 32, 33 and 38, are made by means of the configuration information loaded into them by configuration unit 14.\n\nThose of ordinary skill in the art will readily recognize that the example shown in FIG. 2 is a simplified example for illustrative purposes only and that in an actual circuit emulation, programmable gate arrays 18 a, 18 b, 18 d, and 18 e shown in FIG. 2 will contain more logic functions and will be much more richly connected. In fact, once configured, the emulation array will contain the entire circuit to be emulated, with the exception of any VLSI components, which may be externally connected to the emulation array as shown with respect to FIG. 3.\n\nReferring now to FIG. 3, VLSI devices 26 a and 26 b are shown connected to emulation array 16 via a plurality of conductors 44 a-g and 46 a-g. In addition, bus 48 is shown connected both to each VLSI device and to emulation array 16. Bus 48 is provided for bus architecture oriented VLSI devices such as microprocessors, having address and data busses, etc.\n\nThose of ordinary skill in the art will readily recognize that the VLSI devices 26 a and 26 b are shown illustratively connected to emulation array 16 with only seven signal lines 44 a-g and 46 a-g and bus 48, respectively. In practice, any number of single signal connections may be made to these devices, the exact number being a matter of design choice based upon the maximum likely number of such connections which would be needed as well as the total number of signal lines available for the devices.\n\nReferring not to FIG. 4, a presently-preferred embodiment of a memory device emulation circuit is shown. Memory devices 50 a, 50 b, and 50 c are shown having their address, data and control lines connected to a programmable gate array device 18 in emulation array 16. Thus, address busses 52 a, 52 b, and 52 c of memory devices 50 a, 50 b, and 50 c respectively are shown connected to programmable gate array device 18 as are data lines 54 a-c and control lines 56 a-c. Master address bus 58, master data bus 60 and master control bus 62 connect from programmable gate array 18 to the emulation array 16. By the appropriate programming of the interconnects in the programmable gate array matrix 16 the memory devices 50 a, 50 b, and 50 c in the circuit of FIG. 4, may be configured to emulate memory arrays of varying widths and depths as required by the circuit being emulated.\n\nAs will be appreciated by those of ordinary skill in the art, the memory devices 50 a, 50 b, and 50 c can be virtually any type of memory. The numbers of address data and control lines will vary with size and type of memory and those of ordinary skill in the art will have no difficulty realizing how to configure a memory emulation array as depicted in FIG. 4 using any type of memory chips.\n\nReferring now to FIG. 5, the interface between the emulation array 16 and the users external system 24 will be described. The interface unit (reference 25 of FIG. 1) may be configured from a programmable gate array 70. Programmable gate array 70 may also be a Xilinx XC3090 programmable gate array integrated circuit. The function of the programmable gate array 70 will be to provide signal mapping between the emulation array 16 and the user's external system 24. Programmable gate array 70 provides connections and signal paths between the plurality of conductors coming into the programmable gate array 70 on lines 72, and the lines 74 connecting programmable gate array 70 to the user's external system 24. Another function of the programmable gate array 70 to provide buffering of the signals on lines 72 and 74.\n\nA third function of programmable gate array 70 is to provide local implementation of high speed logic. For certain circuit design, there may be some critical signal paths which, if routed through the emulation array, would cause system failure because of the time delay associated with signal paths involved in the emulation array 16. For such circuits, the critical path logic may be implemented in the interface unit close to the user's external system to cut down the signal path time and the signal delay.\n\nA presently-preferred embodiment, line 72 is a 75 ohm cable transmission line. Those of ordinary skill in the art will recognize that termination resistors, useful to prevent signal reflections at the ends of the cables should be provided at each end of the transmission lines since the line 72 is bi-directional and will be conducting signals in one direction or another direction depending on the particular design being emulated.\n\nReferring now to FIG. 6, the logic analyzer and pattern generator circuitry of the present invention is seen to include a plurality of programmable gate arrays. In a presently preferred embodiment, a first data channel programmable gate array 80 is connected between an I/O bus 82 and a plurality of random access memory (RAM) chips 84 a-h. A common address bus 86 is connected to all of the RAM chips 84 a-h from data channel programmable gate array 80. A data bus 88 is connected from the data channel programmable gate array 80 to the data inputs of the RAM chips 84 a through 84 f.\n\nA second data channel programmable gate array 90 is connected to the I/O bus 82. A plurality of Ram chips 92 a-h are connected to data channel programmable gate array 90 via an address bus 94. A data bus 96 connects the second data channel programmable gate array 90 to the data inputs of random access memory chips 92 a-92 f. Together, first and second data channel programmable gate arrays 80 and 90, and their associated RAM chips 84 a-h and 92 a-h, constitute a data module. The present invention may use one or more data modules. In a presently preferred embodiment, there are four data modules.\n\nThe data channel programmable gate array 80 and 90 are controlled by a control logic programmable gate array 98 which is connected to I/O bus 82. Control lines 100 connect control logic programmable gate array 98 to data channel programmable gate arrays 80 and 90. A time stamp bus 102 connects control logic programmable gate array 98 to the data inputs of random access memories 84 g and h and 92 g and h. The time stamp signal from control logic programmable gate array 98 places event time information into random access memories 84 g and h and 92 g and h simultaneous with data from events being written into random access memories 84 a-f and 92 a-f.\n\nReferring now to FIG. 7, the probing logic of a preferred embodiment of the present invention is disclosed. The probing logic section 20 contains probe programmable gate arrays 110 a, 110 b and 110 c. Probe programmable gate arrays 110 a-c are connected to I/O bus 82.\n\nEach of probe programmable gate arrays 110 a, 110 b, and 110 c are connected to the programmable gate arrays in the emulation array in the column of the matrix above it. Thus, probe programmable gate array 110 a has connections to emulation array programmable gate arrays 18 a, 18 d, and 18 g; probe programmable gate array 110 b has connections to emulation array programmable gate arrays 18 b, 18 e, and 18 h, and probe programmable gate array 110 c has connections to emulation array programmable gate arrays 18 c, 18 f, and 18 i.\n\nThe operation of the probing logic will be shown using example illustrated in FIG. 7. Those of ordinary skill in the art will readily recognize that FIG. 7 is merely an illustration and the probing logic shown in FIG. 7 is generally applicable.\n\nIn the illustration of FIG. 7, emulation array programmable gate array 18 a is shown to include a pair of inverters 112 and 114. A line 116 is shown extending from emulation array programmable gate array 18 a to probe programmable gate array 110 a. Similarly, lines 118 and 1209 connect emulation array programmable gate arrays 18 d and 18 g to probe programmable gate array 110 a.\n\nIn the second column of the matrix of emulation array 16, a D flip-flop 122 is shown in emulation array programmable gate array 18 e. Lines 124, 126, and 128 are shown connecting emulation array programmable gate arrays 18 b, 18 e, and 18 h, respectively, to probe programmable gate array 110 b.\n\nIn a similarly manner, lines 130 132, and 134 are shown connecting emulation array programmable gate arrays 18 c, 18 f, and 18I, respectively, to probe programmable gate array 110 c. Those of ordinary skill in the art will readily recognize that lines 116, 118, 120, 124, 126, 128, 130, 132, and 134 are shown as single lines for illustrative purposes only. In any practical embodiment, a plurality of such lines may be provided so that multiple points in any of the emulation array programmable gate arrays can be probed by the probe programmable gate arrays. In a presently preferred embodiment, there are 9 lines connected from each probe programmable gate array to each emulation array programmable gate array in the column above it.\n\nReturning to the illustrative embodiment of FIG. 7, suppose it is desired to probe the output of invertor 112. Emulation array programmable gate array 18 a is programmed, creating a connection between the I/O pin to which line 116 is connected and the node comprising the output of inverter 112 and the input of inverter 114.\n\nSimilarly, if the clock input of D flip-flop 122 inside emulation array programmable gate array 18 e is to be probed, that programmable gate array is programmed to create a connection between line 126 and the clock input of D flip-flop 122. A second connection is created within one of the probe PGAs (10 a-c to route the probed signal to one of the I/O Bus Signals.\n\nThe programmable gate arrays used in the various portions of the present invention are programmed by configuration unit 14. The programming of the programmable gate arrays by configuration unit 14 may be best understood with reference to FIG. 8. This discloses one presently preferred method of configuring programmable gate arrays. Other methods are available and are explained in the Xilinx data book.\n\nFor purposes of the explanation of configuration unit 14, illustrative programmable gate arrays 150, 152, 154, and 156 are shown in FIG. 8, although it is to be understood by those of ordinary skill in the art that programmable gate arrays 150, 152, 154 and 156 represent all such gate arrays in the system and that by understanding the principles herein disclosed, a particular system configured according to the present invention could have an arbitrary number of programmable gate arrays.\n\nData entry work station 12 of FIG. 1a may be connected to the standard VME bus well understood by those of ordinary skill in the art. VME bus 158 in FIG. 8 is the bus connected to the output of data entry work station 12. The VME bus 158 is connected to serial to parallel converter 160, and to address latch 172 and to Strobe generator 164. The output of address latch 172 is address bus 174, which is connected to strobe demultiplexer 162, clock demultiplexer 166, and verify demultiplexer 170.\n\nThe serial output and serial input of serial/parallel converter 160 are connected to the data inputs and the data outputs, respectively, of programmable gate arrays 150, 152, 154, and 156. Strobe demultiplexer 162, connected on one end to address bus 174, has an output for each of the programmable gate arrays 150, 152, 154, and 156. Verify demultiplexer 170 is likewise connected on one end to address bus 174 and has an output for each of programmable gate arrays 150, 152, 154, and 156. Both strobe demultiplexer 162 and verify demultiplexer 170 are connected to strobe generator 164. The function of strobe generator 164 is to provide an edge-activated strobe signal which either strobe demultiplexer 162 or verify demultiplexer 170 will route to the appropriate one of the programmable gate arrays 150, 152, 154, or 156. Strobe generator 164 is connected to the DSO data strobe line in the VME bus 158.\n\nClock demultiplexer 166 is connected on one end to address bus 174 and has an output corresponding to each of programmable gate arrays 150, 152, 154, and 156. Clock demultiplexer 166 is also connected to clock generator 168 which is used to clock the data into programmable gate arrays 150, 152, 154, and 156.\n\nThe configuration software which runs in data entry work station 12 results in a series o files each of which programs one of the programmable gate array chips in the system. Information from these files is transferred to the configuration unit 14 as a plurality of bytes. A software routine running in the data entry work station directs the programming of all programmable gate arrays in the system using the hardware of configuration unit 14. Three signals are needed to program the programmable gate arrays. The first, a clock signal, is decoded from a master clock signal by clock demultiplexer 166. The second signal is a strobe signal, which is an edge triggered strobe and is decoded by strobe demultiplexer 162. The strobe signal acts as an enable signal to the selected one of illustrative programmable gate arrays 150, 152, 154, or 156. The third signal used to program the programmable gate arrays is the data itself, which is sent as a serial data stream. Clock demultiplexer 166 is necessary because upon system power up, the nature of the presently-preferred programmable gate array devices is such that they all are enabled to receive data, thus requiring some selection process to prevent the nonselected programmable gate array chips from programming.\n\nThe data entry work station first sends an address across the VME bus which specifies address latch 172. A data byte is latched into address latch 172 and appears on address bus 174. Once the address information in address latch 172 is valid, data entry workstation 12 sends a strobe signal over VME bus 158 to strobe generator 164 which then provides the necessary strobe signal to strobe demultiplexer 162. Strobe demultiplexer 162 routes the strobe signal to the selected one of the programmable gate arrays 150, 152, 154, or 156. Data from VME bus 158 is then loaded into serial/parallel converter 160. The data is then clocked out onto serial out line 176 which is commonly connected to the data input lines of programmable gate arrays 150, 152, 154, and 156. The clocking serial/parallel converter 160 is coordinated with the clocking from 168, providing the clock signal to clock demultiplexer 166. The clock signals from clock generator 168, routed via clock demultiplexer 166 to the selected one of programmable gate arrays 150, 152, 154, and 156 allow the serial data appearing on Sout line 176 of serial/parallel converter 160 to be taken into the appropriate programmable gate array one bit at a time. After serial/parallel converter 160 has been emptied, the VME bus supplies another data byte to serial/parallel converter 160. The clocking of the data into the selected programmable gate array is then repeated. Each successive data byte is delayed by withholding the VME DTACK signal until the preceding byte has been shifted out of the serial/parallel converter. Another byte is loaded into serial/parallel converter 160 and clocked into the selected programmable gate array until all of the data bytes for the selected programmable gate array have been loaded into the array. VME bus 158 then loads another address into address latch 172, thus selecting another programmable gate array for programming. This process is repeated until all of the programmable gate arrays in the system have been loaded with information.\n\nAfter all the programmable gate arrays in the system have been loaded, the information which has been loaded into them may be verified for correctness. Verify demultiplexer 170 selects a programmable gate array for verification and provides a strobe signal started by VME bus 158, generated by strobe generator 164 and routed by verify demultiplexer 170. Clock 168, routed to the appropriate programmable gate array via clock demultiplexer 166 clocks serial data out of the data output of the selected programmable gate array and into the Sin input of serial/parallel converter 160. Once serial/parallel converter 160 has been loaded, its parallel data is placed out onto the VME bus.\n\nThis process is completely analogous to the loading process except for the data direction.\n\nAlthough the data in and data out connections of programmable gate arrays 150, 152, 154, and 156 are shown connected to a single serial/parallel converter 176, those of ordinary skill in the art will realize that both the data in and data out connections of the programmable gate arrays may be split and buffered as is known in the art to reduce loading and noise.\n\nReferring now to FIG. 9, a preferred routine for the loading of information into the gate arrays of the present invention is disclosed. First, at step 180, the files to be loaded are inventoried. Next, at step 182, the first file name is used to generate an address. Next, at step 184, that address is written into address latch 172. Next, at step 186, a strobe signal is generated by writing to strobe generator 164. At step 188, a data byte is written into serial/parallel to converter 160.\n\nNext, at step 190, the decision is made whether the data byte just written is the last data byte in the file. If is not, step 188 is repeated. If the data byte just written was the last data byte in the file, a verify signal is generated by the strobe generator at step 192. Next, at step 194, the data byte is read from the serial/parallel converter 160. Next, at step 196, it is determined whether the byte just read is the last byte in the file. If not, step 194 is repeated. If it was the last byte, the data read is compared to the data written at step 198.\n\nAt step 200 it is determined whether the written data matches the read data, and if the data does not match an error is reported at step 202. If the data does match, at step 204 it is determined whether the file just operated on is the last file. If not, the program returns to step 182 to process the next file. If so, the program terminates.\n\nData entry workstation 12 runs several software programs which convert the information input by the system user into information which may be used directed by configuration unit 14 to program all the programmable gate arrays used in the present invention. An additional software program is used to control the hardware in configuration unit 14 for the purposes of both programming and verifying the information in the programmable gate arrays. A block diagram of a presently-preferred software structure useful in the present invention is shown in FIG. 10.\n\nReferring now to FIG. 10, a schematics data file 210 is created in data entry workstation 12 by the user. Netlister 212 converts schematics data file 210 into netlist file 214. Library file 216 contains information about the individual logic components which will be configured into the user's real circuit or system and which the system of the present invention will emulate. Library file 216 may be made up of any number of individual component model library files readily available from information provided by semiconductor and component manufacturers. The choice of which of such library files to incorporate into a system constructed in accordance with the present invention is purely a matter of the marketeer's choice, and is in no way within the scope of the present invention.\n\nNetlister 212, and library 216 are readily available in commercially available data entry workstations; however, the library is sometimes provided in a proprietary format, which must either be converted or substituted by a conventional format library. Schematic file 210 is of course, created by the user.\n\nNetlist file 214 is read by netlist parser 218, which places data from netlist file 214 into memory.\n\nInformation from netlist parser 218 is processed by hierarchical netlist expander 220 and the resulting data is linked with the data from library file 216 in library linker 222. Parsers, linkers and netlist expanders are well-understood by those of ordinary skill in the art and are straightforwardly implemented.\n\nThe netlist information, linked with the library information by library linker 222, is now a gate level net list 224 in a form suitable for functional implementation and timing analysis as is well understood by those of ordinary skill in the art.\n\nThe next step, shown at reference numeral 226, is to partition the circuit to be emulated among the gate arrays in the emulation system. In a presently preferred embodiment, this may be accomplished by software such as that disclosed herein with respect to FIGS. 11a-e.\n\nAfter partitioning, the next step in the process of configuring is a system routing, shown at reference numeral 228, which assigns the connection between circuit elements to available chip to chip wiring resources. This may be accomplished by using a Lee-Moore maze router as described in Lee C. An Algorithm for Path Connections and its Applications, IRE Trans. on Electronic Computers. Vec-10 pp. 346-365, September 1961, which is expressly incorporated by reference herein.\n\nOnce the gate level netlist has been partitioned on to the programmable gate arrays, the information may be processed by software which produces information for programming the gate arrays. This step is shown at reference numeral 230. Such software is available from Xilinx, Inc., of San Jose, Calif., and is known as XNF2LCA, APR, and XACT. This processing produces a set of bit stream files which may be directly loaded into the programmable gate arrays. The loading of the files into the programmable gate arrays is disclosed elsewhere herein.\n\nAt step 232, timing analysis is performed. In a presently-preferred embodiment, software known as âMotiveâ, available from Quad Design Technology of Camarillo, Calif., may be used.\n\nIn a presently preferred embodiment, FIGS. 11a-e illustrate how partitioning may be accomplished.\n\nReferring first in FIG. 11a, at step 250, the total number of gate array chips are divided into two equal groups called âbinsâ. Next, at step 252 the fixed resources, which consist of I/O connections, probes to the circuit, VSLI connections, memory, etc., shown in FIG. 1, for example, at reference numerals 24, 20 26 and 28, are placed in appropriate bins which are physically located close to the circuit elements to which they will connect.\n\nNext, at step 254 all blocks in the hierarchical net list with a size greater than 66% of the bin capacity are expanded. This step breaks up large blocks into smaller pieces.\n\nNext, at step 256, all blocks are constructively placed into bins. This process is described in more detail with reference to FIG. 11c.\n\nNext, at step 258, the bin placement is iteratively improved. This process is more clearly described with reference to FIG. 11d.\n\nReferring now to FIG. 11b, the placement by block is iteratively improved at step 260. This procedure is described in detail with reference to FIG. 11e. At step 262, the determination is made whether or not the size of all bins is equal to the size of a chip. If so, the placement is finished and the program terminates. If not, all blocks in the hierarchical net list with a size greater than 33% of the smallest bin presently defined are expanded. First, at step 266, a bin, which this sub-routine has not yet operated on, is selected. Next, at step 268, a determination is made whether the bin size is greater than the chip size. If the bin size is not greater than the chip size, this bin is marked as expanded at step 270. If the bin size is greater than the chip size, the bin is expanded.\n\nFirst, at step 272, all blocks are removed from the bin. Next, at 274 the bin is divided into two bins. The division of bins is accomplished such that bins are multiples of chip sizes. For instance, if a bin is the size of three chips, this step may break the bin into one bin having the size of two chips and one bin having size of one chip.\n\nNext at step 276, the fixed resources which were in the old bin are placed into the two newly-created bins. At 278, the blocks are constructively placed into the new bins. This procedure is described in detail with reference to FIG. 11c. Next, at step 280 these new bins are marked as having been expanded. Next, at step 280 a determination is made whether there are any more unexpanded bins left. If so, the program returns to step 266 and repeats. If not, the placement by bin is iteratively improved at step 282. This routine is described in detail with reference to FIG. 11d. Next, at step 284, the placement by block is iteratively improved as shown with respect to FIG. 11e. After step 284, the program returns to step 262 to determine whether the size of all bins is equal to or greater than the size of the single chip.\n\nReferring now to FIG. 11c, a subroutine which constructively places blocks into bins is disclosed. First, at step 286 the unplaced block with the most connections to already-placed blocks is selected. Next, at step 288 the resultant wire length if the block is placed in each bin is estimated. Next, at step 290 the bin having the lowest estimated wire length and space for the block is picked. Next, at step 292, the block is placed in this selected bin. Next, at step 294, it is determined whether there remain any more unplaced blocks. If not, the subroutine terminates. If so, the routine repeats 286 with respect to one of these unplaced blocks.\n\nReferring now to FIG. 11d, the subroutine for iteratively improving the bin placement is disclosed. First, at step 296, a bin is selected, next, at step 298, it is determined whether the bin size or cutset size is greater than a threshold. The cutset size is equal to the number of connections which traverse bin boundaries. The threshold is based on the available wires which traverse the bin boundaries. In a presently-preferred embodiments the threshold is 80%. Therefore, if greater than 80% of the wires traversing the bin boundaries are used up, the answer is affirmative. If the bin size or cutset size does not exceed the threshold, the decision is made at step 300 whether all bins have been improved. If yes, the subroutine is terminated, if not the subroutine returns to step 296.\n\nIf the bin size or cutset size is greater than the threshold, a block within that bin having the lowest cost to move is picked up at step 302. Choosing which block to move is related to the cutset reduction and size of the block. For example, a relatively small block having a large reduction in cutset size if moved is an ideal candidate to move. On the other hand a large block having a small cutset reduction if moved is less than ideal to move.\n\nNext, at step 304, a better available bin with space is sought. The criteria for selecting this best bin include whether the block fits into the bin, whether adding the block would make the cutset exceed threshold, and whether the bin into which the block is placed, will result in the lowest overall estimated wire length. Next, at step 306, it is determined whether such a bin with space has been found. If a better bin with space has been found, the block is moved to a new bin at 310. If no better bin with any space has been found the unimproved bin having the lowest penalty is selected at step 308 and at step 310 the block is moved to this new bin. The subroutine than returns to step 298.\n\nReferring now to FIG. 11e, the iterative improvement by block subroutine is disclosed. First, at step 312 a block is randomly picked. Next, at step 314, the desired location for that block in a bin is chosen. It is desired to move the block, if at all, towards the direction in which the block has the most connections. The facts which are used to make this determination are the desire to minimize the cutset count and to minimize the estimated wire length. If both of these factors have already been minimized, there is no need to move the block.\n\nAt step 316, the determination is made whether there is enough room in the desired bin to place the block. If not, the block is not moved and it is determined at step 318 whether there are any more unpicked blocks. If not, the routine ends. If so, it returns to step 312 to randomly pick another block. If, at step 316 is has been determined that there is room in the bin for the block, the block is moved to the desired bin at step 320. The routine then continues to step 318 at previously described.\n\nWhile a presently-preferred embodiment of the invention has been disclosed, those of ordinary skill in the art will be enabled to contemplate variations from the information given in this disclosure. Such variations are intended to fall within the scope of the present invention which shall be limited only by the appended claims."
    }
}