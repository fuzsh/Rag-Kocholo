{
    "id": "correct_subsidiary_00051_1",
    "rank": 94,
    "data": {
        "url": "https://patents.google.com/patent/US8612201B2/en",
        "read_more_link": "",
        "language": "en",
        "title": "US8612201B2 - Hardware emulation system having a heterogeneous cluster of processors - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/7b/53/dc/7fe999680007d1/US08612201-20131217-D00000.png",
            "https://patentimages.storage.googleapis.com/f5/e5/70/13f18e0fe8cb76/US08612201-20131217-D00001.png",
            "https://patentimages.storage.googleapis.com/f8/10/b9/3ed4130351722c/US08612201-20131217-D00002.png",
            "https://patentimages.storage.googleapis.com/d1/02/24/3a3a070808bbd6/US08612201-20131217-D00003.png",
            "https://patentimages.storage.googleapis.com/7e/4e/d6/69bf3739238889/US08612201-20131217-D00004.png",
            "https://patentimages.storage.googleapis.com/e2/58/10/59da6f9e841f70/US08612201-20131217-D00005.png",
            "https://patentimages.storage.googleapis.com/de/88/4e/53513e849c8aa1/US08612201-20131217-D00006.png",
            "https://patentimages.storage.googleapis.com/de/2d/21/226335b7348acc/US08612201-20131217-D00007.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2006-04-11T00:00:00",
        "summary": "",
        "meta_description": "A hardware emulation system having a heterogeneous cluster of processors is described. The apparatus for emulating a hardware design comprises a plurality of processors, where each processor performs a different function during an emulation cycle. The method performed by the apparatus comprises using a data fetch processor to retrieve data from a data array, evaluating the retrieved data using the data fetch processor to produce an output bit, supplying the output bit to an intracluster crossbar and using a data store processor to store the output bit in the data array.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US8612201B2/en",
        "text": "Hardware emulation system having a heterogeneous cluster of processors Download PDF\n\nInfo\n\nPublication number\n\nUS8612201B2\n\nUS8612201B2 US11/401,641 US40164106A US8612201B2 US 8612201 B2 US8612201 B2 US 8612201B2 US 40164106 A US40164106 A US 40164106A US 8612201 B2 US8612201 B2 US 8612201B2\n\nAuthority\n\nUS\n\nUnited States\n\nPrior art keywords\n\ndata\n\nmemory\n\ncrossbar\n\nprocessor\n\nintracluster\n\nPrior art date\n\n2006-04-11\n\nLegal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)\n\nActive, expires 2029-09-19\n\nApplication number\n\nUS11/401,641\n\nOther versions\n\nUS20070239422A1 (en\n\nInventor\n\nMikhail Bershteyn\n\nMitchell G. Poplack\n\nBeshara G. Elmufdi\n\nCurrent Assignee (The listed assignees may be inaccurate. Google has not performed a legal analysis and makes no representation or warranty as to the accuracy of the list.)\n\nCadence Design Systems Inc\n\nOriginal Assignee\n\nCadence Design Systems Inc\n\nPriority date (The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed.)\n\n2006-04-11\n\nFiling date\n\n2006-04-11\n\nPublication date\n\n2013-12-17\n\n2006-04-11 Application filed by Cadence Design Systems Inc filed Critical Cadence Design Systems Inc\n\n2006-04-11 Priority to US11/401,641 priority Critical patent/US8612201B2/en\n\n2006-04-11 Assigned to CADENCE DESIGN SYSTEMS, INC. reassignment CADENCE DESIGN SYSTEMS, INC. ASSIGNMENT OF ASSIGNORS INTEREST (SEE DOCUMENT FOR DETAILS). Assignors: ELMUFDI, BESHARA G., POPLACK, MITCHELL G., BERSHTEYN, MIKHAIL\n\n2007-04-11 Priority to JP2007127373A priority patent/JP5136974B2/en\n\n2007-04-11 Priority to EP07007390A priority patent/EP1845462B1/en\n\n2007-10-11 Publication of US20070239422A1 publication Critical patent/US20070239422A1/en\n\n2013-12-17 Application granted granted Critical\n\n2013-12-17 Publication of US8612201B2 publication Critical patent/US8612201B2/en\n\nStatus Active legal-status Critical Current\n\n2029-09-19 Adjusted expiration legal-status Critical\n\nLinks\n\nUSPTO\n\nUSPTO PatentCenter\n\nUSPTO Assignment\n\nEspacenet\n\nGlobal Dossier\n\nDiscuss\n\nImages\n\nClassifications\n\nG—PHYSICS\n\nG06—COMPUTING; CALCULATING OR COUNTING\n\nG06F—ELECTRIC DIGITAL DATA PROCESSING\n\nG06F30/00—Computer-aided design [CAD]\n\nG06F30/30—Circuit design\n\nG06F30/32—Circuit design at the digital level\n\nG06F30/33—Design verification, e.g. functional simulation or model checking\n\nG06F30/3308—Design verification, e.g. functional simulation or model checking using simulation\n\nG06F30/331—Design verification, e.g. functional simulation or model checking using simulation with hardware acceleration, e.g. by using field programmable gate array [FPGA] or emulation\n\nDefinitions\n\nEmbodiments of the present invention generally relate to a processor based hardware emulation system and, more particularly, to a heterogeneous processor based hardware emulation system.\n\nHardware emulators are programmable devices used to verify hardware designs.\n\na common method of hardware design verification is to use processor-based hardware emulators to emulate the design prior to physically manufacturing the integrated circuit(s) of the hardware.\n\nThese processor-based emulators sequentially evaluate combinatorial logic levels, starting at the inputs and proceeding to the outputs. Each pass through the entire set of logic levels is known as a cycle; the evaluation of each individual logic level is known as an emulation step.\n\nHardware emulators allow engineers and hardware designers to test and verify the operation of an integrated circuit, an entire board of integrated circuits, or an entire system without having to first physically fabricate the hardware.\n\nHardware emulators need to improve in efficiency to keep pace with the increased complexity of integrated circuits.\n\nthe speed with which a hardware emulator can emulate an integrated circuit is one of the most important benchmarks of the emulator's efficiency, and also one of the emulator's most important selling factors in the emulator market.\n\nConventional hardware emulators are comprised of identical processors.\n\nthe processors are generally arranged into groups of processors known as clusters.\n\neach processor performs an identical set of functions, i.e., retrieving data from a memory, evaluating the data, and writing the processed result back to the memory.\n\nProcessors address the memory via an instruction word.\n\nthe instruction word is stored in a special instruction memory and contains a read address for the data to be evaluated and a Boolean function table that instructs the processor on how to evaluate the data.\n\nthe processor then stores the produced result back to the same memory location as indicated by the instruction address.\n\nthe amount of memory required by a conventional hardware emulator is directly dependent on the number of processors present in the hardware emulator. Specifically, the hardware emulator must contain a memory that is at least equal to the number of processors multiplied by the depth of the instruction memory. The instruction word must contain several address fields to enable the processor to address any location within the memory. Also, during each instruction execution cycle, each processor must perform numerous energy-consuming read and write accesses to the memory.\n\nthe present invention generally relates to an improved processor-based emulation engine.\n\nthe apparatus for emulating a hardware design comprises a plurality of processors that form at least one heterogeneous cluster of processors, where each processor in a cluster performs a different function during an emulation cycle.\n\nthe method performed by the apparatus comprises using a data fetch processor to retrieve data from a data array, evaluate the retrieved data using the data fetch processor to produce an output bit, supply the output bit to an intracluster crossbar and use a data store processor to store the output bit in the data array.\n\nFIG. 1 is a general overview of a hardware emulation system\n\nFIG. 2 is a block diagram of a hardware emulation chip\n\nFIG. 3 is a block diagram of a heterogeneous cluster of processors\n\nFIG. 4 is a diagram of a data fetch instruction word\n\nFIG. 5 is a diagram of a data store instruction word\n\nFIG. 6 is a diagram of a computation instruction word\n\nFIG. 7 is a flow diagram of a method that can be utilized by one embodiment of the present invention.\n\nFIG. 8 is a diagram of an intercluster communication instruction word\n\nFIG. 9 is a diagram of an external connectivity instruction word\n\nFIG. 10 is a flow diagram of a process utilized by a compiler in accordance with one embodiment of the present invention.\n\nthe present invention is an improved method and apparatus that uses a heterogeneous duster of processors to increase the efficiency of an emulation engine.\n\nAn exemplary emulation engine is disclosed in U.S. Pat. No. 6,618,698 âClustered Processors In An Emulation Engineâ and U.S. Pat. No. 5,551,013 âMultiprocessor For Hardware Emulationâ which are hereby incorporated by reference in their entirety.\n\nFIG. 1 depicts an overview of an emulation system 100 .\n\nthe system comprises a computer workstation 105 , an emulation board 120 and a target system 130 .\n\nthe computer workstation 105 provides emulation support facilities to the emulation board 120 .\n\nthe computer workstation 105 comprises at least one central processing unit (CPU) 106 , support circuits 108 and a memory 110 .\n\nthe CPU 106 may comprise one or more conventionally available microprocessors and/or microcontrollers.\n\nthe support circuits 108 are well known circuits that are used to support the operation of the CPU 106 . These circuits comprise power supplies, clocks, input/output interface circuitry, cache and the like.\n\nMemory 110 may comprise random access memory, read only memory, removable disk memory, flash memory, optical storage and various combinations of these types of memory.\n\nthe memory 110 is sometimes referred to as main memory and may in part be used as cache memory or buffer memory.\n\nthe memory 110 stores various forms of software and files, such as an operating system (OS) 112 , a compiler 114 , and emulation support software 116 .\n\nOS operating system\n\ncompiler 114 compiler 114\n\nemulation support software 116 emulation support software\n\nthe compiler 114 converts a hardware design, e.g., hardware described in VHDL or Verilog, to a sequence of instructions that can be evaluated by the emulation board 120 .\n\nthe computer workstation 105 allows a user to interface with the emulation board 120 , control the emulation process and collect emulation results for analysis.\n\nthe emulation board 120 is composed of individual emulation chips 122 1 to 122 64 (collectively 122 ). Under control of the computer workstation 105 , programming information and data is loaded to the emulation board 120 .\n\nthe emulation board 120 emulates a portion 125 of the target system 130 .\n\nthe portion 125 of the target system 130 may be an integrated circuit, a memory, a processor, or any object or device that can be emulated in a programming language.\n\nPopular emulation programming languages include Verilog and VHDL.\n\nFIG. 2 depicts an expanded view of an emulation chip 122 that is utilized by the emulation board 120 .\n\nthe emulation chip 122 comprises heterogeneous clusters of processors 202 1 to 202 6 (collectively 202 ) capable of communicating with each other via an intercluster crossbar 210 .\n\nEach heterogeneous cluster of processors 202 has at least one input 206 1 to 206 7 and 206 9 to 206 12 (collectively 206 ) and at least one output 208 1 to 208 7 and 208 9 to 208 12 (collectively 208 ).\n\nthe input 206 and output 208 allows the heterogeneous cluster of processors 202 to communicate with other heterogeneous clusters of processors 202 via the intercluster crossbar 210 , other emulation chips via external connectors 212 and 214 , and external hardware 216 .\n\nthe external hardware 216 may be a Very Large Scale Integration (VLSI) circuit, A debugger, a memory, or any combination of hardware and software from which the emulation chip 122 can benefit.\n\nthe emulation chip 122 has input connectors 212 1 to 212 4 (collectively 212 ) for receiving data from other emulation chips and output connectors 214 1 to 214 4 (collectively 214 ), known as chip pads, for supplying data to other emulation chips.\n\nFIG. 3 depicts a block diagram of one of the heterogeneous clusters of processors, 202 3 , depicted in FIG. 2 .\n\nthe cluster 202 3 is defined as heterogeneous because each of the processors 302 / 304 / 306 within the cluster 202 performs a different function.\n\nEach processor 302 / 304 / 306 plays a unique role in the retrieval, evaluation, and storage of data within the duster 202 . For example, only a data fetch processor 302 is capable of retrieving data from a data array 314 and only a data store processor 306 is capable of writing processed data to the data array 314 .\n\nthe duster 202 comprises at least one data fetch processor 302 and its associated data fetch instruction memory 308 , at least one data store processor 304 and its associated data store instruction memory 310 , an intracluster crossbar 300 , a data array 314 , a sequencer 328 , an external communication control 322 and an intercluster memory 320 .\n\nthe cluster 202 also includes a computation processor 306 and its associated computation instruction memory 312 . As shall be discussed below, the computation processor 306 and its memory 312 are optional components.\n\nthe sequencer 328 is connected to the data array 314 , the data fetch instruction memory 308 , data store instruction memory 310 , computation instruction memory 312 , intercluster memory 320 and external communication control 322 .\n\nthe sequencer 328 provides timing information to the cluster 202 , provides sequential write addresses to the data array 314 , and causes the data fetch instruction memory 308 , data store instruction memory 310 and computation instruction memory 312 to sequentially output instruction words (shown in FIG. 4-6 ).\n\nthe instruction words control the operation of their respective processors, i.e., an instruction word produced by the data fetch instruction memory 308 controls the operation of the data fetch processor 302 , an instruction word produced by the data store instruction memory 310 controls the operation of the data store processor 304 , and the instruction word produced by the computation instruction memory controls the operation of the computation processor 306 .\n\nthe sequencer 328 also controls the operation of the intercluster memory 320 and the external communication control 322 by providing sequential instruction addresses to the intercluster memory 320 and external communication control 322 .\n\nthe instruction memories 308 / 310 / 312 store instruction words that are sequentially and repetitively provided to their respective processors 302 / 304 / 306 under the control of the sequencer 328 .\n\nEach increment of the sequencer 328 causes the step value to advance from zero to a predetermined maximum value and corresponds to one design path clock cycle for the emulated design.\n\nthe processors 302 / 304 / 306 are a fundamental component of the emulation engine 120 .\n\nthe processors' primary function is to work together to execute an N-input logical function (where N is an integer) and produce a function bit out during each step of the sequencer 328 .\n\nthe inputs for each logic function can be selected from a variety of sources, including bits stored from a previous operation, or from another one or more processors.\n\nthe resulting function bit out may correspond to any one of: a logic gate output of the emulated design, a register output of the emulated design, a synthesized intermediate logic state, or a control bit generated for the emulation process.\n\neach of the processors are identical to each other and are capable of performing identical functions.\n\neach of the processors 302 / 304 / 306 plays a unique role in the operation of the emulation engine 120 .\n\nthe clusters 202 that form the emulation engine 120 are considered heterogeneous.\n\nthe data fetch processor 302 receives an instruction word from its associated data fetch processor memory 308 .\n\nthe instruction word comprises a read address for a location in the data array 314 .\n\nthe data fetch processor 302 retrieves data from the data array 314 using the read address provided by the instruction word.\n\nthe instruction word also includes an operating instruction for evaluating the data retrieved from the data array 314 .\n\nthe data fetch processor 302 evaluates the data in accordance with the instruction word and produces an output bit.\n\nthe data fetch processor 302 writes the output bit to the intracluster crossbar 300 .\n\nthe data store processor 304 receives an instruction word from its associated data store processor memory 310 .\n\nthe instruction word enables the data store processor 304 to select data from the intracluster crossbar 300 .\n\nthe instruction word also includes an operating instruction for evaluating the data retrieved from the intracluster crossbar 300 .\n\nthe data store processor 304 evaluates the data in accordance with the instruction word and produces an output bit.\n\nthe data store processor 304 writes the output bit back to the intracluster crossbar 300 and to the data array 314 .\n\nthe output bit is stored in the data array 314 at a write address provided by the sequencer 328 . In another embodiment of the invention, the output bit is stored at a write address in the data array 314 that is specified by a field in the data store processor instruction word.\n\nthe computation processor 306 receives an instruction word from its associated computation instruction memory 312 .\n\nthe instruction word enables the computation processor 306 to select data from the intracluster crossbar 300 .\n\nthe instruction word also includes an operating instruction for evaluating the data retrieved from the intracluster crossbar 300 .\n\nthe computation processor 306 evaluates the data in accordance with the instruction word and produces an output bit.\n\nthe computation processor 306 writes the output bit back to the intracluster crossbar 300 .\n\nthe computation processor 306 and its associated computation instruction memory 312 are optional and not necessary for the present invention to function.\n\nthe computation processor 306 cannot address the data array 314 , nor can it write processed data to the data array 314 .\n\nthe computation processor 306 can only address the intracluster crossbar 300 . Therefore, the computation processor 306 and its associated computation instruction memory 312 is not necessary for the operation of the heterogeneous cluster of processors 202 . However, the computation processor 306 increases the amount of data the cluster 202 can evaluate in one instruction cycle.\n\nthe intracluster crossbar 300 enables the processors 302 / 304 / 306 to communicate with each other.\n\nthe processors 302 / 304 / 306 evaluate data and write the output bit to the intracluster crossbar 300 .\n\na processor 302 / 304 / 306 can retrieve the data from the intracluster crossbar 300 without having to retrieve the data from the data array 314 .\n\nthe intracluster crossbar 300 is comprised of at least one multiplexer.\n\nthe intracluster crossbar 300 has an external input 2065 and an external output 208 5 that connects the duster 202 to external hardware 216 ; an external input 206 6 and an external output 208 6 that connects to the intercluster crossbar 210 .\n\nthe intercluster memory 320 stores control bits used to select data from the intercluster crossbar 210 and from intracluster crossbar 300 .\n\nthe sequencer 328 causes the intercluster memory 320 to output âcontrol bitsâ to the intracluster crossbar 300 .\n\nAn output bit is selected using the âcontrol bitsâ provided by the intercluster memory 320 and written to the intercluster crossbar 210 via external output 208 6 .\n\nAnother set of control bits is provided to the intercluster crossbar 210 to select the data acquired into intracluster crossbar 300 via external input 206 6 .\n\nthe external communication control 322 stores âcontrol bitsâ used to select data from the intracluster crossbar 300 .\n\nthe sequencer 328 causes the external communication control 322 to output âcontrol bitsâ to the intracluster crossbar 300 .\n\nAn output bit is selected using the âcontrol bitsâ provided by the external communication control 322 and written to the external hardware 216 via external output 208 .\n\nAnother set of control bits enables the acquisition of data from external hardware 216 into intracluster crossbar 300 via external input 206 5 .\n\nthe operation and timing of the heterogeneous cluster of processors 202 is controlled by the sequencer 328 .\n\nEach increment of the sequencer 328 from zero to the maximal value of the sequencer 328 is known as an emulation step.\n\nthe sequencer 328 causes the instruction memories 308 / 310 / 312 to provide instruction words (shown in FIG. 4-6 ) to their associated processors, 302 / 304 / 306 respectively.\n\nEach emulation step results in data being retrieved from the data array 314 by the data fetch processor 302 , evaluated by the data fetch processor 302 , and then stored back into the data array 314 by the data store processor 304 .\n\nFIG. 4 represents one embodiment of a data fetch instruction word 400 .\n\nthe data fetch instruction word 400 is stored in the data fetch memory 308 .\n\nthe data fetch instruction word 400 comprises a Boolean table function field 402 and a plurality of address fields 404 1 to 404 4 (collectively 404 ).\n\nthe size of the Boolean table function field 402 is determined by two raised to the power of the number of address fields. In the present embodiment there are four address fields 404 i to 404 4 , therefore the Boolean function table field 402 contains sixteen bits. Each address field 404 has 12 bits. Therefore, the total length of the data fetch instruction word 400 is sixty-four bits.\n\nthe data fetch instruction word 400 may be smaller or larger than sixty-four bits.\n\nthe data fetch processor 302 uses the data fetch instruction word 400 to retrieve data from the data array 314 .\n\nthe address fields 404 provide a read address for the data array 314 .\n\nthe data fetch processor 302 evaluates the data supplied by the data array 314 using the Boolean function table field 402 to produce an output bit.\n\nFIG. 5 represents one embodiment of a data store instruction word 500 .\n\nthe data store instruction word 500 is stored in the data store memory 310 .\n\nthe data store instruction word 500 comprises a Boolean table function field 502 and a plurality of computation operand address fields 504 1 to 504 4 (collectively 504 ).\n\nthe Boolean table function field 502 in the data store instruction word 500 contains the same information as Boolean table function field 402 in data fetch instruction word 400 .\n\nthe computation operand address fields 504 are smaller in size than the address fields 404 in the data fetch instruction word 400 because they only need to address the intracluster crossbar (ICCB) 300 and not the full data array 314 .\n\nICCB intracluster crossbar\n\nthe data store processor 304 uses the data store instruction word 500 to retrieve data from the ICCB 300 .\n\nthe address fields 504 provide a read address for the ICCB 300 .\n\nthe data store processor 304 evaluates the data supplied by the ICCB 300 using the Boolean function table field 502 to produce an output bit.\n\nFIG. 6 represents one embodiment of a computation instruction word 600 .\n\nthe computation instruction word 600 is stored in the computation memory 312 .\n\nthe computation instruction word 600 comprises a Boolean table function field 602 and a plurality of computation operand address fields 604 1 to 604 4 (collectively 604 ).\n\nthe Boolean table function field 602 in the computation instruction word 600 contains the same information as Boolean table function field 402 in data fetch instruction word 400 .\n\nthe computation operand address fields 604 are smaller in size than the address fields 404 in the data fetch instruction word 400 because they only need to address the intracluster crossbar (ICCB) 300 and not the full data array 314 .\n\nICCB intracluster crossbar\n\nthe computation processor 306 uses the computation instruction word 600 to retrieve data from the ICCB 300 .\n\nthe address fields 604 provide a read address for the ICCB 300 .\n\nthe computation processor 306 evaluates the data supplied by the ICCB 300 using the Boolean function table field 602 to produce an output bit.\n\nFIG. 7 depicts a flow diagram of a method 700 that details the operation of the heterogeneous cluster of processors 202 in accordance with one embodiment of the present invention.\n\nthe method 700 starts at block 702 and proceeds to block 704 .\n\na sequencer 328 causes a data fetch memory 308 to output a data fetch instruction word 400 to its associated data fetch processor 302 .\n\nthe data fetch processor 302 reads data from a data array 314 using a read address 404 1 - 404 4 supplied by the data fetch instruction word 400 .\n\nthe data fetch processor 302 evaluates the data using a Boolean function table 402 that is a part of the data fetch instruction word 400 .\n\nthe data fetch processor 302 produces a data bit that is a result of the data evaluation and places the bit onto an intracluster crossbar (ICCB) 300 .\n\nthe sequencer 328 causes a data store memory 310 to output a data store instruction word 500 to a data store processor 304 .\n\nthe data store processor 304 reads data from the ICCB 300 using a read address 504 1 - 504 4 supplied by the data store instruction word 500 .\n\nthe data store processor 304 evaluates the data using a Boolean function table 502 that is a part of the data store instruction word 500 .\n\nthe data store processor 304 produces a data bit that is a result of the data evaluation and writes it to the data array 314 .\n\nthe data bit is written to the same address produced by the sequencer 328 from which the data fetch processor 302 retrieved the instruction word. The method ends at block 720 .\n\nFIG. 8 represents one embodiment of an intercluster communication word 800 .\n\nthe intercluster communication word 800 is stored in the intercluster memory 320 .\n\nthe intercluster communication word 800 comprises an acquisition control field 802 and a transmission control field 804 .\n\nthe transmission control field 804 addresses the ICCB 300 and selects data to be transmitted to the intercluster crossbar 210 .\n\nthe intercluster crossbar 210 is comprised of at least one multiplexer.\n\nthe acquisition control field 802 is used to make a selection inside the intercluster crossbar of the bit of data that should be acquired into the ICCB 300 .\n\nthe bit is provided by the ICCB 300 of another heterogeneous cluster of processors 202 within the emulation engine 120 via the intercluster crossbar 210 .\n\nFIG. 9 represents one embodiment of an external connectivity word 900 .\n\nthe external connectivity word 900 is stored in external connectivity memory 322 .\n\nthe external connectivity word 900 includes an acquisition control field 902 and a transmission control field 904 .\n\nthe acquisition control field 902 is only one bit and enables data to be selected from the external hardware 216 .\n\nthe transmission control field 904 is used to select the data and produce an output bit. This output bit is then transmitted to the external hardware 216 .\n\nFIG. 10 depicts a flow diagram of a process 1000 utilized by a compiler (shown in FIG. 1 as 114 ) in accordance with one embodiment of the present invention.\n\nthe compiler 114 translates a design under verification (hardware design) into instructions that can be stored in the instruction memories 308 / 310 / 312 / 320 / 322 and evaluated by the processors 302 / 304 / 306 .\n\nthe process 1000 begins at block 1002 and proceeds through a series of steps to convert the hardware design into a sequence of instructions.\n\nthe compiler employs technology mapping to reduce the variety of arithmetic and logic operations to Boolean functions.\n\nthe number of operands present in the Boolean function cannot exceed a fixed value.\n\nthe number of operands present in the Boolean function are equal to the number of input ports on each processor.\n\nthe Boolean function has a maximum of four operands to match four input ports present on each processor.\n\nthe Boolean functions produced by technology mapping step 1004 are assigned to heterogeneous clusters of processors 202 .\n\nthe compiler attempts to uniformly distribute the Boolean functions between all available heterogeneous clusters of processors 202 and also attempts to minimize the amount of communication between heterogeneous dusters of processors 202 .\n\nthe Boolean functions assigned to each heterogeneous cluster of processors 202 are further assigned to various instruction cycles of the cluster. The compiler must assure the cause-and-effect relationships between the Boolean functions are consistent with the sequences of instruction cycles at which these operations are scheduled.\n\nBoolean function A depends on the evaluation of Boolean function B\n\nBoolean function B must be evaluated in an instruction cycle before function A is evaluated.\n\nthe compiler attempts to minimize the overall number of instruction cycles needed to execute the entire model because the performance of the emulation system 100 is inversely proportional to the number of necessary instruction cycles.\n\nthe Boolean functions assigned to the same instruction cycle in the same cluster are further assigned to processors 302 / 304 / 306 that constitute the duster 202 .\n\nthe compiler is aware that each processor 302 / 304 / 306 in the duster 202 serves a unique purpose. Only data fetch processors 302 are capable of retrieving data from the data array 314 . Only data store processors 304 are capable of writing data to the data array 314 . Data fetch processors 304 can implement the functions that receive their input from outside an identified set of Boolean functions, while data store processors 304 can implement the functions whose output values are consumed outside of the identified set of Boolean functions.\n\nModel saving block 1012 results in a sequence of instructions computed by the compiler in block 1004 to 1010 stored in a persistent form on a medium that can be used conveniently for downloading the instructions into emulation system.\n\nthe methods of such storage on various kinds of media are well known to those skilled in the art.\n\nthe process 1000 ends at block 1014 .\n\nthe compiler must ensure that data is retrieved by the data fetch processor 302 from the data array 314 , evaluated, and then stored back to the data array 314 by a data store processor 306 within one instruction cycle time.\n\nthe compiler must take into account the total propagation delay of a signal through a heterogeneous duster of processors 202 when assigning an instruction to a particular processor 302 / 304 / 306 within the cluster 202 .\n\nthe time for an instruction to execute includes the evaluation time by a particular processor 302 / 304 / 306 , as well as the delay the signal experiences on an intracluster crossbar 300 .\n\nthe total time for an instruction to execute cannot exceed the total time allocated for one emulation step.\n\nstep 1008 Since the ability of compiler to meet this limitation in step 1008 is strongly dependent on the configuration of the set of logic gates identified in steps 1004 and 1006 , in some embodiments of the present invention these steps are executed in cooperative fashion, possibly through several iterations until the desired result is achieved.\n\nthe instruction cycle time may be determined by the best result compiler could achieve in minimizing the propagation delay through a cluster 202 .\n\nthe emulation system 100 can assign different cycle times to different instructions in view of the results calculated by compiler.\n\na benefit of the present invention is that the number of processors present on an emulation board can be increased without a substantial increase in the amount of memory present on the emulation board. Only a portion of the processors on the emulation board require direct access to the memory. The size of the memory is directly dependent upon the number of processors which can read from the memory. A heterogeneous duster of processors, where only certain processors can read from the memory, allows for a total increase of processors on the emulation board because the total amount of memory does not have to correspondingly increase.\n\nLandscapes\n\nEngineering & Computer Science (AREA)\n\nComputer Hardware Design (AREA)\n\nPhysics & Mathematics (AREA)\n\nTheoretical Computer Science (AREA)\n\nEvolutionary Computation (AREA)\n\nGeometry (AREA)\n\nGeneral Engineering & Computer Science (AREA)\n\nGeneral Physics & Mathematics (AREA)\n\nTest And Diagnosis Of Digital Computers (AREA)\n\nDebugging And Monitoring (AREA)\n\nAbstract\n\nA hardware emulation system having a heterogeneous cluster of processors is described. The apparatus for emulating a hardware design comprises a plurality of processors, where each processor performs a different function during an emulation cycle. The method performed by the apparatus comprises using a data fetch processor to retrieve data from a data array, evaluating the retrieved data using the data fetch processor to produce an output bit, supplying the output bit to an intracluster crossbar and using a data store processor to store the output bit in the data array.\n\nDescription\n\nBACKGROUND OF THE INVENTION\n\n1. Field of the Invention\n\nEmbodiments of the present invention generally relate to a processor based hardware emulation system and, more particularly, to a heterogeneous processor based hardware emulation system.\n\n2. Description of the Related Art\n\nHardware emulators are programmable devices used to verify hardware designs. A common method of hardware design verification is to use processor-based hardware emulators to emulate the design prior to physically manufacturing the integrated circuit(s) of the hardware. These processor-based emulators sequentially evaluate combinatorial logic levels, starting at the inputs and proceeding to the outputs. Each pass through the entire set of logic levels is known as a cycle; the evaluation of each individual logic level is known as an emulation step.\n\nAn exemplary hardware emulator is described in commonly assigned U.S. Pat. No. 6,618,698 titled âClustered Processors In An Emulation Engineâ, which is hereby incorporated by reference in its entirety. Hardware emulators allow engineers and hardware designers to test and verify the operation of an integrated circuit, an entire board of integrated circuits, or an entire system without having to first physically fabricate the hardware.\n\nThe complexity and number of logic gates present on an integrated circuit has increased significantly in the past several years. Hardware emulators need to improve in efficiency to keep pace with the increased complexity of integrated circuits. The speed with which a hardware emulator can emulate an integrated circuit is one of the most important benchmarks of the emulator's efficiency, and also one of the emulator's most important selling factors in the emulator market.\n\nConventional hardware emulators are comprised of identical processors. The processors are generally arranged into groups of processors known as clusters. In a conventional hardware emulator, each processor performs an identical set of functions, i.e., retrieving data from a memory, evaluating the data, and writing the processed result back to the memory. Processors address the memory via an instruction word. The instruction word is stored in a special instruction memory and contains a read address for the data to be evaluated and a Boolean function table that instructs the processor on how to evaluate the data. The processor then stores the produced result back to the same memory location as indicated by the instruction address.\n\nThe amount of memory required by a conventional hardware emulator is directly dependent on the number of processors present in the hardware emulator. Specifically, the hardware emulator must contain a memory that is at least equal to the number of processors multiplied by the depth of the instruction memory. The instruction word must contain several address fields to enable the processor to address any location within the memory. Also, during each instruction execution cycle, each processor must perform numerous energy-consuming read and write accesses to the memory.\n\nThus, there is a need in the art for a hardware emulator that contains more processors than a conventional hardware emulator but does not require substantially more memory.\n\nSUMMARY OF THE INVENTION\n\nThe present invention generally relates to an improved processor-based emulation engine. The apparatus for emulating a hardware design comprises a plurality of processors that form at least one heterogeneous cluster of processors, where each processor in a cluster performs a different function during an emulation cycle. The method performed by the apparatus comprises using a data fetch processor to retrieve data from a data array, evaluate the retrieved data using the data fetch processor to produce an output bit, supply the output bit to an intracluster crossbar and use a data store processor to store the output bit in the data array.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nSo that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.\n\nFIG. 1 is a general overview of a hardware emulation system;\n\nFIG. 2 is a block diagram of a hardware emulation chip;\n\nFIG. 3 is a block diagram of a heterogeneous cluster of processors;\n\nFIG. 4 is a diagram of a data fetch instruction word;\n\nFIG. 5 is a diagram of a data store instruction word;\n\nFIG. 6 is a diagram of a computation instruction word;\n\nFIG. 7 is a flow diagram of a method that can be utilized by one embodiment of the present invention;\n\nFIG. 8 is a diagram of an intercluster communication instruction word;\n\nFIG. 9 is a diagram of an external connectivity instruction word; and\n\nFIG. 10 is a flow diagram of a process utilized by a compiler in accordance with one embodiment of the present invention.\n\nDETAILED DESCRIPTION\n\nThe present invention is an improved method and apparatus that uses a heterogeneous duster of processors to increase the efficiency of an emulation engine. An exemplary emulation engine is disclosed in U.S. Pat. No. 6,618,698 âClustered Processors In An Emulation Engineâ and U.S. Pat. No. 5,551,013 âMultiprocessor For Hardware Emulationâ which are hereby incorporated by reference in their entirety.\n\nFIG. 1 depicts an overview of an emulation system 100. The system comprises a computer workstation 105, an emulation board 120 and a target system 130. The computer workstation 105 provides emulation support facilities to the emulation board 120.\n\nThe computer workstation 105 comprises at least one central processing unit (CPU) 106, support circuits 108 and a memory 110. The CPU 106 may comprise one or more conventionally available microprocessors and/or microcontrollers. The support circuits 108 are well known circuits that are used to support the operation of the CPU 106. These circuits comprise power supplies, clocks, input/output interface circuitry, cache and the like.\n\nMemory 110 may comprise random access memory, read only memory, removable disk memory, flash memory, optical storage and various combinations of these types of memory. The memory 110 is sometimes referred to as main memory and may in part be used as cache memory or buffer memory. The memory 110 stores various forms of software and files, such as an operating system (OS) 112, a compiler 114, and emulation support software 116.\n\nThe compiler 114 converts a hardware design, e.g., hardware described in VHDL or Verilog, to a sequence of instructions that can be evaluated by the emulation board 120.\n\nThe computer workstation 105 allows a user to interface with the emulation board 120, control the emulation process and collect emulation results for analysis. The emulation board 120 is composed of individual emulation chips 122 1 to 122 64 (collectively 122). Under control of the computer workstation 105, programming information and data is loaded to the emulation board 120.\n\nIn response to the programming received from the emulation support software 116, the emulation board 120 emulates a portion 125 of the target system 130. The portion 125 of the target system 130 may be an integrated circuit, a memory, a processor, or any object or device that can be emulated in a programming language. Popular emulation programming languages include Verilog and VHDL.\n\nFIG. 2 depicts an expanded view of an emulation chip 122 that is utilized by the emulation board 120. The emulation chip 122 comprises heterogeneous clusters of processors 202 1 to 202 6 (collectively 202) capable of communicating with each other via an intercluster crossbar 210. Each heterogeneous cluster of processors 202 has at least one input 206 1 to 206 7 and 206 9 to 206 12 (collectively 206) and at least one output 208 1 to 208 7 and 208 9 to 208 12 (collectively 208). The input 206 and output 208 allows the heterogeneous cluster of processors 202 to communicate with other heterogeneous clusters of processors 202 via the intercluster crossbar 210, other emulation chips via external connectors 212 and 214, and external hardware 216. The external hardware 216 may be a Very Large Scale Integration (VLSI) circuit, A debugger, a memory, or any combination of hardware and software from which the emulation chip 122 can benefit. The emulation chip 122 has input connectors 212 1 to 212 4 (collectively 212) for receiving data from other emulation chips and output connectors 214 1 to 214 4 (collectively 214), known as chip pads, for supplying data to other emulation chips.\n\nFIG. 3 depicts a block diagram of one of the heterogeneous clusters of processors, 202 3, depicted in FIG. 2. The cluster 202 3 is defined as heterogeneous because each of the processors 302/304/306 within the cluster 202 performs a different function. Each processor 302/304/306 plays a unique role in the retrieval, evaluation, and storage of data within the duster 202. For example, only a data fetch processor 302 is capable of retrieving data from a data array 314 and only a data store processor 306 is capable of writing processed data to the data array 314.\n\nThe duster 202 comprises at least one data fetch processor 302 and its associated data fetch instruction memory 308, at least one data store processor 304 and its associated data store instruction memory 310, an intracluster crossbar 300, a data array 314, a sequencer 328, an external communication control 322 and an intercluster memory 320. The cluster 202 also includes a computation processor 306 and its associated computation instruction memory 312. As shall be discussed below, the computation processor 306 and its memory 312 are optional components.\n\nThe sequencer 328 is connected to the data array 314, the data fetch instruction memory 308, data store instruction memory 310, computation instruction memory 312, intercluster memory 320 and external communication control 322. The sequencer 328 provides timing information to the cluster 202, provides sequential write addresses to the data array 314, and causes the data fetch instruction memory 308, data store instruction memory 310 and computation instruction memory 312 to sequentially output instruction words (shown in FIG. 4-6). The instruction words control the operation of their respective processors, i.e., an instruction word produced by the data fetch instruction memory 308 controls the operation of the data fetch processor 302, an instruction word produced by the data store instruction memory 310 controls the operation of the data store processor 304, and the instruction word produced by the computation instruction memory controls the operation of the computation processor 306. The sequencer 328 also controls the operation of the intercluster memory 320 and the external communication control 322 by providing sequential instruction addresses to the intercluster memory 320 and external communication control 322. The instruction memories 308/310/312 store instruction words that are sequentially and repetitively provided to their respective processors 302/304/306 under the control of the sequencer 328. Each increment of the sequencer 328 causes the step value to advance from zero to a predetermined maximum value and corresponds to one design path clock cycle for the emulated design.\n\nThe processors 302/304/306 are a fundamental component of the emulation engine 120. The processors' primary function is to work together to execute an N-input logical function (where N is an integer) and produce a function bit out during each step of the sequencer 328. The inputs for each logic function can be selected from a variety of sources, including bits stored from a previous operation, or from another one or more processors. The resulting function bit out may correspond to any one of: a logic gate output of the emulated design, a register output of the emulated design, a synthesized intermediate logic state, or a control bit generated for the emulation process. In a conventional emulation engine, each of the processors are identical to each other and are capable of performing identical functions. In the present invention, each of the processors 302/304/306 plays a unique role in the operation of the emulation engine 120. Thus, the clusters 202 that form the emulation engine 120 are considered heterogeneous.\n\nThe data fetch processor 302 receives an instruction word from its associated data fetch processor memory 308. The instruction word comprises a read address for a location in the data array 314. The data fetch processor 302 retrieves data from the data array 314 using the read address provided by the instruction word. The instruction word also includes an operating instruction for evaluating the data retrieved from the data array 314. The data fetch processor 302 evaluates the data in accordance with the instruction word and produces an output bit. The data fetch processor 302 writes the output bit to the intracluster crossbar 300.\n\nThe data store processor 304 receives an instruction word from its associated data store processor memory 310. The instruction word enables the data store processor 304 to select data from the intracluster crossbar 300. The instruction word also includes an operating instruction for evaluating the data retrieved from the intracluster crossbar 300. The data store processor 304 evaluates the data in accordance with the instruction word and produces an output bit. The data store processor 304 writes the output bit back to the intracluster crossbar 300 and to the data array 314. The output bit is stored in the data array 314 at a write address provided by the sequencer 328. In another embodiment of the invention, the output bit is stored at a write address in the data array 314 that is specified by a field in the data store processor instruction word.\n\nThe computation processor 306 receives an instruction word from its associated computation instruction memory 312. The instruction word enables the computation processor 306 to select data from the intracluster crossbar 300. The instruction word also includes an operating instruction for evaluating the data retrieved from the intracluster crossbar 300. The computation processor 306 evaluates the data in accordance with the instruction word and produces an output bit. The computation processor 306 writes the output bit back to the intracluster crossbar 300.\n\nThe computation processor 306 and its associated computation instruction memory 312 are optional and not necessary for the present invention to function. The computation processor 306 cannot address the data array 314, nor can it write processed data to the data array 314. The computation processor 306 can only address the intracluster crossbar 300. Therefore, the computation processor 306 and its associated computation instruction memory 312 is not necessary for the operation of the heterogeneous cluster of processors 202. However, the computation processor 306 increases the amount of data the cluster 202 can evaluate in one instruction cycle.\n\nThe intracluster crossbar 300 enables the processors 302/304/306 to communicate with each other. The processors 302/304/306 evaluate data and write the output bit to the intracluster crossbar 300. A processor 302/304/306 can retrieve the data from the intracluster crossbar 300 without having to retrieve the data from the data array 314. In one embodiment of the invention, the intracluster crossbar 300 is comprised of at least one multiplexer. The intracluster crossbar 300 has an external input 2065 and an external output 208 5 that connects the duster 202 to external hardware 216; an external input 206 6 and an external output 208 6 that connects to the intercluster crossbar 210.\n\nThe intercluster memory 320 stores control bits used to select data from the intercluster crossbar 210 and from intracluster crossbar 300. The sequencer 328 causes the intercluster memory 320 to output âcontrol bitsâ to the intracluster crossbar 300. An output bit is selected using the âcontrol bitsâ provided by the intercluster memory 320 and written to the intercluster crossbar 210 via external output 208 6. Another set of control bits is provided to the intercluster crossbar 210 to select the data acquired into intracluster crossbar 300 via external input 206 6.\n\nThe external communication control 322 stores âcontrol bitsâ used to select data from the intracluster crossbar 300. The sequencer 328 causes the external communication control 322 to output âcontrol bitsâ to the intracluster crossbar 300. An output bit is selected using the âcontrol bitsâ provided by the external communication control 322 and written to the external hardware 216 via external output 208. Another set of control bits enables the acquisition of data from external hardware 216 into intracluster crossbar 300 via external input 206 5.\n\nThe operation and timing of the heterogeneous cluster of processors 202 is controlled by the sequencer 328. Each increment of the sequencer 328 from zero to the maximal value of the sequencer 328 is known as an emulation step. During each emulation step, the sequencer 328 causes the instruction memories 308/310/312 to provide instruction words (shown in FIG. 4-6) to their associated processors, 302/304/306 respectively. Each emulation step results in data being retrieved from the data array 314 by the data fetch processor 302, evaluated by the data fetch processor 302, and then stored back into the data array 314 by the data store processor 304.\n\nFIG. 4 represents one embodiment of a data fetch instruction word 400. The data fetch instruction word 400 is stored in the data fetch memory 308. In one embodiment, the data fetch instruction word 400 comprises a Boolean table function field 402 and a plurality of address fields 404 1 to 404 4 (collectively 404). The size of the Boolean table function field 402 is determined by two raised to the power of the number of address fields. In the present embodiment there are four address fields 404 i to 404 4, therefore the Boolean function table field 402 contains sixteen bits. Each address field 404 has 12 bits. Therefore, the total length of the data fetch instruction word 400 is sixty-four bits. One skilled in the art will appreciate the length of the data fetch instruction word 400 is dependent on the size of the Boolean function table field 402 and the size of the address field 404. The data fetch instruction word 400 may be smaller or larger than sixty-four bits.\n\nThe data fetch processor 302 uses the data fetch instruction word 400 to retrieve data from the data array 314. The address fields 404 provide a read address for the data array 314. The data fetch processor 302 evaluates the data supplied by the data array 314 using the Boolean function table field 402 to produce an output bit.\n\nFIG. 5 represents one embodiment of a data store instruction word 500. The data store instruction word 500 is stored in the data store memory 310. The data store instruction word 500 comprises a Boolean table function field 502 and a plurality of computation operand address fields 504 1 to 504 4 (collectively 504). The Boolean table function field 502 in the data store instruction word 500 contains the same information as Boolean table function field 402 in data fetch instruction word 400. The computation operand address fields 504 are smaller in size than the address fields 404 in the data fetch instruction word 400 because they only need to address the intracluster crossbar (ICCB) 300 and not the full data array 314.\n\nThe data store processor 304 uses the data store instruction word 500 to retrieve data from the ICCB 300. The address fields 504 provide a read address for the ICCB 300. The data store processor 304 evaluates the data supplied by the ICCB 300 using the Boolean function table field 502 to produce an output bit.\n\nFIG. 6 represents one embodiment of a computation instruction word 600. The computation instruction word 600 is stored in the computation memory 312. The computation instruction word 600 comprises a Boolean table function field 602 and a plurality of computation operand address fields 604 1 to 604 4 (collectively 604). The Boolean table function field 602 in the computation instruction word 600 contains the same information as Boolean table function field 402 in data fetch instruction word 400. The computation operand address fields 604 are smaller in size than the address fields 404 in the data fetch instruction word 400 because they only need to address the intracluster crossbar (ICCB) 300 and not the full data array 314.\n\nThe computation processor 306 uses the computation instruction word 600 to retrieve data from the ICCB 300. The address fields 604 provide a read address for the ICCB 300. The computation processor 306 evaluates the data supplied by the ICCB 300 using the Boolean function table field 602 to produce an output bit.\n\nFIG. 7 depicts a flow diagram of a method 700 that details the operation of the heterogeneous cluster of processors 202 in accordance with one embodiment of the present invention. The method 700 starts at block 702 and proceeds to block 704. At block 704, a sequencer 328 causes a data fetch memory 308 to output a data fetch instruction word 400 to its associated data fetch processor 302. At block 706, the data fetch processor 302 reads data from a data array 314 using a read address 404 1-404 4 supplied by the data fetch instruction word 400. At block 708, the data fetch processor 302 evaluates the data using a Boolean function table 402 that is a part of the data fetch instruction word 400.\n\nAt block 710, the data fetch processor 302 produces a data bit that is a result of the data evaluation and places the bit onto an intracluster crossbar (ICCB) 300. At block 712, the sequencer 328 causes a data store memory 310 to output a data store instruction word 500 to a data store processor 304. At block 714, the data store processor 304 reads data from the ICCB 300 using a read address 504 1-504 4 supplied by the data store instruction word 500. At block 716, the data store processor 304 evaluates the data using a Boolean function table 502 that is a part of the data store instruction word 500. At block 718, the data store processor 304 produces a data bit that is a result of the data evaluation and writes it to the data array 314. In one embodiment of the invention, the data bit is written to the same address produced by the sequencer 328 from which the data fetch processor 302 retrieved the instruction word. The method ends at block 720.\n\nFIG. 8 represents one embodiment of an intercluster communication word 800. The intercluster communication word 800 is stored in the intercluster memory 320. The intercluster communication word 800 comprises an acquisition control field 802 and a transmission control field 804. The transmission control field 804 addresses the ICCB 300 and selects data to be transmitted to the intercluster crossbar 210. In one embodiment of the invention, the intercluster crossbar 210 is comprised of at least one multiplexer. The acquisition control field 802 is used to make a selection inside the intercluster crossbar of the bit of data that should be acquired into the ICCB 300. The bit is provided by the ICCB 300 of another heterogeneous cluster of processors 202 within the emulation engine 120 via the intercluster crossbar 210.\n\nFIG. 9 represents one embodiment of an external connectivity word 900. The external connectivity word 900 is stored in external connectivity memory 322. The external connectivity word 900 includes an acquisition control field 902 and a transmission control field 904. In one embodiment, the acquisition control field 902 is only one bit and enables data to be selected from the external hardware 216. The transmission control field 904 is used to select the data and produce an output bit. This output bit is then transmitted to the external hardware 216.\n\nFIG. 10 depicts a flow diagram of a process 1000 utilized by a compiler (shown in FIG. 1 as 114) in accordance with one embodiment of the present invention. The compiler 114 translates a design under verification (hardware design) into instructions that can be stored in the instruction memories 308/310/312/320/322 and evaluated by the processors 302/304/306.\n\nThe process 1000 begins at block 1002 and proceeds through a series of steps to convert the hardware design into a sequence of instructions. At block 1004, the compiler employs technology mapping to reduce the variety of arithmetic and logic operations to Boolean functions. The number of operands present in the Boolean function cannot exceed a fixed value. Generally, the number of operands present in the Boolean function are equal to the number of input ports on each processor. In one embodiment, the Boolean function has a maximum of four operands to match four input ports present on each processor.\n\nAt partitioning block 1006, the Boolean functions produced by technology mapping step 1004 are assigned to heterogeneous clusters of processors 202. The compiler attempts to uniformly distribute the Boolean functions between all available heterogeneous clusters of processors 202 and also attempts to minimize the amount of communication between heterogeneous dusters of processors 202. At instruction scheduling block 1008, the Boolean functions assigned to each heterogeneous cluster of processors 202 are further assigned to various instruction cycles of the cluster. The compiler must assure the cause-and-effect relationships between the Boolean functions are consistent with the sequences of instruction cycles at which these operations are scheduled. For example, if Boolean function A depends on the evaluation of Boolean function B, then Boolean function B must be evaluated in an instruction cycle before function A is evaluated. The compiler attempts to minimize the overall number of instruction cycles needed to execute the entire model because the performance of the emulation system 100 is inversely proportional to the number of necessary instruction cycles.\n\nAt timing-driven intra-duster placement and routing block 1010, the Boolean functions assigned to the same instruction cycle in the same cluster are further assigned to processors 302/304/306 that constitute the duster 202. The compiler is aware that each processor 302/304/306 in the duster 202 serves a unique purpose. Only data fetch processors 302 are capable of retrieving data from the data array 314. Only data store processors 304 are capable of writing data to the data array 314. Data fetch processors 304 can implement the functions that receive their input from outside an identified set of Boolean functions, while data store processors 304 can implement the functions whose output values are consumed outside of the identified set of Boolean functions.\n\nModel saving block 1012 results in a sequence of instructions computed by the compiler in block 1004 to 1010 stored in a persistent form on a medium that can be used conveniently for downloading the instructions into emulation system. The methods of such storage on various kinds of media are well known to those skilled in the art. The process 1000 ends at block 1014.\n\nThe compiler must ensure that data is retrieved by the data fetch processor 302 from the data array 314, evaluated, and then stored back to the data array 314 by a data store processor 306 within one instruction cycle time. The compiler must take into account the total propagation delay of a signal through a heterogeneous duster of processors 202 when assigning an instruction to a particular processor 302/304/306 within the cluster 202. The time for an instruction to execute includes the evaluation time by a particular processor 302/304/306, as well as the delay the signal experiences on an intracluster crossbar 300. The total time for an instruction to execute cannot exceed the total time allocated for one emulation step. Since the ability of compiler to meet this limitation in step 1008 is strongly dependent on the configuration of the set of logic gates identified in steps 1004 and 1006, in some embodiments of the present invention these steps are executed in cooperative fashion, possibly through several iterations until the desired result is achieved.\n\nAs an alternative embodiment of the present invention, the instruction cycle time may be determined by the best result compiler could achieve in minimizing the propagation delay through a cluster 202. As another alternative, the emulation system 100 can assign different cycle times to different instructions in view of the results calculated by compiler.\n\nA benefit of the present invention is that the number of processors present on an emulation board can be increased without a substantial increase in the amount of memory present on the emulation board. Only a portion of the processors on the emulation board require direct access to the memory. The size of the memory is directly dependent upon the number of processors which can read from the memory. A heterogeneous duster of processors, where only certain processors can read from the memory, allows for a total increase of processors on the emulation board because the total amount of memory does not have to correspondingly increase.\n\nWhile the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow.\n\nClaims (13)\n\nThe invention claimed is:\n\n1. An apparatus for emulating a hardware design, comprising:\n\na data array memory;\n\nan intracluster crossbar;\n\na plurality of processors in a heterogeneous cluster coupled to the intracluster crossbar;\n\na data fetch processor of the plurality of processors configured to, within one instruction cycle time,\n\nretrieve data from the data array memory, and\n\nwrite the data to the intracluster crossbar;\n\na data store processor of the plurality of processors configured to, within the one instruction cycle time,\n\nselect the data from the intracluster crossbar, and\n\nstore the data in the data array memory; and\n\nan intercluster memory configured to store control bits used to select the data from the intracluster crossbar and from an intercluster crossbar operatively connected to the intercluster memory.\n\n2. The apparatus of claim 1 further comprising:\n\na data fetch instruction memory coupled to the data fetch processor; and\n\na data store instruction memory coupled to the data store processor.\n\n3. The apparatus of claim 2 further comprising a sequencer configured to provide timing to the data fetch instruction memory, the data store instruction memory and the data array memory.\n\n4. The apparatus of claim 1 wherein the plurality of processors includes a computation processor coupled to the intracluster crossbar.\n\n5. The apparatus of claim 4 further comprising a computation instruction memory coupled to the computation processor.\n\n6. The apparatus of claim 5 further comprising a sequencer configured to provide timing to at least one of the data fetch instruction memory, the data store instruction memory, the data array memory, and the computation instruction memory.\n\n7. The apparatus of claim 1 wherein the intracluster crossbar comprises at least one multiplexer.\n\n8. The apparatus of claim 1 wherein the intracluster crossbar comprises an external connection for communication to at least one external hardware device and an intercluster crossbar connection to an intercluster crossbar.\n\n9. The apparatus of claim 8 further comprising an external communication control configured to provide selected data to the external connection.\n\n10. The apparatus of claim 8 further comprising an intercluster memory configured to provide selected data to the intercluster crossbar connection.\n\n11. A method for emulating a hardware design comprising;\n\nproviding a data array memory, an intracluster crossbar, and a plurality of processors in a heterogeneous cluster, each of the plurality of processors coupled to the data array memory and the intracluster crossbar;\n\nstoring, at an intercluster memory operatively connected to the intracluster crossbar and an intercluster crossbar, one or more control bits used to select data from the intracluster crossbar and from the intercluster crossbar;\n\nconfiguring a data fetch processor of the plurality of processors to retrieve data from the data array memory, and configuring a data store processor of the plurality of processors to store data in the data array memory;\n\nusing the data fetch processor to retrieve data from the data array memory, within one instruction cycle time;\n\nevaluating the retrieved data using at least one of the data fetch processor, a computation processor of the plurality of processors and the data store processor to produce an output bit;\n\nsupplying the output bit to the intracluster crossbar; and\n\nusing the data store processor to store the output bit in the data array memory, within the one instruction cycle time.\n\n12. The method of claim 11 further comprising using, by the data fetch processor, an instruction word supplied by a data fetch memory, wherein the instruction word comprises a read address for accessing data from the data array memory.\n\n13. The method of claim 12 further comprising using, by the data store processor, a second instruction word supplied by a data store memory to store the output bit in the data array memory, wherein the second instruction word comprises a second read address for accessing data from the intracluster crossbar.\n\nUS11/401,641 2006-04-11 2006-04-11 Hardware emulation system having a heterogeneous cluster of processors Active 2029-09-19 US8612201B2 (en)\n\nPriority Applications (3)\n\nApplication Number Priority Date Filing Date Title US11/401,641 US8612201B2 (en) 2006-04-11 2006-04-11 Hardware emulation system having a heterogeneous cluster of processors JP2007127373A JP5136974B2 (en) 2006-04-11 2007-04-11 Hardware emulation system with heterogeneous clusters of processors EP07007390A EP1845462B1 (en) 2006-04-11 2007-04-11 Hardware emulations system for integrated circuits having a heterogeneous cluster of processors\n\nApplications Claiming Priority (1)\n\nApplication Number Priority Date Filing Date Title US11/401,641 US8612201B2 (en) 2006-04-11 2006-04-11 Hardware emulation system having a heterogeneous cluster of processors\n\nPublications (2)\n\nPublication Number Publication Date US20070239422A1 US20070239422A1 (en) 2007-10-11 US8612201B2 true US8612201B2 (en) 2013-12-17\n\nFamily\n\nID=38293237\n\nFamily Applications (1)\n\nApplication Number Title Priority Date Filing Date US11/401,641 Active 2029-09-19 US8612201B2 (en) 2006-04-11 2006-04-11 Hardware emulation system having a heterogeneous cluster of processors\n\nCountry Status (3)\n\nCountry Link US (1) US8612201B2 (en) EP (1) EP1845462B1 (en) JP (1) JP5136974B2 (en)\n\nCited By (2)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US20140325181A1 (en) * 2005-12-22 2014-10-30 Stmicroelectronics S.A. Hierarchical reconfigurable computer architecture RU213487U1 (en) * 2022-04-05 2022-09-13 Ð¤ÐµÐ´ÐµÑÐ°Ð»ÑÐ½Ð¾Ðµ Ð³Ð¾ÑÑÐ´Ð°ÑÑÑÐ²ÐµÐ½Ð½Ð¾Ðµ Ð±ÑÐ´Ð¶ÐµÑÐ½Ð¾Ðµ Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°ÑÐµÐ»ÑÐ½Ð¾Ðµ ÑÑÑÐµÐ¶Ð´ÐµÐ½Ð¸Ðµ Ð²ÑÑÑÐµÐ³Ð¾ Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ \"Ð ÑÐ±Ð¸Ð½ÑÐºÐ¸Ð¹ Ð³Ð¾ÑÑÐ´Ð°ÑÑÑÐ²ÐµÐ½Ð½ÑÐ¹ Ð°Ð²Ð¸Ð°ÑÐ¸Ð¾Ð½Ð½ÑÐ¹ ÑÐµÑ Ð½Ð¸ÑÐµÑÐºÐ¸Ð¹ ÑÐ½Ð¸Ð²ÐµÑÑÐ¸ÑÐµÑ Ð¸Ð¼ÐµÐ½Ð¸ Ð.Ð. Ð¡Ð¾Ð»Ð¾Ð²ÑÐµÐ²Ð°\" HARDWARE EMULATOR OF THE TRAINING STAND WITH A BLOCK OF ADDITIONAL MEMORY\n\nFamilies Citing this family (6)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US7725304B1 (en) * 2006-05-22 2010-05-25 Cadence Design Systems, Inc. Method and apparatus for coupling data between discrete processor based emulation integrated chips JP2010182241A (en) * 2009-02-09 2010-08-19 Fujitsu Ltd Evaluation method and device US8532975B2 (en) * 2009-06-12 2013-09-10 Cadence Design Systems, Inc. System and method implementing a simulation acceleration capture buffer KR101665850B1 (en) * 2015-02-05 2016-10-12 (ì£¼)ì¸ì ë³´ Method for Protecting Program by Using Heterogeneous Processor Emulation US10409624B1 (en) * 2016-03-08 2019-09-10 Cadence Design Systems, Inc. Data array compaction in an emulation system US10990728B1 (en) * 2019-12-19 2021-04-27 Cadence Design Systems, Inc. Functional built-in self-test architecture in an emulation system\n\nCitations (27)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US4674033A (en) * 1983-10-24 1987-06-16 British Telecommunications Public Limited Company Multiprocessor system having a shared memory for enhanced interprocessor communication WO1990004233A1 (en) 1988-10-05 1990-04-19 Mentor Graphics Corporation Method of using electronically reconfigurable gate array logic and apparatus formed thereby US4969117A (en) * 1988-05-16 1990-11-06 Ardent Computer Corporation Chaining and hazard apparatus and method US5233701A (en) * 1988-03-29 1993-08-03 Nec Corporation System for managing interprocessor common memory US5388233A (en) * 1993-04-30 1995-02-07 Intel Corporation Method and apparatus for counting instruction types using bit masks and a programmable bit map US5410723A (en) * 1989-11-21 1995-04-25 Deutsche Itt Industries Gmbh Wavefront array processor for blocking the issuance of first handshake signal (req) by the presence of second handshake signal (ack) which indicates the readyness of the receiving cell US5471593A (en) * 1989-12-11 1995-11-28 Branigin; Michael H. Computer processor with an efficient means of executing many instructions simultaneously US5551013A (en) 1994-06-03 1996-08-27 International Business Machines Corporation Multiprocessor for hardware emulation US5701507A (en) * 1991-12-26 1997-12-23 Texas Instruments Incorporated Architecture of a chip having multiple processors and multiple memories US5721828A (en) * 1993-05-06 1998-02-24 Mercury Computer Systems, Inc. Multicomputer memory access architecture US5761484A (en) 1994-04-01 1998-06-02 Massachusetts Institute Of Technology Virtual interconnections for reconfigurable logic systems EP0849672A2 (en) 1996-12-20 1998-06-24 Texas Instruments Incorporated Non-intrusive software breakpoints in a processor instructions execution pipeline JPH10171847A (en) 1996-10-17 1998-06-26 Quickturn Design Syst Inc Method and device for verifying design by using emulation and simulation US5781921A (en) * 1996-05-06 1998-07-14 Ohmeda Inc. Method and apparatus to effect firmware upgrades using a removable memory device under software control US5802348A (en) 1995-12-18 1998-09-01 Virtual Machine Works, Inc. Logic analysis system for logic emulation systems US5845322A (en) * 1996-09-17 1998-12-01 Vlsi Technology, Inc. Modular scalable multi-processor architecture US6141636A (en) * 1997-03-31 2000-10-31 Quickturn Design Systems, Inc. Logic analysis subsystem in a time-sliced emulator JP2002018819A (en) 2000-06-30 2002-01-22 Kuraoka Gonichi Method for solidifying and working trunk, branch of tree and bamboo with resin US6513057B1 (en) * 1996-10-28 2003-01-28 Unisys Corporation Heterogeneous symmetric multi-processing system US6618698B1 (en) 1999-08-12 2003-09-09 Quickturn Design Systems, Inc. Clustered processors in an emulation engine JP2004246402A (en) 2003-02-10 2004-09-02 Matsushita Electric Ind Co Ltd Method and device for optimizing logical circuit, and device for synthesizing same US20050013705A1 (en) * 2003-07-16 2005-01-20 Keith Farkas Heterogeneous processor core systems for improved throughput US7089538B1 (en) * 2000-09-06 2006-08-08 Quicktum Design Systems, Inc. High speed software driven emulator comprised of a plurality of emulation processors with a method to allow memory read/writes without interrupting the emulation US20070180182A1 (en) * 2006-02-02 2007-08-02 Gostin Gary B System and method for a distributed crossbar network using a plurality of crossbars US7257665B2 (en) * 2003-09-29 2007-08-14 Intel Corporation Branch-aware FIFO for interprocessor data sharing JP2008263323A (en) 2007-04-10 2008-10-30 Toyota Central R&D Labs Inc Communication synchronizing method and communication terminal US7464227B2 (en) * 2002-12-10 2008-12-09 Intel Corporation Method and apparatus for supporting opportunistic sharing in coherent multiprocessors\n\nFamily Cites Families (1)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title JP3394834B2 (en) * 1995-03-20 2003-04-07 å¯å£«éæ ªå¼ä¼ç¤¾ Debugging method for devices that make up a multiprocessor system\n\n2006\n\n2006-04-11 US US11/401,641 patent/US8612201B2/en active Active\n\n2007\n\n2007-04-11 JP JP2007127373A patent/JP5136974B2/en not_active Expired - Fee Related\n\n2007-04-11 EP EP07007390A patent/EP1845462B1/en not_active Expired - Fee Related\n\nPatent Citations (31)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US4674033A (en) * 1983-10-24 1987-06-16 British Telecommunications Public Limited Company Multiprocessor system having a shared memory for enhanced interprocessor communication US5233701A (en) * 1988-03-29 1993-08-03 Nec Corporation System for managing interprocessor common memory US4969117A (en) * 1988-05-16 1990-11-06 Ardent Computer Corporation Chaining and hazard apparatus and method WO1990004233A1 (en) 1988-10-05 1990-04-19 Mentor Graphics Corporation Method of using electronically reconfigurable gate array logic and apparatus formed thereby US5410723A (en) * 1989-11-21 1995-04-25 Deutsche Itt Industries Gmbh Wavefront array processor for blocking the issuance of first handshake signal (req) by the presence of second handshake signal (ack) which indicates the readyness of the receiving cell US5471593A (en) * 1989-12-11 1995-11-28 Branigin; Michael H. Computer processor with an efficient means of executing many instructions simultaneously US5701507A (en) * 1991-12-26 1997-12-23 Texas Instruments Incorporated Architecture of a chip having multiple processors and multiple memories US5388233A (en) * 1993-04-30 1995-02-07 Intel Corporation Method and apparatus for counting instruction types using bit masks and a programmable bit map US5721828A (en) * 1993-05-06 1998-02-24 Mercury Computer Systems, Inc. Multicomputer memory access architecture US5761484A (en) 1994-04-01 1998-06-02 Massachusetts Institute Of Technology Virtual interconnections for reconfigurable logic systems US5551013A (en) 1994-06-03 1996-08-27 International Business Machines Corporation Multiprocessor for hardware emulation US5802348A (en) 1995-12-18 1998-09-01 Virtual Machine Works, Inc. Logic analysis system for logic emulation systems US5781921A (en) * 1996-05-06 1998-07-14 Ohmeda Inc. Method and apparatus to effect firmware upgrades using a removable memory device under software control US5845322A (en) * 1996-09-17 1998-12-01 Vlsi Technology, Inc. Modular scalable multi-processor architecture US5841967A (en) 1996-10-17 1998-11-24 Quickturn Design Systems, Inc. Method and apparatus for design verification using emulation and simulation US6058492A (en) 1996-10-17 2000-05-02 Quickturn Design Systems, Inc. Method and apparatus for design verification using emulation and simulation JPH10171847A (en) 1996-10-17 1998-06-26 Quickturn Design Syst Inc Method and device for verifying design by using emulation and simulation US6513057B1 (en) * 1996-10-28 2003-01-28 Unisys Corporation Heterogeneous symmetric multi-processing system EP0849672A2 (en) 1996-12-20 1998-06-24 Texas Instruments Incorporated Non-intrusive software breakpoints in a processor instructions execution pipeline JPH10326189A (en) 1996-12-20 1998-12-08 Texas Instr Inc <Ti> Non-invasion software break point in processor instruction execution pipeline US6141636A (en) * 1997-03-31 2000-10-31 Quickturn Design Systems, Inc. Logic analysis subsystem in a time-sliced emulator US6618698B1 (en) 1999-08-12 2003-09-09 Quickturn Design Systems, Inc. Clustered processors in an emulation engine JP2002018819A (en) 2000-06-30 2002-01-22 Kuraoka Gonichi Method for solidifying and working trunk, branch of tree and bamboo with resin US7089538B1 (en) * 2000-09-06 2006-08-08 Quicktum Design Systems, Inc. High speed software driven emulator comprised of a plurality of emulation processors with a method to allow memory read/writes without interrupting the emulation US7464227B2 (en) * 2002-12-10 2008-12-09 Intel Corporation Method and apparatus for supporting opportunistic sharing in coherent multiprocessors JP2004246402A (en) 2003-02-10 2004-09-02 Matsushita Electric Ind Co Ltd Method and device for optimizing logical circuit, and device for synthesizing same US7146582B2 (en) 2003-02-10 2006-12-05 Matsushita Electric Industrial Co., Ltd. Logic circuit optimizing method, logic circuit optimizing device and logic circuit composing device US20050013705A1 (en) * 2003-07-16 2005-01-20 Keith Farkas Heterogeneous processor core systems for improved throughput US7257665B2 (en) * 2003-09-29 2007-08-14 Intel Corporation Branch-aware FIFO for interprocessor data sharing US20070180182A1 (en) * 2006-02-02 2007-08-02 Gostin Gary B System and method for a distributed crossbar network using a plurality of crossbars JP2008263323A (en) 2007-04-10 2008-10-30 Toyota Central R&D Labs Inc Communication synchronizing method and communication terminal\n\nNon-Patent Citations (5)\n\n* Cited by examiner, â Cited by third party Title John D. Davis et al., \"A chip prototyping substrate: the flexible architecture for simulation and testing (FAST)\", Sep. 2005, ACM SIGARCH Computer Architecture News, vol. 33, No. 4, pp. 34-43. * M. Morris Mano et al., \"Logic and Computer Design Fundamentals\", 2004, Pearson Prentice Hall, pp. 557-565. * M. Morris Mano, \"Computer System Architecture\", second edition, 1982, Prentice-Hall, pp. 270-327. * N. Jagadish et al., \"An efficient scheme for interprocessor communication using dual-ported RAMs,\" 1989, IEEE Micro, vol. 9, issue 5, pp. 10-19. * Robert J. Gove, \"The multimedia video processor (MVP): a chip architecture for advanced DSP applications,\" 1994, 1994 Sixth IEEE Digital Signal Processing Workshop, pp. 27-30. *\n\nCited By (5)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US20140325181A1 (en) * 2005-12-22 2014-10-30 Stmicroelectronics S.A. Hierarchical reconfigurable computer architecture US9323716B2 (en) * 2005-12-22 2016-04-26 Stmicroelectronics Sa Hierarchical reconfigurable computer architecture RU213487U1 (en) * 2022-04-05 2022-09-13 Ð¤ÐµÐ´ÐµÑÐ°Ð»ÑÐ½Ð¾Ðµ Ð³Ð¾ÑÑÐ´Ð°ÑÑÑÐ²ÐµÐ½Ð½Ð¾Ðµ Ð±ÑÐ´Ð¶ÐµÑÐ½Ð¾Ðµ Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°ÑÐµÐ»ÑÐ½Ð¾Ðµ ÑÑÑÐµÐ¶Ð´ÐµÐ½Ð¸Ðµ Ð²ÑÑÑÐµÐ³Ð¾ Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ \"Ð ÑÐ±Ð¸Ð½ÑÐºÐ¸Ð¹ Ð³Ð¾ÑÑÐ´Ð°ÑÑÑÐ²ÐµÐ½Ð½ÑÐ¹ Ð°Ð²Ð¸Ð°ÑÐ¸Ð¾Ð½Ð½ÑÐ¹ ÑÐµÑ Ð½Ð¸ÑÐµÑÐºÐ¸Ð¹ ÑÐ½Ð¸Ð²ÐµÑÑÐ¸ÑÐµÑ Ð¸Ð¼ÐµÐ½Ð¸ Ð.Ð. Ð¡Ð¾Ð»Ð¾Ð²ÑÐµÐ²Ð°\" HARDWARE EMULATOR OF THE TRAINING STAND WITH A BLOCK OF ADDITIONAL MEMORY RU220601U1 (en) * 2023-06-19 2023-09-25 Ð¤ÐµÐ´ÐµÑÐ°Ð»ÑÐ½Ð¾Ðµ Ð³Ð¾ÑÑÐ´Ð°ÑÑÑÐ²ÐµÐ½Ð½Ð¾Ðµ Ð±ÑÐ´Ð¶ÐµÑÐ½Ð¾Ðµ Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°ÑÐµÐ»ÑÐ½Ð¾Ðµ ÑÑÑÐµÐ¶Ð´ÐµÐ½Ð¸Ðµ Ð²ÑÑÑÐµÐ³Ð¾ Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ \"Ð ÑÐ±Ð¸Ð½ÑÐºÐ¸Ð¹ Ð³Ð¾ÑÑÐ´Ð°ÑÑÑÐ²ÐµÐ½Ð½ÑÐ¹ Ð°Ð²Ð¸Ð°ÑÐ¸Ð¾Ð½Ð½ÑÐ¹ ÑÐµÑ Ð½Ð¸ÑÐµÑÐºÐ¸Ð¹ ÑÐ½Ð¸Ð²ÐµÑÑÐ¸ÑÐµÑ Ð¸Ð¼ÐµÐ½Ð¸ Ð.Ð. Ð¡Ð¾Ð»Ð¾Ð²ÑÐµÐ²Ð°\" HARDWARE EMULATOR OF A TRAINING STAND WITH ANALOG INFORMATION PROCESSING UNIT RU226464U1 (en) * 2024-03-13 2024-06-05 Ð¤ÐµÐ´ÐµÑÐ°Ð»ÑÐ½Ð¾Ðµ Ð³Ð¾ÑÑÐ´Ð°ÑÑÑÐ²ÐµÐ½Ð½Ð¾Ðµ Ð±ÑÐ´Ð¶ÐµÑÐ½Ð¾Ðµ Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°ÑÐµÐ»ÑÐ½Ð¾Ðµ ÑÑÑÐµÐ¶Ð´ÐµÐ½Ð¸Ðµ Ð²ÑÑÑÐµÐ³Ð¾ Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ \"Ð ÑÐ±Ð¸Ð½ÑÐºÐ¸Ð¹ Ð³Ð¾ÑÑÐ´Ð°ÑÑÑÐ²ÐµÐ½Ð½ÑÐ¹ Ð°Ð²Ð¸Ð°ÑÐ¸Ð¾Ð½Ð½ÑÐ¹ ÑÐµÑ Ð½Ð¸ÑÐµÑÐºÐ¸Ð¹ ÑÐ½Ð¸Ð²ÐµÑÑÐ¸ÑÐµÑ Ð¸Ð¼ÐµÐ½Ð¸ Ð.Ð. Ð¡Ð¾Ð»Ð¾Ð²ÑÐµÐ²Ð°\" Hardware emulator of a training stand with a mathematical coprocessor block\n\nAlso Published As\n\nPublication number Publication date JP2007293871A (en) 2007-11-08 JP5136974B2 (en) 2013-02-06 US20070239422A1 (en) 2007-10-11 EP1845462B1 (en) 2012-01-25 EP1845462A1 (en) 2007-10-17\n\nSimilar Documents\n\nPublication Publication Date Title US8612201B2 (en) 2013-12-17 Hardware emulation system having a heterogeneous cluster of processors Rogers et al. 2020 gem5-salam: A system architecture for llvm-based accelerator modeling Biancolin et al. 2019 FASED: FPGA-accelerated simulation and evaluation of DRAM US9298866B1 (en) 2016-03-29 Method and system for modeling a flip-flop of a user design US7904288B1 (en) 2011-03-08 Hardware emulator having a variable input emulation group US9171111B1 (en) 2015-10-27 Hardware emulation method and system using a port time shift register US8706469B2 (en) 2014-04-22 Method and apparatus for increasing the efficiency of an emulation engine US8027828B2 (en) 2011-09-27 Method and apparatus for synchronizing processors in a hardware emulation system US7606698B1 (en) 2009-10-20 Method and apparatus for sharing data between discrete clusters of processors US7827023B2 (en) 2010-11-02 Method and apparatus for increasing the efficiency of an emulation engine US8090568B2 (en) 2012-01-03 Hardware emulator having a variable input primitive US7725304B1 (en) 2010-05-25 Method and apparatus for coupling data between discrete processor based emulation integrated chips US8160862B1 (en) 2012-04-17 Method and apparatus for controlling power in an emulation system US7908465B1 (en) 2011-03-15 Hardware emulator having a selectable write-back processor unit Hadizadeh et al. 2017 Parallel processor architecture with a new algorithm for simultaneous processing of mips-based series instructions JP2006268873A (en) 2006-10-05 Hardware acceleration system for functional simulation Davis et al. 2005 A chip prototyping substrate: the flexible architecture for simulation and testing (fast) Bekker et al. 2019 Performance analysis of standalone and in-fpga LEON3 processors for use in deep space missions US7729897B2 (en) 2010-06-01 Time multiplexed interface for emulator system Min et al. 2011 Realizing cycle accurate processor memory simulation via interface abstraction Denneau et al. 1983 Design and implementation of a software simulation engine US8468009B1 (en) 2013-06-18 Hardware emulation unit having a shadow processor Gong et al. 2005 Storage assignment during high-level synthesis for configurable architectures Chowdhury 2016 AnyCore: Design, Fabrication, and Evaluation of Comprehensively Adaptive Superscalar Processors Lu 2023 FSSD-DPR: FPGA-based emulation framework for solid-state drives with dynamic parameter-based reconfiguration\n\nLegal Events\n\nDate Code Title Description"
    }
}