{
    "id": "correct_subsidiary_00105_2",
    "rank": 77,
    "data": {
        "url": "https://www.infoworld.com/article/2076339/locating-corba-objects-using-java-idl.html",
        "read_more_link": "",
        "language": "en",
        "title": "Locating CORBA objects using Java IDL",
        "top_image": "https://www.infoworld.com/wp-content/themes/iw-b2b-child-theme/src/static/img/favicon-32x32.png",
        "meta_img": "https://www.infoworld.com/wp-content/themes/iw-b2b-child-theme/src/static/img/favicon-32x32.png",
        "images": [
            "https://images.techhive.com/images/idge/imported/article/jvw/1999/02/stringification-100157869-orig.gif?auto=webp&quality=85,70",
            "https://images.techhive.com/images/idge/imported/article/jvw/1999/02/naming-hier-100157870-orig.gif?auto=webp&quality=85,70",
            "https://www.infoworld.com/wp-content/uploads/2024/07/2968930-0-98724100-1721690569-shutterstock_2212948463.jpg?quality=50&strip=all&w=375",
            "https://www.infoworld.com/wp-content/uploads/2024/07/2518084-0-22615100-1721637053-shutterstock_2300601069.jpg?quality=50&strip=all&w=375",
            "https://www.infoworld.com/wp-content/uploads/2024/07/2520817-0-84992100-1721687889-shutterstock_339205646-100946977-orig.jpg?quality=50&strip=all&w=375",
            "https://www.infoworld.com/wp-content/uploads/2024/07/Youtube-Thumbnails_Template-OLD-1.png?w=444",
            "https://www.infoworld.com/wp-content/uploads/2024/06/youtube-thumbnails_template-old-100963211-orig.jpg?quality=50&strip=all&w=444",
            "https://www.infoworld.com/wp-content/uploads/2024/06/youtube-thumbnails_template-old-100963201-orig.jpg?quality=50&strip=all&w=444"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "and Andy Krumel"
        ],
        "publish_date": "1999-02-01T03:00:00-05:00",
        "summary": "",
        "meta_description": "Implementing CORBA objects is no trivial matter. In fact, it's a\nfeat worthy of a round of high fives. Once the celebration subsides\nand everyone has left your cube suitably impressed with your coding\ntalents, you must figure out how to publish your new object so that\nany computer on the enterprise can easily locate it. What\nelse would you use but a naming service? \n\nIn this month's Enterprise Java column, Andy\nKrumel examines the naming facilities specified in the CORBA\nstandard and several proprietary extensions implemented by CORBA\nvendors. (4,000 words)\n\n Note: This article assumes you have an understanding of the\nCORBA standard and CORBA IDL. A link to a CORBA tutorial is\nprovided at the end of the article. :END_SUMMARY",
        "meta_lang": "en",
        "meta_favicon": "https://www.infoworld.com/wp-content/themes/iw-b2b-child-theme/src/static/img/favicon.ico",
        "meta_site_name": "InfoWorld",
        "canonical_link": "https://www.infoworld.com/article/2162976/locating-corba-objects-using-java-idl.html",
        "text": "One of the longest weeks in my programming career was the one I spent attempting to combine a CORBA object implemented using Visigenic’s VisiBroker for Java with a client using JDK 1.2 beta 2.\n\nObviously, this was a while ago since Java 2 was released very recently and Visigenic subsequently has been swallowed by Borland, which morphed into Inprise. Anyway, ever the one who likes to stick to standard protocols and APIs, I originally implemented the server and client applications using the Java IDL API integrated into the JDK. Playing safe, the server and client relied on the standard CORBA naming service for locating the CORBA object. All went according to schedule until the server’s default Java IDL ORB was replaced with Visigenic’s ORB. If I used the VisiBroker Naming Service implementation, the client could not locate the naming service, and if I used the Java IDL implementation, the server could not locate the naming service. Pow— instant headache!\n\nHad I finally been let down by open standards? Had IIOP really not made it possible for multiple ORBs to interoperate? Yes and No turned out to be the respective answers to those questions. As usual, the Templar Knight in me ran off to do battle without first stopping to read the specification’s fine print or performing adequate prototyping. A little food, sleep and research quickly solved the problem once all possible hacking (and I, myself) was exhausted.\n\npackage ior; import org.omg.CosNaming.*; import org.omg.CORBA.ORB; import org.omg.CosNaming.NamingContextPackage.CannotProceed; import org.omg.CosNaming.NamingContextPackage.NotFound; import ior.*; public class NamingClient { public static void main(String args[]) throws NotFound, CannotProceed, org.omg.CORBA.ORBPackage.InvalidName, org.omg.CosNaming.NamingContextPackage.InvalidName { NamingContext ncRef = //get initial context here //create the naming path NameComponent name[] = { new NameComponent(\"simple\", \"\"), new NameComponent(\"object\", \"\") }; //resolve the path to a reference org.omg.CORBA.Object ref; SimpleObject obj; ref = ncRef.resolve(name); obj = SimpleObjectHelper.narrow(ref); //invoke methods obj.invoke(); } }\n\nIn a filesystem, concatenating the parent directory names and the filename together using a slash (this picks your direction) forms the path to a file. When using the naming service, the path to the object is formed using a sequence of NameComponent instances, where each NameComponent represents a binding within the naming hierarchy. Each NameComponent contains two strings: id and kind. The naming service does not use these strings except to ensure that each id is unique within the specified context. The id specifies the key value for the binding, while the kind provides a description (usually an empty string).\n\nBinding an object\n\nThe following server-side code publishes the object retrieved in the previous example. Thus, it publishes a ior.SimpleObject implementation to the simple-object name within the naming service:\n\nNamingContext ncRef = //get initial context here NamingContext simpleCxt; NameComponent simpleName[] = { new NameComponent(\"simple\", \"\") }; simpleCxt = ncRef.new_context(); try { ncRef.bind_context(simpleName, simpleCxt); } catch(AlreadyBound ex) { //already bound so resolve to it instead objRef = ncRef.resolve(simpleName); simpleCxt = NamingContextHelper.narrow(objRef); } //export the object to the naming service NameComponent objName[] = { new NameComponent(\"object\", \"\") }; simpleCxt.rebind(objName, obj); //block to prevent program from ending and wait for client requests System.out.println(\"Ready for client simple requests...\");\n\nThis example uses a compound name that requires a little care. A real naming service implementation will support persistent names, which means a context can remain in existence long after the registered object has been removed from the name space. Your object registration code needs to handle the cases in which a parent naming context may or may not currently exist, and preserve all bindings if it does exist.\n\nThis example uses exception handling to efficiently handle both cases. The code assumes the simple context is not currently bound to the initial naming context and proceeds as follows:\n\nThe application creates a one-element NameComponent array for the simple naming context binding.\n\nThe application creates a new, unbound naming context by invoking the new_context() method on the root naming context. A NamingContext instance can only be created using another NamingContext.\n\nThe new NamingContext is bound to the root naming context under the name simple using the bind_context() method.\n\nIf a context is already bound to the simple name, the NamingContext bind_context() method generates an org.omg.CosNaming.CosNamingPackage.AlreadBound exception. Anticipating this problem, the program catches this exception (if it occurs) and resolves the existing context using resolve(), just like resolving a normal object.\n\nOnce the simple naming context is obtained from the naming service, a NameComponent array is built and bound using the NamingContext rebind() method.\n\nNotice how NamingContext objects are published using the bind_context() method while all other CORBA objects are published using the bind() or rebind() methods. A NamingContext can be published using a bind() method, but it will not be usable as a naming context binding with the naming service.\n\nOther naming approaches\n\nIf using an IOR is too crude and the COS Naming Service is too cumbersome, you may want to investigate the Java Naming and Directory Service (JNDI) or the Inprise Web Naming Service. JNDI provides a generic API for directory and naming services. The current incarnation of JNDI (as of mid-January) contains a beta implementation of a COS Naming Service provider. This provider enables you to bind, list, and resolve bindings using the standard JNDI API, which can be much more simple and elegant than using the standard org.omg.CosNaming package.\n\nThe Inprise Web Naming Service uses a Web server to manage and publish CORBA object IORs. This makes obtaining references as easy as specifying a URL and could potentially solve the problem of obtaining the initial naming context reference.\n\nBoth Inprise and Iona provide proprietary naming facilities through the use of binding an object to a name at the time of object construction. The name bindings are broadcast across the network through a proprietary communication scheme to all properly configured ORBs. The end result is a very easy-to-use naming service implementation in which the client application uses a single, lightweight bind() method to resolve to a specific object.\n\nThe limitations of this type of naming scheme are:\n\nClient hosts must be properly configured to receive binding broadcast notifications.\n\nAn object can be bound to a single name only.\n\nProprietary schemes will not work when using multiple-ORB implementations. This situation can occur when using ORBs built into commercial products such as Web browsers, database servers, and application servers along with your custom applications written using your company’s standard ORB — not to mention the combinations that result when integrating with your suppliers and customers.\n\nConclusion\n\nCORBA provides two standard mechanisms for enabling client programs to obtain servant references: IORs and the COS Naming Service. As is normally the case with open standards, software vendors have developed additional naming service implementations. Choosing a naming service for your applications will depend on ORB vendor(s), network topology, existing company software architecture standards, and your level of aversion to “proprietary standards.”\n\nThis article discussed four object reference resolution mechanisms:\n\nIOR — The only mechanism that is truly ORB-independent\n\nCOS Naming Service — Provides scalability and robustness\n\nInprise Web Naming Service — Uses a familiar naming convention (URLs) to publish and resolve references; potentially ORB-independent\n\nProprietary ORB naming services — Provides a simple-to-program, robust naming solution\n\nGood luck locating the object of your dreams.\n\nAndy Krumel graduated from the US Naval Academy and started his career as a naval aviator. However, after a series of engine fires, radio failures, and assorted other mishaps, a career in computer programming looked more long-lived. Today, Andy is the founder of K&A Software, a rapidly growing, three-year-old Silicon Valley training and consulting firm specializing in Java and distributed applications. Andy and his cohorts will do just about anything to spread the word about Java’s fantastic capabilities, from speaking at conferences, to teaching corporate training classes, to even writing an occasional article. When not pontificating, Andy is squirreled away creating solutions for one of K&A’s corporate clients."
    }
}