{
    "id": "dbpedia_3610_3",
    "rank": 82,
    "data": {
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped",
        "read_more_link": "",
        "language": "en",
        "title": "DefinitelyTyped/DefinitelyTyped: The repository for high quality TypeScript type definitions.",
        "top_image": "https://opengraph.githubassets.com/57df3f37dd73cf80e78932e4d470825e6ba88c42572d46ab627f5a0989a0382b/DefinitelyTyped/DefinitelyTyped",
        "meta_img": "https://opengraph.githubassets.com/57df3f37dd73cf80e78932e4d470825e6ba88c42572d46ab627f5a0989a0382b/DefinitelyTyped/DefinitelyTyped",
        "images": [
            "https://github.com/DefinitelyTyped/DefinitelyTyped/actions/workflows/CI.yml/badge.svg?branch=master&event=push",
            "https://github.com/DefinitelyTyped/DefinitelyTyped/actions/workflows/CI.yml/badge.svg?branch=master&event=schedule",
            "https://github.com/DefinitelyTyped/DefinitelyTyped/actions/workflows/watchdog-publisher.yml/badge.svg",
            "https://github.com/DefinitelyTyped/DefinitelyTyped/actions/workflows/watchdog-typescript-bot.yml/badge.svg",
            "https://user-images.githubusercontent.com/30049719/228748963-56fabfd1-9101-42c2-9891-b586b775b01e.png",
            "https://github.com/DefinitelyTyped/DefinitelyTyped/raw/master/docs/support-window.svg#gh-light-mode-only",
            "https://github.com/DefinitelyTyped/DefinitelyTyped/raw/master/docs/support-window.svg#gh-dark-mode-only",
            "https://github.com/microsoft/DefinitelyTyped-tools/tree/main/packages/mergebot/docs/dt-mergebot-lifecycle.svg",
            "https://avatars.githubusercontent.com/u/128720388?s=64&v=4",
            "https://avatars.githubusercontent.com/u/45424539?s=64&v=4",
            "https://avatars.githubusercontent.com/u/104224887?s=64&v=4",
            "https://avatars.githubusercontent.com/u/109822601?s=64&v=4",
            "https://avatars.githubusercontent.com/u/172062471?s=64&v=4",
            "https://avatars.githubusercontent.com/u/24265352?s=64&v=4",
            "https://avatars.githubusercontent.com/u/166770154?s=64&v=4",
            "https://avatars.githubusercontent.com/u/102552192?s=64&v=4",
            "https://avatars.githubusercontent.com/u/125332?s=64&v=4",
            "https://avatars.githubusercontent.com/u/293473?s=64&v=4",
            "https://avatars.githubusercontent.com/u/972891?s=64&v=4",
            "https://avatars.githubusercontent.com/u/14539?s=64&v=4",
            "https://avatars.githubusercontent.com/u/4807083?s=64&v=4",
            "https://avatars.githubusercontent.com/u/16928427?s=64&v=4",
            "https://avatars.githubusercontent.com/u/9092011?s=64&v=4",
            "https://avatars.githubusercontent.com/u/32570?s=64&v=4",
            "https://avatars.githubusercontent.com/u/5273975?s=64&v=4",
            "https://avatars.githubusercontent.com/u/13305542?s=64&v=4",
            "https://avatars.githubusercontent.com/u/867242?s=64&v=4",
            "https://avatars.githubusercontent.com/u/12292047?s=64&v=4",
            "https://avatars.githubusercontent.com/u/874898?s=64&v=4",
            "https://avatars.githubusercontent.com/u/78493?s=64&v=4"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "The repository for high quality TypeScript type definitions. - DefinitelyTyped/DefinitelyTyped",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/DefinitelyTyped/DefinitelyTyped",
        "text": "The repository for high quality TypeScript type definitions.\n\nYou can also read this README in Español, 한국어, Русский, 简体中文, Português, Italiano, 日本語 and Français!\n\nLink to Admin manual\n\nDefinitely Typed has recently changed to a proper pnpm monorepo; you may want to reread this document for changes to the layout of packages in this repo.\n\nAt the very least, you may want to git clean -fdx the repo (or node ./scripts/clean-node-modules.js on Windows) to clean up node_modules and run pnpm install --filter . to install the workspace root. See further sections for more info on pnpm install.\n\nThis section tracks the health of the repository and publishing process. It may be helpful for contributors experiencing any issues with their PRs and packages.\n\nMost recent build type-checked/linted cleanly:\n\nAll packages are type-checking/linting cleanly:\n\nAll packages are being published to npm in under an hour and a half:\n\ntypescript-bot has been active on Definitely Typed\n\nCurrent infrastructure status updates\n\nIf anything here seems wrong or any of the above are failing, please let us know in the Definitely Typed channel on the TypeScript Community Discord server.\n\nSee the TypeScript handbook.\n\nThis is the preferred method. For example:\n\nnpm install --save-dev @types/node\n\nTo install typings for a scoped module, remove the @ and add double-underscore after the scope. For example, to install typings for @babel/preset-env:\n\nnpm install --save-dev @types/babel__preset-env\n\nThe types should then be automatically included by the compiler. You may need to add a types reference if you're not using modules:\n\nSee more in the handbook.\n\nFor an npm package \"foo\", typings for it will be at \"@types/foo\".\n\nIf your package has typings specified using the types or typings key in its package.json, the npm registry will display that the package has available bindings like so:\n\nIf you still can't find the typings, just look for any \".d.ts\" files in the package and manually include them with a /// <reference path=\"\" />.\n\nDefinitely Typed only tests packages on versions of TypeScript that are less than 2 years old.\n\nOlder versions of TypeScript\n\n@types packages have tags for versions of TypeScript that they explicitly support, so you can usually get older versions of packages that predate the 2-year window. For example, if you run npm dist-tags @types/react, you'll see that TypeScript 2.5 can use types for react@16.0, whereas TypeScript 2.6 and 2.7 can use types for react@16.4:\n\nTag Version latest 16.9.23 ts2.0 15.0.1 ... ... ts2.5 16.0.36 ts2.6 16.4.7 ts2.7 16.4.7 ... ...\n\nTypeScript 1.*\n\nManually download from the master branch of this repository and place them in your project\n\nTypings (use preferred alternatives, typings is deprecated)\n\nNuGet (use preferred alternatives, nuget DT type publishing has been turned off)\n\nYou may need to add manual references.\n\nDefinitely Typed only works because of contributions by users like you!\n\nBefore you share your improvement with the world, use the types yourself by creating a typename.d.ts file in your project and filling out its exports:\n\nYou can edit the types directly in node_modules/@types/foo/index.d.ts to validate your changes, then bring the changes to this repo with the steps below.\n\nAlternatively, you can use module augmentation to extend existing types from the DT module or use the declare module technique above which will override the version in node_modules.\n\nAdd to your tsconfig.json:\n\nCreate types/foo/index.d.ts containing declarations for the module \"foo\". You should now be able to import from \"foo\" in your code and it will route to the new type definition. Then build and run the code to make sure your type definition actually corresponds to what happens at runtime.\n\nOnce you've tested your definitions with real code, make a PR then follow the instructions to edit an existing package or create a new package.\n\nOnce you've tested your package, you can share it on Definitely Typed.\n\nFirst, fork this repository, clone it, install node and run pnpm install. Note that pnpm install will install the entire repository, including packages you may not be editing. If you'd like to install only a subset, you can run pnpm install -w --filter \"{./types/foo}...\" to install @types/foo and all of its dependencies. If you need to run tests for packages that depend on @types/foo, you can run pnpm install -w --filter \"...{./types/foo}...\" to pull in all related packages for testing.\n\nWe use a bot to let a large number of pull requests to DefinitelyTyped be handled entirely in a self-service manner. You can read more about why and how here. Here is a handy reference showing the life cycle of a pull request to DT:\n\nYou can clone the entire repository as per usual, but it's large and includes a massive directory of type packages.\n\nYou can clone the entire repository as per usual, but it's large and includes a massive directory of type packages. This will take some time to clone and may be unnecessarily unwieldy.\n\nFor a more manageable clone that includes only the type packages relevant to you, you can use git's sparse-checkout and --filter features. This will reduce clone time and improve git performance.\n\n⚠️ This requires minimum git version 2.27.0, which is likely newer than the default on most machines. More complicated procedures are available in older versions, but not covered by this guide.\n\ngit clone --sparse --filter=blob:none <forkedUrl>\n\n--sparse initializes the sparse-checkout file so the working directory starts with only the files in the root of the repository.\n\n--filter=blob:none will including all commit history but exclude files, fetching them only as needed.\n\ngit sparse-checkout add types/<type> types/<dependency-type> ...\n\nMake changes. Remember to edit tests. If you make breaking changes, do not forget to update a major version.\n\nRun pnpm test <package to test>.\n\nWhen you make a PR to edit an existing package, dt-bot should @-mention the package's owners. If it doesn't, you can do so yourself in the comment associated with the PR.\n\nIf you are the library author and your package is written in TypeScript, bundle the generated declaration files in your package instead of publishing to Definitely Typed. You can also generate declaration files from JavaScript files, using JSDoc for type annotations.\n\nIf you are adding typings for an npm package, create a directory with the same name. If the package you are adding typings for is not on npm, make sure the name you choose for it does not conflict with the name of a package on npm. (You can use npm info <my-package> to check for the existence of the <my-package> package.)\n\nYour package should have this structure:\n\nFile Purpose index.d.ts This contains the typings for the package. <my-package>-tests.ts This contains sample code which tests the typings. This code does not run, but it is type-checked. tsconfig.json This allows you to run tsc within the package. .eslintrc.json (Rarely) Needed only to disable lint rules written for eslint. package.json Contains metadata for the package, including its name, version and dependencies. .npmignore Specifies which files are intended to be included in the package.\n\nGenerate these by running npx dts-gen --dt --name <my-package> --template module. See all options at dts-gen.\n\nIf you have .d.ts files besides index.d.ts, make sure that they are referenced either in index.d.ts or the tests.\n\nDefinitely Typed members routinely monitor for new PRs, though keep in mind that the number of other PRs may slow things down.\n\nFor a good example package, see base64-js.\n\nWhen a package bundles its own types, types should be removed from Definitely Typed to avoid confusion.\n\nYou can remove it by running pnpm run not-needed <typingsPackageName> <asOfVersion> [<libraryName>].\n\n<typingsPackageName>: This is the name of the directory to delete.\n\n<asOfVersion>: A stub will be published to @types/<typingsPackageName> with this version. Should be higher than any currently published version and should be a version of <libraryName> on npm.\n\n<libraryName>: Name of npm package that replaces the Definitely Typed types. Usually this is identical to <typingsPackageName>, in which case you can omit it.\n\nIf a package was never on Definitely Typed, it does not need to be added to notNeededPackages.json.\n\nTest your changes by running pnpm test <package to test> where <package to test> is the name of your package. You need to run this from the DefinitelyTyped directory because individual package.jsons don't define test scripts.\n\nThis script uses dtslint to run the TypeScript compiler against your dts files.\n\nOnce you have all your changes ready, use pnpm run test-all to see how your changes affect other modules.\n\ndtslint includes module format and package.json configuration checks from @arethetypeswrong/cli. The checks run only if a SemVer-major-compatible implementation package can be found on npm to compare against the DefinitelyTyped package. (DefinitelyTyped packages marked as nonNpm in their package.json are skipped.)\n\nMany packages currently fail the attw checks and need to be fixed. To allow us to make incremental progress, failed attw checks do not fail the dtslint run when the package is listed in failingPackages in attw.json, but they will still be reported in the pnpm test my-package output. If you fix the package, remove it from failingPackages so that attw checks can start failing dtslint runs.\n\nAll problems reported by attw have documentation linked in the output. Some rules of thumb to help avoid problems:\n\nThe package.json in the DefinitelyTyped package must have matching type and exports fields if the implementation package uses them in its package.json. For example, if an implementation package.json looks like:\n\n{ \"name\": \"my-package\", \"version\": \"1.0.1\", \"type\": \"module\", \"main\": \"dist/cjs/index.cjs\", \"exports\": { \".\": { \"import\": \"./dist/esm/index.js\", \"require\": \"./dist/cjs/index.cjs\" }, \"./subpath\": { \"import\": \"./dist/esm/subpath.js\", \"require\": \"./dist/cjs/subpath.cjs\" } } }\n\nthen the DefinitelyTyped package.json should look something like:\n\n{ \"name\": \"@types/my-package\", \"version\": \"1.0.9999\", \"type\": \"module\", \"types\": \"index.d.ts\", \"exports\": { \".\": { \"import\": \"./index.d.ts\", \"require\": \"./index.d.cts\" }, \"./subpath\": { \"import\": \"./subpath.d.ts\", \"require\": \"./subpath.d.cts\" } } }\n\nNotice that each exports subpath is reflected, and each JavaScript file has a corresponding declaration file with a matching file extension—a .d.ts file types a .js file, not a .mjs or .cjs file!\n\nWhen the implementation package uses module.exports = ..., the DefinitelyTyped package should use export =, not export default. (Alternatively, if the module.exports is just an object of named properties, the DefinitelyTyped package can use a series of named exports.) The most common obstacle to correcting this problem is confusion about how to export types in addition to the primary export. For example, assume these types are incorrectly using export default:\n\nexport interface Options { // ... } export default function doSomething(options: Options): void;\n\nChanging the export default to an export = creates an error:\n\nexport interface Options { // ... } declare function doSomething(options: Options): void; export = doSomething; // ^^^^^^^^^^^^^^^^^ // Error: An export assignment cannot be used in a module with other exported elements.\n\nTo fix this, move the types inside a namespace with the same name as the function:\n\ndeclare namespace doSomething { export interface Options { // ... } } declare function doSomething(options: doSomething.Options): void; export = doSomething;\n\nIf you need help fixing a problem, please ask in the DefinitelyTyped channel on the TypeScript Community Discord server.\n\nIf you are adding typings for an npm package, create a directory with the same name. If the package you are adding typings for is not on npm, set \"nonNpm\": true in the package.json, and make sure the name you choose for it does not conflict with the name of a package on npm. (You can use npm info <my-package> to check for the existence of the <my-package> package.)\n\nIn rare occasions, nonNpm may be set to \"conflict\", which incidates that there is a package on npm with the same name, but the types intentionally conflict with that package. This can be true for packages which define an environment like @types/node or for dummy packages like aws-lambda. Avoid using \"conflict\" where possible.\n\nThere should be a <my-package>-tests.ts file, which is considered your test file, along with any *.ts files it imports. If you don't see any test files in the module's folder, create a <my-package>-tests.ts. These files are used to validate the API exported from the *.d.ts files which are shipped as @types/<my-package>. They do not themselves ship.\n\nChanges to the *.d.ts files should include a corresponding *.ts file change which shows the API being used, so that someone doesn't accidentally break code you depend on. For example, this change to a function in a .d.ts file adding a new param to a function:\n\nindex.d.ts:\n\n<my-package>-tests.ts:\n\nIf you're wondering where to start with test code, the examples in the README of the original package are a great place to start.\n\nYou can validate your changes with npm test <package to test> from the root of this repo, which takes changed files into account.\n\nUse $ExpectType to assert that an expression is of a given type and @ts-expect-error to assert that a compile error. Examples:\n\nFor more details, see dtslint readme.\n\nIf for some reason a lint rule needs to be disabled, disable it for a specific line:\n\nYou can still disable rules with an .eslintrc.json, but should not in new packages. Disabling rules for the entire package makes it harder to review.\n\ntsconfig.json should have noImplicitAny, noImplicitThis, strictNullChecks and strictFunctionTypes set to true.\n\nYou may edit the tsconfig.json to add new test files, to add \"target\": \"es6\" (needed for async functions), to add to \"lib\" or to add the \"jsx\" compiler option.\n\nTL;DR: esModuleInterop and allowSyntheticDefaultImports are not allowed in your tsconfig.json.\n\nThese options make it possible to write a default import for a CJS export, modeling the built-in interoperability between CJS and ES modules in Node and in some JS bundlers:\n\n// component.d.ts declare class Component {​​​​​}​​​​​ // CJS export, modeling `module.exports = Component` in JS export = Component; // index.d.ts // ESM default import, only allowed under 'esModuleInterop' or 'allowSyntheticDefaultExports' import Component from \"./component\";\n\nSince the compile-time validity of the import in index.d.ts is dependent upon specific compilation settings, which users of your types do not inherit, using this pattern in DefinitelyTyped would force users to change their own compilation settings, which might be incorrect for their runtime. Instead, you must write a CJS import for a CJS export to ensure widespread, config-independent compatibility:\n\n// index.d.ts // CJS import, modeling `const Component = require(\"./component\")` in JS import Component = require(\"./component\");\n\nThis file is required and should follow this template:\n\nA package.json specifies all dependencies, including other @types packages.\n\nYou must add non-@types dependencies to the list of allowed external dependencies. Pikaday is a good example. These additions are approved by a maintainer, which gives us the chance to make sure that @types packages don't depend on malicious packages.\n\nIf the implementation package uses ESM and specifies \"type\": \"module\", then you should modify package.json to match:\n\nThis also applies if the implementation package has exports in its package.json.\n\nThis file defines which files are to be included in each @types package. It must take a specific form. For packages with only one version in the repo:\n\nWhich is to say \"ignore all files, but don't ignore any declaration files\". For packages that have more than one version in the repo, the \"latest\" version (at the top level) should contain something like:\n\nWhich is the same as the previous .npmignore but ignoring each of the versioned child directories.\n\nCI will fail if this file contains the wrong contents and provide the intended value. No matter what this file contains, the publisher will only publish declaration files.\n\nFirst, follow advice from the handbook.\n\nFormatting: dprint is set up on this repo, so you can run pnpm dprint fmt -- 'path/to/package/**/*.ts'.\n\nConsider using the VS Code .vscode/settings.template.json (or equivalent for other editors) to format on save with the VS Code dprint extension\n\nfunction sum(nums: number[]): number: Use ReadonlyArray if a function does not write to its parameters.\n\ninterface Foo { new(): Foo; }: This defines a type of objects that are new-able. You probably want declare class Foo { constructor(); }.\n\nconst Class: { new(): IClass; }: Prefer to use a class declaration class Class { constructor(); } instead of a new-able constant.\n\ngetMeAT<T>(): T: If a type parameter does not appear in the types of any parameters, you don't really have a generic function, you just have a disguised type assertion. Prefer to use a real type assertion, e.g. getMeAT() as number. Example where a type parameter is acceptable: function id<T>(value: T): T;. Example where it is not acceptable: function parseJson<T>(json: string): T;. Exception: new Map<string, number>() is OK.\n\nUsing the types Function and Object is almost never a good idea. In 99% of cases it's possible to specify a more specific type. Examples are (x: number) => number for functions and { x: number, y: number } for objects. If there is no certainty at all about the type, any is the right choice, not Object. If the only known fact about the type is that it's some object, use the type object, not Object or { [key: string]: any }.\n\nvar foo: string | any: When any is used in a union type, the resulting type is still any. So, while the string portion of this type annotation may look useful, it in fact offers no additional typechecking over simply using any. Depending on the intention, acceptable alternatives could be any, string or string | object.\n\nTL;DR: do not modify .github/CODEOWNERS, always modify list of the owners in package.json.\n\nDT has the concept of \"Definition Owners\" which are people who want to maintain the quality of a particular module's types.\n\nAdding yourself to the list will cause you to be notified (via your GitHub username) whenever someone makes a pull request or issue about the package.\n\nYour PR reviews will have a higher precedence of importance to the bot which maintains this repo.\n\nThe DT maintainers are putting trust in the definition owners to ensure a stable eco-system, please don't add yourself lightly.\n\nTo add yourself as a Definition Owner, modify the owners array in package.json:\n\nNote that this list is not used to provide credit for contributions; it is only used for managing PR reviews.\n\nOnce a week the Definition Owners are synced to the file .github/CODEOWNERS which is our source of truth.\n\nDefinitely Typed is one of the most active repositories on GitHub. You might have wondered how the project came to be. @johnnyreilly wrote a history of Definitely Typed. It tells the story of the early days of Definitely Typed, from a repository created by @borisyankov, to the point where it became a pivotal part of the TypeScript ecosystem. You can read the story of Definitely Typed here.\n\nThe master branch is automatically published to the @types scope on npm thanks to DefinitelyTyped-tools.\n\nIt depends, but most pull requests will be merged within a week. Some PRs can be merged by the owners of a module and they can be merged much faster. Roughly:\n\nPRs which only change the types of a module and have corresponding tests changes will be merged much faster\n\nPRs that have been approved by an owner listed in the definition's package.json are usually merged more quickly; PRs for new definitions will take more time as they require more review from maintainers. Each PR is reviewed by a TypeScript or Definitely Typed team member before being merged, so please be patient as human factors may cause delays. Check the New Pull Request Status Board to see progress as maintainers work through the open PRs.\n\nFor changes to very popular modules, e.g. Node/Express/Jest which have many millions of downloads each per week on npm, the requirements for contributions are a bit higher. Changes to these projects can have massive ecosystem effects and so we treat changes to them with a lot of care. These modules require both a sign-off from a DT maintainer and enthusiastic support from the module owners. The bar for passing this can be quite high and often PRs can go stale because it doesn't have a champion. If you're finding that no-one is committing, try to make your PR have a smaller focus.\n\nnpm packages should update within an hour. If it's been more than an hour, mention the PR number on the Definitely Typed channel on the TypeScript Community Discord server and the current maintainer will get the correct team member to investigate.\n\nIf the module you're referencing is a module (uses export), use an import. If the module you're referencing is an ambient module (uses declare module) or just declares globals, use <reference types=\"\" />.\n\nThen they are wrong and we've not noticed yet. You can help by submitting a pull request to fix them.\n\nYes, using dprint. We recommend using a dprint extension for your editor.\n\nAlternatively, you can enable a git hook which will format your code automatically. Run pnpm run setup-hooks. Then, when you commit, dprint fmt command will be executed on changed files. If you take advantage of partial clone, make sure to call git sparse-checkout add .husky to check out the git hooks before running the setup-hooks script.\n\nPull requests do not require correct formatting to be merged. Any unformatted code will be automatically reformatted after being merged.\n\n💡 If you're a VS Code user, we suggest copying the .vscode/settings.template.json file to .vscode/settings.json. That template sets the dprint VS Code extension as the default formatter in the repo.\n\nHere are the currently requested definitions.\n\nIf types are part of a web standard, they should be contributed to TypeScript-DOM-lib-generator so that they can become part of the default lib.dom.d.ts.\n\nIf there's no source JavaScript code at all, for example if you're writing helper types or types for a spec, you should publish the types yourself, not on Definitely Typed. Because they're meant to provide types for existing JavaScript code, @types packages are not meant to be imported directly. That is, you shouldn't create a Definitely Typed package that's meant to be used like import type { ... } from \"@types/foo\". Nor should you expect to write import type { ... } from \"foo\" when there's no foo installed.\n\nThis is different from providing types for a browser only JavaScript library or types for an entire environment like node, bun, et al. There, the types are either resolved implicitly or using /// <references types=\"foo\" />.\n\nSome packages, like chai-http, export a function.\n\nImporting this module with an ES6 style import in the form import * as foo from \"foo\"; leads to the error:\n\nerror TS2497: Module 'foo' resolves to a non-module entity and cannot be imported using this construct.\n\nThis error can be suppressed by merging the function declaration with an empty namespace of the same name, but this practice is discouraged. This is a commonly cited Stack Overflow answer regarding this matter.\n\nIt is more appropriate to import the module using the import foo = require(\"foo\"); syntax. Nevertheless, if you want to use a default import like import foo from \"foo\"; you have two options:\n\nyou can use the --allowSyntheticDefaultImports compiler option if your module runtime supports an interop scheme for non-ECMAScript modules, i.e. if default imports work in your environment (e.g. Webpack, SystemJS, esm).\n\nyou can use the --esModuleInterop compiler option if you want TypeScript to take care of non-ECMAScript interop (since TypeScript 2.7).\n\nLike in the previous question, refer to using either the --allowSyntheticDefaultImports or --esModuleInterop compiler options.\n\nDo not change the type definition if it is accurate. For an npm package, export = is accurate if node -p 'require(\"foo\")' works to import a module and export default is accurate if node -p 'require(\"foo\").default' works to import a module.\n\nThen you will have set the minimum supported version by specifying \"minimumTypeScriptVersion\": \"X.Y\" in package.json.\n\nHowever, if your project needs to maintain types that are compatible with, say, 3.7 and above at the same time as types that are compatible with 3.6 or below, you will need to use the typesVersions feature. You can find a detailed explanation of this feature in the official TypeScript documentation.\n\nHere's a short example to get you started:\n\nYou'll have to add typesVersions to package.json:\n\n{ \"private\": true, \"types\": \"index\", \"typesVersions\": { \"<=3.6\": { \"*\": [\"ts3.6/*\"] } } }\n\nCreate the sub-directory mentioned in the typesVersions field inside your types directory (ts3.6/ in this example). ts3.6/ will support TypeScript versions 3.6 and below, so copy the existing types and tests there.\n\nBack in the root of the package, add the TypeScript 3.7 features you want to use. When people install the package, TypeScript 3.6 and below will start from ts3.6/index.d.ts, whereas TypeScript 3.7 and above will start from index.d.ts.\n\nYou can look at bluebird for an example.\n\nThis may belong in TypeScript-DOM-lib-generator. See the guidelines there. If the standard is still a draft, it belongs here. Use a name beginning with dom- and include a link to the standard as the \"Project\" link in package.json. When it graduates draft mode, we may remove it from Definitely Typed and deprecate the associated @types package.\n\nNOTE: The discussion in this section assumes familiarity with Semantic versioning\n\nEach Definitely Typed package is versioned when published to npm. The DefinitelyTyped-tools (the tool that publishes @types packages to npm) will set the declaration package's version by using the major.minor.9999 version number listed in package.json. For example, here are the first few lines of Node's type declarations for version 20.8.x at the time of writing:\n\nBecause the version is listed as 20.8.9999, the npm version of the @types/node package will also be 20.8.x. Note that the version in package.json should only contain major.minor version (e.g. 10.12) followed by .9999. This is because only the major and minor release numbers are aligned between library packages and type declaration packages. (The .9999 is to ensure that local @types packages are always newest during local development.) The patch release number of the type declaration package (e.g. .0 in 20.8.0) is initialized to zero by Definitely Typed and is incremented each time a new @types/node package is published to npm for the same major/minor version of the corresponding library.\n\nSometimes type declaration package versions and library package versions can get out of sync. Below are a few common reasons why, in order of how much they inconvenience users of a library. Only the last case is typically problematic.\n\nAs noted above, the patch version of the type declaration package is unrelated to the library patch version. This allows Definitely Typed to safely update type declarations for the same major/minor version of a library.\n\nIf updating a package for new functionality, don't forget to update the version number to line up with that version of the library. If users make sure versions correspond between JavaScript packages and their respective @types packages, then npm update should typically just work.\n\nIt's common for type declaration package updates to lag behind library updates because it's often library users, not maintainers, who update Definitely Typed when new library features are released. So, there may be a lag of days, weeks or even months before a helpful community member sends a PR to update the type declaration package for a new library release. If you're impacted by this, you can be the change you want to see in the world and you can be that helpful community member!\n\n❗ If you're updating type declarations for a library, always set the major.minor version in package.json to match the library version that you're documenting! ❗\n\nIf a library is updated to a new major version with breaking changes, how should I update its type declaration package?\n\nSemantic versioning requires that versions with breaking changes must increment the major version number. For example, a library that removes a publicly exported function after its 3.5.8 release must bump its version to 4.0.0 in its next release. Furthermore, when the library's 4.0.0 release is out, it's Definitely Typed type declaration package should also be updated to 4.0.0, including any breaking changes to the library's API.\n\nMany libraries have a large installed base of developers (including maintainers of other packages using that library as a dependency) who won't move right away to a new version that has breaking changes, because it might be months until a maintainer has time to rewrite code to adapt to the new version. In the meantime, users of old library versions still may want to update type declarations for older versions.\n\nIf you intend to continue updating the older version of a library's type declarations, you may create a new subfolder (e.g. /v2/) named for the current (soon to be \"old\") version and copy existing files from the current version to it.\n\nWhen creating a new version folder, ensure that the version field of package.json has been updated; pnpm will automatically resolve to this versioned package whenever it's needed. If other packages in the repo need to depend on this new version, ensure that their package.jsons are also updated too.\n\nFor example, if we are creating types/history/v2, its package.json would look like:\n\nAnother package may select this version by specifying:\n\nAlso, /// <reference types=\"..\" /> will not work with path mapping, so dependencies must use import.\n\n@types packages always type packages of the same version, so @types/foo@5.4.x are for foo@5.4.x. As a consequence, all changes, breaking or not, are published as patch revisions, unless paired with a major/minor bump to change the package version being targeted (coincidentally or not).\n\nWhen it comes to breaking changes, DT maintainers consider the popularity of the package, the upsides of the proposed breaking change, the effort that will be required for users to fix their code, and whether the change could reasonably be delayed until it can be synced with a major bump of the upstream library.\n\nThe TypeScript handbook contains excellent general information about writing definitions and also this example definition file which shows how to create a definition using ES6-style module syntax, while also specifying objects made available to the global scope. This technique is demonstrated practically in the definition for big.js, which is a library that can be loaded globally via script tag on a web page or imported via require or ES6-style imports.\n\nTo test how your definition can be used both when referenced globally or as an imported module, create a test folder and place two test files in there. Name one YourLibraryName-global.test.ts and the other YourLibraryName-module.test.ts. The global test file should exercise the definition according to how it would be used in a script loaded on a web page where the library is available on the global scope - in this scenario you should not specify an import statement. The module test file should exercise the definition according to how it would be used when imported (including the import statement(s)). If you specify a files property in your tsconfig.json file, be sure to include both test files. A practical example of this is also available on the big.js definition.\n\nPlease note that it is not required to fully exercise the definition in each test file - it is sufficient to test only the globally accessible elements on the global test file and fully exercise the definition in the module test file or vice versa.\n\nTypes for a scoped package @foo/bar should go in types/foo__bar. Note the double underscore.\n\nThis project is licensed under the MIT license.\n\nCopyrights on the definition files are respective of each contributor listed at the beginning of each definition file."
    }
}