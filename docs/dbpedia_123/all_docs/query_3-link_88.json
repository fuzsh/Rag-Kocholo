{
    "id": "dbpedia_123_3",
    "rank": 88,
    "data": {
        "url": "https://forum.arduino.cc/t/rubiks-cube-robot-solver/262557",
        "read_more_link": "",
        "language": "en",
        "title": "Rubik's cube Robot solver",
        "top_image": "https://europe1.discourse-cdn.com/arduino/original/4X/2/5/4/254938a09ef3e838488e8f7efd1fa1f3bba69a6a.png",
        "meta_img": "https://europe1.discourse-cdn.com/arduino/original/4X/2/5/4/254938a09ef3e838488e8f7efd1fa1f3bba69a6a.png",
        "images": [
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/2/5/4/254938a09ef3e838488e8f7efd1fa1f3bba69a6a_2_500x278.png",
            "https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/b/3/6/b36041be6ea6aade27eaa85e48dabc8e213344ec_2_500x281.png",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/original/4X/0/3/8/03861d91bb7a2b86920d01f9462b5a5bd5c49412.jpeg",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/1/5/f/15f4658f9c1ac8957de2cc91dd1f0680c970f60f_2_500x260.jpeg",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/8/6/b/86b1156ac3991352e726731fc8fc4cf08af5a176_2_220x120.jpeg",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/1/b/5/1b510f2a4fab69af4218d405193cb6bb463d4ff6_2_500x281.jpeg",
            "https://europe1.discourse-cdn.com/arduino/original/4X/2/c/4/2c47f8008ffbc1fbba63ce0dfe50224fb5075440.jpeg",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/d/7/6/d7607bd42b6e9f8e3ffd6f08b1e5f777baa9f8f1_2_500x389.jpeg",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/8/5/f/85f746770ece5576865e6cf44bf7a9b6ccf53c5f_2_500x342.jpeg",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/original/4X/3/8/7/387476e93196e820c1a97016a42935e71bda5182.png",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/c/5/1/c517d628879a7ad4bf96a03bcf9776db50c9ad9b_2_500x342.png",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/7/5/a/75a089e8a6706a9337971fcfd5d6b43f696113ef_2_690x356.png",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/3/4/1/341adb2594f90f217f24e9cb916dbcc928edec1c_2_500x280.png",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/original/4X/7/f/9/7f9667180b67e0bb659969af092f558c9ac32651.jpeg",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/f/3/5/f35825b2c753a77078e065fcc2042e1a30b9ff9f_2_500x333.jpeg",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/7/7/8/7785083320392b96f3b7fa337395588c55226dff_2_690x359.png",
            "https://emoji.discourse-cdn.com/twitter/money_mouth_face.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/money_mouth_face.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/money_mouth_face.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/roll_eyes.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/1/d/f/1df91a685743e42c3b72a941ae35f7e9bf560bbe_2_500x287.jpeg",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=12"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "X-firm"
        ],
        "publish_date": "2014-10-10T17:37:18+00:00",
        "summary": "",
        "meta_description": "There are 100+ robots cube solver on the Web \nMost of them are Lego Mindstorm based, some others use very expensive hardware \nFew Arduino based robots in fact \nI plan to build something like this: \n  \n &gt;&gt; Video &lt;&lt; \nbut..&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://europe1.discourse-cdn.com/arduino/optimized/3X/c/c/cc4b0921af3d89006e843364a2b18989ad72f83e_2_32x32.png",
        "meta_site_name": "Arduino Forum",
        "canonical_link": "https://forum.arduino.cc/t/rubiks-cube-robot-solver/262557",
        "text": "There are 100+ robots cube solver on the Web\n\nMost of them are Lego Mindstorm based, some others use very expensive hardware\n\nFew Arduino based robots in fact\n\nI plan to build something like this:\n\n>> Video <<\n\nbut... cheaper\n\nor more likely\n\n>> Video <<\n\nbut with better gripping\n\nThe robot will be semi-autonomous\n\nColor recognition and solving to be made at PC level\n\nCube movements performed under Arduino control, at robot level\n\n(USB cable could be disconnected at this stage)\n\nSolving will be done through already existing software, Cube Explorer appears to be a good candidate\n\nA middleware will be developped (using Processing or Python) to convey information back and forth\n\nbetween Arduino and cube solver software\n\nRoad map:\n\ndesign a suitable gripper\n\nrobot construction (2 grippers + frame), test and tuning\n\ndevelop Arduino code for moving the Cube\n\ndevelop the software link between solving and moving\n\nfinal integration\n\nI will use this thread as a blog, to share success and failure\n\nand possibly obtain ideas an advices from our community\n\nNot sure to reach destination but the route itself is promising and definitely exciting\n\nStay tuned\n\nReserved for additional information, photos and videos\n\nParts list (PC/webcam version)\n\nFrame:\n\nPlywood 10mm\n\nGrippers:\n\nPlywood 5mm (plexiglass, or PVC)\n\n4 standard servo's\n\nM3 screws 10, 16, 20 and 24mm\n\n3mm washers\n\nM3 nuts\n\nM3 Nylock nuts\n\n14mm brass standoff spacers\n\nFor Imperial people, use 1/8\" hardware\n\nDrawing\n\nAssembly video\n\nEDIT (feb 2018)\n\nThe grippers 3D printed version has been released on Thingiverse\n\nThis is the Fusion 360 final assembly, including the wrist servo:\n\nexploded view video\n\nthe embedded horns are designed for Futaba 25 teeth spline geometry (Futaba/TowerPro/Orion/Savox/ProTekAce/Bluebird...)\n\nI will release the two specific parts for Hitech servo's family (24T) if required\n\nDiscussion starts at post #428\n\nCube:\n\nI use a Dayan GuHong (57 mm), the DaYan ZhanChi is also very good\n\nDo not use the not so smooth genuine Rubik's Cube(tm)\n\nThe reference site in China for cubes: http://lightake.com/c/DaYan_001001005\n\nOther parts:\n\nFlexible mini 28 LED USB lamp (4 bucks shipped)\n\nCustom shield with 4 servo's sockets\n\nWebcam with optional manual White Balance\n\nPower supply: 6V, 2000mA\n\nI use two 18650 LiFePO4 batteries for powering both Servo's and Arduino\n\nSoftware:\n\nArduino: CubeMover V1.3 NEW VarSpeedServo Library\n\nPython (PC): RubikKasBot V1.3\n\nSolving (PC): Cube Explorer\n\nTesting:\n\nMake sure you test your hardware according to post #6 and post #13\n\nAndroid version (Autonomous design w/o PC)\n\nRobotic hardware is unchanged, webcam is replaced by an Android smarphone\n\nThis version works this way:\n\nSmartphone - take a picture from face #1 and perform color recognition for the 9 facelets\n\nSmartphone - send a Bluetooth command to Arduino to rotate cube to next face\n\nArduino - rotate Cube to next face\n\nSmartphone - same for all 6 faces\n\nSmartphone - build and send via WiFi a query to a dedicated Rubik's solving server (Montréal, Canada)\n\nSmartphone - receive solution from server (Singmaster notation)\n\nSmartphone - send Bluetooth command to Arduino (Singmaster notation format)\n\nArduino - move Cube according to command and put the cube in the right order\n\nTypical query to server:\n\nhttp://nova.polymtl.ca/~simark/solverB/query.php?b=WGGOOOGGG&l=OOGBBYOOY&f=YBBBRRBRR&r=ORBBGGBRR&u=YYRYYGRWW&d=OYYWWWWWW\n\nCorresponding answer from server: OK F U F D'\n\nClic the query and see for yourself\n\nEDIT: this server is now offline, see below\n\nAditional hardware:\n\nHC-05 or HC-06 Bluetooth board for smartphone/Arduino communication (3$ shipped on eBay)\n\nor a very convenient Arduino/HC-05 combo\n\nSoftware:\n\nArduino: CubeMover V1.3 NEW VarSpeedServo Library\n\nSmartphone: Rubik's App is available on request (free)\n\nYou should understand smartphone connection with HC-05 / HC-06 Bluetooth board\n\nThe best approach is to have Joystick BT Commander up and running (same protocol)\n\nEDIT July 28th, 2018\n\nEnd of technical support\n\nI have been supporting this project for nearly four years, this was an exciting experience\n\nI have since moved to other projects and it's now time for me to retire\n\nAll possible questions have been answered in this thread, just read it\n\nThe Android App is here\n\nFeel free to use this thread on a peer to peer basis to share your experience\n\nPlease no more PM's\n\nThanks again for your interest and good luck for your projects\n\nEDIT March 3rd, 2021\n\n** Notice for the android version only **\n\nThe nova server from Polytechnique Montreal is offline since last november, please look here for more info\n\nDon't dump your beloved robot yet , just build a local server on your personal computer\n\nThe easy way:\n\nDownload Cube Explorer 5.14 from Kociemba, uncompress\n\nCube Explorer is a stand alone application (no install), in its own folder\n\nOpen folder, delete cube514qtm.exe (not used), launch cube514htm.exe\n\nAt first run only, the program will create some additional files within its folder\n\nGo to Option/Web Server and check 'Enable Web Server'\n\nYou'r all set\n\nNow open your favorite Web browser and copy/paste this URL:\n\nhttp://localhost:8081/?uufuurfddbfllrrlffulllfflffbuuddddddbbrllubbudrrbbbrrr\n\nResponse: F U F D' as expected\n\nYou may just clic the above query and see for yourself\n\nFor seasoned users:\n\nInstall your own Raspberry Py server using Kociemba Python code\n\nNow... the current android App (V1.23) has a burnt in query header (http://nova.polymtl.ca/~simark/solverB/query.php?)\n\nI just modified the App and added an option for entering a specific server URL\n\nTo get V2.0 (free), just leave me a PM including your email address\n\nI will now prepare a sketch with all possible moves:\n\nF (Front), B (Back), U (Up), D (Down), L (Left), R (Right), plus the \" ' \" and \" 2 \" variants\n\nFor debugging purpose, moves will be entered through Arduino's serial monitor\n\nHere it is:\n\n#define VERSION \"Cube Mover V1.2 @kas2014\\n\" // V1.2: refactored using Cube class // V1.1: replaced Servo with VarSpeedServo library // V1.0: initial release #include <VarSpeedServo.h> #include \"cube.h\" // ---------- user adjustments ------------------- #define DOWN_CLOSE 91 //92 #define DOWN_OPEN 132 #define DOWN_CW 6 #define DOWN_MID 89 #define DOWN_CCW 172 #define BACK_CLOSE 84 //85 #define BACK_OPEN 129 #define BACK_CW 2 #define BACK_MID 87 #define BACK_CCW 171 #define LOW_SPEED 50 //50 #define HI_SPEED 100 //80 // ----------------------------------------------- #define downPinchPin 9 #define downRotPin 10 #define backPinchPin 5 #define backRotPin 6 #define bipPin 11 // buzzer #define myRX 2 #define myTX 3 #define STX 0x02 // serial data frame delimiters #define ETX 0x03 Cube myCube(downPinchPin, downRotPin, backPinchPin, backRotPin); char cmd[128]; // bytes received buffer void setup() { Serial.begin(57600); Serial.println(VERSION); pinMode(bipPin, OUTPUT); myCube.begin(HI_SPEED); // set HIGH servo's speed myCube.downSetLimits(DOWN_CLOSE, DOWN_OPEN, DOWN_CW,DOWN_MID, DOWN_CCW); // set limits for pinch and rotation servo's myCube.backSetLimits(BACK_CLOSE, BACK_OPEN, BACK_CW, BACK_MID, BACK_CCW); myCube.seize(); bip(20, 2); // bip } void loop() { if(getSerialData()) parseData(); } // --------------------------- boolean getSerialData() { if(Serial.available()) { // data received from smartphone delay(2); cmd[0] = Serial.read(); if(cmd[0] == STX) { int i=1; while(Serial.available()) { delay(1); cmd[i] = Serial.read(); // Serial.print(cmd[i]); if(cmd[i]>'u' || i>124) { bip(20, 5); return false; } // Communication error XXX reinitialiser à zero <<< if((cmd[i]==ETX)) return true; // i++; } } } return false; } boolean getSerialMonitor() { // Serial Monitor fsetting: Newline if(Serial.available()) { for(int i=0; i<124; i++) cmd[i] = 0; int n = Serial.readBytesUntil('\\n', cmd, 124); // Serial.print(cmd[0]); Serial.print(\" \"); cmd[n+1] = ETX; return true; } return false; } void parseData() { // parseData(cmd) int i = 0; String progress = \"\"; while (cmd[i] != ETX) { // Serial.print(cmd[i]); mySerial.print(\" \"); switch(cmd[i]) { // Move commands ------------------------------------------------------------ case 'R': // 'R' moves switch(cmd[i+1]) { case '2': Serial.print(\"R2 \"); myCube.R2(); break; case 39: Serial.print(\"R' \"); myCube.Rp(); break; default: Serial.print(\"R \"); myCube.R(); break; } break; case 'L': // 'L' moves switch(cmd[i+1]) { case '2': Serial.print(\"L2 \"); myCube.L2(); break; case 39: Serial.print(\"L' \"); myCube.Lp(); break; default: Serial.print(\"L \"); myCube.L(); break; } break; case 'U': // 'U' moves switch(cmd[i+1]) { case '2': Serial.print(\"U2 \"); myCube.U2(); break; case 39: Serial.print(\"U' \"); myCube.Up(); break; default: Serial.print(\"U \"); myCube.U(); break; } break; case 'D': ** snip (9000 caracters limitation) ** case 'F': case 'B': } break; // Scan commands ----------------------------------------------------------- case 'f': // Scan Front side myCube.scanFront(); Serial.println(\"OKf\"); break; case 'r': // Scan Right side myCube.scanRight(); Serial.println(\"OKr\"); break; case 'b': // Scan Back side myCube.scanBack(); Serial.println(\"OKb\"); break; case 'l': // Scan Right side myCube.scanLeft(); Serial.println(\"OKl\"); break; case 'u': // Scan Up side myCube.scanUp(); Serial.println(\"OKu\"); break; case 'd': // Scan Down side myCube.scanDown(); Serial.println(\"OKd\"); break; case 'g': // back to Front side myCube.scanFront2(); Serial.println(\"OKg\"); break; // Other commands -------------------------------------------------------------- case 'T': // release gripper pressure myCube.seize(); bip(40, 2); Serial.print(\"seize\"); break; case 'S': // change move speed switch(cmd[i+1]) { case '2': myCube.setSpeed(HI_SPEED); Serial.print(\"High Speed\"); break; case '1': myCube.setSpeed(LOW_SPEED); Serial.print(\"Low Speed\"); break; } break; case 'V': // bips switch(cmd[i+1]) { case '4': bip(80, 4); Serial.print(\"bip (4)\"); break; case '2': bip(80, 2); Serial.print(\"bip (2)\"); break; default: bip(80, 1); Serial.print(\"bip \"); break; } break; default: break; } i++; } Serial.println(); bip(20, 2); } void bip(int duration, int n) { // Bip piezo: duration in ms, n repeats for(int i=0; i<n; i++) { digitalWrite(bipPin, HIGH); delay(duration); digitalWrite(bipPin, LOW); delay(75); } }\n\nI also created a library to separate the \"logic\" of the program from the low-level details\n\nEDIT: see post #43 for complete code including cube.h\n\nAccording to Singmaster notation,\n\nmyCube.L generates a move\n\nmyCube.L2 for move\n\nmyCube.Lp (L prime) for a <L'> move\n\nFor demonstration purpose, the cube was first mixed according to < D B2 R2 U' F' L F2 R D2 R B2 R' >\n\nIn this video, I entered < R B2 R' D2 R' F2 L' F U R2 B2 D' > (inverse moves) in the IDE Serial Monitor.\n\n>> Video <<\n\nThe cube is restored, as expected\n\nI will now create a simple Python script (2 buttons) that will:\n\nLaunch Cube Explorer\n\nmove the cube, face by face, for color recognition by Cube Explorer\n\nrequest and obtain the solution from Cube Explorer\n\ntransfer this solution to Arduino"
    }
}