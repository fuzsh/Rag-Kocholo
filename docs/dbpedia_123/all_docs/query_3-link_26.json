{
    "id": "dbpedia_123_3",
    "rank": 26,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/142760/how-to-represent-a-rubiks-cube-in-a-data-structure",
        "read_more_link": "",
        "language": "en",
        "title": "How to represent a Rubik's Cube in a data structure",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://i.sstatic.net/Ct4o3.jpg?s=64",
            "https://www.gravatar.com/avatar/f639b8588fff8bf480c5967a4cfc2bc9?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/4af3541c00d591e9a518b9c0b3b1190a?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/29J5X.jpg?s=64",
            "https://www.gravatar.com/avatar/1e60394201364fb6ed5ad6587a3d8bd1?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/29J5X.jpg?s=64",
            "https://www.gravatar.com/avatar/3a839dc32d2a7c5e86ebe6dbd276d707?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/7a32d4c53103b176a7d37287174fd4b9?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/6e2168c4647a4f096a14c254bd3d3f68?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/1dd96b49e69805fe4213c3c0652bc9f5?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/GB50X.png",
            "https://www.gravatar.com/avatar/eb9f7e57a3c762c6d98139a2a349fae9?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/be571f1fff20320f83c67834c188435f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e97c628a88337b15e76a4690e916a2cd?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/560e7baed307950747f2ff0ca2b1a13a?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/322f2385bd9db6bbc5ca6e37bb637fcd?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://softwareengineering.stackexchange.com/posts/142760/ivc/31d9?prg=00e19aab-6110-4b4b-bd11-20317c439434"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2012-04-03T11:38:26",
        "summary": "",
        "meta_description": "If I am attempting to simulate a Rubik's Cube, how would you create a data structure to store the cube's state in memory, with X number of tiles per side?\n\nThings to consider:\r\nthe cube can be of any",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/142760/how-to-represent-a-rubiks-cube-in-a-data-structure",
        "text": "It should be noted that I am an avid speed cuber, but I have never tried to programatically represent a Rubik's cube in an algorithm or data structure.\n\nI would probably create separate data structures to capture the unique aspects of each block in a cube.\n\nThere are 3 distinct types of blocks on a cube:\n\nCorner Block - It has three color faces and three adjacent pieces that it will share a side with at any time.\n\nEdge Block - It has two color faces and has 4 adjacent pieces that it will share a side with at any time. In 3x3 blocks it always has 2 center pieces and 2 corner pieces.\n\nCenter block - In a 3x3 cube this piece is not movable, however it can be rotated. It will always have 4 adjacent edge blocks. In larger cubes there are multiple center blocks that could share with another center block or an edge piece. Center blocks never are adjacent to a corner block.\n\nKnowing this, a Block can have a list of references to other blocks that it touches. I would keep another list of lists, which would be a list of blocks that represent a single cube face and a list that keeps references to every cube face.\n\nEvery cube face would be represented as a unique face.\n\nWith these data structures it would be pretty easy to write an algorithm that performs a rotation transformation on each face, moving the appropriate blocks into and out of the appropriate lists.\n\nEDIT: Important note, these lists must be ordered of course but I forgot to mention that. For example, if I flip the right side, then the left corner right side block moves to the right corner of the right side and is rotated clockwise.\n\nWhen I think of this problem, I think of a static cube with the colors moving across it in known patterns. So....\n\nA Cube object contains 6 Side objects that remain fixed indexed 0-5. Each side contains 9 position objects that remain fixed indexed 0-8. Each position contains a color.\n\nFor simplicity, handle every action in quarter turn increments. There are 3 axes of rotation, each in 2 possible directions for a total of 6 possible actions on the cube. With this information, it becomes a fairly simple task to map out the 6 possible actions on the cube.\n\nSo the color green in side 6, position 3, may move to side 1 position 3, or side 2 position 7, amongst others, depending on the action taken. I haven't explored this enough to find any mathematical translations, but patterns will probably emerge that you can take advantage of in code.\n\nUsing the data structure, how can I know if a certain cube in a certain state is solvable? I have been struggling with this question myself and haven't quite found the answer yet.\n\nTo do this, never begin with a random cube state. Instead, start with a solved state, and perform n actions programmatically to get the cube into a random starting state. Since you only took legal actions to get to the current state, the cube must be solvable.\n\nI found an x-y-z coordinate system to be a simple way of addressing a Rubik's cube, and rotation matrices a simple, generic way of implementing the rotations.\n\nI created a Piece class containing a position vector (x, y, z). A Piece can be rotated by applying a rotation matrix to its position (a matrix-vector multiplication). The Piece also keeps tracks of it colors in a tuple (cx, cy, cz), giving the colors facing along each axis. A small amount of logic ensures these colors are updated appropriately during a rotation: a 90 degree rotation in the X-Y plane means we would swap the values of cx and cy.\n\nBecause all of the rotation logic is encapsulated in the Piece class, the Cube can store an unordered list of Pieces, and rotations can be done in a generic fashion. To do a rotation of the left face, select all pieces with an x-coordinate of -1 and apply the appropriate rotation matrix to each Piece. To do a rotation of the entire cube, apply the same rotation matrix to every piece.\n\nThis implementation is simple and has a couple of niceties:\n\nA Piece object's position will change, but its colors do not. This means you can ask for the red-green piece, hang on to the object, do some rotations, and check the same object to see where the red-green piece ended up.\n\nEach type of Piece (edge, center, corner) has a unique coordinate pattern. For a 3x3 cube, a corner piece has no zeros in its position vector ((-1, 1, 1)), an edge has exactly one zero ((1, 0, -1)), and a center piece has two zeroes ((-1, 0, 0)).\n\nThe rotation matrices that work for a 3x3 cube will work for an NxN cube.\n\nDownsides:\n\nMatrix-vector multiplication is slower than swapping values in arrays.\n\nLinear-time lookups for Pieces by position. You'd have to store Pieces in an external data-structure and update that during rotations for constant-time lookups by position. This defeats some of the elegance of using rotation matrices, and leaks rotation logic into your Cube class. If I was implementing any kind of search-based solving algo, I'd use another implementation.\n\nPattern analysis (during solving) is not as nice as it could be. A Piece has no knowledge of its adjacent Pieces, and analysis would be slow due to the above performance issues.\n\nyou can use a simple array (each element having a 1 to 1 mapping to a square on a face) and simulate each rotation with a certain permutation\n\nyou can get away with only 3 essential permutations: rotate a slice with the axis though the front face, rotate the cube around the vertical axis and rotate the cube over the horizontal axis through the left and right faces. all the other moves can be expressed by some concatenation of these three.\n\nthe most straightforward way of know whether a cube is solvable is to solve it (find a series of permutations that will solve the cube), if you end up with 2 edges that have swapped place, a single flipped edge, a single flipped corner or 2 swapped corners you have a unxolvable cube\n\nThe first condition that it be solveable would be that each piece be present and that colors on each piece can be used to assemble a \"sovled\" cube. This is a relatively trivial condition whose truth can be determined with a simple checklist. The color scheme on a \"standard\" cube is defined, but even if you're not dealing with standard cube there are only 6! possible combinations of solved faces.\n\nOnce you have all the pieces and colors right, then it is a matter determining if any given physical configuration is solvable. Not all of them are. The most naive way to check this is to run a cube-solving algorithm and see if it terminates with a solved cube. I don't know if there are fancy combinatorial techniques to determine solvability without actually trying to solve the cube.\n\nAs for what data structure... that almost doesn't matter. The tricky part is getting the transformations right and being able to represent the cube state in a way that allows you to neatly work with available algorithms in the literature. As Maple-shaft indicated there are three types of pieces. Literature on rubik's cube solving always refer to pieces by their type. Transformations are also represented in common ways (look up Singmaster notation). Also, all solutions that I've seen always refer to one piece as a reference point (usually putting the white center piece on bottom).\n\nSince you already received great answers, let me add just a detail.\n\nIrrespective of your concrete representation, note that lenses are a very fine tool for \"zooming in\" on the various parts of a cube. For instance, look at the function cycleLeft in this Haskell code. It is a generic function which cyclically permutes any list of length 4. The code for performing the L move looks like this:\n\nmoveL :: Aut (RubiksCube a) moveL = cong cube $ cong leftCols cycleLeft . cong leftSide rotateSideCW\n\nThus cycleLeft operates on the view given by leftCols. Similarly, rotateSideCW, which is a generic function taking a side to a rotated version of it, operates on the view given by leftSide. The other moves can be implemented in similar ways.\n\nThe goal of that Haskell library is to create pretty pictures. I think it succeeded:\n\nI like the idea of @maple_shaft to represent different pieces (mini-cubes) differently: central, edge, and corner pieces carry 1, 2, or 3 colors, respectively.\n\nI'd represent the relationships between them as a (bidirectional) graph, with edges connecting adjacent pieces. Each piece would have an array of slots for edges (connections): 4 slots in central pieces, 4 slots in edge pieces, 3 slots in corner pieces. Alternatively, center pieces may have 4 connection to edge pieces and 4 for corner pieces separately, and/or edge pieces may have 2 connection to center pieces and 2 to corner pieces separately.\n\nThese arrays are ordered so that iterating over graph edges always represent 'the same' rotation, modulo the cube's rotation. That is, e.g. for a center piece, if you rotate the cube so that its face is on top, the order of connections is always clockwise. Similarly for edge and corner pieces. This property holds after face rotations (or so it seems to me now).\n\nFinding pieces belonging to an edge is trivial.\n\nFinding pieces belonging to a face is trivial.\n\nFinding faces that are at given direction to given face, or an opposite face, is traversing 2 or 3 well-defined links.\n\nTo rotate a face, update connections of all pieces connected to the face's central piece.\n\nDetection of clearly unsolvable conditions (swapped/flipped edges, swapped corner) if hopefully easy, too, because finding pieces of particular type and their orientation is simple.\n\nHow about nodes and pointers?\n\nAssuming there is always 6 faces, and that 1 node represents 1 square on 1 face:\n\nr , g , b r , g , b r , g , b | | | r , g , b - r , g , b r , g , b - r , g , b r , g , b - r , g , b\n\nA node has a pointer to each node next to it. A circle rotation just migrates the pointer (Number of nodes/Number of faces)-1 nodes over, in this case 2. Since all rotations are circle rotations, you just build one rotate function. It is recursive, moving each node one space, and checking if it has moved them enough, since it will have collected the number of nodes, and there is always four faces. If not, increment the number of times moved value and call rotate again.\n\nDon't forget it's doubly linked, so update the newly pointed nodes as well. There will always be Height*Width number of nodes moved, with one pointer updated per node, so there should be Height*Width*2 number of pointers updated.\n\nSince all the nodes point to each other, just walk around on circle updating each node as you come to it.\n\nThis should work for any sized cube, without edge cases or complex logic. It's just a pointer walk/update.\n\nFrom personal experience using a set to keep track of each rotational part of the cube works well. Each sub cube is in three sets no mater the size of the rubik cube. So to find a sub cube some where on the rubik's cube you just take the intersection of the three sets (the result is one sub cube). To do a move remove the effected sub cubs from the sets involved in the move and then put them back into the sets that take them as a result of the move.\n\nThe 4 by 4 cube will have 12 sets. 6 sets for the 6 faces and 6 sets for the six bands that go around the cube. The faces each have 16 sub cubes and the bands each have 12 sub cubs. There are a total of 56 sub cubes. Each sub cube holds information about color and the direction of the colors. The rubik cube itself is a 4 by 4 by 4 array with each element having information consisting of the 3 sets that define the sub cube at that location.\n\nUnlike the other 11 answers this data structure has you using the intersection of sets to define each sub blocks location in the cube. This save the work of having to update the near sub blocks when a change is made."
    }
}