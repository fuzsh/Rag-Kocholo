{
    "id": "dbpedia_3622_3",
    "rank": 25,
    "data": {
        "url": "https://seaborn.pydata.org/tutorial/objects_interface.html",
        "read_more_link": "",
        "language": "en",
        "title": "The seaborn.objects interface — seaborn 0.13.2 documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://seaborn.pydata.org/_static/logo-wide-lightbg.svg",
            "https://seaborn.pydata.org/_static/logo-wide-lightbg.svg",
            "https://seaborn.pydata.org/_images/objects_interface_4_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_6_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_8_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_10_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_12_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_14_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_16_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_18_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_20_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_22_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_24_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_26_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_28_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_30_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_32_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_34_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_36_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_38_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_40_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_42_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_44_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_46_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_48_0.svg",
            "https://seaborn.pydata.org/_images/objects_interface_50_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_52_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_54_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_56_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_58_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_60_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_62_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_66_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_68_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_71_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_73_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_75_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_77_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_79_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_81_0.png",
            "https://seaborn.pydata.org/_images/objects_interface_83_0.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "../_static/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Specifying a plot and mapping data#\n\nThe objects interface should be imported with the following convention:\n\nimport seaborn.objects as so\n\nThe seaborn.objects namespace will provide access to all of the relevant classes. The most important is Plot. You specify plots by instantiating a Plot object and calling its methods. Let’s see a simple example:\n\n( so.Plot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\") .add(so.Dot()) )\n\nThis code, which produces a scatter plot, should look reasonably familiar. Just as when using seaborn.scatterplot(), we passed a tidy dataframe (penguins) and assigned two of its columns to the x and y coordinates of the plot. But instead of starting with the type of chart and then adding some data assignments, here we started with the data assignments and then added a graphical element.\n\nSetting properties#\n\nThe Dot class is an example of a Mark: an object that graphically represents data values. Each mark will have a number of properties that can be set to change its appearance:\n\n( so.Plot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\") .add(so.Dot(color=\"g\", pointsize=4)) )\n\nMapping properties#\n\nAs with seaborn’s functions, it is also possible to map data values to various graphical properties:\n\n( so.Plot( penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", color=\"species\", pointsize=\"body_mass_g\", ) .add(so.Dot()) )\n\nWhile this basic functionality is not novel, an important difference from the function API is that properties are mapped using the same parameter names that would set them directly (instead of having hue vs. color, etc.). What matters is where the property is defined: passing a value when you initialize Dot will set it directly, whereas assigning a variable when you set up the Plot will map the corresponding data.\n\nBeyond this difference, the objects interface also allows a much wider range of mark properties to be mapped:\n\n( so.Plot( penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", edgecolor=\"sex\", edgewidth=\"body_mass_g\", ) .add(so.Dot(color=\".8\")) )\n\nDefining groups#\n\nThe Dot mark represents each data point independently, so the assignment of a variable to a property only has the effect of changing each dot’s appearance. For marks that group or connect observations, such as Line, it also determines the number of distinct graphical elements:\n\n( so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\", color=\"Country\") .add(so.Line()) )\n\nIt is also possible to define a grouping without changing any visual properties, by using group:\n\n( so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\", group=\"Country\") .add(so.Line()) )\n\nTransforming data before plotting#\n\nStatistical transformation#\n\nAs with many seaborn functions, the objects interface supports statistical transformations. These are performed by Stat objects, such as Agg:\n\n( so.Plot(penguins, x=\"species\", y=\"body_mass_g\") .add(so.Bar(), so.Agg()) )\n\nIn the function interface, statistical transformations are possible with some visual representations (e.g. seaborn.barplot()) but not others (e.g. seaborn.scatterplot()). The objects interface more cleanly separates representation and transformation, allowing you to compose Mark and Stat objects:\n\n( so.Plot(penguins, x=\"species\", y=\"body_mass_g\") .add(so.Dot(pointsize=10), so.Agg()) )\n\nWhen forming groups by mapping properties, the Stat transformation is applied to each group separately:\n\n( so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\") .add(so.Dot(pointsize=10), so.Agg()) )\n\nResolving overplotting#\n\nSome seaborn functions also have mechanisms that automatically resolve overplotting, as when seaborn.barplot() “dodges” bars once hue is assigned. The objects interface has less complex default behavior. Bars representing multiple groups will overlap by default:\n\n( so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\") .add(so.Bar(), so.Agg()) )\n\nNevertheless, it is possible to compose the Bar mark with the Agg stat and a second transformation, implemented by Dodge:\n\n( so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\") .add(so.Bar(), so.Agg(), so.Dodge()) )\n\nThe Dodge class is an example of a Move transformation, which is like a Stat but only adjusts x and y coordinates. The Move classes can be applied with any mark, and it’s not necessary to use a Stat first:\n\n( so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\") .add(so.Dot(), so.Dodge()) )\n\nIt’s also possible to apply multiple Move operations in sequence:\n\n( so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\") .add(so.Dot(), so.Dodge(), so.Jitter(.3)) )\n\nCreating variables through transformation#\n\nThe Agg stat requires both x and y to already be defined, but variables can also be created through statistical transformation. For example, the Hist stat requires only one of x or y to be defined, and it will create the other by counting observations:\n\n( so.Plot(penguins, x=\"species\") .add(so.Bar(), so.Hist()) )\n\nThe Hist stat will also create new x values (by binning) when given numeric data:\n\n( so.Plot(penguins, x=\"flipper_length_mm\") .add(so.Bars(), so.Hist()) )\n\nNotice how we used Bars, rather than Bar for the plot with the continuous x axis. These two marks are related, but Bars has different defaults and works better for continuous histograms. It also produces a different, more efficient matplotlib artist. You will find the pattern of singular/plural marks elsewhere. The plural version is typically optimized for cases with larger numbers of marks.\n\nSome transforms accept both x and y, but add interval data for each coordinate. This is particularly relevant for plotting error bars after aggregating:\n\n( so.Plot(penguins, x=\"body_mass_g\", y=\"species\", color=\"sex\") .add(so.Range(), so.Est(errorbar=\"sd\"), so.Dodge()) .add(so.Dot(), so.Agg(), so.Dodge()) )\n\nOrienting marks and transforms#\n\nWhen aggregating, dodging, and drawing a bar, the x and y variables are treated differently. Each operation has the concept of an orientation. The Plot tries to determine the orientation automatically based on the data types of the variables. For instance, if we flip the assignment of species and body_mass_g, we’ll get the same plot, but oriented horizontally:\n\n( so.Plot(penguins, x=\"body_mass_g\", y=\"species\", color=\"sex\") .add(so.Bar(), so.Agg(), so.Dodge()) )\n\nSometimes, the correct orientation is ambiguous, as when both the x and y variables are numeric. In these cases, you can be explicit by passing the orient parameter to Plot.add():\n\n( so.Plot(tips, x=\"total_bill\", y=\"size\", color=\"time\") .add(so.Bar(), so.Agg(), so.Dodge(), orient=\"y\") )\n\nBuilding and displaying the plot#\n\nMost examples this far have produced a single subplot with just one kind of mark on it. But Plot does not limit you to this.\n\nAdding multiple layers#\n\nMore complex single-subplot graphics can be created by calling Plot.add() repeatedly. Each time it is called, it defines a layer in the plot. For example, we may want to add a scatterplot (now using Dots) and then a regression fit:\n\n( so.Plot(tips, x=\"total_bill\", y=\"tip\") .add(so.Dots()) .add(so.Line(), so.PolyFit()) )\n\nVariable mappings that are defined in the Plot constructor will be used for all layers:\n\n( so.Plot(tips, x=\"total_bill\", y=\"tip\", color=\"time\") .add(so.Dots()) .add(so.Line(), so.PolyFit()) )\n\nLayer-specific mappings#\n\nYou can also define a mapping such that it is used only in a specific layer. This is accomplished by defining the mapping within the call to Plot.add for the relevant layer:\n\n( so.Plot(tips, x=\"total_bill\", y=\"tip\") .add(so.Dots(), color=\"time\") .add(so.Line(color=\".2\"), so.PolyFit()) )\n\nAlternatively, define the layer for the entire plot, but remove it from a specific layer by setting the variable to None:\n\n( so.Plot(tips, x=\"total_bill\", y=\"tip\", color=\"time\") .add(so.Dots()) .add(so.Line(color=\".2\"), so.PolyFit(), color=None) )\n\nTo recap, there are three ways to specify the value of a mark property: (1) by mapping a variable in all layers, (2) by mapping a variable in a specific layer, and (3) by setting the property directly:\n\nFaceting and pairing subplots#\n\nAs with seaborn’s figure-level functions (seaborn.displot(), seaborn.catplot(), etc.), the Plot interface can also produce figures with multiple “facets”, or subplots containing subsets of data. This is accomplished with the Plot.facet() method:\n\n( so.Plot(penguins, x=\"flipper_length_mm\") .facet(\"species\") .add(so.Bars(), so.Hist()) )\n\nCall Plot.facet() with the variables that should be used to define the columns and/or rows of the plot:\n\n( so.Plot(penguins, x=\"flipper_length_mm\") .facet(col=\"species\", row=\"sex\") .add(so.Bars(), so.Hist()) )\n\nYou can facet using a variable with a larger number of levels by “wrapping” across the other dimension:\n\n( so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\") .facet(col=\"Country\", wrap=3) .add(so.Line()) )\n\nAll layers will be faceted unless you explicitly exclude them, which can be useful for providing additional context on each subplot:\n\n( so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\") .facet(\"Country\", wrap=3) .add(so.Line(alpha=.3), group=\"Country\", col=None) .add(so.Line(linewidth=3)) )\n\nAn alternate way to produce subplots is Plot.pair(). Like seaborn.PairGrid, this draws all of the data on each subplot, using different variables for the x and/or y coordinates:\n\n( so.Plot(penguins, y=\"body_mass_g\", color=\"species\") .pair(x=[\"bill_length_mm\", \"bill_depth_mm\"]) .add(so.Dots()) )\n\nYou can combine faceting and pairing so long as the operations add subplots on opposite dimensions:\n\n( so.Plot(penguins, y=\"body_mass_g\", color=\"species\") .pair(x=[\"bill_length_mm\", \"bill_depth_mm\"]) .facet(row=\"sex\") .add(so.Dots()) )\n\nIntegrating with matplotlib#\n\nThere may be cases where you want multiple subplots to appear in a figure with a more complex structure than what Plot.facet() or Plot.pair() can provide. The current solution is to delegate figure setup to matplotlib and to supply the matplotlib object that Plot should use with the Plot.on() method. This object can be either a matplotlib.axes.Axes, matplotlib.figure.Figure, or matplotlib.figure.SubFigure; the latter is most useful for constructing bespoke subplot layouts:\n\nf = mpl.figure.Figure(figsize=(8, 4)) sf1, sf2 = f.subfigures(1, 2) ( so.Plot(penguins, x=\"body_mass_g\", y=\"flipper_length_mm\") .add(so.Dots()) .on(sf1) .plot() ) ( so.Plot(penguins, x=\"body_mass_g\") .facet(row=\"sex\") .add(so.Bars(), so.Hist()) .on(sf2) .plot() )\n\nBuilding and displaying the plot#\n\nAn important thing to know is that Plot methods clone the object they are called on and return that clone instead of updating the object in place. This means that you can define a common plot spec and then produce several variations on it.\n\nSo, take this basic specification:\n\np = so.Plot(healthexp, \"Year\", \"Spending_USD\", color=\"Country\")\n\nWe could use it to draw a line plot:\n\np.add(so.Line())\n\nOr perhaps a stacked area plot:\n\np.add(so.Area(), so.Stack())\n\nThe Plot methods are fully declarative. Calling them updates the plot spec, but it doesn’t actually do any plotting. One consequence of this is that methods can be called in any order, and many of them can be called multiple times.\n\nWhen does the plot actually get rendered? Plot is optimized for use in notebook environments. The rendering is automatically triggered when the Plot gets displayed in the Jupyter REPL. That’s why we didn’t see anything in the example above, where we defined a Plot but assigned it to p rather than letting it return out to the REPL.\n\nTo see a plot in a notebook, either return it from the final line of a cell or call Jupyter’s built-in display function on the object. The notebook integration bypasses matplotlib.pyplot entirely, but you can use its figure-display machinery in other contexts by calling Plot.show().\n\nYou can also save the plot to a file (or buffer) by calling Plot.save().\n\nCustomizing the appearance#\n\nThe new interface aims to support a deep amount of customization through Plot, reducing the need to switch gears and use matplotlib functionality directly. (But please be patient; not all of the features needed to achieve this goal have been implemented!)\n\nParameterizing scales#\n\nAll of the data-dependent properties are controlled by the concept of a Scale and the Plot.scale() method. This method accepts several different types of arguments. One possibility, which is closest to the use of scales in matplotlib, is to pass the name of a function that transforms the coordinates:\n\n( so.Plot(diamonds, x=\"carat\", y=\"price\") .add(so.Dots()) .scale(y=\"log\") )\n\nPlot.scale() can also control the mappings for semantic properties like color. You can directly pass it any argument that you would pass to the palette parameter in seaborn’s function interface:\n\n( so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"clarity\") .add(so.Dots()) .scale(color=\"flare\") )\n\nAnother option is to provide a tuple of (min, max) values, controlling the range that the scale should map into. This works both for numeric properties and for colors:\n\n( so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"clarity\", pointsize=\"carat\") .add(so.Dots()) .scale(color=(\"#88c\", \"#555\"), pointsize=(2, 10)) )\n\nFor additional control, you can pass a Scale object. There are several different types of Scale, each with appropriate parameters. For example, Continuous lets you define the input domain (norm), the output range (values), and the function that maps between them (trans), while Nominal allows you to specify an ordering:\n\n( so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"carat\", marker=\"cut\") .add(so.Dots()) .scale( color=so.Continuous(\"crest\", norm=(0, 3), trans=\"sqrt\"), marker=so.Nominal([\"o\", \"+\", \"x\"], order=[\"Ideal\", \"Premium\", \"Good\"]), ) )\n\nCustomizing legends and ticks#\n\nThe Scale objects are also how you specify which values should appear as tick labels / in the legend, along with how they appear. For example, the Continuous.tick() method lets you control the density or locations of the ticks, and the Continuous.label() method lets you modify the format:\n\n( so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"carat\") .add(so.Dots()) .scale( x=so.Continuous().tick(every=0.5), y=so.Continuous().label(like=\"${x:.0f}\"), color=so.Continuous().tick(at=[1, 2, 3, 4]), ) )\n\nCustomizing limits, labels, and titles#\n\nPlot has a number of methods for simple customization, including Plot.label(), Plot.limit(), and Plot.share():\n\n( so.Plot(penguins, x=\"body_mass_g\", y=\"species\", color=\"island\") .facet(col=\"sex\") .add(so.Dot(), so.Jitter(.5)) .share(x=False) .limit(y=(2.5, -.5)) .label( x=\"Body mass (g)\", y=\"\", color=str.capitalize, title=\"{} penguins\".format, ) )\n\nTheme customization#\n\nFinally, Plot supports data-independent theming through the Plot.theme method. Currently, this method accepts a dictionary of matplotlib rc parameters. You can set them directly and/or pass a package of parameters from seaborn’s theming functions:\n\nfrom seaborn import axes_style theme_dict = {**axes_style(\"whitegrid\"), \"grid.linestyle\": \":\"} so.Plot().theme(theme_dict)\n\nTo change the theme for all Plot instances, update the settings in Plot.config:\n\nso.Plot.config.theme.update(theme_dict)"
    }
}