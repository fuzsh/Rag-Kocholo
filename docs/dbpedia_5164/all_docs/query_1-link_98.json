{
    "id": "dbpedia_5164_1",
    "rank": 98,
    "data": {
        "url": "https://owasp.org/www-community/attacks/csrf",
        "read_more_link": "",
        "language": "en",
        "title": "Cross Site Request Forgery (CSRF)",
        "top_image": "https://owasp.org/www--site-theme/favicon.ico",
        "meta_img": "https://owasp.org/www--site-theme/favicon.ico",
        "images": [
            "https://owasp.org/assets/images/logo.png",
            "https://owasp.org/assets/images/logo.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Cross Site Request Forgery (CSRF) on the main website for The OWASP Foundation. OWASP is a nonprofit foundation that works to improve the security of software.",
        "meta_lang": "en",
        "meta_favicon": "https://owasp.org/www--site-theme/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://owasp.org/www-community/attacks/csrf",
        "text": "Author: KirstenS\n\nContributor(s): Dave Wichers, Davisnw, Paul Petefish, Adar Weidman, Michael Brooks, Ahsan Mir, Dc, D0ubl3 h3lix, Jim Manico, Robert Gilbert, Tgondrom, Pawel Krawczyk, Brandt, A V Minhaz, Kevin Lorenzo, Andrew Smith, Christina Schelin, Ari Elias-Bachrach, Sarciszewski, kingthorin, Ben Spatafora, Krishna Madala\n\nOverview\n\nCross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted actions on a web application in which they’re currently authenticated. With a little help of social engineering (such as sending a link via email or chat), an attacker may trick the users of a web application into executing actions of the attacker’s choosing. If the victim is a normal user, a successful CSRF attack can force the user to perform state changing requests like transferring funds, changing their email address, and so forth. If the victim is an administrative account, CSRF can compromise the entire web application.\n\nRelated Security Activities\n\nHow to Review Code for CSRF Vulnerabilities\n\nSee the OWASP Code Review Guide article on how to review code for CSRF vulnerabilities.\n\nHow to Test for CSRF Vulnerabilities\n\nSee the OWASP Testing Guide article on how to test for CSRF vulnerabilities.\n\nHow to Prevent CSRF Vulnerabilities\n\nSee the CSRF Prevention Cheat Sheet for prevention measures.\n\nListen to the OWASP Top Ten CSRF Podcast.\n\nMost frameworks have built-in CSRF support such as Joomla, Spring, Struts, Ruby on Rails, .NET and others.\n\nUse OWASP CSRF Guard to add CSRF protection to your Java applications. You can use CSRFProtector Project to protect your PHP applications or any project deployed using Apache Server.\n\nJohn Melton also has an excellent blog post describing how to use the native anti-CSRF functionality of the OWASP ESAPI.\n\nDescription\n\nCSRF is an attack that tricks the victim into submitting a malicious request. It inherits the identity and privileges of the victim to perform an undesired function on the victim’s behalf (though note that this is not true of login CSRF, a special form of the attack described below). For most sites, browser requests automatically include any credentials associated with the site, such as the user’s session cookie, IP address, Windows domain credentials, and so forth. Therefore, if the user is currently authenticated to the site, the site will have no way to distinguish between the forged request sent by the victim and a legitimate request sent by the victim.\n\nCSRF attacks target functionality that causes a state change on the server, such as changing the victim’s email address or password, or purchasing something. Forcing the victim to retrieve data doesn’t benefit an attacker because the attacker doesn’t receive the response, the victim does. As such, CSRF attacks target state-changing requests.\n\nAn attacker can use CSRF to obtain the victim’s private data via a special form of the attack, known as login CSRF. The attacker forces a non-authenticated user to log in to an account the attacker controls. If the victim does not realize this, they may add personal data—such as credit card information—to the account. The attacker can then log back into the account to view this data, along with the victim’s activity history on the web application.\n\nIt’s sometimes possible to store the CSRF attack on the vulnerable site itself. Such vulnerabilities are called “stored CSRF flaws”. This can be accomplished by simply storing an IMG or IFRAME tag in a field that accepts HTML, or by a more complex cross-site scripting attack. If the attack can store a CSRF attack in the site, the severity of the attack is amplified. In particular, the likelihood is increased because the victim is more likely to view the page containing the attack than some random page on the Internet. The likelihood is also increased because the victim is sure to be authenticated to the site already.\n\nSynonyms\n\nCSRF attacks are also known by a number of other names, including XSRF, “Sea Surf”, Session Riding, Cross-Site Reference Forgery, and Hostile Linking. Microsoft refers to this type of attack as a One-Click attack in their threat modeling process and many places in their online documentation.\n\nPrevention measures that do NOT work\n\nA number of flawed ideas for defending against CSRF attacks have been developed over time. Here are a few that we recommend you avoid.\n\nUsing a secret cookie\n\nRemember that all cookies, even the secret ones, will be submitted with every request. All authentication tokens will be submitted regardless of whether or not the end-user was tricked into submitting the request. Furthermore, session identifiers are simply used by the application container to associate the request with a specific session object. The session identifier does not verify that the end-user intended to submit the request.\n\nOnly accepting POST requests\n\nApplications can be developed to only accept POST requests for the execution of business logic. The misconception is that since the attacker cannot construct a malicious link, a CSRF attack cannot be executed. Unfortunately, this logic is incorrect. There are numerous methods in which an attacker can trick a victim into submitting a forged POST request, such as a simple form hosted in an attacker’s Website with hidden values. This form can be triggered automatically by JavaScript or can be triggered by the victim who thinks the form will do something else.\n\nMulti-Step Transactions\n\nMulti-Step transactions are not an adequate prevention of CSRF. As long as an attacker can predict or deduce each step of the completed transaction, then CSRF is possible.\n\nURL Rewriting\n\nThis might be seen as a useful CSRF prevention technique as the attacker cannot guess the victim’s session ID. However, the user’s session ID is exposed in the URL. We don’t recommend fixing one security flaw by introducing another.\n\nHTTPS\n\nHTTPS by itself does nothing to defend against CSRF.\n\nHowever, HTTPS should be considered a prerequisite for any preventative measures to be trustworthy.\n\nValidating the Referrer Header\n\nThis doesn’t work in practice because the referrer header can be easily spoofed by an attacker. Additionally, some users or browsers might not send the referrer header due to privacy settings or policies, leading to false positives. Moreover, there are situations where the referrer can be null, such as when a user navigates to a site from a bookmark or any other resource without a traditional url. In these scenarios, legitimate requests could be mistaken as potential CSRF attacks, which would result in more potential false positive flags.\n\nExamples\n\nHow does the attack work?\n\nThere are numerous ways in which an end user can be tricked into loading information from or submitting information to a web application. In order to execute an attack, we must first understand how to generate a valid malicious request for our victim to execute. Let us consider the following example: Alice wishes to transfer $100 to Bob using the bank.com web application that is vulnerable to CSRF. Maria, an attacker, wants to trick Alice into sending the money to Maria instead. The attack will comprise the following steps:\n\nBuilding an exploit URL or script\n\nTricking Alice into executing the action with Social Engineering\n\nGET scenario\n\nIf the application was designed to primarily use GET requests to transfer parameters and execute actions, the money transfer operation might be reduced to a request like:\n\nGET http://bank.com/transfer.do?acct=BOB&amount=100 HTTP/1.1\n\nMaria now decides to exploit this web application vulnerability using Alice as the victim. Maria first constructs the following exploit URL which will transfer $100,000 from Alice’s account to Maria’s account. Maria takes the original command URL and replaces the beneficiary name with herself, raising the transfer amount significantly at the same time:\n\nhttp://bank.com/transfer.do?acct=MARIA&amount=100000\n\nThe social engineering aspect of the attack tricks Alice into loading this URL when Alice is logged into the bank application. This is usually done with one of the following techniques:\n\nsending an unsolicited email with HTML content\n\nplanting an exploit URL or script on pages that are likely to be visited by the victim while they are also doing online banking\n\nThe exploit URL can be disguised as an ordinary link, encouraging the victim to click it:\n\n<a href=\"http://bank.com/transfer.do?acct=MARIA&amount=100000\">View my Pictures!</a>\n\nOr as a 0x0 fake image:\n\n<img src=\"http://bank.com/transfer.do?acct=MARIA&amount=100000\" width=\"0\" height=\"0\" border=\"0\">\n\nIf this image tag were included in the email, Alice wouldn’t see anything. However, the browser will still submit the request to bank.com without any visual indication that the transfer has taken place.\n\nA real life example of CSRF attack on an application using GET was a uTorrent exploit from 2008 that was used on a mass scale to download malware.\n\nPOST scenario\n\nThe only difference between GET and POST attacks is how the attack is being executed by the victim. Let’s assume the bank now uses POST and the vulnerable request looks like this:\n\nSuch a request cannot be delivered using standard A or IMG tags, but can be delivered using a FORM tags:\n\nThis form will require the user to click on the submit button, but this can be also executed automatically using JavaScript:\n\nOther HTTP methods\n\nModern web application APIs frequently use other HTTP methods, such as PUT or DELETE. Let’s assume the vulnerable bank uses PUT that takes a JSON block as an argument:\n\nSuch requests can be executed with JavaScript embedded into an exploit page:\n\nFortunately, this request will not be executed by modern web browsers thanks to same-origin policy restrictions. This restriction is enabled by default unless the target web site explicitly opens up cross-origin requests from the attacker’s (or everyone’s) origin by using CORS with the following header:\n\nAccess-Control-Allow-Origin: *\n\nRelated Attacks\n\nCross-site Scripting (XSS)\n\nCross Site History Manipulation (XSHM)\n\nRelated Controls\n\nAdd a per-request nonce to the URL and all forms in addition to the standard session. This is also referred to as “form keys”. Many frameworks (e.g., Drupal.org 4.7.4+) either have or are starting to include this type of protection “built-in” to every form so the programmer does not need to code this protection manually.\n\nAdd a hash (session id, function name, server-side secret) to all forms.\n\nFor .NET, add a session identifier to ViewState with MAC (described in detail in the DotNet Security Cheat Sheet).\n\nChecking the referrer header in the client’s HTTP request can prevent CSRF attacks. Ensuring that the HTTP request has come from the original site means that attacks from other sites will not function. It is very common to see referrer header checks used on embedded network hardware due to memory limitations.\n\nXSS can be used to bypass both referrer and token based checks simultaneously. For instance, the Samy worm used an XMLHttpRequest to obtain the CSRF token to forge requests.\n\n“Although CSRF is fundamentally a problem with the web application, not the user, users can help protect their accounts at poorly designed sites by logging off the site before visiting another, or clearing their browser’s cookies at the end of each browser session.” –http://en.wikipedia.org/wiki/Cross-site_request_forgery#_note-1\n\nReferences\n\nOWASP Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet\n\nThe Cross-Site Request Forgery (CSRF/XSRF) FAQ\n\n“This paper serves as a living document for Cross-Site Request Forgery issues. This document will serve as a repository of information from existing papers, talks, and mailing list postings and will be updated as new information is discovered.”*"
    }
}