{
    "id": "dbpedia_4771_3",
    "rank": 66,
    "data": {
        "url": "https://catdir.loc.gov/catdir/toc/ecip0711/2007006846.html",
        "read_more_link": "",
        "language": "en",
        "title": "Table of contents for Concepts of programming languages",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://catdir.loc.gov/cgi-bin/Count.cgi?sh=0|ft=1&dd=C|df=toc.dat"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Programming languages (Electronic computers)"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Table of Contents for Concepts of programming languages / Robert W. Sebesta, available from the Library of Congress.",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Table of contents for Concepts of programming languages / Robert W. Sebesta.\n\nBibliographic record and links to related information available from the Library of Congress catalog.\n\nNote: Contents data are machine generated based on pre-publication provided by the publisher. Contents may have variations from the printed book or be incomplete or contain other coding.\n\nContents Chapter 1 Preliminaries 1 1.1 Reasons for Studying Concepts of Programming Languages 2 1.2 Programming Domains 5 1.3 Language Evaluation Criteria 7 1.4 Influences on Language Design 20 1.5 Language Categories 23 1.6 Language Design Trade-offs 24 1.7 Implementation Methods 25 1.8 Programming Environments 33 Summary ¿ Review Questions ¿ Problem Set 34 Chapter 2 Evolution of the Major Programming Languages 39 2.1 Zuse's Plankalkül 40 2.2 Minimal Hardware Programming: Pseudocodes 43 2.3 The IBM 704 and Fortran 45 2.4 Functional Programming: LISP 52 2.5 The First Step Toward Sophistication: ALGOL 60 57 2.6 Computerizing Business Records: COBOL 63 2.7 The Beginnings of Timesharing: BASIC 68 Interview: ALAN COOPER-User Design and Language Design 72 2.8 Everything for Everybody: PL/I 74 2.9 Two Early Dynamic Languages: APL and SNOBOL 78 2.10 The Beginnings of Data Abstraction: SIMULA 67 79 2.11 Orthogonal Design: ALGOL 68 80 2.12 Some Early Descendants of the ALGOLs 82 2.13 Programming Based on Logic: Prolog 90 2.14 History's Largest Design Effort: Ada 92 2.15 Object-Oriented Programming: Smalltalk 97 2.16 Combining Imperative and Object-Oriented Features: C++ 101 2.17 An Imperative-Based Object-Oriented Language: Java 104 2.18 Scripting Languages: JavaScript, PHP, and Python 108 2.19 A C-Based Language for the New Millennium: C# 112 2.20 Markup/Programming Hybrid Languages 115 Summary ¿ Bibliographic Notes ¿ Review Questions ¿Problem Set 117 Chapter 3 Describing Syntax and Semantics 123 3.1 Introduction 124 3.2 The General Problem of Describing Syntax 125 3.3 Formal Methods of Describing Syntax 127 3.4 Attribute Grammars 141 History Note 142 3.5 Describing the Meanings of Programs: Dynamic Semantics 148 History Note 164 Summary ¿ Bibliographic Notes ¿ Review Questions ¿ Problem Set ¿ Programming Exercises .......................................................................169 Chapter 4 Lexical and Syntax Analysis 175 4.1 Introduction 176 4.2 Lexical Analysis 177 4.3 The Parsing Problem 181 4.4 Recursive-Descent Parsing 185 4.5 Bottom-Up Parsing 193 Summary ¿ Review Questions ¿ Problem Set ¿Programming Exercises 200 Chapter 5 Names, Bindings, Type Checking, and Scopes 205 5.1 Introduction 206 5.2 Names 207 History Note 207 History Note 208 5.3 Variables 209 History Note 210 5.4 The Concept of Binding 212 Interview: RASMUS LERDORF-Scripting Languages and Other Examples of Slick Solutions 216 5.5 Type Checking 222 5.6 Strong Typing 223 5.7 Type Compatibility 225 History Note 225 5.8 Scope 228 5.9 Scope and Lifetime 237 5.10 Referencing Environments 237 5.11 Named Constants 239 Summary ¿ Review Questions ¿ Problem Set ¿ Programming Exercises ....242 Chapter 6 Data Types 251 6.1 Introduction 252 6.2 Primitive Data Types 253 6.3 Character String Types 256 History Note 258 6.4 User-Defined Ordinal Types 261 6.5 Array Types 266 History Note 267 History Note 269 6.6 Associative Arrays 279 Interview: RASMUS LERDORF-The Open Source Movement and Work Life 280 6.7 Record Types 284 6.8 Union Types 288 6.9 Pointer and Reference Types 292 History Note 296 Summary ¿ Bibliographic Notes ¿ Review Questions ¿ Problem Set ¿Programming Exercises 305 Chapter 7 Expressions and Assignment Statements 311 7.1 Introduction 312 7.2 Arithmetic Expressions 313 History Note 320 7.3 Overloaded Operators 321 7.4 Type Conversions 323 History Note 324 7.5 Relational and Boolean Expressions 326 History Note 326 7.6 Short-Circuit Evaluation 329 7.7 Assignment Statements 330 History Note 333 7.8 Mixed-mode Assignment 334 Summary ¿ Review Questions ¿ Problem Set ¿ Programming Exercises ....335 Chapter 8 Statement-Level Control Structures 341 8.1 Introduction 342 8.2 Selection Statements 343 History Note 344 History Note 346 8.3 Iterative Statements 352 History Note 354 Interview: LARRY WALL-Part 1: Linguistics and the Birth of Perl 362 8.4 Unconditional Branching 366 History Note 366 8.5 Guarded Commands 367 8.6 Conclusions 371 Summary ¿ Review Questions ¿ Problem Set ¿Programming Exercises 372 Chapter 9 Subprograms 377 9.1 Introduction 378 9.2 Fundamentals of Subprograms 378 9.3 Design Issues for Subprograms 385 9.4 Local Referencing Environments 385 9.5 Parameter-Passing Methods 387 Interview: LARRY WALL-Part 2: Scripting Languages in General and Perl in Particular 388 History Note 396 History Note 397 History Note 401 9.6 Parameters That Are Subprogram Names 408 History Note 409 9.7 Overloaded Subprograms 410 9.8 Generic Subprograms 411 9.9 Design Issues for Functions 417 9.10 User-Defined Overloaded Operators 418 9.11 Coroutines 419 History Note 419 Summary ¿ Review Questions ¿ Problem Set ¿Programming Exercises 421 Chapter 10 Implementing Subprograms 427 10.1 The General Semantics of Calls and Returns 428 10.2 Implementing \"Simple\" Subprograms 429 10.3 Implementing Subprograms with Stack-Dynamic Local Variables 431 10.4 Nested Subprograms 439 Interview: NIKLAUS WIRTH-Keeping It Simple 440 10.5 Blocks 447 10.6 Implementing Dynamic Scoping 449 Summary ¿ Review Questions ¿ Problem Set 453 Chapter 11 Abstract Data Types and Encapsulation Constructs 459 11.1 The Concept of Abstraction 460 11.2 Introduction to Data Abstraction 461 11.3 Design Issues for Abstract Data Types 463 11.4 Language Examples 464 Interview: BJARNE STROUSTRUP-C++: Its Birth, Its Ubiquitousness, and Common Criticisms .466 11.5 Parameterized Abstract Data Types 478 11.6 Encapsulation Constructs 481 11.7 Naming Encapsulations 484 Summary ¿ Review Questions ¿ Problem Set ¿Programming Exercises 488 Chapter 12 Support for Object-Oriented Programming 493 12.1 Introduction 494 12.2 Object-Oriented Programming 494 12.3 Design Issues for Object-Oriented Languages 497 12.4 Support for Object-Oriented Programming in Smalltalk 502 12.5 Support for Object-Oriented Programming in C++ 504 Interview: BJARNE STROUSTRUP-On Paradigms and Better Programming 506 12.6 Support for Object-Oriented Programming in Java 514 12.7 Support for Object-Oriented Programming in C# 517 12.8 Support for Object-Oriented Programming in Ada 95 519 12.9 The Object Model of JavaScript 524 12.10 Implementation of Object-Oriented Constructs 527 Summary ¿ Review Questions ¿ Problem Set ¿Programming Exercises 530 Chapter 13 Concurrency 535 13.1 Introduction 536 13.2 Introduction to Subprogram-Level Concurrency 539 13.3 Semaphores 543 History Note 543 13.4 Monitors 548 13.5 Message Passing 550 13.6 Ada Support for Concurrency 551 13.7 Java Threads 562 13.8 C# Threads 570 13.9 Statement-Level Concurrency 572 Summary ¿ Bibliographic Notes ¿ Review Questions ¿ Problem Set ¿ Programming Exercises 574 Chapter 14 Exception Handling and Event Handling 579 14.1 Introduction to Exception Handling 580 History Note 584 14.2 Exception Handling in Ada 586 14.3 Exception Handling in C++ 593 14.4 Exception Handling in Java 597 Interview: JAMES GOSLING-The Birth of Java 600 14.5 Introduction to Event Handling 607 14.6 Event Handling with Java 608 Summary ¿ Bibliographic Notes ¿ Review Questions ¿ Problem Set .........614 Chapter 15 Functional Programming Languages 619 15.1 Introduction 620 15.2 Mathematical Functions 621 15.3 Fundamentals of Functional Programming Languages 623 15.4 The First Functional Programming Language: LISP 624 15.5 An Introduction to Scheme 628 15.6 COMMON LISP 645 15.7 ML 645 15.8 Haskell 649 15.9 Applications of Functional Languages 653 15.10 A Comparison of Functional and Imperative Languages 653 Summary ¿ Bibliographic Notes ¿ Review Questions ¿ Problem Set ¿ Programming Exercises 654 Chapter 16 Logic Programming Languages 659 16.1 Introduction 660 16.2 A Brief Introduction to Predicate Calculus 660 16.3 Predicate Calculus and Proving Theorems 664 16.4 An Overview of Logic Programming 666 16.5 The Origins of Prolog 668 16.6 The Basic Elements of Prolog 669 16.7 The Deficiencies of Prolog 684 16.8 Applications of Logic Programming 689 Summary ¿ Bibliographic Notes ¿ Review Questions ¿ Problem Set ¿ Programming Exercises .......................................................................691 Bibliography 695 Index\n\nLibrary of Congress Subject Headings for this publication:"
    }
}