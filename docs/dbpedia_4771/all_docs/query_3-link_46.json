{
    "id": "dbpedia_4771_3",
    "rank": 46,
    "data": {
        "url": "https://lolyluli.wordpress.com/2014/10/15/problem-set-chapter-3/",
        "read_more_link": "",
        "language": "en",
        "title": "Concept of Programming Languages by Robert W. Sebesta (Q&A) – Chapter 2",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://1.gravatar.com/avatar/a3c04de477a5954c0b2f964c0701e0d41294287f355dc3d140e3761c2d4a0c05?s=60&d=identicon&r=G",
            "https://1.gravatar.com/avatar/a3c04de477a5954c0b2f964c0701e0d41294287f355dc3d140e3761c2d4a0c05?s=32&d=identicon&r=G",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2014-10-15T00:00:00",
        "summary": "",
        "meta_description": "14. What are the arguments both for and against the idea of a typeless language? Arguments for the idea: Flexibility, Brevity of syntax. It places stricter controls on what objects can receive and send, so making it easier to enforce design strategies throughout the application. When there are errors in types, there can be picked…",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "lolyluli",
        "canonical_link": "https://lolyluli.wordpress.com/2014/10/15/problem-set-chapter-3/",
        "text": "14. What are the arguments both for and against the idea of a typeless language?\n\nArguments for the idea:\n\nFlexibility, Brevity of syntax. It places stricter controls on what objects can receive and send, so making it easier to enforce design strategies throughout the application. When there are errors in types, there can be picked up during precompilation or in the IDE.\n\nArguments against the idea:\n\nWithout type checking, there is no means to verify the integrity of the data without executing the application. The syntax of typed languages can be viewed as overly long or verbose. Typed languages aren’t as flexible as untyped languages, as data structures need to be cast to the correct type before another object can receive them. It is also said that by using typed languages, the compiler spends less time dynamically typing objects and so executes faster. However, this point is a grey area and that the main area of argument is how these language differences play out when designing applications where more then a few people are working on the code.\n\n15. Are there any logic programming languages other than Prolog?\n\nYes, there are Fortran, C++, COBOL, Algol.\n\n16. What is your opinion of the argument that languages that are too complex are too dangerous to use, and we should therefore keep all languages small and simple?\n\nLanguages are too complex are too dangerous to use because of its meaning itself. Ambiguous languages can cause trouble and misunderstanding among people.So, we must keep it small and simple to avoid ambiguous and misunderstanding.\n\n17. Do you think language design by committee is a good idea? Support your opinion.\n\nLanguage design by committee definitely has its advantages, with varying points of view from different domains, different programming backgrounds, and even different language backgrounds all contributing for the better of the language like ALGOL 58. Knowledge of Plankalkul enhanced ALGOL 58 because members from Europe were familiar with the language. Improvements like variable length identifiers and array dimensions were improved upon previous languages. Even though many arguments and conflicts arise, like whether to use a comma (European) or a period (American) for a decimal point took place, it is beneficial to have options. I think history would show that the best use of committees would be after a language has been invented and accepted. At this point a better evaluation is possible and committee members would be better conditioned to make improvements than initial discoveries.\n\n18. Languages continually evolve. What sort of restrictions do you think are appropriate for changes in programming languages? Compare your answers with the evolution of Fortran."
    }
}