{
    "id": "dbpedia_4771_2",
    "rank": 1,
    "data": {
        "url": "https://forem.julialang.org/ndx/where-do-we-go-next-from-here-with-programming-languages-3ec2",
        "read_more_link": "",
        "language": "en",
        "title": "Where do we go next from here with programming languages?",
        "top_image": "https://forem.julialang.org/images/EfMDG8BVcB1NfnHz9Do-mhMCtGnxzJUKwGjbeT4ovng/rs:fill:1000:500/g:sm/mb:500000/ar:1/aHR0cHM6Ly9mb3Jl/bS5qdWxpYWxhbmcu/b3JnL3JlbW90ZWlt/YWdlcy91cGxvYWRz/L2FydGljbGVzL2I2/Mm5zNnpzMWtqYjE3/Ymp6amk4LmpwZw",
        "meta_img": "https://forem.julialang.org/images/EfMDG8BVcB1NfnHz9Do-mhMCtGnxzJUKwGjbeT4ovng/rs:fill:1000:500/g:sm/mb:500000/ar:1/aHR0cHM6Ly9mb3Jl/bS5qdWxpYWxhbmcu/b3JnL3JlbW90ZWlt/YWdlcy91cGxvYWRz/L2FydGljbGVzL2I2/Mm5zNnpzMWtqYjE3/Ymp6amk4LmpwZw",
        "images": [
            "https://forem-bce91056d27d.forem.cloud/remoteimages/uploads/logos/resized_logo_CFnt9o1904mD7GeQihh4.png",
            "https://forem.julialang.org/assets/heart-plus-active-9ea3b22f2bc311281db911d416166c5f430636e76b15cd5df6b3b841d830eefa.svg",
            "https://forem.julialang.org/assets/sparkle-heart-5f9bee3767e18deb1bb725290cb151c25234768a0e9a2bd39370c382d02920cf.svg",
            "https://forem.julialang.org/assets/multi-unicorn-b44d6f8c23cdd00964192bedc38af3e82463978aa611b4365bd33a0f1f4f3e97.svg",
            "https://forem.julialang.org/assets/exploding-head-daceb38d627e6ae9b730f36a1e390fca556a4289d5a41abb2c35068ad3e2c4b5.svg",
            "https://forem.julialang.org/assets/raised-hands-74b2099fd66a39f2d7eed9305ee0f4553df0eb7b4f11b01b6b1b499973048fe5.svg",
            "https://forem.julialang.org/assets/fire-f60e7a582391810302117f987b22a8ef04a2fe0df7e3258a5f49332df1cec71e.svg",
            "https://forem.julialang.org/images/g_3LMGZPTFtmjWrYKzSVeobElnU_07RZ-RSNfUPhr0Y/rs:fill:1000:420/g:sm/mb:500000/ar:1/aHR0cHM6Ly9mb3Jl/bS5qdWxpYWxhbmcu/b3JnL3JlbW90ZWlt/YWdlcy91cGxvYWRz/L2FydGljbGVzL2I2/Mm5zNnpzMWtqYjE3/Ymp6amk4LmpwZw",
            "https://forem.julialang.org/images/OeRMPMs-0MVGK8xwRkjFWBvzE6Q1uAvGybGvT4iFoMg/rs:fill:50:50/g:sm/mb:500000/ar:1/aHR0cHM6Ly9mb3Jl/bS5qdWxpYWxhbmcu/b3JnL3JlbW90ZWlt/YWdlcy91cGxvYWRz/L3VzZXIvcHJvZmls/ZV9pbWFnZS82MjIv/OWZiNTUzNjMtNGZj/ZS00NzNmLWJiYTUt/MGYyYzNkNjEzODg1/LnBuZw",
            "https://forem.julialang.org/assets/sparkle-heart-5f9bee3767e18deb1bb725290cb151c25234768a0e9a2bd39370c382d02920cf.svg",
            "https://forem.julialang.org/assets/multi-unicorn-b44d6f8c23cdd00964192bedc38af3e82463978aa611b4365bd33a0f1f4f3e97.svg",
            "https://forem.julialang.org/assets/exploding-head-daceb38d627e6ae9b730f36a1e390fca556a4289d5a41abb2c35068ad3e2c4b5.svg",
            "https://forem.julialang.org/assets/raised-hands-74b2099fd66a39f2d7eed9305ee0f4553df0eb7b4f11b01b6b1b499973048fe5.svg",
            "https://forem.julialang.org/assets/fire-f60e7a582391810302117f987b22a8ef04a2fe0df7e3258a5f49332df1cec71e.svg",
            "https://forem.julialang.org/images/S67V3CJtf3eEry3GBBCq_L7xklvkV6EBpkYESK2aqUQ/rt:fit/w:256/g:sm/mb:500000/ar:1/aHR0cHM6Ly9mb3Jl/bS1iY2U5MTA1NmQy/N2QuZm9yZW0uY2xv/dWQvcmVtb3RlaW1h/Z2VzL3VwbG9hZHMv/YXJ0aWNsZXMvNXo3/a3Z4c3d4ZmNjMWxp/MGNoM2gucG5n",
            "https://forem.julialang.org/images/7a1KvI1h33hX1FZJz0bOKhPgbkW93ap387-2qIU9ooY/rs:fill:90:90/g:sm/mb:500000/ar:1/aHR0cHM6Ly9mb3Jl/bS5qdWxpYWxhbmcu/b3JnL3JlbW90ZWlt/YWdlcy91cGxvYWRz/L3VzZXIvcHJvZmls/ZV9pbWFnZS82MjIv/OWZiNTUzNjMtNGZj/ZS00NzNmLWJiYTUt/MGYyYzNkNjEzODg1/LnBuZw",
            "https://forem.julialang.org/images/TC-ooJOdsCNflVPpWROlQjEiRtoQaPUCRwhNHTBvgh4/rt:fit/w:190/g:sm/q:80/mb:500000/ar:1/aHR0cHM6Ly9mb3Jl/bS1iY2U5MTA1NmQy/N2QuZm9yZW0uY2xv/dWQvcmVtb3RlaW1h/Z2VzL3VwbG9hZHMv/YXJ0aWNsZXMvNXo3/a3Z4c3d4ZmNjMWxp/MGNoM2gucG5n",
            "https://forem.julialang.org/assets/sparkle-heart-5f9bee3767e18deb1bb725290cb151c25234768a0e9a2bd39370c382d02920cf.svg",
            "https://forem.julialang.org/assets/multi-unicorn-b44d6f8c23cdd00964192bedc38af3e82463978aa611b4365bd33a0f1f4f3e97.svg",
            "https://forem.julialang.org/assets/exploding-head-daceb38d627e6ae9b730f36a1e390fca556a4289d5a41abb2c35068ad3e2c4b5.svg",
            "https://forem.julialang.org/assets/raised-hands-74b2099fd66a39f2d7eed9305ee0f4553df0eb7b4f11b01b6b1b499973048fe5.svg",
            "https://forem.julialang.org/assets/fire-f60e7a582391810302117f987b22a8ef04a2fe0df7e3258a5f49332df1cec71e.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "ndx"
        ],
        "publish_date": "2022-07-12T16:43:02+00:00",
        "summary": "",
        "meta_description": "Once upon a time - exactly 74 years ago - a man born in Berlin, Prussia, at the time of the German...",
        "meta_lang": "en",
        "meta_favicon": "https://forem.julialang.org/images/Vz_KiBFa44eSIr6ZGIchzGfaXYrJpEbM_cqRgerBecw/rt:fit/w:32/g:sm/mb:500000/ar:1/aHR0cHM6Ly9mb3Jl/bS1iY2U5MTA1NmQy/N2QuZm9yZW0uY2xv/dWQvcmVtb3RlaW1h/Z2VzL3VwbG9hZHMv/YXJ0aWNsZXMvZWlu/Nms0Yzg2Y2RnNjhv/bGR2ZncucG5n",
        "meta_site_name": "Julia Community ðŸŸ£",
        "canonical_link": "https://forem.julialang.org/ndx/where-do-we-go-next-from-here-with-programming-languages-3ec2",
        "text": "Once upon a time - exactly 74 years ago - a man born in Berlin, Prussia, at the time of the German Empire, published the first concept of what we call today as a \"high-level programming language\". But wait, a lot happened before then.\n\nHistory has it that after he graduated, he went to work for one of the big motor companies of his time, using his artistic skills in the design of advertisements. He also worked as a design engineer at one aircraft factory in a place near Berlin. This required the performance of many routine calculations by hand, leading him to theorise and plan a way of doing them by machine.\n\nThis man, who later in the twilight of his days on earth would die from a heart attack, was a self-taught, and built and developed a lot of his works without knowledge about other mechanical computing machines that existed already. Although he would later go on to build on existing discoveries and technologies, between 1936 and 1945 he was in near-total isolation; he completed his work entirely independently of other leading computer scientists and mathematicians of his day.\n\nIt was in 1945, after the Luisenstadt bombing, that he fled from Berlin to the rural AllgÃ¤u. In the extreme deprivation of post-war Germany, he was unable to build computers. Unable to continue building computers - which was also forbidden by the Allied Powers - he devoted his time to the development of a higher-level programming model and language.\n\nIn 1948 he published a paper and presented it at one of the annual meetings of his time. His work failed to attract much attention. In a 1957 lecture, he expressed his hope that the higher level programming language he had created, \"after some time as a Sleeping Beauty, will yet come to life.\" He expressed disappointment that the designers of another programming language, who used most of his works never acknowledged the influence of high level programming language on their own work.\n\nThe man we've been taking about is Konrad Zuse, and PlankalkÃ¼l was the name of the higher level programming language he built, which was essentially made for engineers. ALGOL 58 was the programming language designed with most of his work, but the developers never acknowledged the influence of PlankalkÃ¼l on it.\n\nPlankalkÃ¼l was more comprehensively published[vague] in 1972. The first compiler was implemented by Joachim Hohmann in his 1975 dissertation. Other independent implementations followed in 1998 and 2000 at the Free University of Berlin, history continues of course, but we will end there for now.\n\nTo know where we are going we somehow need to know where we are coming from - and that story was introduced just as a way to take us back a little to see where this \"higher level programming language\" thing started and where it's likely to go.\n\nThere are currently more than 700 programming languages out there as at this time of writing. Some are low level, most are high level. Some designed for speed, others designed for simplicity. Some designed for security, others designed for low-level interactions, and the list goes on and on and on.\n\nGo out now and ask someone with no computer programming language: how many programming languages do we have? Let them make an educated guess with the knowledge of how they see the computer world, chances are they would all answer in the range of 0 - 10. The ones who answer in the range of 20 - 50 would be waiting to get a response back from you that he/she was wrong. Chances are as well, that if you should make an educated guess now, you might get it completely wrong as well. The vague answer is that there are over 700 programming languages. WOW!!!!\n\nI failed it as well, it was only by \"googling\" that I came to know of this unimaginable number. Now, the question is: why 700? why not 1? why not 5? why not 10? why not even 20? how come its over 700?ðŸ˜±. That's an open question, so discuss it with your friends.\n\nMy view is this: there are over 700 but are all 700 being massively used. Of course, that's a simple NO. If all 700 are not being used, why do they exist? They exist because there's an informal law in computer programming: \"programming languages are only created, they cannot be destroyed.\"\n\nBut why can't they be destroyed? Because the trend is: learn programming and then fall in love with a language. Then technology advances and you know we can no longer use your \"loving language\" efficiently anymore as the current world demands something with a different philosophy, which your loving language can do if tweaked, but wasn't designed for, but you choose to continue using it and only use a different language when your job requires it. So you see, we can only create but not destroy, because every creation gathers a fan base which won't let it die, no matter its age - PlankalkÃ¼l is a case in point, as its still being used.\n\nBut that doesn't answer the question of this article - where do we go next from here with programming languages? Honestly, speaking technology is one sweet field where advances are great (and they would always come), only if it won't hurt or demand you to learn something kinda entirely new or change your current perspectives and beliefs. The golden question now is this: if the man/woman who created your programming language \"loved\" the language they learnt programming with so much that it blinded them to see a change or think in a new paradigm, do you think we would have seen another high-level programming language other than PlankalkÃ¼l ?\n\nWould there have been Python, if Van Rossum so loved BASIC, or would there have been C++ if Bjarne so loved C, or would there have been Julia if Viral could only see Lisp, and the list goes on and on and on. The point is technology itself is built on ADVANCEMENT, so no matter how much you love a language, know its only going to be for a while or if you're lucky enough, your whole lifetime; but no matter how hard you try, your kids won't use what you use, or even if they used what you use, they won't use it in the same way that you used it - that's how technology works, so embrace it.\n\nBut still the question is not answered yet - where do we go next from here with programming languages? Where we go next from here depends on two things:\n\nA body would be set up to regulate the creation of programming languages.\n\nNew languages won't be created except they're coming with a completely different philosophy.\n\nNow think for a moment if advancement and discoveries was regulated? Would there be any \"outside-the-box\" discoveries accepted. Of course the answer is NO. History shows how regulation only helps in maintaining moral conducts and order but kills imagination and discoveries into new areas; this is the reason our school system still thinks \"grading students\" has been the norm and so is good, even when mathematically and statistically speaking, grades are no projection into the future of any child, as countless evidences has shown, and rather than helping students, it kills their morale and makes some feel like losers. The truth is if there was a regulation (which there won't be) in the technology space to control new discoveries, the world would have been a boring place, as we would have only seen ways on how to improve the post office system instead of envisioning an \"email\" along with it.\n\nC++ was designed with \"classes\" in mind. So its built on the already existing ideas of \"C\" but with \"classes\" included. So can we say \"classes\" is a whole different philosophy to enforce the creation of a new language. If its not, why don't we just extend the language \"C\", so it accepts the \"class\" idea and then we don't need a new language, but simply have one with two design philosophy? The answer to this question is a question: a car can drive in a blazing speed and take us where we want to in a small time and with comfort compared to if had to walk by foot. The aeroplane can fly us to where we want to in a small time and with comfort compared to if we had to walk or drive a car. But if a car \"can take us in a small time and with comfort\" to where we want compared to if we walk by foot, why do we need an aeroplane then? Why not just add to the design of a car so it can fly, and then we only need one device, just a car? Until you can answer this question with the car and aeroplane analogy, you can't answer the question with C and C++.\n\nThe truth is \"design and philosophy\" is very different from \"features and abilities\". \"Features and abilities\" build on pre-existing \"design and philosophy\", but then \"design and philosophy\" are completely built on new \"ideas and thought process.\" There is no difference between a Tesla car and a Ferrari, except the features and abilities. So we only needed a Ferrari when we needed new features, for this we do not need a new device, we simply have to build on the \"pre-existing design and philosophy\" of a car. But when it comes to an aeroplane, it brings a new idea - the idea of objects being able to fly in the air. That's a whole new \"though process\". So you see, its best if we come down and think of how to make \"objects\" fly instead of how to make a \"car\" fly. Then we finally did it, the name doesn't matter - we could have called an aeroplane a \"flying car\", what matters is the different idea an aeroplane has. This is how it is too with programming languages.\n\nYes, there are languages with \"features and abilities\" which in the true sense the developers should have thought of contributing to the orginal languages they borrowed the idea from, instead of creating a new one - but we humans know how we all want something called \"our\" own, instead of I built \"their\" own: this is the reason there are many programming languages in the world today, not the design and philosophy thing. Its good to know C++ was designed for classes and C for procedural. So when a use case comes for each design, I know where to go to.\n\nThe question then is if we have very limited programming paradigms and concepts, how come we have over 700 languages as if we're on planet talking to humans, when in its true sense we're only talking to a computer? The reason is the \"features and abilities\" that leads to new programming languages instead of developing already existing ones when its just \"features and designs\". Of course we all caused it, when we started attributing programming languages to \"owners\", \"creators\", etc. If there was no \"creator\" or \"owner\" to a programming language, then the idea of contribution would have been easy for us humans. Look at the earth, imagine if only Mr. A owned planet earth, we would all have seen this has a place to just dump and go, but because we see it as for \"humanity\" as a whole, we all contribute to its good. So this is one area in the future where open source can go to, an area where there are only \"contributors\" and no \"creators\", \"owners\" or \"founders\" exists.\n\nStill the question yet is not answered: where do we go next from here with programming languages. I think now I can answer in my view. The programming languages numbers would keep surging at a rate probably 100 against new programming paradigms or concepts, as the creation of any programming paradigm leads to at least 100 programming languages with same \"design and philosophy\" but different \"features and abilities\", i.e, programming languages : programming paradigms is at a ratio of 100:1.\n\nSecondly programming paradigms and new concepts would be getting diminished as a lot of emphasis would be on languages instead of new paradigms that would help the technical computing community. This is of course is my view and it can be wrong.\n\nFinally I want to speak on Julia vs Python? Comparing this two languages is like comparing an aeroplane to a car. They both have one purpose: take us to where we want to in quick time and comfort than if we would work. But with different \"design and philosophy\", one moves on the land and is quick compared to a human foot, the other moves on the air, and is quickest compared to the car and a human foot.\n\nSo you sit there and ask? Should I switch to Julia from Python, or go learn C++, or even ruby. C++ is a programming language used to talk on a lower-level with the computer. It is still popular because of an idea I call \"diminishing-increasing dependency\". Diminishing-Increasing dependency is a concept where we are going away from something, but haven't found other alternatives to fully replace it, so the more we go away from it looking for other alternatives, the more we rely on it. Check the last 100 programming languages designed, and you'd see what I'm talking about: the syntax is so different from C++, that you wouldn't even think any programming language should look like C++ do.\n\nBut the truth is, yes the generation we're slowly moving into does not want a program to be \"dirty\" like C++ even when it does the work, we want something we can read to somebody else and still give the computer to execute it. But the truth is, the computer is still at a stage where it only understands 0's and 1's - so C++ is the language that interacts with it so closely at that level, hence the more better a language we look for, the more C++ we would be using. So C++ would keep getting popular as it has no competitor, because no languages are being develop that way to be \"dirty\" anymore, just so it can talk on a lower-level with a computer. So you see modern languages having more competitors than old languages like FORTRAN, COBOL, C and C++, because no one is building languages in that style anymore - and the more we look for the perfect language, the more we have to depend on the only ones we have for now that can talk to a computer in a very close way - \"Diminishing-Increasing Dependency\".\n\nOf course, 100 years from now, C++ and its counterparts would all be gone in a way and would only be used as legacy languages, because we would have developed the computer to a stage where it can take human-readable code and still be fast and even faster than C++ and its counterpart would have been - Is 100 years too much an exaggeration? Well, just give it any number, but one thing is sure, its not happening in your time if you're old enough to read this as at the time of writing.\n\nNow back to Python and Julia. If you're an avid Python lover, do you belief deep down 20 years from now, we would all still be depending on Python to run numerical simulations? Well the future would tell anyway, but sure we know the answer in a way.\n\nThe truth is we can't depend on Python for numerical simulations 10, 20, 30 years from now. The language wasn't designed for \"speed\" and \"numerical computing\". It was designed for \"readability\" and \"general use\". Every day, data is being flooded out into the space, and we want something a bit faster and one that makes lives easier as well. Python is a great language but it just got into a community that would come back to bite it. Numerical computing is not \"general use\", it needs to be \"fast\", and that's a first requirement. Then it needs to embrace the mathematical world and breathe it. Python itself does not have any one of these traits, it only works as an interface after the work is done inside by other core languages - making you worry over learning another language if you have an idea that's worth building from scratch and is very time intensive.\n\nNow when you come to Julia, you could in a way exaggerate that the 100 years I said above is finally here. It gives you the speed and even more than the speed C++ would give you (this is still largely debatable) along with the readability. So in a sense, Julia is the 21-st century language, as it seeks to finally make C++ and its counterpart obsolete. So you see, Python is no comparable to Julia, Julia is competing with C++ and counteparts we all know that, but as for Python, it is just too small for it - the fact that the community hasn't fully accepted Julia yet doesn't makes Python anywhere near it; Julia is just waiting for full industry acceptance. Python is only there because of its uncountable libraries available (libraries mostly developed outside the language f its does a lot of intensive work) and community base it has over Julia, not the language itself\n\nJulia beats C++ speed on some instance and also breathes and lives the math world. You can use 'âˆš' to represent a square root and its valid code. 2x - 5y + 4x * 23y is valid Julia code. This is just a pinch of how it lives for the mathematical world - so your kids would grow up to see that just as we understand \"2x - 5y\", the computer understands it as well. Of course, python can add that if it chooses, but the point is, it wasn't designed for that - you want to be on an aeroplane flying and not a car that was tweaked so it can fly."
    }
}