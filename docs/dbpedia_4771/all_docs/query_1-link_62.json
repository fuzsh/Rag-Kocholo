{
    "id": "dbpedia_4771_1",
    "rank": 62,
    "data": {
        "url": "https://www.slideserve.com/adara/software-ii-principles-of-programming-languages",
        "read_more_link": "",
        "language": "en",
        "title": "Software II: Principles of Programming Languages PowerPoint Presentation",
        "top_image": "https://cdn2.slideserve.com/4459036/software-ii-principles-of-programming-languages-n.jpg",
        "meta_img": "https://cdn2.slideserve.com/4459036/software-ii-principles-of-programming-languages-n.jpg",
        "images": [
            "https://www.slideserve.com/img/logo.svg",
            "https://cdn2.slideserve.com/4459036/software-ii-principles-of-programming-languages-n.jpg",
            "https://www.slideserve.com/photo/32338.jpeg",
            "https://www.slideserve.com/img/output_cBjjdt.gif",
            "https://cdn0.slideserve.com/52113/concepts-of-programming-languages-dt.jpg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg",
            "https://www.slideserve.com/img/preload-bg.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2014-09-16T00:00:00",
        "summary": "",
        "meta_description": "Software II: Principles of Programming Languages. Lecture 2 – A History of Programming Languages. What is a Programming Language?. A programming language describes computation to be performed by computers. Slideshow 4459036 by adara",
        "meta_lang": "en",
        "meta_favicon": "https://www.slideserve.com/img/favicon.ico",
        "meta_site_name": "SlideServe",
        "canonical_link": "https://www.slideserve.com/adara/software-ii-principles-of-programming-languages",
        "text": "Software II: Principles of Programming Languages Lecture 2 – A History of Programming Languages\n\nWhat is a Programming Language? • A programming language describes computation to be performed by computers. • Programming languages have a history that parallels the development of computers and a history that is independent of computer development. • Konrad’s Zuse’s Plankalkül • Alonzo Church’s lambda calculus\n\nProgramming Languages Describe Algorithms • The need to describe calculations is ancient: A cistern. The length equals the height. A certain volume of dirt has been excavated. The cross-sectional area plus this volume comes to 120. The length is 5. What is the width? Add 1 to 5, giving 6. Divide 6 into 120, obtaining 20. Divide 5 into 20, obtaining the width, 4. This is the procedure. • Why does this work?\n\nThe Math Behind the Description Volume + Cross-section = L W H + L W = L2 W + L W = L W ( L + 1) = 5 W ( 5 + 1) = 5 W ( 6) = 120\n\nEarly History – The First Programmer • The First Stored-Program Computer to be designed was Charles Babbage’s Analytical Engine (the store-program computer to be completed was the UNIVAC in 1951). • The first computer program to be written was by Babbage’s collaborator Ada, Countess of Lovelace in the 1840s.\n\nZuse’s Plankalkül • Designed in 1945, but not published until 1972 • Never implemented • Advanced data structures • Floating point numbers, arrays, records • Invariants – mathematical expressions rthat would be true during execution at the points in the code where they appeared.\n\nPlankalkül Syntax • An assignment statement to assign the expression A[4] + 1 to A[5] | A + 1 => A V | 4 5 (operand subscripts) S | 1.n 1.n (data types – n-bit integers)\n\nThe 1950s - The First Programming Languages Originally, all programming was done using the machine’s own language, i.e., the binary code native to the CPU. • This led to many mistakes which took a great deal of time to locate and correct. • Eventually, programmers started using symbolic names for opcodes and operands to make it easier to program and then they would hand-translate.\n\nThe First Programming Languages (continued) • Eventually, assemblers were written to automate the translations of these symbolic programs into machine language. • The success of assembly languages encouraged computer scientists to develop higher-level languages which could further simplify the programming process.\n\nNumerically-Based Languages • Many of the earliest computers were used almost exclusively for scientific calculations and consequently many of the earliest attempts at languages were for scientific purposes. • Mauchly’s Short Code, Grace Murray Hopper’s A-0 and John Backus’s Speedcoding were designed to compile simple arithmetic expressions.\n\nFORTRAN • John Backus’s team at IBM developed FORTRAN (for FORmula TRANslator) in 1955-1957. • While FORTRAN was designed for numerical computation, it included control structures, conditions and input/output. • FORTRAN’s popularity led to FORTRAN II in 1958, FORTRAN IV in 1962, leading to its standardization in 1966, with revised standards coming out in 1977 and 1990.\n\nA Program In FORTRAN C FORTRAN EXAMPLE PROGRAM C INPUT: AN INTEGER, LIST_LEN, WHERE LIST_LEN IS LESS C THAN 100, FOLLOWS BY LIST_LEN-INTEGER VALUES C OUTPUT: THE NUMBER OF INPUT VALUES THAT ARE GREATER C THAN THE AVERAGE OF ALL INPUT VALUES DIMENSION INTLST(99) IMPLICIT INTEGER(A, C, R, S) RESULT = 0 SUM = 0 READ(5,501) LSTLEN 501 FORMAT(I3) IF (LSTLEN) 106, 106, 101 IF (LSTLEN - 100) 101, 106, 106 101 CONTINUE C READ INPUT DATA INTO AN ARRAY AND COMPUTE ITS SUM DO 102 COUNTR = 1, LSTLEN READ(5,502) INTLST(COUNTR) 502 FORMAT(I4)\n\nSUM = SUM + INTLST(COUNTR) 102 CONTINUE C COMPUTE THE AVERAGE AVERGE = SUM / LSTLEN C COUNT THE VALUES THAT ARE GREATER THAN THE AVERAGE DO 103 COUNTR = 1, LSTLEN IF (INTLST(COUNTR) - AVERGE)103, 103, 104 104 CONTINUE RESULT = RESULT + 1 103 CONTINUE C PRINT THE RESULT WRITE(6,503) RESULT 503 FORMAT(33H NUMBER OF VALUES .GT. AVERAGE IS, I2) 106 CONTINUE WRITE(6,504) 504 FORMAT(39H ERROR - LIST LENGTH VALUE IS NOT, 1 6H LEGAL) RETURN END\n\nA Program in FORTRAN IV C FORTRAN EXAMPLE PROGRAM C INPUT: AN INTEGER, LISTLEN, WHERE LISTLEN IS LESS C THAN 100, FOLLOWS BY LISTLEN-INTEGER VALUES C OUTPUT: THE NUMBER OF INPUT VALUES THAT ARE GREATER C THAN THE AVERAGE OF ALL INPUT VALUES INTEGER INTLST(99) INTEGER LSTLEN, COUNTR, SUM, AVERGE, RESULT RESULT = 0 SUM = 0 READ(*,*) LSTLEN IF ((LSTLEN .LE. 0) .OR. (LSTLEN .GE. 100)) 1 GOTO 104 C READ INPUT DATA INTO AN ARRAY AND COMPUTE ITS SUM DO 101 COUNTR = 1, LSTLEN READ(*,*) INTLST(COUNTR) SUM = SUM + INTLST(COUNTR) 101 CONTINUE\n\nC COMPUTE THE AVERAGE AVERGE = SUM / LSTLEN C COUNT THE VALUES THAT ARE GREATER THAN THE AVERAGE DO 102 COUNTR = 1, LSTLEN IF (INTLST(COUNTR) .LE. AVERGE) GOTO 103 RESULT = RESULT + 1 103 CONTINUE 102 CONTINUE C PRINT THE RESULT WRITE(6,*) 'NUMBER OF VALUE .GT. AVERAGE IS', 1 RESULT 104 CONTINUE WRITE(6,*) 'ERROR - LIST LENGTH VALUE IS NOT’, 1 ‘LEGAL’ RETURN END\n\nA Program in FORTRAN 77 Program Example C Fortran Example program C Input: An integer, ListLen, where ListLen is less C than 100, follows by List_Len-Integer values C Output: The number of input values that are greater C than the average of all input values INTEGER INTLIST(99) INTEGER LISTLEN, COUNTER, SUM, AVERAGE, RESULT RESULT = 0 SUM = 0 READ *, LISTLEN IF ((LISTLEN .GT. 0) .AND. (LISTLEN .LT. 100)) THEN C Read Input data into an array and compute its sum DO 101 COUNTER = 1, LISTLEN READ *, INTLIST(COUNTER) SUM = SUM + INTLIST(COUNTER) 101 CONTINUE\n\nC Compute the average AVERAGE = SUM / LISTLEN C Count the values that are greater than the average DO 102 COUNTER = 1, LISTLEN IF (INTLIST(COUNTER) .GT. AVERAGE) THEN RESULT = RESULT + 1 ENDIF 102 CONTINUE C Print the result PRINT *, 'Number of value .GT. Average is', Result ELSE PRINT *, 'Error - list length value is not legal’ ENDIF END\n\nA Program in Fortran 95 Program Example ! Fortran Example program ! Input: An integer, List_Len, where List_Len ! is less than 100, follows by ! List_Len-Integer values ! Output: The number of input values that are ! greater than the average of all input ! values Implicit none Integer :: Int_List(99) Integer :: List_Len, Counter, Sum, Average, Result Result = 0 Sum = 0 Read *, List_Len\n\nIf ((List_Len > 0) .AND. (List_Len < 100)) Then ! Read Input data into an array and compute its ! sum Do Counter = 1, List_Len Read *, Int_List(Counter) Sum = Sum + Int_List(Counter) End Do ! Compute the average Average = Sum / List_Len ! Count the values that are greater than the ! average Do Counter = 1, List_Len If (Int_List(Counter) > Average) Then Result = Result + 1 End If End Do\n\n! Print the result Print *, 'Number of value > Average is', Result Else Print *, 'Error - list length value is not legal’ End If End Program Example\n\nALGOL • FORTRAN’s success led to fear that IBM would dominate the computer industry. • GAMM and ACM organized committees to design a universal language which merged and developed ALGOL 58 (which led to ALGOL 60 and ALGOL 62). • Many later languages are derivatives of ALGOL, including PL/I, C, Pascal and Ada.\n\nDesign of ALGOL FORTRAN had been designed to run efficiently on an IBM 701; ALGOL had been designed to meet four different goals: • ALGOL notation should be close to standard mathematics • ALGOL should be useful in describing algorithms • Programs in ALGOL should be compilable into machine language. • ALGOL should not be tied to a single computer architecture.\n\nInfluence of ALGOL • While ALGOL saw limited use in the US (and only some in Europe), it made many contributions to other languages: • Backus and Naur developed the notation still used to express language syntax (BNF), based on Chomsky’s context-free language concept. • Burrough’s use of Lukasiwicz’s notation for writing expressions (prefix notation) led to the use of stack-based architectures.\n\nALGOL-60: Example procedure Absmax(a) Size:(n, m) Result:(y) Subscripts:(i, k); value n, m; array a; integer n, m, i, k; real y; comment The absolute greatest element of the matrix a, of size n by m is transferred to y, and the subscripts of this element to i and k; begin integer p, q; y := 0; i := 1; k := 1;\n\nfor p:=1 step 1 until n do for q:=1 step 1 until m do if abs(a[p, q]) > y then begin y := abs(a[p, q]); i := p; k := q end end Absmax\n\nCOBOL • Commercial data processing was one of the earliest commercial applications of computers. • The U.S. Defense Dept. sponsored the effort to develop COBOL (Common Business-Oriented Language), which was standardized in 1960, revised in 1961 & 1962, re-standarized in 1968, 1974, and 1984. • As of 2000, more lines of source code have been written in COBOL than any other programming language.\n\nInfluence of COBOL • Its popularity is due to: • self-documenting style (very English-like) • its record structure makes it easy to organize data • its PICTURE clauses made it easy to format input and output in different ways. • COBOL has been a major influence on most database manipulation languages.\n\nA Program in COBOL IDENTIFICATION DIVISION. PROGRAM-ID. PRODUCE-REORDER-LISTING. ENVIRONMENT DIVISION. CONFIGURATION SECTION. SOURCE-COMPUTER. DEC-VAX. OBJECT-COMPUTER. DEC-VAX. INPUT-OUTPUT SECTION. FILE-CONTROL. SELECT BAL-FWD-FILE ASSIGN TO READER. SELECT REORDER-LISTING ASSIGN TO LOCAL-PRINTER.\n\nDATA DIVISION. FD BAL-FWD-FILE LABEL RECORDS ARE STANDARD. RECORD CONTAINS 80 CHARACTERS. 01 BAL-FWD-CARD. 05 BAL-ITEM-NO PICTURE IS 9(5). 05 BAL-ITEM-DESC PICTURE IS X(20). 05 FILLER PICTURE IS X(5). 05 BAL-UNIT-PRICE PICTURE IS 999V99. 05 BAL-REORDER-POINT PICTURE IS 9(5). 05 BAL-ON-HAND PICTURE IS 9(5). 05 BAL-ON-ORDER PICTURE IS 9(5). 05 FILLER PICTURE IS X(30).\n\nFD REORDER-LISTING LABEL RECORDS ARE STANDARD. RECORD CONTAINS 80 CHARACTERS. 01 REORDER-LINE. 05 RL-ITEM-NO PICTURE IS Z(5). 0F FILLER PICTURE IS X(5). 05 RL-ITEM-DESC PICTURE IS X(20). 05 FILLER PICTURE IS X(5). 05 RL-UNIT-PRICE PICTURE IS ZZZ.99. 05 FILLER PICTURE IS X(5). 05 RL-AVAILABLE-STOCK PICTURE IS Z(5). 05 FILLER PICTURE IS X(5). 05 RL-REORDER-POINT PICTURE IS Z(5). 05 FILLER PICTURE IS X(71).\n\nWORKING-STORAGE SECTION. 01 SWITCHES. 05 CARD-EOF-SWITCH PICTURE X. 01 WORK-FIELDS. 05 AVAILABLE-STOCK PICTURE 9(5). PROCEDURE DIVISION. 1000-PRODUCE-REORDER-LISTING. OPEN INPUT BAL-FWD-FILE. OPEN OUTPUT REORDER-LISTING. MOVE \"N\" TO CARD-EOF-SWITCH. PERFORM 1100-PRODUCE-REORDER-LINE UNTIL CARD-EOF-SWITCH IS EQUAL TO \"Y\". CLOSE BAL-FWD-FILE CLOSE REORDER-LISTING. STOP RUN.\n\n1100-PRODUCE REORDER-LINE. PERFORM 1110-READ-INVENTORY-RECORD. IF CARD-EOF-SWITCH IS NOT EQUAL TO \"Y\" PERFORM 1120-CALCULATE-AVAILABLE-STOCK IF AVAILABLE-STOCK IS LESS THAN BAL-REORDER-POINT PERFORM 1130-PRINT-REORDER-LINE. 1110-READ-INVENTORY-RECORD. READ BAL-FWD-FILE RECORD AT END MOVE \"Y\" TO CARD-EOF-SWITCH. 1120-CALCULATE-AVAILABLE-STOCK. ADD BAL-ON-HAND BAL-ON-ORDER GIVING AVAILABLE-STOCK.\n\n1130 PRINT-REORDER-LINE. MOVE SPACE TO REORDER-LINE. MOVE BAL-ITEM-NO TO RL-ITEM-NO. MOVE BAL-ITEM-DESC TO RL-ITEM-DESC. MOVE BAL-UNIT-PRICE TO RL-UNIT-PRICE. MOVE AVAILABLE-STOCK TO RL-AVAILABLE-STOCK. MOVE BAL-REORDER POINT TO RL-REORDER-POINT WRITE REORDER-LINE.\n\nLISP • John McCarthy of MIT developed LISP (LISt Processor) in the late 1950s to handle list structures in a functional format. • Only two data types: atoms and lists • The language pioneered garbage collection and recursive procedures; its dialects include Scheme. • Because it is not an imperative language, it does not run as efficiently on standard computer architectures. However, there are computer architectures designed for it on which they run more efficiently. • Many major AI programs have been written in LISP.\n\nLISP Lists (A B C D) (A (B C) D (E(F G)))\n\nAPL • APL (A Programming Language) was designed by Ken Iverson to handle scientific computations, especially those involves vectors and matrices. • It has a large set of operators and requires a special character set and is extremely difficult to read.\n\nAPL Keyboard Layout\n\nSample APL Program (~R∊R∘.×R)/R←1↓⍳R Executed from right to left, this means: • ιR creates a vector containing integers from 1 to R • (if R = 6 at the beginning of the program, ιR is 1 2 3 4 5 6) • Drop first element of this vector (↓ function), i.e. 1. So 1↓ιR is 2 3 4 5 6 • Set R to the new vector (←, assignment primitive), i.e. 2 3 4 5 6\n\nA Program in PL/I /* PL/I PROGRAM EXAMPLE INPUT: AN INTEGER, LISTLEN, WHERE LISTLEN IS LESS THAN 100, FOLLOWED BY LISTLEN-INTEGER VALUES OUTPUT:THE NUMBER OF INPUT VALUES THAT ARE GREATER THAN THE AVERAGE OF ALL INPUT VALUES */ PLIEX: PROCEDURE OPTIONS(MAIN); DECLARE INTLIST(1:99) FIXED; DCL (LISTLEN, COUNTER, SUM, AVERAGE, RESULT) FIXED; RESULT = 0 SUM = 0 GET LIST (LISTLEN); IF (LISTLEN > 0 & LISTLEN< 100) THEN DO; /*READ INPUT DATA INTO AN ARRAY AND COMPUTE ITS SUM */ DO COUNTER = 1 TO LISTLEN; GET LIST (INTLIST(COUNTER)); SUM = SUM + INTLIST(COUNTER); END;\n\n/* COMPUTE THE AVERAGE */ AVERAGE = SUM / LISTLEN /* COUNT THE VALUES THAT ARE GREATER THAN THE AVERAGE */ DO COUNTER = 1 TO LISTLEN; IF (INTLIST(COUNTER) > AVERAGE) THEN RESULT = RESULT + 1; END; /* PRINT THE RESULT */ PUT SKIP LIST ('NUMBER OF VALUES > AVERAGE IS'); PUT LIST (RESULT); ELSE PUT SKIP LIST('ERROR - LIST LENGTH VALUE IS NOT’ ‘ LEGAL'); END PLIEX;\n\nSuccesses and Failures of PL/I • The PL/I language was so complex that its compiler was huge and slow and the executable code that it created was also huge and slow. • Because of its complexity, PL/I was a difficult language to master. • PL/I included some concepts that were ahead of its time, such as exception handling.\n\nSNOBOL • SNOBOL (String Oriented Symbolic Language) was develop by R. Griswold at AT&T Bell Labs. • SNOBOL was the first string-processing language and SNOBOL4 included powerful pattern-matching capabilities.\n\nSimula • Simula67 was created by Kristen Nygaard and Ole-Johan Dahl at the Norwegian Computing Center in 1965-1967. • It was designed for computer simulation and introduced to concept of the class, the basis behind object-orientation.\n\nBASIC • John Kemeny and Thomas Kurtz originally developed BASIC as a language to teach beginning students how to program in a more user-friendly environment. • BASIC’s original design was most heavily influenced by FORTRAN but was later expanded to include many other features.\n\nBASIC Sample Progam 10 INPUT \"What is your name: \", U$ 20 PRINT \"Hello \"; U$ 30 INPUT \"How many stars do you want: \", N 40 S$ = \"\" 50 FOR I = 1 TO N 60 S$ = S$ + \"*\" 70 NEXT I 80 PRINT S$ 90 INPUT \"Do you want more stars? \", A$ 100 IF LEN(A$) = 0 THEN GOTO 90 110 A$ = LEFT$(A$, 1) 120 IF A$ = \"Y\" OR A$ = \"y\" THEN GOTO 30 130 PRINT \"Goodbye \"; U$ 140 END\n\nThe 1970s – Simplicity, Abstraction, Study • Most of the new programming languages are characterized by a move toward simplicity and consistency. • Developments included Pascal and C. Both languages became extremely popular although adding few new concepts. • The desire to add mechanisms for data abstraction, concurrency and verification led to the development of languages such as CLU, Euclid and Mesa.\n\nPascal • Niklaus Wirth and C. A. R. Hoare developed ALGOL-W and later Pascal, which had a simplified structure. • Pascal’s structure made it a great teaching langauge and a popular language for describing algorithms. • There were several important features that it lacked including string processing, separate compilation, practical I/O facilities."
    }
}