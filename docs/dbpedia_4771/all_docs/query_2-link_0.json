{
    "id": "dbpedia_4771_2",
    "rank": 0,
    "data": {
        "url": "https://en.wikipedia.org/wiki/History_of_programming_languages",
        "read_more_link": "",
        "language": "en",
        "title": "History of programming languages",
        "top_image": "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg/1200px-Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg",
        "meta_img": "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg/1200px-Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/6/6c/Wiki_letter_w.svg/40px-Wiki_letter_w.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg/250px-Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/96/Symbol_category_class.svg/16px-Symbol_category_class.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/0/07/Fortran_acs_cover.jpeg/100px-Fortran_acs_cover.jpeg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Lisp_logo.svg/100px-Lisp_logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Simula_-_logo.svg/100px-Simula_-_logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Lambda_lc.svg/100px-Lambda_lc.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/The_C_Programming_Language_logo.svg/100px-The_C_Programming_Language_logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Smalltalk_Balloon.svg/100px-Smalltalk_Balloon.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Matlab_Logo.png/100px-Matlab_Logo.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Erlang_logo.png/100px-Erlang_logo.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/e/eb/Tcl-powered.svg/100px-Tcl-powered.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/100px-ISO_C%2B%2B_Logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Haskell-Logo.svg/100px-Haskell-Logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Lua-Logo.svg/100px-Lua-Logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/PHP_Logo.png/100px-PHP_Logo.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Rebol_logo.png/100px-Rebol_logo.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/100px-Python-logo-notext.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Ruby_logo.svg/100px-Ruby_logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/D_Programming_Language_logo.svg/100px-D_Programming_Language_logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/36/Groovy-logo.svg/100px-Groovy-logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/PowerShell_Core_6.0_icon.png/100px-PowerShell_Core_6.0_icon.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/Rust_programming_language_black_logo.svg/100px-Rust_programming_language_black_logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Scratchlogo.svg/100px-Scratchlogo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/Go_Logo_Blue.svg/100px-Go_Logo_Blue.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Dart_programming_language_logo.svg/100px-Dart_programming_language_logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Swift_logo.svg/100px-Swift_logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Kotlin_logo_2021.svg/100px-Kotlin_logo_2021.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/Typescript.svg/100px-Typescript.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/C_Sharp_Logo_2023.svg/100px-C_Sharp_Logo_2023.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Ringlogo_transparent.png/100px-Ringlogo_transparent.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Julia_Programming_Language_Logo.svg/100px-Julia_Programming_Language_Logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b3/Zig_logo_2020.svg/100px-Zig_logo_2020.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Dennis_Ritchie_2011.jpg/100px-Dennis_Ritchie_2011.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/4/49/Niklaus_Wirth%2C_UrGU.jpg/100px-Niklaus_Wirth%2C_UrGU.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Grace_Hopper.jpg/100px-Grace_Hopper.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/BjarneStroustrup.jpg/100px-BjarneStroustrup.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Anders_Hejlsberg.jpg/100px-Anders_Hejlsberg.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e2/Guido-portrait-2014-drc.jpg/100px-Guido-portrait-2014-drc.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Yukihiro_Matsumoto_EuRuKo_2011.jpg/100px-Yukihiro_Matsumoto_EuRuKo_2011.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/James_Gosling_2008.jpg/100px-James_Gosling_2008.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b3/Larry_Wall_YAPC_2007.jpg/100px-Larry_Wall_YAPC_2007.jpg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/d/db/Symbol_list_class.svg/16px-Symbol_list_class.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/96/Symbol_category_class.svg/16px-Symbol_category_class.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2004-08-12T20:10:00+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/History_of_programming_languages",
        "text": "For a detailed timeline of events, see Timeline of programming languages. For the ACM conference series, see History of Programming Languages.\n\nFor broader coverage of this topic, see Programming language.\n\nThe history of programming languages spans from documentation of early mechanical computers to modern tools for software development. Early programming languages were highly specialized, relying on mathematical notation and similarly obscure syntax.[1] Throughout the 20th century, research in compiler theory led to the creation of high-level programming languages, which use a more accessible syntax to communicate instructions.\n\nThe first high-level programming language was Plankalkül, created by Konrad Zuse between 1942 and 1945.[2] The first high-level language to have an associated compiler was created by Corrado Böhm in 1951, for his PhD thesis.[3] The first commercially available language was FORTRAN (FORmula TRANslation), developed in 1956 (first manual appeared in 1956, but first developed in 1954) by a team led by John Backus at IBM.\n\nEarly history\n\n[edit]\n\nDuring 1842–1849, Ada Lovelace translated the memoir of Italian mathematician Luigi Menabrea about Charles Babbage's newest proposed machine: the Analytical Engine; she supplemented the memoir with notes that specified in detail a method for calculating Bernoulli numbers with the engine, recognized by most of historians as the world's first published computer program.[4]\n\nJacquard Looms and Charles Babbage's Difference Engine both were designed to utilize punched cards,[5][6] which would describe the sequence of operations that their programmable machines should perform.\n\nThe first computer codes were specialized for their applications: e.g., Alonzo Church was able to express the lambda calculus in a formulaic way and the Turing machine was an abstraction of the operation of a tape-marking machine.\n\nFirst programming languages\n\n[edit]\n\nIn the 1940s, the first recognizably modern electrically powered computers were created. The limited speed and memory capacity forced programmers to write hand-tuned assembly language programs. It was eventually realized that programming in assembly language required a great deal of intellectual effort.[citation needed]\n\nAn early proposal for a high-level programming language was Plankalkül, developed by Konrad Zuse for his Z1 computer between 1942 and 1945 but not implemented at the time.[7]\n\nThe first functioning programming languages designed to communicate instructions to a computer were written in the early 1950s. John Mauchly's Short Code, proposed in 1949, was one of the first high-level languages ever developed for an electronic computer.[8] Unlike machine code, Short Code statements represented mathematical expressions in understandable form. However, the program had to be interpreted into machine code every time it ran, making the process much slower than running the equivalent machine code.\n\nIn the early 1950s, Alick Glennie developed Autocode, possibly the first compiled programming language, at the University of Manchester. In 1954, a second iteration of the language, known as the \"Mark 1 Autocode\", was developed for the Mark 1 by R. A. Brooker. Brooker, with the University of Manchester, also developed an autocode for the Ferranti Mercury in the 1950s. The version for the EDSAC 2 was devised by Douglas Hartree of University of Cambridge Mathematical Laboratory in 1961. Known as EDSAC 2 Autocode, it was a straight development from Mercury Autocode adapted for local circumstances and was noted for its object code optimization and source-language diagnostics which were advanced for the time. A contemporary but separate thread of development, Atlas Autocode was developed for the University of Manchester Atlas 1 machine.\n\nIn 1954, FORTRAN was invented at IBM by a team led by John Backus; it was the first widely used high-level general purpose language to have a functional implementation, in contrast to only a design on paper.[9][10] When FORTRAN was first introduced, it was viewed with skepticism due to bugs, delays in development, and the comparative efficiency of \"hand-coded\" programs written in assembly.[11] However, in a hardware market that was rapidly evolving, the language eventually became known for its efficiency. It is still a popular language for high-performance computing[12] and is used for programs that benchmark and rank the world's TOP500 fastest supercomputers.[13]\n\nAnother early programming language was devised by Grace Hopper in the US, named FLOW-MATIC. It was developed for the UNIVAC I at Remington Rand during the period from 1955 until 1959. Hopper found that business data processing customers were uncomfortable with mathematical notation, and in early 1955, she and her team wrote a specification for an English language programming language and implemented a prototype.[14] The FLOW-MATIC compiler became publicly available in early 1958 and was substantially complete in 1959.[15] Flow-Matic was a major influence in the design of COBOL, since only it and its direct descendant AIMACO were in use at the time.[16]\n\nOther languages still in use today include LISP (1958), invented by John McCarthy and COBOL (1959), created by the Short Range Committee. Another milestone in the late 1950s was the publication, by a committee of American and European computer scientists, of \"a new language for algorithms\"; the ALGOL 60 Report (the \"ALGOrithmic Language\"). This report consolidated many ideas circulating at the time and featured three key language innovations:\n\nnested block structure: code sequences and associated declarations could be grouped into blocks without having to be turned into separate, explicitly named procedures;\n\nlexical scoping: a block could have its own private variables, procedures and functions, invisible to code outside that block, that is, information hiding.\n\nAnother innovation, related to this, was in how the language was described:\n\na mathematically exact notation, Backus–Naur form (BNF), was used to describe the language's syntax. Nearly all subsequent programming languages have used a variant of BNF to describe the context-free portion of their syntax.\n\nALGOL 60 was particularly influential in the design of later languages, some of which soon became more popular. The Burroughs large systems were designed to be programmed in an extended subset of ALGOL.\n\nALGOL's key ideas were continued, producing ALGOL 68:\n\nsyntax and semantics became even more orthogonal, with anonymous routines, a recursive typing system with higher-order functions, etc.;\n\nnot only the context-free part, but the full language syntax and semantics were defined formally, in terms of Van Wijngaarden grammar, a formalism designed specifically for this purpose.\n\nALGOL 68's many little-used language features (for example, concurrent and parallel blocks) and its complex system of syntactic shortcuts and automatic type coercions made it unpopular with implementers and gained it a reputation of being difficult. Niklaus Wirth actually walked out of the design committee to create the simpler Pascal language.\n\nSome notable languages that were developed in this period include:\n\n1951 – Regional Assembly Language\n\n1952 – Autocode\n\n1954 – IPL (forerunner to LISP)\n\n1955 – FLOW-MATIC (led to COBOL)\n\n1957 – FORTRAN (first compiler)\n\n1957 – COMTRAN (precursor to COBOL)\n\n1958 – LISP\n\n1958 – ALGOL 58\n\n1959 – FACT (forerunner to COBOL)\n\n1959 – COBOL\n\n1959 – RPG\n\n1960 – ALGOL 60\n\n1962 – APL\n\n1962 – Simula\n\n1962 – SNOBOL\n\n1963 – CPL (forerunner to C)\n\n1964 – Speakeasy\n\n1964 – BASIC\n\n1964 – PL/I\n\n1966 – JOSS\n\n1966 – MUMPS\n\n1967 – BCPL (forerunner to C)\n\n1967 – Logo (an educational language that later influenced Smalltalk and Scratch).\n\nEstablishing fundamental paradigms\n\n[edit]\n\nThe period from the late 1960s to the late 1970s brought a major flowering of programming languages. Most of the major language paradigms now in use were invented in this period:[original research?]\n\nSpeakeasy, developed in 1964 at Argonne National Laboratory (ANL) by Stanley Cohen, is an object-oriented programming system (OOPS), much like the later MATLAB, IDL and Mathematica numerical package. Speakeasy has a clear Fortran foundation syntax. It first addressed efficient physics computing internally at ANL, was modified for research use (as \"Modeleasy\") for the Federal Reserve Board in the early 1970s and then was made available commercially; Speakeasy and Modeleasy are still in use.\n\nSimula, invented in the late 1960s by Nygaard and Dahl as a superset of ALGOL 60, was the first language designed to support object-oriented programming.\n\nFORTH, the earliest concatenative programming language was designed by Charles Moore in 1969 as a personal development system while at the National Radio Astronomy Observatory (NRAO).\n\nC, an early systems programming language, was developed by Dennis Ritchie and Ken Thompson at Bell Labs between 1969 and 1973.\n\nSmalltalk (mid-1970s) provided a complete ground-up design of an object-oriented language.\n\nProlog, designed in 1972 by Alain Colmerauer, Phillipe Roussel, and Robert Kowalski, was the first logic programming language.\n\nML built a polymorphic type system (invented by Robin Milner in 1973) on Lisp,[17] pioneering statically typed functional programming languages. Each of these languages spawned an entire family of descendants, and most modern languages count at least one of them in their ancestry.\n\nThe 1960s and 1970s also saw considerable debate over the merits of \"structured programming\", which essentially meant programming without the use of goto. A significant fraction of programmers believed that, even in languages that provide goto, it is bad programming style to use it except in rare circumstances. This debate was closely related to language design: some languages had no goto, which forced the use of structured programming.\n\nTo provide even faster compile times, some languages were structured for \"one-pass compilers\" which expect subordinate routines to be defined first, as with Pascal, where the main routine, or driver function, is the final section of the program listing.\n\nSome notable languages that were developed in this period include:\n\n1967 – BCPL (forerunner to B)\n\n1967 – Logo\n\n1969 – B (forerunner to C)\n\n1970 – Pascal\n\n1970 – Forth\n\n1972 – C\n\n1972 – Smalltalk\n\n1972 – Prolog\n\n1973 – ML\n\n1975 – Scheme\n\n1978 – SQL (a query language, later extended)\n\n1980s: consolidation, modules, performance\n\n[edit]\n\nThe 1980s were years of relative consolidation in imperative languages. Rather than inventing new paradigms, all of these movements elaborated upon the ideas invented in the prior decade. C++ combined object-oriented and systems programming. The United States government standardized Ada, a systems programming language intended for use by defense contractors. In Japan and elsewhere, vast sums were spent investigating so-called fifth-generation programming languages that incorporated logic programming constructs. The functional languages community moved to standardize ML and Lisp. Research in Miranda, a functional language with lazy evaluation, began to take hold in this decade.\n\nOne important new trend in language design was an increased focus on programming for large-scale systems through the use of modules, or large-scale organizational units of code. Modula, Ada, and ML all developed notable module systems in the 1980s. Module systems were often wedded to generic programming constructs: generics being, in essence, parametrized modules[citation needed] (see also Polymorphism (computer science)).\n\nAlthough major new paradigms for imperative programming languages did not appear, many researchers expanded on the ideas of prior languages and adapted them to new contexts. For example, the languages of the Argus and Emerald systems adapted object-oriented programming to distributed computing systems.\n\nThe 1980s also brought advances in programming language implementation. The reduced instruction set computer (RISC) movement in computer architecture postulated that hardware should be designed for compilers rather than for human assembly programmers. Aided by central processing unit (CPU) speed improvements that enabled increasingly aggressive compiling methods, the RISC movement sparked greater interest in compiler technology for high-level languages.\n\nLanguage technology continued along these lines well into the 1990s.\n\nSome notable languages that were developed in this period include:\n\n1990s: the Internet age\n\n[edit]\n\nThe rapid growth of the Internet in the mid-1990s was the next major historic event in programming languages. By opening up a radically new platform for computer systems, the Internet created an opportunity for new languages to be adopted. In particular, the JavaScript programming language rose to popularity because of its early integration with the Netscape Navigator web browser. Various other scripting languages achieved widespread use in developing customized applications for web servers such as PHP. The 1990s saw no fundamental novelty in imperative languages, but much recombination and maturation of old ideas. This era began the spread of functional languages. A big driving philosophy was programmer productivity. Many rapid application development (RAD) languages emerged, which usually came with an integrated development environment (IDE), garbage collection, and were descendants of older languages. All such languages were object-oriented. These included Object Pascal, Objective Caml (renamed OCaml), Visual Basic, and Java. Java in particular received much attention.\n\nMore radical and innovative than the RAD languages were the new scripting languages. These did not directly descend from other languages and featured new syntaxes and more liberal incorporation of features. Many consider these scripting languages to be more productive than even the RAD languages, but often because of choices that make small programs simpler but large programs more difficult to write and maintain.[citation needed] Nevertheless, scripting languages came to be the most prominent ones used in connection with the Web.\n\nSome programming languages included other languages in their distribution to save the development time. for example both of Python and Ruby included Tcl to support GUI programming through libraries like Tkinter.\n\nSome notable languages that were developed in this period include:\n\nCurrent trends\n\n[edit]\n\nProgramming language evolution continues, in both industry and research. Some of the recent trends have included:\n\nIncreasing support for functional programming in mainstream languages used commercially, including purely functional programming for making code easier to reason about and to parallelize (at both micro- and macro- levels)\n\nConstructs to support concurrent and distributed programming.\n\nMechanisms for adding security and reliability verification to the language: extended static checking, dependent typing, information flow control, static thread safety.\n\nAlternative mechanisms for composability and modularity: mixins, traits, typeclasses, delegates, aspects.\n\nComponent-oriented software development.\n\nMetaprogramming, reflective programming (reflection), or access to the abstract syntax tree\n\nAspect-oriented programming (AOP) allowing developers to insert code in another module or class at \"join points\"\n\nDomain-specific languages and code generation\n\nXML for graphical interface (XUL, Extensible Application Markup Language (XAML))\n\nIncreased interest in distribution and mobility.\n\nIntegration with databases, including XML and relational databases.\n\nOpen source as a developmental philosophy for languages, including the GNU Compiler Collection and languages such as PHP, Python, Ruby, and Scala.\n\nMore interest in visual programming languages like Scratch, LabVIEW, and PWCT\n\nMassively parallel languages for GPU graphics processing units and supercomputer arrays, including OpenCL\n\nEarly research into quantum computing programming languages (see list)\n\nEarly research in applying artificial intelligence (AI) methods to generate code using AI like using GPT-3 and Gemini.[18][19]\n\nMany Big Tech companies introduced multiple new programming languages that are designed to serve their needs and provides first-class support for their platforms. for example:\n\nMicrosoft introduced C#, F#, TypeScript, Q#, Bosque, and Power Fx.\n\nGoogle introduced Go, Dart, and Carbon.\n\nApple introduced Swift.\n\nMeta introduced Hack.\n\nSome notable languages developed during this period and are listed in TIOBE index (Top 100 programming languages) as of February 2024 include:[20][21]\n\n2000 – ActionScript\n\n2001 – C#\n\n2001 – D\n\n2002 – Scratch\n\n2003 – Groovy\n\n2003 – Scala\n\n2005 – F#\n\n2006 – PowerShell\n\n2007 – Clojure\n\n2008 – Nim\n\n2009 – Go\n\n2011 – Dart\n\n2011 – Kotlin\n\n2012 – Julia\n\n2012 – TypeScript\n\n2012 – Elixir\n\n2014 – Swift\n\n2014 – Hack\n\n2015 – Rust\n\n2015 – Raku\n\n2016 – Ring\n\n2016 – Zig\n\n2022 – Carbon\n\nOther new programming languages include Elm, Ballerina, Red, Crystal, Haxe, V (Vlang), Reason, and Mojo.\n\nKey figures\n\n[edit]\n\nSome key people who helped develop programming languages:\n\nAda Lovelace, published first computer program\n\nAlan Cooper, developer of Visual Basic.\n\nAlan Kay, pioneering work on object-oriented programming, and originator of Smalltalk.\n\nAnders Hejlsberg, developer of Turbo Pascal, Delphi, C#, and TypeScript.\n\nArthur Whitney, developer of A+, k, and q.\n\nBertrand Meyer, inventor of Eiffel.\n\nBjarne Stroustrup, developer of C++.\n\nBrad Cox, co-creator of Objective-C.\n\nBrendan Eich, developer of JavaScript.\n\nBrian Kernighan, co-author of the first book on the C programming language with Dennis Ritchie, coauthor of the AWK and AMPL programming languages.\n\nChuck Moore, inventor of Forth, the first concatenative programming language, and a prominent name in stack machine microprocessor design.\n\nChris Lattner, creator of Swift, Mojo and LLVM.\n\nCleve Moler, creator of MATLAB.\n\nDennis Ritchie, inventor of C. Unix Operating System, Plan 9 Operating System.\n\nDouglas McIlroy, influenced and designed such languages as SNOBOL, TRAC, PL/I, ALTRAN, TMG and C++.\n\nGrace Hopper, first to use the term compiler and developer of FLOW-MATIC, influenced development of COBOL. Popularized machine-independent programming languages and the term \"debugging\".\n\nGuido van Rossum, creator of Python.\n\nJames Gosling, lead developer of Java and its precursor, Oak.\n\nJean Ichbiah, chief designer of Ada, Ada 83.\n\nJean-Yves Girard, co-inventor of the polymorphic lambda calculus (System F).\n\nJeff Bezanson, main designer, and one of the core developers of Julia.\n\nJeffrey Snover, inventor of PowerShell.\n\nJoe Armstrong, creator of Erlang.\n\nJohn Backus, inventor of Fortran, cooperated in designing ALGOL 58 and ALGOL 60.\n\nJohn C. Reynolds, co-inventor of the polymorphic lambda calculus (System F).\n\nJohn McCarthy, inventor of LISP, design committee of ALGOL 60.\n\nJohn von Neumann, originator of the operating system concept.\n\nGraydon Hoare, inventor of Rust.\n\nKen Thompson, inventor of B and Go.\n\nKenneth E. Iverson, developer of APL, co-developer of J with Roger Hui.\n\nKonrad Zuse, designed the first high-level programming language, Plankalkül (which influenced ALGOL 58[22]).\n\nKristen Nygaard, pioneered object-oriented programming, co-invented Simula.\n\nLarry Wall, creator of the Perl programming language (see Perl and Raku).\n\nMartin Odersky, creator of Scala, and previously a contributor to the design of Java.\n\nMartin Richards developed the BCPL programming language, forerunner of the B and C languages.\n\nNathaniel Rochester, inventor of first assembler (IBM 701).\n\nNiklaus Wirth, inventor of Pascal, Modula and Oberon.\n\nOle-Johan Dahl, pioneered object-oriented programming, co-invented Simula.\n\nRasmus Lerdorf, creator of PHP.\n\nRich Hickey, creator of Clojure.\n\nRobert Gentleman, co-creator of R.\n\nRobert Griesemer, co-creator of Go.\n\nRobin Milner, inventor of ML, and sharing credit for Hindley–Milner polymorphic type inference.\n\nRob Pike, co-creator of Go, Inferno (operating system) and Plan 9 (operating system) Operating System co-author.\n\nRoss Ihaka, co-creator of R.\n\nStanley Cohen, inventor of Speakeasy, which was created with an OOPS, object-oriented programming system, the first instance, in 1964.\n\nStephen Wolfram, creator of Mathematica.\n\nWalter Bright, creator of D.\n\nYukihiro Matsumoto, creator of Ruby.\n\nSee also\n\n[edit]\n\nReferences\n\n[edit]\n\nFurther reading\n\n[edit]\n\nRosen, Saul, (editor), Programming Systems and Languages, McGraw-Hill, 1967.\n\nSammet, Jean E., Programming Languages: History and Fundamentals, Prentice-Hall, 1969.\n\nSammet, Jean E. (July 1972). \"Programming Languages: History and Future\". Communications of the ACM. 15 (7): 601–610. doi:10.1145/361454.361485. S2CID 2003242.\n\nRichard L. Wexelblat (ed.): History of Programming Languages, Academic Press 1981.\n\nThomas J. Bergin and Richard G. Gibson (eds.): History of Programming Languages, Addison Wesley, 1996.\n\nSebesta, Robert W. Concepts of programming languages. Pearson Education India, 2004."
    }
}