{
    "id": "dbpedia_4771_0",
    "rank": 82,
    "data": {
        "url": "https://www.britannica.com/technology/computer/UNIVAC",
        "read_more_link": "",
        "language": "en",
        "title": "Computer - UNIVAC, Computing, Data Storage",
        "top_image": "https://cdn.britannica.com/77/170477-050-1C747EE3/Laptop-computer.jpg",
        "meta_img": "https://cdn.britannica.com/77/170477-050-1C747EE3/Laptop-computer.jpg",
        "images": [
            "https://cdn.britannica.com/mendel/eb-logo/MendelNewThistleLogo.png",
            "https://cdn.britannica.com/mendel/eb-logo/MendelNewThistleLogo.png",
            "https://cdn.britannica.com/77/170477-004-B774BDDF/Laptop-computer.jpg",
            "https://cdn.britannica.com/87/261287-049-7FE742EA/technology-timeline-banner.jpg",
            "https://cdn.britannica.com/61/74061-004-9EAD20C7/computer-peripherals-images-laser-printer-inkjet-layout.jpg",
            "https://cdn.britannica.com/67/74067-004-02138267/Gordon-E-Moore-law-number-transistors-computer.jpg",
            "https://cdn.britannica.com/63/74063-004-1E01870E/hard-drive.jpg",
            "https://cdn.britannica.com/42/20542-004-771D1C10/laser-DVD-player-CD-focus-point-storage.jpg",
            "https://cdn.britannica.com/64/74064-004-1192BCB2/mouse-personal-computer.jpg",
            "https://cdn.britannica.com/65/74065-004-5A9ED975/computer-laser-printer.jpg",
            "https://cdn.britannica.com/66/74066-004-DDBF4DD5/colour-Inkjet-printer-Colour-inkjet-printers-amounts.jpg",
            "https://cdn.britannica.com/82/179682-138-95AEFEA2/quantum-computers.jpg?w=400&h=225&c=crop",
            "https://cdn.britannica.com/mendel-resources/3-124/images/shared/default3.png?v=3.124.35",
            "https://cdn.britannica.com/63/166063-131-0E023062/computer-chip-processing-unit-history-society-science.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/93/149293-131-2CD523EA/Technician-computer-system-console-UNIVAC-Corona-Annex-June-1-1981.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/93/149293-131-2CD523EA/Technician-computer-system-console-UNIVAC-Corona-Annex-June-1-1981.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/88/129488-131-09AB5E83/Internet-blue-screen-blog-society-history-media-2009.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/30/199930-131-B3D1D347/computer.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/09/198609-131-0FECF4D1/insides-desktop-computer.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/88/129488-131-09AB5E83/Internet-blue-screen-blog-society-history-media-2009.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/31/190731-131-C89CEF04/Saltwater-crocodile.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/47/71447-131-D3FA964C/soldiers-Red-Army.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/07/186707-131-EE0952B0/Efrite-Aladdin-jinn.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/02/196602-131-7D54F98C/map-Globe-South-America.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/68/220368-131-C835E48E/United-States-electoral-college-votes-by-state.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/45/190645-131-6408BC80/Lake-Ysyk-body-water-Kyrgyzstan.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/45/189145-131-45FF672E/Secret-Service-Agent-Earpiece.jpg?w=200&h=200&c=crop",
            "https://cdn.britannica.com/01/23601-004-CD74EAC4/IBM-650-computer-business-applications-1954.jpg?w=300"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "computer",
            "encyclopedia",
            "encyclopeadia",
            "britannica",
            "article"
        ],
        "tags": null,
        "authors": [
            "Paul A. Freiberger",
            "David Hemmendinger"
        ],
        "publish_date": "2001-05-11T00:00:00+00:00",
        "summary": "",
        "meta_description": "Computer - UNIVAC, Computing, Data Storage: After leaving the Moore School, Eckert and Mauchly struggled to obtain capital to build their latest design, a computer they called the Universal Automatic Computer, or UNIVAC. (In the meantime, they contracted with the Northrop Corporation to build the Binary Automatic Computer, or BINAC, which, when completed in 1949, became the first American stored-program computer.) The partners delivered the first UNIVAC to the U.S. Bureau of the Census in March 1951, although their company, their patents, and their talents had been acquired by Remington Rand, Inc., in 1950. Although it owed something to experience with ENIAC, UNIVAC was built from",
        "meta_lang": "en",
        "meta_favicon": "/favicon.png",
        "meta_site_name": "Encyclopedia Britannica",
        "canonical_link": "https://www.britannica.com/technology/computer/UNIVAC",
        "text": "Machine language\n\nOne implication of the stored-program model was that programs could read and operate on other programs as data; that is, they would be capable of self-modification. Konrad Zuse had looked upon this possibility as “making a contract with the Devil” because of the potential for abuse, and he had chosen not to implement it in his machines. But self-modification was essential for achieving a true general-purpose machine.\n\nOne of the very first employments of self-modification was for computer language translation, “language” here referring to the instructions that make the machine work. Although the earliest machines worked by flipping switches, the stored-program machines were driven by stored coded instructions, and the conventions for encoding these instructions were referred to as the machine’s language.\n\nWriting programs for early computers meant using the machine’s language. The form of a particular machine’s language is dictated by its physical and logical structure. For example, if the machine uses registers to store intermediate results of calculations, there must be instructions for moving data between such registers.\n\nThe vocabulary and rules of syntax of machine language tend to be highly detailed and very far from the natural or mathematical language in which problems are normally formulated. The desirability of automating the translation of problems into machine language was immediately evident to users, who either had to become computer experts and programmers themselves in order to use the machines or had to rely on experts and programmers who might not fully understand the problems they were translating.\n\nAutomatic translation from pure mathematics or some other “high-level language” to machine language was therefore necessary before computers would be useful to a broader class of users. As early as the 1830s, Charles Babbage and Ada Lovelace had recognized that such translation could be done by machine (see the earlier section Ada Lovelace, the first programmer), but they made no attempt to follow up on this idea and simply wrote their programs in machine language.\n\nHoward Aiken, working in the 1930s, also saw the virtue of automated translation from a high-level language to machine language. Aiken proposed a coding machine that would be dedicated to this task, accepting high-level programs and producing the actual machine-language instructions that the computer would process.\n\nBut a separate machine was not actually necessary. The IAS model guaranteed that the stored-program computer would have the power to serve as its own coding machine. The translator program, written in machine language and running on the computer, would be fed the target program as data, and it would output machine-language instructions. This plan was altogether feasible, but the cost of the machines was so great that it was not seen as cost-effective to use them for anything that a human could do—including program translation.\n\nTwo forces, in fact, argued against the early development of high-level computer languages. One was skepticism that anyone outside the “priesthood” of computer operators could or would use computers directly. Consequently, early computer makers saw no need to make them more accessible to people who would not use them anyway. A second reason was efficiency. Any translation process would necessarily add to the computing time necessary to solve a problem, and mathematicians and operators were far cheaper by the hour than computers.\n\nProgrammers did, though, come up with specialized high-level languages, or HLLs, for computer instruction—even without automatic translators to turn their programs into machine language. They simply did the translation by hand. They did this because casting problems in an intermediate programming language, somewhere between mathematics and the highly detailed language of the machine, had the advantage of making it easier to understand the program’s logical structure and to correct, or debug, any defects in the program.\n\nThe early HLLs thus were all paper-and-pencil methods of recasting problems in an intermediate form that made it easier to write code for a machine. Herman Goldstine, with contributions from his wife, Adele Goldstine, and from John von Neumann, created a graphical representation of this process: flow diagrams. Although the diagrams were only a notational device, they were widely circulated and had great influence, evolving into what are known today as flowcharts.\n\nZuse’s Plankalkül\n\nKonrad Zuse developed the first real programming language, Plankalkül (“Plan Calculus”), in 1944–45. Zuse’s language allowed for the creation of procedures (also called routines or subroutines; stored chunks of code that could be invoked repeatedly to perform routine operations such as taking a square root) and structured data (such as a record in a database, with a mixture of alphabetic and numeric data representing, for instance, name, address, and birth date). In addition, it provided conditional statements that could modify program execution, as well as repeat, or loop, statements that would cause a marked block of statements or a subroutine to be repeated a specified number of times or for as long as some condition held.\n\nZuse knew that computers could do more than arithmetic, but he was aware of the propensity of anyone introduced to them to view them as nothing more than calculators. So he took pains to demonstrate nonnumeric solutions with Plankalkül. He wrote programs to check the syntactical correctness of Boolean expressions (an application in logic and text handling) and even to check chess moves.\n\nUnlike flowcharts, Zuse’s program was no intermediate language intended for pencil-and-paper translation by mathematicians. It was deliberately intended for machine translation, and Zuse did some work toward implementing a translator for Plankalkül. He did not get very far, however; he had to disassemble his machine near the end of the war and was not able to put it back together and work on it for several years. Unfortunately, his language and his work, which were roughly a dozen years ahead of their time, were not generally known outside Germany.\n\nCompilers\n\nAn alternative to this approach is what is now known as compilation. In compilation, the entire HLL program is converted to machine language and stored for later execution. Although translation may take many hours or even days, once the translated program is stored, it can be recalled anytime in the form of a fast-executing machine-language program.\n\nIn 1952 Heinz Rutishauser, who had worked with Zuse on his computers after the war, wrote an influential paper, “Automatische Rechenplanfertigung bei programmgesteuerten Rechenmaschinen” (loosely translatable as “Computer Automated Conversion of Code to Machine Language”), in which he laid down the foundations of compiler construction and described two proposed compilers. Rutishauser was later involved in creating one of the most carefully defined programming languages of this early era, ALGOL. (See next section, FORTRAN, COBOL, and ALGOL.)\n\nThen, in September 1952, Alick Glennie, a student at the University of Manchester, England, created the first of several programs called Autocode for the Manchester Mark I. Autocode was the first compiler actually to be implemented. (The language that it compiled was called by the same name.) Glennie’s compiler had little influence, however. When J. Halcombe Laning created a compiler for the Whirlwind computer at the Massachusetts Institute of Technology (MIT) two years later, he met with similar lack of interest. Both compilers had the fatal drawback of producing code that ran slower (10 times slower, in the case of Laning’s) than code handwritten in machine language."
    }
}