{
    "id": "dbpedia_4771_1",
    "rank": 74,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/267086/is-every-language-written-in-c",
        "read_more_link": "",
        "language": "en",
        "title": "Is every language written in C?",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://i.sstatic.net/idvz6.jpg?s=64",
            "https://i.sstatic.net/cFyP6.jpg?s=64",
            "https://www.gravatar.com/avatar/487d8f71839dcd0a5a90f2185f960c3d?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/b0d8ecb1f35283c9ac7fd219916efb90?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/ed181f8c80df53d2b67a4f4fff088ed4?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/KACBq.png?s=64",
            "https://lh5.googleusercontent.com/-oPv7OtP0unE/AAAAAAAAAAI/AAAAAAAAAFw/F2_X5n6UfLg/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/a18972c4ea4565ddb0606c5fe01d94cc?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/eea1fb6e67a04a8444199e984903cd33?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/0JPCW.jpg?s=64",
            "https://i.sstatic.net/Fm52y.png?s=64",
            "https://i.sstatic.net/o9Hve.jpg?s=64",
            "https://www.gravatar.com/avatar/80df0d0f2a1945a7bed366ff25f8ea5d?s=64&d=identicon&r=PG",
            "https://softwareengineering.stackexchange.com/posts/267086/ivc/315d?prg=e4867f12-c120-4e6a-a2c1-48669764055f"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2014-12-22T08:08:49",
        "summary": "",
        "meta_description": "Sometimes while programming in different languages (C/C++, C#), this thought comes to my mind: \r\nIs each and every language written in the C programming language?\nIs the C language the mother/fathe...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/267086/is-every-language-written-in-c",
        "text": "No.\n\nOCaml, Haskell, Lisp dialects like Scheme, and several other languages are often used in the development of hobby languages.\n\nMany languages are implemented in C because it's a ubiquitous language, and compiler-writing tools like lexer-parser generators (such as yacc and bison) are well-understood and almost as ubiquitous.\n\nBut C itself couldn't originally be developed in C when it was first created. It was, in fact, originally developed using the B language. Earlier languages (like Fortran) were usually bootstrapped using a native assembly language or even machine code long before C ever existed.\n\nUnrelatedly, language paradigms like OOP are generally language-agnostic. The functional paradigm, for example, was developed (by Alonzo Church) as a foundation of mathematics long before any programming language ever existed. The procedural and structured programming paradigms came out of the mathematical work of theorists like John von Neumann. Object-orientation was developed by several different and unrelated efforts, some out of the lambda calculus (the functional paradigm) and some out of dynamic programming systems like SmallTalk at Xerox PARC by Alan Kay.\n\nC is merely a tiny part of the story, decades after these ideas came into being.\n\nIs each and every language written in C language?\n\nA language is a set of abstract mathematical rules and restrictions (\"if I write this, that happens\"). It isn't written in anything, really.\n\nIt is specified, usually in a mixture of a formalized subset of English, mathematical notation, and maybe some specialized specification language. The syntax is often specified in a variant of EBNF or ABNF.\n\nFor example, here is the specification of the for expression from the ISO Ruby Language Specification:\n\n§11.5.2.3.4 The for expression\n\nSyntax\n\nfor-expression → for for-variable [no line-terminator here] in expression do-clause end\n\nfor-variable → left-hand-side | multiple-left-hand-side\n\nSemantics\n\nA for-expression is evaluated as follows:\n\nEvaluate the expression. If the evaluation of the expression is terminated by a break-expression, next-expression, or redo-expression, the behavior is unspecified. Otherwise, let O be the resulting value.\n\nLet E be the primary-method-invocation of the form primary-expression [no line-terminator here].each do | block-parameter-list | block-body end, where the value of the primary-expression is O, the block-parameter-list is the for-variable, the block-body is the compound-statement of the do-clause.\n\nEvaluate E; however, if a block whose block-body is the compound-statement of the do-clause of the for-expression is called during this evaluation, the steps in §11.3.3 except the Step c) and the Step e) 4) shall be taken for the evaluation of this call.\n\nThe value of the for-expression is the resulting value of the invocation.\n\nHere's a different example from the type conformance rules of Scala:\n\nThe polymorphic type [a1 >: L1 <: U1 , … , an >: Ln <: Un]T conforms to the polymorphic type [a1 >: L′1 <: U′1 , … , an >: L′n <: U′n]T′ if, assuming L′1 <: a1 <: U′1 , … , L′n <: an <: U′n one has T <: T′ and Li <: L′i and U′i <: Ui for i ∈ { 1 , … , n }.\n\nIs C language mother/father of all languages?\n\nNo, it is not. C is pretty young. There are a lot of old languages. Since time travel is physically impossible, it is simply impossible for C to have had any influence whatsoever on those old languages.\n\nPlankalkül (1943)\n\nSpeedcoding (1953)\n\nFortran (1954)\n\nIPL (1956)\n\nLisp (1958)\n\nAlgol (1958)\n\nCOBOL (1959)\n\nJOVIAL (1960)\n\nAPL (1962)\n\nSIMULA (1962)\n\nSNOBOL (1962)\n\nCPL (1963)\n\nBASIC (1964)\n\nPL/I (1964)\n\nRPG (1964)\n\nBCPL (1966)\n\nISWIM (1966)\n\nMUMPS (1967)\n\nForth (1968)\n\nLOGO (1968)\n\nREFAL (1968)\n\nB (1969)\n\nBLISS (1970)\n\nPascal (1971)\n\nKRL (1971)\n\nSmalltalk (1972)\n\nAll of those existed before C was even invented. And many others have no influence of C in them, even after it existed. The PASCAL-family of languages (ALGOL-58, ALGOL-60, ALGOL-X, ALGOL-W, PASCAL, Modula-2, Oberon, Oberon-2, Active Oberon, Component Pascal) is a completely separate lineage. The whole Lisp family (LISP, Franz Lisp, InterLisp, MacLisp, Scheme, Flavors, LOOPS, CommonLoops, Dylan, CommonLisp, Arc, Clojure, Racket, etc.) is unrelated as well. Functional languages (ISWIM, KRL, Miranda, ML, SML, CAML, OCaml, F#, Haskell, Gofer, Clean) and the whole dependently-typed family (Agda, Coq, GURU, Idris) are about as far from C as possible. The same is true for the Smalltalk family (Smalltalk, Self, Newspeak, Us, Korz), the logic programming family (PLANNER, Prolog, Mercury), SQL, and many others.\n\nEach concept (OOP etc) is all implemented in C language?\n\nThe first languages with OO concepts were Simula (1960) and Smalltalk (1972), but object-oriented systems had been built as far back as 1953 (without calling them that). Again, that's long before C existed, so OO cannot possibly have any relation to C.\n\nI would make this a comment if I could, but I can't so here goes:\n\nOne of the reasons C seems so ubiquitous is because it is one of the earliest languages developed, and an enormous amount of modern languages are based off of its structure (Java, Go, PHP, Perl, etc.) - making it seem like it's more places than it is.\n\nAnother oft-forgotten reason is that in 1973 Unix was rewritten in C and many of Unix's system calls are also available as C programs/functions, making the two highly interlinked. Since Unix was a powerful part of the development of modern programming as a whole, C was dragged along into infamy with it.\n\nHaving said all that, the answer to your question is \"No\". C is based off of a language called ALGOL, and there were many competitors both with ALGOL (FORTRAN, Lisp, COBOL) and C (none come to mind). Object-oriented programming, arguably the biggest paradigm-shift in programming design, did not originate with C - despite C++ being a very popular OOP language (it showed up first in Lisp or Simula 67, depending on who you ask). By the time OOP came about, C was such a popular language that it didn't need to be first - it was so popular that the C++ \"expansion\", so to speak, became one of the primary OOP languages too. It remains in modern use mainly because of its powerful memory control features (you can directly allocate and deallocate the memory your structures create), allowing it to create programs on tight memory budgets (think video games) and its highly optimized compiler (obviously depending on the compiler). Admittedly, even these features are losing ground as Java JIT compilation and in-language memory managers become more advanced.\n\nProgramming languages are specifications (not software!) usually written in some English document (with some formalization, e.g. EBNF for most of the syntax; sometimes their semantics is also partly formalized).\n\nFor example, C11 is defined by n1570 (which you should read). Some dialect of Scheme is defined by R5RS (which you should also read, it is very well written).\n\nProgramming languages may be implemented by some software. Sometimes that software is a compiler written in the programming language itself. Read about bootstrapping compilers.\n\nOne can write a compiler in the compiled programming language itself. If that language XX is brand new, you need to go thru a temporary step which involves writing a minimal interpreter or compiler of a subset of that language in some other implementation language (perhaps C), and later your can throw away that temporary compiler or interpreter (which don't need to be \"good\", just to be enough to compile the other compiler). Once you compiled your XX compiler written in XX you can throw away your temporary compiler.\n\nOften (but not always) the runtime system is partly written in C (in particular the garbage collector).\n\nNotice that bones is a Scheme compiler and runtime entirely written in itself (and you can find many other examples of fully bootstrapped implementations).\n\nBTW it is convenient to use C as the target language of compilers.\n\nToday, a lot of programming languages implementations is free software or open source. Feel free to study (and perhaps contribute to) their source code!\n\nThe Programmation Automatique des Formules (literally \"automatic formulae programming\") programming language was designed and implemented in France (around 1959) by my father, Dimitri Starynkevitch (1919-1993). It is a BASIC like language (whose specification is written in French, on paper). See this web page for more.\n\nConsider reading Queinnec's book Lisp in Small Pieces and Pitrat's book Artificial Beings, the conscience of a conscience machine about bootstrapped programming languages. The RefPerSys open source project aims to become one (but a lot of work remains to generate most of the code of this homoiconic software).\n\nPS. Feel free to send me an email to [email protected] for details you don't want to share on a public forum, but mention the URL of your question in that email.\n\nHere is a list of some programming languages that are not written in C, alongside the languages they are implemented in:\n\nHaskell - Haskell\n\nIdris - Haskell\n\nAdga - Haskell\n\nClash - Haskell\n\nPureScript - Haskell\n\nElm - Haskell\n\nMercury - Mercury\n\nRust - Rust (initially OCaml)\n\nGo - Go\n\nCrystal - Crystal\n\nOCaml - OCaml\n\nFrege - Frege + Java\n\nHaxe - OCaml + Haxe\n\nScala - Scala\n\nFuthark - Haskell\n\nATS - ATS\n\nThe best languages for implementing a compiler are probably going to be pretty far away from C. Functional languages give you things like recursion schemes and monadic parser combinators (provided you have typeclasses), which makes them especially suited for compiler work.\n\nSecond, to address your question as to whether C is the \"mother/father of all programming languages\" - not really. C was a well-designed language at the time it appeared, and it no doubt has influenced language designers who then went on to do very different things. But at the end of the day, Haskell departs from C in essentially every way possible. C is 45 years old and it is not surprising that we have learned to do better in the meantime.\n\nFinally, to answer your third question, it is simply not the case that C implements \"all the concepts\". In particular, trying to implement some of the advanced concepts from functional programming (such as metamorphisms, or, god forbid, synchromorphisms) in C would be monstrously difficult. I am not particularly familiar with object-oriented programming, but I do know for a fact that some object-oriented languages have sum types."
    }
}