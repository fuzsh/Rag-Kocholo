{
    "id": "dbpedia_4771_3",
    "rank": 85,
    "data": {
        "url": "https://craftofcoding.wordpress.com/tag/if-statement/",
        "read_more_link": "",
        "language": "en",
        "title": "if statement – The Craft of Coding",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://craftofcoding.wordpress.com/wp-content/uploads/2020/04/controlstr_if1.jpg",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2020/04/controlstr_if2.jpg",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2017/04/firstif.jpg",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-10-21T17:30:51+00:00",
        "summary": "",
        "meta_description": "Posts about if statement written by spqr",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "The Craft of Coding",
        "canonical_link": "https://craftofcoding.wordpress.com/tag/if-statement/",
        "text": "Until now, the small programs we have written work in a linear fashion, i.e. they start at the top, and work through each statement until they reach the end of the program. But what if an algorithm his a fork in the road, i.e. has to make a decision to go one way or another? In this case a decision must be made. All programming languages provide this type of structure, usually in the form of an if statement. If statements allow a statement to be activated only under certain conditions, or provide one of more alternate paths in a program. An if statement just asks if a certain condition is true or false, and acts accordingly.\n\nFor example consider the following Fortran program which calculates the square root of a number:\n\nprogram sqroot real :: x, sqrtx write(*,*) 'Enter a number: ' read(*,*) x sqrtx = sqrt(x) write(*,*) 'sqrt(', x, ') = ', sqrtx end program sqroot\n\nThe program works fine except when a negative number is input, then it returns the result as NaN, short for Not-an-Number. This can cause issues, and a better solution would be to check that x is not negative before the calculation is performed. This can be done by only performing the square-root calculation if the value input by the user is greater-then or equal to zero.\n\nprogram sqroot real :: x, sqrtx write(*,*) 'Enter a number: ' read(*,*) x if (x >= 0) then sqrtx = sqrt(x) write(*,*) 'sqrt(', x, ') = ', sqrtx else write(*,*) 'Error: Number must be >= 0.' end if end program sqroot\n\nNow the if statement asks “is x >= 0?”. If this statement is true then it performs the square-root calculation and prints out the result. If x is negative, i.e. “is x >= 0?” is false, then it prints out the error message. The same program in Python would look like this:\n\nimport math x = float(input('Enter a number: ')) if (x >= 0): sqrtx = math.sqrt(x) print('sqrt(',x,') = ',sqrtx) else: print('Error: number must be >= 0')\n\nNote here the first use of indenting in Python – indenting (4 spaces) is used to imply code association, i.e. the code on lines 4 and 5 are indented and are associated with the part of the if statement when x is greater than or equal to 0.\n\nIt is possible to use if statements to check a number of conditions. For example in the simple interest program, the principal amount, and time (years) should all be positive numbers, whereas the rate should be between 0.0 and 1.0. The program below adds these checks and balances by using a nested-if statement.\n\nprogram simpleInterest real :: p, r, t, i write(*,*) \"principal, rate, time:\" read(*,*) p, r, t if (p <= 0) then write(*,*) \"No negative or zero balances\" else if (r < 0.0 .or. r > 1.0) then write(*,*) \"Rates between 0.0 and 1.0\" else if (t <= 0) then write(*,*) \"Time must be > 0\" else i = p * r * t write(*,*) \"Interest = $\", i end if end program simpleInterest\n\nIt first checks if the principal, p, is less than or equal to 0 (Line 5). If it is, it prints a message, and the program ends. If p is greater than zero, if then checks to see if the rate, r, is less than 0.0 or greater than 1.0, i.e. out of the bounds 0.0…1.0 (Line 7). If it is out of bounds, then a message is printed and the program ends. If p is greater than 0, and r is within bounds, then it checks if the time, t, is less than or equal to zero (Line 9). If it is, it prints a message, and the program ends. If it passes all three checks, i.e. all three inputs are valid, then it hits the final else statement, and performs the interest calculation (Lines 12-13).\n\nThis isn’t really that complicated, but it shows how we can start to build more options into the programs we write.\n\nIt’s not hard to make programming concepts appear simple. In fact you can do it with very little effort.\n\nHumans make decisions on a daily basis, so it goes without saying that systems must also make decisions, albeit in the guise of algorithms. Decision, selection, or conditional statements, as they are often referred to, are the basic logical structures of programming. A conditional statement resembles a fork in the road; there are at least two paths that may be taken and one must be chosen. Consider the following description of an if statement:\n\nThe if statement allows a program to choose between two alternative paths by testing the value of an expression.\n\nPrograms “flow” from start to end, activating each instruction as they proceed. For example, consider the following statements:\n\n1 radius = 3.784 2 height = 12.3 3 areaCir = pi * radius^2 4 volCyl = areaCir * height\n\nThe statements are activated in sequence from line 1 to line 4. An if statement is a control structure that allows for a branch to occur in the flow of control in a program: if a certain condition exists, then perform one action, else perform another action. Here is what a basic if statement looks with only one option:\n\nThe code in the program moves linearly from statement A, until it encounters an “if” statement. At the if statement, some condition is tested. If the condition is true, then the program activates an addition piece of code (made up of one or more statements). If the condition is false, nothing happens, and the program bypasses the if statement and continues on to statement B. You will notice that there is no else portion of the decision, as it is usually optional – you can just have the if do something if the condition is true, otherwise it does nothing. If there is an “else” part to the decision, activated when the condition is false, the diagram is just modified, so that the if statement activates the piece of code in the else portion. Here is what the if-else looks like visually:\n\nThe if statement is pretty ubiquitous in programming languages, and the only thing that really changes is its syntax (how it is constructed). Some languages use the word then, others assume that the statements after the condition are associated with the “true” part of the branch – as is the case with Julia.\n\nIn the Julia example below, a branch is made based on whether a person worked <= 40 hours, or more than 40 hours. Based on the value of hours, a different value of pay is calculated. This value may then be used to calculate taxes owed, or some other things.\n\nif (hours <= 40.0) pay = rate * hours else pay = rate * (40.0 + (hours-40.0)*1.5) end\n\nHere is the same example written in Fortran, the only difference is that Fortran uses the keyword then, and terminates using “end if” instead of just the end of Julia.:\n\nif (hours <= 40.0) then pay = rate * hours else pay = rate * (40.0 + (hours-40.0)*1.5) end if\n\nPython is a little different again, because it uses indenting instead of terminators like “end“.\n\nif hours <= 40.0: pay = rate * hours else pay = rate * (40.0 + (hours-40.0)*1.5)\n\nFinally here is C, which in its simplest form looks like this:\n\nif (hours <= 40.0) pay = rate * hour; else pay = rate * (40.0 + (hours-40.0)*1.5);\n\nNote that while the syntax changes, the fundamental concept of how an if statement works is the same. Make a decision, branch in a program.\n\nEarly versions (Cobol74) of if statements in Cobol were of the form:\n\nif condition sentence-1 else sentence-2.\n\nWith the statement’s scope terminated by a period. Consider the following piece of code:\n\nif A = 1 if B = 1 display “Both A & B equal 1” else next sentence else if B = 1 display “A NOT = 1, but B = 1” else display “Neither A NOR B = 1”.\n\nThe phrase next sentence is an archaic artifact which sends control to the first statement which follows the next period, if B=1 is false. In the Cobol85 standard a more elegant solution in the form of an end-if scope terminator was introduced. This essentially transforms the above code into:\n\nif A = 1 if B = 1 display “Both A & B equal 1” end-if else if B = 1 display “A NOT = 1, but B = 1” else display “Neither A NOR B = 1” end-if end-if.\n\nNote that this code is not written like this:\n\nif A = 1 if B = 1 display “Both A & B equal 1” end-if else if B = 1 display “A NOT = 1, but B = 1” else display “Neither A NOR B = 1” end-if.\n\nThe compiler WILL complain that there is an end-if missing. The keyword then can also be incorporated in the following manner, although technically it is not needed:\n\nif A = 1 then if B = 1 then display “Both A & B equal 1” end-if else if B = 1 then display “A NOT = 1, but B = 1” else display “Neither A NOR B = 1” end-if end-if.\n\nBy 1977, Fortran had likely its greatest metamorphosis from an unstructured, to a quasi-structured language. At the eleventh hour the revision for the F77 standard was modified to reduce the impact of goto statements to match other languages, where its influence was minimal, or even non-existent. The changes made Fortran 77 vastly different from its predecessor, Fortran 66.\n\nOf major importance, was the inclusion of a “block IF“, which took the following form:\n\nIF (E) THEN ... END IF\n\nThe use of THEN as a new keyword allowed a block of statements to be incorporated until the terminating keyword ENDIF was reached. This also solved the dangling else problem. This was augmented by the addition of the keyword ELSE, which allowed for a group of statements to be actioned if the preceding IF is not satisfied.\n\nIF (E) THEN ... ELSE ... ENDIF\n\nBy the mid-70s, Fortran was likely coerced into making these changes due to the competition from C and Pascal, both of which offered these conditionals. These new F77 constructs allowed for improved program readability, especially through eliminating the need for statement labels, and goto statements. Here is an example:\n\nIF (K.GT.0) THEN POSNUM = POSNUM + 1 ELSE IF (K.LT.0) THEN NEGNUM = NEGNUM + 1 ELSE ZEROS = ZEROS + 1 ENDIF\n\nThe emergence of Ada did nothing to evolve the if statement. Like Pascal and F77, it used a then keyword, borrowed the else-if idea from Algol68, renaming it elsif, and used the same structure terminator endif, as F77. By this stage, if statements had likely evolved as far as they would, and new languages were just selecting appropriate concepts from existing languages.\n\nif C1 then S1 elsif C2 then S2 elsif Cn then Sn else S(n+1) endif;\n\nFortran 90 would go on to finally make the arithmetic if obsolescent. Python would alter very little, adopting the elif of Algol68, and the lack of parentheses.\n\nif x == 0: zeroes = zeroes + 1 elif x < 0: negnum = negnum + 1 else: posnum = posnum + 1\n\nJulia as well uses an amalgam of structural pieces.\n\nif x < 0 negnum = negnum + 1 elseif x > 0 posnum = posnum + 1 else zeroes = zeroes + 1 end\n\nWe are now in the age of mix-and-match, and it is unlikely the if statement will evolve to any great extent.\n\nThe design of the if statement in Algol 60 was likely the pinnacle of its evolution. From here on in every language tweaked its syntax, but there were no major changes. Languages like Algol 68, C, and Pascal all had conditional statements. Algol 68, although having the same name as “Algol” moniker, was a different language altogether.\n\nWhereas Algol 60 required the use of explicit compound statements within an if statement if more than one statement was being controlled, Algol 68 incorporated the use of control structure terminators. For the if statement this meant the use of the reversed keyword fi. Algol 68 still lacked the parentheses of Fortran, but also had no requirements for compound statements, as each section was self-delineated. It had the following general form:\n\nif C then ... else ... fi\n\nThis had the added effect of eliminating the dangling-else problem of Algol 60. Algol 68 also added the keyword elif, a short-hand to allow for a series of else-if statements:\n\nif C1 then ... elif C2 then ... elif C3 then ... else ... fi\n\nHere is an example:\n\nif x>0 then posNum := posNum + 1; elif x<0 then negNum := negNum + 1; else zeros := zeros + 1; fi\n\nThe if statement of C simplified that of Algol 60, deleting the then clause, and adding parentheses to enclose the conditional statement. It had the following general form:\n\nif (C) statement1; else statement2;\n\nHowever, similar to Algol 60, groups of statements require the use of compound statements delineated by { }, and C also suffers from the dangling-else problem of Algol 60. Here is an example:\n\nif (x>0) posNum := posNum + 1; else if (x<0) negNum := negNum + 1; else zeros := zeros + 1;\n\nPascal, which arrived at a similar time to C, has a syntax similar to that of C – except its logical expression was bracket-less, and it used the then keyword, like Algol 60. Like Algol 60, it also suffered from the dangling-else problem, and required the use of begin-end delineators for a compound statement.\n\nif C then S else S2;\n\nFortran did not make any inroads into modifying the if statement until later. Likely spurned on by Algol 60, Fortran IV introduced the logical if statement in 1965. It had the following form:\n\nIF (E) STATEMENT\n\nWhere E was a logical expression, using operators of the form .EQ. for =, and .LE. for ≤. The statement was any statement except a DO statement or another logical IF. However unlike Algol 60, there were no compound statements, and no keyword corresponding to else. Both these had to be achieved by means of goto statements. In this sense it almost mimicked an if-else statement. Consider the example below:\n\nIF (A .LE. 0) GOTO 15 W = X ** A GOTO 20 15 W = 0 20 ...\n\nIn this case, if the value of A is less than of equal to zero, the program jumps to statement 15, setting W to 0. Otherwise it calculates W=X**A, and jumps to statement 20. Notice that the Fortran conditional “operators” are stropped by the use of periods, e.g. .EQ.. This was done to avoid potential ambiguity. The expression A LE 0 could also have been interpreted as the variable ALE0. Fortran 66, the first industry standard made no changes to the if statement.\n\nThere were a number of differences between Fortran (IV) and Algol (60):\n\nFortran used mnemonics to represent conditional operator, e.g. .LE., versus Algol’s ≤ (in some implementations <= was used due to the non-availability of ≤)\n\nFortran uses parentheses, ( ), to separate the logical expression from the statement, whereas Algol uses the additional keyword then.\n\nFortran (66) required that each arithmetic statement on either side of a conditional be of the same datatype. This is because A.GT.B was often translated to A-B.GT.0.(This disappeared in F77).\n\nBy all accounts, Fortran IV, and 66 were extremely deficient with respect to conditional statements. The next major changes were not to appear until Fortran 77.\n\nConsider code that looked like this in Algol 60:\n\nif k>0 then posNum := posNum + 1 else if k<0 then negNum := negNum + 1 else zeros := zeros + 1\n\nThe equivalent in Fortran 66 would be:\n\nIF (K.GT.0) GOTO 30 IF (K.LT.0) GOTO 31 ZEROS = ZEROS + 1 GOTO 47 30 POSNUM = POSNUM + 1 GOTO 47 31 NEGNUM = NEGNUM + 1 75 ...\n\nHow did if evolve in other languages? Algol 68, C, Pascal?\n\nArguably one of the most important control structures to evolve is “if“. Without it, programs couldn’t make any sort of decisions.\n\nFew algorithmic languages, apart from Plankalkül (1948), contained conditional statements. Plankalkül formed conditional statements with the help of a symbol which was an arrow with a period above it, which was used in the following manner:\n\nThe left side of the statement, B, signifies the condition (Bedingung) and is an expression with a boolean value, and the right side, a, is an arbitrary statement. If B evaluates to 0 (nein), then the statement ends here, otherwise if B is 1 (ja), then the statement continues with a. There is no “else” statement. Heinz Rutishauser’s Superplan (1949-1951), did not have a decision statement.\n\nDecision statements in programming languages are intrinsically linked to branch instructions in assembler. The first language to use something akin to the modern form of the if statement was likely Fortran I which used an if statement as a form of three-way goto statement.\n\nIF (E) L1, L2, L3\n\nThe expression, E is evaluated and one of the alternative paths of L1, L2, and L3 is chosen based on whether E is negative, zero or positive. This became known as the arithmetic if. This could be used to derive a three-way decision statement of the form:\n\nIF (X-Y) 10, 10, 30 10 MAXNUM = Y GO TO 20 30 MAXNUM = X 20 ...\n\nThis says that if X-Y is less than or equal to zero, then the maximum is Y, otherwise the maximum is X. This made sense in the context of unstructured jumps using go to. This allowed for a very limited decision structure, where the expression always had to be expressed in terms of some numeric output.\n\nIn 1957-58 John McCarthy, developer of Lisp, was writing a series of routines for legal chess moves in Fortran which prompted him to invent conditional expressions. He found the arithmetic if construct from Fortran I and II “awkward to use” [McCarthy81], and found it more natural to invent a Fortran function XIF(M,N1,N2) whose value was N1 or N2 based on whether M was zero or not (it was written in machine language). The function was likely not that efficient, as it required all three arguments to be evaluated before XIF() was entered. In Lisp, the conditional took the form of the cond function:\n\n(cond (condition1 result1) (condition2 result2) ... (T resultN))\n\nLater a more “traditional” like conditional operator was included into the specifications for Lisp, and appeared as follows:\n\nX = IF (N .EQ. 0, ICAR(Y), ICDR(Y))\n\nMcCarthy suggested the use of this concept in Algol 58 when he was a member of the Algol committee. In the Algol 58 preliminary report the if statement took the form:\n\nif (a>0); c:=a↑2↓×b↑2↓ if (a<0); c:=a↑2↓+b↑2↓ if (a=0); go to bed\n\nAlgol 58 did not really progress much, and was superseded by Algol 60. Algol 60 added the keyword then, to separate the logical expression from the statement to be executed. many considered this if-then combination to make the statement more readable. The Algol statement was also extended to include an “else” part. Here is an example of an if-then-else in Algol 60.\n\nif x > 0 then pos := pos + 1 else negzero := negzero + 1\n\nThis lead to the ambiguity we know today as the “dangling-else”. Whereas a statement such as:\n\nif x=0 then if y=0 then m:=m+1\n\nis not ambiguous, the following statement could be:\n\nif x=0 then if y=0 then m:=m+1 else n:=n-1\n\nIs 1 to be subtracted from n when x is non-zero, whatever the value of y, OR when x is zero but y is not? A conundrum.\n\nTo further add to the structural space, these if statements were constrained to the control of a single statement, which limited their usefulness. Algol 60 dealt with this through the use of the compound statement it had introduced using the keywords begin and end. For example, a piece of code to swap two numbers if x < y:\n\nif x<y then begin dummy:=x; x:=y; y:=dummy end\n\nOr, written in a more readable manner (many early languages crammed as much as they could on one line – blame punch-cards):\n\nif x<y then begin dummy:=x; x:=y; y:=dummy end\n\nThis structure could also be used to reduce the dangling-else problem:\n\nif x=0 then begin if y=0 then m:=m+1 else n:=n-1 end\n\nREF(S):\n\n[McCarthy81] McCarthy, J., “LISP Session”, History of Programming Languages, pp.173-197, ACM (1981)\n\nA programming language designed for use by novice programmers should follow the principles described in cognitive load theory (CLT), which helps reduce the load on working memory. The basic cognitive architecture is divided into three stores of memory: sensory memory, short-term memory, and long-term memory [1]. Information from the environment enters the mind through he sensory memory (decay period is maybe several hundred milliseconds). The short-term memory, also known as the “working memory”, performs conscious processing (decay period = 15-30 seconds). Long-term memory is the permanent store of information. It is the working memory that is effected by cognitive load: it is not stored for that long, and there is a very limited capacity (7±2 items). These limitations in working memory pose a severe constraint on learning capacity.\n\nThe cognitive load on the novice programmer is always high. This is partially because of the large assortment of concepts to be learned, and the immense syntactic structure of some languages. Let’s take java for example. The quintessential program for beginners is “Hello World”. Here is the Java version of the program.\n\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello, World!\"); } }\n\nMany times novice programmers are told that the key line is System.out.println(), and to ignore the terms public, class, main, String[], and args – they will be explained later. It is however difficult to ignore these things in such a simple program. In five lines of text this simple program introduces the ideas of visibility modifiers (public), OO (class), method names (main), parameters, and arrays. This provides the perfect scenario for information overload. Compare this against the same task in Python or Julia:\n\nPython: print \"Hello, World!\" Julia : println(\"Hello, World!\")\n\nThe cognitive load here is quite low in comparison, as there are no requirements beyond using a statement to print the string “Hello, World!” to the screen. Another case involves I/O in C. Consider the following code in C to obtain an integer from the user, and print it out:\n\n#include <stdio.h> int main(void) { int n; scanf(\"%d\", &n); printf(\"%d\", n); return 0; }\n\nThis simple program requires the novice programmer to understand the following:\n\nC requires a library to be included for I/O.\n\nC requires variables to be declared before they are used.\n\nC requires the exact format of the data to be input (or output) to be specified by means of formatting codes.\n\nC requires a basic understanding of the address-of operator (&) and hence pointers in order to successfully store a number input by a user.\n\nC requires come understanding of void parameters, and return types.\n\nThis is a simple program, albiet one with a potentially high cognitive load. This is further complicated by the fact that erroneous input by the user will break the program. Consider a similar program in Python:\n\nn = int(input(\"number? \")) print(n)\n\nIn this program the novice programmer is still required to have an understanding of the function input(), which takes any input typed by the user, and int() which converts the input to an integer, but there is no other requirement to understand how or where the memory is stored. This therefore has a lower cognitive load. Julia uses a similar construct:\n\nn = chomp(readline(STDIN)) n = parse(Int, n) println(n)\n\nThe only difference here is that the function readline() reads input from the user, chomp() removes the trailing RETURN key pressed by the user, and parse() turns what is essentially a string into an integer. As such it probably has a higher cognitive load than Python, largely because the used is not use to words like chomp and parse.\n\nMost teachers forget the effect of cognitive load on trying to program because we are experts, whose programming knowledge is tacit, i.e. it can’t readily be taught in the same way that people recognize a face in a crowd. When a person sees a face they recognize, they are not conscious of the individual features of the face, only the face as a whole. Similarly an expert programmer may look at a program and understand what the program does, without having to go through every line of code.\n\nLanguages such as C are rife with syntax that increase the cognitive load of the novice programmer. Even if they aren’t taught the syntax, they will encounter it, and have to deal with it. Take for example the notion of the ternary operator, basically a shortcut decision operator found in many languages.\n\nn = (x != 0) ? x+1 : 4;\n\nThis basically says that if x is not equal to 0, assign n the value x+1, otherwise assign n the value 4. The problem is that it requires more extensive knowledge of the language than novices require. It could have also been written as:\n\nif (x != 0) n = x + 1; else n = 4;\n\nThis is not as compact, but much more readable to the novice programmer, and more importantly has a lower cognitive load.\n\n[1] Atkinson, R. C., Shiffrin, R. M., “The psychology of learning and motivation: advances in research and theory”, in The psychology of learning and motivation: Advances in research and theory, Vol. 2, pp. 89–195 (1968)"
    }
}