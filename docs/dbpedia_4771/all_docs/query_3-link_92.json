{
    "id": "dbpedia_4771_3",
    "rank": 92,
    "data": {
        "url": "https://cs.lmu.edu/~ray/notes/plstudy/",
        "read_more_link": "",
        "language": "en",
        "title": "plstudy",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://cs.lmu.edu/~ray/images/fortran-logo32.png",
            "https://cs.lmu.edu/~ray/images/c-logo32.png",
            "https://cs.lmu.edu/~ray/images/go-logo32.png",
            "https://cs.lmu.edu/~ray/images/js-logo32.png",
            "https://cs.lmu.edu/~ray/images/java-logo32.png",
            "https://cs.lmu.edu/~ray/images/kotlin-logo32.png",
            "https://cs.lmu.edu/~ray/images/swift-logo32.png",
            "https://cs.lmu.edu/~ray/images/perl-logo32.png",
            "https://cs.lmu.edu/~ray/images/julia-logo32.png",
            "https://cs.lmu.edu/~ray/images/lisp-logo32.png",
            "https://cs.lmu.edu/~ray/images/clojure-logo32.png",
            "https://cs.lmu.edu/~ray/images/haskell-logo32.png",
            "https://cs.lmu.edu/~ray/images/python-logo32.png",
            "https://cs.lmu.edu/~ray/images/apl-logo32.png",
            "https://cs.lmu.edu/~ray/images/k-logo32.png",
            "https://cs.lmu.edu/~ray/images/redmonk.png ",
            "https://cs.lmu.edu/~ray/images/fortran-logo32.png",
            "https://cs.lmu.edu/~ray/images/kotlin-logo32.png",
            "https://cs.lmu.edu/~ray/images/lisp-logo32.png",
            "https://cs.lmu.edu/~ray/images/python-logo32.png"
        ],
        "movies": [
            "https://www.youtube.com/embed/prIwpKL57dM",
            "https://player.vimeo.com/video/71278954?h=955cc6c33d&title=0&byline=0&portrait=0",
            "https://www.youtube.com/embed/aGJTXdXQN2o",
            "https://www.youtube.com/embed/6avJHaC3C2U",
            "https://www.youtube.com/embed/xu0jWgGoDjc",
            "https://www.youtube.com/embed/S9sS55s-oR0"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "The Study of Programming Languages\n\nHello! Since you are here, you are probably wondering why the study of programming languages a worthy pursuit. “What’s in it for me?” you may be asking. Fear not—there are benefits. “How should I study them?” you may be asking. There are good answers to this question, too.\n\nWhy Study Programming Languages?\n\nBecause benefits.\n\nProfessional Benefits\n\nStudying programming languages will help you in many ways! For instance, you will:\n\nExpress yourself better\n\nExpertly wielding language, whether natural or programming, allows you to communicate ideas powerfully. Programming is a form of written expression just like writing novels, short stories, technical manuals, wikis, screenplays, essays, dialogues, articles, and poetry. Just as knowledge of rhetoric can improve your prose, verse, and arguments, knowledge of programming languages improves your ability to express yourself in code. Studying the mathematical formalisms underlying language syntax and semantics leads to expertise in reading and writing precise specifications.\n\nBecome a better technical decision-maker\n\nYou will be able to choose the most appropriate language for a given task. Some languages do a great job expressing some kinds of tasks and do a terrible job at others. You will be able to describe design tradeoffs (garbage collection or not, compile-time type safety or not) and be able to articulate how exactly languages like Rust, Swift, and Zig compete against C and C++.\n\nLearn new languages more easily\n\nThinking in terms of language independent concepts (e.g. types, sequencing, iteration, selection, recursion, concurrency, subroutines, parameterization, naming, scope, abstraction, inheritance, composition, binding, method dispatch, etc.), rather than in one particular language’s syntactic constructs (e.g., “if statement,” “while statement,” “virtual function”), enables you to adapt to any programming environment.\n\n... Mastering more than one language is often a watershed in the career of a professional programmer. Once a programmer realizes that programming principles transcend the syntax of any specific language, the doors swing open to knowledge that truly makes a difference in quality and productivity. — Steve McConnell\n\nBecome more productive\n\nAs you become able to use the languages you do use more effectively. If you know how and why a language was designed, you can:\n\nchoose the best and most efficient feature for the task at hand\n\nutilize some of its non-obvious powerful features\n\nsimulate useful (and powerful) features from other languages that your language lacks\n\nunderstand obscure features\n\nunderstand weird error messages\n\nunderstand and diagnose unexpected behavior\n\nunderstand the performance implications of doing things a certain way\n\nuse a debugger effectively\n\nDesign (and implement!) your own language\n\nThere are many good reasons for creating new languages to solve problems (see this essay by Tom Van Cutsem). Even if you never create a complete language, you might need to write your own little language as part of a larger application, for example:\n\nA query language for database access\n\nA query language for a search engine\n\nA calculator\n\nA console interface to an adventure game\n\nExpand your mind\n\nYou cannot grow when your thinking about programming is fixed. Study programming languages to encounter fascinating ways of programming you might never have even imagined before, achieving enlightenment as you deeply understand pattern matching, type inference, closures, prototypes, introspection, instrumentation, just-in-time compilation, annotations, decorators, memoization, traits, streams, monads, actors, mailboxes, comprehensions, continuations, wildcards, regular expressions, proxies, and transactional memory.\n\nExercise: What is a monad? What is a continuation?\n\nYour study will lead you to embrace languages, and programming environments, that may be different than you’ve ever imagined. You do know about eToys, right?\n\nPrepare yourself to build some stunning things\n\nImagine formally-verified compilers, formally-verified hardware, formally-verified programs, the world’s smartest and fastest IDE, code generators from specifications, block-programming environments that actually work, and so on. To build programs that manipulate and build other programs, you need the deep understanding of what programs are, and this comes from studying the field of Programming Languages.\n\nSo basically, you will become happier and make more money.\n\nSocial Benefits\n\nStudying programming languages may even enable you to:\n\nParticipate in exciting academic and professional discussions at meetups and conferences, making new friends.\n\nSocialize with researchers in linguistics, programming languages, and people interested in communication, making even more new friends.\n\nMake a difference in the world, with a programming language you design yourself, gaining followers and subscribers.\n\nImpress your friends with esoteric, geeky, fun, and sometimes arcane knowledge, gaining admirers.\n\nIs it Really a Field of Study?\n\nThe ACM says yes!\n\nKnowledge AreaCodeSome Topics Algorithms and ComplexityALAlgorithmic Analysis • Algorithmic Strategies • Data Structures and Algorithms • Automata • Computability • Computational Complexity Architecture and OrganizationARDigital Logic and Digital Systems • Machine-level Data Representation • Assembly-Level Machine Organization • Memory System Organization and Architecture • Interfacing and Communication • Functional Organization • Multiprocessing and Alternative Architectures • Performance Enhancements Computational ScienceCNModeling and Simulation • Processing • Interactive Visualization • Data, Information and Knowledge • Numeric Analysis • Symbolic Computation • Mathematical Modeling • High-Performance Computing Discrete StructuresDSLogic • Sets, Relations, and Functions • Proof Techniques • Basics of Counting • Graphs and Trees • Discrete Probability Graphics and VisualizationGVMedia Applications • Digitization • Color Models • Rendering • Modeling • Animation • Visualization Human-Computer InteractionHCIInteractive Systems • Testing • Collaboration and Communication • Statistical Methods • Human Factors • Mixed, Augmented, and Virtual Reality Information Assurance and SecurityIASDefensive Programming • Threats and Attacks • Network Security • Cryptography • Web Security • Platform Security • Policy and Governance • Digital Forensics • Secure Software Engineering Information ManagementIMDatabase Systems • Data Modeling • Indexing • Key-Value, Document, Relational, and Graph Databases • Query Languages • Transaction Processing • Distributed Databases • Physical Database Design • Data Mining • Information Storage and Retrieval • Multimedia Systems Intelligent SystemsISKnowledge Representation and Reasoning • Search • Machine Learning • Reasoning Under Uncertainty • Agents • Natural Language Processing • Robotics • Speech Recognition and Synthesis • Perception and Computer Vision Networking and CommunicationNCNetworked Applications • Reliable Data Delivery • Routing and Forwarding • Local and Wide Area Networks • Resource Allocation • Mobility • Social Networking Operating SystemsOSOperating System Organization • Concurrency • Scheduling and Dispatch • Memory Management • Security and Protection • Virtual Machines • Device Management • File Systems • Realtime and Embedded Systems • Fault Tolerance • System Performance and Evaluation Platform-Based DevelopmentPBDWeb Platforms • Mobile Platforms • Industrial Platforms • Game Platforms Parallel and Distributed ComputingPDParallel Decomposition • Communication and Coordination • Parallel Algorithms, Analysis, and Programming • Parallel Architecture • Parallel Performance • Distributed Systems • Cloud Computing • Formal Models and Semantics Programming LanguagesPLObject Oriented Programming • Functional Programming • Event-Driven and Reactive Programming • Type Systems • Program Representation • Language Translation and Execution • Syntax Analysis • Semantic Analysis • Code Generation • Runtime Systems • Static Analysis • Concurrency and Parallelism • Type Systems • Formal Semantics • Language Pragmatics • Logic Programming Software Development FundamentalsSDFAlgorithms and Design • Fundamental Programming Concepts • Fundamental Data Structures • Development Methods Software EngineeringSESoftware Processes • Project Management • Tools and Environments • Requirements Engineering • Software Design • Software Construction • Software Verification and Validation • Software Evolution • Software Reliability • Formal Methods Systems FundamentalsSFComputational Paradigms • Cross-Layer Communications • State and State Machines • Parallelism • Evaluation • Resource Allocation and Scheduling • Proximity • Virtualization and Isolation • Reliability through Redundancy • Quantitative Evaluation Social Issues and Professional PracticeSPSocial Context • Analytic Tools • Professional Ethics • Intellectual Property • Privacy and Civil Liberties • Professional Communication • Sustainability • History • Economics of Computing • Security Policies, Law, and Crime\n\nYou might even find the study of languages, especially in its theoretical side, to be even more fundamental than the favorite of job interviewers—data structures and algorithms. Language theory directly deals with how information itself is expressed, organized, and manipulated. Without a way to represent data or computation, we really wouldn’t have computer science.\n\nHow to Study Programming Languages\n\nSelf-check time! Make sure you know what a programming language is.\n\nDid you read the article? No? Read it. Now? Okay, let’s lay out a study plan.\n\nAn effective study of programming languages has three parts:\n\nThe study of those three technical parts requires concurrent study of two less technical but necessary and important threads:\n\nLet’s give a very brief overview of these five items, in this order:\n\nHistory\n\nLearning (Specific) Languages\n\nLearning (Language-independent) Concepts\n\n(Mathematical and Logical) Foundational Theories\n\nPragmatics\n\nHistory\n\nYour study of programming languages is enhanced when done in a historical context. Programming Languages do have a rich history. There have been many books and articles written on the History of Programming Languages (HOPL). It’s really fascinating! And super important, too.\n\nWe can’t boil the history of the field into a couple paragraphs, but there are some historical highlights worth mentioning to whet your appetite:\n\nEarly History\n\nPrior to the 1940s we have the Jacquard machine and Ada Lovelace's programming of the Analytical Engine. Plankalkül is designed in the early 1940s but never gets popular. It’s a high-level language, yes, but mostly symbolic.\n\n1950s-1960s Rise of natural language-like languages\n\nGrace Hopper leads the COBOL effort (business computing), John McCarthy leads Lisp (AI), John Backus leads Fortran (scientific computing). Early Algol becomes popular and eventually we get behemoth multi-purpose languages like Algol 68 and PL/1.\n\n1970s The structured programming revolution begins\n\nLanguages providing information hiding, such as Modula, CLU, Simula, Mesa, and Euclid attempt to address the “software crisis.” Structured and modular features are bolted on to earlier languages.\n\n1980s Object-orientation takes over the world\n\nThough begun in the 1960s with Simula and refined in the 1970s at Xerox PARC with Smalltalk, OO—or approximations to it—explodes in the 1980s with C with Classes (since renamed C++), Objective-C, Eiffel, and Self. Earlier languages such as Lisp and Pascal gain OO features, becoming Common Lisp and Object Pascal, respectively.\n\n1990s The World Wide Web appears\n\nPerl becomes popular. Java, JavaScript, and PHP are created with web applications in mind.\n\n2000s: Interest in established dynamic languages such as Ruby takes off\n\nScala shows that static languages can feel dynamic. Clojure arrives as a dynamic, modern Lisp, leveraging Java’s virtual machine.\n\n2010s: Old things become new again\n\nMulticore processors and “Big Data” revive interest in functional programming. Older languages such as Python and R, and the newer Julia language, find use in data science. Net-centric computing and performance concerns make static typing popular again as Go, Rust, and Swift challenge C and C++ for native applications.\n\n2020s: People are talking about AI again\n\nMojo is created with direct support for AI, and particularly machine learning, applications, allowing programmers to not have to employ a variety of external packages to get their work done.\n\nOverviews are nice, but you’ll need to go much deeper. Here are some great reads and watches:\n\nWikipedia’s article on the History of Programming Languages\n\nList of recommended reads from a Hacker News question\n\nMany people don’t realize what incredible work happened in the 1960s and 1970s. Learn about this era in this informative and entertaining look into what this work could have turned into, so much sooner that it did, if it did:\n\nExercise: Watch this video, please. Follow along with the video notes and references.\n\nFollow up with your own web searches for “History of Programming Languages” or “Evolution of Programming Languages.”\n\nLearning Languages\n\nOne dimension of the study of programming languages is to learn how to program in a lot of languages. By doing so, some of the important linguistic concepts will naturally emerge. But which languages should you learn, and what should you learn about them? A good place to start is to note:\n\nWhether a language is significant or not. A significant language is one that has had a major impact on the design of future languages, or has come into widespread use.\n\nThe context in which the language was designed. Perhaps it was designed to solve a particular problem or address a particular problem domain. You might even track the evolution of the language over time, as intended application areas may change over the life of the language.\n\nUnderstanding a language’s motivation for existence is essential. It is unfair to criticize a language for doing a bad job in an area which it was never intended to be used for.\n\nSome Significant Languages\n\nHere are a few languages that for some reason or another rate as significant. The reasons why they are grouped the way they are shown here will be discussed in class:\n\nFortran (I, II, IV, 66, 77, 90, 95, 2003, 2008, 2018, 2023)\n\nLisp, Scheme, Common Lisp, Clojure\n\nCOBOL (60, 68, 74, 85, 2002, 2014, 2023)\n\nAlgol (58, 60, W, 68), Pascal, Modula (2, 3), Oberon\n\nPL/I\n\nAPL, J, K, Q\n\nBASIC\n\nClu, Alphard, Euclid, Mesa, Cedar, Turing, Ada (83, 95, 2005, 2012, 2023)\n\nForth, Factor\n\nBCPL, B, C (K&R, 90, 99, 11, 17, 23), C++ (98, 11, 14, 17, 20, 23, 26), D, Rust, Zig, Odin\n\nJava, C#, Scala, Kotlin\n\nPerl, PHP, Hack, Tcl, Python, Ruby, Groovy, Lua\n\nSimula, Smalltalk (72, 74, 76, 80), Object Pascal, Eiffel\n\nConcurrent Pascal, Occam, Linda, SR, Erlang, Elixir, Go, Chapel, Gleam\n\nObjective C, Swift\n\nSelf, JavaScript, ActionScript, CoffeeScript, TypeScript\n\nStandard ML (90, 97), CAML, Ocaml, F#\n\nMiranda, Haskell, PureScript, Elm\n\nCoq, Agda, Lean, Idris\n\nProlog\n\nSnobol, Icon\n\nId, Val, Sisal\n\nSQL\n\nPostscript\n\nMojo\n\nMATLAB, R, Julia\n\nIntercal, Unlambda, LOLCODE, ArnoldC, Brainfuck, Malbolge, Befunge, Whitespace\n\nGolfScript, Pyth, CJam, Jelly, 05AB1E\n\nMotivation\n\nHere are some languages and their motivations for being created. In some cases, the language found a niche outside the purpose for which it was designed. But the point is that some problem was seen as significant enough to warrant a new language.\n\nFortran — Numeric computation\n\nLISP — Symbolic computation, artificial intelligence\n\nCOBOL — Business computation\n\nAlgol 60 — Algorithmic description\n\nAPL — Array processing with a concise mathematical notation\n\nAlgol 68 — Kitchen sink of programming language features\n\nPascal — Teaching structured programming\n\nModula — Modular programming\n\nC — Systems programming\n\nSQL — Database applications\n\nScheme — To simplify Lisp\n\nProlog — Expert systems; Natural language processing\n\nSmalltalk — Workstation GUI programming\n\nMATLAB — Numeric computation without having to use Fortran\n\nAda — Megaprogramming; Embedded systems\n\nC++ — Simulation\n\nML — Theorem proving\n\nPerl — Scripts, with a focus on text processing\n\nErlang — Massively scalable, reliable, soft realtime systems\n\nPython — To be an extensible scripting language\n\nRuby — To be the language Matz wanted (and better than Perl)\n\nLua — General-purpose scripting\n\nK — Ultra high-performance numerical (typically financial) analysis\n\nR — Statistical and graphical Computing\n\nJava — Compact downloadable executable components\n\nC# — To be the Java of the Microsoft (.NET) world\n\nJavaScript — Client-side scripting for web applications\n\nPHP — Server-side scripting for web applications\n\nPostscript — Formatting of printed documents\n\nHaskell — Unifying the best of existing functional languages\n\nIo — Dynamic language experimentation\n\nScratch — Creating and sharing interactive stories, games, music, and art\n\nScala — Supporting both object-oriented and functional programming\n\nF# — Solving complex problems simply\n\nClojure — To be a modern Lisp-dialect for the JVM\n\nNim — Expressivity in a systems programming language\n\nCoffeeScript — To be a better JavaScript\n\nDart — To be a better language for modern (web) apps\n\nGo — To build large distributed, interconnected systems\n\nParaSail — Safe, secure, highly parallel applications\n\nChapel — Parallel programming at scale\n\nRust — Large, safe, network clients and servers\n\nTypeScript — Large-scale JavaScript applications\n\nQuipper — Functional programming for Quantum computers\n\nHack — To do PHP-compatible things while keeping your sanity\n\nElm — To be a “delightful language for reliable webapps”\n\nElixir — Modernizing and extending Erlang\n\nKotlin — Fixing and improving Java\n\nJulia — Scientific computing in a dynamic language with near compiled-language speed\n\nCrystal — High expressiveness together with speed and safety\n\nSwift — Because it was time to make something more fun than Objective-C for iOS apps\n\nZig — Safety, efficiency, and reusability\n\nGleam — Type-safe systems that scale\n\nBallerina — To compose network services for cloud computing\n\nGrain — Support for web applications in a modern language\n\nVerse — Metaverse applications\n\nMojo — AI and machine learning applications\n\nExercise: Java is an example of a language whose primary use turned out to be completely different from its original design purpose. What are Java’s niches today?\n\nWhere to Learn More\n\nLanguage lists, comparisons, and taxonomies:\n\nWikipedia’s Programming Languages Article\n\nWikipedia’s Programming Language Lists\n\nAn overview I did (with some help from students)\n\nHyperpolyglot AWESOME\n\nLearn X in Y Minutes\n\nPixel’s Language Study with links to two great diagrams of language evolution and a great chart of syntax across languages\n\nAnother Diagram of Language Evolution (seems to have stalled at 2020)\n\nA fairly comprehensive list of languages, organized chronologically (stops at 2014)\n\nThe “Mother Tongues” Diagram (ancient, stops at 2001, but it has colors)\n\nAn arbitrary list of 256 languages, from 2013\n\nThe Programming Languages Category Page at RosettaCode\n\nExercise: Can anyone find more recent lists?\n\nAs you learn more languages, you will start to enjoy Rosetta Code, and hopefully contribute!\n\nLearning Language Concepts\n\nAn important part of language study is a deep understanding of language-independent concepts. The vocabulary around programming languages is massive, so how can you organize all this knowledge you will be gaining?\n\nPrerequisite Knowledge\n\nLet’s begin with some critically important terminology that underlies the study of programming languages. To aid your learning, the terms are motivated and chunked into five themes:\n\n1. Information\n\nInformation is that which informs. All usable information is representable as strings of characters. Today, virtually every information system uses the Unicode alphabet. Here are some example strings that give evidence that Unicode is sufficient for anything of interest to us:\n\n91332.3e-81 Stay behind the yellow line! /Pecs/Los Angeles/Berlin/Madrid//1 2/3 0/2 2/2 0/3 2/// (* (+ 88 3) (- 9 7)) int average(int x, int y) {return (x + y) / 2;} {\"type\": \"dog\", \"id\": \"30025\", \"name\": \"Lisichka\", \"age\": 13} ∀α β. α⊥β ⇔ (α•β = 0) 1. f3 e5 2. g4 ♛h4++\n\n2. Representation\n\nEach character in Unicode can be encoded into bits. The most widely used encoding for characters today is UTF-8. Characters are not the only basic information unit that can be encoded. The other two are numbers (e.g., 389.221E-25) and atoms (e.g., true, false, null, north, south, blue).\n\n3. Classification\n\nBasic information units (characters, numbers, and atoms) are chunked into data units called values. Values can be the basic characters, numbers, and atoms, as well as composite values including tuples, records, sums, variants, enums, lists, sets, dictionaries, and more. Values inhabit types which classify values by their shared behavior.\n\n4. Architecture\n\nA program is made up, structurally, of entities, which are things like literals, variables, declarations, expressions, statements, functions, procedures, coroutines, threads, processes, modules, and packages. The statics of a language shows how to put them together. Importantly, it also defines how names are bound to entities, and the scope of each binding. (When you take a compiler class, you will learn that naming is done with identifiers.)\n\nValues are not entities\n\nIt is sometimes easy to get confused between values, literals, and variables. This should help: values are pure information. Literals and variables are elements of a program that stand for and contain values, respectively.\n\nExercise: Study the terms above and make sure you understand them. Can you give examples of values? Can you give examples of entities? Can you explain the difference between a value and an entity?\n\n5. Execution\n\nWhen a program runs, computational entities generate and respond to events, that is, they communicate and coordinate with each other (possibly in concurrent, parallel, or distributed fashions). Internally, computations carry out execution according to different kinds of control flow: sequential, conditional, iterative, nondeterministic, asynchronous, etc. The dynamics of the language describe the computational orders and effects.\n\nThe Big Questions\n\nNow, before we can begin to organize all this knowledge, we’ll want to ask some pretty deep, philosophical questions, that will help to motivate an ontology, or at least the beginnings of one.\n\nWhat kinds of information units do we wish to store and process, and what are their behavioral capabilities? (Typing)\n\nHow do we denote, or encode, these values? (Representation)\n\nFrom what kinds of entities can we build our programs, and how do we name these entities? (Binding)\n\nHow do we chunk information and computational procedures into larger units to better manage large systems? (Abstraction)\n\nHow can we build entities that are customizable in some way? (Parameterization)\n\nHow do entities emit and respond to events? (Communication)\n\nHow do we synchronize various sub-computations? When do we require sequential execution and when do we allow true parallel execution? (Coordination)\n\nHow can computations know about themselves? (Metaprogramming)\n\nHow can we know our programs always do what they should? (Correctness)\n\nHow do we know they never do what they should not? (Security)\n\nOntologies\n\nWhen we start examining the little things, it’s nice to organize concepts into an ontology. There are many possible ontologies. Since we’re just getting a high-level view of the field right now, let’s just throw some things out there. Don’t worry if most of these terms are completely unfamiliar:\n\nNaming. We have to be able to name things. Naming is indispensible even in human languages.\n\nBinding: associating names with entities\n\nScope: the region in space or time in which a binding is active\n\nVisibility: sometimes you can see a name, sometimes you can’t\n\nExtent: the lifetime of a binding\n\nStorage class: “Where” are certain named (entities) stored?\n\nLinkage: How, if at all, are names accessible from the outside?\n\nDefining vs. referencing occurrences\n\nOverloading and aliasing\n\nPolymorphism (static/dynamic)\n\nBound vs. free names\n\nShallow vs. deep binding\n\nStatic vs. dynamic scope\n\nEvaluation. How do we express value-producing computations? An expression is either a value, or one or more expressions joined by operators. Expressions are evaluated to produce a value.\n\nOperators (Precedence, assocativity, fixity, arity)\n\nEvaluation order (defined, undefined, short-circuit)\n\nSide effects\n\nLvalues vs. Rvalues\n\nInitialization vs. Assignment\n\nAssignables (mutable variables)\n\nEager vs. Lazy Evaluation\n\nInteresting values: are errors values? are types values?\n\nMacros\n\nExecution. Computations often are required to occur in time. Some constructs, called statements or commands, are executed to produce actions, or effects. Some are triggered by events. How can we organize these actions so they occur when we want them to?\n\nSequencing (semicolon, comma)\n\nSelection (if, switch, case)\n\nIteration (for, while, forEach, takeWhile)\n\nRecursion\n\nProcedural/Functional abstraction\n\nNon-determinism\n\nConcurrency\n\nAsynchronicity\n\nParallelism\n\nDisruption (return, break, continue, throw, panic)\n\nTypes. A value’s type constrains the way it may be used in a program. Types impose constraints on what we can and cannot say. How can we classify values so that they behave in certain, predictable ways?\n\nFixed set of types or can you create new ones?\n\nAre types extra-lingual or are they values you can manipulate (first-class types)?\n\nTypes vs. Classes vs. Typeclasses\n\nType Expressions\n\nEquivalence, compatibility, checking, coercion\n\nInference\n\nSpectra: static vs. dynamic, strong vs. weak, manifest vs. inferential, nominal vs. structural\n\nParameterized types (generics), covariance, contravariance, invariance\n\nDependent types\n\nBasic types: Boolean, numerics, characters, atoms\n\nCollections (arrays, lists, set, dictionaries)\n\nSum and product types\n\nOptionals\n\nRegular Expressions and other pattern types\n\nFirst-class types\n\nHigher-kinded types\n\nUniverses\n\nFunctional Abstraction, Routines, a.k.a. subroutines, subprograms, procedures, or functions, may just be the most important building block of good code. They abstract executable code into (often named) chunks so we can invoke them when needed. They can be parameterized, too!\n\nProcedures (abstractions for commands)\n\nFunctions (abstractions for expressions)\n\nSignatures\n\nNames, modes, types, patterns, defaults, rest parameters\n\nParameters and arguments\n\nExactly one parameter? Or zero to many?\n\nExactly one return value? Or zero to many?\n\nParameter association\n\nPositional vs. Named\n\nValue, value-result, reference, name\n\nHigher-order functions\n\nClosures\n\nData Abstraction. Just like we can chunk code into procedures, we can chunk data as well. But not just data. When we bundle data and code together, we get something qualitatively more powerful.\n\nModules, packages, namespaces, classes, units, etc.\n\nImport and export\n\nOpen vs. Closed\n\nObject orientation\n\nSeparate compilation (the physical organization of a system)\n\n“Bob Barton, the main designer of the B5000 and a professor at Utah had said in one of his talks a few days earlier: \"The basic principle of recursive design is to make the parts have the same power as the whole.\" For the first time I thought of the whole as the entire computer and wondered why anyone would want to divide it up into weaker things called data structures and procedures. Why not divide it up into little computers, as time sharing was starting to? But not in dozens. Why not thousands of them, each simulating a useful structure?” — Alan Kay\n\nConcurrency. In the real world, things don’t happen in a single sequence. Things can happen at anytime. Different things can happen at the same time. It would be great if a language had features that enable us to express these situations clearly and enable safe execution of these concurrent activities.\n\nThreads vs. processes\n\nEvents\n\nSingle-threaded event queue vs. preemptive threading\n\nShared resources and synchronization\n\nScheduling\n\nAsynchronicity: callbacks, promises, async/await\n\nCoroutines (yield)\n\nChannels vs. Processes\n\nBuffered vs. Unbuffered communication\n\nMetaprogramming. You might write a HR program that can answer questions like “What is the average salary of employees in the marketing department?” But can you also ask it ”How many local variables are you made up of, and what are their types?” Metaprogramming is writing programs that can answer questions about, and manipulate, programs (including themselves).\n\nIntrospection\n\nReflection\n\nEval\n\nDecorators\n\nMetaclasses\n\nTheoretical Foundations\n\nA study of just about anything can be enhanced with mathematical and logical precision. For programming languages, we want a way to specify, unambiguously, exactly what are the legal programs in a language, and what exactly they mean. Natural language is open to interpretation and fuzziness and ambiguity, so we would like to bring in some mathematical machinery as expressed in the study of logic and various mathematical and computational theories.\n\nLogic\n\nLogic is the study of reasoning. It is used in programming languages to specify the behavior of programs.\n\nType Theory\n\nType Theory is a theory used provide a rigorous foundation of mathematics, and of programming languages! It is a superior alternative to Set Theory, at least for computer science.\n\nThe Lambda Calculus\n\nThe Lambda Calculus is a formal system of functions and of computation.\n\nTheories of Computation\n\nLanguage Theory is the study of how computations are expressed. Automata Theory is the study of abstract machines for carrying out computations. Computation Theory is the study of what can and cannot be computed. Complexity Theory is the study of quantifying resources required for certain computations.\n\nSyntax\n\nA programming language gives us a way structure our thoughts. A program’s structure is determined by the syntax of the language. The syntax defines which strings of characters are valid programs, and if valid, how the characters are grouped into words (called tokens) and how the words are grouped into phrases (such as declarations, expressions, statements, etc.)\n\nA syntax is normally defined formally and mathematically, using objects such sets, sequences, alphabets, and grammars.\n\nSyntactic formalisms are well understood in computer science and fluency with at least one formalism is an expectation of undergraduate computer science students and most programers. Among those you will encounter in your study of programming languages are: BNF, EBNF, ABNF, plain old Context-Free Grammars, Syntax Diagrams, and (my favorite) Parsing Expression Grammars.\n\nSemantics\n\nThe semantics of a language gives meaning to its programs. We need to be able to precisely and unambiguously define the meaning (or effect) of every program. This requires a fair amount of mathematical machinery. Unlike syntax, for which formalisms are straightforward, mathematical approaches to semantics are generally undertaken only in graduate computer science courses.\n\nSee the Wikipedia articles on Semantics and Semantics in Computer Science.\n\nPragmatics\n\nPragmatics does not affect the formal specification of programming languages; however, pragmatic concerns must guide your design of a programming language—if you want it to be easy to read, easy to write, and able to be implemented efficiently. Pragmatics encompasses:\n\nWhat does the language value?\n\nThe sort of applications a language best suited for\n\nThe advantages and disadvantages relative to other languages\n\nExpressiveness and performance characteristics\n\nCommon programming idioms (good ways and not-so-good ways of doing things)\n\nAn implied execution model: Assignment-based, Stack, Combinators, Data-flow, etc.\n\nThe standard library or libraries\n\nThe ecosystem that evolved around the language, encompassing:\n\nProgramming environments, e.g., IDEs, REPLs, workspaces, playgrounds, playpens\n\nThe ecosystem for 3rd party libraries (e.g. NPM for JavaScript, Pip for Python, Gems for Ruby, Rocks for Lua, Maven for Java, ...)\n\nVision and Values\n\nWe can think of a language’s value system as what it is that the language wants to be. The values stem from the vision of the designers and ultimately play a role in making a language learnable, usable, and maybe even successful. To get a sense of what this all means, see Ashley Williams’ amazing talk subtitled “How language values shape the features we build and the journeys we take to design them.” It focuses on JavaScript and Rust, but the ideas are universally applicable:\n\nCriteria for Evaluation\n\nReasonable people know that all languages have their pros and cons. But why are some things pros and other things cons?\n\nTechnical Criteria\n\nThere are certain technical criteria. For example, is the language:\n\nEasy to read? Because:\n\nOver 90% of programmer time is reading and modifying existing code\n\nLabor costs dwarf hardware costs\n\nIf someone can’t understand existing code, it will get thrown away\n\nEasy to write? Because:\n\nIf the learning curve is too high, who would bother to use it?\n\nHighly Expressive? That would help reading and writing. Does the language have:\n\nOperators like A = B + C which adds whole arrays in Fortran 90?\n\nAbstract data types (with encapsulation)?\n\nModule and package structures to aid programming-in-the-large?\n\nA rich operator set, as in languages like APL and Perl?\n\nRich type/object structures supporting inheritance, composition and aggregation?\n\nPolymorphism, overloading, aliasing?\n\nHigher order functions?\n\nPattern matching?\n\nBuilt-in control flow (e.g. unification, backtracking)?\n\nFacilities for symbolic computation?\n\nSupport for asynchronous, concurrent, and distributed programming?\n\nDesigned to make it impossible to making (some) stupid mistakes? Some languages do! For example you might see:\n\nA requirement to declare variables and types detects spelling errors early\n\nSimple iteration over collections vs. crazy-flexible for loops\n\nRobust switches with pattern-match exhaustiveness vs. the abomination which is the C switch\n\nSafe discriminated sum types vs. unsafe C unions\n\nLanguages without insecure features, such as user-specified pointer deallocation, pointer arithmetic, automatic coercions\n\nWhitespace significance prevents the classic Fortran 77 example\n\nDO 10 I = 1 . 5 PRINT * \"Hello\" 10 CONTINUE\n\nDesigned to allow quick and incremental compilation? Because breaking a programmer’s flow by constantly hitting that compile button or having to run linkers, or such things get annoying.\n\nIf compilation is as fast as you can type, development time and cost can be greatly reduced.\n\nIf compilation can be incremental, there’s no need to recompile after making small changes.\n\nIf compilation can be quick, some compilation can be done at runtime to adapt to changing conditions.\n\nAmenable to efficient target code generation?\n\nLanguages with static scope and type checking keep the runtime system free from tons of work, e.g. no runtime variable lookup: all variable references have already been resolved to machine addresses.\n\nLanguages with no first-class functions allow for stack-allocation of frames.\n\nSome languages are strongly influenced by hardware.\n\nGenuinely portable? Yes, we want our creations to spread!\n\nMany languages have too many implementation dependencies.\n\nAlso see Wikipedia’s Programming Language Comparison article.\n\nNon-Technical Criteria\n\nThere are non-technical, subjective criteria, too. Good and successful are not the same! Success comes from:\n\nBeing the only language suitable for a specific problem\n\nPersonal preference (no accounting for taste)\n\nGood development environments\n\nFast compilers (not necessarily a language issue!)\n\nA massive ecosystem (like NPM or Maven or Pip or Gems)\n\nPatronage (support from a government or big company)\n\n“Everyone else is using it”\n\n“The boss made me use it”\n\nEconomics and Inertia — “we already invested too much in this to change”\n\nLaziness — “I’m too tired to learn a new language”\n\nExercise: What else can you think of that makes people want to use a particular language?\n\nExpressiveness\n\nExpressiveness is a pragmatic concern, too, influencing how a language can be wielded to say what needs to be said. Some languages want to be verbose, low-level, or “close to the machine” and others want to be terse or expressive. Here’s the way different languages allow you to express a function to return the sum of the squares of even numbers in a list. In class, we’ll discuss the pragmatic issues that arise in each:\n\nint sum_of_even_squares(int* a, unsigned int length) { int total = 0; for (unsigned int i = 0; i < length; i++) { if (a[i] % 2 == 0) { total += a[i] * a[i]; } } return total; }\n\nfunc sumOfEvenSquares(a []int) int { total := 0 for _, x := range a { if x % 2 == 0 { total += x * x } } return total }\n\nfunction sumOfEvenSquares(a) { return a.filter(x => x % 2 === 0).map(x => x**2).reduce((x, y) => x + y, 0) }\n\npublic static int sumOfEvenSquares(int[] a) { return IntStream.of(a).filter(x -> x%2==0).map(x -> x*x).sum(); }\n\nfun sumOfEvenSquares(a: Array<Int>): Int { return a.filter { it % 2 == 0 }.map { it * it }.sum() }\n\nfunc sumOfEvenSquares(_ a: [Int]) -> Int { return a.filter{$0 % 2 == 0}.map{$0 * $0}.reduce(0, +) }\n\nsub sum_of_even_squares { sum0 map { $_**2 } grep { $_ % 2 == 0 } @_; }\n\nfunction sumOfEvenSquares(a) sum(x -> x^2, filter(x -> x % 2 == 0, a), init = 0) end\n\n(defun sum-of-even-squares (a) (reduce #'+ (mapcar (lambda (x) (* x x)) (remove-if-not #'evenp a))))\n\n(defn sum-of-even-squares [a] (->> a (filter even?) (map #(* % %)) (reduce +)))\n\nsumOfEvenSquares :: [Int] -> Int sumOfEvenSquares = sum . map (^ 2) . filter even\n\ndef sum_of_even_squares(a): return sum(x**2 for x in a if x % 2 == 0)\n\nsumOfEvenSquares ← {+/((2|⍵)=0)×⍵*2}\n\nsumofevensquares: {+/x[&~x!2]^2}\n\nRelated to expressiveness is the idea of code as art, or art as code. Here’s a discussion of what this actually means:\n\nPopularity\n\nThere are countless numbers of ways to measure popularity! You really can’t make popularity statements without stating your measure. Then people will argue whether your measure is even valid. 🤷‍♀️ Nevertheless, it’s fun to look at this stuff from time to time.\n\nRedMonk has a language ranking scheme that combines pull requests on GitHub and questions on StackOverflow. (One could argue that this measures how confusing a language is too...maybe most of the StackOverflow questions are language complaints?) Here is the ranking from June 2021:\n\nRedMonk gives these rankings:\n\nJavaScript\n\nPython\n\nJava\n\nPHP\n\nCSS\n\nC++#\n\nC#\n\nTypeScript\n\nRuby\n\nC\n\nSwift\n\nR\n\nObjective-C\n\nShell\n\nScala\n\nGo\n\nPowerShell\n\nKotlin\n\nRust\n\nDart\n\nAnother ranking system, by Tiobe, ends up with a radically different top 20. They say: “The ratings are based on the number of skilled engineers world-wide, courses and third party vendors. Popular search engines such as Google, Bing, Yahoo!, Wikipedia, Amazon, YouTube and Baidu are used to calculate the ratings.”\n\nHere’s a current take:\n\nBut what makes a language popular? MPJ has thoughts:\n\nUnderstanding Evaluation Tradeoffs\n\nYou can’t have everything, it seems:\n\nThe expressive power of dynamic typing, polymorphic type systems, functions as first-class values, higher-order functions, and closures can sometimes impact performance.\n\nAutomatic garbage collection saves billions of dollars in programmer time, but isn’t always a good idea in embedded, life-critical, real-time systems.\n\nA language may be wonderful and amazing and increase developer productivity, but if no talented people are out there that know the language, how will you hire the best team?\n\nLanguages that are intentionally designed to be horrible (Brainfuck, Java2K, Malbolge, etc.) have some intellectual and educational value (and offer amusement).\n\nExercise: Think up some other tradeoffs.\n\nNo Competition!\n\nDon’t make the mistake of thinking programming languages are like sports teams—they don’t compete against each other. Don’t root for one to “win.”\n\nRealize that languages serve different purposes and are often used together to build systems.\n\nRecall Practice\n\nHere are some questions useful for your spaced repetition learning. Many of the answers are not found on this page. Some will have popped up in lecture. Others will require you to do your own research."
    }
}