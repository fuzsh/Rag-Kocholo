{
    "id": "dbpedia_4771_0",
    "rank": 5,
    "data": {
        "url": "http://www.catb.org/retro/plankalkuel/",
        "read_more_link": "",
        "language": "en",
        "title": "The \"Plankalkül\" of Konrad Zuse: A Forerunner of Today's Programming Languages",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/glyph2.png",
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/glyph2.png",
            "http://www.catb.org/retro/plankalkuel/figure1.png",
            "http://www.catb.org/retro/plankalkuel/glyph3.png",
            "http://www.catb.org/retro/plankalkuel/glyph3.png",
            "http://www.catb.org/retro/plankalkuel/le.png",
            "http://www.catb.org/retro/plankalkuel/le.png",
            "http://www.catb.org/retro/plankalkuel/le.png",
            "http://www.catb.org/retro/plankalkuel/figure2.png",
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/diagram1.png",
            "http://www.catb.org/retro/plankalkuel/diagram2.png",
            "http://www.catb.org/retro/plankalkuel/diagram3.png",
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/ne.png",
            "http://www.catb.org/retro/plankalkuel/le.png",
            "http://www.catb.org/retro/plankalkuel/ieo.png",
            "http://www.catb.org/retro/plankalkuel/bza.png",
            "http://www.catb.org/retro/plankalkuel/bzb.png",
            "http://www.catb.org/retro/plankalkuel/bza.png",
            "http://www.catb.org/retro/plankalkuel/diagram4.png",
            "http://www.catb.org/retro/plankalkuel/diagram5.png",
            "http://www.catb.org/retro/plankalkuel/figure3.png",
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/glyph1.png",
            "http://www.catb.org/retro/plankalkuel/ge.png",
            "http://www.catb.org/retro/plankalkuel/ne.png",
            "http://www.catb.org/retro/plankalkuel/ne.png",
            "http://www.catb.org/retro/plankalkuel/figure4.png",
            "http://www.catb.org/retro/plankalkuel/ne.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "a. Syntax Checking for Boolean Expressions\n\nA typical application of the Plankalkül [Z49, p. 446] contains a procedure for the syntax check of Boolean expressions. Zuse starts from the observation:\n\nSuch expressions contain the following symbols: variable symbols, negation symbol, operation symbols, parentheses symbols, and space symbol that is needed for the separation of expressions. The symbols in question are coded in bit sequences.\n\nIn the procedure (Figure 3), denotes the structure of these 8-bit sequences, and m with arbitrary m 1 denotes the symbol sequences that are to be investigated. A call of the procedure with a (coded) symbol sequence x as its actual parameter means to test the predicate\n\nSa(x): <<x is a 'meaningful expression', i.e. a (syntactically correct) Boolean expression>>.\n\nThis predicate is introduced recursively by:\n\n(i) A variable symbol is a meaningful expression.\n\n(ii) A meaningful expression, prefixed by a negation symbol, yields a meaningful expression.\n\n(iii) Two meaningful expressions, connected by an operation symbol, yield a meaningful expression.\n\n(iv) A meaningful expression, put in parentheses, yields a meaningful expression.\n\nTo transform this definition into an algorithm, Zuse defines, now for symbols x, the auxilliary predicates:\n\nVa(x): <<x is a variable symbol>>\n\nOp(x): <<x is operation symbol>>\n\nNeg(x): <<x is negation symbol>>\n\nKla(x): <<x is opening patenthesis>>\n\nKlz(x): <<x is closing parenthesis>>\n\nand furthermore the predicates:\n\nAz(x): Va(x) V Neg(x) V Kla(x)\n\nSz(x): Va(x) V Klz(x)\n\nSq(x,y): (Sz(x) ^ ¬ Az(y)) V (¬Sz(x) ^ Az(y))\n\nHe then postulates:\n\n1. The first symbol x has to fulfill Az(x)\n\n2. Two symbols x, y following each other have to fulfill Sq(x, y)\n\n3. The last symbol x has to fulfill Sz(x).\n\nMoreover, he uses the two parentheses counts:\n\n4. The number of opening parenthesis has to be equal to the number of closing parentheses.\n\n5. For any segment of the symbol sequences, the number of opening parentheses must not be smaller than the number of closing parentheses.\n\nThe program (Figure 3) checks these conditions: (2) serves for the special case of condition 1. (3) and (4) are initializations for the repetitive statement which checks condition 2 and the count 5. Condition 3 for the final case is then checked in (11) and the count 4 in (12). The program, by the way, contains mistakes: for example, a count corresponding to (7) is missing for the first symbol. More seriously, the condition x V0[0] in (5) should be read as x = V0[i] ^ i 0.\n\nFor a direct transliteration of Zuse's (corrected) procedure, we assume first that suitable Boolean procedures Va(x), Op(x), etc., are declared. Using these predicates, we obtain in ALGOL 68 (the encircled numbers refer to Figure 3):\n\n(Of course, in ALGOL 68 there exist possibilities for a more efficient formulation.)"
    }
}