{
    "id": "dbpedia_4771_2",
    "rank": 57,
    "data": {
        "url": "https://craftofcoding.wordpress.com/category/programming-language/",
        "read_more_link": "",
        "language": "en",
        "title": "programming language – The Craft of Coding",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://craftofcoding.wordpress.com/wp-content/uploads/2024/01/generationslang.png",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2022/01/langextinct.png?w=798",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2022/01/langdead.png?w=312",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2022/01/langexpired.png?w=330",
            "https://www.beholder.uk/vintage/languages/img/c-cartoon.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-01-29T16:26:18+00:00",
        "summary": "",
        "meta_description": "Posts about programming language written by spqr",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "The Craft of Coding",
        "canonical_link": "https://craftofcoding.wordpress.com/category/programming-language/",
        "text": "Oh right, there aren’t any. But why not? Mainly because this isn’t the 1980s when it was still possible to design a language that looked a little different from everything else around it. There is also the issue of why? Why do we need new programming languages? The ones we currently have work just fine. They do, go and have a close look at them. The monolithic Cobol does a fine job at finance… why would we want to change that? Why would we take the risk? C is fantastic at systems programming. Others like Python do a good job at dealing with data. Too many articles talk about “dead” programming languages with little or context to real-world use.\n\nEvery year there are the ubiquitous posts, postulating the “new programming languages” that are paving the way in the frontiers of programming. One I saw recently touted Kotlin as a great “new” language. I mean it first appeared in 2011, and yes it is one of the official Android development languages… but it isn’t anywhere near new or revolutionary. In fact if you look at the syntax of many of these new languages, they all in some way are derived from Java, or C++, or some other language in the long line of C-based languages. Nothing exciting here, move along.\n\nWe keep re-inventing the wheel with a slightly different spin on it. Mostly these languages appear as augmentations for software development on mobile platforms, or for data analysis. Many are super-bloated with features, which makes you long for the simplicity of C or Fortran, where you could memorize the syntactic structure in your head. None of these new languages are saving the world, yet people love jumping onto whatever new bandwagon appears.\n\nLook, I’m not against new languages, but you can’t sell a language purely on the idea that it runs faster. Great. Is it at all usable? Is it bloated? Does it do anything some other language doesn’t already do? Truly revolutionary programming languages will come when people step away from the the current C-based language family and come up with something completely different – more than just a new spin on a for loop. Actually what I would like to see is people actually do some large scale studies on the learnability and usability of existing programming languages before we attempt to create new languages. Will it happen? It did once, but the last of these type of studies happened in the 1980’s when people actually still gave a damn about the languages they were developing.\n\nFrom my perspective programming languages have become like iOS. Many of them have a new releases multiple times a year, yet none of these updates really change the landscape of the language, except perhaps killing backwards compatibility, or adding some new feature that likely isn’t needed. Good languages are simple to design, and simple to use. Yes, it’s a nice concept to fit every stupid feature possible in a language, but it isn’t necessary – that’s what libraries are for. Remember the idea of “reuse”? It was one of the big selling points of OO, but never really led to anything tangible. New programming languages? No thanks, I’ll stick with the tried and true.\n\nI find it funny when people call Fortran and Cobol “old” languages. Seems a little ageist. It appeared in 1957, and C, which nobody really calls old at all, appeared in 1972… only 15 years later. Hardly enough to warrant such abuse. Of course Fortran is a Baby Boomer, and C is Gen X, which is maybe why nobody messes with C, but somehow Fortran is fair game. Now the big problem is that nobody in higher-ed teaches Fortran anymore, opting instead for something like C, or one of the Millennials – C++ or Java. None of these are great options for introductory programming, and most institutions flog them into the ground, teaching very little else in terms of languages, and making students almost monolingual in the process (learning a combination of C-based languages is really being monolingual, as there is very little that differentiates the core structure of these languages).\n\nThis mantra has lead to students having an inherent bias towards 1-2 languages. It may be the leading cause of a lack of Fortran programmers… oh and Cobol programmers too. But people tend to shoot themselves in the foot using this approach. Way too many people have skills in languages like C, so there is a much larger pool of people for companies to choose from. And despite what the internet says, neither Fortran nor Cobol are dead languages. We rely on them far too much, and reengineering code is a colossal nightmare, not to mention *VERY* costly. Think AI will do it? Maybe, but which financial institution is going to risk it? Even two minutes of outage is too much.\n\nBesides which there is nothing wrong with Fortran, because it is not the same language as Fortran I of 1957 fame. Languages evolve, which I doubt many of these people actually take into consideration when they write their “dead language” lists. Sure, by looking at “jobs available” you may be able to come to that conclusion, but you actually have to be clued into how software is used. There is over 800 billion lines of Cobol code in daily use around the world, and it continues to grow. Hardly the signs of a dying language, and that’s because Cobol does finance better than any other language – that’s what it was designed to do. Lots of science is still done in Fortran, because guess what, it’s good at performing calculations, especially on high performance platforms.\n\nLook programming languages don’t age – if they dare to evolve. Sure, Fortran and Cobol aren’t multi-paradigm to the point newer languages are, but with all that functionality comes a key baggage – complex languages. Just because a language has structural simplicity, doesn’t mean it can’t do everything other languages do.\n\nI find it funny when people talk about teaching modern programming languages. How exactly is modern defined? Are we talking about languages which are in demand right now (due to job postings perhaps)? Or perhaps languages that developers report they are using? Let’s look at the latter via Stack Overflow’s 2022 Developer Survey of over 70,000 developers. These surveys are kind-of eye-opening, but not in the way you would think.\n\nIn the technology section they tend to lump programming, scripting and mark-up languages in one category. Of those Javascript makes the top of the list at 65.36%. I get it, it’s the most popular because of how much it’s used in websites, but it’s not a hard-core language. Next is HTML/CSS at 55.08% – mark-up languages, NOT programming languages. If we were to look at core programming languages, as we make our way through the list we get: Python 48.07%, Java 33.27%, C# 27.98%, C++ 22.55%, C 19.27%. From there it tends to spiral down to nothing. In this list I don’t really see “modern” programming languages. Ruby only sits at 6.05%, Swift at 4.91%.\n\nOf course there are some issues with these surveys. It is predominantly people who use Stackoverflow, where the dominant age group is 25-34 (39.62%), which is arguably the largest demographic, and 56% of people only have 1-9 years represents of experience. And 70,000 represents 0.25% of the 27 million odd software developers in the world. And let’s face it, if you’re writing HTML and CSS, it’s isn’t exactly software development (sorry, it just isn’t), and Javascript, well it’s more than likely a bit of a psychosis (and besides can you really trust a language that doesn’t have real integers?).\n\nThere are 101 of these “top programming lists”, all of which say the same thing. None come from extensive industry surveys. And none of these languages are “modern” in the real sense of the word. They are modern in the sense that all languages evolve. Fortran 2018 is a modern language. The TIOBE index, puts the top languages as Python, C, Java, C++, C#, Visual Basic, Javascript, etc. etc. But you have to take these ranking with a grain of salt as Cobol is ranked 25th, and is still in heavy demand in financial circles. Still it is telling, none of the top seven are modern languages per se.\n\nSo when someone talks about teaching a course on “modern” programming languages what exactly are they talking about? Are they talking about paradigm? Of the four main paradigms: procedural, OO, scripting and functional, the first three are well covered. So perhaps functional programming languages? They are used in data science and machine learning, and obviously will have a role in the future of programming. So a course could be filled with Clojure, Elixir, Haskell and/or Scala – but then just call it a course on functional programming. But the paradigm has been around since Lisp appeared in 1958, so these are just modern renditions of functional languages.\n\nSo what is a modern industry programming language? It doesn’t exist. It’s a bit like someone who says they’re creating a modern hammer – sure it might look more aesthetically pleasing, or be made of titanium, but it still fundamentally works the same as a hammer from 1000 years ago. Perhaps academics have some strange notion of what a modern language is? Besides which, if you are a good programmer you can teach yourself a new “modern” language, right?\n\nWhen I first started programming in Julia, I thought it could be the next best thing. I mean a language that was nearly as fast as C with all the conveniences of Python, minus the annoyances? But I adopted it in its early days, when it was still evolving. I sometimes wish it had just appeared one day as version 1, and made periodic updates every year or three. The problem with the sort of evolution Julia and similar languages undertake is that small changes break things in existing code. I’m not saying this sort of language evolution is wrong, but there is something to be said at how languages like C and Fortran tackle it.\n\nLook, I like Julia, it a nice language, with a *lot* of built-in functionality. But there are things that I just find annoying.\n\nIts “multi-paradigm” nature. Yeah, I know other languages have this too, but it does tend to bloat a language.\n\nThings always seem to break. Code I write that sits around for a month no longer works when I update the compiler. This is less of a problem now, but it still happens, and is an affect of working with a language that is evolving.\n\nMemory consumption is extremely high. Compare the peak memory usage for a program that does nothing more than print “hell0” (with /usr/bin/time - l). The peak memory usage is called the “Maximum resident set size“. The C and Fortran programs use 0, the Julia program, 518Mb. Shocking? Just slightly.\n\nThe error messages still suck. Look, if you’re an experienced programmer, you’ll be able to figure out an error trace. If you’re a novice, good luck.\n\nThe language is not stable, and by that I mean it seems to have a lot of bugs. You can’t really call something that has bugs stable.\n\nThere aren’t enough packages to suit the needs of users. There are just things that are missing, or for libraries that exist, they often have some esoteric characteristics. The ecosystem is just too small.\n\nThe documentation, while quite comprehensive, is not at all easy to understand.\n\nThere are pros and cons to every language of course, but Julia is likely too late in the game. it’s hard to even compare it to the likes of Python and C because they have been around for too long. Julia will add to the spectrum of languages, but likely won’t supplant the likes of Python. Languages tend to emerge for a specific need, and Julia evolved to try and compete with Python in the data science realm.\n\nAt the end of the day, programming in any language boils down to usability. How easy is a language to use? I just find there are too many elements of Julia that are annoying to use. A case in point is the use of include, use and import. Why does this language need all three? using loads the code associated with a module, import beings only the module name into scope, and include includes the content of a file into a program. I get that they do different things, but it just becomes somewhat annoying… and it is confusing for people trying to learn the language.\n\nMaybe I just prefer simple languages, where the language spec could be written on the back of a drink coaster. Julia was developed as an alternative to Python, but trying to dislodge an incumbent is hard. Algol-60 tried hard to dislodge Fortran, and failed – only a change in language paradigms saw Fortran dislodged as the franca lingua of coding. I was super enthusiastic when I first started programming in Julia, but now I just find it requires far too much energy, and frankly, life’s too short.\n\nIf you want to read more about some of these things, I suggest What’s bad about Julia? and Julia: A Post-Mortem.\n\nIn the world of spoken languages an extinct language is one that no longer has any speakers. Conversely a dead language is one that no longer the native language of any community (e.g. Latin, although a version, Romansh is still spoken by some people in the Swiss canton of Graubunden). In many ways programming languages can be similarly categorized. An extinct programming language is one that no longer has anyone that programs in it, or no longer has any accessible compilers. A good example of an extinct language is Algol-60 – there are really no accessible compilers, and no-one really programs in it.\n\nA dead programming language is one which no longer is really used by a broad community of people. Algol-68 is a good example of this – there are still people that code in Algol-68, eg. via the Algol-68 Genie project, which provides a compiler, but on the whole there is not really a large community which supports the language. APL and PL/1 are some other good examples. Dead languages also include earlier versions of a language. For example, the language Fortran IV is essentially a dead language, because there is no real support for the language. Fortran has evolved over its existence, leaving legacy programs which can still be compiled (because Fortran is great at backwards compatibility), but which really have little or no community support.\n\nA third category is expired programming languages. These are languages which have lost their support infrastructure. The best case example of this is Python2. On January 1, 2020 the Python Software Community decided to “sunset” Python2. This basically means that Python 2 remains as is, no bug fixes, no changes, no support. So while there is still a community of programmers who actively used Python 2, they will realistically have to transition to Python 3, porting their programs. So while Python 2 is expiring, eventually it will become extinct, because it will have no support, e.g. no backwards compatibility. This can cause some huge issues, especially if a piece of software is dependent on libraries which are themselves written in Python 2, yet are no longer supported, and may be impossible to convert to Python 3. There’s no surprise why, Python 3 is just a more capable language. There is no doubt that Python 2 will still linger for years, but it won’t evolve becoming somewhat of a zombie language. Eventually it will just become extinct.\n\nNote that I didn’t include the likes of Fortran, Cobol, or Ada in either of these categories, because they are active, modern languages in their own right, used extensively in a number of industries. Want to read more about the death of Python2? Try “Variations on the Death of Python 2“.\n\nSome may think Fortran is an archaic language, and certainly not one that should be taught, but in any respects modern Fortran is an exceptionally good language to teach programming in. Certainly better than C and its idiosyncrasies. Better than Python or Julia you say? In many cases yes. Certainly things like I/O are still problematic for the novice programmer in these languages. Partially it is because modern Fortran is easy to read and comprehend, which is an important factor for the individual learning to program for the first time. The idea of introductory languages is not necessarily that they are suited to commercial endeavours, but rather that they are (i) easy to implement algorithm in, (ii) readable, and (iii) do not contain things that will confuse and bewilder.\n\nLet’s perform the simple task of calculating the distance to the horizon. The calculation is quite simple, all that is required is the height of your eye, i.e. the distance that your eyes are off the surface of the water. The formula for calculating the distance, d, is d=√(2rh), where r is the radius of the earth (6367.45km), and h is the height of the object in metres (divided by 1000 to convert to km). So for an observer standing in a tower 42m above sea level, the distance to the horizon is d=√(2×6367.45×(42/1000)) = 23.13km. So a program to calculate this in Fortran would look like this:\n\nprogram horizon real :: height, dist write(*,*) 'Height above sea level(m): ' read(*,*) height dist = sqrt(2*6367.45*(height/1000.0)) write(*,*) 'Distance to horizon = ', dist, 'km' end program horizon\n\nThere is very little the novice programmer could not understand in this program – even without having any real notion of the syntax of Fortran. The terms read and write imply something is being input and output, the distance calculation is effectively just an equation. The only real sticking point maybe the variable declaration on the second line. The equivalent C program is somewhat more challenging.\n\n#include <stdio.h> #include <math.h> int main(void) { float height, dist; printf(\"Height above sea level(m): \"); scanf(\"%f\", &height); dist = sqrt(2*6367.45*(height/1000.0)); printf(\"Distance to horizon = %.2fkm\\n\", dist); return 0; }\n\nFirstly it is four lines longer, and the only thing the same between the two programs is the equation. Two of the lines in the C program are taken up including libraries for I/O and math functions – which Fortran doesn’t require. The printf function deals with output, and is quasi-intuitive… the scanf function is not at all intuitive. What about int main(void) – muddy. What about the Python program, surely it must be better than both Fortran and C?\n\nimport math height = float(input('Height above sea level(m): ')) dist = math.sqrt(2*6367.45*(height/1000.0)) print('Distance to horizon = ', dist, 'km')\n\nPython dispenses with the notion of defining the “program”, allowing the algorithm to take place with little fanfare… I mean it is only 4 lines. But the math library still has to be imported. The prompt for the height is combined together with reading in the value, which is nice and compact, but the user will still question what float() is doing. And Julia?\n\nprintln(\"Height above sea level(m): \") height = parse(Float64, chomp(readline())) dist = sqrt(2*6367.45*(height/1000.0)) println(\"Distance to horizon = \", dist, \"km\")\n\nIt suffers from input issues as well, chomping and parsing things – things novice programmers don’t care to know about. The commonality among all these programs is of course the calculation. The usability of a programming language is likely associated with how well it uses appropriate words to describe functions and actions, and uses symbols appropriately."
    }
}