{
    "id": "dbpedia_4771_2",
    "rank": 42,
    "data": {
        "url": "https://arxiv.org/html/2403.16087v1",
        "read_more_link": "",
        "language": "en",
        "title": "LLMs as Compiler for Arabic Programming Language",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://arxiv.org/html/extracted/5491777/figures/modelarc.jpeg",
            "https://arxiv.org/html/extracted/5491777/functions_ops.drawio.png",
            "https://arxiv.org/html/extracted/5491777/Reseach-keywords_ar.drawio.png",
            "https://arxiv.org/html/extracted/5491777/figures/interface.jpeg",
            "https://arxiv.org/html/extracted/5491777/figures/flowchart.jpeg",
            "https://arxiv.org/html/extracted/5491777/figures/ex1-2.png",
            "https://arxiv.org/html/extracted/5491777/figures/ex2.png",
            "https://arxiv.org/html/extracted/5491777/figures/ex3.png",
            "https://arxiv.org/html/extracted/5491777/figures/ex4-2.png",
            "https://arxiv.org/html/extracted/5491777/figures/cex1.png",
            "https://arxiv.org/html/extracted/5491777/figures/cex2.png",
            "https://arxiv.org/html/extracted/5491777/figures/cex3.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "arabic programming language",
            "LLM",
            "compiler",
            "API"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "License: CC BY-NC-ND 4.0\n\narXiv:2403.16087v1 [cs.SE] 24 Mar 2024\n\n11institutetext: RIOTU labs, Prince Sultan University, KSA\n\n11email: {ssibaee, onajar,lghouti, akoubaa}@psu.edu.sa\n\nLLMs as Compiler for Arabic Programming Language\n\nSerry Sibaee Omar Najar Lahouri Ghouti Anis Koubaa\n\nAbstract\n\nIn this paper we introduce APL (Arabic Programming Language) that uses Large language models (LLM) as semi-compiler to covert Arabic text code to python code then run the code. Designing a full pipeline from the structure of the APL text then a prompt (using prompt engineering) then running the prodcued python code using PyRunner. This project has a three parts first python library (GitHub), a playground with simple interface and this research paper.\n\nKeywords:\n\narabic programming language, LLM, compiler, API\n\n1 Introduction\n\nProgramming languages serve as crucial tools for communicating with computers, facilitating various tasks and applications. Over the past few decades, the landscape of programming languages has evolved significantly, with numerous languages emerging, predominantly in English for example python, java, php and C++.\n\nIn [5][6] the evolution and diversity of programming languages are explored through a historical lens. Beginning with Zuse’s Plankalkül, the narrative progresses through seminal moments in programming language development, such as the introduction of pseudocodes, the emergence of Fortran for the IBM 704, and the advent of functional programming with LISP. Key languages like ALGOL 60, COBOL, and BASIC are examined for their contributions to business computing and timesharing systems. The text delves into the expansive capabilities of languages like PL/I, APL, and SNOBOL, which catered to diverse programming needs. Additionally, it highlights significant advancements such as the introduction of SIMULA 67, ALGOL 68’s orthogonal design principles, and the inception of logic-based programming with Prolog. Noteworthy efforts in language design, including Ada’s comprehensive approach and Smalltalk’s pioneering object-oriented paradigm, are discussed alongside popular languages like C++ and Java. The chapter also explores scripting languages, markup/programming hybrid languages, and the prominence of C sharp as a flagship language within the .NET ecosystem. And as we can notice that all of the previous programming langauges are in English, and this shortage made developers enthusiatec about building their own programming languages with their mother-tounge languages, for example ”Chinese BASIC” programming language in chinese, ”Superlogo” in Dutch, ”LSE (Language Symbolique d’Enseignement)” in french and ”Teuton” in German [7].\n\nThen we have several Arabic-based programming languages have been introduced over the years. One of the earliest endeavors in this domain was made by Al Alamiah company in 1987, with the creation of Arabic Sakhr Basic [9]. This language, an adaptation of BASIC, featured Arabic keywords and expressions tailored for MSX home computers. ARLOGO [10] emerged as another Arabic programming language, based on UCB Logo, primarily aimed at educational purposes. While ARLOGO is open-source and currently compatible only with Microsoft Windows, ARABLAN [11] was developed in 1995 specifically for teaching programming to school children in Arab countries. Al-Risalah [12] followed, offering an Arabic object-oriented programming experience inspired by languages like Pascal, C++, and Eiffel, with a focus on educational use. More recently, additional Arabic programming languages have been developed, including AMORIA[13], Ebda3[14], Jeem[15], Loughaty[16], Qlb[17], and Kalimat [18], And recently in 2019 we saw ”Phoenix” The Arabic Object-Oriented Programming Language[19] These languages collectively contribute to the growing landscape of programming education and practice in Arabic-speaking communities. Talking about programming langauges is not complete without talking about The history of programming language compilers because it is marked by significant milestones and components. The concept of a compiler was introduced by Grace Hopper in the early 1950s, with the A-0 System. The first high-level programming language to be developed was Fortran, created by John Backus and his team at IBM in the mid-1950s, which aimed to simplify the programming process and improve code efficiency [20] The evolution of compilers is closely tied to the development of programming languages and the diversification of computing needs. Key components of a compiler include lexical analysis, syntax analysis, semantic analysis, optimization, and code generation. Lexical analysis breaks down the source code into tokens, syntax analysis constructs a parse tree based on the language’s grammar, semantic analysis checks for semantic consistency, optimization improves the performance of the generated code, and code generation translates the optimized intermediate representation into the target language [21]. The history of compilers is also intertwined with the evolution of software engineering practices and the quest for more reliable and efficient programming paradigms [22].\n\nThen we have the ”Elephant in the room” the Pre-trained language models (PLMs) that revolutionized various natural language processing (NLP) tasks by capturing rich linguistic representations. That could be summarized focusing on their architectural differences and key families.\n\nEncoder-only models, like BERT and its variants, excel at language understanding tasks like text classification. They process input text through an encoder network, learning contextual representations for downstream tasks. Decoder-only models, exemplified by GPT-1 and GPT-2, specialize in text generation. They employ a decoder network to iteratively produce text sequences conditioned on a prompt or previous token.\n\nEncoder-decoder models, like T5 and BART, combine both capabilities. They utilize an encoder-decoder architecture, enabling them to handle understanding and generation tasks seamlessly. This unified approach makes them versatile for various NLP applications.\n\nBeyond these established architectures, new families are emerging with unique characteristics. The LLaMA family emphasizes open-sourcing, fostering community-driven development of better LLMs. PaLM focuses on scaling, achieving state-of-the-art performance on numerous benchmarks. Other families like FLAN, Gopher, and ERNIE 3.0 showcase diverse design choices and research directions.\n\nThis overview highlights the multifaceted nature of PLMs, offering researchers and practitioners a range of options for tackling different NLP challenges. As the field continues to evolve, further exploration of novel architectures and training methods is expected to push the boundaries of language understanding and generation capabilities [23].\n\nAfter this introduction we can see that there are some connections between programming languages compilers and LLMs in the general (abstract) where both has a hidden structure to solve (work with) problems so the idea to use LLMs as a semi programming compiler that translate Arabic structured text (APL programming language) to a Python code that could be run. We will discuss the architecture of the compiler where we will see the changes of the writing style of the APL, then we discuss the capabilities of the language. After that the prompt engineering of the LLMs that will be used to change the APL code to a Python code. Then Introducing a new API and interface of the APL that could be used to help who wants to use the compiler in their applications.\n\n2 Related work\n\nIn the dynamic realm of contemporary programming, the advent of Large Language Models (LLMs) parallels historical shifts in programming paradigms. Analogous to the evolution from assembly language to high-level languages facilitated by optimizing compilers, LLMs signify a transformative leap, positioning themselves not merely as advanced autocompletion tools but as compilers. This conceptual shift is underscored by the absence of direct exploration in the literature regarding the utilization of LLMs as programming compilers.\n\nHistorically, programming proficiency resided in mastering assembly language, a skill rendered obsolete by optimizing compilers translating high-level languages into efficient machine code. A parallel transition is underway today, elevating the act of programming to a higher level of abstraction. LLMs, conceived as compilers, signify this evolution by translating natural language prompts into high-level programming languages, redefining the coding landscape.\n\nEmpirical evidence, exemplified by Copilot, accentuates this transformative potential. Copilot demonstrated efficacy in solving introductory programming problems, showcasing an ability to generate accurate solutions from problem descriptions alone. In instances of inaccuracies, developers prefer prompt manipulation over conventional debugging, reflecting a paradigm shift in code creation methodologies.\n\nThe academic discourse delves into this trans-formative trajectory, with LLMCompiler [1] for parallel function calling and the innovative Synthesize, Execute, Debug (SED) approach [3] exemplifying engagements with evolving programming paradigms. Furthermore, critical insights from online articles [2] contribute nuanced perspectives, collectively consolidating the conceptualization of LLMs as compilers in the intricate landscape of modern programming methodologies. The absence of direct exploration in current literature underscores the nascent nature of employing LLMs as programming compilers, paving the way for future inquiries into this transformative domain.\n\nAlso there is an opposite approach of make a programming language that ease the use of LLM in python code called ’LMQL’ ”LMQL offers a novel way of interweaving traditional programming with the ability to call LLMs in your code.”[4] And a side note that no one has tried explicitly to use LLMs as a compiler to run a new programming language but the general research shows to use LLMs to automate programming or help programmers to program fast with multiple way auto complete the written code (copilot) or solving the problems by asking the chat Bot to debug and suggest solutions. And the near idea that is similar to ours is ”PseuToPy” [24] which is an explicit compiler (did not use LLMs but the idea is the same) that change chinese code which follows the structre of python code then run it. Also a new Approch that shows a reverse way of using LLMs as a decompilers where the LLM was Decompile-Eval dataset improve decompilation. [25]\n\n3 Methodology\n\nthe methodology has three main parts the paper will explain each one of them separately The methodology unfolds in two key dimensions: Compiler Architecture and Prompt Engineering. Compiler Architecture investigates the integral components—LLM Planner, Task Fetching Unit, and Executor—providing a foundational understanding of LLM Compiler’s structure. In parallel, Prompt Engineering explores the intricacies of transforming natural language prompts into effective instructions for the LLM, ensuring a holistic methodology that integrates both architectural foundations and linguistic nuances.\n\n3.1 Architecture of the compiler\n\nThis section will discuss the structure of the programming language where how the input is represented and how the included operations (loops and functions).\n\n3.1.1 Structure of the input code\n\nThe APL code is written completely in Arabic script from right to left. And for Loops (while for example) we chose not to use indentation of python but the curly brackets because it is easier for the programmer and also easier for the LLM to compiler because copying and pasting the indented text could mess the code. Also the final condition is to make sure the programmer write the code line by line and do not use the ’;’ to make it clearer and easier for the reader and for the LLM\n\n1.\n\nArabic Script\n\n2.\n\nCurly Brackets Usage\n\n3.\n\nLine-by-Line Operations\n\nThe code input follows an Arabic script, introducing a distinctive structure influenced by a shift to the use of curly brackets ”{}” instead of indentation, departing from the traditional indentation in Python. Each operation is distinctly presented on its own line, eliminating the need for semicolons (;) in multi-line statements.\n\n3.1.2 Programming Language Components\n\nFor simplicity we did not include all of python properties but just these six generic ones to make it simple and also for the fragility of LLMs in the chain of combined prompts. So these are the capabilities of the APL.\n\n1.\n\nVariables\n\n2.\n\nOperations\n\n3.\n\nFile Reading (Limited to TXT Files)\n\n4.\n\nIf Conditions\n\n5.\n\nLoops\n\n6.\n\nFunctions\n\n3.1.3 Arabic Text Conventions\n\nThis section details the conventions employed for Arabic text within the programming language, including variable names, operations, conditions, and loops, as well as the syntax for functions and file reading.\n\n3.2 Prompt Engineering: Dealing with the Text\n\n3.2.1 Structure of the Prompt\n\nIn the realm of prompt engineering, the task involves translating Arabic text into executable Python code. The process includes renaming variables to English for operational clarity and substituting Arabic functions with their Python equivalents (e.g., replacing with print). The overarching goal is to ensure the prompt results in valid and runnable Python code, facilitating seamless integration within the programming environment.\n\n3.2.2 Prompt Structure Guidelines: Dealing with Keywords\n\nIn the process of crafting prompts for translation into Python code, it is essential to handle specific Arabic terms and translate them into their corresponding Python keywords. The following table outlines the mapping of relevant keywords, ensuring their seamless integration into Python code while preserving Arabic texts used within strings.\n\n3.2.3 The used prompt\n\nThe used prompt in the GPT-4 is: ”This GPT specializes in translating Arabic algorithmic instructions into Python code. It accurately replaces Arabic keywords with their Python equivalents, ensures variables are named in English for runnable code, and checks for syntax correctness. If a syntax error is detected, it provides a specific error message to help users correct the issue. The output code is provided as plain text, not in Python markdown, to ensure compatibility with various text editors and environments.”\n\n4 API and interface\n\nIn this work, we conceptualize the API similarly to a traditional compiler. But rather than translating a high-level language into machine code, our API acts as a pipe, turning Arabic input into Python code. This method makes use of Python’s adaptability and widespread use in AI applications and research.\n\n4.1 The Structure of the API\n\nThe API is designed to be seamlessly integrated into existing Python environments. This integration is achieved through a dedicated Python library, which is hosted on GitHub for accessibility and collaborative development. The library encapsulates the API’s functionality into a single, user-friendly class. The main component of our Python library is the Compiler class. This class is initialized with an API key, enabling secure and authenticated access to the API’s functionalities. The syntax is straightforward:\n\n4.2 Sample of the Interface\n\nTo demonstrate the practical application and user interaction with our API, we introduce a sample interface designed for simplicity and effectiveness.\n\nDesign of the Interface: The interface features a dual-pane layout. The right pane serves as the input area where users can write or paste Arabic code. This design choice caters to the natural right-to-left flow of Arabic script, ensuring a familiar and comfortable user experience.\n\nCompatibility of Arabic Text with Output Display: The output, or translated Python code, is shown in the left pane. A special focus is on making sure that Arabic text is compatible. This includes proper rendering of Arabic characters and script peculiarities in the output display in addition to left-to-right text alignment. Users’ understanding and debugging abilities are improved by this dual-pane structure, which makes it simple to compare the generated Python code with the original Arabic script.\n\n5 Illustration\n\nIn this section, we showcase the APL application of the LLM compiler in bridging linguistic barriers between Arabic and Python programming. The LLm compiler A⁢P⁢L𝐴𝑃𝐿APLitalic_A italic_P italic_L has been tested under the progression from foundational programming concepts to more intricate operations illustrates not only the flexibility of the model but also its potential to democratize programming for Arabic-speaking individuals.\n\nFigure6 demonstrates the foundational initiating with fundamental operations, such as file handling, arithmetic computations, string manipulations, and basic function definitions, this segment aims to solidify the groundwork. These examples emphasize the model’s ability to comprehend and execute simple instructions, thereby laying a robust foundation for more complex tasks. Additionally, Figure 7 shows more advanced Operations, building upon the basics, this segment delves into more sophisticated programming constructs. It includes the manipulation of data structures, control flow, and file operations with nuanced requirements. Demonstrating the model’s adeptness at handling complexity\n\n6 challenges and future work\n\nThe main challenges that faced us in the development of the compiler is the prompt engineering because it’s facing Arabic text in two contexts the first is the programming language keywords and naming these need to be replaced with the English version so the python code could run without syntax errors, but on the other hand the Arabic text that was used in strings need to be kept as it is so if we print it or modify it in the code the Arabic characters still the same as the programmer added them. The second main problem we faced was the cost of using GPT-4 API where in the development phase this is not a big deal but in the deployment phase this will cost a of money to compile the APL code. In the future we could try to fine tune a open-source models so it reduce the costs of using paid APIs and also it will working on a specific task without the potential risk of getting useless responds from the non-generalized model.\n\nReferences\n\n[1] Kim, S., Moon, S., Tabrizi, R., Lee, N., Mahoney, M. W., Keutzer, K., Gholami, A. (2023, December 7). ”An LLM Compiler for Parallel Function Calling.” In Proceedings of the Conference Name (pp. PageRange). Springer.\n\n[2] Author. (2023, February 26). ”LLMs are compilers.” Online article. Retrieved from https://vivekhaldar.com/articles/llms-are-compilers/\n\n[3] Liventsev, V., Grishina, A., Härmä, A., Moonen, L. (2023, April 20). ”Fully Autonomous Programming with Large Language Models.” In Proceedings of the Conference Name (pp. PageRange). Springer.\n\n[4] LMQL is a programming language for large language models (LLMs) based on a superset of Python. https://github.com/eth-sri/lmql\n\n[5] Robert W. Sebesta’s ”Concepts of Programming Languages”\n\n[6] Computer Languages History diagram by levenez https://www.levenez.com/lang/\n\n[7] Wiki Article about programming languages that are not english\n\n[8] GitHub repository that summarize info about non-English programming languages https://github.com/flightstar/Artificial-Intelligence-in-Non-English-Based-Programming-Language\n\n[9] Arabic Sakhr Basic (1987, MSX, Al Alamiah).\n\n[10] ARLOGO project homepage. http://arlogo.sourceforge.net/. Retrieved February 15, 2017.\n\n[11] Mansoor Al-A’Ali, Mohammed Hamid. ”Design of an Arabic programming language (ARABLAN).” Journal Computer Languages, Volume 21, Issue 3-4, pp. 191-201, October, 1995.\n\n[12] Essam Mohammad Arif. ”Design of an Arabic object-oriented programming language and a help system for pedagogical purposes.” Doctoral Dissertation, Illinois Institute of Technology Chicago, IL, USA, 1995.\n\n[13] AMORIA homepage. http://ammoria.sourceforge.net/. Retrieved Dec 14, 2018.\n\n[14] Ebda3 homepage. http://ebda3lang.blogspot.com/. Retrieved Dec 14, 2018.\n\n[15] Jeem homepage. http://www.jeemlang.com/. Retrieved Dec 14, 2018.\n\n[16] Youssef Bassil, Aziz Barbar. ”Loughaty/MyProLang – My Programming Language - A Template-Driven Automatic Natural Programming Language.” Proceedings of the World Congress on Engineering and Computer Science, WCECS 2008, San Francisco, USA.\n\n[17] Qlb GitHub. https://github.com/nasser/---. Retrieved Dec 14, 2018.\n\n[18] Kalimat GitHub. https://github.com/lordadamson/kalimat. Retrieved February 15, 2017.\n\n[19] Phoenix - The Arabic Object-Oriented Programming Language Youssef Bassil, LACSC – Lebanese Association for Computational Sciences, Registered under No. 957, 2011, Beirut, Lebanon\n\n[20] The State of Fortran, Laurence Kedward and others March 2022, Computing in Science and Engineering. doi:10.1109/MCSE.2022.3159862\n\n[21] MLSA: a static bugs analysis tool based on LLVM IR Hongliang Liang and others International Journal of Networked and Distributed Computing, Vol. 4, No. 3 (July 2016), 137-144\n\n[22] Compiling quantamorphisms for the IBM Q Experience. Ana Neri, and Others arXiv:2010.10510v1 [quant-ph] 21 Oct 2020\n\n[23] Large Language Models: A Survey arXiv:2402.06196v1 [cs.CL] 9 Feb 2024\n\n[24] PseuToPy: Towards a Non-English Natural Programming Language Patrick Wang ICER 2021: Proceedings of the 17th ACM Conference on International Computing Education ResearchAugust 2021Pages 429–430https://doi.org/10.1145/3446871.3469787\n\n[25] Open-access LLMs, Decompile-Eval dataset improve decompilation, enhancing program semantics. Hanzhuo Tan, Qi Luo, Jing Li, Yuqun Zhang Southern University of Science and Technology The Hong Kong Polytechnic University"
    }
}