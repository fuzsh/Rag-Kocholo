{
    "id": "dbpedia_4771_0",
    "rank": 32,
    "data": {
        "url": "https://senxxkingslayer.wordpress.com/2013/03/",
        "read_more_link": "",
        "language": "en",
        "title": "Senxxkingslayer's Blog",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2013-03-18T20:25:47+07:00",
        "summary": "",
        "meta_description": "2 posts published by senxxkingslayer during March 2013",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "Senxxkingslayer's Blog",
        "canonical_link": null,
        "text": "Chapter 2\n\nAssigned by Mr. Tri Djoko Wahjono\n\nI. Review Answer\n\n1. In what year was Plankalkül designed? In what year was that design published?\n\nAnswer: Plankalkul was designed by Konrad Zuse between 1942 & 1945. He first published a paper on it in 1948. More information on the language was published in 1972.\n\n2. What two common data structures were included in Plankalkül?\n\nAnswer: Array and Records\n\n3. How were the pseudo codes of the early 1950s implemented?\n\nThey were implemented through machine codes.\n\n4. Speedcoding was invented to overcome two significant shortcomings of the computer hardware of the early 1950s. What were they?\n\nAnswer: Non-connotative names, absolute addressing (Also: floating-point arithmetic, automatic incrementing of address register).\n\n5. Why was the slowness of interpretation of programs acceptable in the early 1950s?\n\nAnswer: Because the lack of floating point hardware\n\n6. What hardware capability that first appeared in the IBM 704 computer strongly affected the evolution of programming languages? Explain why.\n\nAnswer: Its capabilities prompted the development of Fortran because it was able to support floating-point operations hardware.\n\n7. In what year was the Fortran design project begun?\n\nAnswer: May 1954\n\n8. What was the primary application area of computers at the time Fortran was designed?\n\nAnswer: Mathematics\n\n9. What was the source of all of the control flow statements of Fortran I?\n\nAnswer: They were based on 704 instructions\n\n10. What was the most significant feature added to Fortran I to get Fortran II?\n\nAnswer: Independent-compilation capability\n\n11. What control flow statements were added to Fortran IV to get Fortran 77?\n\nAnswer: logical loop statements and IF with an optional ELSE\n\n12. Which version of Fortran was the first to have any sort of dynamic variables?\n\nAnswer: Fortran 90\n\n13. Which version of Fortran was the first to have character string handling?\n\nAnswer: Fortran 77\n\n14. Why were linguists interested in artificial intelligence in the late 1950s?\n\nAnswer: Because linguists were concerned with natural language processing.\n\n15. Where was LISP developed? By whom?\n\nAnswer: It was developed at MIT by John McCarthy\n\n16. In what way are Scheme and Common LISP opposites of each other?\n\nAnswer: Common LISP allows for static scoping and dynamic scoping Scheme only uses static scoping. Scheme is relatively small while Common LISP is large and complex.\n\n17. What dialect of LISP is used for introductory programming courses at some universities?\n\nAnswer: Scheme\n\n18. What two professional organizations together designed ALGOL 60?\n\nAnswer: ACM and GAMM\n\n19. In what version of ALGOL did block structure appear?\n\nAnswer: ALGOL 60\n\n20. What missing language element of ALGOL 60 damaged its chances for widespread use?\n\nAnswer: The lack of input and output statements with formatting\n\n21. What language was designed to describe the syntax of ALGOL 60?\n\nAnswer: BNF\n\n22. On what language was COBOL based?\n\nAnswer: FLOW-MATIC\n\n23. In what year did the COBOL design process begin?\n\nAnswer: 1959\n\nII. Problem set\n\n3. Write a short history of the A-0, A-1, and A-2 systems designed by Grace Hopper and her associates.\n\nThe A-0 system (Arithmetic Language version 0), written by Grace Hopper in 1951 and 1952 for the UNIVAC I, was the first compiler ever developed for an electronic computer. The A-0 functioned more as a loader or linker than the modern notion of a compiler The A-0 system was followed by the A-1, A-2, A-3 (released as ARITH-MATIC), AT-3 (released as MATH-MATIC) and B-0 (released as FLOW-MATIC).\n\nThe A-2 system was developed at the UNIVAC division of Remington Rand in 1953 and released to customers by the end of that year.[2] Customers were provided the source code for A-2 and invited to send their improvements back to UNIVAC. Thus A-2 was an early, and perhaps the first, example of free and open-source software.\n\n7. LISP began as a pure functional language but gradually acquired more and more imperative features. Why?\n\nJohn McCarthy’s original interest in developing LISP was to meet the demand for artificial intelligence as a functional programming language, but there soon emerged different dialects, cleaners, more modern, and more imperative, that began to deviate from the functional form into Scheme. COMMON LISP combined the different forms into a single form that was more imperative, including assignment and iteration.\n\n8. Describe in detail the three most important reasons, in your opinion, why ALGOL 60 did not become a very widely used language.\n\nExcessive flexibility hurt ALGOL60 since languages that are difficult to learn were not as well received as languages with a more rigid structure. Allowing a large number of possibilities also introduce an element of inefficiency since the methods to complete a task would differ between programmers.\n\nSecond, Sebesta (2002, p. 60) notes that its association with BNF alienated the language as strange and complicated. If programmers are not excited about using a language, they will always find a different one.\n\nThe third and perhaps the most important reason that ALGOL60 was not very widely used was because of a lack of support from IBM, who was at the time the preeminent company for using computer languages. Without some help from a large corporation, ALGOL60 did not have much of a chance, much like COBOL without the DoD.\n\n9. Why, in your opinion, did COBOL allow long identifiers when Fortran and ALGOL did not?\n\nCOBOL required that managers without a background in programming should be able to read programs and English should be used as much as possible. This caused identifiers to be longer, making the language more English-like. Sebesta (2002, p. 57) states that “[ALGOL] identifiers were allowed to have any length, as opposed to FORTRAN’s restriction to six or fewer….” FORTRAN was also a much older language that was built during a time of very little memory and a focus on syntax “as close as possible to standard mathematical notation” leaving little room for long identifiers.\n\n10. Outline the major motivation of IBM in developing PL/I.\n\nLike Fortran, PL/I was developed as an IBM product. By the early 1960s, the users of computers in industry had settled into two separate and quite different camps: scientific and business. From the IBM point of view, scientific programmers could use either the large-scale 7090 or the small-scale 1620 IBM computers. This group used floating-point data and arrays extensively\n\nFor business applications, people used the large 7080 or the small 1401 IBM computers. They needed the decimal and character string data types, as well as elaborate and efficient input and output facilities. They used COBOL, although in early 1963 when the PL/I story begins\n\nThe two widely separated computer user groups were moving toward each other in ways that were thought certain to create problems This perceptions naturally led to the concept of designing a single universal computer that would be capable of doing both floating-point and decimal arithmetic, and therefore both scientific and business applications.\n\n13. Describe, in your own words, the concept of orthogonality in programming language design.\n\nIt appears that orthogonality means the simplicity of programming constructs, or a minimal number of control and data structures in a language. Each additional construct increases the complexity, removing orthogonality.\n\n15. What are the arguments both for and against the idea of a typeless language?\n\nArguments for are obvious flexibility and ease of use. Without having to define a data type the programmer is free to develop code that is generated quickly and without much thought. Learning the language is much simpler because one doesn’t have to determine size or how the compiler will interpret the type later on, only what information must be included.\n\nArguments against include data insecurity, such as the assignment of a character type ‘A’ that could in fact be “defined” as a HEX value by the programmer. The compiler would also have trouble interpreting floating point values compared to integers. The resulting arithmetic would also cause serious problems; like adding 5 + “happy” and how they are interpreted different than perhaps the programmer intended.\n\n18. Do you think language design by committee is a good idea? (Support your opinion)\n\nLanguage design by committee definitely has its advantages, with varying points of view from different domains, different programming backgrounds, and even different language backgrounds all contributing for the better of the language like ALGOL 58. Knowledge of Plankalkul enhanced ALGOL 58 because members from Europe were familiar with the language. Improvements like variable length identifiers and array dimensions were improved upon previous languages. Even though many arguments and conflicts arise, like whether to use a comma (European) or a period (American) for a decimal point took place, it is beneficial to have options. I think history would show that the best use of committees would be after a language has been invented and accepted. At this point a better evaluation is possible and committee members would be better conditioned to make improvements than initial discoveries.\n\nAssigned by Mr. Tri Djoko Wahjono\n\nReview Questions\n\n1. Why is it useful for a programmer to have some background in language design, even though he or she may never actually design a programming language?\n\nAnswer: Because, by knowing the language design programmer will find that there are many concepts that are common across programming languages. For example, control structures, error/exception handling, array/memory management.\n\nUnderstanding these basics makes it easier for programmer to learn and adopt new languages.\n\n2. How can knowledge of programming language characteristics benefit the whole computing community?\n\nAnswer:\n\n3. What programming language has dominated scientific computing over the past 50 years?\n\nAnswer: Fotran (Formula Translator)\n\n4. What programming language has dominated business applications over the past 50 years?\n\nAnswer: COBOL (Common Business-Oriented Language)\n\n5. What programming language has dominated artificial intelligence overthe past 50 years?\n\nAnswer: Lisp\n\n6. In what language is most of UNIX written?\n\nAnswer: C\n\n7. What is the disadvantage of having too many features in a language?\n\nAnswer: If a language has a large number of different constructs, some programmers might not be familiar with all of them. This situation can lead to a misuse of some features and a disuse of others that may be either more elegant or more efficient, or both, than those that are used. It may even be possible, as noted by Hoare (1973), to use unknown features accidentally, with bizarre results.\n\n8. How can user-defined operator overloading harm the readability of a program?\n\nAnswer: Because The compiler does not come to know how to make precision of this operator\n\n9. What is one example of a lack of orthogonality in the design of C?\n\nAnswer: C has two kinds of structured data types, arrays and records (structs), records can be returned from functions but arrays cannot. A member of a structure can be any data type except void or a structure of the same type. An array element can be any data type except void or a function. Parameters are passed by value, unless they are arrays, in which case they are, in effect, passed by reference (because the appearance of an array name without a subscript in a C program is interpreted to be the address of the array’s first element).\n\nProblem Sets\n\n1. Do you believe that solving a problem in a particular algorithm step requires programming language skills? Support your answer!\n\nAnswer: Yes, because if our skill in one language (or concept) is bigger, then our capacity to have an abstract though is also getting bigger, for example the knowledge of array, if the so called “programmer” doesn’t know it, his mind may be stuck on even a simple code of program.\n\n2. Who is said to be the first programmer in the history?\n\nAnswer: Ada Lovelace (http://en.wikipedia.org/wiki/Ada_Lovelace)\n\n3. What are the disadvantages of multiple programming languages?\n\nAnswer: The disadvantages of multiple programming languages are:\n\na. Confusing, Every language has their own syntaxes. Therefore, programmers must remember syntaxes in every single language and also programmers have to know about the language behavior that may differ one to another.\n\nb. It’s quite not convenient because if you have a task of making an application that include more than 1 domain of computer programming, it may be difficult.\n\n4. In what way do the languages for scientific applications differ from the languages for business application? Support your view!\n\nAnswer: The main difference that differs them is the calculation itself, because on scientific application, the calculation may include a very small number (exponential float point) but on business one, the calculation will be much simpler than the scientific application.\n\n5. In what way do the languages for Artificial Intelligence differ from the languages for web software? Support your view!\n\nAnswer: On artificial intelligence domain the usage of symbol is more dominant than the usage of computation, but in web software calculation is included to support the flexibility of the software.\n\n6. Which characteristic of programming languages do you think are the most important and why?\n\nAnswer: Based on my opinion, the most important one will be its readability, because, nowadays, the focus of the programming is not on the efficiency, but on the cost of maintenance, thus the language itself must be easy to be read. If it is easy to be read, the maintenance progress will takes less time and the cost will be smaller too.\n\n16. Does a Just-In-Time (JIT) implementation system affect the execution of the code? Why or why not?\n\nAnswer: JIT will not affect the execution of the code, because JIT does nothing to the code other than translating it to another language, the code itself isn’t changed.\n\n17. Some programming languages-for example, SQL- use “=” to check the quality of two expressions, while C uses it to assign values to variable. Which of these, in your opinion, is more natural and least likely to result in syntax error? Support your answer!\n\nAnswer: Based on my opinion, C to me is more natural than SQL and less likely to make a syntax error, because we would more assign a value to a variable more than performing a selection by using an if-else statement. To use the selection itself, we must clearly assign the value or else it would print a bizarre output."
    }
}