{
    "id": "dbpedia_4771_3",
    "rank": 8,
    "data": {
        "url": "https://senxxkingslayer.wordpress.com/2013/03/18/concept-of-programming-languanges-10th-edition/",
        "read_more_link": "",
        "language": "en",
        "title": "Concept of programming languanges 10th edition",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2013-03-18T00:00:00",
        "summary": "",
        "meta_description": "Chapter 2 Assigned by Mr. Tri Djoko Wahjono I. Review Answer 1. In what year was Plankalkül designed? In what year was that design published? Answer: Plankalkul was designed by Konrad Zuse between 1942 & 1945. He first published a paper on it in 1948. More information on the language was published in 1972. 2.…",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "Senxxkingslayer's Blog",
        "canonical_link": "https://senxxkingslayer.wordpress.com/2013/03/18/concept-of-programming-languanges-10th-edition/",
        "text": "Chapter 2\n\nAssigned by Mr. Tri Djoko Wahjono\n\nI. Review Answer\n\n1. In what year was Plankalkül designed? In what year was that design published?\n\nAnswer: Plankalkul was designed by Konrad Zuse between 1942 & 1945. He first published a paper on it in 1948. More information on the language was published in 1972.\n\n2. What two common data structures were included in Plankalkül?\n\nAnswer: Array and Records\n\n3. How were the pseudo codes of the early 1950s implemented?\n\nThey were implemented through machine codes.\n\n4. Speedcoding was invented to overcome two significant shortcomings of the computer hardware of the early 1950s. What were they?\n\nAnswer: Non-connotative names, absolute addressing (Also: floating-point arithmetic, automatic incrementing of address register).\n\n5. Why was the slowness of interpretation of programs acceptable in the early 1950s?\n\nAnswer: Because the lack of floating point hardware\n\n6. What hardware capability that first appeared in the IBM 704 computer strongly affected the evolution of programming languages? Explain why.\n\nAnswer: Its capabilities prompted the development of Fortran because it was able to support floating-point operations hardware.\n\n7. In what year was the Fortran design project begun?\n\nAnswer: May 1954\n\n8. What was the primary application area of computers at the time Fortran was designed?\n\nAnswer: Mathematics\n\n9. What was the source of all of the control flow statements of Fortran I?\n\nAnswer: They were based on 704 instructions\n\n10. What was the most significant feature added to Fortran I to get Fortran II?\n\nAnswer: Independent-compilation capability\n\n11. What control flow statements were added to Fortran IV to get Fortran 77?\n\nAnswer: logical loop statements and IF with an optional ELSE\n\n12. Which version of Fortran was the first to have any sort of dynamic variables?\n\nAnswer: Fortran 90\n\n13. Which version of Fortran was the first to have character string handling?\n\nAnswer: Fortran 77\n\n14. Why were linguists interested in artificial intelligence in the late 1950s?\n\nAnswer: Because linguists were concerned with natural language processing.\n\n15. Where was LISP developed? By whom?\n\nAnswer: It was developed at MIT by John McCarthy\n\n16. In what way are Scheme and Common LISP opposites of each other?\n\nAnswer: Common LISP allows for static scoping and dynamic scoping Scheme only uses static scoping. Scheme is relatively small while Common LISP is large and complex.\n\n17. What dialect of LISP is used for introductory programming courses at some universities?\n\nAnswer: Scheme\n\n18. What two professional organizations together designed ALGOL 60?\n\nAnswer: ACM and GAMM\n\n19. In what version of ALGOL did block structure appear?\n\nAnswer: ALGOL 60\n\n20. What missing language element of ALGOL 60 damaged its chances for widespread use?\n\nAnswer: The lack of input and output statements with formatting\n\n21. What language was designed to describe the syntax of ALGOL 60?\n\nAnswer: BNF\n\n22. On what language was COBOL based?\n\nAnswer: FLOW-MATIC\n\n23. In what year did the COBOL design process begin?\n\nAnswer: 1959\n\nII. Problem set\n\n3. Write a short history of the A-0, A-1, and A-2 systems designed by Grace Hopper and her associates.\n\nThe A-0 system (Arithmetic Language version 0), written by Grace Hopper in 1951 and 1952 for the UNIVAC I, was the first compiler ever developed for an electronic computer. The A-0 functioned more as a loader or linker than the modern notion of a compiler The A-0 system was followed by the A-1, A-2, A-3 (released as ARITH-MATIC), AT-3 (released as MATH-MATIC) and B-0 (released as FLOW-MATIC).\n\nThe A-2 system was developed at the UNIVAC division of Remington Rand in 1953 and released to customers by the end of that year.[2] Customers were provided the source code for A-2 and invited to send their improvements back to UNIVAC. Thus A-2 was an early, and perhaps the first, example of free and open-source software.\n\n7. LISP began as a pure functional language but gradually acquired more and more imperative features. Why?\n\nJohn McCarthy’s original interest in developing LISP was to meet the demand for artificial intelligence as a functional programming language, but there soon emerged different dialects, cleaners, more modern, and more imperative, that began to deviate from the functional form into Scheme. COMMON LISP combined the different forms into a single form that was more imperative, including assignment and iteration.\n\n8. Describe in detail the three most important reasons, in your opinion, why ALGOL 60 did not become a very widely used language.\n\nExcessive flexibility hurt ALGOL60 since languages that are difficult to learn were not as well received as languages with a more rigid structure. Allowing a large number of possibilities also introduce an element of inefficiency since the methods to complete a task would differ between programmers.\n\nSecond, Sebesta (2002, p. 60) notes that its association with BNF alienated the language as strange and complicated. If programmers are not excited about using a language, they will always find a different one.\n\nThe third and perhaps the most important reason that ALGOL60 was not very widely used was because of a lack of support from IBM, who was at the time the preeminent company for using computer languages. Without some help from a large corporation, ALGOL60 did not have much of a chance, much like COBOL without the DoD.\n\n9. Why, in your opinion, did COBOL allow long identifiers when Fortran and ALGOL did not?\n\nCOBOL required that managers without a background in programming should be able to read programs and English should be used as much as possible. This caused identifiers to be longer, making the language more English-like. Sebesta (2002, p. 57) states that “[ALGOL] identifiers were allowed to have any length, as opposed to FORTRAN’s restriction to six or fewer….” FORTRAN was also a much older language that was built during a time of very little memory and a focus on syntax “as close as possible to standard mathematical notation” leaving little room for long identifiers.\n\n10. Outline the major motivation of IBM in developing PL/I.\n\nLike Fortran, PL/I was developed as an IBM product. By the early 1960s, the users of computers in industry had settled into two separate and quite different camps: scientific and business. From the IBM point of view, scientific programmers could use either the large-scale 7090 or the small-scale 1620 IBM computers. This group used floating-point data and arrays extensively\n\nFor business applications, people used the large 7080 or the small 1401 IBM computers. They needed the decimal and character string data types, as well as elaborate and efficient input and output facilities. They used COBOL, although in early 1963 when the PL/I story begins\n\nThe two widely separated computer user groups were moving toward each other in ways that were thought certain to create problems This perceptions naturally led to the concept of designing a single universal computer that would be capable of doing both floating-point and decimal arithmetic, and therefore both scientific and business applications.\n\n13. Describe, in your own words, the concept of orthogonality in programming language design.\n\nIt appears that orthogonality means the simplicity of programming constructs, or a minimal number of control and data structures in a language. Each additional construct increases the complexity, removing orthogonality.\n\n15. What are the arguments both for and against the idea of a typeless language?\n\nArguments for are obvious flexibility and ease of use. Without having to define a data type the programmer is free to develop code that is generated quickly and without much thought. Learning the language is much simpler because one doesn’t have to determine size or how the compiler will interpret the type later on, only what information must be included.\n\nArguments against include data insecurity, such as the assignment of a character type ‘A’ that could in fact be “defined” as a HEX value by the programmer. The compiler would also have trouble interpreting floating point values compared to integers. The resulting arithmetic would also cause serious problems; like adding 5 + “happy” and how they are interpreted different than perhaps the programmer intended.\n\n18. Do you think language design by committee is a good idea? (Support your opinion)\n\nLanguage design by committee definitely has its advantages, with varying points of view from different domains, different programming backgrounds, and even different language backgrounds all contributing for the better of the language like ALGOL 58. Knowledge of Plankalkul enhanced ALGOL 58 because members from Europe were familiar with the language. Improvements like variable length identifiers and array dimensions were improved upon previous languages. Even though many arguments and conflicts arise, like whether to use a comma (European) or a period (American) for a decimal point took place, it is beneficial to have options. I think history would show that the best use of committees would be after a language has been invented and accepted. At this point a better evaluation is possible and committee members would be better conditioned to make improvements than initial discoveries."
    }
}