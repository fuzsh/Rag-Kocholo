{
    "id": "dbpedia_4771_1",
    "rank": 97,
    "data": {
        "url": "https://www.studocu.com/my/document/universiti-teknologi-mara/principles-of-compilers/final-notes/20470229",
        "read_more_link": "",
        "language": "en",
        "title": "CHAPTER 1 Why was Konrad Zuse’ Plankalkül programming language not implemented?",
        "top_image": "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/136e66ce24d973259e660ae618c2f798/thumb_1200_1698.png",
        "meta_img": "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/136e66ce24d973259e660ae618c2f798/thumb_1200_1698.png",
        "images": [
            "https://collector-27m703Hm.perimeterx.net/api/v1/collector/noScript.gif?appId=27m703Hm",
            "https://d3tvd1u91rr79.cloudfront.net/136e66ce24d973259e660ae618c2f798/html/bg1.png?Policy=eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6XC9cL2QzdHZkMXU5MXJyNzkuY2xvdWRmcm9udC5uZXRcLzEzNmU2NmNlMjRkOTczMjU5ZTY2MGFlNjE4YzJmNzk4XC9odG1sXC8qIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNzI0OTU0MjU2fX19XX0_&Signature=Z~~~GIiP13t0ej5gWAoJ7nQ2FiSrSOQJer4NpIWLwShsaniZg8B1iIgBVVCIBnu-1r7zv9YH6Is9SEd4S35CVIPWO3ENzMrW86UvgJMirHRcgPMepy51XzIQueI-3Pg7RDkPEn8duUs0fe1ZAlojxS4iLxjalC9Tm-8jSC-XDjCz6tcYn~4YNB8LW~s8nSdgNLwR0gdLKor9i5q3C3i4KoclKwEw03-JXztg~mNdbFrJyVRTeREKharbbd6q3GjscnX7mmAX1MqVa1oy77FhqQRBxryqEZTuGluoEtTZ3fFkNl4kh9dxPAPIc03OE0DdFrLLF7SeHkOlJtp96z4HsQ__&Key-Pair-Id=APKAJ535ZH3ZAIIOADHQ",
            "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/554bb567ba4810cb59f6678f92fa9181/thumb_300_425.png",
            "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/247ae99fa7bf9c0ae9b2459d5ef5002e/thumb_300_425.png",
            "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/1e43c2ba1f0606a909f1d073ca6cd48e/thumb_300_388.png",
            "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/586de84c330397ce766a1553f759c62c/thumb_300_425.png",
            "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/554bb567ba4810cb59f6678f92fa9181/thumb_300_425.png",
            "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/247ae99fa7bf9c0ae9b2459d5ef5002e/thumb_300_425.png",
            "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/1e43c2ba1f0606a909f1d073ca6cd48e/thumb_300_388.png",
            "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/586de84c330397ce766a1553f759c62c/thumb_300_425.png",
            "https://d20ohkaloyme4g.cloudfront.net/img/document_thumbnails/c8895dfc73e3d672ecdbf6a29d5b0684/thumb_300_424.png",
            "https://d20ohkaloyme4g.cloudfront.net/img/google-play-badge.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "This is notes that i did for my Test 1 chapter why was konrad plankalkül programming language not implemented? what was the first commercial electronic computer",
        "meta_lang": "en",
        "meta_favicon": "https://d20ohkaloyme4g.cloudfront.net/img/favicon.svg",
        "meta_site_name": "Studocu",
        "canonical_link": "https://www.studocu.com/my/document/universiti-teknologi-mara/principles-of-compilers/final-notes/20470229",
        "text": "CHAPTER 1\n\nWhy was Konrad Zuse’ Plankalkül programming language not implemented?\n\nBecause he was in Germany during WW\n\nWhat was the first commercial electronic computer in the United States?\n\nUNIVAC 1\n\nWhat was the first widely used High Level programming language?\n\nFortran\n\nName two programming languages that were designed to be machine-independent?\n\nALGOL + COBOL\n\nWhy was the PL/I language created? Business + scientific applications need the same functions in computers (IBM System 360)\n\nPlankalkül  Year: 1945 – first high-level programming language  Created by German scientist Konrad Zuse  Never implemented (considering the War situation.., no contact with other scientists.. isolated)  Was only published in 1972\n\nPseudocodes Pseudocode” used here is not what the contemporary meaning is. In 1940s – 1950s:\n\nA. Short Code a. Year: 1949 for BINAC Computers b. Later: UNIVAC I (first commercial electronic computer in US) c. Creator: John Mauchly d. Code:\n\nB. Speedcoding (slide 6) a. Year: 1954 for IBM 701 b. Creator: John Backus\n\nC. UNIVAC Compiling System a. Year: 1951 – 1953 for UNIVAC b. Series of compiling systems: A- 0, A-1, A- c. Created by a team led by Grace Hopper\n\nWhat’s the problem with interpreter system? (page 8)\n\nwas the lack of floating-point hardware in the available computers. All floating-point operations had to be simulated in software,\n\nevery time-consuming process. Because so much processor time was spent in software floating-point processing, the overhead of interpretation and the simulation of indexing were relatively insignificant. As long as floating- point had to be done by software, interpretation was an acceptable expense. Flowever, many programmers of that time never used interpretive systems, preferring the efficiency of hand-coded machine (or assembly) language 3. Fortran  Late 1940s – mid 1950s: interpreter system tolerated because computers can’t do floating point operation  Had to be simulated in software  IBM 704 released in 1954 – first computer hardware able to do floating point operations A. Fortran 0  IBM while still working on 704 computer, also worked at Fortran.  1954: John Backus + group released a report: The IBM Mathematical FORmula TRANslating system: Fortran B. Fortran I  Released: April 1957  Featured:  Input/output formatting  Up to 6 characters variable name  User-defined subroutines  “if” statement “do” loop statement C. Fortran II ( page 12 slide)  Released: Spring 1958  Fixed many bugs  Add: Independent compilation of subroutines D. Fortran IV  Improvement:  Explicit type declarations for variables ▪ E: int  Logical “if” construct  Capability to pass subprograms as\n\nYear: 1968\n\nPASCAL Year: 1971 by Nicklaus Wirth (former member of ALGOL 68 Committee)  Largest impact was on teaching programming  From mid-1970s until the late 1990s, it was the most widely used language for teaching programming\n\nProgramming Based on Logic 1. PROLOG (SLIDE 44) Year: 1972 by team led by Alain Colmerauer\n\nHistory’s Largest Design Effort 1**. ADA (SLIDE 45)**  Commissioned by Department of Defense – huge design efforts that involved hundreds of people, money and 8 years.  Named ADA: after world’s first computer programmer 2. ADA 95 (SLIDE 47)\n\nObject Oriented Programming 1. Smalltalk (SLIDE 48)  Developed at Xerox PARC, initially by Alan Kay, later by Adele Goldberg\n\nCombining Imperative and Object-Oriented Programming\n\nC++\n\nYear: 1980 by Stroustrup at Bell Labs Evolved from C and SIMULA 67 17. Imperative-based OO Language JAVA (SLIDE 50)  Developed at Sun in the early 1990s 18. Scripting Languages A. JavaScript B. PHP C. JSP\n\nWhy was APL language considered hard to read?\n\nUses a lot of symbols\n\nWhich programming language introduced the concept of class?\n\nSIMULA\n\nWhich language involved history's largest effort ever?\n\nADA\n\nWhich programming language featured the first full implementation of OOP?\n\nSimula(1967)\n\nWhich features of JAVA makes it very popular?\n\nCHAPTER 1 (INTRODUCTION)\n\nUser interface is the mechanism through which the user of a device communicates with the device What is a Compiler? the kinds of instructions that the computer’s CPU is capable of executing For example, there are often instructions which do the following kinds of operations: (1) add two numbers stored in memory, (2) move numbers from one location in memory to another, (3) move information between the CPU and memory. COMPILER - Definition A software translator which accepts, as input, a program written in a particular high-level language and produces, as output, an equivalent program in machine language for a particular machine. Input Program Language\n\nSource program Source Language Output program Language\n\nObject program Object Language What are the advantages of a high-level language over machine or assembly language?\n\n(1) Machine language (and even assembly language) is difficult to work with and difficult to maintain (2) a much greater degree of machine independence and portability from one kind of computer to another (3) You don’t have to retrain application programmers every time a new machine (with a new instruction set) is introduced (4) High-level languages may support data abstraction (through data structures) and program abstraction (procedures and functions). What are the disadvantages of high-level languages? (\n\n(1) The programmer doesn’t have complete control of the machine’s resources (registers, interrupts, I/O buffers). (2) The compiler may generate inefficient machine language programs. (3) Additional software – the compiler – is needed in order to use a high-level language. Interpreter ."
    }
}