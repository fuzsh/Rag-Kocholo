{
    "id": "dbpedia_1806_1",
    "rank": 41,
    "data": {
        "url": "https://www.werkenbijqualogy.com/blog/29/new-pl-sql-iterator-constructs",
        "read_more_link": "",
        "language": "en",
        "title": "New PL/SQL iterator constructs",
        "top_image": "https://www.werkenbijqualogy.com/media/cache/w1200/uploads/blogartikelen_background-642588791d3125.76227342-659fcf7687a407.77756302.jpg",
        "meta_img": "https://www.werkenbijqualogy.com/media/cache/w1200/uploads/blogartikelen_background-642588791d3125.76227342-659fcf7687a407.77756302.jpg",
        "images": [
            "https://www.werkenbijqualogy.com/uploads/Logo.png",
            "https://www.werkenbijqualogy.com/uploads/Logo.png",
            "https://www.werkenbijqualogy.com/uploads/Logo.png",
            "https://www.werkenbijqualogy.com/uploads/Patrick Barel.jpg",
            "https://www.werkenbijqualogy.com/uploads/Patrick Barel.jpg",
            "https://www.werkenbijqualogy.com/media/cache/crop_center/rc/pFndVP7K/uploads/blogartikelen_background-642588791d3125.76227342-660d6a8816f7f4.86749021.jpg",
            "https://www.werkenbijqualogy.com/media/cache/crop_center/rc/LZoFzAIA/uploads/blogartikelen_background-642588791d3125.76227342-65fae6641792a2.49976950.jpg",
            "https://www.werkenbijqualogy.com/media/cache/crop_center/rc/SYhY42hI/uploads/blogartikelen_background-642588791d3125.76227342-65e8336f040f64.70053842.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Auteur: Patrick Barel"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "nl",
        "meta_favicon": "/uploads/Favicon-Qualogy.png",
        "meta_site_name": "",
        "canonical_link": "https://www.werkenbijqualogy.com/blog/29/new-pl-sql-iterator-constructs",
        "text": "Oracle Database 21c introduced some new iterator constructs. We all know the standard, sequential iterator for loops, which run from the lowest number to the highest number, or in reverse. If you wanted to skip certain values, you had to write code inside the loop to either skip or execute the logic.\n\nFor instance, if you wanted to display a list of even numbers you had to write something like this:\n\nfor i in 1 .. 10 loop\n\nif mod( i, 2 ) = 0 then\n\ndbms_output.put_line( to_char( i ) );\n\nend if;\n\nend loop;\n\nIn Oracle Database 23c (actually already since Oracle Database 21c) you can create loops with a stepped iterator:\n\nfor i in 2 .. 10 by 2 loop\n\ndbms_output.put_line( to_char( i ) );\n\nend loop;\n\nBe aware that you may have to change the lowest number to get the correct results. You don’t have to use an integer as the ‘step’ value. This can also be a fractional value:\n\nfor i in 2 .. 5 by .5 loop\n\ndbms_output.put_line( to_char( i ) );\n\nend loop;\n\nBut if you run your code like this, you will still see only the values 2, 3, 4, and 5. That is because the iterator is still an integer, which means it cannot hold fractional values. Another new thing in Oracle Database 23c is that the iterator datatype can be modified. To create the correct loop, which will display 2, 2.5, 3, 3.5, 4, 4.5, and 5 we need to change the iterator to a floating point type, like number( 2, 1 ).\n\nfor i number( 2, 1 ) in 2 .. 5 by .5 loop\n\ndbms_output.put_line( to_char( i ) );\n\nend loop;\n\nThat is another new thing in Oracle 21c. You have more control over the iterator. Up until Oracle Database 21c the iterator was always an integer and you had no control over it. In Oracle Database 21c you can not only define a different datatype (number, instead of integer), you can also define the iterator to be mutable inside the loop. If you try to run code like this, it will result in an error:\n\nfor i number( 3, 2 ) in 2 .. 5 by .5 loop\n\ndbms_output.put_line( to_char( i ) );\n\nif i = 3\n\nthen i := 3.25;\n\nend if;\n\nend loop;\n\nORA-06550: line 5, column 12:\n\nPLS-00363: expression 'I' cannot be used as an assignment target\n\nORA-06550: line 5, column 12:\n\nPL/SQL: Statement ignored\n\nBut Oracle Database 21c allows you to define the iterator to be mutable, therefor you have full control over the value of the iterator.\n\nbegin\n\nfor i mutable number( 3, 2 ) in 2 .. 5 by .5 loop\n\ndbms_output.put_line( to_char( i ) );\n\nif i = 3\n\nthen i := 3.25;\n\nend if;\n\nend loop;\n\nend;\n\n/\n\n2\n\n2.5\n\n3\n\n3.75\n\n4.25\n\n4.75\n\nPL/SQL procedure successfully completed\n\nBe very careful when doing this, because it is really easy to create endless loops. Believe me, I know, I did just that when writing the examples.\n\nCollections\n\nWhen looping through the contents of a collection, you had two choices. If your collection is densely filled, you can iterate from the first item to the last item, visiting every item in between (except for Associative Arrays indexed by a Varchar2) like this:\n\ndeclare\n\ntype driver_tt is table of f1data.drivers%rowtype\n\nindex by pls_integer;\n\ndrivers driver_tt;\n\nbegin\n\nselect d.*\n\nbulk collect\n\ninto drivers\n\nfrom f1data.drivers d\n\nwhere d.nationality = 'Dutch'\n\norder by d.forename;\n\nfor driver in drivers.first .. drivers.last loop\n\ndbms_output.put_line( drivers(driver).forename\n\n|| ' '\n\n|| drivers(driver).surname\n\n);\n\nend loop;\n\nend;\n\n/\n\nBen Pon\n\nBoy Lunger\n\nCarel Godin de Beaufort\n\nChristijan Albers\n\nDries van der Lof\n\nErnie de Vos\n\nGiedo van der Garde\n\nGijs van Lennep\n\nHuub Rothengatter\n\nJan Lammers\n\nJan Flinterman\n\nJos Verstappen\n\nMax Verstappen\n\nMichael Bleekemolen\n\nNyck de Vries\n\nRob Slotemaker\n\nRobert Doornbos\n\nRoelof Wunderink\n\nPL/SQL procedure successfully completed\n\nLet’s choose to remove Max Verstappen from the retrieved list (we would never do this, but for the sake of argument) then the collection is not dense anymore, so if you would try to iterate over the collection from first to last, you would run into a no data found error:\n\ndeclare\n\ntype driver_tt is table of f1data.drivers%rowtype\n\nindex by pls_integer;\n\ndrivers driver_tt;\n\nbegin\n\nselect d.*\n\nbulk collect\n\ninto drivers\n\nfrom f1data.drivers d\n\nwhere d.nationality = 'Dutch'\n\norder by d.forename;\n\ndrivers.delete( 13 ); -- Remove Max Verstappen\n\nfor driver in drivers.first .. drivers.last loop\n\ndbms_output.put_line( drivers(driver).forename\n\n|| ' '\n\n|| drivers(driver).surname\n\n);\n\nend loop;\n\nend;\n\n/\n\nBen Pon\n\nBoy Lunger\n\nCarel Godin de Beaufort\n\nChristijan Albers\n\nDries van der Lof\n\nErnie de Vos\n\nGiedo van der Garde\n\nGijs van Lennep\n\nHuub Rothengatter\n\nJan Lammers\n\nJan Flinterman\n\nJos Verstappen\n\n<< removed the code for brevity >>\n\nORA-01403: no data found\n\nORA-06512: at line 14\n\nYou may know how to use a sparse collection in a forall statement. You can use the indices of and the values of construction. A similar construction is now available in the loops in PL/SQL.\n\ndeclare\n\ntype driver_tt is table of f1data.drivers%rowtype\n\nindex by pls_integer;\n\ndrivers driver_tt;\n\nbegin\n\nselect d.*\n\nbulk collect\n\ninto drivers\n\nfrom f1data.drivers d\n\nwhere d.nationality = 'Dutch'\n\norder by d.forename;\n\ndrivers.delete( 13 ); -- Remove Max Verstappen\n\nfor driver in indices of drivers loop\n\ndbms_output.put_line( drivers(driver).forename\n\n|| ' '\n\n|| drivers(driver).surname\n\n);\n\nend loop;\n\nend;\n\n/\n\ndeclare\n\ntype driver_tt is table of f1data.drivers%rowtype\n\nindex by pls_integer;\n\ndrivers driver_tt;\n\nbegin\n\nselect d.*\n\nbulk collect\n\ninto drivers\n\nfrom f1data.drivers d\n\nwhere d.nationality = 'Dutch'\n\norder by d.forename;\n\ndrivers.delete( 13 ); -- Remove Max Verstappen\n\nfor driver in values of drivers loop\n\ndbms_output.put_line( driver.forename\n\n|| ' '\n\n|| driver.surname\n\n);\n\nend loop;\n\nend;\n\n/\n\nBoth scripts result in the same output, but note, in first one (indices of) the iterator is a numeric value, which is the pointer into the collection, whereas in the second on (values of) the iterator is the complete record from the collection. Therefore, you have to treat them a bit differently.\n\nYou can read more on the new PL/SQL iterator constructs in Modern Oracle Database Programming, Chapter 7.\n\nThe source code used in this article can be found at:\n\nhttps://github.com/Qualogy-Solutions/OracleDatabase23c/blob/main/iterators.sql\n\nAlso read my previous blogs about Oracle Database 23:\n\nIntroduction blog series Oracle Database 23\n\nDeveloper Role\n\nGroup by Alias\n\nIf [Not] Exists\n\nTable values constructor\n\nThe Boolean data type\n\nAnd my next blog:"
    }
}