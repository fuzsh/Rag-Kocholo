{
    "id": "yago_24146_1",
    "rank": 37,
    "data": {
        "url": "http://web.stanford.edu/~wfsharpe/mia/mat/mia_mat3.htm",
        "read_more_link": "",
        "language": "en",
        "title": "MATLAB",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://web.stanford.edu/~wfsharpe/home.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Contents:\n\nIntroduction\n\nMATLAB Versions\n\nMatrices as Fundamental Objects\n\nMatrix Operations\n\nAssignment Statements\n\nCase Sensitivity\n\nImmediate and Deferred Execution\n\nShowing Values\n\nInitializing Matrices\n\nMaking Matrices from Matrices\n\nUsing Portions of Matrices\n\nText Strings\n\nMatrix and Array Operations\n\nUsing Functions\n\nLogical and Relational Operations on Matrices\n\nSorting Matrices\n\nControlling Execution Flow\n\nWriting Functions\n\nComments and Help\n\nData Input and Output\n\nMATLAB Function Library\n\nIntroduction\n\nMATLAB stands for Matrix Laboratory. According to The Mathworks, its producer, it is a \"technical computing environment\". We will take the more mundane view that it is a programming language.\n\nThis section covers much of the language, but by no means all. We aspire to at the least to promote a reasonable proficiency in reading procedures that we will write in the language but choose to address this material to those who wish to use our procedures and write their own programs.\n\nMATLAB Versions\n\nVersions of MATLAB are available for almost all major computing platforms. Our material was produced and tested on the version designed for the Microsoft Windows environment. The vast majority of it should work with other versions, but no guarantees can be offered.\n\nOf particular interest are the Student Versions of MATLAB. Prices are generally below $100. These systems include most of the features of the language, but no matrix can have more than 8,192 elements, with either the number of rows or columns limited to 32. For many applications this proves to be of no consequence. At the very least, one can use a student version to experiment with the language.\n\nThe Student Editions are sold as books with disks enclosed. They are published by Prentice-Hall and can be ordered through bookstores.\n\nIn addition to the MATLAB system itself, Mathworks offers sets of Toolboxes, containing MATLAB functions for solving a number of important types of problems. Of particular interest to us is the optimization toolbox, which will be discussed in a later section.\n\nMatrices as Fundamental Objects\n\nMATLAB is one of a few languages in which each variable is a matrix (broadly construed) and \"knows\" how big it is. Moreover, the fundamental operators (e.g. addition, multiplication) are programmed to deal with matrices when required. And the MATLAB environment handles much of the bothersome housekeeping that makes all this possible. Since so many of the procedures required for Macro-Investment Analysis involve matrices, MATLAB proves to be an extremely efficient language for both communication and implementation.\n\nMatrix Operations\n\nConsider the following MATLAB expression:\n\nC = A + B\n\nIf both A and B are scalars (1 by 1 matrices), C will be a scalar equal to their sum. If A and B are row vectors of identical length, C will be a row vector of the same length, with each element equal to the sum of the corresponding elements of A and B. Finally, if A and B are, say, {3*4} matrices, so will C, with each element equal to the sum of the corresponding elements of A and B.\n\nIn short the symbol \"+\" means \"perform a matrix addition\". But what if A and B are of incompatible sizes? Not surprisingly, MATLAB will complain with a statement such as:\n\n??? Error using ==> + Matrix dimensions must agree.\n\nSo the symbol \"+\" means \"perform a matrix addition if you can and let me know if you can't\".\n\nAssignment Statements\n\nMATLAB uses a pattern common in many programming languages for assigning the value of an expression to a variable. The variable name is placed on the left of an equal sign and the expression on the right. The expression is evaluated and the result assigned to the variable name. In MATLAB, there is no need to declare a variable before assigning a value to it. If a variable has previously been assigned a value, the new value overrides the predecessor.\n\nThis may sound obvious, but consider that the term \"value\" now includes information concerning the size of matrix as well as its contents. Thus if A and B are of size {20*30} the statement:\n\nC = A + B\n\nCreates a variable named C that is also {20*30} and fills it with the appropriate values. If C already existed and was, say {20*15} it would be replaced with the required {20*30} matrix. In MATLAB, unlike some languages, there is no need to \"pre-dimension\" or \"re-dimension\" variables. It all happens without any explicit action on the part of the user.\n\nCase Sensitivity\n\nMATLAB variable names are normally case-sensitive. Thus variable C is different from variable c. A variable name can have up to 19 characters, including letters, numbers and underscores. While it is tempting to use names such as FundReturns it is safer to choose instead fund_returns or to use the convention from the C language of capitalizing only second and subsequent words, as in fundReturns. In any event, a\\Adopt a simple set of naming conventions so that you won't write one version of a name in one place and another later. If you do so, you may get lucky (e.g. the system will complain that you have asked for the value of an undefined variable) or you may not (e.g. you will assign the new value to a newly-created variable instead of the old one desired). In programming languages there are always tradeoffs. You don't have to declare variables in advance in MATLAB. This avoids a great deal of effort, but it allows nasty, difficult-to-detect errors to creep into your programs.\n\nImmediate and Deferred Execution\n\nWhen MATLAB is invoked, the user is presented with an interactive environment. Enter a statement, press the carriage return (\"ENTER\") and the statement is immediately executed. Given the power that can be packed into one MATLAB statement, this is no small accomplishment. However, for many purposes it is desirable to store a set of MATLAB statements for use when needed.\n\nThe simplest form of this approach is the creation of a script file: a set of commands in a file with a name ending in .m (e.g. do_it.m). Once such a file exists and is stored on disk in a directory that MATLAB knows about (i.e. one on the \"MATLAB path\"), the user can simply type:\n\ndo_it\n\nat the prompt in interactive mode. The statements will then be executed.\n\nEven more powerful is the function file; this is also a file with an .m extension, but one that stores a function. For example, assume that the file val_port.m, stored in an appropriate directory, contains a function to produce the value of a portfolio, given a vector of holdings and a vector of prices. In interactive mode, one can then simply type:\n\nv = val_port(holdings, prices);\n\nMATLAB will realize that it doesn't have a built-in function named val_port and search the relevant directories for a file named val_port.m, then use the function contained in it.\n\nWhenever possible, you should try to create \"m-files\" to do your work, since they can easily be re-used.\n\nShowing Values\n\nIf at any time you wish to see the contents of a variable, just type its name. MATLAB will do its best, although the result may take some space if the variable is a large matrix.\n\nMATLAB likes to do this and will tell you what it has produced after an assignment statement unless you request otherwise. Thus if you type:\n\nC = A + B\n\nMATLAB will show you the value of C. This may be a bit daunting if C is, say, a 20 by 30 matrix. To surpress this, put a semicolon at the end of any assignment statement. For example:\n\nC = A + B;\n\nInitializing Matrices\n\nIf a matrix is small enough, one can provide initial values by simply typing them in. For example:\n\na = 3; b = [ 1 2 3]; c = [ 4 ; 5 ; 6]; d = [ 1 2 3 ; 4 5 6];\n\nHere, a is a scalar, b is a {1*3} row vector, c a {3*1} column vector, and d is a {2*3} matrix. Thus, typing \"d\" produces:\n\nd = 1 2 3 4 5 6\n\nThe system for indicating matrix contents is very simple. Values separated by spaces are to be on the same row; those separated by semicolons are on to be on separate rows. All values are enclosed in square brackets.\n\nMaking Matrices from Matrices\n\nThe general scheme for initializing matrices can be extended to include matrices as components. For example:\n\na = [1 2 3]; b = [4 5 6]; c = [a b];\n\ngives:\n\nc = 1 2 3 4 5 6\n\nWhile:\n\nd = [a ; b]\n\ngives:\n\nd = 1 2 3 4 5 6\n\nMatrices can easily be \"pasted\" together in this manner -- a process that is both simple and easily understood by anyone reading a procedure (including its author). Of course, the sizes of the matrices must be compatible. If they are not, MATLAB will tell you.\n\nUsing Portions of Matrices\n\nFrequently one wishes to reference only a portion of a matrix. MATLAB provides simple and powerful ways to do so.\n\nTo reference a part of a matrix, give the matrix name followed by parentheses with expressions indicating the portion desired. The simplest case arises when only one element is wanted. For example, using d in the previous section:\n\nd(1,2) equals 2 d(2,1) equals 4\n\nIn every case the first parenthesized expression indicates the row (or rows), while the second expression indicates the column (or columns). If a matrix is, in fact, a vector, a single expression may be given to indicate the desired element, but it is often wise to give both row and column information explicitly, even in such cases.\n\nMATLAB's real power comes into play when more than a single element of a matrix is wanted. To indicate \"all the rows\" use a colon for the first expression. To indicate \"all the columns\", use a colon for the second expression. Thus, with:\n\nd = 1 2 3 4 5 6 d(1,:) equals 1 2 3 d(:,2) equals 2 5\n\nIn fact, you may use any expression in this manner as long as it evaluates to a vector of valid row or column numbers. For example:\n\nd(2,[2 3]) equals 5 6 d(2, [3 2]) equals 6 5\n\nVariables may also be used as \"subscripts\". Thus:\n\nif z = [2 3] then d(2,z) equals 5 6\n\nParticularly useful in this context (and others) is the construct that uses a colon to produce a string of consecutive integers. For example:\n\nthe statement: x = 3:5 produces x = 3 4 5\n\nThus:\n\nd(1, 1:2) equals 1 2\n\nText Strings\n\nMATLAB is wonderful with numbers. It deals with text but you can tell that its heart isn't in it.\n\nA variable in MATLAB is one of two types: numeric or string. A string matrix is like any other, except the elements in it are interpreted asASCII numbers. Thus the number 32 represents a space, the number 65 a capital A, etc.. To create a string variable, enclose a string of characters in \"single\" quotation marks (actually, apostrophes), thus:\n\nstg = 'This is a string';\n\nSince a string variable is in fact a row vector of numbers, it is possible to create a list of strings by creating a matrix in which each row is a separate string. As with all standard matrices, the rows must be of the same length. Thus:\n\nthe statement x = ['ab' ; 'cd'] produces: x = ab cd while x = ['ab' 'cd'] produces: x = abcd as always.\n\nMatrix and Array Operations\n\nThe Mathworks uses the term matrix operation to refer to standard procedures such as matrix multiplication. The term array operation is reserved for element-by-element computations.\n\nMatrix Operations\n\nMatrix transposition is as easy as adding a prime (apostrophe) to the name of the matrix. Thus:\n\nif: x = 1 2 3 then: x' = 1 2 3\n\nTo add two matrices of the same size, use the plus (+) sign. To subtract one matrix from another of the same size, use a minus (-) sign. If a matrix needs to be \"turned around\" to conform, use its transpose. Thus, if A is {3*4} and B is {4*3}, the statement:\n\nC = A + B\n\nwill get you the message:\n\n??? Error using ==> + Matrix dimensions must agree.\n\nwhile:\n\nC = A + B'\n\nwill get you a new matrix.\n\nThere is one case in which addition or subtraction works when the components are of different sizes. If one is a scalar, it is added to or subtracted from all the elements in the other.\n\nMatrix multiplication is indicated by an asterisk (*), commonly regarded in programming languages as a \"times sign\". With one exception the usual rules apply: the inner dimensions of the two operands must be the same. If they are not, you will be told so. The one allowed exception covers the case in which one of the components is a scalar. In this instance, the scalar value is multiplied by every element in the matrix, resulting in a new matrix of the same size.\n\nMATLAB provides two notations for \"matrix division\" that provide rapid solutions to simultaneous equation or linear regression problems. They are better discussed in the context of such problems.\n\nArray Operations\n\nTo indicate an array (element-by-element) operation, precede a standard operator with a period (dot). Thus:\n\nif x = 1 2 3 and y = 4 5 6 then: x.*y = 4 10 18 the \"dot product\" of x and y.\n\nYou may divide all the elements in one matrix by the corresponding elements in another, producing a matrix of the same size, as in:\n\nC = A ./ B\n\nIn each case, one of the operands may be a scalar. This proves handy when you wish to raise all the elements in a matrix to a power. For example:\n\nif x = 1 2 3 then: x.^2 = 1 4 9\n\nMATLAB array operations include multiplication (.*), division (./) and exponentiation (.^). Array addition and subtraction are not needed (and in fact are not allowed), since they would simply duplicate the operations of matrix addition and subtraction.\n\nUsing Functions\n\nMATLAB has a number of built-in functions -- many of which are very powerful. Some provide one (matrix) answer; others provide two or more.\n\nYou may use any function in an expression. If it returns one answer, that answer will be used. The sum function provides an example:\n\nif x = 1 2 3 then the statement: y =sum(x) + 10 will produce: y = 16\n\nSome functions, such as max provide more than one answer. If such a function is included in an expression, only the first answer will be used. For example:\n\nif x = 1 4 3 the statement: z = 10 + max(x) will produce: z = 14\n\nTo get all the answers from a function that provides more than one, use a multiple assignment statement in which the variables that are to receive the answers are listed to the left of the equal sign, enclosed in square brackets, and the function is on the right. For example:\n\nif x = 1 4 3 the statement: [y n] = max(x) will produce: y = 4 n = 2\n\nIn this case, y is the maximum value in x, and n indicates the position in which it was found.\n\nMany of MATLAB's built-in functions, such as sum, min, max, and mean have natural interpretations when applied to a vector. If a matrix is given as an argument to such a function, its procedure is applied separately to each column, and a row vector of results returned. Thus:\n\nif x = 1 2 3 4 5 6 then : sum(x) = 5 7 9\n\nSome functions provide no answers per se. For example, to plot a vector y against a vector x, simply use the statement:\n\nplot(x,y)\n\nwhich will produce the desired cross-plot.\n\nNote that in this case, two arguments (the items in the parentheses after the function name) were provided as inputs to the function. Each function needs a specific number of inputs. However, some have been programmed to react appropriately when fewer are given. For example, to plot y against (1,2,3...), you can use the statement:\n\nplot(y)\n\nThere are many built-in functions in MATLAB. Among them, the following are particularly useful for Macro-Investment Analysis:\n\nones\n\nones matrix\n\nzeros\n\nzeros matrix\n\nsize\n\nsize of a matrix\n\ndiag\n\ndiagonal elements of a matrix\n\ninv\n\nmatrix inverse\n\nrand\n\nuniformly distributed random numbers\n\nrandn\n\nnormally distributed random numbers\n\ncumprod\n\ncumulative product of elements\n\ncumsum\n\ncumulative sum of elements\n\nmax\n\nlargest component\n\nmin\n\nsmallest component\n\nsum\n\nsum of elements\n\nmean\n\naverage or mean value\n\nmedian\n\nmedian value\n\nstd\n\nstandard deviation\n\nsort\n\nsort in ascending order\n\nfind\n\nfind indices of nonzero entries\n\ncorrcoef\n\ncorrelation coefficients\n\ncov\n\ncovariance matrix\n\nNot listed, but of great use, are the many functions that provide plots of data in either two or three dimensions, as well as a number of more specialized functions. However, this list should serve to whet the Analyst's appetite. The full list of functions and information on each one can be obtained via MATLAB's on-line help system.\n\nLogical and Relational Operations on Matrices\n\nMATLAB offers six relational operators:\n\n< : less than\n\n<= : less than or equal to\n\n> : greater than\n\n>= : greater than or equal to\n\n== : equal\n\n~= : not equal\n\nNote carefully the difference between the double equality and the single equality. Thus A==B should be read \"A is equal to B\", while A=B should be read \"A should be assigned the value of B\". The former is a logical relation, the latter an assignment statement.\n\nWhenever MATLAB encounters a relational operator, it produces a one if the expression is true and a zero if the expression is false. Thus:\n\nthe statement: x = 1 < 3 produces: x=1, while x = 1 > 3 produces: x=0\n\nRelational operators can be used on matrices, as long as they are of the same size. Operations are performed element-by-element, resulting a matrix with ones in positions for which the relation was true and zeros in positions for which the relation was false. Thus:\n\nif A = 1 2 3 4 and B = 3 1 2 2 the statement: C = A > B produces: C = 0 1 1 1\n\nOne or both of the operands connected by a relational operator can be a scalar. Thus:\n\nif A = 1 2 3 4 the statement: C = A > 2 produces: C = 0 0 1 1\n\nOne may also use logical operators of which there are three:\n\n& : and\n\n| : or\n\n~ : not\n\nEach works with matrices on an element-by-element basis and conforms to the ordinary rules of logic, treating any non-zero element as true and any zero element as false.\n\nRelational and logical operators are used frequently with If statements (described below) and scalar variables, as in more mundane programming languages. But the ability to use them with matrices offers major advantages in some Investment applications.\n\nSorting Matrices\n\nTo sort a matrix in ascending order, use the sort function. If the argument is a vector, the result will be a new vector with the items in the desired order. If it is a matrix, the result will be a new matrix in which each column will contain the contents of the corresponding column from the old matrix, in ascending order. Note that in the latter case, each column is, in effect, sorted separately. Thus:\n\nif x = 1 5 3 2 2 8 the statement: y=sort(x) will produce: y = 1 2 2 5 3 8\n\nTo obtain a record of the rows from which each of the sorted elements came, use a multiple assignment to get the second output of the function. For the case above:\n\nthe statement: [y r] = sort(x) would produce y as before and r = 1 2 3 1 2 3\n\nThus the second item in the sorted list in column 1 came from row 3, etc..\n\nControlling Execution Flow\n\nIt is possible to do a great deal in MATLAB by simply executing statements involving matrix expressions, one after the other, However, there are cases in which one simply must substitute some non-sequential order. To facilitate this, MATLAB provides three relatively standard methods for controlling program flow: For Loops, While Loops, and If statements\n\nFor Loops\n\nThe most common use of a For Loop arises when a set of statements is to be repeated a fixed number of times, as in:\n\nfor j= 1:n ....... end\n\nThere are fancier ways to use For Loops, but for our purposes, the standard one suffices.\n\nWhile Loops\n\nA While Loop contains statements to be executed as long as a stated condition remains true, as in:\n\nwhile x > 0.5 ....... end\n\nIt is, of course, crucial that at some point a statement will be executed that will cause the condition in the While statement to be false. If this is not the case, you have created an infinite loop -- one that will go merrily on until you pull the plug.\n\nFor readability, it is sometimes useful to create variables for TRUE and FALSE, then use them in a While Loop. For example:\n\ntrue = 1==1; false = 1==0; ..... done = false; while not done ........ end\n\nOf course, somewhere in the While loop there should be a statement that will at some point set done equal to true.\n\nIf Statements\n\nA If Statement provides a method for executing certain statements if a condition is true and other statements (or none) if the condition is false. For example:\n\nIf x > 0.5 ........ else ....... end\n\nIn this case, if x is greater than 0.5 the first set of statements will be executed; if not, the second set will be executed.\n\nA simpler version omits the \"else section\", as in:\n\nIf x > 0.5 ........ end\n\nHere, the statements will be executed if (but only if) x exceeds 0.5.\n\nNesting\n\nAll three of these structures allow nesting, in which one type of structure lies within another. For example:\n\nfor j = 1:n for k = 1:n if x(j,k) > 0.5 x(j,k) = 1.5; end end end\n\nThe indentation is for the reader's benefit, but highly recommended in this and other situations. MATLAB will pair up end statements with preceding for, while, or if statements in a last-come-first-served manner. It is up to the programmer to ensure that this will give the desired results. Indenting can help, but hardly guarantees success on every occasion.\n\nWhile it is tempting for those with experience in traditional programming languages to take the easy way out, using For and While loops for mathematical operations, this temptation should be resisted strenuously. For example, instead of:\n\nport_val = 0; for j = 1:n port_val = port_val + ( holdings(j) * prices(j)); end\n\nwrite:\n\nport_val = holdings*prices;\n\nThe latter is more succinct, far clearer, and will run much faster. MATLAB performs matrix operations at blinding speed, but can be downright glacial at times when loops are to be executed a great many times, since it must do a certain amount of translation of each statement every time it is encountered.\n\nWriting Functions\n\nThe power of MATLAB really comes into play when you add your own functions to enhance the language. Once a function m-file is written, debugged, and placed in an appropriate directory, it is for all practical purposes part of your version of MATLAB.\n\nA function file starts with a line declaring the function, its arguments and its outputs. There follow the statements required to produce the outputs from the inputs (arguments). That's it.\n\nHere is a simple example:\n\nfunction y = port_val(holdings,prices) y = holdings*prices;\n\nOf course, this will only work if the holdings and prices vectors or matrices are compatible for matrix multiplication. A more complex version could examine the sizes of these two matrices, then use transposes, etc. as required.\n\nIt is important to note that the argument and output names used in a function file are strictly local variables that exist only within the function itself. Thus in a program, one could write the statement:\n\nv = port_val(h,p);\n\nThe first matrix in the argument list in this calling statement (here, h) would be assigned to the first argument in the function (here, holdings) while the second matrix in the calling statement (p) would be assigned to the second matrix in the function (prices). There is no need for the names to be the same in any respect. Moreover, the function cannot change the original arguments in any way. It can only return information via its output.\n\nThis function returns only one output, called y internally. However, the resultant matrix will be substituted for the entire argument \"call\" in any expression.\n\nIf a function is to return two or more arguments, simply assign them names in the declaration line, as in:\n\nfunction [total_val, avg_val] = port_val(holdings,prices) total_val = holdings*prices; avg_val = total_val/size(holdings,2);\n\nThis can still be used as in the earlier case if only the total value is desired. To get both the total value and the average value per position, a program could use a statement such as:\n\n[tval aval] = port_val( h,p);\n\nNote that as with inputs, the correspondence between outputs in the calling statement and the function itself is strictly by order. When the function has finished its work, its output values are assigned to the variables in the calling statement.\n\nVariables other than inputs and arguments may be included in functions, as needed. They are strictly local to the function and have no existence outside it. Indeed, a variable in a function may have the same name as one in another place; the two will coexist with neither bothering the other. While MATLAB provides for the use of \"global variables\", their use is widely discouraged and will not be treated here.\n\nIt is an excellent idea to include comments throughout any m-file. To do so, use the percent (%) sign. Everything after it up to the end of the line will be ignored by MATLAB.\n\nThe first several lines after each function header should provide a brief description of the function and its use. Once the function has been placed in an appropriate directory, a user need only type help followed by the function name to be shown all the initial comment lines (up to the first non-comment or totally blank line). Thus if there is a function named port_val, the user can get this information by typing:\n\nhelp port_val\n\nTo provide even more assistance, create a script file with nothing but comment lines, each giving the name and a brief description of all your functions and scripts. If this were named mia_fun, the user could simply type:\n\nhelp mia_fun\n\nto get a list of your functions, then type help function name to get more details on any specific function.\n\nData Input and Output\n\nThere are many ways to get information into and out of the MATLAB environment. We will cover only the simpler ones here.\n\nData Input\n\nThe most straightforward way to get information into MATLAB is to type it in \"command mode\". For example:\n\nprices = [ 12.50 37.875 12.25]; assets = ['cash ';'bonds ' ; 'stocks'];\n\nMATLAB even makes it easy to enter matrices in a more normal form by treating carriage returns as semicolons within brackets. Thus:\n\nholdings = [ 100 200 300 400 500 600 ]\n\nwill create a {3*2} matrix, as desired.\n\nA second way to get data into MATLAB is to create a script file with the required statements, such as the one above. This can be done with any text processor. Large matrices of data can even be \"cut out\" of databases, spreadsheets, etc. then edited to include the desired variable names, square brackets and the like. Once the file or files are saved with .m names they only have to be invoked to bring the data into MATLAB.\n\nNext up the chain of complexity is the use of a flat file which stores data for a matrix. Such a file should have numeric ascii text characters, with each element in a row separated from its neighbor with a space and each row on a separate line. Say, for example, that you have stored the elements of a matrix in a file named test.txt in a directory on the MATLAB path. Then the statement:\n\nload test.txt\n\nwill create a matrix named test containing the data.\n\nData Output\n\nA simple way to output data is to display a matrix. This can be accomplished by either giving its name (without a semicolon) in interactive mode. Alternatively you can use the disp function, which shows values without the variable name, as in:\n\ndisp(test);\n\nFor prettier output, MATLAB has various functions for creating strings from numbers, formatting data, etc.. Function pmat can produce small tables with string identifiers on the borders.\n\nIf you want to save almost everything that appears on your screen, issue the command:\n\ndiary filename\n\nwhere filename represents the name of a new file that will receive the subsequent output. When you are through, issue the command:\n\ndiary off\n\nLater, at your leisure, you may use a text editor to extract data, commands, etc. to data files, script or function files, and so on.\n\nThere are, of course, other alternatives. If you are in an environment (such as a Windows system) that allows material to be copied from one program and pasted into another, this may suffice.\n\nTo create a flat file containing the data from a matrix use the -ascii version of the save command. For example:\n\nsave newdata.txt test -ascii\n\nwill save the matrix named test in the file named newdata.txt.\n\nFinally, you may save all or part of the material from a MATLAB session in MATLAB's own mat file format. To save all the variables in a file named temp.mat, issue the command:\n\nsave temp\n\nAt some later session you may load all this information by simply issuing the command:\n\nload temp\n\nTo save only one or more matrices in this manner, list their names after the file name. Thus:\n\nsave temp prices holdings portval\n\nwould save only these three matrices in file temp.mat. Subsequent use of the command:\n\nload temp\n\nwould restore the three named matrices, with their values intact.\n\nThere are more sophisticated ways to move information into and out of MATLAB, but they can be left to others.\n\nMATLAB Function Library"
    }
}