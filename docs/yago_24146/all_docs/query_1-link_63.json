{
    "id": "yago_24146_1",
    "rank": 63,
    "data": {
        "url": "https://realpython.com/matlab-vs-python/",
        "read_more_link": "",
        "language": "en",
        "title": "MATLAB vs Python: Why and How to Make the Switch – Real Python",
        "top_image": "https://files.realpython.com/media/Matlab-vs-Python_Watermarked.78d19c0990ea.jpg",
        "meta_img": "https://files.realpython.com/media/Matlab-vs-Python_Watermarked.78d19c0990ea.jpg",
        "images": [
            "https://realpython.com/static/real-python-logo.893c30edea53.svg",
            "https://realpython.com/static/pytrick-dict-merge.4201a0125a5e.png",
            "https://files.realpython.com/media/Matlab-vs-Python_Watermarked.78d19c0990ea.jpg",
            "https://files.realpython.com/media/anaconda-navigator.bff710edb0a0.png",
            "https://files.realpython.com/media/spyder-default.0ad112e1eb06.png",
            "https://files.realpython.com/media/spyder-matlab-view.c9e6fbfcffe4.png",
            "https://files.realpython.com/media/spyder-variable-explorer.bed4ebb8ed14.png",
            "https://files.realpython.com/media/spyder-run-settings.784e177e3ab9.png",
            "https://files.realpython.com/media/jupyterlab-main-window.d9420a33f736.png",
            "https://realpython.com/static/pytrick-dict-merge.4201a0125a5e.png",
            "https://realpython.com/cdn-cgi/image/width=1000,height=1000,fit=crop,gravity=auto,format=auto/https://files.realpython.com/media/BryanWeber-square.789781f1e92c.jpg",
            "https://realpython.com/cdn-cgi/image/width=1000,height=1000,fit=crop,gravity=auto,format=auto/https://files.realpython.com/media/BryanWeber-square.789781f1e92c.jpg",
            "https://realpython.com/cdn-cgi/image/width=959,height=959,fit=crop,gravity=auto,format=auto/https://files.realpython.com/media/PP.9b8b026f75b8.jpg",
            "https://realpython.com/cdn-cgi/image/width=800,height=800,fit=crop,gravity=auto,format=auto/https://files.realpython.com/media/gahjelle.470149ee709e.jpg",
            "https://realpython.com/cdn-cgi/image/width=800,height=800,fit=crop,gravity=auto,format=auto/https://files.realpython.com/media/jjablonksi-avatar.e37c4f83308e.jpg",
            "https://realpython.com/static/videos/lesson-locked.f5105cfd26db.svg",
            "https://realpython.com/static/videos/lesson-locked.f5105cfd26db.svg",
            "https://realpython.com/static/videos/lesson-locked.f5105cfd26db.svg",
            "https://files.realpython.com/media/numpy-learning-guide.71182b4d845c.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Real Python"
        ],
        "publish_date": "2019-09-09T14:00:00+00:00",
        "summary": "",
        "meta_description": "In this step-by-step tutorial, you'll learn about MATLAB vs Python, why you should switch from MATLAB to Python, the packages you'll need to make a smooth transition, and the bumps you'll most likely encounter along the way.",
        "meta_lang": "en",
        "meta_favicon": "/static/favicon.68cbf4197b0c.png",
        "meta_site_name": "",
        "canonical_link": "https://realpython.com/matlab-vs-python/",
        "text": "MATLAB vs Python: Comparing Features and Philosophy\n\nPython is a high-level, general-purpose programming language designed for ease of use by human beings accomplishing all sorts of tasks. Python was created by Guido van Rossum and first released in the early 1990s. Python is a mature language developed by hundreds of collaborators around the world.\n\nPython is used by developers working on small, personal projects all the way up to some of the largest internet companies in the world. Not only does Python run Reddit and Dropbox, but the original Google algorithm was written in Python. Also, the Python-based Django Framework runs Instagram and many other websites. On the science and engineering side, the data to create the 2019 photo of a black hole was processed in Python, and major companies like Netflix use Python in their data analytics work.\n\nThere is also an important philosophical difference in the MATLAB vs Python comparison. MATLAB is proprietary, closed-source software. For most people, a license to use MATLAB is quite expensive, which means that if you have code in MATLAB, then only people who can afford a license will be able to run it. Plus, users are charged for each additional toolbox they want to install to extend the basic functionality of MATLAB. Aside from the cost, the MATLAB language is developed exclusively by Mathworks. If Mathworks were ever to go out of business, then MATLAB would no longer be able to be developed and might eventually stop functioning.\n\nOn the other hand, Python is free and open-source software. Not only can you download Python at no cost, but you can also download, look at, and modify the source code as well. This is a big advantage for Python because it means that anyone can pick up the development of the language if the current developers were unable to continue for some reason.\n\nIf you’re a researcher or scientist, then using open-source software has some pretty big benefits. Paul Romer, the 2018 Nobel Laureate in Economics, is a recent convert to Python. By his estimation, switching to open-source software in general, and Python in particular, brought greater integrity and accountability to his research. This was because all of the code could be shared and run by any interested reader. Prof. Romer wrote an excellent article, Jupyter, Mathematica, and the Future of the Research Paper, about his experience with open-source software.\n\nMoreover, since Python is available at no cost, a much broader audience can use the code you develop. As you’ll see a little later on in the article, Python has an awesome community that can help you get started with the language and advance your knowledge. There are tens of thousands of tutorials, articles, and books all about Python software development. Here are a few to get you started:\n\nIntroduction to Python 3\n\nBasic Data Types in Python\n\nPython 3 Basics Learning Path\n\nPlus, with so many developers in the community, there are hundreds of thousands of free packages to accomplish many of the tasks that you’ll want to do with Python. You’ll learn more about how to get these packages later on in this article.\n\nLike MATLAB, Python is an interpreted language. This means that Python code can be ported between all of the major operating system platforms and CPU architectures out there, with only small changes required for different platforms. There are distributions of Python for desktop and laptop CPUs and microcontrollers like Adafruit. Python can also talk to other microcontrollers like Arduino with a simple programming interface that is almost identical no matter the host operating system.\n\nFor all of these reasons, and many more, Python is an excellent choice to replace MATLAB as your programming language of choice. Now that you’re convinced to try out Python, read on to find out how to get it on your computer and how to switch from MATLAB!\n\nNote: GNU Octave is a free and open-source clone of MATLAB. In this sense, GNU Octave has the same philosophical advantages that Python has around code reproducibility and access to the software.\n\nOctave’s syntax is mostly compatible with MATLAB syntax, so it provides a short learning curve for MATLAB developers who want to use open-source software. However, Octave can’t match Python’s community or the number of different kinds of applications that Python can serve, so we definitely recommend you switch whole hog over to Python.\n\nBesides, this website is called Real Python, not Real Octave 😀\n\nAn Overview of Basic Array Operations\n\nAs you have seen, Python does not include a high-speed library for arrays in its standard library. However, the excellent NumPy library is easily available if you install Anaconda. NumPy functions as the de facto array and matrix library for Python.\n\nNumPy has two array-like types:\n\nnumpy.ndarray, also known as numpy.array\n\nnumpy.matrix\n\nThe main difference between these two types is that the ndarray can be any number of dimensions, while the matrix is limited to exactly two dimensions. For ndarray, all operations such as addition, subtraction, multiplication, exponentiation, and division operate element-wise. However, for the matrix type, operations like multiplication and exponentiation are matrix operations.\n\nWhen you’re converting from MATLAB, the matrix type may seem more familiar. It offers similar behavior that you may be used to from MATLAB in terms of operation syntax. However, NumPy strongly recommends that you use the ndarray type because it is more flexible and because matrix will eventually be removed.\n\nIn the rest of this section, you will get to know the major differences between MATLAB and NumPy arrays. You can go in-depth on how to use NumPy arrays by reading Look Ma, No for Loops: Array Programming With NumPy.\n\nBasic Mathematical Operators Work Element-Wise in NumPy\n\nMATLAB, with its heritage as a matrix scripting language, assumes that all arithmetic operators will be operating on arrays. Therefore, MATLAB treats the multiplication of matrices or vectors as matrix multiplication. Consider this example:\n\nMatlab\n\n>> arr_1=[1,2,3]; >> arr_2=[4,5,6]; >> arr_1*arr_2 Error using * Incorrect dimensions for matrix multiplication. Check that the number of columns in the first matrix matches the number of rows in the second matrix. To perform elementwise multiplication, use '.*'.\n\nCopied!\n\nIn this code, you are creating two 1x3 matrices, arr_1, and arr_2. Then, you are attempting to multiply them together. For these 1xN arrays, this is equivalent to taking the dot or scalar product. However, the scalar product only works when the left operand is 1xN and the right is Nx1, so MATLAB produces an error message and suggests the dot-star operator (.*) as the proper syntax for element-wise multiplication:\n\nMatlab\n\n>> arr_1.*arr_2 ans = 4 10 18\n\nCopied!\n\nIn this code, you are performing the element-wise multiplication of arr_1 and arr_2. This multiplies the first element of arr_1 with the first element of arr_2 (4*1 = 4), second with second (2*5 = 10), and third with third (3*6 = 18).\n\nTo perform the scalar product, you can take the transpose of arr_2 to convert it to a 3x1 array:\n\nMatlab\n\n>> arr_1*transpose(arr_2) ans = 32\n\nCopied!\n\nIn this code, you are performing matrix multiplication with arr_1 and the transpose of arr_2. Note that you can use either transpose() or the quote operator (') to take the transpose of arr_2. Since arr_1 is 1x3 and transpose(arr_2) is 3x1, this results in the scalar, or dot, product.\n\nWith NumPy arrays, operations like multiplication with the asterisk (*) operate element-wise by default:\n\nPython\n\nIn [1]: import numpy as np In [2]: arr_1 = np.array([1, 2, 3]) In [3]: arr_2 = np.array([4, 5, 6]) In [4]: arr_1 * arr_2 Out[4]: np.array([ 4, 10, 18])\n\nCopied!\n\nIn this code, you are first importing the NumPy package and assigning it to the name np. Then you are creating two one-dimensional arrays. Notice the syntax for creating arrays in NumPy. It starts with np.array(), which should be read as “from within np, find array().” Then, you have to pass a Python list or tuple to the array constructor that contains the elements of the array. In this case, you are passing a Python list, denoted by the square brackets.\n\nFinally, on input line 4, you are multiplying arr_1 and arr_2. Notice that the result on output line 4 is another array with the elements 4, 10, and 18, the same result as the element-wise multiplication in MATLAB.\n\nIf you want to perform the dot or scalar product for two arrays in NumPy, you have two options. The preferred option is to use the matrix multiplication operator (@) added in Python 3.5. You may see some older code also use dot() from the NumPy library and pass the two arrays:\n\nPython\n\nIn [5]: arr_1 @ arr_2 Out[5]: 32 In [6]: np.dot(arr_1, arr_2) Out[6]: 32\n\nCopied!\n\nIn this code, input line 5 uses the matrix multiplication operator to find the scalar product of arr_1 and arr_2. As expected, the result is 32. Input line 5 uses dot() and should be read as “from within np, find dot() and pass arr_1 and arr_2.” You can see that the result is identical.\n\nNotice that NumPy did not require you to transpose arr_2 before performing the scalar product. You’ll learn more about this feature in the next section.\n\nOne-Dimensional Arrays Are Vectors in NumPy\n\nAs you saw in the last section, MATLAB insists that the dimensions of arrays align when performing matrix multiplication, while NumPy is a little bit more flexible. This is because of how one-dimensional arrays are treated in MATLAB versus in NumPy.\n\nIn MATLAB, every array always has at least two dimensions, even if only implicitly. You can see this by checking the size() of a single number:\n\nMatlab\n\n>> size(1) ans = 1 1\n\nCopied!\n\nHere, you are finding the size of the integer 1. You can see that the result is an array with 1 row and 1 column.\n\nYou can create row vectors or column vectors in MATLAB, and switch between them with the transpose operator (') or transpose():\n\nMatlab\n\n>> arr_1=[1,2,3]; >> arr_2=[1;2;3]; >> arr_1'==arr_2 ans = 3×1 logical array 1 1 1 >> arr_2'==arr_1 ans = 1×3 logical array 1 1 1\n\nCopied!\n\nIn this code, you are creating two vectors: arr_1 and arr_2. Arrays with values in one dimension only are called vectors. arr_1 is a row vector because the elements are arranged in one row and three columns, whereas arr_2 is a column vector because the elements are arranged in three rows and one column. In MATLAB, elements are put into different columns by separating them with a comma in the assignment and elements are put into different rows by separating them with a semicolon.\n\nThen, you are checking the equality of the transpose of arr_1 with arr_2, and you find that all of the elements are equal and the result is a column vector of logical values. Finally, you are checking the equality of the transpose of arr_2 with arr_1, and you find that all of the elements are equal and the result is a row vector of logical values.\n\nYou can see that in MATLAB, even vectors have two dimensions associated with them: rows and columns. When the transpose is performed, the rows are switched with the columns, and the shape of the array is changed. This means there are two types of vectors in MATLAB: row-vectors and column-vectors.\n\nIn NumPy, there are three types of one-dimensional arrays or vectors. The default is an N-element vector with only one dimension. This is different from the default in MATLAB, where every array has at least 2 dimensions. This one-dimensional vector in NumPy does not have a sense of rows and columns, since for a one-dimensional structure, it does not matter in general whether the elements are stored in rows or in columns, only how many elements there are.\n\nYou can see an example of creating this kind of array in the following example. In the next few examples, there are extra spaces added before and after parentheses to clarify the syntax. These spaces are usually not considered good Python style, but they’re in the example to help you see what’s going on:\n\nPython\n\nIn [1]: import numpy as np In [2]: arr_vec = np.array( [1, 2, 3] ) In [3]: arr_vec.shape Out[3]: (3,)\n\nCopied!\n\nIn this code, you are creating a default 3-element vector in NumPy. On input line 1, you import NumPy and make it available under np. On input line 2 you are creating the array and storing it in arr_vec. You are passing the list [1, 2, 3] to array(), where the list has 3 elements and none of the elements are themselves lists. This creates the 3-element array with only one dimension.\n\nYou can verify that this is the case by displaying the shape of the array, as shown on input line 3. That line should be read as “from within arr_vec (an array), find the shape.” The shape of the array is equivalent to size() in MATLAB. In this case, the shape is (3,), indicating there are three elements and only one dimension, since there is not a second number after the comma.\n\nYou can also create row-vectors and column-vectors in NumPy, analogous to the row-vectors and column-vectors in MATLAB. NumPy’s array() takes a flat list or a nested list as input. Using the flat list gets you a one-dimensional, N-element vector. By using the nested list, you can create arrays of any dimension that you want. A nested list means that there are one or more lists contained within an outer list. Here’s an example of a nested list:\n\nPython\n\n[[1, 2, 3], [4, 5, 6]]\n\nCopied!\n\nIn this code, you see an outer list that has 2 elements. Each of these 2 elements of the outer list is another, nested, list that has three elements, the integers 1-3 and 4-6. In terms of arrays, you can think of the number of elements of each inner list as the number of columns, and the number of nested lists is the number of rows. This is easier to see if you change the formatting:\n\nPython\n\n[ [1, 2, 3], [4, 5, 6] ]\n\nCopied!\n\nThis code is still valid Python syntax, but it emphasizes how the inner lists are each a row of the array, and the number of elements in each inner list is the number of columns. In this case, we would have an array with 2 rows and 3 columns. We can use these nested lists to create row-vectors and column-vectors in NumPy arrays:\n\nPython\n\nIn [4]: arr_row = np.array( [[1, 2, 3]] ) In [5]: arr_row.shape Out[5]: (1, 3)\n\nCopied!\n\nIn this code, you are creating a row array or vector by using a nested list. Input line 4 is passing [[1, 2, 3]] to array(). You can break out the formatting of this nested list to see how it looks:\n\nPython\n\n[ [1, 2, 3] ]\n\nCopied!\n\nAs you can see, there is one row in this nested list with three columns. On input line 5, you are displaying the shape of this array. As expected, the shape is (1, 3), or one row with three columns.\n\nFinally, you can create a column array by including three nested lists in the input:\n\nPython\n\nIn [6]: arr_col = np.array( [[1], [2], [3]] ) In [7]: arr_col.shape Out[7]: (3, 1)\n\nCopied!\n\nIn this code, input line 6 is passing [[1], [2], [3]] to the array constructor. You can break out the formatting of this nested list to see how it looks:\n\nPython\n\n[ [1], [2], [3] ]\n\nCopied!\n\nAs you can see, there are three rows in this nested list with one column each. On input line 7, you are displaying the shape of this array. As expected, the shape is (3, 1), or three rows with one column.\n\nSince the general N-element vector has no sense of rows and columns, NumPy is able to shape the vector in whatever way makes sense for the operation being performed. You saw this in the last section, where the NumPy array did not need to be transposed to perform the scalar product, whereas the MATLAB array did need to be transposed.\n\nTrying to take the transpose of the N-element vector does not change the shape of the array. You can take the transpose using either np.transpose() or the .T attribute of the array:\n\nPython\n\nIn [8]: arr_vec_transp = np.transpose(arr_vec) In [9]: arr_vec_transp.shape Out[9]: (3,)\n\nCopied!\n\nIn this code, you are taking the transpose of the N-element vector arr_vec and printing its shape. Notice that the shape is the same as the shape of the original arr_vec.\n\nHowever, if you are using row-vectors and column-vectors, you will need to ensure that the dimensions are appropriate for the particular operation. For instance, trying to take the scalar product of the row vector with itself will result in an error:\n\nPython\n\nIn [10]: arr_row @ arr_row Traceback (most recent call last): File \"<ipython-input-10-2b447c0bc8d5>\", line 1, in <module> arr_row @ arr_row ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)->(n?,m?) (size 1 is different from 3)\n\nCopied!\n\nIn this code, trying to find the scalar product of the row vector with itself results in a ValueError informing you that the dimensions of the arrays are not aligned. Using dot() gives the same error but a slightly different message:\n\nPython\n\nIn [11]: np.dot(arr_row, arr_row) Traceback (most recent call last): File \"<ipython-input-11-d6e191b317ae>\", line 1, in <module> np.dot(arr_row, arr_row) ValueError: shapes (1,3) and (1,3) not aligned: 3 (dim 1) != 1 (dim 0)\n\nCopied!\n\nIn this code, you are using dot() from the np namespace to attempt to find the scalar product of two 1x3 row-vectors. Since this operation is not permitted, NumPy raises a ValueError, similar to the matrix multiplication operator.\n\nInstead, you need to take the transpose of one of the arguments:\n\nPython\n\nIn [12]: arr_row.T Out[12]: array([[1], [2], [3]]) In [13]: sc_prod = arr_row @ arr_row.T In [14]: sc_prod Out[14]: array([[14]])\n\nCopied!\n\nOn input line 12, you are taking the transpose of the row vector to turn it into a column vector using the transpose attribute (.T). This is shown in corresponding output line, where the elements are arranged to form a column for printing purposes. Then, you are taking the scalar product of the vector with its transpose, producing an array with a single value, 14. Notice that this is a 1x1 array, so to access just the value, you need to access the first element in each dimension:\n\nPython\n\nIn [15]: sc_prod.shape Out[15]: (1, 1) In [16]: sc_prod[0, 0] Out[16]: 14\n\nCopied!\n\nIn this code, you are verifying that the shape is 1x1, and then accessing the first element in each dimension located at the 0th index. Remember that Python uses 0 as the first index, not 1.\n\nYou can use the nested lists to create arrays of any shape that you want. To create a three-by-three array (two-dimensional), simply include three elements in each of your three nested lists:\n\nPython\n\nIn [17]: arr_2d = np.array( [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ) In [18]: arr_2d.shape Out[18]: (3, 3)\n\nCopied!\n\nIn this code, you have nested three lists with three elements each into the constructor. As shown by the shape, this produces a 3x3 array with the elements 1 through 9.\n\nCreating Arrays Is Very Flexible in NumPy\n\nMATLAB and NumPy both allow you to explicitly specify the specific elements in an array, as you have seen in the previous section. In addition to this direct creation of arrays, both MATLAB and NumPy support a number of other methods to create arrays without explicitly specifying each element. The NumPy project maintains a detailed list of the equivalent functions between MATLAB and NumPy.\n\nMany functions operate identically between MATLAB and NumPy. This includes commonly used functions like linspace() and logspace() to generate evenly spaced data and ones() and zeros() to generate arrays of a given shape filled with ones and zeros, respectively. The full list of ways to create arrays in NumPy is listed in the official documentation.\n\nThe one big difference between MATLAB and NumPy in terms of array creation routines is that MATLAB supports simply using the colon to create an array, while NumPy does not. Instead, NumPy uses arange() to create an array between specified values.\n\nIn MATLAB, you can use a colon to create an array specification range. In general, you can use up to 2 colons in a specification. The syntax is as follows:\n\nMatlab\n\nstart:stop start:step:stop\n\nCopied!\n\nIn this syntax, the, first method only uses one colon and specifies the start and stop values. The second method includes a second colon, where the value before the first colon is the start, the middle value is the step, and the last value is the stop.\n\nTry out these examples to experiment with this syntax:\n\nMatlab\n\n>> arr_1=1:6 arr_1 = 1 2 3 4 5 6 >> size(arr_1) ans = 1 6\n\nCopied!\n\nIn this example, you are using the single colon with the start and stop to generate an array with the values from 1 to 6. You can see that when the step is omitted, it defaults to a value of 1. Notice that MATLAB includes both the start and the stop values in the array, and that the size of the array is 6 elements long. Next, change the value of the step size to create a new array:\n\nMatlab\n\n>> arr_2=1:2:6 arr_2 = 1 3 5\n\nCopied!\n\nIn this example, you are using the two colons syntax with the start, step, and stop. The start value is 1, the step is 2, and the stop value is 6, so MATLAB starts with 1, increments to 3, and then to 5. The next step would exceed the stop value, so MATLAB does not include the stop value in the array. Next, change the starting value to create another new array:\n\nMatlab\n\n>> arr_3=2:2:6 arr_3 = 2 4 6\n\nCopied!\n\nIn this example, you are again using the two colon method, but you are specifying the start value as 2 instead of 1. In this case, MATLAB starts at 2, increments to 4, increments to 6, and then has reached the stop value so does not go further. Notice that in this case, the the stop value of 6 is included in the array.\n\nWith NumPy, you can use arange() to create an array with specific start, stop, and step values. However, arange() has one big difference from MATLAB, which is that the stop value is not included in the resulting array. The reason for this is so that the size of the array is equal to stop - start for the default case of a step size of 1. Notice in MATLAB that the size of the array of the integers from 1 to 6 is 6, but 6 - 1 = 5.\n\nThere are three ways to use arange():\n\nPython\n\nimport numpy as np np.arange(stop) np.arange(start, stop) np.arange(start, stop, step)\n\nCopied!\n\nIf you only pass one argument to arange(), it will be interpreted as the stop value. The start value defaults to 0 and the step defaults to 1. If you pass two arguments to arange(), they are interpreted as the start and stop values. Finally, you can pass all three of start, stop, and step to arange().\n\nNotice that the order of the arguments is different from MATLAB, going start, stop, step in Python. If you’re having trouble remembering the order that these arguments go, remember that you can use keyword arguments in Python to be explicit about what each argument means.\n\nYou can try out arange() with the following examples:\n\nPython\n\nIn [1]: import numpy as np In [2]: arr_1 = np.arange(1, 7) In [3]: arr_1 Out[3]: array([1, 2, 3, 4, 5, 6]) In [4]: arr_1.shape Out[4]: (6,)\n\nCopied!\n\nIn this example, you are creating an array that contains the values from 1 to 6. As in MATLAB, if the step is omitted, it defaults to 1. Notice that you had to pass the stop value 7 so that the array stopped at 6. However, the size of the resulting array is 7 - 1 = 6 elements long. Next, you should see how to change the step size:\n\nPython\n\nIn [5]: arr_2 = np.arange(1, 7, 2) In [6]: arr_2 Out[6]: array([1, 3, 5])\n\nCopied!\n\nIn this code, you are creating an array that contains the values from 1 to 6, incrementing by two between each element. The step is two, so NumPy starts with 1, increments to 3, and then to 5. The next step would equal the stop value, but NumPy does not include the stop value in the array. Notice that the formula to compute the size of the array is a little bit different, since the step size is not 1.\n\nWith step sizes other than 1, the size of the array can be computed by (stop - start)/step if this results in an integer value. In this case, the size of the array is (7 - 1)/2 = 3 elements, as expected. If (stop - start)/step results in a floating point number, the size of the array is equal to the next largest integer as demonstrated in the next example:\n\nPython\n\nIn [7]: arr_3 = np.arange(2, 7, 2) In [8]: arr_3 Out[8]: array([2, 4, 6])\n\nCopied!\n\nIn this example, you are creating an array that contains the values from 2 to 6, incrementing by two between each element. The step is two, so NumPy starts with 2, increments to 4, and then to 6. The next step would exceed the stop value, so NumPy stops at 6. Notice that the size of the array is (7 - 2)/2 = 2.5, so the next highest integer is 3 elements, as expected.\n\nFinally, you should usually use integer arguments to arange() in NumPy and the colon operator in MATLAB. If you use floating point values (numbers with decimals), especially for the step, the elements may not come out exactly as you expect. If you want to use floating point numbers, linspace() is a better choice in general.\n\nThe Colon Operator Is Very Powerful in NumPy\n\nIn MATLAB, the colon operator is used to perform a number of useful tasks. As you saw, it can be used to create arrays, and it can also be used to index or slice arrays. When indexing arrays, MATLAB supports the end keyword to extend the specified range to the end of that dimension, as you saw earlier:\n\nMatlab\n\n>> arr_1=1:2:6; >> arr_1(2:end) ans = 3 5\n\nCopied!\n\nIn this code, you are indexing arr_1 starting at the second index and going to the end of the array. You can also specify a specific index as the stop value:\n\nMatlab\n\n>> arr_2=1:6; >> arr_2(2:4) ans = 2 3 4\n\nCopied!\n\nIn this code, you are creating an array arr_2 with the numbers 1 through 6, inclusive. Then, you are specifying the second element as the start value and the fourth element as the stop value in the slice. MATLAB supports the two-colon increment syntax when indexing as well:\n\nMatlab\n\n>> arr_2(2:2:end) ans = 2 4 6\n\nCopied!\n\nIn this code, you are indexing the array, starting at the second element, skipping every other element, until the end of the array. You can also use end as the starting point of the slice with a negative step:\n\nMatlab\n\n>> arr_2(end:-1:4) ans = 6 5 4\n\nCopied!\n\nIn this code, you are indexing arr_2 starting from the last value, decrementing by 1, and ending at the 4th element. Finally, you can slice all of the element in a dimension by using just a bare colon:\n\nMatlab\n\n>> arr_2(:) ans = 1 2 3 4 5 6\n\nCopied!\n\nIn this code, you are selecting all of the first dimension of the array using just the colon.\n\nNumPy and Python in general also use the colon for the slice syntax, but the order of the values is slightly different. In Python, the order is start : stop : step, whereas in MATLAB, it is start : step : stop, as you saw earlier. In addition, in NumPy you can omit start or stop and they will have default a value of 0 (or the first element) for start and the last element for stop. In MATLAB, you must specify start and stop if you want to specify either of them. Thus, Python does not have the end keyword, since you can omit stop to achieve the same behavior.\n\nTry out the following examples of the slice syntax in NumPy:\n\nPython\n\nIn [1]: import numpy as np In [2]: arr_1 = np.arange(1, 7, 2) In [3]: arr_1[1:] Out[3]: array([3, 5])\n\nCopied!\n\nIn this code, you are creating an array with the integers from 1 to 6, inclusive, skipping every other number. Then, you are slicing the array taking the second element (index 1) until the end of the array. Notice that the stop value was omitted, so it defaulted to the last element in the array.\n\nYou can also specify a specific element as the stop value. You saw in using arange() that the array did not include the stop value. The same is true of the slice syntax in Python, the slice will include everything up to, but not including, the stop index:\n\nPython\n\nIn [4]: arr_2 = np.arange(1, 7) In [5]: arr_2[1:4] Out[5]: array([2, 3, 4])\n\nCopied!\n\nIn this code, you are creating an array with the integers from 1 to 6, inclusive. Then, you are slicing the array starting at the second element (index 1, value 2) until the fourth element (index 3, value 4). However, you specified the stop index as 4 (the fifth element in the array, value 5). The reason Python includes up to the (stop - 1) index is the same reason arange() does not include the stop value, so that the length of the resulting array is equal to stop - start. Next, try changing the step of the slice:\n\nPython\n\nIn [6]: arr_2[1::2] Out[6]: array([2, 4, 6])\n\nCopied!\n\nIn this code, you are slicing the array starting at the second element (index 1), going until the end of the array, and taking every second element. This results in an array with the values 2, 4, and 6. Notice that the stop value was omitted in the slice syntax, so it defaulted to the last element in the array.\n\nYou can also use a negative step in the slicing syntax for Python:\n\nPython\n\nIn [7]: arr_2[:2:-1] Out[7]: array([6, 5, 4])\n\nCopied!\n\nIn this code, you are not specifying the start index of the slice, you are specifying the stop value should be index 2, and the step should be -1. Since the start index is not specified and the step is negative, the start value is assumed to be the last element in the array (or the first element in the reversed array). For the stop value, index 2 has the value of 3 and one index before that (in the reversed array) is index 3 with the value of 4.\n\nFinally, just like in MATLAB, a bare colon means to select all of the elements from that dimension:\n\nPython\n\nIn [8]: arr_2[:] Out[8]: array([1, 2, 3, 4, 5, 6])\n\nCopied!\n\nArray Slices Are Views of Arrays in NumPy\n\nIn MATLAB, when you access a slice of an array and assign it to a variable, MATLAB will make a copy of that portion of the array into your new variable. This means that when you assign values to the slice, the original array is not affected. Try out this example to help explain the differences of MATLAB vs Python:\n\nMatlab\n\n>> arr_1=[1,2,3;4,5,6;7,8,9]; >> arr_2=arr_1(2:end,2:end); arr_2 = 5 6 8 9 >> arr_2(1,1)=10 arr_2 = 10 6 8 9 >> arr_1 arr_1 = 1 2 3 4 5 6 7 8 9\n\nCopied!\n\nIn this code, you have created a 3x3 array arr_1 storing the values from 1 through 9. Then, you create a 2x2 slice of the original array storing from the second value to the end in both dimensions, arr_2. On the third input line, you assign the value 10 to the upper left element in arr_2. Finally, you print arr_1 again to verify that none of the values in arr_1 have changed.\n\nTechnical detail: MATLAB employs a copy-on-write memory management system, where an array may only be copied to a new memory location when it is modified. You can read more about MATLAB memory management in Memory Management for Functions and Variables on the Mathworks blog and in Internal Matlab memory optimizations.\n\nIn NumPy, slices of arrays are views to the original array. This behavior saves memory and time, since the values in the array don’t have to be copied to a new location. However, it means that changes that you make to a slice from an array will change the original array. You should try the following code to see how this works:\n\nPython\n\nIn [1]: import numpy as np In [2]: arr_1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8 ,9]]) In [3]: arr_2 = arr_1[1:, 1:] In [4]: arr_2 Out[4]: array([[5, 6], [8, 9]])\n\nCopied!\n\nIn this code, you are creating a 3x3 array arr_1 storing the values from 1 through 9. Then, you create a 2x2 slice of the original array storing from the second value to the end in both dimensions, arr_2. Notice that the Python indexing is 0-based, so the second element has the index 1. Finally, you are printing arr_2 to verify that it is a 2x2 array.\n\nNow you should see what happens when you change a value in arr_2. Like in the MATLAB example, you should change the upper left element of arr_2:\n\nPython\n\nIn [5]: arr_2[0, 0] = 10 In [6]: arr_2 Out[6]: array([[10, 6], [ 8, 9]]) In [7]: arr_1 Out[7]: array([[ 1, 2, 3], [ 4, 10, 6], [ 7, 8, 9]])\n\nCopied!\n\nIn this code, you first assign the upper left element in arr_2, at index (0, 0) to have a value of 10. Then you print arr_2 to verify that the appropriate value has changed. Finally, you print arr_1 and see that the value in the middle of the array has changed from 5 to 10!\n\nThis is what is meant by arr_2 being a view of arr_1. Since it is a view, arr_2 points to the same memory location as arr_1, so updating arr_2 also updates arr_1 because the value stored in the memory location accessed by both arr_2 and arr_1 has been updated. This also goes the other direction, where changing values in arr_1 will update the value in arr_2:\n\nPython\n\nIn [8]: arr_1[-1, -1] = 42 In [9]: arr_1 Out[9]: array([[ 1, 2, 3], [ 4, 10, 6], [ 7, 8, 42]]) In [10]: arr_2 Out[10]: array([[10, 6], [ 8, 42]])\n\nCopied!\n\nIn this code, you are assigning the bottom right element of arr_1 to have the value 42. Remember that in Python, an index of -1 means the last value on that dimension. Then you are printing arr_1 to verify that the lower right value has changed from 9 to 42. Finally, you are printing arr_2, and you see for arr_2 as well, the bottom right value has changed from 9 to 42.\n\nIf you want to generate a copy of an array, you can use np.copy(). Copying an array creates a new place in memory for the copy to be stored, so changes to the copied array do not affect the original:\n\nPython\n\nIn [11]: arr_3 = np.copy(arr_2) In [12]: arr_3[1, 0] = 37 In [13]: arr_3 Out[13]: array([[10, 6], [37, 42]]) In [14]: arr_2 Out[14]: array([[10, 6], [ 8, 42]])\n\nCopied!\n\nIn this code, you are creating arr_3 as a copy of arr_2. Then, you are changing the element in the second row, first column to have the value of 37. Then, you are printing arr_3 to verify that the specified change has been made. Finally, you are printing arr_2 to verify that no changes have occurred in arr_2, as expected.\n\nTips and Tricks to Make Your Code Pythonic\n\nLike any other programming language, Python code written by experienced Python developers often has a particular look and feel to it. This is because they are able to take advantage of specific idioms in Python to work with Python rather than against Python. Developers coming from other languages often miss out on what makes code Pythonic in their first projects.\n\nIn this section, you’ll learn some tips and tricks to make your code Pythonic and level up your Python skills. There are many more tips and tricks than you can learn here, so feel free to check out Write More Pythonic Code.\n\nYou Should Not Use Semicolons to End Lines in Python\n\nIn MATLAB, ending a line of code with a semicolon ; suppresses the output from that line. For instance, assigning a variable will print the value of the variable after the assignment if the semicolon is omitted.\n\nIn Python, you should not end lines of code with semicolons. It is unnecessary, since Python does not change its behavior whether the line is ended with a semicolon or not. So you can save yourself a key stroke and not bother including the semicolon in your scripts and libraries.\n\nThere is one case in Python where the semicolon is useful. When you want to execute several statements, but you cannot include a newline character in the input, you can separate the statements with semicolons. This is mostly useful to execute very short scripts from the command prompt or terminal. For instance, to find the particular Python executable that is running, you can type the following:\n\nShell\n\n$ python -c\"import sys; print(sys.executable)\" /home/eleanor/anaconda3/bin/python\n\nCopied!\n\nIn this code, you are executing the Python interpreter in the python executable and passing the -c switch. This switch takes the next argument and executes it within the interpreter. Since the shell environment would execute if you pressed Enter to insert a new line, you can type the whole script on one line.\n\nIn this case, you have two logical statements that need to be separated by the semicolon. First you are importing the built-in sys library and then you are printing the value of sys.executable. In this example, the Python interpreter that the shell is running comes from the /home/eleanor/anaconda3/bin/python file.\n\nYou Should Not Import * From a Module in Python\n\nIn a previous section, you read about how namespaces are one honking great idea in Python. In MATLAB, all functions are part of the global namespace by default, so every function and class name has to be unique. Python solves this problem by using namespaces and requiring you to specify which module a function should come from.\n\nYou will find tutorials around the Web that suggest you write the following:\n\nPython\n\nfrom a_module import *\n\nCopied!\n\nIn this code, you are using the * to indicate that Python should import everything that is contained in a_module and put it in the current scope without a prefix. This is slightly more convenient, because you no longer have to prefix functions and classes from a_module with anything, you can just use them directly. However, it is not a good practice because you don’t know what names are defined in a_module and whether or not they will override any existing names in your current scope.\n\nTechnical Note: When you from a_module import *, Python imports all of the names listed in a special variable called __all__ in a_module. However, if that variable is not defined, Python will import all of the variables, functions, and classes defined in a_module.\n\nYou Should Take Advantage of the Different Data Types in Python\n\nMATLAB, with its heritage as a linear algebra and array focused language, treats most data types as arrays of some sort. This often makes it a little bit tricky to work with more advanced data types like structs, containers.Map, cell arrays, and more.\n\nPython has several built-in data types that are very flexible and can be used to accomplish a number of useful tasks. The major ones that you’ll learn about in this section are lists and dictionaries.\n\nLists\n\nPython lists are mutable sequences of values. Lists can contain heterogeneous data, which means that each element of the list can be of a different type. Because lists are mutable, you can change the value of any element in the list, or add or remove values from the list, without creating a new list object.\n\nSince lists are sequences, you can create loops that iterate over them. In Python, you do not need to access each element of a list with an index in a for loop, as you would do in MATLAB:\n\nMatlab\n\n>> arr_1=1:2:6; >> fori=1:length(arr_1) disp(arr_1(i)) end 1 3 5\n\nCopied!\n\nIn this code, you are creating an array arr_1 with the integers from 1 to 6, taking every other number. Then you are creating a for loop where the loop variable goes from 1 to the length of arr_1. Finally, you are displaying the value of the element of arr_1 at the loop variable on each step by using the loop variable i to index arr_1.\n\nIn Python, you should not use an index for the list when you loop over it. Instead, you should loop directly over the items in a list:\n\nPython\n\nIn [1]: lst_1 = [1, \"b\", 3.0] In [2]: for item in lst_1: ...: print(item) ...: 1 b 3.0\n\nCopied!\n\nIn this code, on input line 1 you are first creating a Python list with three elements:\n\nThe integer 1\n\nThe string \"b\"\n\nThe float 3.0\n\nThis list is assigned to lst_1. Then you are using a for loop to access each item in the list in turn. On each iteration, the next value in the list is put into the variable item that you specified on the for line. Then, you are printing the value of item on each iteration.\n\nNotice in the previous example that you could loop over the value of each element in the list without using an index. Nonetheless, sometimes you want to access the index of each item in the list as you’re looping over it. For those cases, Python provides enumerate() that returns the index and the value of the item:\n\nPython\n\nIn [3]: for index, item in enumerate(lst_1): ...: print(f\"The index is {index} and the item is {item}\") ...: The index is 0 and the item is 1 The index is 1 and the item is b The index is 2 and the item is 3.0\n\nCopied!\n\nIn this code, you are looping over lst_1 again, but this time, you are using enumerate() to get both the index and the item. Then you are printing the value of the index and item on each loop iteration. As you can see from the result, the index values start at 0 as expected, but you do not need to use the index to access the item from the list.\n\nIn summary, you should not write Python code like this:\n\nPython\n\nfor i in range(len(lst_1)): print(lst_1[i])\n\nCopied!\n\nIn this code, you are creating a range of integers from 0 to the length of lst_1 and then you are accessing each element in the list by its index. This can lead to off-by-one and fencepost errors. Instead, you should write code that loops over the list directly:\n\nPython\n\nfor item in lst_1: print(item)\n\nCopied!\n\nYou can read a lot more about lists in Lists and Tuples in Python and about for loops and iteration in Python “for” Loops (Definite Iteration). There is also a more advanced concept called list comprehensions that you can learn about in Using List Comprehensions Effectively.\n\nDictionaries\n\nIn MATLAB, you can create a map data type with containers.Map(). This kind of data structure is useful when you have two pieces of data that are always related to each other and you want to connect them together. For instance, you can map cities to their population with a containers.Map():\n\nMatlab\n\n>> cities=containers.Map({'Cleveland';'Pittsburgh';'Hartford'}, [383793,301048,122587]); >> cities('Cleveland') ans = 383793\n\nCopied!\n\nIn this code, you are creating a containers.Map() on the first line. The first argument is a cell array of character arrays with the city names. These are called the keys of the map. The second argument is an array of populations. These are called the values of the map. Then, you are accessing the value of the population in Cleveland by indexing the map with a character array.\n\nYou can assign new values into the map by assigning to an undefined key value:\n\nMatlab\n\n>> cities('Providence')=180393;\n\nCopied!\n\nIf you try to access a key that does not exist, you will receive an error message:\n\nMatlab\n\n>> cities('New York City') Error using containers.Map/subsref The specified key is not present in this container.\n\nCopied!\n\nPython has an equivalent data structure called a dictionary. To create a Python dictionary, you can use curly braces and specify the keys and values with each other:\n\nPython\n\nIn [1]: cities = { ...: \"Cleveland\": 383_793, ...: \"Pittsburgh\": 301_048, ...: \"Hartford\": 122_587} In [2]: cities[\"Cleveland\"] Out[2]: 383793\n\nCopied!\n\nIn this code, on input line 1 you are creating the dictionary of cities using curly braces. Notice that the key and value are specified together, separated by a colon. The values are specified with _ in the numbers, a feature available since Python 3.6. This does not change the value of the number, it only makes it easier to read very large numbers. Then, you are accessing the value at the \"Cleveland\" key using square brackets, similar to the indexing syntax for lists and arrays.\n\nYou can add new keys to the dictionary by assigning to them:\n\nPython\n\nIn [3]: cities[\"Providence\"] = 180_393\n\nCopied!\n\nIn this code, you assigned a new key \"Providence\" to the dictionary with a value of 180,393. If you try to access a key that is not in the dictionary, you will get a KeyError:\n\nPython\n\nIn [4]: cities[\"New York City\"] Traceback (most recent call last): File \"<ipython-input-4-6ebe5b35f3ea>\", line 1, in <module> cities[\"New York City\"] KeyError: 'New York City'\n\nCopied!\n\nIn this code, you are trying to access the dictionary using the \"New York City\" key. However, this key does not exist in the dictionary so Python raises a KeyError letting you know that \"New York City\" is not an option.\n\nYou can read a lot more about Python dictionaries in Dictionaries in Python and KeyError exceptions in Python KeyError Exceptions and How to Handle Them. You can also iterate through dictionaries and use dictionary comprehensions, similar to list comprehensions. You can read about these topics in How to Iterate Through a Dictionary in Python.\n\nExceptions Help You Control Program Flow in Python\n\nMATLAB and Python both use errors and exceptions to let you know when something has gone wrong in the code. In this section, you will learn about common exceptions in Python and how you can handle them appropriately.\n\nIf you want an introduction to Python exceptions overall, you can read Python Exceptions: An Introduction. When a Python exception is raised, it produces a traceback. You can read about how to interpret the traceback in Understanding Python Tracebacks. Understanding tracebacks is very helpful to interpret and correct Python exceptions in general. There are a few specific cases that usually have the same resolution. You’ll see those described in the rest of this section.\n\nNameError\n\nPython NameError exceptions are usually the result of a variable being undefined. When you see a NameError, check your code for typos and misspelled variable names. You can use the debugging features and the variable explorer in Spyder to find out which variables are defined.\n\nSyntaxError\n\nPython SyntaxError exceptions mean that you have input some improper syntax. This is usually caused by mismatched brackets, when you have only the opening bracket or closing bracket but not the matching one. These exceptions usually point to the line after the place where the problem is located.\n\nAnother common SyntaxError is using only one equals sign in an if statement. In this case, you either meant not-equals (!=) or equals (==), so you can correct the line. For more on SyntaxError exceptions, check out Invalid Syntax in Python: Common Reasons for SyntaxError.\n\nKeyError\n\nPython KeyError exceptions occur when you try to access a key in a dictionary that does not exist. You can use .get() to retrieve a key from a dictionary if it exists, or return a default value if the key does not exist. You can read more about KeyError exceptions in Python KeyError Exceptions and How to Handle Them.\n\nIndexError\n\nPython IndexError exceptions occur when you are trying to access the index of an array or list that does not exist. This usually means the array or list you are trying to access has fewer elements than the index you are trying to access. You can use the debugging features and the variable explorer in Spyder to see the size of lists and arrays and make sure you’re only accessing indices that exist.\n\nImportError/ModuleNotFoundError\n\nPython ImportError and ModuleNotFoundError exceptions occur when you try to import a module that Python cannot find. This might be because it is installed in a different conda environment or virtualenv, or it might be because you forgot to install the package.\n\nThe solution to this error is usually to conda install or pip install the package and make sure the correct environment is activated. If you’re not using the base environment in conda, you also need to make sure to install Spyder or Jupyter into your environment.\n\nTypeError/ValueError\n\nPython TypeError exceptions happen when an argument is of the wrong type. This happens most commonly when you pass an argument of the wrong type into a function. For instance, a function that works with numbers would raise a TypeError if a string were passed in.\n\nA related exception is the ValueError. This exception happens when an argument is of the correct type, but has an incorrect value. For instance, a function that works only with positive numbers would raise a ValueError if a negative number were passed in.\n\nAttributeError\n\nPython AttributeError exceptions happen when you try to access an attribute of an object when the object does not have that attribute. You will often see this error associated with the message NoneType object has no attribute. This message most likely means that a function has returned None instead of the object you were expecting and you are trying to access an attribute that would be present on the real object, but is not defined for None.\n\nHow to Handle Exceptions in Python\n\nMATLAB allows you to try a statement of code and catch any errors that are thrown by the code. Once you have caught an error, you can do further processing of the error and assign variables based on the type of error. The MATLAB documentation has several good examples of how this would look in MATLAB.\n\nIn Python, one big difference from MATLAB is that you can choose to catch only certain types of exceptions and handle them. This allows all other exceptions to continue to be displayed to the user. If you want to learn more about how to do this in Python, you can read The try and except Block: Handling Exceptions.\n\nTo see how this works, you can try the following example:\n\nPython\n\nIn [1]: import math In [2]: def my_sqrt(number): ...: print(f\"You passed the argument: {number!r}\") ...: try: ...: return math.sqrt(number) ...: except ValueError: ...: print(\"You passed a number that cannot be operated on\") ...: except TypeError: ...: print(\"You passed an argument that was not a number\") ...: In [3]: my_sqrt(4.0) You passed the argument: 4.0 Out[3]: 2.0 In [4]: my_sqrt(-1.0) You passed the argument: -1.0 You passed a number that cannot be operated on In [4]: my_sqrt(\"4.0\") You passed the argument: '4.0' You passed an argument that was not a number\n\nCopied!\n\nIn this code, on input line 1 you are importing the built-in math library. Then, starting on input line 2, you are defining a function called my_sqrt() that will take one argument, called number. Inside the function definition, you first print the argument that the user passed.\n\nNext, you enter the try/except block. First, you try to take the square root of the input argument and return the result. If taking the square root of the argument results in an error, Python will catch that error and check which type of error was raised.\n\nYou have defined code that handles two specific exceptions: ValueError and TypeError. If math.sqrt() raises a ValueError, your code will print a message that the number cannot be operated on. If math.sqrt() raises a TypeError, your code will print a message that the argument was not a number. If any other type of exception is raised by math.sqrt(), that error will be passed through without any processing, since there is no handler for any other error types.\n\nMore specifically, Python checks for any error that is raised by the code in the try block. In your case, you only defined one line of code in the try block, but this is not required, and you can have as many lines as you want there. However, it is usually a good practice to minimize the number of lines of code in the try block so you can be very specific about which code is raising any errors.\n\nOn input line 3, you are testing out my_sqrt(). First, you pass the value 4.0 to the function. The function prints the argument, and math.sqrt() has no problems taking the square root of 4, resulting in 2.0 on the output line.\n\nOn input line 4, you are passing -1.0 as the argument to my_sqrt(). As you may recall, taking the square root of negative numbers results in a complex number, which the math.sqrt() function is not equipped to handle. Taking the square root of a negative number using math.sqrt() raises a ValueError. You exception handler catches this ValueError and prints the message that the number cannot be operated on.\n\nOn input line 5, you are passing \"4.0\" as the argument to my_sqrt(). In this case, math.sqrt() does not know how to take the square root of a string, even though that string appears to represent a number. You can see that you have passed a string by the quotes in the statement giving the value of the argument: You passed the argument: '4.0'. Since math.sqrt() cannot take the square root of a string, it raises a TypeError, and your function prints the message that the argument was not a number.\n\nThere Is an Official Guide to Writing Good Code in Python\n\nThe Python community has developed a set of recommendations for how to style your Python code. These are codified in a document called PEP 8, which stands for Python Enhancement Proposal #8. PEP 8 can be found in full on the Python website. You can also learn more about good Python style in How to Write Beautiful Python Code With PEP 8 and Idiomatic Python 101.\n\nPerhaps the most important principle in PEP 8 is the saying that “a foolish consistency is the hobgoblin of little minds.” This means that you should follow the recommendations in PEP 8 for almost all of your code, but there may be some limited cases where it is a good idea not to follow the PEP 8 recommendations. For instance, if you are working with an existing codebase that has its own style, you should follow that style where it diverges from PEP 8. You can see an excellent discussion of this principle from Raymond Hettinger, one of the core Python developers, in a talk from PyCon 2015.\n\nAside from reading PEP 8, you can use a few Python packages to automatically make sure that your code fits the style guidelines. Flake8 is a code linter that reads your code and makes suggestions for how you can improve it. This is similar to the feature in the MATLAB code editor that makes improvement suggestions. In addition, packages such as Black, yapf, and autopep8 will automatically format your code to be compliant with PEP 8 or your own style rules. Using these packages can help your code feel more Pythonic and help you learn good Python style!"
    }
}