{
    "id": "yago_24146_3",
    "rank": 89,
    "data": {
        "url": "https://wiki.octave.org/Differences_between_Octave_and_Matlab",
        "read_more_link": "",
        "language": "en",
        "title": "Differences between Octave and Matlab",
        "top_image": "https://wiki.octave.org/favicon.ico",
        "meta_img": "https://wiki.octave.org/favicon.ico",
        "images": [
            "https://wiki.octave.org/wiki/resources/assets/poweredby_mediawiki_88x31.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "People often ask\n\nI wrote some code for Matlab, and I want to get it running under Octave. Is there anything I should watch out for?\n\nor alternatively\n\nI wrote some code in Octave, and want to share it with Matlab users. Is there anything I should watch out for?\n\nwhich is not quite the same thing. There are still a number of differences between Octave and Matlab, however in general differences between the two are considered as bugs. Octave might consider that the bug is in Matlab and do nothing about it, but generally functionality is almost identical. If you find an important functional difference between Octave behavior and Matlab, then you should send a description of this difference (with code illustrating the difference, if possible) to http://bugs.octave.org.\n\nFurthermore, Octave adds a few syntactical extensions to Matlab that might cause some issues when exchanging files between Matlab and Octave users.\n\nAs both Octave and Matlab are under constant development, the information in this section is subject to change.\n\nYou should also look at the pages http://packages.octave.org and http://octave.sourceforge.net/docs.html that have a function reference that is up to date. You can use this function reference to see the number of octave functions that are available and their Matlab compatibility.\n\nGraphical Curve Fitting Tool[edit]\n\nCurrently, Octave lacks a graphical curve fitting tool such as Matlab's curvefit tool. [1]\n\nYou can use polyfit or the packages signal or optim to achieve these task but these are not graphical tools.\n\nA tool moving closer to the curve fitting toolbox is available for linear regression FitTool.m and for nonlinear regression FitToolNL.m. Find documentation in the file CurveFit.pdf.\n\nNested Functions[edit]\n\nOctave has limited support for nested functions since version 3.8.0. That is\n\nis equivalent to\n\nThe main difference with Matlab is a matter of scope. While nested functions have access to the parent function's scope in Matlab, no such thing is available in Octave, due to how Octave essentially “un-nests” nested functions.\n\nThe authors of Octave consider the nested function scoping rules of Matlab to be more problems than they are worth as they introduce difficult to find bugs as inadvertently modifying a variable in a nested function that is also used in the parent is particularly easy for those not attentive to detail.\n\nDifferences in core syntax[edit]\n\nThere are a few core Matlab syntaxes that are not accepted by Octave, these being\n\nSome limitations on the use of function handles. The major difference is related to nested function scoping rules (as above) and their use with function handles.\n\nSome limitations of variable argument lists on the LHS of an expression, though the most common types are accepted.\n\nMatlab classdef object oriented programming is only partially supported, see classdef for details.\n\nDifferences in core functions[edit]\n\nA large number of the Matlab core functions (i.e. those that are in the core and not a toolbox) are implemented, and certainly all of the commonly used ones. There are a few functions that aren't implemented, usually to do with specific missing Octave functionality (GUI, DLL, Java, ActiveX, DDE, web, and serial functions). Some of the core functions have limitations that aren't in the Matlab version. For example the sprandn function can not force a particular condition number for the matrix like Matlab can. Another example is that testing and the runtests function work differently in Matlab and Octave.\n\nJust-In-Time compiler[edit]\n\nMatlab includes a \"Just-In-Time\" compiler. This compiler allows the acceleration of for-loops in Matlab to almost native performance with certain restrictions. The JIT must know the return type of all functions called in the loops and so you can't include user functions in the loop of JIT optimized loops. Octave has a not fully functional JIT compiler. For this reason you must vectorize your code as much as possible. The MathWorks themselves have a good document discussing vectorization at http://www.mathworks.com/support/tech-notes/1100/1109.html.\n\nCompiler[edit]\n\nOn a related point, there is no Octave compiler, and so you can't convert your Octave code into a binary for additional speed or distribution.\n\nGraphic handles[edit]\n\nThe support for graphics handles is converging towards full compatibility. If you notice any incompatibilities, please report a bug.\n\nGUI functions[edit]\n\nThe support for Matlab compatible GUI functions was added in Octave version 3.6.0 and is converging towards full compatibility. If you notice any incompatibilities, please report a bug.\n\nSimulink[edit]\n\nOctave itself includes no Simulink support. Typically the Simulink models lag research and are less flexible, so shouldn't really be used in a research environment. However, some Matlab users that try to use Octave complain about this lack.\n\nMEX-Files[edit]\n\nOctave includes an API to the Matlab MEX interface. However, as MEX is an API to the internals of Matlab and the internals of Octave differ from Matlab, there is necessarily a manipulation of the data to convert from a MEX interface to the Octave equivalent. This is notable for all complex matrices, where Matlab stores complex arrays as real and imaginary parts, whereas Octave respects the C99/C++ standards of co-locating the real/imag parts in memory. Also due to the way Matlab allows access to the arrays passed through a pointer, the MEX interface might require copies of arrays (even non complex ones).\n\n[edit]\n\nBlock comments denoted by #{ and #} markers (or %{ and %}) are supported by Octave with some limitations. The major limitation is that block comments are not supported within [] or {}.\n\nMat-File format[edit]\n\nThere are some differences in the mat v5 file format accepted by Octave. Matlab recently introduced the \"-V7.3\" save option which is an HDF5 format which is particularly useful for 64-bit platforms where the standard Matlab format can not correctly save variables. Octave accepts HDF5 files, but is not yet compatible with the \"-v7.3\" versions produced by Matlab.\n\nAlthough Octave can load inline function handles saved by Matlab, it can not yet save them.\n\nFinally, some multi-byte Unicode characters aren't yet treated in mat-files.\n\nProfiler[edit]\n\nThanks to Daniel Kraft's 2011 Google Summer of Code project, Octave has a profiler since version 3.6.0.\n\nToolboxes[edit]\n\nOctave is a community project and so the toolboxes that exist are donated by those interested in them through Octave Forge. These might be lacking in certain functionality relative to the Matlab toolboxes, and might not exactly duplicate the Matlab functionality or interface.\n\nShort-circuit & and | operators[edit]\n\nThe & and | operators in Matlab short-circuit when included in a condition (e.g. an if or while statement) and not otherwise. In Octave only the && and || short circuit. Note that this means that\n\nand\n\nhave different semantics in Matlab. This is really a Matlab bug, but there is too much code out there that relies on this behavior to change it. Prefer the && and || operators in if statements if possible.\n\nNote that the difference with Matlab is also significant when either argument is a function with side effects or if the first argument is a scalar and the second argument is an empty matrix. For example, note the difference between\n\nand\n\nIn the latter case, Octave displays since version 4.0.0 a warning:\n\nwarning: Matlab-style short-circuit operation performed for operator |\n\nAnother case that is documented in the Matlab manuals is that\n\nAlso Matlab requires the operands of && and || to be scalar values but Octave does not (it just applies the rule that for an operand to be considered true, every element of the object must be nonzero or logically true).\n\nFinally, note the inconsistence of thinking of the condition of an if statement as being equivalent to all(X(:)) when X is a matrix. This is true for all cases EXCEPT empty matrices:\n\nHowever,\n\nis not the same as\n\nbecause, despite the name, the all is really returning true if none of the elements of the matrix are zero, and since there are no elements, well, none of them are zero. This is an example of vacuous truth. But, somewhere along the line, someone decided that if ([]) should be false. The Mathworks probably thought it just looks wrong to have [] be true in this context even if you can use logical gymnastics to convince yourself that \"all\" the elements of an empty matrix are nonzero. Octave however duplicates this behavior for if statements containing empty matrices.\n\nSolvers for singular, under- and over-determined matrices[edit]\n\nMatlab's solvers as used by the operators mldivide \\ and mrdivide /, use a different approach than Octave's in the case of singular, under-, or over-determined matrices. In the case of a singular matrix, Matlab returns the result given by the LU decomposition, even though the underlying solver has flagged the result as erroneous. Octave has made the choice of falling back to a minimum norm solution of matrices that have been flagged as singular which arguably is a better result for these cases.\n\nIn the case of under- or over-determined matrices, Octave continues to use a minimum norm solution, whereas Matlab uses an approach that is equivalent to\n\nWhile this approach is certainly faster and uses less memory than Octave's minimum norm approach, this approach seems to be inferior in other ways.\n\nA numerical question arises: how big can the null space component become, relative to the minimum-norm solution? Can it be nicely bounded, or can it be arbitrarily big? Consider this example:\n\nwhile Octave's minimum-norm values are about 3e-2, Matlab's results are 50-times larger. For another issue, try this code:\n\nIt shows that unlike in Octave, mldivide in Matlab is not invariant with respect to column permutations. If there are multiple columns of the same norm, permuting columns of the matrix gets you different result than permuting the solution vector. This will surprise many users.\n\nSince the mldivide \\ and mrdivide / operators are often part of a more complex expression, where there is no room to react to warnings or flags, it should prefer intelligence (robustness) to speed, and so the Octave developers are firmly of the opinion that Octave's approach for singular, under- and over-determined matrices is a better choice than Matlab's.\n\nOctave extensions[edit]\n\nThe extensions in Octave over MATLAB syntax are very useful, but might cause issues when sharing with Matlab users. A list of the major extensions that should be avoided to be compatible with Matlab are:\n\nComments in Octave can be marked with #. This allows POSIX systems to have the first line as #! octave -q and mark the script itself executable. MATLAB doesn't have this feature due to the absence of comments starting with #\".\n\nCode blocks like if, for, while, etc can be terminated with block specific terminations like endif. MATLAB doesn't have this and all blocks must be terminated with end.\n\nOctave has a lisp-like unwind_protect block that allows blocks of code that terminate in an error to ensure that the variables that are touched are restored. You can do something similar with try/catch combined with rethrow (lasterror ()) in Matlab, however rethrow and lasterror are only available in Octave 2.9.10 and later. MATLAB 2008a also introduced OnCleanUp that is similar to unwind_protect, except that the object created by this function has to be explicitly cleared in order for the cleanup code to run.\n\nNote that using try/catch combined with rethrow (lasterror ()) cannot guarantee that global variables will be correctly reset, as it won't catch user interrupts with Ctrl-C. For example\n\ncompared to\n\nTyping Ctrl-C in the first case returns the user directly to the prompt, and the variable a is not reset to the saved value. In the second case the variable a is reset correctly. Therefore Matlab gives no safe way of temporarily changing global variables.\n\nIndexing can be applied to all objects in Octave and not just variables. Therefore sin(x)(1:10) for example is perfectly valid in Octave but not Matlab. To do the same in Matlab you must do y = sin(x); y = y([1:10]);\n\nOctave has the operators ++, –-, -=, +=, *=, etc. As MATLAB doesn't, if you are sharing code these should be avoided.\n\nCharacter strings in Octave can be denoted with double or single quotes. There is a subtle difference between the two in that escaped characters like \\n (newline), \\t (tab), etc are interpreted in double quoted strings but not single quoted strings. This difference is important on Windows platforms where the \\ character is used in path names, and so single quoted strings should be used in paths. MATLAB doesn't have double quoted strings and so they should be avoided if the code will be transferred to a MATLAB user.\n\nWhat features are unique to Octave?[edit]\n\nAlthough most of the Octave language will be familiar to Matlab users, it has some unique features of its own.\n\nFunctions defined on the command-line[edit]\n\nFunctions can be defined by entering code on the command line, a feature not supported by Matlab. For example, you may type:\n\nAs a natural extension of this, functions can also be defined in script files (m-files whose first non-comment line isn't function out = foo (...))\n\nNote: MATLAB R2016b added the ability to define functions in script files.\n\n[edit]\n\nThe pound character, #, may be used to start comments, in addition to %. See the previous example. The major advantage of this is that as # is also a comment character for unix script files, any file that starts with a string like #! /usr/bin/octave -q will be treated as an octave script and be executed by octave.\n\nStrings delimited by double quotes \"[edit]\n\nIn 2016, Matlab introduced String Arrays, that are initialized by using double quoted strings, and are not implemented in Octave yet. In Octave double-quoted strings include backslash interpretation (like C++, C, and Perl) while single quoted are uninterpreted (like Matlab and Perl).\n\nLine continuation by backslash[edit]\n\nLines can be continued with a backslash, \\, in addition to three points ... as in Matlab.\n\nInformative block closing[edit]\n\nYou may close function, for, while, if, ... blocks with endfunction, endfor, endwhile, ... keywords in addition to using end. As with Matlab, the end (or endfunction) keyword that marks the end of a function defined in a .m file is optional.\n\nCoherent syntax[edit]\n\nIndexing other things than variables is possible, as in:\n\nIn Matlab, it is for example necessary to assign the intermediate result cos([0 pi pi/4 7]) to a variable before it can be indexed again.\n\nExclamation mark as not operator[edit]\n\nThe exclamation mark ! (aka “Bang!”) is a negation operator, just like the tilde ~:\n\nNote however that Matlab uses the ! operator for shell escapes, for which Octave requires using the system command.\n\nIncrement and decrement operators[edit]\n\nIf you like the ++, += etc operators, rejoice! Octave includes the C-like increment and decrement operators ++ and -- in both their prefix and postfix forms, in addition to +=, -=, *=, /=, ^=,.+=,.-=,.*=, ./= and .^=.\n\nFor example, to pre-increment the variable x, you would write ++x. This would add one to x and then return the new value of x as the result of the expression. It is exactly the same as the expression x = x + 1.\n\nTo post-increment a variable x, you would write x++. This adds one to the variable x, but returns the value that x had prior to incrementing it. For example, if x is equal to 2, the result of the expression x++ is 2, and the new value of x is 3.\n\nFor matrix and vector arguments, the increment and decrement operators work on each element of the operand.\n\nUnwind-protect[edit]\n\nIn addition to try-catch blocks, Octave supports an alternative form of exception handling modeled after the unwind-protect form of Lisp. The general form of an unwind_protect block looks like this:\n\nWhere body and cleanup are both optional and may contain any Octave expressions or commands. The statements in cleanup are guaranteed to be executed regardless of how control exits body.\n\nThe unwind_protect statement is often used to reliably restore the values of global variables that need to be temporarily changed.\n\nMatlab can be made to do something similar with their onCleanup function that was introduced in 2008a. Octave also has onCleanup since version 3.4.0.\n\nBuilt-in ODE and DAE solvers[edit]\n\nOctave includes LSODE, DASSL and DASPK for solving systems of stiff ordinary differential and differential-algebraic equations. These functions are built in to the interpreter.\n\nDo-Until loop structure[edit]\n\nSimilar to the do-while loop in C and C++, Octave allows a do-until loop which does not exist in Matlab:\n\nBroadcasting[edit]\n\nBorrowed from other languages, octave broadcasting allows easy and readable vectorization.\n\nNote: Automatic expansion of dimensions was added to MATLAB R2016b.\n\nDocumentation strings[edit]\n\nOctave allows extensive formatting of the help string of functions using Texinfo. The effect on the online documentation is relatively small, but makes the help string of functions conform to the help of Octave’s own functions. However, the effect on the appearance of printed or online documentation will be greatly improved.\n\nTest functions[edit]\n\nOctave allows to add self-tests to user defined functions. Tests are put after function definition in specially commented block.\n\nSuch a function can be tested for valid outputs by following code:\n\n>> test a PASSES 1 out of 1 test\n\nDemonstration Functions[edit]\n\nExample code block can be part of function file in a similar manner as test functions. For example to run demo for function multinom of package specfun, use:\n\ndemo multinom\n\nPowerful assert[edit]\n\nFunction assert have extended input possibilities.\n\nHow to Programmatically Identify If You're Running Octave[edit]\n\nBecause you may want to write cross-platform compatible code but make use of Octave-specific features when they're available, it may be necessary to programmatically detect the program environment. The following function can be used to detect whether it is being run in Octave. Due to the persistent variable it can be called repeatedly without a heavy performance hit.\n\n%% Return: true if the environment is Octave. %% function retval = isOctave persistent cacheval; % speeds up repeated calls if isempty (cacheval) cacheval = (exist (\"OCTAVE_VERSION\", \"builtin\") > 0); end retval = cacheval; end\n\n[edit]"
    }
}