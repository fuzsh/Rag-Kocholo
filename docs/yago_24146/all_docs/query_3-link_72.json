{
    "id": "yago_24146_3",
    "rank": 72,
    "data": {
        "url": "https://ohiostate.pressbooks.pub/matlab/chapter/chapter-1/",
        "read_more_link": "",
        "language": "en",
        "title": "Calculating and Scripting with MATLAB – MATLAB Programming for Engineering Applications",
        "top_image": "https://ohiostate.pressbooks.pub/app/themes/pressbooks-book/dist/images/favicon-32x32.png",
        "meta_img": "https://ohiostate.pressbooks.pub/app/themes/pressbooks-book/dist/images/favicon-32x32.png",
        "images": [
            "https://ohiostate.pressbooks.pub/app/uploads/sites/233/2020/08/MATLAB_empty_window_capture.png",
            "https://ohiostate.pressbooks.pub/app/uploads/sites/233/2020/08/MATLAB_workspace_capture.png",
            "https://ohiostate.pressbooks.pub/app/uploads/sites/233/2020/08/MATLAB_workspace2_capture.png",
            "https://ohiostate.pressbooks.pub/app/uploads/sites/233/2020/09/newScriptcapture.png",
            "https://ohiostate.pressbooks.pub/app/uploads/sites/233/2020/09/editWindowCapture.png",
            "https://ohiostate.pressbooks.pub/app/uploads/sites/233/2020/09/Leibniz_capture1.png",
            "https://ohiostate.pressbooks.pub/app/uploads/sites/233/2020/09/Leibniz_capture2.png",
            "https://ohiostate.pressbooks.pub/app/uploads/sites/233/2020/09/Leibniz_capture3.png",
            "https://ohiostate.pressbooks.pub/app/uploads/sites/233/2020/09/clear_capture.png",
            "https://ohiostate.pressbooks.pub/app/uploads/sites/233/2020/09/clc_capture.png",
            "https://ohiostate.pressbooks.pub/app/themes/pressbooks-book/assets/images/yt_icon_mono_dark.png"
        ],
        "movies": [
            "about:blank",
            "about:blank",
            "about:blank",
            "about:blank",
            "about:blank",
            "about:blank"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "James Toney",
            "jayakumar5"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://ohiostate.pressbooks.pub/app/themes/pressbooks-book/dist/images/apple-touch-icon.png",
        "meta_site_name": "",
        "canonical_link": "https://ohiostate.pressbooks.pub/matlab/chapter/chapter-1/",
        "text": "1 Calculating and Scripting with MATLAB\n\nThe easiest way to start learning to use MATLAB is through the command line interface. When the MATLAB environment opens, it looks something like this:\n\nFigure 1.1: The MATLAB environment\n\nThe large area in the middle is the command window, where individual lines of MATLAB code can be entered, and the results are displayed.\n\nWhat makes MATLAB especially convenient for newcomers to programming is that it is an “interpreted” language, rather than a “compiled” one, like C or Java. The difference is that a program in a compiled language must be processed in two steps: first it is converted to “machine code”, a low-level representation of the program that can be executed directly by the CPU, then it is executed. An interpreted language, on the other hand, is converted to machine code at the same time that it is run (in a simplified way of looking at it). As an analogy, imagine that you want to understand a speech given in a foreign language that you don’t understand. There are two approaches: you could have the speech translated (compiled) into your native language and read it later, or you could have it interpreted in real time, line-by-line. A C or Java compiler is like a translator, while the MATLAB (or Python) environment is like a simultaneous interpreter.\n\nThe reason that interpreted languages are a bit easier for novices to learn is that they make it possible try code out one line at a time. For example, this line of MATLAB code can be entered at the command prompt, divorced from any other context, and the answer is presented immediately (try it!):\n\n>> seconds_per_year = 365 * 24 * 60 * 60\n\nseconds_per_year =\n\n31536000\n\n>>\n\nThe >> is the command prompt that appears in the MATLAB command window, not something that the user types. The rest of the first line is a MATLAB “instruction”, “statement”, or “command” – the terms are used more-or-less interchangeably – that tells the interpreter to perform a calculation and store the result. The second and third lines are MATLAB’s presentation of the result of the calculation. The * symbol means multiplication, so this statement multiplies 365 (day/year) x 24 (hrs/day) x 60 (minutes/hr) x 60 (seconds / minute). Notice that there is no indication of units in the instruction – MATLAB has no innate understanding of dimensions or units. The result is stored in a “variable” called seconds_per_year – more about this concept in the next section.\n\nThe objective of programming is to arrange a sequence of instructions in advance, then execute them in rapid succession, but we will leave that for a later section.\n\n1.1 Storing Information – Variables\n\nAn advantage of using a computer to perform complex calculations is that it enables breaking the calculation up into steps. The results of each step can be stored for use in subsequent steps. A variable is just a way to refer to a value (or as we will see in the next chapter, set of values) that is stored in computer memory. In the example above, seconds_per_year is the name that is attached to a location in the computer’s memory that stores the value 315360000.\n\nThe whole point of a “variable” is that it can change. Suppose it occurs to you that a year is not really 365 days, but 365 1/4 days. You can re-do the calculation above and get an updated result:\n\n>> seconds_per_year = 365.25 * 24 * 60 * 60\n\nseconds_per_year =\n\n31557600\n\nThe value of the variable seconds_per_year has been changed, but it still refers to the same location in the computer’s memory. The previous value that was stored there has been overwritten – it is no longer in the computer’s memory.\n\nA statement like this that has a variable name followed by an equals sign (=) and an expression (which could simply be a number) is called an assignment statement. It means, “store the value of the expression on the right of the = in the variable given on the left.” Unlike in mathematics, it is not a statement that the two things are equal – it is an operation that makes the variable equal to the given expression. Beginning programmers are often confused by a statement like this:\n\n>> x = x + 1\n\nHow can x be equal to x + 1? Mathematically, it cannot. What this statement is doing is taking the current value of x (based on whatever operations were performed previously), adding 1 to it, and storing that back in the variable x.\n\nThe current value of a variable can be examined two ways. First, if the name of the variable is typed at the command line, MATLAB displays its value:\n\n>> seconds_per_year\n\nseconds_per_year =\n\n31557600\n\nSecond, the variable can be examined in the “workspace”, which is the area in the right of Figure 1.1. After the revised calculation is performed, it appears like this:\n\nFigure 1.2: Seeing the value of a variable in the workspace\n\nOn the right, all variables stored in memory are listed with their current values.\n\nThe purpose of storing values in memory is so that they can be used in subsequent steps of a calculation. To illustrate the point, suppose that you want to calculate the speed of light in miles per year, given that you know its value in S.I, units (299,792,458 m/s). You could first calculate the number of meters in a mile, given that 1 mile = 5280 feet, and 3.28 feet = 1 meter:\n\n>> meters_per_mile = 5280/3.28\n\nmeters_per_mile =\n\n1.6098e+03\n\nNotice that the result was displayed in scientific (or exponential notation). e+03 means “times 10 to the 3rd power.”\n\nNext, the results from the two previous steps can be used to calculate the end result:\n\n>> c_miles_per_year = 2.99792458e8 * seconds_per_year / meters_per_mile\n\nc_miles_per_year =\n\n5.8771e+12\n\nHere the division operator (/) has been used. Once this series of calculation has been performed, the workspace window looks like this:\n\nFigure 1.3: A list of variables in the workspace\n\n1.1.1 Valid Variable Names\n\nThe rules for variable names are:\n\ncan be 1 to 63 characters long\n\ncan contain letters, numbers, and the underscore (_), but no other special characters\n\nmust begin with a letter\n\nletters can be upper or lowercase, but variable name is case sensitive – for example, avg_score is a different variable name than Avg_score.\n\nVariable names should be chosen to help a reader of the program understand what the program is doing. For instance, a variable storing the number of students could be called num_students, numberOfStudents, etc., but it should not be called N, which does not indicate what the variable represents.\n\nUnderscores are often used as separators to make multi-word variable names easier to read. For example, average_score is preferable to averagescore. Another convention that many programmers use is capitalizing every word but the first, e.g. averageScore or finalExamScore. (It is legal to capitalize the first word as well, but the convention is not to do so.)\n\n1.2 Performing Arithmetic Calculations\n\nTwo of the basic arithmetic operators (* and /) have been demonstrated in previous examples. The remaining operators are:\n\n+ addition\n\n- subtraction\n\n^ exponentiation (raising to a power)\n\nParentheses can be used to group terms as needed. The standard rules for order of operation apply:\n\nparentheses\n\nexponentiation\n\nmultiplication & division\n\naddition & subtraction\n\nWhen there are multiple operations of equal precedence, they are performed from left to right.\n\n1.3 Performing Calculations Using Built-in Functions\n\nThere are many routine calculations in engineering that require special functions – e.g. trigonometric functions, logarithms, statistics, etc. MATLAB has functions to perform these operations built-in.\n\nTo use a built-in function, the name of the function is given, with its argument (the value on which it is operating) enclosed in parentheses. For example:\n\nHere sqrt ( ) is the MATLAB built-in function that calculates the square root. The argument does not have to be a simple number – it can be a complex expression or a variable, as well. For example, a two-line sequence to calculate the sine of 30 degrees could be:\n\nSome of the most commonly used built-in functions are listed in the table below.\n\nTable 1.1: Common Built-in Functions\n\nOne of the problems in the previous checkpoint question actually produces a surprising answer when executed in MATLAB. Try this:\n\n>> sin (pi)\n\nDid you get the answer you expected? Think about why that may be.\n\n1.4 Beyond the Command Line – Scripting\n\nThe transition from using MATLAB to programming in MATLAB occurs when you move away from the command line and begin assembling sequences of instructions using the editor. The simplest kinds of programs, involving a linear sequence of operations in a single file, are sometimes called “scripts.” There is no rigid distinction between “script” and “program”; generally, any program that does not use user-defined functions (discussed beginning in Chapter 4) may be thought of as a script.\n\nTo open the editor, click the New Script button in the upper left on the home tab:\n\nFigure 1.3: Creating a new script\n\nThis will open the editor window:\n\nFigure 1.4: The editor window\n\nAny sequence of MATLAB instructions can be entered in the editor and saved for later execution.\n\nAs an example, consider calculating successive approximations of [latex]\\pi[/latex] based on the Leibniz formula:\n\n[latex]\\pi = 4 (1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} +\\frac{1}{9} + ...)[/latex]\n\nSuppose we want to calculate the first nine approximations to get an idea of how fast this series converges. The most simplistic way of performing the calculations, using the limited set of MATLAB capabilities that we have introduced so far, is this:\n\nThe first line, beginning with a %, is a comment. It performs no function in the program; it is only there to document the program, so that a person reading the code will understand what it does.\n\nAfter these lines are entered in the editor, the file must be saved under a suitable name. A MATLAB code file has the extension .m, so a suitable name for this file might be Leibniz_pi.m. WARNING: MATLAB file names can only contain letters, numbers and underscores, just like variable names. Never put a blank space in a file name. Once the file has been saved it can be execute by clicking the Run button (the green arrow in the middle at the top) or by typing the filename at the command prompt. The result of each operation will be displayed to the command window. Here the windows have been rearranged so that the editor and command windows are side-by-side for better visibility.\n\nFigure 1.5: A simple script\n\nYou can see that this power series is not a very good one – it converges quite slowly.\n\n1.5 Displaying Output\n\nIn all of the examples so far, the result of each calculation step was “echoed” to the command window. In most programs that behavior is not desired; it is better to only display the final result. To suppress the output from a calculation step (prevent it from appearing in the command window), terminate the line with a semi-colon. The previous example could be modified so that only the last result is displayed:\n\nFigure 1.6: Suppressing output using semi-colons\n\n1.5.1 Using disp() to control output\n\nAn even better option is to terminate every line with a semi-colon and use the disp() function (or fprintf(), which is introduced in Chapter 3) to control what is displayed to the command window. disp() takes as an argument either a string in quotes (what computer scientists call a ‘literal’) or a variable name. Text in quotes will be displayed exactly as it is; if a variable name is provided, the value of that variable will be displayed. Use of disp() to display the results of the Leibniz_pi script is shown below.\n\nFigure 1.7: Using the disp() function\n\nImproved disp() Functionality\n\nThe latest versions of MATLAB allow text and numerical values to be displayed on a single line as follows:\n\n>> disp (\"The ninth approximation of pi from the Leibniz formula is \" + pi9)\n\nThe ninth approximation of pi from the Leibniz formula is 3.2524\n\n>>\n\nThe + is a short-cut method for concatenating strings. The number, pi9, is automatically converted to text and appended to the string in quotes.\n\nImportant syntax notes: to combine text & numerical output using this method, the text must be enclosed in double-quotes (“) not single-quotes (‘). The reason for this distinction is explained in Chapter 2. Also, the items (text and numbers) are combined using a +, not a comma.\n\n1.5.2 clear and clc\n\nTwo commands that are often placed at the beginning of a MATLAB script are clear and clc. It is important to understand the difference between them. clc simply clears the command window – like erasing a white board. clear, on the other hand, erases everything from the workspace – that is, it deletes all of the stored variables from the computer’s memory. It should be used with caution, and never in the middle of a program unless you are sure that you want to throw away all previous results. This is how the previous MATLAB environment appears after executing clear and then clc:\n\nFigure 1.8: The clc and clear commands\n\nFor this initial example, it was important to show where in the MATLAB environment the code and output appear using screenshots, but that is not practical for more complex examples. In subsequent chapters, code snippets will be displayed in simple text boxes. Longer code examples with output will be presented as downloadable pdf files like this:\n\n1.6 Problems\n\n[latex]\\sigma_n = \\frac{\\sigma_x + \\sigma_y}{2} + \\frac{\\sigma_x - \\sigma_y}{2}cos (2\\theta) + \\tau_{xy} sin(2\\theta)\\\\[/latex]\n\n[latex]\\tau_{nt} = -\\frac{\\sigma_x - \\sigma_y}{2}sin(2\\theta) + \\tau_{xy}cos(2\\theta)[/latex]\n\n[latex]\\\\ \\\\[/latex]\n\nVerify your calculation with the following values;[latex]\\\\ \\\\[/latex]\n\nGiven: [latex]\\sigma_x=-110.3, \\sigma_y=18.2, \\tau_{xy} = 51.195, \\theta=33.0^o[/latex]\n\nResult: [latex]\\sigma_n=-25.4, \\tau_{nt} = 79.5[/latex]\n\n[latex]\\\\ \\\\[/latex]\n\n2. Calculate the gravitational force between the Earth and the Sun using Newton’s universal law of gravitation:[latex]\\\\ \\\\[/latex]\n\n[latex]F_{es} = \\frac{G M_e M_s}{r_{es}^2}[/latex]\n\n[latex]\\\\ \\\\[/latex]\n\nValues for the masses, universal gravitation constant, and mean Earth-Sun distance can be found online. The result should be [latex]3.5\\times10^{22}\\ N[/latex]\n\n[latex]\\\\ \\\\[/latex]\n\n3. The decibel scale is a logarithmic scale that is widely used in electromagnetics and acoustics. In acoustics, the relationship between the sound intensity in [latex]W/cm^2[/latex] and the sound pressure level in decibels (dB) is\n\n[latex]\\\\ \\\\[/latex]\n\n[latex]dB\\: SPL = 10\\; log_{10} ({\\frac{I}{I_r}})[/latex]\n\nwhere [latex]I_r[/latex] is a standard reference level = [latex]10^{-12}\\ W/cm^2[/latex]"
    }
}