{
    "id": "wrong_mix_property_foundationPlace_00128_3",
    "rank": 34,
    "data": {
        "url": "https://github.com/nokia/OWASP-CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md",
        "read_more_link": "",
        "language": "en",
        "title": "OWASP-CheatSheetSeries/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md at master · nokia/OWASP-CheatSheetSeries",
        "top_image": "https://opengraph.githubassets.com/68bf4b6ebab92665fff9f530c94b26e90532d2728bf90ca6f6dfa17232529b13/nokia/OWASP-CheatSheetSeries",
        "meta_img": "https://opengraph.githubassets.com/68bf4b6ebab92665fff9f530c94b26e90532d2728bf90ca6f6dfa17232529b13/nokia/OWASP-CheatSheetSeries",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "The OWASP Cheat Sheet Series was created to provide a concise collection of high value information on specific application security topics. - OWASP-CheatSheetSeries/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md at master · nokia/OWASP-CheatSheetSeries",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/nokia/OWASP-CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md",
        "text": "This article provides a simple positive model for preventing XSS using output encoding properly. While there are a huge number of XSS attack vectors, following a few simple rules can completely defend against this serious attack.\n\nThis article does not explore the technical or business impact of XSS. Suffice it to say that it can lead to an attacker gaining the ability to do anything a victim can do through their browser.\n\nBoth reflected and stored XSS can be addressed by performing the appropriate validation and encoding on the server-side. DOM Based XSS can be addressed with a special subset of rules described in the DOM based XSS Prevention Cheat Sheet.\n\nFor a cheatsheet on the attack vectors related to XSS, please refer to the XSS Filter Evasion Cheat Sheet. More background on browser security and the various browsers can be found in the Browser Security Handbook.\n\nBefore reading this cheatsheet, it is important to have a fundamental understanding of Injection Theory.\n\nThis article treats an HTML page like a template, with slots where a developer is allowed to put untrusted data. These slots cover the vast majority of the common places where a developer might want to put untrusted data. Putting untrusted data in other places in the HTML is not allowed. This is an \"allow list\" model, that denies everything that is not specifically allowed.\n\nGiven the way browsers parse HTML, each of the different types of slots has slightly different security rules. When you put untrusted data into these slots, you need to take certain steps to make sure that the data does not break out of that slot into a context that allows code execution. In a way, this approach treats an HTML document like a parameterized database query - the data is kept in specific places and is isolated from code contexts with encoding.\n\nThis document sets out the most common types of slots and the rules for putting untrusted data into them safely. Based on the various specifications, known XSS vectors, and a great deal of manual testing with all the popular browsers, we have determined that the rules proposed here are safe.\n\nThe slots are defined and a few examples of each are provided. Developers SHOULD NOT put data into any other slots without a very careful analysis to ensure that what they are doing is safe. Browser parsing is extremely tricky and many innocuous looking characters can be significant in the right context.\n\nHTML entity encoding is okay for untrusted data that you put in the body of the HTML document, such as inside a <div> tag. It even sort of works for untrusted data that goes into attributes, particularly if you're religious about using quotes around your attributes. But HTML entity encoding doesn't work if you're putting untrusted data inside a <script> tag anywhere, or an event handler attribute like onmouseover, or inside CSS, or in a URL. So even if you use an HTML entity encoding method everywhere, you are still most likely vulnerable to XSS. You MUST use the encode syntax for the part of the HTML document you're putting untrusted data into. That's what the rules below are all about.\n\nWriting these encoders is not tremendously difficult, but there are quite a few hidden pitfalls. For example, you might be tempted to use some of the escaping shortcuts like \\\" in JavaScript. However, these values are dangerous and may be misinterpreted by the nested parsers in the browser. You might also forget to escape the escape character, which attackers can use to neutralize your attempts to be safe. OWASP recommends using a security-focused encoding library to make sure these rules are properly implemented.\n\nMicrosoft provides a System.Web.Security.AntiXss.AntiXssEncoder Class for .NET 4.5 to 4.8, and ASP.Net Core has a few (limited) built-in features. ASP.NET 2.0 Framework has built-in ValidateRequest function that provides limited sanitization.\n\nThe OWASP Java Encoder Project provides a high-performance encoding library for Java.\n\nThe following rules are intended to prevent all XSS in your application. While these rules do not allow absolute freedom in putting untrusted data into an HTML document, they should cover the vast majority of common use cases. You do not have to allow all the rules in your organization. Many organizations may find that allowing only Rule #1 and Rule #2 are sufficient for their needs. Please add a note to the discussion page if there is an additional context that is often required and can be secured with encoding.\n\nDo NOT simply encode/escape the list of example characters provided in the various rules. It is NOT sufficient to encode/escape only that list. Block list approaches are quite fragile. The allow list rules here have been carefully designed to provide protection even against future vulnerabilities introduced by browser changes.\n\nThe first rule is to deny all - don't put untrusted data into your HTML document unless it is within one of the slots defined in Rule #1 through Rule #5. The reason for Rule #0 is that there are so many strange contexts within HTML that the list of encoding rules gets very complicated. We can't think of any good reason to put untrusted data in these contexts. This includes \"nested contexts\" like a URL inside a JavaScript -- the encoding rules for those locations are tricky and dangerous.\n\nIf you insist on putting untrusted data into nested contexts, please do a lot of cross-browser testing and let us know what you find out.\n\nDirectly in a script:\n\nInside an HTML comment:\n\nIn an attribute name:\n\nIn a tag name:\n\nDirectly in CSS:\n\nMost importantly, never accept actual JavaScript code from an untrusted source and then run it. For example, a parameter named \"callback\" that contains a JavaScript code snippet. No amount of encoding/escaping can fix that.\n\nRule #1 is for when you want to put untrusted data directly into the HTML body somewhere. This includes inside normal tags like div, p, b, td, etc. Most web frameworks have a method for HTML encoding/escaping for the characters detailed below. However, this is absolutely not sufficient for other HTML contexts. You need to implement the other rules detailed here as well.\n\nEncode the following characters with HTML entity encoding to prevent switching into any execution context, such as script, style, or event handlers. Using hex entities is recommended in the spec. The 5 characters significant in XML (&, <, >, \", '):\n\nRule #2 is for putting untrusted data into HTML attribute values like width, name, value, etc.\n\nFor example:\n\nAlways quote dynamic attributes with \" or '. Quoted attributes can only be broken out of with the corresponding quote, while unquoted attributes can be broken out of with many characters, including [space] % * + , - / ; < = > ^ and |.\n\nEncode the corresponding quote: \" and ' should be encoded to &#x22 and &#x27 respectively.\n\nSome attributes can be used for attack event with encoding and should not be dynamic, or with extra care\n\nhref can be used to inject JavaScript with javascript pseudo protocol (e.g. href=\"javascript:attack())\n\nall event handlers (onclick, onerror, onmouseover, ...) can be used to inject JavaScript\n\nsrc can also be used to inject external scripts depending on the context (e.g. in a script tag)\n\nstyle can be exploited, see rule 4.\n\nRule #3 concerns dynamically generated JavaScript code - both script blocks and event-handler attributes. The only safe place to put untrusted data into this code is inside a quoted \"data value.\" Including untrusted data inside any other JavaScript context is quite dangerous, as it is extremely easy to switch into an execution context with characters including (but not limited to) semi-colon, equals, space, plus, and many more, so use with caution.\n\nInside a quoted string:\n\nOne side of a quoted expression:\n\nInside quoted event handler:\n\nPlease note there are some JavaScript functions that can never safely use untrusted data as input - EVEN IF JAVASCRIPT ENCODED!\n\nFor example:\n\nExcept for alphanumeric characters, encode all characters less than 256 with the \\xHH format to prevent switching out of the data value into the script context or into another attribute. DO NOT use any escaping shortcuts like \\\" because the quote character may be matched by the HTML attribute parser which runs first. These escaping shortcuts are also susceptible to escape-the-escape attacks where the attacker sends \\\" and the vulnerable code turns that into \\\\\" which enables the quote.\n\nIf an event handler is properly quoted, breaking out requires the corresponding quote. However, we have intentionally made this rule quite broad because event handler attributes are often left unquoted. Unquoted attributes can be broken out of with many characters including [space] % * + , - / ; < = > ^ and |.\n\nAlso, a </script> closing tag will close a script block even though it is inside a quoted string because the HTML parser runs before the JavaScript parser. Please note this is an aggressive encoding policy that over-encodes. If there is a guarantee that proper quoting is accomplished then a much smaller character set is needed. Please look at the OWASP Java Encoder JavaScript encoding examples for examples of proper JavaScript use that requires minimal encoding.\n\nIn a Web 2.0 world, the need for having data dynamically generated by an application in a JavaScript context is common. One strategy is to make an AJAX call to get the values, but this isn't always performant. Often, an initial block of JSON is loaded into the page to act as a single place to store multiple values. This data is tricky, though not impossible, to encode/escape correctly without breaking the format and content of the values.\n\nEnsure returned Content-Type header is application/json and not text/html. This shall instruct the browser not misunderstand the context and execute injected script\n\nBad HTTP response:\n\nGood HTTP response:\n\nA common anti-pattern one would see:\n\nA safe JSON serializer will allow developers to serialize JSON as string of literal JavaScript which can be embedded in an HTML in the contents of the <script> tag. HTML characters and JavaScript line terminators need be encoded. Consider the Yahoo JavaScript Serializer for this task.\n\nThis technique has the advantage that HTML entity encoding is widely supported and helps separate data from server side code without crossing any context boundaries. Consider placing the JSON block on the page as a normal element and then parsing the innerHTML to get the contents. The JavaScript that reads the span can live in an external file, thus making the implementation of CSP enforcement easier.\n\nAn alternative to encoding and decoding JSON directly in JavaScript, is to normalize JSON server-side by converting < to \\u003c before delivering it to the browser.\n\nRULE #4 - CSS Encode And Strictly Validate Before Inserting Untrusted Data into HTML Style Property Values\n\nRule #4 is for when you want to put untrusted data into a style sheet or a style tag. CSS is surprisingly powerful, and can be used for numerous attacks. Therefore, it's important that you only use untrusted data in a property value and not into other places in style data. You should stay away from putting untrusted data into complex properties like url, behavior, and custom (-moz-binding).\n\nYou should also not put untrusted data into IE's expression property value which allows JavaScript.\n\nProperty value:\n\nPlease note there are some CSS contexts that can never safely use untrusted data as input - EVEN IF PROPERLY CSS ENCODED! You will have to ensure that URLs only start with http not javascript and that properties never start with \"expression\".\n\nFor example:\n\nExcept for alphanumeric characters, encode all characters with ASCII values less than 256 with the \\HH encoding format. DO NOT use any escaping shortcuts like \\\" because the quote character may be matched by the HTML attribute parser which runs first. These escaping shortcuts are also susceptible to escape-the-escape attacks where the attacker sends \\\" and the vulnerable code turns that into \\\\\" which enables the quote.\n\nIf attribute is quoted, breaking out requires the corresponding quote. All attributes should be quoted but your encoding should be strong enough to prevent XSS when untrusted data is placed in unquoted contexts.\n\nUnquoted attributes can be broken out of with many characters including [space] % * + , - / ; < = > ^ and |.\n\nAlso, the </style> tag will close the style block even though it is inside a quoted string because the HTML parser runs before the JavaScript parser. Please note that we recommend aggressive CSS encoding and validation to prevent XSS attacks for both quoted and unquoted attributes.\n\nRule #5 is for when you want to put untrusted data into HTTP GET parameter value.\n\nExcept for alphanumeric characters, encode all characters with ASCII values less than 256 with the %HH encoding format. Including untrusted data in data: URLs should not be allowed as there is no good way to disable attacks with encoding/escaping to prevent switching out of the URL.\n\nAll attributes should be quoted. Unquoted attributes can be broken out of with many characters including [space] % * + , - / ; < = > ^ and |. Note that entity encoding is useless in this context.\n\nWARNING: Do not encode complete or relative URLs with URL encoding! If untrusted input is meant to be placed into href, src or other URL-based attributes, it should be validated to make sure it does not point to an unexpected protocol, especially javascript links. URLs should then be encoded based on the context of display like any other piece of data. For example, user driven URLs in HREF links should be attribute encoded.\n\nFor example:\n\nIf your application handles markup -- untrusted input that is supposed to contain HTML -- it can be very difficult to validate. Encoding is also difficult, since it would break all the tags that are supposed to be in the input. Therefore, you need a library that can parse and clean HTML formatted text. There are several available at OWASP that are simple to use:\n\nHtmlSanitizer\n\nAn open-source .Net library. The HTML is cleaned with an \"allow list\" approach. All allowed tags and attributes can be configured. The library is unit tested with the OWASP XSS Filter Evasion Cheat Sheet\n\nOWASP Java HTML Sanitizer\n\nFor more information on OWASP Java HTML Sanitizer policy construction, see here.\n\nRuby on Rails SanitizeHelper\n\nThe SanitizeHelper module provides a set of methods for scrubbing text of undesired HTML elements.\n\nOther libraries that provide HTML Sanitization include:\n\nHTML sanitizer from Google Closure Library (JavaScript/Node.js, docs)\n\nDOMPurify (JavaScript, requires jsdom for Node.js)\n\nPHP HTML Purifier\n\nPython Bleach\n\nUntrusted URLs that include the protocol javascript: will execute JavaScript code when used in URL DOM locations such as anchor tag HREF attributes or iFrame src locations. Be sure to validate all untrusted URLs to ensure they only contain safe schemes such as HTTPS.\n\nFor details on what DOM-based XSS is, and defenses against this type of XSS flaw, please see the OWASP article on DOM based XSS Prevention Cheat Sheet.\n\nPreventing all XSS flaws in an application is hard, as you can see. To help mitigate the impact of an XSS flaw on your site, OWASP also recommends you set the HTTPOnly flag on your session cookie and any custom cookies you have that are not accessed by any JavaScript you wrote. This cookie flag is typically on by default in .NET apps, but in other languages you have to set it manually. For more details on the HTTPOnly cookie flag, including what it does, and how to use it, see the OWASP article on HTTPOnly.\n\nThere is another good complex solution to mitigate the impact of an XSS flaw called Content Security Policy. It's a browser side mechanism which allows you to create source allow lists for client side resources of your web application, e.g. JavaScript, CSS, images, etc. CSP via special HTTP header instructs the browser to only execute or render resources from those sources.\n\nFor example this CSP:\n\nWill instruct web browser to load all resources only from the page's origin and JavaScript source code files additionally from static.domain.tld. For more details on Content Security Policy, including what it does, and how to use it, see this article on Content Security Policy.\n\nMany web application frameworks provide automatic contextual escaping functionality such as AngularJS strict contextual escaping and Go Templates. Use these technologies when you can.\n\nModern JavaScript frameworks have pretty good XSS protection built in. Usually framework API allows bypassing that protection in order to render unescaped HTML or include executable code.\n\nThe following API methods and props in the table below are considered dangerous and by using them you are potentially exposing your users to an XSS vulnerability. If you really have to use them remember that now all the data must be sanitized by yourself.\n\nJavaScript framework Dangerous methods / props Angular (2+) bypassSecurityTrust React dangerouslySetInnerHTML Svelte {@html ...} Vue (2+) v-html\n\nAvoid template injection in Angular by building with --prod parameter (ng build --prod).\n\nAlso remember to keep your framework updated to the latest version with all possible bugfixes.\n\nThe X-XSS-Protection header has been deprecated by modern browsers and its use can introduce additional security issues on the client side. As such, it is recommended to set the header as X-XSS-Protection: 0 in order to disable the XSS Auditor, and not allow it to take the default behavior of the browser handling the response. Check the below references for a better understanding on this topic:\n\nGoogle Chrome’s XSS Auditor goes back to filter mode\n\nChrome removed the XSS Auditor\n\nFirefox does not implement the XSSAuditor\n\nEdge retired their XSS filter\n\nOWASP ZAP deprecated the scan for the header\n\nSecurityHeaders.com no longer scans for the header\n\nThe following snippets of HTML demonstrate how to safely render untrusted data in a variety of different contexts.\n\nData Type Context Code Sample Defense String HTML Body <span>UNTRUSTED DATA </span> HTML Entity Encoding (rule #1). String Safe HTML Attributes <input type=\"text\" name=\"fname\" value=\"UNTRUSTED DATA \"> Aggressive HTML Entity Encoding (rule #2), Only place untrusted data into a list of safe attributes (listed below), Strictly validate unsafe attributes such as background, ID and name. String GET Parameter <a href=\"/site/search?value=UNTRUSTED DATA \">clickme</a> URL Encoding (rule #5). String Untrusted URL in a SRC or HREF attribute <a href=\"UNTRUSTED URL \">clickme</a> <iframe src=\"UNTRUSTED URL \" /> Canonicalize input, URL Validation, Safe URL verification, Allow-list http and HTTPS URLs only (Avoid the JavaScript Protocol to Open a new Window), Attribute encoder. String CSS Value html <div style=\"width: UNTRUSTED DATA ;\">Selection</div> Strict structural validation (rule #4), CSS Hex encoding, Good design of CSS Features. String JavaScript Variable <script>var currentValue='UNTRUSTED DATA ';</script> <script>someFunction('UNTRUSTED DATA ');</script> Ensure JavaScript variables are quoted, JavaScript Hex Encoding, JavaScript Unicode Encoding, Avoid backslash encoding (\\\" or \\' or \\\\). HTML HTML Body <div>UNTRUSTED HTML</div> HTML Validation (JSoup, AntiSamy, HTML Sanitizer...). String DOM XSS <script>document.write(\"UNTRUSTED INPUT: \" + document.location.hash );<script/> DOM based XSS Prevention Cheat Sheet\n\nSafe HTML Attributes include: align, alink, alt, bgcolor, border, cellpadding, cellspacing, class, color, cols, colspan, coords, dir, face, height, hspace, ismap, lang, marginheight, marginwidth, multiple, nohref, noresize, noshade, nowrap, ref, rel, rev, rows, rowspan, scrolling, shape, span, summary, tabindex, title, usemap, valign, value, vlink, vspace, width.\n\nThe purpose of output encoding (as it relates to Cross Site Scripting) is to convert untrusted input into a safe form where the input is displayed as data to the user without executing as code in the browser. The following charts details a list of critical output encoding methods needed to stop Cross Site Scripting.\n\nEncoding Type Encoding Mechanism HTML Entity Encoding Convert & to &amp;, Convert < to &lt;, Convert > to &gt;, Convert \" to &quot;, Convert ' to &#x27;, Convert / to &#x2F; HTML Attribute Encoding Except for alphanumeric characters, encode all characters with the HTML Entity &#xHH; format, including spaces. (HH = Hex Value) URL Encoding Standard percent encoding, see here. URL encoding should only be used to encode parameter values, not the entire URL or path fragments of a URL. JavaScript Encoding Except for alphanumeric characters, encode all characters with the \\uXXXX unicode encoding format (X = Integer). CSS Hex Encoding CSS encoding supports \\XX and \\XXXXXX. Using a two character encode can cause problems if the next character continues the encode sequence. There are two solutions (a) Add a space after the CSS encode (will be ignored by the CSS parser) (b) use the full amount of CSS encoding possible by zero padding the value.\n\nRelated Articles\n\nXSS Attack Cheat Sheet:\n\nThe following article describes how to exploit different kinds of XSS Vulnerabilities that this article was created to help you avoid:\n\nOWASP: XSS Filter Evasion Cheat Sheet.\n\nDescription of XSS Vulnerabilities:\n\nOWASP article on XSS Vulnerabilities.\n\nDiscussion on the Types of XSS Vulnerabilities:\n\nTypes of Cross-Site Scripting.\n\nHow to Review Code for Cross-site scripting Vulnerabilities:\n\nOWASP Code Review Guide article on Reviewing Code for Cross-site scripting Vulnerabilities.\n\nHow to Test for Cross-site scripting Vulnerabilities:"
    }
}