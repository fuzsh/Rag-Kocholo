{
    "id": "dbpedia_989_3",
    "rank": 85,
    "data": {
        "url": "https://devforum.play.date/t/moving-multiple-potentially-contiguous-sprites/2718",
        "read_more_link": "",
        "language": "en",
        "title": "'moving' multiple potentially contiguous sprites",
        "top_image": "https://devforum-cdn.play.date/original/2X/c/c0b050e7998ebafd5d1721a985b313050be81ce1.png",
        "meta_img": "https://devforum-cdn.play.date/original/2X/c/c0b050e7998ebafd5d1721a985b313050be81ce1.png",
        "images": [
            "https://devforum.play.date/images/emoji/apple/slightly_smiling_face.png?v=12",
            "https://devforum.play.date/user_avatar/devforum.play.date/daverutledge/48/2332_2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Bro-Code (Ryan Beard)",
            "daverutledge (Dave Rutledge)",
            "neven (Neven Mrgan)"
        ],
        "publish_date": "2022-01-24T17:34:24+00:00",
        "summary": "",
        "meta_description": "The crank drives cars forward along the x axis (and backward, but keeping it simple for this example): \na] swap the next tile forward to the car \nb] make the current tile whatever the previous tile was. \nSo far, so good &hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://devforum-cdn.play.date/optimized/1X/36f06e24a77c9f83f9f186e2be83dfd26c07c494_2_32x32.png",
        "meta_site_name": "Playdate Developer Forum",
        "canonical_link": "https://devforum.play.date/t/moving-multiple-potentially-contiguous-sprites/2718",
        "text": "The crank drives cars forward along the x axis (and backward, but keeping it simple for this example):\n\na] swap the next tile forward to the car\n\nb] make the current tile whatever the previous tile was.\n\nSo far, so good with one car.\n\nAnd multiple cars… as long as there is at least one road tile between cars (ie, there are not two cars directly in a row). Here's my simplified code:\n\n[player script] on crank do if event.ra>0 then emit \"drive_forward\" end end\n\n[car script] on drive_forward do next_x = event.x next_x++ // locate the tile in front of the car last_x = event.x last_x-- // locate the tile behind the car lastTile = name last_x,event.y // get that previous tile name tell next_x,event.y to swap \"car\" // move the car up a tile end tell event.x,event.y to swap \"{lastTile}\" // swap in the previous tile where the car was end end\n\nIf it matters, I've got the cars as sprites. (I've got a separate player.)\n\nI think the problem relates to the iteration of the script replacing road tiles all the way up until the lead car in a chain. If that's right, is there a better way to do this? (If that's wrong, what is happening?)\n\nWell, one problem I can see is, that when a car B is directly behind a car A, this part…\n\ntell event.x,event.y to swap \"{lastTile}\" // swap in the previous tile where the car was end\n\n… already moves the car B behind car A. And after the script for car A is finished, there are three cars left: car A, that moved on, the swapped in car B.swap at the old position of car A, and car B, which wasn’t deleted!\n\nAs a little graphic:\n\nBefore: X X B A X X\n\nAfter: X X B B.swap A X X\n\nI’d fix this first and see, if the problem is still there or changed. I guess you could do that by checking, whether the tile behind car A is also a car. If yes, just move car A forward and swap in a street tile.\n\nHi @daverutledge - I have a little experience with complicated swap routines via the endless runner I'm currently porting over from desktop.\n\nWould it make more sense to swap the current car position with the tile in front of the car, rather than locating the tile behind the car's current position? That would limit this to a two tile equation, rather than a three tile equation (like \"leap frog\").\n\nThinking it would be something more along these lines:\n\non drive_forward do next_x = event.x next_x++ // locate the tile in front of the car lastTile = name next_x,event.y // get the name of the tile currently in front of the car tell next_x,event.y to swap \"car\" // move the car up a tile end tell event.x,event.y to swap \"{lastTile}\" // swap in the previous tile where the car was end end\n\nYou'll also want to handle the cases where event.x == 24, but the exact approach will depend on your game design.\n\n@Bro-Code I've now tried both approaches and…I'm even more confused.\n\na) moving forward, the 3-tile approach (my original idea) kills off all but the lead vehicle\n\nb) moving forward, the 2-tile approach (your suggestion) spaces out adjacent vehicles\n\nc) moving backward, everything works great until the wrap-around and then each break in different ways\n\nThe difference between driving forward and backward is making me think this may be a quirk of how 'emit' cycles through sprites. Oh, and to be clear, the wrap-around (backward and forward) works fine when there's only one car in a row.\n\nI created a \"game\" that's my attempt to simplify this case as well as allow me to try multiple variants. I attached the .json here in case anyone's up for seeing if/where I went wrong and/or coming up with another approach. For further simplicity, I've removed the crank aspect, and the A button moves forward and the B button moves back. I recommend loading it, and moving backward one button-press at a time until it breaks. Then trying the same thing moving forward one button-press at a time.\n\nIt's entirely likely I've just coded this terribly and there will be an obvious fix, but I've simplified so much and still can't find any clear error. It's more likely there's just a much easier way to accomplish this. (For complicated reasons, I can't use 'player' for the vehicles.)\n\nHere's the .json, if anyone is up for looking into this, feel free to ask me for more clarification or code.\n\nHello Cars.json.zip (3.0 KB)\n\n@daverutledge I think I cracked the case.\n\nFirst, I completely misunderstood the goal here. I was thinking it was a racing game and you wanted to move the player car in front of the others as the player progressed (static player, moving background). I now see what you're trying to accomplish.\n\nThe sprite recursion moves left to right, so when you are moving vehicles forward, you have to remember where the last car/truck was. Otherwise, if you have a string of multiple cars/trucks, the last one analyzed gets overwritten by a road tile and will be 'lost' in the subsequent iteration.\n\nSimilarly, if you have cars/trucks that are separated by only a single road tile, you can use the last truck's/car's location to know if you need to insert a road tile or not to maintain that single-tile separation.\n\nThere was also a bug when moving backwards if you had a string of cars/trucks together, there was no 'memory' of the first car/truck in the line (x == 0), so by the time you reached x==24 you were swapping in the already replaced tile rather than the original tile at the start of the movement.\n\nThere are a few new variables to track theses, and they need to be reset before each drive_forward and drive_backward routine, but you'll see the corrected code in the truck's script. I reset the car's script back to the three-position model so you can track the changes.\n\nHello Cars_Edit.json.zip (3.1 KB)\n\n@Bro-Code Ah ha! I feel like I was simultaneously very close and a big step away from getting this right. Setting a variable for the x of the last truck makes a lot of sense.\n\nThanks for both the coding help and the thorough explanation.\n\n--\n\nI do have a quirky situation I'm having trouble isolating. If I place a truck on 0,13 and then drive backwards, I get a stream of 4 trucks (rather than the expected 1). I'll have to stew on the code a bit more to see where/why that's happening.\n\nUnfortunately, since the recursion appears to move left to right (from x==0 to x==24), if you start putting the same vehicle on multiple rows (Y values), you'll have to track a unique lastTruckX and lastCarX value for each row, e.g. lastTruckX_0, lastTruckX_1, lastTruckX_2...lastTruckX_24. You'd then have to compare against the event.y value to determine which row you were on and which lastTruckX_# value to use.\n\nAnother approach might be to just iterate through the entire collection of columns/rows and move each one left/right depending on the input command. This would allow you to start from either end of the y-series (0 or 24) based on the direction of movement, and you'd only have to capture the 'first' column tiles for each valid row at the start. This would give you one master movement event that could be run in the room rather than dispersing your code across each vehicle tile.\n\nYet another option could be to use frames to track the tile movement. If you created 3 replica frames for each tile type (road, truck, car), with an FPS of 0, you could let the frame position represent the previous tile type (0 = road, 1 = truck, 2 = car). This gives you a per tile variable to know what it was prior to being changed during the recursive tile forward/backward movement event execution. This actually might be the cleanest solution overall. I'm wrapping up for the night, but can help mock this up in the AM if you're still working it.\n\nFrame as variable is clever! However, in my specific case, I'm already using a unique vehicle sprite in each row. I had been mimicking the script from the first vehicle across my six sprites, so they were using the same lastTruckX variable. It seems like adding a unique variable will be my easiest solution. It’s not a huge deal if I have to copy/paste/tweak for each row.\n\n[edit later] I hesitate to declare victory, but on implementing a lastTruck_# and zeroTruck_# variable in player for each row (and using distinct sprites per row), everything seems to be working on every variation of car spacing I have tried. There's probably some refactoring I can do to simplify, and I may build out a unit test that randomly places cars, drives them back and forth random amounts, and then counts how many remain to be sure, but it's looking good so far.\n\nThanks for all your help here!"
    }
}