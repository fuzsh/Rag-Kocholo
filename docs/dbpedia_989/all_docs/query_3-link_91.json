{
    "id": "dbpedia_989_3",
    "rank": 91,
    "data": {
        "url": "https://tilesandsprites.wordpress.com/",
        "read_more_link": "",
        "language": "en",
        "title": "Tiles and Sprites",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/09/player_sprites.png?w=645",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/06/editor060611.jpg?w=645&h=388",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/06/pig1.jpg?w=645",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/04/editor041711.jpg?w=645&h=387",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/04/editor041011.jpg?w=645&h=387",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/03/ed-auto11.png?w=645",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/03/ed-clips.png?w=645",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/03/ed-tree.png?w=645",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/03/ed-wall.png?w=645",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/02/xbox-4.png?w=645",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/02/xbox-5.png?w=645",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/02/xbox-2-s.png?w=645",
            "https://tilesandsprites.wordpress.com/wp-content/uploads/2011/02/xbox-3-s.png?w=645",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Andy Wood's game development journal",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "Tiles and Sprites",
        "canonical_link": "https://tilesandsprites.wordpress.com/",
        "text": "This post is a follow up to this one.\n\nLast time, I listed the main types of work involved in creating new content for the game. For each one, I gave an overview of the current (probably tedious) workflow, and then sketched my ideal vision for how it should work.\n\nSince then, I’ve implemented a few of the ideas. Here’s an update on the three areas I discussed in the last post:\n\nCreating Maps\n\nI’ve pretty well settled on a consistent, logical way to use layers – time to call it good.\n\nFinished the automatic Wall tool\n\nFinished the automatic Cliff tool\n\nStill have qualms about how to represent vertical objects (trees, poles)\n\nLinking Maps\n\nImplemented exactly the workflow that I described last time. Success!\n\nCreating New Entities\n\nI haven’t done any work on this yet. I expect to work on the first Boss this week (!), which will provide the opportunity.\n\nAnd now I’ll continue with the next three types of work. To review, they are:\n\nCreating new gameplay, both by creating new entities, and by writing additional code\n\nCreating events (scripted sequences), by writing script\n\nManaging story logic (if you completed goal A, make character X say something new), by writing script\n\nCreating New Gameplay\n\nThe current state of things\n\nThe largest component of creating new gameplay is actually creating new entity types, since the entities provide a lot of the mechanics. Do I want destructible weeds that drop items? The weeds and the items are both entities. Do I want some sort of rock-paper-scissors type play between certain player attacks and certain enemies? Well, those enemies, at, least, are entities. So continuing to make it easier to create new entities will also make it easier to create new gameplay. I discussed this topic in the previous post, and nothing has changed since then – I plan to work on this more this week.\n\nThe next big component of gameplay is in the interactions between different entities. How close do you have to be to hit an enemy? Do you take damage from touching an enemy, or does he have to attack? Is this enemy immune to this weapon? These are all interactions between entities, and they can’t be completely modeled just by writing entity code.\n\nI’m actually fairly happy with how entity interaction works currently, after spending a couple of days focusing on it. Conceptually, all the entities are contained in an Entity Manager. The Entity Manager maintains a variety of entity lists. Each list corresponds to a particular type of interaction, or a particular type of action the engine might want to take on entities. An entity can show up in multiple lists. For example, there is one list for entities that can respond to the player tapping the action button while facing them. There is another list for entities that the player can step on. There’s yet another list specifically for enemies.\n\nThe Entity Manager, in turn, is contained within the World, which also contains the Map. Maintaining different lists for specific functions allows the World to efficiently check for interactions between only those entities that can participate in such an interaction. When the World checks to see if the player has stepped on something important, like an event trigger, it only checks those entities that are in the Steppable list.\n\nAdding new types of interactions is pretty easy. First, determine which lists the interacting entities should be placed in. If the interaction calls for a new list, make one, and make sure the right entities get into it. Then, add some code to the World that operates on the appropriate lists, doing the appropriate checks on the entities in those lists.\n\nThe next big component of gameplay is what I will call Game Systems. Game Systems are separate from entities. They involve numbers and rules. They answer questions like: When does the player level up, and what happens when they do? How much damage does this weapon do against this enemy, and is luck involved? What changes when the player collects this powerup?\n\nTo illustrate where Entities end and Game Systems begin, lets look at that last example. Let’s say the player touches a powerup item, which boosts his running speed. The player and the item are both entities, and their individual behavior and animation are the responsibility of the entities. The physical act of touching the item, and the removal of the item from the screen, are entity interaction, handled by the World. The result of that interaction, the increase in running speed, is the domain of Game Systems. (In some places, the line is slightly fuzzy. For example, the game system for powerups does its work in part by interacting with the player entity.)\n\nGame Systems are basically auxiliary code to the World. The World makes queries against the Game Systems to determine certain numbers and outcomes, and the Game Systems can interact with the entities as needed. Most of this is pretty straightforward, and I think I’ve pretty happy with the way it works now. The most important thing here is probably just to continue to keep the code clean.\n\nThe ideal\n\nAs I’ve already said, I’d like it to be much easier to create new entities and give them behaviors. I’m looking forward to working on that soon. I don’t really have any major complaints about entity interactions or game systems. I put a lot of work recently into cleaning up interactions. I may do something similar with game systems as they evolve more.\n\nI will say one thing about a particular kind of entity interaction – hit detection. Detecting whether an enemy has hit you, or whether you’ve hit an enemy, is critical to whether the game feels fair or not. Too unforgiving, and it feels frustrating. Too loose, and it feels too easy and unrealistic. I’ve iterated on this a couple of times already, but I’m not happy with it yet. This is the kind of thing where I’m probably going to have to spend a whole day (at least) doing nothing but tuning the way hit detection works, until it matches what my eyes naturally expect when I see the action on screen. This is especially tricky in a 2.5-dimensional game, where things are basically 2D, but there are also depth cues. Is that enemy really touching me, or is he just standing in front of me and obscuring my sprite a little bit?\n\nCreating Events\n\nThe current state of things\n\nEvents are in transition right now, as I’ve already begun to implement big improvements to that system this week. They began as simple scripts (text files), which are essentially lists of commands, and parameters to the commands. Later, I added simple conditional blocks (IF blocks) to deal with changing conditions in the game.\n\nEvents have both a readable text representation (the script files), and a logical in-memory representation (like a very simple syntax tree) that is directly parsed from the script, and is used by the runtime. I’ve been writing them by editing the script files. At runtime, the script commands generally just trigger certain functions inside the engine. So, creating script consists of inventing new commands, implementing the engine functions that back those commands, and using the commands in new scripts.\n\nThis works tolerably well. The major downside is that it’s all code, and no visualization except for running the actual game to see if the script does the right thing. Lots of commands require coordinates, and the only way I can get these currently is to run the map editor, load the map, mouse over the grid, and write down the coordinates manually. Not efficient!\n\nThe ideal\n\nLately, I’m finding it useful to focus more on the scripts as syntax trees, and less on the text files. As syntax trees, they’re just like any other well-organized data. I can create informative views from them, and more user-friendly ways to edit them than plain text.\n\nWhat I’d like is some view of the scripts that is integrated with the map editor. I want to be able to see the results of the script execution, visually, on the map. I want to be able to mouse over a picture of an NPC and see what they say. I want to be able to place entities (i.e. to enter their coordinates) by clicking on the map. I’d like to be able to step though the script one line at a time, like in a debugger, and see the events unfold.\n\nI’ve already made a lot of progress towards exactly this, and I should be able to finish up this week. So far, I have a view in the editor that shows a tree view of the script on one side, and the map the script takes place in on the other side.\n\nManaging Story Logic\n\nThe current state of things\n\nRight now, the key to managing story logic is flags. There is one big collection of flags, where each flag tells whether some goal in the game has been accomplished yet or not. Script can set these flags in response to those goals being reached, and check the flags to create conditional circumstances. For example, talking to an NPC might trigger a script which set the flag TalkedToNpc1. The script for another map might check this flag, and set another NPC’s conversation to one of two different options, depending on whether the flag is set.\n\nThis simple mechanism allows for quite a bit of interesting game behavior by itself, but it is a nightmare to maintain. I’ve only made a handful of maps, but there are already a half-dozen flags, being set in different scripts, and affecting the behavior of still other scripts. There are clearly way too many places for these flags to hide. It’s hard to verify that the resulting logic is correct, and “water-tight”. The system is functionally complete, but difficult to maintain, and error-prone.\n\nThe ideal\n\nGame logic management is closely related to event management, so I’m looking for the same kinds of integrated, visual solutions. I’d like to be able to see a list of all the flags at a glance, perhaps with comments describing exactly what they mean, and what they affect. I’d like to see a visual representation of the game state that they affect, right on the map, and I’d like to be able to immediately see the changes caused by toggling the flags. And I’d like some easy way to see which events a given flag appears in – where it is set, and where it is checked.\n\nI think all of this can be accomplished within the framework of the event view that I’m currently working on. I already have a view of the script commands, including tree nodes for the conditional branches based on the flags. I have the map integrated into this view, and I intend to incorporate a version of the script interpreter that will update the state of this map. Again, this is reminiscent of a debugger, where you can toggle variables and see the results.\n\nI’m less sure of how to present a master list of flags, in a way that relates them to their appearance in different scripts. For example, if a flag appears in the scripts for two different maps, which map should be showing when I click on that flag? It’s usually clear which map should be shown when I click on a whole script, because most scripts operate within a single map. But when focusing on a specific flag, this could often be ambiguous. Another consideration is that cross-referencing all the flags with all the scripts would require either loading all the scripts in the game into memory at once, or maintaining an index relating the flags to the scripts in which they appear.\n\nSo I have my work cut out for this week. I should be able to address the remaining content-creation issues, namely easier entity creation, and better event and game logic management. I’ll have a chance to refine entity creation when I take on the very exciting challenge of creating the first Boss! And I’ll keep working at better event management as I finish designing and implementing the new integrated Event View in the editor.\n\nLately, I’ve been focused on the overall process of content creation for the game. I think the bulk of the remaining work by far is content, and not code. So I’m very interested in finding ways to streamline content creation up front, in hopes that I can multiply efficiency over the long haul ahead.\n\nI’ve been working on the first few scenarios in the game, and paying attention to what kinds of work are involved, how long it takes to complete certain tasks, and why. Ignoring artwork for now, the main tasks have been:\n\nCreating new maps, using the map editor\n\nLinking maps together, using the map editor\n\nCreating new types of entities (monsters, environmental objects), by writing code\n\nCreating new gameplay, both by creating new entities, and by writing additional code\n\nCreating events (scripted sequences), by writing script\n\nManaging story logic (if you completed goal A, make character X say something new), by writing script\n\nI’m going to analyze each of these tasks in turn, describing the current process given the tools I have now, and imagining my ideal workflow.\n\nCreating Maps\n\nThe current state of things\n\nI’ve created a decent map editor, which I’ve been evolving as I go. I usually start by drawing the ground for the open, walkable parts on the bottom layer. Then I fill in the rest with trees, cliffs, houses or other objects as appropriate. The automated tools come in handy here, especially for trees. Layer management is key – putting certain parts of the map on certain layers just works better, logically. As of now I have a mostly-consistent system that I use to organize layers.\n\nI recently added two new features to the editor that make map creation easier. The first is a project tree, where I can see all the game assets at a glance, and load them for editing just by clicking on them. This makes it much easier to switch between maps in the editor. The second is a new layer UI. There is now a Photoshop-like panel for the layers, making it much easier to visualize the structure of the map. It also allows turning individual layers on and off, as well as making individual layers partly transparent.\n\nThe ideal\n\nI’d like to have a totally settled, consistent system for layering. Although I have settled into usual ways of layering, there’s still some uncertainty. In particular, I’m still not sure of the best way to represent vertical objects like trees and poles. I have a mostly-working approach, but it is very difficult to render the vertical objects and the sprites correctly in back-to-front order. I think it shouldn’t be as tricky as it is, so I’m still interested in finding a better solution. Ideally, layering would be very well defined, not needing very much creative thought for each new map. E.g. – dirt always on this layer, grass always on this layer, trees always on these layers, etc.\n\nThe automated tools are ok, but they could be much better. The tree tool works well, but requires a bit of trial and error to make sure the solid trunks end up defining exactly the desired entry and exit points on the forest maps. The wall tool really only works as a proof of concept – not quite ready for production – and the cliff tool doesn’t work at all yet. It is a very hard problem to have these brushes draw directly into the low-level tile-grid representation. They are really asking for a higher-level representation that recognizes solid regions of high-level object types, e.g. regions of ground-border-by-wall, and regions of ground-bordered-by-cliff. Ideally, all of these tools would allow the user to paint features onto a map without thinking about anything other than placement. Also, the editor would save meta-data about the brush regions alongside the tile grid.\n\nLinking Maps\n\nThe current state of things\n\nMaps need to be linked together in order to form the game world. This includes linking one edge of a map to the edge of the next map, as well as linking doors to interiors (like the insides of houses and caves).\n\nRight now, the UI for doing this in the editor is just plain embarrassing! It involves writing coordinates down manually, and creating both sides of a bi-directional link separately. Ugh. It’s tedious.\n\nThe ideal\n\nThis one is actually pretty simple, and it’s also one of the top reasons for making the project tree, so I will probably fix this very soon. The process should simply be:\n\nclick on map A in the project tree\n\nselect the link tool\n\nuse the link tool to select the origin map cells on map A\n\nclick on map B in the project tree\n\nclick on the upper-left destination cell on map B\n\nAnd that’s it. That should be all the editor needs to know to create a bi-directional link.\n\nI’ve also been wanting to include information about which compass directions the links work in, to make sure the player auto-runs in the right direction while transitioning between maps. But as I sit here thinking about it now, I think I can infer this by which side of the tile the player enters from….\n\nCreating New Entities\n\nThe current state of things\n\nCreating new entity types (monsters, spawners, doors, npcs, etc) entails writing a new class for each type. So the general process is: create a new class, inherit from the appropriate base class (e.g. monsters all inherit from a common Enemy class), specify some required initialization data (e.g. the shape that represents a sprites “base” on the ground), override a few abstract methods, and thoughtfully override a few virtual methods depending on this entity’s specific behavior. The more complex the entity’s behavior, the more new, custom code has to be written.\n\nThe ideal\n\nOverall, this process is not too bad in practice. I can currently create a new monster, for example, in a couple of hours. But it feels a little bit sloppy in places. I think it could be easier, and more well-defined both in terms of reuse of existing behaviors, definition of new behaviors, and interaction between different behaviors.\n\nIdeally, I’d like to be able to define behaviors separately from entities, using a set of common physical concepts (e.g. size, directions), and then create new entities by mixing in behaviors and parameters. Ultimately, this could even allow simplifying all or even just most enemies down to a single class, with variation achieved solely by parameterization and composition of behaviors. I’ve taken a stab at this once before, and decided it was more complicated than it was worth. I’m interested in trying again.\n\nA compromise would be to retain different classes for different entities, and put the effort into making the base classes really well-defined, and better systematizing the reuse of common behaviors and concepts.\n\nTo be continued…\n\nThis post is getting pretty long, so I’ll save the remaining tasks for next time.\n\nIn the last couple of weeks, I’ve started really working on the game proper. I mean, I’ve been editing actual maps that are probably draft versions of what will end up in the final game. (I even scripted the introduction sequence! But that’s another topic.) Anyway, once I started working on real maps, I quickly noticed that it is really, really tedious to put together detailed, layered maps one tile at a time. Even with a spiffy graphical editor, even with the ability to “paint” tiles onto the map with a mouse.\n\nWell, what’s really good at doing tedious, repetitive work? Computers! What I’d like to be able to do is convey the idea of the design I have in mind to the computer, and have it work out the details of tile placement without too much micro-management from me. One way to do this is with more powerful drawing tools in the editor. And one of the perks of using my own custom-built editor is that I can design these tools to match the best workflow I can dream up.\n\nSo here’s what I’ve come up with so far:\n\nAuto Terrain Tiling\n\nIt’s typical to have various types of terrain in a tileset, e.g. dirt, grass, tall grass, water, and so on. And these different types of terrain have interfaces with each other – there’s the edge where dirt meets grass, the edge where grass meets water, etc. A long time ago, I used to struggle with how to make these edges. But now I know that there are certain canonical patterns that make tiling issues much simpler. For example, you can find a lovely chart at the bottom of this post that illustrates a great way to divide up and think about these kinds of edges.\n\nWell, it’s one thing to understand how to make the tiles, but laying down the edges by hand one tile at a time is still going to be extremely tedious! It would be nice to have a brush that lets you just paint the terrain type you want, and automatically places the right edge pieces depending on where it detects corners and straight sections. And that’s exactly the tool I made:\n\n“Clips”\n\nThere are plenty of other situations that involve painstakingly piecing together a bunch of tiles in some repeatable way. Take houses for example. A house is a pretty big object, so it’s made from a lot of tiles arranged in a particular way. When I started working on the first village, I found myself making a lot of mostly similar houses. Very tedious. When you have an assembled object that you’re likely to need several of, it would be nice to be able to remember the tile pattern, so that you can “stamp” out a lot of copies of the pattern. This is basically the same idea as copy and paste, except it needs to be smart about a couple of things, like preserving any layer information, and not including the ground. Also, it would be nice to be able to save this pattern permanently with the tileset, and not just in memory, so you can reuse it another day.\n\nI call the solution I came up with “clips” – because it’s so similar to the clipboard. First, you assemble just the object you want – e.g. a house, or a tree. You do this on a blank map, with no ground underneath. The you select the whole object, and choose a command called Edit > Save As Clip. This saves just your selection to disk, along with layering information, and associates it with the tileset. Now, in addition to selecting tiles to draw with, you can also select any saved clip, and draw with that! If you need variations of an object, you can simply make multiple clips.\n\nTree Tool\n\nTrees are usually made of multiple tiles, and they certainly qualify as objects that need to be repeated a lot. I could already save quite a bit of work by making trees into clips, so that I can place the whole tree at once. But if I have a lot of different trees and a lot of different tilesets, that’s going to turn into a lot of clips. Also, it turns out that trees have their own particular tiling issues, particular when you put a bunch of them together in a stand or forest.\n\nDid you ever struggle with making forest tiles in such a way that it looks like each row of trees is in front of the row above it? I sure did, until my brother told me about a very elegant and ingenious way of using layers! I can tell you how to do it, but you kind of have to try it yourself to understand why it works. This technique assumes that the tileset can have transparency, and that the map can have as many layers as the height of the tree in tiles. Basically, you always place the bottom row of tiles in each tree on layer 1, the next row up on layer 2, the next row up on layer 3, and so on, depending on how tall the tree is. If you do this, then you can magically place rows of trees one behind the other, and the layers all work out correctly. You can make rows of trees from the top to the bottom of the map if you want, and you still only need as many layers as a single tree is tall. Maybe an illustration will help:\n\nRather than using clips for this, I decided to make a tool for drawing trees (and any other vertical objects that have a base, and occlude things behind them). It automatically does the correct layer placement described here – so the bottom row of selected tiles goes on layer 1, the next row up on layer 2, etc. Also, if you “paint” with it, it automatically staggers the selected object in a typical tree pattern (like bricks)! This is a HUGE time saver for tiling trees and forests, and is also handy for rocks, poles, pillars, and things like that.\n\nAuto Wall Tiling\n\nThe next thing I found extremely tedious while drawing the first couple of maps, is walls and cliffs. Piecing a canyon full of cliffs together one tile at a time gets old. And it turns out that walls have a very canonical pattern to them, which means there has to be a way to automate their construction. I thought about how I might go about this for the last few days, and I finally sat down to tackle it just tonight. The implementation is still a bit rough, but I’m happy to say it is basically working. The idea is that when you’re drawing an interior-type map, such as a house, cave, dungeon, or even a canyon, the really important part is the floor. The floor is what determines where the player can walk, which way the passages go, the shape of the dungeon. The walls are usually just going to follow the floor. So I designed this tool to allow you to focus on drawing the floor. It automatically fills in the correct wall pieces as you paint the floor onto the map! I thought this was pretty cool. Note the standard wall pattern in the tileset:\n\nAutomatic Wall Tiling\n\nSummary\n\nSo there you have it! A bunch of editor tools that should help to take some of the tedium out of map creation. It’s helpful to notice when you’re doing something repetitive, and you develop your own internal system for doing it. If you can systematize it, chances are you can turn it into an algorithm! I intend to keep trying to notice when I’m spending too much time on a task that the computer could be doing for me, and see if I can make a tool that saves me from having to do it again.\n\nHere’s a February recap:\n\nContinuing updates to collision detection system\n\nLinks between maps (so you can run from one map to the next, or from an exterior to an interior)\n\nDoors\n\nWalking, talking NPCs (townspeople)\n\nMessage boxes with line breaking\n\nA* Pathfinding AI\n\nAutomatic tiling tool for terrain boundaries in the editor\n\nNice village tileset and map\n\nPersistent clipboard in editor for saving reusable things like complex trees and houses\n\nZooming in the editor\n\nCore of the event scripting system (script parsing, simple expression tree building)\n\nChange from 80 pixel to 60 pixel tiles\n\nRedrawn player sprites\n\nLots of graphical experimentation\n\nSimultaneous build system for Windows and XBOX versions!\n\nNot bad! This past week has been very busy. First, I made a change from an 80-pixel tile size to 60 pixels. At 80 pixels, the view looked too zoomed in to me. This had been bothering me for a while, and it finally reached a threshold where I had to try another scale. I’m pretty happy with 60 pixel tiles, for now. I am realizing that the opposite of the “too zoomed in” problem is finding that the characters look a little small when the view is zoomed out more. Anyway, I made the change across the board. Resizing the tile sets was pretty easy, but resizing the sprites turned out to be more time consuming. I ended up re-drawing (or at least re-tracing and re-inking) the player character completely, because I needed different proportions for him, and I was a little bit unhappy with the way some of the animation looked anyway.\n\nAll that redrawing was a very big job – probably two solid days. The upside is that it gave me a change to do a lot of thinking about the art direction, as well as a lot of experimenting. I studied all the maps of all the classic RPGs on sites like http://www.vgmaps.com/. Those mapping sites are an amazing resource for studying how the masters did their tiling and pixel art. I thought about different approaches to inking and coloring. I read a few pixel art tutorials. I even considered the possibility of continuing with the pencil sketch style I’ve been using for development, and I started two threads on Reddit here and here that generated quite a bit of discussion. To my surprise, the consensus there seemed to be that people thought it would be cool, assuming the game was good.\n\nI found that response very interesting, but I still think I want color. Color is a pretty big deal. So I’ve been experimenting with various approaches to coloring in paint programs. So far, the one I like best is drawing think inked lines, filling the inked in areas with solid colors, then adding shadows. Like a Disney approach. My brother has some interesting theories about how to use 3D rendering software to produce 2D sprites that look drawn. I’m looking forward to his proof of concept on that.\n\nI started work on the in-game event scripting system. I’m always curious about how games typically approach scripted sequences. In particular, I wonder how many somehow make use of existing scripting engines, vs. how many roll their own. I’m a former compiler-guy, and remain very interested in languages, so I’m opting to create my own scripting system, as I did for Aspetra oh so long ago. But I’ve worked on real commercial compilers and interpreters since Aspetra, so this time around I know quite a bit more about lexing, tokenizing, expression trees and so forth. I’m having a lot of fun with that part. Last week I converted an old tokenizer I wrote a couple years ago to C#, and wrote an expression tree builder for a very simple grammar that I plan to develop as I go. I expect to have it driving simple world events this week.\n\nToday, I spent all day doing a chore that was a bit boring, but that I expect to pay big dividends. I reorganized all the runtime code in such a way that I can now build both XBOX and Windows versions of the game. It’s all nicely factored so that I can work on a common code base, and I don’t really have to do any extra work to get both versions. XNA is already such a nice abstraction, that this was not difficult at all. The major platform-specific thing with XNA is the input. I want game pad controls for the XBOX version, and keyboard controls for the Windows version. So, I wrote a handful of classes that abstract the notion of a game pad into an imaginary virtual controller that’s common to both platforms. Then, in the XBOX project, I have a tiny bit of platform-specific code that uses the XBOX game pad to drive the virtual controller, and in the Windows project, the corresponding code uses the keyboard to drive the same virtual controller. The rest of the code only needs to interact with the virtual controller abstraction.\n\nI think it will be very, very nice to be able to do primary testing and debugging on my dev machine now. I should only need to test on the XBOX semi-regularly, to make sure everything is working, and performing well.\n\nI’ve been making tons of progress of all kinds this week. Last week, however, I was stuck for a couple of days. Part of it was probably the fact that I was recovering from some brutal wisdom tooth surgery. But most of it had to do with hard decisions about the design of the game world.\n\nIn particular, I’m talking about the structural design of the game world. Things like, how to you get from Point A to Point B? How big is a map? How do you get from one map to another? Is there an overworld? Since I’ve already thought these to death, I’ll get to the point. I finally narrowed down the decision space to these three options:\n\nContinuous, un-zoned – Basically like World of Warcraft, but 2D. The whole world would look like one enormous map, and you can run from anywhere to anywhere else without any fades or load screens\n\nContinuous, zoned – Like Secret of Mana or Secret of Evermore. The world is continuous in the sense that you run from one map to the next, without any overworld map. But there are fades between maps, and it’s obvious where the map boundaries are.\n\nZoned, with overworld – Like the classic Final Fantasies, and countless other turn-based RPGs. Lots of separate maps, and a larger scale world map for traveling longer distances.\n\nThis was a tough decision. I’ve always had a general feel for what this game would be like – and I probably spent most of the time imagining it like #2. But when it came time to actually use this scheme to represent the area around the first village, I ran into problems. This led me to seriously consider the other options.\n\n#1 – Continous, un-zoned: In this kind of scheme, everything is on the same absolute scale, and it’s all in the same continuous space. One upside is that it can make the world seem more real. A potential downside is that it’s more complicated technically. You need to stream the map, and you need to work out how to process only the necessary parts of the world around you. From a design standpoint, the major downside is that you can end up with a lot of boring, unnecessary space in-between the interesting destinations. You can potentially solve that by filling the space with more interesting things, at the risk of losing focus. Another issue is that for a large world, you can spend way too much time running from one place to another. Some people like this because it’s more realistic, and others don’t like it because it’s tedious. The tedium can be reduced with various fast-travel systems.\n\n#2 – Continuous, zoned: Historically, this seems to be the norm for Action RPGs. Crystalis, Lagoon, Secret of Mana… all the classics used this scheme. In contrast to #1, this is technically simpler. You’re always inside exactly one relatively small, finite map, and you only need to compute things happening in that map. On the design side, you can be sure that the world is composed entirely of these focused, hand-crafted maps. I think this gives a game more of a video-game feel, as opposed to a virtual-world feel. I supposed that can be either a plus or a minus, depending on your design goals. One downside is that if you have a world fully sketched out, it can be challenging to represent it adequately with lots of small segments. Like #1, this scheme can lead to lots of tedious running back and forth between zones, unless there’s a fast-travel system. On the flip side, it can seem unrealistic if towns are only separated by a few wilderness maps, because real towns wouldn’t be so close together. Once again, this leads to more of a video-game feel, where the maps are only meant to convey an impression of distance.\n\n#3 – Zoned, with overworld: This scheme has long been the norm for turn-based RPGs. The idea is that different maps represent completely different scales. So you can represent a large world, with more realistic distances between sites, but without it taking too long to run between them. The trade-off is that the world is distinctly not continuous. There are large stretches of in-between space where you will never see anything up close. The important places are clearly marked as individual zones.\n\nFor a time, I thought #1 might be intriguing for an Action RPG. I went so far as to code a proof of concept, to show I could do chunked, pseudo-infinite maps. It was cool, but it definitely suffered from the problem of having way too much empty space to fill. My design philosophy for Action RPGs demands that most areas should be designed like an action game, with a minimum of open, empty areas. Think about how much empty space there is in WoW!\n\nI’m leaving #3 on the table, but the thing is, I don’t have a specific reason for an overworld map right now. Unless that changes, I’m back to my first instinct, which is #2.\n\nSo, back to my trouble with the first village. I envisioned this village as standing by itself in the middle of a large plain. How would I represent this? Here I started getting into the design challenges of this type of world.\n\nPerhaps the major “downside” of #2 is that it is very vulnerable to the Insurmountable Waist-High Fence problem! When segmenting the world into lots of smaller maps, it often becomes necessary to keep the players path somewhat “under control”. Otherwise, the world would turn into something more like #1. In general, there are three options for Exits from a map:\n\nYou go through an entrance that leads to an interior/cave/dungeon\n\nYou go through a narrow exit that leads to a corresponding narrow entrance in the next map over\n\nYou walk off the wide-open edge of the map, and into the wide-open edge of the next map over\n\nIf there is too much of exit type #3, you basically have the equivalent of an un-zoned world, but with fades. This carries the same problem of ending up with too much useless, empty space, and a lack of focus in the world design. I happen to think exit type #3 should be seriously minimized – if there’s a large open area, put it all on one map. But no matter how large or small an area is, eventually you will reach a boundary. And as a game designer, that means you need an excuse for why the player can’t go any farther. Even WoW has cliffs! But it can be tricky, to say the least, to come up with boundaries that don’t seem stupid, like the Insurmountable Waist-High Fence.\n\nSo, given these three ways of connecting maps together, how would I represent an open village surrounded by an open plain? Most Action RPGs skirt around this problem by always surrounding all towns with walls, so that you have to enter or leave by a small gate. Well, my story calls for a small, open village – the kind that simply doesn’t have walls. Sure, I could just relax and throw an insurmountable waist-high fence around the village, and the problem would go away. But I wasn’t satisfied with this. I wanted to think through all my design options. I could:\n\nPut some type of obstruction around the village, creating small exits (river, fence, wall, trees, steep drop-off, etc.)\n\nPut the village and the surrounding plain on one large map (still leaves the problem of what to do at the edge of this large map)\n\nLeave the edges of the village open, and make 4 more adjacent maps on each side to represent the plain (leaves the problem of what to put in these maps)\n\nI didn’t really like any of these options, and this kept leading me to question the overall world structure. But then I had another thought. Would it be possible to find some kind of compromise between these approaches that wasn’t as bad as the individual approaches? So I sat down with my notebook and just sketched and thought for awhile.\n\nI thought, what if the village was only obstructed in one or two directions? Like, by a river flowing by on one or two sides? And what if I made the village map just a little larger, with some empty plain-like space around it, but not too much? And then, maybe it wouldn’t be so bad to have 2 open edges, leading to two adjacent areas. Surely enough interesting things will happen around town to make use of two adjacent maps.\n\nAnd that was when I realized that I was really designing, and that design is hard. By that I simply mean that there’s no one-size-fits-all pattern that can tell me how to make the world, and there’s no way around having to make difficult choices along the way. The overall structure of the world, meaning the relationships between maps, are tools, and it’s the designer’s job to use the available tools to make a world. I also realized that as annoying as Insurmountable Waist-High Fences can be, obstructions in video games are probably a fact of life. The best I can do is to try to stick to believable ones, like rushing rivers, cliffs, high walls – things that would actually stop you in the real world."
    }
}