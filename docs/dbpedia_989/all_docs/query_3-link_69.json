{
    "id": "dbpedia_989_3",
    "rank": 69,
    "data": {
        "url": "https://community.monogame.net/t/ecs-and-animated-sprites-where-it-all-fell-apart/14854",
        "read_more_link": "",
        "language": "en",
        "title": "ECS and Animated Sprites - where it all fell apart...",
        "top_image": "https://community.monogame.net/uploads/default/original/2X/1/1f3e05db83f249568a90bc00b870f7da34da0b2b.png",
        "meta_img": "https://community.monogame.net/uploads/default/original/2X/1/1f3e05db83f249568a90bc00b870f7da34da0b2b.png",
        "images": [
            "https://github.githubassets.com/favicons/favicon.svg",
            "https://opengraph.githubassets.com/f7f76358f606e347a933711446f680cac164cba7847bee23868f9d35302b4acc/PaulBlythe/Fox1",
            "https://img.youtube.com/vi/m89DVJGl3a4/maxresdefault.jpg",
            "https://github.githubassets.com/favicons/favicon.svg",
            "https://opengraph.githubassets.com/13da3b88991337c1f3b0d3c5ab6cae643a126454a6e7e66a99071866408422a0/SanderMertens/ecs-faq",
            "https://community.monogame.net/user_avatar/community.monogame.net/mrbildo/48/10340_2.png",
            "https://community.monogame.net/user_avatar/community.monogame.net/poohshoes/48/7441_2.png",
            "https://community.monogame.net/user_avatar/community.monogame.net/poohshoes/48/7441_2.png",
            "https://community.monogame.net/user_avatar/community.monogame.net/martenfur/48/10015_2.png",
            "https://community.monogame.net/images/emoji/twitter/+1.png?v=12",
            "https://community.monogame.net/images/emoji/twitter/wink.png?v=12",
            "https://monogame.net/images/logo_light.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-01-30T06:12:07+00:00",
        "summary": "",
        "meta_description": "After years of prototyping and messing around I’m finally trying to finish a game and man, this ECS thing is a struggle. \nSo in the past I’ve always written my little games using the, now-out-of-fashion, OOP way of base &hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://community.monogame.net/uploads/default/optimized/2X/9/97fc71fe61a108d7e61792f0a1fa7e31ac56d2da_2_32x32.png",
        "meta_site_name": "Community | MonoGame",
        "canonical_link": "https://community.monogame.net/t/ecs-and-animated-sprites-where-it-all-fell-apart/14854",
        "text": "After years of prototyping and messing around I’m finally trying to finish a game and man, this ECS thing is a struggle.\n\nSo in the past I’ve always written my little games using the, now-out-of-fashion, OOP way of base class with update, draw, etc. I had a lot of success. So I thought since I was going to try this “for real” I would see what the pros are doing and I stumbled across ECS and the myriad of content out there surrounding it.\n\nI didn’t start out with any frameworks as I’m happy to write it myself. At first everything worked great-I had a lean Entity class, Postion component, Renderable component, a RenderingSystem and I was drawing little static sprites all over the screen. Then I tried to adapt my AnimatedSprite class and it all fell apart.\n\nSo I then I thought, hey, other people have solved this, let me look at some ECS frameworks. What I found were a lot of highly optimized skeletons with no reference implementations or reference implementations that seemed nothing like what I was told ECS was. I’m truly not being critical of the awesome open-source frameworks out there, but I haven’t found one that implements the concept of an AnimatedSprite using “pure” ECS, meaning an Entity with little more than an ID, Components that only store data and Systems that do all the logic.\n\nIn my prototype I have everything all wired up with a nice state machine that can trigger animations and transitional animations and can loop, ping-pong, etc. I’m just having a real helluva time adapting that to ECS without writing really sloppy code.\n\nOK, so for some focused questions:\n\nMan, I’d love to see your ECS state machine and animation system. Can I?\n\nIn a property/field-only Component how do you track current delta time other than constantly decorating your Compontent with it? Meaning, I need to know when to switch animation frames based on some kind of speed variable compared to accumulated time. Is it appropriate to store that at the Component level? I feel like my Components are just getting super busy.\n\nHow granular should a Component be? Maybe that’s my problem? At a certain point ECS seems pointless if your Components are just versions of OOP-style entities.\n\nBased what I’ve seen I feel like everyone ends up with some kind of hybrid approach.\n\nThank you for your patience.\n\nEDIT: yes, I’ve looked through this: GitHub - SanderMertens/ecs-faq: Frequently asked questions about Entity Component Systems\n\nI have an ECS in here\n\nGame/GuruEngineTest/GuruEngineTest/GuruEngine/ECS\n\nIt is aimed at 3D not 2D , but the principles are the same\n\nI have a game object which contains a load of components\n\ngame components can have connections to other game components\n\nSo in my context you can add an animation component to a mesh.\n\nThe animation component is connected to a data source , usually through a named variable, and connected to the mesh through a pointer\n\nWhen the update method on the animator is called, it calculates a new animation matrix, then applies it the the connected mesh\n\nAnother way of animating objects is to combine animation and function, so I have a AntiAircraftArtilleryComponent\n\nThis not only contains the code needed to animate the weapon, but the AI to make it function\n\nIn data I am currently just using text files,eventually I will compile these into binary blobs, but at the moment text is much more convenient\n\nAn example looks like this\n\nAntiAircraftArtilleryComponent_1 AntiAircraftArtilleryComponent 2 Root#Root#Flak18_88mm:GameComponents Transform#WorldTransform#WorldTransform_1:Consumers 1 Meshes#Body:Aircraft, 8 FireTime Float 2 RecoilDistance Float -0.35 MaxPitch Float 10 MinPitch Float -85 MinYaw Float 0 MaxYaw Float 360 AnimMode Int 0 Round String AAA/Flak88mm\n\nBreaking this down you have…\n\nThe name of the component AntiAircraftArtilleryComponent_1\n\nThe class of the component AntiAircraftArtilleryComponent\n\nIt has two direct connections\n\nThe first connects this component to the root of the game object, required for update to be called\n\nThen a connection to the game objects world transform\n\nThen a single list connection, which connects this component to the mesh list of the object\n\nThen 8 parameters that control the component\n\nThe Round parameter link to ammunition data for the physics system and particle system data\n\nAn ECS is incredibly powerful when written properly\n\nI don’t know where you read that, but it’s total bollocks\n\nThe whole point is that you can have a designer rather than an expensive coder to put together game objects.\n\nHaving no code in the game objects is just plain stupid.\n\nConsider the alternative.\n\nYou add a component that is just a block of data. Something has to parse that data and decide what to do with it. So that is effectively wasted cpu cycles.\n\nMine does not have to think about what to do with the data, it knows what to do with the data\n\nThen take the case that a component needs to talk to another component, in mine when the object is created it knows the correct update order. So a thruster updates before the physics system. , an animator updates before the mesh.\n\nIn the system you are talking about you will have to artificially impose some kind of update ordering , hard coded in advance.\n\nI really don’t know where you found talk about ECS without code, because I would love to have 10 minutes in a sound proof room with them\n\nThat’s the road I started going down, but when I looked down the path I wasn’t sure it was the way forward. Here is what I’m messing with now:\n\npublic class AnimatedSprite : Sprite, IComponent { public AnimatedSprite(string texturePath, string textureKey, Animation[] animations, int cellWidth, int cellHeight, int columns) : base(texturePath, textureKey) { Animations = animations; CellWidth = cellWidth; CellHeight = cellHeight; Columns = columns; } public AnimatedSprite(string texturePath, string textureKey, Animation[] animations, int cellWidth, int cellHeight, int columns, short layer) : base(texturePath, textureKey, layer) { Animations = animations; CellWidth = cellWidth; CellHeight = cellHeight; Columns = columns; } public AnimatedSprite(string texturePath, string textureKey, Animation[] animations, int cellWidth, int cellHeight, int columns, short layer, Color color) : base(texturePath, textureKey, layer, color) { Animations = animations; CellWidth = cellWidth; CellHeight = cellHeight; Columns = columns; } public Animation[] Animations { get; init; } public int CellWidth { get; init; } public int CellHeight { get; init; } public int Columns { get; init; } public int Speed { get; set; } public int CurrentFrameIndex { get; set; } public int Elapsed { get; set; } //should this go here or in the animation? public Animation CurrentAnimation { get; set; } //is this right? Should this just be what ever animation is running? public Rectangle SourceBounds //probably should be in the system? What if I want to cache it? who/what handles isDirty? { get { var column = CurrentFrameIndex % Columns; var row = CurrentFrameIndex / Columns; var x = column * CellWidth; var y = row * CellHeight; return new Rectangle(x, y, CellWidth, CellHeight); } } } public class Animation { public Animation(string name, int[] frames, int speed, SpriteEffects spriteEffect = SpriteEffects.None, bool isLooped = false) { Name = name; Frames = frames; IsLooped = isLooped; SpriteEffect = spriteEffect; Speed = speed; IsRunning = false; IsCompleted = false; CurrentFrameIndex = 0; } public string Name { get; init; } public int[] Frames { get; init; } public SpriteEffects SpriteEffect { get; init; } public bool IsLooped { get; init; } //public LoopType LoopType { get; init; } public bool IsRunning { get; set; } public bool IsCompleted { get; set; } //public int Elapsed { get; set; } }\n\nOne of the things that has tripped me up is the idea of storing the Elapsed (I’m using ticks, so this is the equivalent of deltaTime) on the Component. In my brain storing the elapsed time should be part of the System state, not part of the Component state. Then I started to go down the road of storing storing a Component cache in the System to track it and I got frustrated.\n\nMaybe what I have is fine.\n\nIf you want help thinking how to solve problems with ECS you can jump into the Discord for MonoGame and somebody will definitely be able to help you. I’m writing this below as a warning for you and others that come this way. Almost every week like clockwork there is some one who is confused about ECS on Discord. We even have memes of “ECS bad” and “ECS good”.\n\nThere is real benefits with getting serious with data-oriented game dev. To reap these benefits you will have to go dig into C# and learn a few things which are not usually worth it for most C# developers outside game dev like how automatic memory management works and how to avoid it when necessary. I make a claim that there exists a portion of developers using MonoGame who do know C# they just have not done game development. Anyways as others have mentioned, if your goal is to just create a game then perhaps is not the best time to jump into this rabbit hole. This is especially true for your first game.\n\nlet me look at some ECS frameworks\n\nThe problem is that most ECS frameworks in C# are not really using data-oriented design. Rather they are just applying the pattern of “Entity Component System” while ignoring one of main reasons why the pattern exists in the first place. Yes this includes MonoGame.Extended which is based on Artemis from Java. I can only talk about MonoGame.Extended, but I believe the ideas can transfer as to why others are in the same boat. The reasons are:\n\nWe didn’t really know in depth what advocates meant with data-oriented back then. Or rather, we didn’t believe them. We been using C# for years. We knew how to solve problems (or so we thought). So why change? Why does it matter if I use class for everything instead of struct? Is crunching some data really faster than fetching pre-computed data from memory? We were skeptics and it’s not surprising that other people are skeptics too. It’s much easier to just fallback into your comfort zone than to learn something new.\n\nC# and .NET in recent years has had some great advancements for game developers. Span<T> and stack-only-allocated structs for example were not widely available when MonoGame.Extended was looking into ECS at the time. Neither was native-AOT (formerly called CoreRT). In comparison, C# has been around since 2002. 3 out 19 years is relatively short time to see new features adopted into production code.\n\nI would recommend either going all in on this rabbit hole xor not going in at all. I think the consensus here for the sake of sanity and efficient use of time is not go in at all unless you have performance problems at scale. It’s once you have a real reason to learn and get practice using data-oriented design that a bit flips in your brain. Once the bit is flipped you wish you could flip that bit for others too.\n\nWith all the warning and “I told you not to” out the way… If you have a good reason to learn how to do this then here are some links:\n\nGitHub - SanderMertens/ecs-faq: Frequently asked questions about Entity Component Systems. Already posted in this thread, but it’s a good go-to resource for introductions.\n\nComponent · Decoupling Patterns · Game Programming Patterns. Good primer for the “E” and “C” in ECS without being ECS.\n\nData Locality · Optimization Patterns · Game Programming Patterns. Good introduction to why data-oriented design matters for game developers. You’ll start to see some early thoughts of where “Entity Component System” is coming from by the end of this chapter.\n\nhttps://github.com/Michaelangel007/game_dev_pdfs/blob/master/c%2B%2B/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf. Lecture slides from Sony with examples in C++.\n\nData-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP) – Games from Within. Game developer blogging about data-oriented design.\n\nhttps://seanmiddleditch.com/oop-is-fine-in-moderation/ Another game developer blogging about data-oriented design. This one is particularly good because the ideas of what we mean by OOP are challenged. There is even examples in C on how to do OOP."
    }
}