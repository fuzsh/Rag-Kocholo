{
    "id": "dbpedia_989_3",
    "rank": 36,
    "data": {
        "url": "https://www.gamedeveloper.com/programming/using-unity-s-new-2d-animation-package-for-traditional-sprite-animation",
        "read_more_link": "",
        "language": "en",
        "title": "Using Unity's New 2D Animation Package for Traditional Sprite Animation",
        "top_image": "https://www.gamedeveloper.com/build/_assets/gamedeveloper-X2EP7LQ6.ico",
        "meta_img": "https://www.gamedeveloper.com/build/_assets/gamedeveloper-X2EP7LQ6.ico",
        "images": [
            "https://www.gamedeveloper.com/build/_assets/informaLogoWhite-RZAE7EJI.png",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt8d5417b628e6b04b/656f5ed8485fda040aba11a1/Game_Developer_Logo_RGB_1.png?width=476&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt259a53becbf82509/66d09536b0646f0b4cfae6dd/Patch_Notes_2_Header.png?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/bltde25c241cf5f4e09/6661f522254a260a445b8c53/relic_hunters.jpg?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/bltb8149045ecc9add6/664670498df30a26f54d5ed4/GDBlogs_Logo_FINAL.png?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/bltf2305978ae183048/650887399f36d9161ddfdbf9/Kyle_Kukshtel.jpg?width=100&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/bltba62518415cda0e2/652fe6ddbc479f8697ef691f/default-cubic.png?width=1280&auto=webp&quality=95&format=jpg&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt1d2f32fc9395c173/650eada347b2f12946ab4154/Screen_20Shot_202021-02-23_20at_202_11_42_20PM.png/?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt8629a7cc182069b0/650eada362e65c3c4e3a2bdc/Screen_20Shot_202021-02-23_20at_202_29_55_20PM.png/?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt64600c950f8124ac/650eadb247b2f1943dab4158/Screen_20Shot_202021-02-23_20at_202_31_21_20PM.png/?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt18ff5dd187751174/650eada9467b0ea149941c1b/Screen_20Shot_202021-02-23_20at_202_03_09_20PM.png/?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/bltf2305978ae183048/650887399f36d9161ddfdbf9/Kyle_Kukshtel.jpg?width=400&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt259a53becbf82509/66d09536b0646f0b4cfae6dd/Patch_Notes_2_Header.png?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/bltde25c241cf5f4e09/6661f522254a260a445b8c53/relic_hunters.jpg?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt750827cec9b89f72/66cf9c1fad0ee115fe08d69d/ss_f1dd718b7bfe57539fbd58d99b992a13b9b2564a.1920x1080.jpg?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/bltd0269c2671887a48/66d03cde9d82784b030dab58/Xbox_Accessibility.png?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt5b911461dd4460c0/66ce3e792dd9337f760328f2/humberlykayfeatured.jpg?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blta575c94332330038/66cf74183ff4484eea7ce399/pexels-lexovertoom-1109543.jpg?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt52e4e5e4eabc3597/66ce05c65eb28c4cf2046dd3/Gamescom_2024.png?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt2638a8adf802a111/66cde4955026665eb67a1cfe/GUzApxWXQAAODBa_(1)_(1).jpg?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt8d5417b628e6b04b/656f5ed8485fda040aba11a1/Game_Developer_Logo_RGB_1.png?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt1363a10229efc062/656db9e79761ff040a595688/MicrosoftTeams-image_(3).png?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt1bbfb7520e56ef03/65250cc0c5c21b80cfb55335/Game_Developer_Jobs_Logo_white.png?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt431090e6027a0c17/65250c42e4f4b80857d3c9cb/gdc_logo_(1).png?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt789019463bae70bf/6523eb443c9b45aa9da4f4b2/logo_omdia_white.png?width=700&auto=webp&quality=80&disable=upscale",
            "https://eu-images.contentstack.com/v3/assets/blt740a130ae3c5d529/blt7ac431a25be6784c/6474a0a18bdc2b0843a07db3/InformaTechBTYB_240x60.png?width=700&auto=webp&quality=80&disable=upscale"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Kyle Kukshtel"
        ],
        "publish_date": "2021-02-24T10:15:00+00:00",
        "summary": "",
        "meta_description": "Diving into Unity's new 2D Animation package and finding a lot to love for the creation sprite-based 2D games.",
        "meta_lang": "en",
        "meta_favicon": "/build/_assets/gamedeveloper-X2EP7LQ6.ico",
        "meta_site_name": "",
        "canonical_link": "https://www.gamedeveloper.com/programming/using-unity-s-new-2d-animation-package-for-traditional-sprite-animation",
        "text": "This post was originally posted to my personal blog\n\nIntroduction\n\nThe Unity package ecosystem can be a bit of a mess to navigate, so I wanted to highlight a package I dove into recently that I was surprised more people weren't talking about â€” the new 2D Animation package. The components and ideas introduced in the package significantly change the 2D animation workflow in a way that makes working with 2D in Unity a lot more reasonable, and in some ways, I believe, fundamentally change how to do 2D in Unity for the better.\n\nBackground\n\nNote: This post is focused on flipbook-style sprite animation, but bone-based animation also benefits from this workflow\n\nIf you've done 2D animation in Unity before you'll be familiar with this workflow:\n\n1) Import and slice a spritesheet\n\n2) Select the sprites from that sheet that form an animation, drag them into the Scene window to create a new animation.\n\n3) Rinse and repeat step 2 for each animation for that spritesheet.\n\n4) If you're using animation controllers and this spritesheet shares the same states as others, you'll make a new override controller for this tilesheet specifically, and link up all these animations.\n\nThis means that every single new 2D object in your game needs unique animations and a unique controller, even if the sheets are the \"same\". This is because the Sprites are hard-referenced in the Animation, where the Animation essentially plays back a series of a direct references to a Sprite asset. So you can't share animations between objects, because the animations themselves point to specific sprites. You're essentially starting over the process from scratch for each object.\n\nThis is a giant pain. It means that if you have even just 5 tilesheets that have 5 animations each, you're looking at 25 additional assets in your project that need to be unique, and require lots of manual setting up, but that are fundamentally all doing the exact same thing: playing back sprites in tilesheet locations. Doing things this way makes sense when you consider that the animation system expects uniqueness-per-animation, which is often the case with 3D rigs. But for 2D, why isn't there just a way to play animations by reference to a tilesheet index? Why can't you just say \"this animation plays tilesheet sprites 0-4\" and share that across sprites?\n\nSpriteLibrary/SpriteResolver\n\nWell I have great news! You can now effectively do that! Unity's new 2D Animation package provides two major tools that more or less replace the functionality of the above workflow. The package sounds like it's meant primarily for bone-based animation (which I suspect is why more people aren't talking about it), but it has tools in it that work for generic 2D Animation as well.\n\nSprite Library\n\nOne of the core things the package introduces is the concept of a SpriteLibrary. As the name may suggest, this is a collection of sprites. It's almost directly a sort of C# dictionary, where sprites are indexed first by Category, then by a given sprite's Label (set by you in the library, not the generated sprite name that comes from slicing a tilesheet). Categories can be roughly whatever you want, and are used a way to group sprites that are used together or are semantically similar. You could have a category, as ther documentation suggests, that defines all the sprites used for a given character. Or, as we'll talk about more below, you could have a category that defines the frames of an animation, with each entry in a category being a specific frame.\n\nWhat this allows you to do is address sprites not by direct reference anymore, but by a collection that can be generically referenced. The SpriteLibrary API, for example, allows you to do this:\n\npublic Sprite GetSprite(string category, string label)\n\nNote here that neither the caller nor the function itself needs to know what's in the library. A version of the function:\n\nvar sprite = MySpriteLibrary.GetSprite(\"Character\", \"Face\");\n\ncould be called on any library. Obviously if the library doesn't have a corresponding category and label you'll have a null sprite, but the point here is that SpriteLibrary has given us a reusable way to reference sprites. Contrast the above with the code with the standard ways to get a single Sprite from a tilesheet:\n\n// From Resouces Folder public Texture2D texture; int spriteIndex = 0; var sprite = Resources.LoadAll<Sprite>(texture.name)[spriteIndex]; //Via Atlas public SpriteAtlas atlas; var sprite = atlas.GetSprite(\"child_sprite_name\"); // (Atlases are also un-ordered, so you can't just called GetSprites()[0])\n\nBoth of these (and many other options) require you to know the exact sprite you're looking for, either by its index or its name. SpriteLibraries give us ways to structure sprite data in a way that can be easily referenced, and, importantly, reusable. The same code path can be used for any libraries that share the same structure, whereas the above samples all need to be edited to account for the specifics of the tilesheet or atlas they are working with.\n\nSprite Resolver\n\nNow where this gets interesting isn't just through the use of a SpriteLibrary. A sprite library would be worthless as an asset alone. The 2D Animation package also gives us access to another new component, the SpriteResolver.\n\nA SpriteResolver, when placed on an object that also has a SpriteLibrary component and linked in Sprite Library, allows you to dynamically assign the given sprite of an attached SpriteRenderer component by changing the values on the resolver. These values map directly to the values you set on the linked in SpriteLibrary.\n\nSo, the following code:\n\nGetComponent<SpriteResolver>().SetCategoryAndLabel(\"Character\", \"Face\");\n\nTells the resolver to try and grab the corresponding sprite from the SpriteLibrary that it has access to. If this code succeeds, the sprite will update in the SpriteRenderer! Below is a screenshot of what would happen if you called the following code on this game object.\n\nGetComponent<SpriteResolver>().SetCategoryAndLabel(\"Idle\", \"3\");\n\nIn the library asset itself, you can see that the category Idle, at sprite label 3, points to the Scavengers_SpriteSheet_2 sprite we see linked above in the SpriteRenderer component.\n\nIt may be hard to grasp the philosophical change in this, but to support you in having the same revelation I had, Unity provides some pretty good samples in the 2D Animation Package (Download by clicking \"Download Samples\" From Window->Package Manager and selecting 2D Animation). What I just discussed is demonstrated in their SpriteSwap samples.\n\nPutting It Together with Animations\n\nSo providing a nicer way to set single sprites on an object is great, and maybe worth the package alone, but the beauty of SpriteResolver isn't just that it exposes an API to set sprites this way, but that the Category and Label fields of the Resolver can be animated.\n\nSo if you take a generic way to address sprites, and add in a generic way to change those addresses.... you get a generic sprite animation system! This is huge. It's made adding new content to Cantata trivial. Here's my process:\n\nFor new Interactables, I don't need to create new animations, new controllers, nothing. I only need a SpriteLibrary, which can be easily created and edited at edit-time or runtime. I wasn't even done adding in all the animations for Cantata, but using this system I was able to swap out ~60 animations (out of a total projected of ~700) for a single set of animations and a single controller.\n\nI'm also thinking of creating a dynamic effects loading system that functions off a similar concept, and this has paved the way as well for me to add in new unit types and sizes that would have been harder in the old system. It's a serious workflow game-changer.\n\nAnd importantly, it just works. Creating new assets in Cantata before wasn't exactly hard, but it was tedious and easy to misclick when creating animations and forgetting to link the proper animation to certain place or whatever. Now I never have to worry about it!\n\nBuilding Animations\n\nI want to take a small step back here as well and talk about how to actually animate the labels, because it's a bit more frustrating that it may seem. A big shoutout here to this blog post as well that seems to be the only other place on the internet that describes how to actually set these values, and who taught me how to do it.\n\nAnnoyingly, you can't just create an animation and easily address the Labels on the SpriteResolver by name. Instead they need to be a \"LabelHash\". This is a number that is effectively impossible to set manually.\n\nThis means to set up your animations, you need to create an animation, target the GameObject you want to animate, and select the SpriteResolver property in the animation editor and add in fields for LabelHash and CategoryHash (both or either, depending on what you want to animate). Your animator should look roughly like this (minus the keyframes):\n\nTo add in animations, you can't just set keyframes and the target label/category name. Instead you have to use their hash. Like I said above as well, these hashes cannot be set directly.\n\nInstead, you need to record the animation yourself. Click the red button to start the animation recording system, and then move the animation playhead to the desired location and then change the category or click the desired sprite in the target SpriteResolver component to make a keyframe of those values at the playhead location. I know.\n\nAdditionally, and this is very important, you need to make sure the keyframes are set to \"Broken\", and \"Both Tangents\" set to \"Constant\". You can do this by right-clicking the keyframe. Because the hashes are discreet values, attempting to tween between them will result in invalid values. By using these settings you're effectively making sure the values are set through the duration of their playback.\n\nAfter setting the values this way, you should be good to go. For Cantata I play these animations back with an animation controller, but you could just as easily just have an animator playing back a single set of animations. I'm also not sure how the label hashes are calculated, but it seems like, as long as the library you swap in for another one has the same names/categories for a given sprite reference, the hashes are interchangeable, i.e. you don't need to make new animations for every new SpriteLibrary.\n\nConclusion\n\nHopefully with this post you've got a bit of a handle on what the new 2D Animation project offers to people doing more \"traditional\" 2D animation inside of Unity. For me, this is now the de-facto way I'll handle 2D animation if I'm doing animation in Unity, as it allows me to cut out any redundant work and also allows me to create animations and controllers that are reusable!\n\nIf you have any questions, feel free to reach out to me via the comments or via @kkukshtel on Twitter. Thanks for reading!\n\nErrata"
    }
}