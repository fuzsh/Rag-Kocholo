{
    "id": "dbpedia_989_3",
    "rank": 25,
    "data": {
        "url": "https://docs.unity3d.com/Manual/Quickstart2DCreate.html",
        "read_more_link": "",
        "language": "en",
        "title": "Manual: Creating a 2D game",
        "top_image": "https://unity3d.com/files/images/ogimg.jpg",
        "meta_img": "https://unity3d.com/files/images/ogimg.jpg",
        "images": [
            "https://docs.unity3d.com/uploads/Main/quickstart-sprite-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-sprite-editor-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-sprite-renderer-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-sort-sprites-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-sprite-atlas-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-9-slice-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-tilemap-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-spriteshape-path-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-frame-by-frame-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-cutout-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-skeletal-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-lighting-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-shadows-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-particle-system-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-post-processing-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-rigidbody-component-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-circle-collider-component.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-is-trigger-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-testing-2d.png",
            "https://docs.unity3d.com/uploads/Main/quickstart-build-settings.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Unity Technologies"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Creating a 2D game\n\nBefore you create a 2D game, you need to decide on a game perspective and an art style.\n\nTo create a 2D game, set up your Unity project and then familiarize yourself with the relevant concepts in the following order:\n\nFundamentals\n\nScripting\n\nSpritesA 2D graphic objects. If you are used to working in 3D, Sprites are essentially just standard textures but there are special techniques for combining and managing sprite textures for efficiency and convenience during development. More info\n\nSee in Glossary\n\nBuilding in-game environments\n\nCharacter animation\n\nGraphics\n\nPhysics 2D\n\nAudio\n\nUser interface\n\nProfiling, optimizing and testing\n\nPublishing\n\nFundamentals\n\nGameObjectsThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary are fundamental objects in Unity that represent characters, props, scenery, and more. Every object in your game is a GameObject.\n\nGameObjects represent the items in your game; the space in which you place them to build your level is called a sceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary. Scenes in Unity are always 3D; when you make a 2D game in Unity, you typically choose to ignore the third dimension (the z-axis) but you can also use it in special cases, for example when making 2.5D games.\n\nThe behavior of GameObjects is defined by blocks of functionality called components. The following components are fundamental for 2D games:\n\nTransform: the Transform componentA Transform component determines the Position, Rotation, and Scale of each object in the scene. Every GameObject has a Transform. More info\n\nSee in Glossary determines the Position, Rotation, and Scale of each GameObject in the scene. Every GameObject has a Transform component.\n\nSprite RendererA component that lets you display images as Sprites for use in both 2D and 3D scenes. More info\n\nSee in Glossary: the Sprite Renderer component renders the Sprite and controls how it looks in a scene.\n\nCamerasA component which creates an image of a particular viewpoint in your scene. The output is either drawn to the screen or captured as a texture. More info\n\nSee in Glossary: devices that capture and display the world to the player. Marking a Camera as Orthographic removes all perspective from the Camera’s view. This is mostly useful for making isometric or 2D games.\n\nCollider 2D: this component defines the shape of a 2D GameObject for the purposes of physical collisionsA collision occurs when the physics engine detects that the colliders of two GameObjects make contact or overlap, when at least one has a Rigidbody component and is in motion. More info\n\nSee in Glossary. See 2D Physics.\n\nComponents are UI(User Interface) Allows a user to interact with your application. Unity currently supports three UI systems. More info\n\nSee in Glossary representations of C# classes; you can use scripts to change and interact with components, or create new ones. See the Scripting section for more details.\n\nScripting\n\nAll 2D games need scriptsA piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info\n\nSee in Glossary. Scripts respond to input from the player and arrange for events in the gameplay to happen when they should.\n\nFor details on how to use scripts in Unity see Scripting Overview. Also see the Unity Learn Beginner Scripting course.\n\nScripts are attached to GameObjects, and any script you create inherits from the MonoBehaviour class.\n\nSprites\n\nSprites are 2D graphic objects. You use Sprites for all types of 2D games. For example, you can import an image of your main character as a Sprite.\n\nYou can also use a collection of Sprites to build a character. This allows you greater control over the movement and animation of your characters.\n\nImporting and setting up Sprites\n\nImport your Sprites with Unity’s recommended settings; see Importing and Setting Up Sprites.\n\nRendering Sprites\n\nUse the Sprite Renderer component to render your Sprites. For example, you can use the Sprite Renderer to change the color and opacity of a Sprite.\n\nSee the Introduction to the Sprite Renderer Learn tutorial. Sorting SpritesBy organizing Sprites in layers, you can create an illusion of depth. You can sort Sprites according to many strategies. See Sorting Sprites for full details. For example, you might sort Sprites along the y-axis, so that Sprites that are higher up are sorted behind Sprites that are lower, to make the Sprites that are higher appear further away than the Sprites that are lower.\n\nTo set the overlay order of Sprites, use Sorting Layers.\n\nTo group GameObjects with Sprite Renderers, and control the order in which they render their Sprites, use Sorting Groups.\n\nSprite Atlas\n\nYou can use a Sprite AtlasA texture that is composed of several smaller textures. Also referred to as a texture atlas, image sprite, sprite sheet or packed texture. More info\n\nSee in Glossary to consolidate several Textures into a single combined Texture. This optimizes your game and saves memory. For example, you can add all your Sprites associated with a particular character or purpose to a Sprite Atlas.\n\nSee the Introduction to the Sprite Atlas Learn tutorial.\n\nBuilding in-game environments\n\nEnvironment design refers to the process of building your game’s levels and environments. You can combine the environment design tools in this section in whichever way makes the most sense for your game; for example, you can make a top-down game using only 9-slice, or you can make a side on platformer with Tilemap and SpriteShape.\n\n9-slicing\n\n9-slicing is a 2D technique that allows you to reuse an image at various sizes without needing to prepare multiple assets. Unity can dynamically stretch and tile designated parts of a Sprite to allow one Sprite to serve as the border or background for UI elements of many sizes. See 9-slicing sprites.\n\nFor example, you could use 9-slicing to stretch a Sprite to shape when you build a 2D level.\n\nSee the Using 9-Slicing for Scalable Sprites Learn tutorial.\n\nTilemap\n\nThe TilemapA GameObject that allows you to quickly create 2D levels using tiles and a grid overlay. More info\n\nSee in Glossary component is a system that stores and handles Tile assets for creating 2D levels. Use the 2D Tilemap Editor package (installed by default) to use Tilemaps.\n\nFor example, you can use Tilemaps to paint levels using Tiles and brush tools and define rules for how Tiles behave.\n\nSee the Introduction to Tilemaps Learn tutorial.\n\n2D Tilemap Extras\n\nTo add some extra Tilemap assets to your Project, install the 2D Tilemap Extras package. This package contains reusable 2D and Tilemap Editor scripts that you can use for your own Projects. You can customize the behavior of the scripts to create new Brushes that suit different scenarios.\n\nIsometric Tilemaps\n\nFor games with isometric perspective, you can create Isometric Tilemaps.\n\nSpriteShape\n\nIn a similar way to a vector drawing tool, SpriteShape provides a more flexible way to create larger Sprites, such as organic-looking landscapes and paths. See the Sprite Shape Profile.\n\nSee the Working with SpriteShape tutorial.\n\nCharacter animation\n\nThere are three different ways you can animate 2D characters:\n\n2D animation type Used for Frame-by-frame Artistic reasons, if you want your game to have a classic animation art style. Frame-by-frame animation is relatively resource-intensive, both to make and to run. Cutout Smooth skeletal animation, when the characters don’t require realistic articulation. Skeletal Smooth skeletal animation where Sprites bend according to the bone structure. Use this when the characters need a more organic feel.\n\nFrame-by-frame\n\nFrame-by-frame animation is based on the traditional cel animation technique of drawing each moment of an animation as individual images, which are played in fast sequence, like flipping pages on a flipbook.\n\nTo do frame-by-frame animation, follow the Frame-by-frame Animation workflow.\n\nSee the Introduction to Sprite Animations Learn tutorial.\n\nCutout\n\nIn cutout animation, multiple Sprites make up the body of a character, and each piece moves to give the visual effect of the whole character moving. This animation style is similar to skeletal animation (see below), except that the Sprites don’t bend.\n\nSkeletal\n\nWith skeletal animation, you map a Sprite or a group of Sprites onto an animation skeleton. You can create and define animation bones for characters and objects, that define how they should bend and move. This approach allows the bones to bend and deform the Sprites, for a more natural movement style. To use skeletal animation, you need to use the 2D Animation package (installed by default).\n\nFor a 2D Animation workflow, including a guide to working with the Bone Editor, see the 2D Animation documentation.\n\nGraphics\n\nThis section describes your graphics options when using Universal Render PipelineA series of operations that take the contents of a Scene, and displays them on a screen. Unity lets you choose from pre-built render pipelines, or write your own. More info\n\nSee in Glossary (URP).\n\nLighting\n\nBecause you’re using URP with the 2D Renderer, you can use the Light 2D component to apply optimized 2D lighting to Sprites. For details, see Introduction to Lights 2D.\n\nTo set up lighting:\n\nPrepare your Sprites for lighting. For details, see Preparing Sprites for Lighting.\n\nSet up normal mapA type of Bump Map texture that allows you to add surface detail such as bumps, grooves, and scratches to a model which catch the light as if they are represented by real geometry.\n\nSee in Glossary and mask Textures. 2D Lights can interact with normal map and mask Textures linked to Sprites to create advanced lighting effects, such as normal mapping. See Setting up normal map and mask Textures.\n\nCreate a 2D Light GameObject; see 2D Lights Properties.\n\nConfigure the 2D Renderer Data asset; see Configuring the 2D Renderer Asset.\n\n(Optional) if you want to apply 2D Light effects to a pixelThe smallest unit in a computer image. Pixel size depends on your screen resolution. Pixel lighting is calculated at every screen pixel. More info\n\nSee in Glossary art game, see 2D Pixel Perfect.\n\nSee the Lighting in URP Learn tutorial.\n\nShadows\n\nTo define the shape and properties that a Light uses to determine the shadows it casts, use the Shadow Caster 2D component. Increase the Light’s Shadow Intensity above zero.\n\nEnhanced look and feel\n\nParticle systems and post-processingA process that improves product visuals by applying filters and effects before the image appears on screen. You can use post-processing effects to simulate physical camera and film properties, for example Bloom and Depth of Field. More info post processing, postprocessing, postprocess\n\nSee in Glossary are optional tools that you can use to add polish to your game.\n\nParticle systems\n\nYou can use particle systems to create dynamic objects like fire, smoke or liquids, as an alternative to using a Sprite. Sprites are more suited to physical objects. See Particle systemsA component that simulates fluid entities such as liquids, clouds and flames by generating and animating large numbers of small 2D images in the scene. More info\n\nSee in Glossary.\n\nPost-processing\n\nYou can use post-processing effects and full-screen effects to significantly improve the appearance of your game. For example, you can use these effects to simulate physical camera or film properties, or to create stylized visuals.\n\nURP has its own post-processing implementation. See Post-processing in the Universal Render Pipeline.\n\nPhysics 2D\n\nThe Physics 2D settings define limits on the accuracy of the physical simulation in your 2D game. See 2D Physics.\n\nThis video provides an overview of 2D physics features in Unity 2020.1.\n\nTo learn how to use Unity’s 2D physics engineA system that simulates aspects of physical systems so that objects can accelerate correctly and be affected by collisions, gravity and other forces. More info\n\nSee in Glossary, see the 2D Physics Learn tutorial.\n\nThe following 2D physics tools are useful for 2D games.\n\nRigidbody 2D\n\nCollider 2D\n\nTriggers\n\n2D Joints\n\n2D Effectors\n\nRigidbody 2D\n\nA RigidbodyA component that allows a GameObject to be affected by simulated gravity and other forces. More info\n\nSee in Glossary 2D component places a GameObject under the control of the physics engine. See Rigidbody 2D.\n\nCollider 2D\n\nCollider 2D components define the shape of a 2D GameObject for the purposes of physical collisions. You can also use ColliderAn invisible shape that is used to handle physical collisions for an object. A collider doesn’t need to be exactly the same shape as the object’s mesh - a rough approximation is often more efficient and indistinguishable in gameplay. More info\n\nSee in Glossary 2D components for input detection. For example, in mobile games you can use them to make Sprites selectable.\n\nThe Collider 2D types that you can use with Rigidbody 2D are:\n\nCircle Collider 2D\n\nBox Collider 2D\n\nPolygon Collider 2D\n\nEdge Collider 2D\n\nCapsule Collider 2D\n\nComposite Collider 2D\n\nTriggers\n\nWhen you set a Collider 2D as a Trigger (by enabling its Is Trigger property), it no longer behaves as a physical object, and it can intersect with other Colliders without causing a collision. Instead, when a Collider enters its space, Unity calls the OnTriggerEnter function on the Trigger GameObject’s scripts.\n\n2D Joints\n\nJoints attach GameObjects together. You can only attach 2D jointsA physics component allowing a dynamic connection between Rigidbody components, usually allowing some degree of movement such as a hinge. More info\n\nSee in Glossary to GameObjects that have a Rigidbody 2D component attached, or to a fixed position in world space. See 2D Joints.\n\n2D Effectors\n\nUse Effector 2D componentsA functional part of a GameObject. A GameObject can contain any number of components. Unity has many built-in components, and you can create your own by writing scripts that inherit from MonoBehaviour. More info\n\nSee in Glossary with Collider 2D components to direct the forces of physics in your scene when GameObject Colliders come into contact with each other. See 2D Effectors.\n\nAudio\n\nYou can add background music and sound effects to your game in Unity; see Audio Overview. Use third-party software to create your audio and import it into Unity with the recommended settings.\n\nUser interface\n\nIf you want to add a menu or help to your game, you need to set up a user interface. To set up a user interface, use Unity UI.\n\nProfiling, optimizing and testing a build\n\nProfiling\n\nProfiling allows you to see how resource-intensive the different parts of your game are. You should always profile your game on its target release platform; see Profiling your application.\n\nOptimizing\n\nAfter profiling, you can use the results to make performance improvements and optimizations. See Understanding optimization in Unity.\n\nTesting\n\nTest your game and your code with the Unity Test Framework; see Unity Test Framework.\n\nPublishing"
    }
}