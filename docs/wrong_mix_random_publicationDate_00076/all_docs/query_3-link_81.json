{
    "id": "wrong_mix_random_publicationDate_00076_3",
    "rank": 81,
    "data": {
        "url": "https://powershell341.rssing.com/chan-14040311/all_p13.html",
        "read_more_link": "",
        "language": "en",
        "title": "Scripting Blog",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://pixel.quantserve.com/pixel/p-KygWsHah2_7Qa.gif",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/450x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/0827.01.png",
            "https://blogs.technet.com/resized-image.ashx/__size/450x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/6318.02.png",
            "https://blogs.technet.com/resized-image.ashx/__size/450x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/3480.03.png",
            "https://blogs.technet.com/aggbug.aspx?PostID=3594559",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/150x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7610.Dr.ScriptoForTips.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3594558",
            "https://blogs.technet.com/resized-image.ashx/__size/550x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/1184.1.png",
            "https://blogs.technet.com/resized-image.ashx/__size/350x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7120.2.png",
            "https://blogs.technet.com/aggbug.aspx?PostID=3595732",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/150x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7610.Dr.ScriptoForTips.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3595722",
            "https://blogs.technet.com/aggbug.aspx?PostID=3595745",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/150x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7610.Dr.ScriptoForTips.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3595742",
            "https://blogs.technet.com/aggbug.aspx?PostID=3592800",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/150x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7610.Dr.ScriptoForTips.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3592798",
            "https://blogs.technet.com/resized-image.ashx/__size/550x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/2806.hsg_2D00_9_2D00_17_2D00_13_2D00_1.png",
            "https://blogs.technet.com/resized-image.ashx/__size/550x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/0044.hsg_2D00_9_2D00_17_2D00_13_2D00_2.png",
            "https://blogs.technet.com/resized-image.ashx/__size/550x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7077.hsg_2D00_9_2D00_17_2D00_13_2D00_4.png",
            "https://blogs.technet.com/resized-image.ashx/__size/550x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/2620.hsg_2D00_9_2D00_17_2D00_13_2D00_5.png",
            "https://blogs.technet.com/aggbug.aspx?PostID=3594653",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/150x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7610.Dr.ScriptoForTips.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3594650",
            "https://blogs.technet.com/aggbug.aspx?PostID=3596551",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/150x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7610.Dr.ScriptoForTips.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3596548",
            "https://blogs.technet.com/resized-image.ashx/__size/400x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/3276.01.png",
            "https://blogs.technet.com/aggbug.aspx?PostID=3596545",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/150x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7610.Dr.ScriptoForTips.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3596578",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/150x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7610.Dr.ScriptoForTips.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3596271",
            "https://blogs.technet.com/aggbug.aspx?PostID=3596290",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/150x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7610.Dr.ScriptoForTips.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3596289",
            "https://blogs.technet.com/resized-image.ashx/__size/550x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/8132.01.png",
            "https://blogs.technet.com/aggbug.aspx?PostID=3596564",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/150x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/7610.Dr.ScriptoForTips.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3596563",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/q-sm.jpg",
            "https://blogs.technet.com/resized-image.ashx/__size/550x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-76-18/0184.01.PNG",
            "https://img.microsoft.com/library/media/1033/technet/images/scriptcenter/qanda/a-sm.jpg",
            "https://blogs.technet.com/aggbug.aspx?PostID=3596576",
            "https://augustacrime.com/wp-content/uploads/2017/01/imageCRESTONCURRY.jpg",
            "https://www.trueshayari.in/wp-content/uploads/2018/12/Mahadev-Status-in-Hindi.jpg",
            "https://busyteacher.org/uploads/posts/2012-11/thumbs/1353086477_make-or-do-collocations-key-0.png",
            "https://2.bp.blogspot.com/-sI9NCiZooEI/WLgKcr_Uh3I/AAAAAAAAKZ0/CsJRU0aVqYs0wQpfjkAUAK7rfmvZbvzeQCPcB/s320/3252.windows-server-2016.png",
            "https://1.bp.blogspot.com/-_msqplafums/WoFP6BwVd6I/AAAAAAAAJiE/juU5uOC6Bb04hWSl3jpnZ5hFowZxDCZAwCLcBGAs/s1600/email2.PNG",
            "https://4.bp.blogspot.com/-P7HUlhcqRgI/UnCno2XjJQI/AAAAAAAAFZ4/pdetT2Y6c4I/s400/526ede69b2b18.image.jpg",
            "https://3.bp.blogspot.com/-tMQtu4f6dsc/Urb0sD55GxI/AAAAAAAA9gU/FL-p5wroTYw/s1600/INPUT.bmp.jpg",
            "https://busyteacher.org/uploads/posts/2015-06/thumbs/1434962640_crossword-months-0.png",
            "https://chrisukorg.files.wordpress.com/2015/02/perry.jpg?w=529&h=511",
            "https://3.bp.blogspot.com/-HBHyCcGBgf8/Wn1yke7zLmI/AAAAAAAAEhI/K7xGK0DnW94EUDg4PXG7m9d5uDemlygEgCLcBGAs/s400/class12-bilogy-ncert-solutions-in-hindi-ch3-2.png",
            "https://s3.amazonaws.com/nixle/uploads/pub_media/md/user24872-1464275450-media1_a5a7a6_240_180_PrsMe_.jpeg",
            "https://u.footballfonts.com/img/portugal-2020-ttf-font.jpg",
            "https://i.pinimg.com/originals/e6/33/6d/e6336d1dad962eae5f8162806efe68ce.png",
            "https://i2.wp.com/www.twincities.com/wp-content/uploads/2019/06/Cha-e1560483258563.jpg?fit=620%2C9999px&ssl=1",
            "https://2.bp.blogspot.com/-7TLcIsTWCRM/WJdhZJ8T1vI/AAAAAAAANlA/7-XTO95WE1494iVWxC5MIpWXckxuscj3QCLcB/s640/meenakshi%2Bjoshi%2Banchor.jpg",
            "https://www.digitalkhabar.in/wp-content/uploads/मतलबी-दोस्त-स्टेट्स.jpg",
            "https://4.bp.blogspot.com/-D2ybkIpqREU/Wti4IoCYwLI/AAAAAAAABEg/UTVmhPWy1QcrZg6t-w8mJpp49Ho6MfwfQCLcBGAs/s640/Anasuya%2B3.png",
            "https://3.bp.blogspot.com/-NP1u31H_hVE/WIJo02ELdQI/AAAAAAAAADY/eCMDy6ZuNoESiAXT9rhyePg9W9gujKiKwCEw/s400/p.txt.jpg",
            "https://www.workloadautomation-community.com/uploads/1/0/2/7/102707030/published/bhoodev.jpg?1560455651",
            "https://www.thesun.co.uk/wp-content/uploads/2024/07/jack-grealish-shares-uefa-super-839674000_761ccd.jpg?strip=all&w=960",
            "https://www.thescottishsun.co.uk/wp-content/uploads/sites/2/2019/07/67302885_2419537418323947_143173275978039296_n.jpg?strip=all&w=293",
            "https://www.thesun.ie/wp-content/uploads/sites/3/2024/07/NINTCHDBPICT000918992384.jpg?strip=all&w=960",
            "https://community.fabric.microsoft.com/t5/image/serverpage/image-id/1137046i4A379712E3E9ECAD/image-size/large?v=v2&px=999",
            "https://i.etsystatic.com/5737923/r/il/9944e2/2883793955/il_570xN.2883793955_p3u0.jpg",
            "https://chitralekha.com/chitralemag/wp-content/uploads/2021/11/bollywood-baten-300x177.jpg",
            "https://i.etsystatic.com/5411265/r/il/86a5b7/1092609551/il_570xN.1092609551_o0j6.jpg",
            "https://www.thesportsbank.net/wp-content/uploads/2020/09/pierre-emile-hojberg.jpg",
            "https://i.etsystatic.com/5131289/r/il/324669/1904491948/il_570xN.1904491948_czgu.jpg",
            "https://www.recordshopx.com/cover/normal/9/96/962000.jpg?lp",
            "https://media2.thecoast.ca/thecoast/imager/u/blog/33268615/fw8bewmwyaa3tng.jpg?cb=1721664196"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "//www.rssing.com/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Summary: Learn about cmdlets developed by the community for Orchestrator.\n\nHey, Scripting Guy!\n\nI was looking, and I could not find any cmdlets to manage Orchestrator. Can you nudge me in the right direction?\n\n—KC\n\nHello KC,\n\nHonorary Scripting Guy, Sean Kearney is here continuing to fill in for Ed while he pokes around a binary tree to see if its leaves have changed.\n\nSo although there are no built-in cmdlets for Orchestrator at this time, there is a powerful following in the community. On CodePlex, there is a module that was developed by a member of the community that addresses this issue by leveraging the supplied web service from Orchestrator: Community Project for System Center Orchestrator (SCORCH) Integration Packs and Utilities.\n\nAll we have to do is download the module, import it, and play with the cmdlets it offers. When you download the module, it will come out as a .zip file. You’ll need to extract it, of course. I extracted mine to a Folder called C:\\Scorch:\n\nAfter you extract the structure, you will find a Windows PowerShell script called Deploy.ps1. Run this script within Windows PowerShell to install the module in your system. You need Administrative credentials to use this feature.\n\nThe module is now installed and registered as an available module. If you need to reload it, simply run:\n\nIMPORT-MODULE Scorch\n\nTo get a list of cmdlets that are available, we can run the following command:\n\nGET-COMMAND –module Scorch\n\nThe author has provided us with nine new cmdlets to manage our Orchestrator environment from Windows PowerShell. If you check further, there are also some sample scripts that show how to leverage these cmdlets.\n\nAll of these cmdlets request the URL for the web service. Our good friend has been kind enough to save us the typing. Simply use this cmdlet with the name of the Orchestrator server (of course, replace MYORCHSERVER with the name of your Orchestrator server):\n\n$OWS=New-ScoWebserverURL –servername MYORCHSERVER\n\nYou can now leverage Windows PowerShell to perform tasks like identifying your runbook server:\n\n(GET-SCORunbookServer –WebServerUrl $OWS).Server.Name\n\nOr possibly, you want to list all the runbooks that are available:\n\nGET-SCOMonitorRunbook –WebServerUrl $OWS | format-table\n\nYou can now externally start a runbook manually (without launching the Orchestrator Runbook Designer interface or relying on the schedule within):\n\n$rb=Get-SCOMonitorRunbook -webserverURL $web | where { $_.Name -eq 'Monitor Email' }\n\nStart-SCORunbook -webserverURL $web -RunbookGuid $rb.Id\n\nOr possibly, you want to stop one:\n\n$rb=Get-SCOMonitorRunbook -webserverURL $web | where { $_.Name -eq 'Monitor Email' }\n\n$list=GET-Scojob –webserverurl $ows –alljobs\n\n$RBstop=$list.job | where { $_.Job.Status –eq ‘Running’ –and $_.Job.RunbookID –eq $rb.RunbookID }\n\n$RBstop | STOP-SCOjob –webserverurl $ows\n\nMuch like Windows PowerShell, Orchestrator has a powerful community following that is helping to enhance and build the product.\n\nSo there you have it…many of the bits, pieces, and catch 22s I’ve picked up for Windows PowerShell and Orchestrator. Hopefully with what I’ve passed along, you have a little more time to yourself each day knowing how easy you can leverage these technologies together!\n\nI invite you to follow the Scripting Guys on Twitter and Facebook. If you have any questions, send email to scripter@microsoft.com, or post your questions on the Official Scripting Guys Forum. See you tomorrow. Until then, peace.\n\nSean Kearney, Honorary Scripting Guy\n\nWindows PowerShell MVP\n\nSummary: Use a hash table to play musical notes in the console.\n\nHonorary Scripting Guy, Sean Kearney, here—filling in for our good friend, Ed Wilson.\n\nToday I decided to have some fun. It’s the weekend, I was bored, and I had too much time on my hands. (I have friends who suggest this happens a lot!)\n\nI knew that in Windows PowerShell, I can make a beep noise by executing this:\n\n[console]::beep(500,100)\n\nIf you check online, you will see that two values can be played with. The first is the frequency and the second is the duration. So if you want to drive the family dog (or possibly most of the people at the breakfast table) bonkers, you could do something like this\n\n[console]::beep(7000,65000)\n\nOf course we like the family dog, so we’re not going to actually do this. But it shows that we can alter frequencies and durations of the sound. So this is where my brain got bored. I wanted to do something that I hadn’t done in a very, very, very long time.\n\nI wanted to turn my computer into a piano. It’s something I had done a long time ago on my old Commodore Vic 20. Granted, the console beep has none of the features I had on my Vic 20, or even in the early Commodore 64 SID chip. But I can make noise.\n\nSo I mucked about and figured out the notes for my piano by ear and by singing “Do Re Mi Fa So La Ti Do” about a hundred times. No, I didn’t sit down with a proper tuning fork, so for the most part, my notes are about as on-key as an angry parrot singing.\n\nHere is my scale (my very off-key scale, I might add!) created in Windows PowerShell:\n\n[console]::beep(290,400)\n\n[console]::beep(330,400)\n\n[console]::beep(360,400)\n\n[console]::beep(390,400)\n\n[console]::beep(440,400)\n\n[console]::beep(480,400)\n\n[console]::beep(530,400)\n\n[console]::beep(580,400)\n\nCool. I’ve got some notes. Now for challenge number two…\n\nI need a way to listen to the keyboard. Fortunately, this is actually pretty easy. By using the $Host variable and the following technique, we can listen to the keyboard:\n\n$Key=$HOST.UI.RawUI.ReadKey(\"NoEcho,IncludeKeyDown\")\n\nThis will allow us to wait until any key on the keyboard is pressed. Not the “ANYKEY”—they’ve stopped shipping that in newer models of computers.\n\nWe’ll have to run an additional command to make sure a pile of keys don’t build up in the keyboard queue:\n\n$HOST.UI.RawUI.Flushinputbuffer()\n\nTry this in your Windows PowerShell console: Tap the letter H, and you’ll notice some interesting results in the value of $Key:\n\nYou’ll see it traps the ASCII value of the key entered, in addition to the actual string content. So we know that we have an easy way to listen to the keyboard and retrieve information from it.\n\nLet’s pick a set of characters for the “Piano” keyboard. We’ll take the regular notes (not sharp or flat) first, starting as the letter Q:\n\nQWERTYUIOP\n\nAnd then for the other notes, we’ll use appropriate numeric keys:\n\n23 567 90\n\nSo our keyboard will look like this:\n\n2 3 5 6 7 9 0\n\nQWERTYUIOP\n\nBut how will we match the keys to the notes? A big nasty pile of IF statements?\n\nNo, this is a perfect opportunity to set up a hash table. We’ll match the keys to each note value. I’ve also taken the liberty to add in some additional notes, such as the missing sharps, and a few extra notes beyond the base scale:\n\n[array]$piano=$NULL\n\n$piano+=@{\"Q\"=290}\n\n$piano+=@{\"2\"=310}\n\n$piano+=@{\"W\"=330}\n\n$piano+=@{\"3\"=345}\n\n$piano+=@{\"E\"=360}\n\n$piano+=@{\"R\"=390}\n\n$piano+=@{\"5\"=415}\n\n$piano+=@{\"T\"=440}\n\n$piano+=@{\"6\"=460}\n\n$piano+=@{\"Y\"=480}\n\n$piano+=@{\"7\"=505}\n\n$piano+=@{\"U\"=530}\n\n$piano+=@{\"I\"=580}\n\n$piano+=@{\"9\"=605}\n\n$piano+=@{\"O\"=630}\n\n$piano+=@{\"0\"=670}\n\n$piano+=@{\"P\"=710}\n\nLovely. We have a list of keys matched to numbers. If only there was an easy way to search an array for information…\n\nBut of course, in Windows PowerShell there is! Simply plug the value you’re looking for into the array. If it matches any entries, it will return them. For example, to find the entry that contains “T”, enter:\n\nOooo! So a simple little line like this should play a note after hitting a key:\n\n$Key=$HOST.UI.RawUI.ReadKey(\"NoEcho,IncludeKeyDown\")\n\n$HOST.UI.RawUI.Flushinputbuffer()\n\n$Note=$Piano.($Key.Character)\n\n[Console]::Beep($Note,100)\n\nSo our loop would look something like this if we wanted to play it forever and ever and ever:\n\nDO {\n\n$Key=$HOST.UI.RawUI.ReadKey(\"NoEcho,IncludeKeyDown\")\n\n$HOST.UI.RawUI.Flushinputbuffer()\n\n$Note=$Piano.($Key.Character)\n\n[Console]::Beep($Note,100)\n\n} Until ($False)\n\nCome back tomorrow, and we’ll build on these ideas in an even more interesting toy, including a little error trapping and visualization!\n\nI invite you to follow the Scripting Guys on Twitter and Facebook. If you have any questions, send email to scripter@microsoft.com, or post your questions on the Official Scripting Guys Forum. See you tomorrow. Until then, peace.\n\nSean Kearney,\n\nHonorary Scripting Guy and Windows PowerShell MVP\n\nSummary: Use Windows PowerShell to interact with the console display.\n\nHonorary Scripting Guy, Sean Kearney, here—filling in for our good friend, Ed Wilson.\n\nFor some reason, I find a need to open today’s blog post like a soap opera—you know, “Last time for Sean Kearney on the Hey, Scripting Guys! Blog.”\n\nSigh, it feels that way…\n\nLast time, we played with a hash table and keyboard input to create a simple toy to play with—a loud, off-key piano in Windows PowerShell. It is somewhat (but not much) worse than my singing voice.\n\nToday we’re going to polish it off a bit. A little error trapping. And how about an actual keyboard on the screen to interact with our piano?\n\nFirst, I’ll show you a simple keyboard that I spent all day drawing up (or maybe it was only my lunch hour):\n\n[array]$keyboard=$Null\n\n$keyboard+=\"\"\n\n$keyboard+=\" _____________________________________________________________\"\n\n$keyboard+=\" ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !\"\n\n$keyboard+=\" ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !\"\n\n$keyboard+=\" ! !___! !___! ! !___! !___! !___! ! !___! !___! !\"\n\n$keyboard+=\" ! ! ! ! ! ! ! ! ! ! !\"\n\n$keyboard+=\" ! ! ! ! ! ! ! ! ! ! !\"\n\n$keyboard+=\" !_____!_____!_____!_____!_____!_____!_____!_____!_____!_____!\"\n\n$keyboard+=\"\"\n\n$keyboard+=\" *** Be A True Rockstar and Use WindowsPowerShell *** \"\n\nThis may not be a fancy keyboard, but it will work nicely. We are going to map the keyboard that we built yesterday to physical positions on the screen.\n\nWhat am I trying to do?\n\nI am going to make sure that every time I hit a note on the keyboard, a key is highlighted on the screen. So we’ll need to identify the row and column for each note.\n\nThe first part is easy. All sharps are on one row (upper), and the rest of the keys are on the lower row. I played with the following combinations to set the positions on the screen:\n\n$Location=$Host.UI.RawUI.cursorposition\n\n$Location.Y=4\n\n$Location.X=10\n\n$Host.UI.RawUI.cursorposition=$Location; WRITE-HOST “*”\n\nBy altering values of Y, I was able to determine my rows:\n\nUpper 3\n\nLower 6\n\nNext, the less tricky part was to figure out the first position for each set of keys. After playing with the previous set of cmdlets and altering the value of X, I was able to determine the starting point for each: the lower row starts at position 6 and the upper row starts at position 9.\n\nFrom that point, it was a matter of some simple math to determine the remaining columns because each key is exactly 6 points apart.\n\nSo now for some fun. Because we need to apply the X and Y coordinates based on the key that is tapped on the piano keyboard, we have to extend our original hash table as follows by adding a column to hold the Y and X values respectively for each key to display:\n\n[array]$piano=$NULL\n\n$piano+=@{\"Q\"=290,6,6}\n\n$piano+=@{\"2\"=310,3,9}\n\n$piano+=@{\"W\"=330,6,12}\n\n$piano+=@{\"3\"=345,3,15}\n\n$piano+=@{\"E\"=360,6,18}\n\n$piano+=@{\"R\"=390,6,24}\n\n$piano+=@{\"5\"=415,3,27}\n\n$piano+=@{\"T\"=440,6,30}\n\n$piano+=@{\"6\"=460,3,33}\n\n$piano+=@{\"Y\"=480,6,36}\n\n$piano+=@{\"7\"=505,3,39}\n\n$piano+=@{\"U\"=530,6,42}\n\n$piano+=@{\"I\"=580,6,48}\n\n$piano+=@{\"9\"=605,3,51}\n\n$piano+=@{\"O\"=630,6,54}\n\n$piano+=@{\"0\"=670,3,57}\n\n$piano+=@{\"P\"=710,6,60}\n\nWith the values of the potential X and Y positions mapped to each key, we can search like before. But now, it will return not only the note, but also the Y and X coordinates for each key.\n\nWe can use a simple piece of script like the following to obtain the current location, and then write some information to the screen:\n\n$Location=$Host.UI.RawUI.cursorposition\n\n$Location.Y=$keyboarddata[1]\n\n$Location.X=$keyboarddata[2]\n\n$Host.UI.RawUI.CursorPosition=$Location\n\nWRITE-HOST “*”\n\nTo return the original cursor position and erase the information, we can simply reset the position:\n\n# Insert a Command we might do to eat up time, like maybe our [console]::beep(500,200)\n\n$Host.UI.RawUI.cursorposition=$Location\n\nWRITE-HOST \" \"\n\nSo really, we’re going to have a loop that runs forever. Or we could insert a special key—maybe such as “ESC”ape to “Escape” the loop?\n\ndo {\n\n# Wait until some fool hits the keyboard\n\n# We're not going to show the key on the screen\n\n# And yes, we'll include Shift, Control and all the others\n\n$Key=$Host.UI.RawUI.ReadKey(\"NoEcho,IncludeKeyDown\")\n\n# Now flush it away so we don't get a pile of keys\n\n# backing up in the queue (Flush? Backup? Ewww)\n\n$Host.UI.RawUI.Flushinputbuffer()\n\n# Grab the character from the $key Object and Match\n\n# It Against the Array\n\n$KeyboardData=$Piano.($Key.Character)\n\n# Now IF we found something of value\n\n# PLAY IT\n\nIf ($KeyboardData) {\n\n$note=$KeyboardData[0]\n\n$Location=$Host.UI.RawUI.cursorposition\n\n$Location.Y=$keyboarddata[1]\n\n$Location.X=$keyboarddata[2]\n\n$Host.UI.RawUI.cursorposition=$Location\n\nWRITE-HOST \"*\"\n\n[console]::beep($note,150)\n\n$Host.UI.RawUI.cursorposition=$Location\n\nWRITE-HOST \" \"\n\n}\n\n# Key having fun until Somebody tries to ESCape\n\n# Get it? Hit's the ESCape key? Bad Pun?\n\n} until ( $key.VirtualKeyCode -eq 27 )\n\nThere you have it. A silly but fun project in Windows PowerShell that leverages hash tables and the console.\n\nFor some fun trivia, I did actually try to launch multiple beeps through different Windows PowerShell consoles to try to generate chords. No good. Doesn’t work. Although I would love to figure out later how to generate MIDI tones via Windows PowerShell. That could be more interesting.\n\nIf you don’t feel like doing a lot of typing, download it here from the TechNet Gallery: A Windows PowerShell Piano.\n\nI invite you to follow the Scripting Guys on Twitter and Facebook. If you have any questions, send email to scripter@microsoft.com, or post your questions on the Official Scripting Guys Forum. See you tomorrow. Until then, peace.\n\nSean Kearney,\n\nHonorary Scripting Guy and Windows PowerShell MVP\n\nSummary: Guest blogger, Bob Stevens, revises his script for conditional user profile removal.\n\nMicrosoft Scripting Guy, Ed Wilson, is here. I am happy to welcome back guest blogger, Bob Stevens. Take it away Bob…\n\nPreviously I released a blog post entitled Weekend Scripter: Use PowerShell for Conditional User Profile Removal. If you have not read this post, please do because it is necessary so that you’ll understand what I am talking about today.\n\nIt was pointed out to me that Windows Vista and later operating systems create temporary user directories instead of re-creating the directories when the user next signs in. To start at a reference point, here is the original script that I created:\n\nIF ((Get-WmiObject Win32_OperatingSystem).version -like “5*”) {\n\n$over30dayprofiles = @(Get-ChildItem -force \"C:\\Documents and Settings\" | Where {\n\n((Get-Date)-$_.lastwritetime).days -ge 30\n\n} )\n\n}\n\nIF ((Get-WmiObject Win32_OperatingSystem).version -like “6*”) {\n\n$over30dayprofiles = @(Get-ChildItem -force \"C:\\Users\" | Where {\n\n((Get-Date)-$_.lastwritetime).days -ge 30\n\n} )\n\nSet-Content \".\\over30dayprofiles.txt\" $over30dayprofiles\n\n$over30dayprofiles = @(Get-Content \".\\over30dayprofiles.txt\" | Foreach-Object {\n\n$_ -replace 'Administrator', '' `\n\n-replace 'LocalService', '' `\n\n-replace 'NetworkService', ''\n\n} | Select-String -pattern \"\\w\" | ForEach-Object { $_.line })\n\n$count = $over30dayprofiles.count\n\n$i = 0\n\nSet-Location 'C:\\Documents and Settings'\n\nDo {\n\nRemove-Item -force -recurse $over30dayprofiles[$i]\n\n$i++\n\n}\n\nUntil($i -ge $count)\n\nThe first alteration that we need is to add a message to the user in the event that there are no profiles to remove. To do so, directly after we remove the desired accounts and white space from the variable $over30dayprofiles, we add the following:\n\nIf ($over30dayprofiles.count -eq 0){Write-Host \" all profiles have been accessed in the last 30 days\"}\n\nIf ($over30dayprofiles.count -gt 0){\n\nBecause of the brace that is located at the end of the second IF statement, we need to add a closing brace at the end of the script. This will run the command inside the script only when there are profiles that have not been accessed within the past 30 days.\n\nDirectly after that, we add the command to determine the SID of each profile that we are going to remove. First we need to define in a variable the number of profiles that we are going to remove:\n\n$count = $over30dayprofiles.count\n\nThe Count property simply counts the items in the $over30dayprofiles array. Next we need to state that this is only to berunin any version of Windows 6 and later. I explained how to do this in another previous post: Weekend Scripter: Use PowerShell for Conditional User Profile Removal.\n\nIF ((Get-WmiObject Win32_OperatingSystem).version -like “6*”) {}\n\nInside the braces, we are going to use the WMI object Win32_userprofile. To do this, we need to use the Get-WMIobject cmdlet to call Win32_userprofile:\n\nGet-WMIobject win32_userprofile\n\nBecause we only want two properties (SID and Path), we are going to filter it by using the pipe operator (|) followed by the Select cmdlet:\n\nGet-WMIobject win32_userprofile | select\n\nThe property types are the same for all profiles, so no quotations are needed. We simply need to separate them by a comma and a space:\n\nGet-WMIobject win32_userprofile | Select SID, Localpath\n\nWe are going to manipulate this further, so we pipe it into the file named ProfileInfo.txt:\n\nGet-WMIobject win32_userprofile | Select SID, Localpath | Out-File .\\ProfileInfo.txt\n\nThe next portion of the script utilizes a Do-Until loop, so we set a counter at 0:\n\n$i = 0\n\nNow let’s create the item that we are going to be manipulating:\n\nNew-Item -path .\\SID.txt -itemtype File\n\nAnd finally, we can start the Do-Until loop:\n\nDo{}\n\nUntil()\n\nInside the braces that follow the Do statement, we are going to pull the contents of ProfileInfo.txt, select any string that has the currently selected value from the $over30dayprofiles array, and split the line at the first whitespace that occurs. This is done by first retrieving the data, and then selecting the line:\n\nGet-Content .\\ProfileInfo.txt | Select-String -pattern $over30dayprofiles[$i] |\n\nNow we split the line at the first white space by using a regular expression:\n\nForeach-Object { $_ -split ’\\s+’ }\n\nAnd we select the first half of the string:\n\nForEach-Object { $_ -split '\\s+' | select -f 1}\n\nIf we append this command to the end of the content and set the output location, this is the result:\n\nGet-Content .\\ProfileInfo.txt | Select-String -pattern $over30dayprofiles[$i] | ForEach-Object { $_ -split '\\s+' | select -f 1} | Add-Content .\\SID.txt\n\nNow we nest this into the Do portion of our Do-Until loop, and add the escape value. An escape value is a predetermined number that will end the loop when the counter meets the inequality presented by the Until or While statements.\n\nDo {\n\nGet-Content .\\ProfileInfo.txt | Select-String -pattern $over30dayprofiles[$i] | ForEach-Object { $_ -split '\\s+' | select -f 1} | Add-Content .\\SID.txt\n\n$i++}\n\nUntil($i -ge $count)\n\nAs you can see, the escape value is $i when our counter reaches a value greater than $count. $count is the number of elements in the $over30daysprofiles array.\n\nIF ((Get-WmiObject Win32_OperatingSystem).version -like “6*”) {\n\nGet-WMIobject win32_userprofile | select SID, Localpath | Out-File .\\ProfileInfo.txt\n\n$i = 0\n\nNew-Item -path .\\SID.txt -itemtype File\n\nDO {\n\nget-content .\\ProfileInfo.txt | Select-String -pattern $over30dayprofiles[$i] | ForEach-Object {\n\n$_ -split '\\s+' | select -f 1\n\n} | Add-Content .\\SID.txt\n\n$i++\n\n}\n\nUntil($i -ge $count)\n\n$SID = @(Get-Content .\\SID.txt)\n\nNow we are going to take the contents of the SID.txt file, and set them as the values for another array, $SID:\n\n$SID = @(Get-Content .\\SID.txt)\n\nBecause this script is to be run on any current computer, we need to add the following line so that we are working out of the Documents and Settings folder:\n\nIF ((Get-WmiObject Win32_OperatingSystem).version -like “5*”) {Set-Location 'C:\\Documents and Settings'}\n\nFor the sake of clarity, the next set of script will be explained in its entirety.\n\nFirst we set our counter and Do-Until statement:\n\n$i = 0\n\nDo {}\n\nUntil()\n\nNow we add the conditional IF statements:\n\n$i = 0\n\nDo {\n\nIF(){}\n\nIF(){}\n\n}\n\nUntil()\n\nNext we add our operating system identifiers by using the WMI object we have already been using:\n\n$i = 0\n\nDo {\n\nIF((Get-WmiObject Win32_OperatingSystem).version -like “5*”){}\n\nIF((Get-WmiObject Win32_OperatingSystem).version -like “6*”){}\n\n}\n\nUntil()\n\nHere is where the script changes depending on the operating system. For version 5 operating systems, we need to simply remove the profile folders because they will re-create if the user signs in again. It was suggested that I use the utility Delprof for this, but because there is no way to differentiate between administrator accounts and user accounts, we will go with this:\n\n$i = 0\n\nDo {\n\nIF((Get-WmiObject Win32_OperatingSystem).version -like “5*”){\n\nRemove-Item -force -recurse $over30dayprofiles[$i]}\n\nIF((Get-WmiObject Win32_OperatingSystem).version -like “6*”){}\n\n}\n\nUntil()\n\nNow we move on to what actually changed. As expressed in the comments from the previous post, when you delete the profile folder from the Users folder in Windows Vista and later, the operating system will continually generate a temporary profile because the registry key located at:\n\n“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList”\n\nSo instead of removing the profile folder or doing some truly interesting stuff with the registry, we are going to use the win32_userprofile WMI object, this bit of script is courtesy of the user, JRV. Specifically, we are going to filter it for the SID in the $SID array that corresponds with the counter, and we are going to set this as the value of the $profile variable:\n\n$profile = Get-WmiObject win32_userprofile -filter \"SID='$($SID[$i])'\"\n\nNow that we have the $profile variable defined with the desired SID, we are going to delete the profile that it refers to. This is done with the Delete() property (this will NOT work without the empty parentheses).\n\n$profile.delete()\n\nNow we add these two lines together and nest them in our second IF statement:\n\n$i = 0\n\nDo {\n\nIF((Get-WmiObject Win32_OperatingSystem).version -like “5*”){Remove-Item -force -recurse $over30dayprofiles[$i]}\n\nIF((Get-WmiObject Win32_OperatingSystem).version -like “6*”){ $profile = Get-WmiObject win32_userprofile -filter \"SID='$($SID[$i])'\"\n\n$profile.delete()}\n\n}\n\nUntil()\n\nWe need to add the rest of the script to increment the counter:\n\nDo {\n\nIF((Get-WmiObject Win32_OperatingSystem).version -like “5*”){Remove-Item -force -recurse $over30dayprofiles[$i]}\n\nIF((Get-WmiObject Win32_OperatingSystem).version -like “6*”){ $profile = Get-WmiObject win32_userprofile -filter \"SID='$($SID[$i])'\"\n\n$profile.delete()}\n\n$i++\n\n}\n\nUntil($i -ge $count)\n\nAnd finally, we need to close the brace that we left open with If “($over30dayprofiles.count -gt 0){“ and clean up our temporary files:\n\nRemove-Item .\\over30dayprofiles.txt\n\nRemove-Item .\\ProfileInfo.txt\n\nRemove-Item .\\SID.txt\n\n}\n\nFollowing is the complete and working script. Although it will generate errors if there is an issue with the accounts being removed, it will function on all others. These errors are reported, and the script will continue to run to completion. I have used Bold formatting to highlight the sections that have been added. _____________________________________________________________\n\nSet-Location $home\\desktop\n\nNew-Item -path .\\over30dayprofiles.txt -itemtype File\n\nIF ((Get-WmiObject Win32_OperatingSystem).version -like “5*”) {\n\n$over30dayprofiles = @(Get-ChildItem -force \"C:\\Documents and Settings\" | Where {\n\n((Get-Date)-$_.lastwritetime).days -ge 30\n\n} )\n\n}\n\nIF ((Get-WmiObject Win32_OperatingSystem).version -like “6*”) {\n\n$over30dayprofiles = @(Get-ChildItem -force \"C:\\Users\" | Where {\n\n((Get-Date)-$_.lastwritetime).days -ge 30\n\n} )\n\n}\n\nSet-Content \".\\over30dayprofiles.txt\" $over30dayprofiles\n\n$over30dayprofiles = @(Get-Content \".\\over30dayprofiles.txt\" | Foreach-Object {\n\n$_ -replace 'Administrator', '' `\n\n-replace 'LocalService', '' `\n\n-replace 'NetworkService', ''`\n\n-replace 'desktop.ini', ''`\n\n-replace 'temp', ''`\n\n-replace 'All Users', ''`\n\n-replace 'Default', ''`\n\n-replace 'Default User', ''`\n\n-replace 'Public', ''`\n\n-replace ' User', ''\n\n} | Select-String -Pattern \"\\w\" | ForEach-Object { $_.line })\n\nIf ($over30dayprofiles.count -eq 0){Write-Host \"all profiles have been accessed in the last 30 days\"}\n\nIf ($over30dayprofiles.count -gt 0){\n\n$count = $over30dayprofiles.count\n\nIF ((Get-WmiObject Win32_OperatingSystem).version -like “6*”) {\n\nget-WMIobject win32_userprofile | select SID, Localpath | Out-File .\\ProfileInfo.txt\n\n$i = 0\n\nNew-Item -path .\\SID.txt -itemtype File\n\nDO {\n\nGet-Content .\\ProfileInfo.txt | Select-String -pattern $over30dayprofiles[$i] | ForEach-Object {\n\n$_ -split '\\s+' | select -f 1\n\n} | Add-Content .\\SID.txt\n\n$i++\n\n}\n\nUntil($i -ge $count)\n\n$SID = @(Get-Content .\\SID.txt)}\n\nIF ((Get-WmiObject Win32_OperatingSystem).version -like “5*”) {Set-Location 'C:\\Documents and Settings'}\n\n$i = 0\n\nDo {\n\nIF((Get-WmiObject Win32_OperatingSystem).version -like “5*”){\n\nRemove-Item -force -recurse $over30dayprofiles[$i]\n\n}\n\nIF((Get-WmiObject Win32_OperatingSystem).version -like “6*”) {\n\n$profile = Get-WmiObject win32_userprofile -filter \"SID='$($SID[$i])'\"\n\n$profile.Delete()\n\n}\n\n$i++\n\n}\n\nUntil($i -ge $count)\n\nRemove-Item .\\over30dayprofiles.txt\n\nRemove-Item .\\ProfileInfo.txt\n\nRemove-Item .\\SID.txt\n\n}\n\nThe complete script is uploaded to the Script Center Repository: Over 30 Day Removal. Please download it from there, rather than attempting to copy from this web page. As with my previous posts, I welcome all critiques. It is my firm belief that anything can be improved by the collective knowledge of the community.\n\n~Bob\n\nThank you, Bob, for your time and efforts in writing this blog to share with our readers.\n\nI invite you to follow me on Twitter and Facebook. If you have any questions, send email to me at scripter@microsoft.com, or post your questions on the Official Scripting Guys Forum. See you tomorrow. Until then, peace.\n\nEd Wilson, Microsoft Scripting Guy\n\nSummary: Guest blogger, system admin Marc Carter, talks about recursively searching AD security groups with Windows PowerShell.\n\nMicrosoft Scripting Guy, Ed Wilson, is here. Marc Carter is back with us today as our guest blogger. Marc is a system administrator at the Corpus Christi Army Depot. Take it away, Marc…\n\nLike many other mid- to large-sized organizations, we use Active Directory Security Groups to help us manage access and permissions to our organization’s various IT resources (such as file shares and Microsoft SharePoint). By nesting those security groups, we create a parent/child hierarchy that is representative of our organization’s business structure. Throughout most of that business structure, our end-user environment consists of a standard pyramid of three primary groups:\n\nFew: executive-level management\n\nSeveral: mid-level chiefs\n\nMany: staff members\n\nEmployee’s positions within that hierarchy dictate the level of access they have to subordinate resources. The higher you are in the organization’s hierarchy, the more resources you have access to. Members at the staff-level typically only require access to resources that impact their daily tasks and duties, and they aren’t concerned with resources outside their office or work area. Moving up the pyramid, chiefs and executives need access at their level and to the subordinate resources directly under them. We accomplish this one-to-many relationship by adding groups as “Members” to their subordinate security groups.\n\nThankfully, the Active Directory cmdlets that come with Windows PowerShell 2.0 make it extremely easy to view and manage members of an Active Directory group. By using the Get-ADGroupMember command, you can view the member objects of a group by simply specifying an identity value. In fact any one of the following four options can be used to identify which group you’re interested in:\n\nDistinguishedName\n\nGUID (objectGUID)\n\nSecurity Identifier (objectSid)\n\nSecurity Accounts Manager (SAM) Account Name (SAMAccountName)\n\nIn the following example, I’m using the SAMAccountName of one of the mid-level chief groups to return a list of members.\n\nText version:\n\nGet-ADGroupMember -Identity “alpha-chiefs”\n\ndistinguishedName : CN=roger.moore,OU=Users,OU=M16,DC=contoso,DC=com\n\nname : roger.moore\n\nobjectClass : user\n\nobjectGUID : 00743c39-22a2-415a-812c-062b4af5c349\n\nSamAccountName : roger.moore\n\nSID : S-1-3-21-4201780169-38368224-110244791-28519\n\nUsing the optional Recursive switch returns a list of accounts that have a membership to the specified group. It provides a bottom-up perspective of membership, and it is effective to see who has permissions on a specific resource.\n\nGet-ADGroupMember -Identity “alpha-staff” -Recursive\n\nTypically, this information is sufficient to analyze and manage resources on a daily basis. However, because of change or transition in our operations, we also have a need to assess our memberships from a top-down view to see not only what resources align under the executive or mid-level managers, but also the staff members who belong to those groups.\n\nTo accomplish this, I wrote an advanced function based on the Get-ADGroupMember and Get-ADGroup cmdlets. I use them to traverse the MemberOf attribute and list users within each of the associated subordinate groups.\n\nI begin by defining the VerbosePreference constant and trying to load the Active Directory module (if not already present) within a Try/Catch statement so the script will fail if it’s unable to access the necessary cmdlets:\n\nText version:\n\nTry {\n\nIf(-not(Get-Module -Name \"ActiveDirectory\")){\n\nImport-Module -Name ActiveDirectory\n\n}\n\n} Catch {\n\nWrite-Warning \"Failed to Import REQUIRED Active Directory Module...exiting script!”\n\nWrite-Warning \"`nhttp://technet.microsoft.com/en-us/library/ee617195.aspx\"\n\nBreak\n\n}\n\nWhen the script successfully passes this test, I start the process of collecting and storing information within a PSCustomObject array, again using Try/Catch so I don’t end up collecting superfluous or unnecessary information.\n\nOn line 59 in the following example, I define the $ADGroup variable with the results of the Get-ADGroup cmdlet and include the Members and MemberOf properties. I’m now ready to start my first loop through the Members collection, adding them to my array. I use an array because I want to collect the name of the Active Directory Group where each member belongs as I traverse down. I use splatting to pass my parameters to my array.\n\nHaving recorded all the Members at the current group level, I’m now ready to start my recursion and loop through the MembersOf attribute. This Active Directory property contains all the subordinate groups that the dominate group is a member of (thus the name MemberOf).\n\nPassing this information back to the function, I start the entire process all over again until there are no more subordinate group memberships (that is, MemberOf is empty). I’m now ready to exit my function, but before doing so, I want to display all that information. I simply call the array and then reset the $VerbosePreference constant back to its original state (when I first initiated the script).\n\nI have to point out that our organization has a fairly stringent policy for naming offices and organizations, which makes it easier to sort the data, but this will work for any situation.\n\nUses for this script\n\nFollowing are two of my favorite uses for this script:\n\nUse Group-Object to provide a quick overview of each group and the count of users (members) within each group.\n\nFormat output in a table (or use Out-GridView) to get a detailed list by Group of all the members. This is an effective way to provide our administrative staff with a security group view of our organizational roster. It helps us ensure that only the folks who require access to sensitive information have it.\n\nI hope this information helps you better organize your company’s Active Directory groups, memberships, and permissions. You can download this function from the Script Center Repository: Get-MemberOfGroup.\n\nI look forward to your comments and suggestions.\n\n~Marc\n\nThank you, Marc.\n\nI invite you to follow me on Twitter and Facebook. If you have any questions, send email to me at scripter@microsoft.com, or post your questions on the Official Scripting Guys Forum. See you tomorrow. Until then, peace.\n\nEd Wilson, Microsoft Scripting Guy\n\nSummary: Learn how to use Windows PowerShell to create ACLs for Windows Azure endpoints.\n\nMicrosoft Scripting Guy, Ed Wilson, is here. Windows networking engineer, James Kehr, is back with us today to share more Windows Azure goodies. Now here’s James…\n\nImagine this if you will. I’ve written two rather large blog posts about creating endpoints and ACLs with Windows PowerShell in Windows Azure. Each one was long enough to be considered a good size short story in the literary world. If you would like a frame of reference for this post, here they are:\n\nCreating ACLs for Windows Azure Endpoints—Part 1\n\nCreating ACLs for Windows Azure Endpoints—Part 2\n\nAnd then I see it. An update to the Windows Azure PowerShell module released the day before my deadline. Do I ignore it, or do I install it and make sure my script still works? Better safe than sorry…update goes on…\n\nTest endpoint script. All good.\n\nTest ACL script. Works great.\n\nTest load balanced endpoint script. No problems found.\n\nAwesome. All is well. “Hmmm,” I thought. “Hmmm,” I said aloud. “I wonder if they fixed the -VM parameter?” Sure enough, it works. Now comes the dilemma. Push back the publishing date and rewrite, or move on as planned? The script does work after all. What to do, what to do?\n\nAt this point, a committee was called to order with five executives, sixteen directors, and forty-two middle managers. After six hours of deliberations, a sub-committee of eighty-four Windows PowerShell and Windows Azure experts was created. The sub-committee then formed an action plan, signed in triplicate, carbon copied, emailed, responded to, and replied to all. This generated a massive email storm, which was lost to drive corruption, restored, rechecked, and brought back to the committee. They convened an independent review and gave recommendations to the sub-committee, which was waiting for a secondary audit from Vogon Consulting services, who gave a recommendation to the committee to rewrite the blog. The committee then ignored the recommendations and ordered the blog posts be published as is.\n\nOr at least that’s how some people on the Interwebz might think it happened. In reality this is closer to what really happened…\n\nEd: Hey James, why don’t you just write a follow-up post with the shortened script?\n\nMe: Sure.\n\nEd: Cool, thanks.\n\nWhich brings us to this post—the unexpected Part 3.\n\nACLs done quicker\n\nThis post focuses on making the endpoint and ACL script from Parts 1 and 2 shorter. Specifically how the fixed -VM parameter works and how it can make your script a bit more efficient. I will forego the technical nitty gritty. If you find yourself lost because of this omission, please read Part 1 and Part 2, which is where you will find the technical and script deep dives.\n\nThe first thing you need to do is get the newest Windows Azure PowerShell module. For this script to work you need at least the August 2013 update. The latest standalone installer can be found at: WindowsAzure/azure-sdk-tools.\n\nThis is also a great resource to see what cmdlets have been added since the previous update. This is important to know because the Windows Azure PowerShell module is in constant change, and features that weren’t there last month could very well be there this month. As the Windows Azure features settle and the Windows Azure PowerShell module matures, it won’t change as rapidly, but for now expect change.\n\nThe post-August 2013 Windows Azure PowerShell module script can be changed to this:\n\n# create an endpoint for HTTP\n\n$avm = Get-AzureVM -ServiceName Web01\n\n# create a new ACL\n\n$acl = New-AzureAclConfig\n\n# add some rules to the ACL\n\nSet-AzureAclConfig -AddRule -ACL $acl -Order 0 -Action Permit -RemoteSubnet \"1.2.3.4/31\" -Description \"Allow App01\"\n\nSet-AzureAclConfig -AddRule -ACL $acl -Order 1 -Action Permit -RemoteSubnet \"172.16.0.0/29\" -Description \"Allow corp proxies\"\n\nSet-AzureAclConfig -AddRule -ACL $acl -Order 2 -Action Deny -RemoteSubnet \"0.0.0.0/0\" -Description \"DenyAll\"\n\n# create endpoint\n\nAdd-AzureEndpoint -Name \"HTTP\" -VM $avm -ACL $acl -Protocol tcp -PublicPort 80 -LocalPort 80 | Update-AzureVM\n\nThe big advantage to this technique is that you can make all your changes offline, and then push them to Windows Azure all at once. The AzureVM variable ($avm) stores all your changes. When you are done making changes, simply pipe $avm to Update-AzureVM. Or do what I did, and pipe your final change to Update-AzureVM.\n\nThe fixed -VM parameter also means that you can perform other endpoint and ACL commands without doing a lot of pipeline work.\n\n# get HTTP endpoint\n\nGet-AzureEndpoint -VM $avm -Name http\n\n# get HTTP ACLs\n\nGet-AzureAclConfig -vm $avm -EndpointName http\n\n# remove the HTTP endpoint\n\nRemove-AzureEndpoint -vm $avm -Name HTTP | Update-AzureVM\n\nWhen you run commands this way, please remember that the changes are made to the AzureVMobject and not to the virtual machine. Because of this these cmdlets, using -VM will reflect the object, and not what’s in Windows Azure. If you need to see what’s in Windows Azure, using the older pipeline technique is still the best:\n\nGet-AzureVM -ServiceName Web01 | Get-AzureAclConfig -EndpointName http\n\nA little love for load-balanced endpoints\n\nThere is one gotcha with the -VM parameter that I would like to mention. It currently does not support arrays of AzureVM objects. This means the script for load-balanced endpoints is, at this time, almost unchanged. When you create a new load-balanced endpoint, you can shorten the script a bit, but you must still use the pipeline. The only real difference is that you can now create a variable that contains an array of Windows Azure VM objects. This allows you to queue several changes and then pipe the variable to the update command.\n\n# get VMs in LB set\n\n$avm = Get-AzureVM -ServiceName jak-az-12r2-tst\n\n# create ACL\n\n$acl = New-AzureAclConfig\n\nSet-AzureAclConfig -AddRule -ACL $acl -Order 0 -Action Permit -RemoteSubnet \"1.2.3.4/31\" -Description \"Allow App servers\"\n\nSet-AzureAclConfig -AddRule -ACL $acl -Order 1 -Action Permit -RemoteSubnet \"172.16.0.0/29\" -Description \"Allow corp proxies\"\n\nSet-AzureAclConfig -AddRule -ACL $acl -Order 2 -Action Deny -RemoteSubnet \"0.0.0.0/0\" -Description \"DenyAll\"\n\n# create new load balanced endpoint\n\n$avm | `\n\nAdd-AzureEndpoint -Name \"HTTPS\" -ACL $acl -Protocol TCP -PublicPort 443 -LocalPort 443 -ProbePort 3443 -ProbeProtocol HTTP -ProbePath \"/” -LBSetName \"Web-HTTPS-LB\" | `\n\nUpdate-AzureVM\n\nThat does it for Windows endpoints and ACLs. I even kept this post down to short-short-story length. I hope to publish a few more Windows Azure PowerShell blog posts in the near future, so stay tuned.\n\n~James\n\nThank you for sharing, James.\n\nI invite you to follow me on Twitter and Facebook. If you have any questions, send email to me at scripter@microsoft.com, or post your questions on the Official Scripting Guys Forum. See you tomorrow. Until then, peace.\n\nEd Wilson, Microsoft Scripting Guy\n\nSummary: Learn about Updatabe Help in Windows PowerShell 3.0.\n\nScripting Guy, Ed Wilson here. Today June Blender is back to tell us about Updatable Help in Windows PowerShell 3.0. Take it away, June…\n\nOne of the great advances in Windows PowerShell 3.0 is Updatable Help. The advantages of updating the Help files on the box between releases are significant, far outweighing the minor hassle of running that first Update-Help or Save-Help command if the module does not include Help files. But there is still a bit of confusion associated with Updatable Help, and I'm here to explain.\n\nDoes this module support Updatable Help?\n\nSome modules support Updatable Help and others do not. Fortunately, there's an easy way to tell which modules support Updatable Help.\n\nIf the HelpInfoUri property of a command (such as cmdlet, function, CIM command, or workflow) has a value, and the value is valid (that is, it begins with \"http\" or \"https\"), the module supports Updatable Help.\n\nPS C:\\> Get-Module -ListAvailable | where HelpInfoUri\n\nThe HelpInfoUri property of each module object comes from the HelpInfoUri key in the module manifest. Following is the module manifest of the NetQos module, and you can see the HelpInfoUri key:\n\nPS C:\\ps-test> cat (get-module -list netqos).path\n\n@{\n\nGUID = '743692B7-A227-4389-B082-2B47DE1D0D2D'\n\nAuthor = \"Microsoft Corporation\"\n\nCompanyName = \"Microsoft Corporation\"\n\nCopyright = \"© Microsoft Corporation. All rights reserved.\"\n\nModuleVersion = '1.0'\n\nPowerShellVersion = '3.0'\n\nNestedModules = @('MSFT_NetQosPolicy.cdxml')\n\nFormatsToProcess = @('MSFT_NetQosPolicy.format.ps1xml')\n\nTypesToProcess = @('MSFT_NetQosPolicy.types.ps1xml')\n\nHelpInfoUri = \"http://go.microsoft.com/fwlink/?LinkId=216150\"\n\nFunctionsToExport = @(\n\n'Get-NetQosPolicy',\n\n'Set-NetQosPolicy',\n\n'Remove-NetQosPolicy',\n\n'New-NetQosPolicy')\n\n}\n\nThis command gets the manifest as a hash table, so you can get the keys as properties. The command returns the value of the HelpInfoUri key.\n\nPS C:\\ps-test>(Invoke-Expression (Get-Content (Get-Module -List NetQos).Path -Raw)).HelpInfoUri\n\nhttp://go.microsoft.com/fwlink/?LinkId=216150\n\nWhy is it called HelpInfoUri?\n\nYou might think that the Windows PowerShell team spends its lunch hours dreaming up weird property names, like HelpInfoUri, but if you know a bit about the innards of Updatable Help, this name actually makes sense.\n\nThe URI in HelpInfoUri is the address of the HelpInfo.xml file for the module's Updatable Help files. So the value is really the URI of HelpInfo. (The Updatable Help files can be in the same location, and often are, but they can also be in a different location.)\n\nThe HelpInfo.xml file is like an old-fashioned .inf file. Remember Autorun.inf? These INFormation files store options for programs like the registry does. We use XML files for efficiency and easy parsing (see Select-XML) but the idea is the same.\n\nThe HelpInfo XML file\n\nBecause we're picking on NetQos today (an AWESOME module), let's look at the HelpInfo.xml file for the NetQos module. When you use Update-Help or Save-Help to download Updatable Help files, the cmdlets also download the HelpInfo XML file and save it in the module directory on your hard drive. So, we can examine the file locally:\n\nPS C:\\ps-test> Get-Content C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Modules\\NetQos\\NetQos\n\n_743692b7-a227-4389-b082-2b47de1d0d2d_HelpInfo.xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<HelpInfo xmlns=\"http://schemas.microsoft.com/powershell/help/2010/05\">\n\n<HelpContentURI>http://go.microsoft.com/fwlink/?LinkId=216150</HelpContentURI>\n\n<SupportedUICultures>\n\n<UICulture>\n\n<UICultureName>en-US</UICultureName>\n\n<UICultureVersion>3.0.0.0</UICultureVersion>\n\n</UICulture>\n\n</SupportedUICultures>\n\n</HelpInfo>\n\nThe HelpInfo XML file has an element for each supported UI culture. Each SupportedUICulture element contains the HelpContentUri, which is the URI of the Updatable Help CAB file. If the HelpInfo XML file and the CAB file are in the same place, the HelpContentUri value is same as the HelpInfoUri value. The SupportedUICulture element also contains information for each UI culture, including the version number of the Help files.\n\nThe Update-Help and Save-Help cmdlets use the version number in the HelpInfo XML file to determine whether you have the latest Help files on your machine. Otherwise, the cmdlets download and install the latest version.\n\nWhy can't I read Help at the HelpInfoUri location?\n\nI bet everyone who's played with Windows PowerShell Updatable Help has tried a variation of this command, which opens your default Internet browser to the location that is specified by the HelpInfoUri value:\n\nPS C:\\> $u = (Get-Module -List NetQos).HelpInfoUri\n\nPS C:\\> (new-object -com shell.application).Open($u)\n\nOr you might have pasted the URI in your browser address bar. And you expected to see the Help topics for the module, or some interesting content. But there was nothing there except a file.\n\nIn the location where Windows stores Updatable Help files, there are no HTML files to display content. There are just the lowly CAB files, which are very valuable, but don't create an UI.\n\nIf you try the same trick with the HelpUri property of a cmdlet, the result is much better.\n\nPS C:\\> $u = (Get-Command Get-History).HelpUri\n\nPS C:\\> (New-Object -Com Shell.Application).Open($u)\n\nOr, better yet:\n\nPS C:\\> Get-Help Get-History -Online\n\nWhat is HelpUri?\n\nNow that we know about the HelpInfoUri property of modules, what is the HelpUri property of commands?\n\nThe URI in the value of the HelpInfo property is the online location of the Help topic for the command:\n\nPS C:\\ps-test> (Get-Command Get-History).HelpUri\n\nhttp://go.microsoft.com/fwlink/?LinkID=113317\n\nThe Online parameter of Get-Help uses the HelpUri (among other things) to find the online Help topic. It can be overridden, but it's the best guess for the URI at the time that the command is written.\n\nThe value of the HelpUri comes from the command script. In cmdlets, HelpUri is a named parameter of the Cmdlet attribute:\n\n[Cmdlet(VerbsCommon.Get, \"History\", HelpUri = \"http://go.microsoft.com/fwlink/?LinkID=001122\")]\n\nIn functions, HelpUri is a parameter of the CmdletBinding attribute:\n\nfunction New-Calendar {\n\n[CmdletBinding(SupportsShouldProcess=$true,\n\nHelpURI=\"http://go.microsoft.com/fwlink/?LinkID=01122\")]\n\nYou can also specify a HelpUri property value in CIM commands and workflows. For the details, see Supporting Online Help in the Windows PowerShell SDK.\n\nNow, about the \"it can be overridden\" part. When a Help topic for the command is installed on the computer, and the first related link in the Help topic is a valid URL, the first related link URL takes precedence over the HelpUri value of the command. That is, the Online parameter of Get-Help uses the first related link if it's a URL. And if it's not, it uses the value of the HelpUri property of the command.\n\nWhy? In Windows PowerShell 3.0, the HelpUri property value of a command comes from the HelpUri attribute in the cmdlet code. But, in Windows PowerShell 2.0, the HelpUri property value came from the first related link in the Help topic, if that link included a URL.\n\nWhen we developed Updatable Help, we wanted online Help to work even when the Help files were not installed on the local machine—so we couldn't rely on a value in a local Help file. That's when we added the HelpUri attribute to the cmdlet (and function, CIM command, and workflow) script.\n\nBut, we maintained the first related link source for backward compatibility and to provide a way to change the online Help topic location without changing the cmdlet.\n\nHere's the relevant section from the Get-History Help topic:\n\nRelated Links\n\nOnline Version: http://go.microsoft.com/fwlink/?LinkID=113317\n\nAdd-History\n\nClear-History\n\nInvoke-History\n\nabout_History\n\nAnd here's the XML for the first related link:\n\n<maml:relatedLinks>\n\n<maml:navigationLink>\n\n<maml:linkText>Online Version:</maml:linkText>\n\n<maml:uri>http://go.microsoft.com/fwlink/?LinkID=113317</maml:uri>\n\n</maml:navigationLink>\n\n</maml:relatedLinks>\n\n…and other Help mysteries\n\nThe Help system in Windows PowerShell is not simple. In fact, it's quite revolutionary. And you can use every feature of the Help system to make the modules and commands that you write really easy for users to use.\n\nIf you have question about the Updatable Help system, or any other aspect of Windows PowerShell, please reply in the Feedback section at the bottom of this page or tweet me a question at @juneb_get_help, and I'll answer them in a follow-up blog post.\n\nIf you are confused about URIs, URLs, URNs, and other URs, see this great blog post by Windows Azure Active Directory PM, Vittorio Bertocci. It's the best one I've seen: URL, URN, URI: Oh My!\n\n~June\n\nThank you, June.\n\nI invite you to follow me on Twitter and Facebook. If you have any questions, send email to me at scripter@microsoft.com, or post your questions on the Official Scripting Guys Forum. See you tomorrow. Until then, peace.\n\nEd Wilson, Microsoft Scripting Guy\n\nSummary: Use a hash table and an array to run prearranged actions.\n\nHonorary Scripting Guy, Sean Kearney here. I’m filling in for our good friend, Ed again today. I think he’s busy playing some tunes with the Windows PowerShell piano we created last week.\n\nSo continuing from last weekend’s silliness, I had the song “Popcorn” in my head. I was thinking, “Is there any way we could have some prerecorded music for Windows PowerShell?”\n\nWell, this is definitely something we can do, but we need to figure out a few details to play music. Looking at a typically sheet of music, we have some details to be aware of:\n\nNote A note (A,B,C,D) could be sharp, flat, or neither (let’s say, neutral).\n\nOctave Our note would be an octave, and there can be multiple C notes at different frequencies.\n\nTime Timing could be quarter, half, or whole (even eighth or sixteenth, but we’ll start simple). The note could also be “dotted” (plays 50% longer than its variant).\n\nBeats Each measure plays a certain number of beats at a time (4/4 is what we’ll work with).\n\nSo before Ludwig Von Beethoven comes out to correct my musical errors, we’re going to define a special array. We’re going to change our original music array from last week slightly.\n\nFirst, instead of a key on the keyboard, we’re going to create a new pattern for musical notes. We’re going to identify octave, note, and sharp or flat with this simple designation:\n\n# First Column Identifies Octave (A-C) (where C is the highest) - Octave 0 = REST\n\n# Second Column Identifies Note\n\n# Third Column Designates Note as Sharp \"S\" or Not \"N\"\n\nFor a C note in the second octave, it will look like this:\n\nBCN\n\nA D# in the third octave looks like this\n\nCDS\n\nAnd of course, a rest note will have a special designation of RRR. So our list of notes will translate to this:\n\n[array]$notes=$NULL\n\n$notes+=@{\"RRR\"=37}\n\n$notes+=@{\"BCN\"=290}\n\n$notes+=@{\"BCS\"=310}\n\n$notes+=@{\"BDN\"=330}\n\n$notes+=@{\"BDS\"=345}\n\n$notes+=@{\"BEN\"=360}\n\n$notes+=@{\"BFN\"=390}\n\n$notes+=@{\"BFS\"=415}\n\n$notes+=@{\"BGN\"=440}\n\n$notes+=@{\"BGS\"=460}\n\n$notes+=@{\"CAN\"=480}\n\n$notes+=@{\"CAS\"=505}\n\n$notes+=@{\"CBN\"=530}\n\n$notes+=@{\"CCN\"=580}\n\n$notes+=@{\"CCS\"=605}\n\n$notes+=@{\"CDN\"=630}\n\n$notes+=@{\"CDS\"=670}\n\n$notes+=@{\"CEN\"=710}\n\n$notes+=@{\"CFN\"=710}\n\n$notes+=@{\"CFN\"=710}\n\n$notes+=@{\"CGN\"=710}\n\n$notes+=@{\"CGN\"=710}\n\nAfter that, we need to define some particular details for notes and duration. For time, we’ll base everything on 4/4 and over two blocks of measures:\n\nEighth note 8\n\nQuarter note 4\n\nHalf note 2\n\nWhole note 1\n\nTo plug in a dotted note, we’ll add an additional column, 1 or 0 for dotted or non-dotted.\n\nSo to play an F#, second octave, whole note, non-dotted, we would use this:\n\nBFS10\n\nOr to play a G note, third octave, half note, dotted, we would use this:\n\nCGN21\n\nSo for our data array, the first three entries will contain the note, and the last pair is how long we’ll play it. Let’s plug-in some data directly:\n\n# Whole Note Dotted\n\n$Length=1\n\n$Dotted=1\n\n$PlayTime=4*(1/$Length)*(.5*[int]($Dotted=\"1\"))\n\nCool. So let’s put this together as a small array to play “Popcorn”:\n\n$MusicString=$NULL\n\n$MusicString+=\"CEN80CDN80CEN80CCN80CAN80CCN80BGN80RRR80\"\n\n$MusicString+=\"CEN80CDN80CEN80CCN80CAN80CCN80BGN80RRR80\"\n\n$MusicString+=\"CEN80CFS80CGN80CFS80CGN80CEN80CFS80CEN80\"\n\n$MusicString+=\"CFS80CDN80CEN80CCN80CAN80CCN80CEN80\"\n\nWe’ll create a loop to parse the data, and pass the results through to the array to determine the note and duration:\n\n$Start=0\n\n$End=$musicstring.Length\n\ndo {\n\n$Data=$MusicString.Substring($Start,5)\n\n$Note=$data.substring(0,3)\n\n$Length=[int]$data.substring(3,1)\n\n$Dotted=$data.substring(4,1)\n\n$Tone=$Notes.$Note\n\n$PlayTime=4*(1/$length)*(.5*[int]($Dotted=\"1\"))\n\nWith this data in hand, let’s play the music:\n\nIf ($Note -ne \"RRR\")\n\n{[console]::beep($tone,300*($Playtime))}\n\nElse\n\n{START-SLEEP -milliseconds (600*$Playtime)}\n\n$Start=$Start+5\n\n} Until ($Start -ge $End)\n\nTaDa! You’re a musician with Windows PowerShell!\n\nIf you’d like to download and listen to this silly little script, it’s sitting in the TechNet Gallery: Windows PowerShell Popcorn Tune.\n\nYou can adapt the music array to meet your own needs, including speeding it up and optimizing it (maybe even tune my horridly guessed notes).\n\nTune in tomorrow when we use Windows PowerShell to cook up a little popcorn for our script.\n\nI invite you to follow the Scripting Guys on Twitter and Facebook. If you have any questions, send email to scripter@microsoft.com, or post your questions on the Official Scripting Guys Forum. See you tomorrow. Until then, peace.\n\nSean Kearney,\n\nHonorary Scripting Guy and Windows PowerShell MVP\n\nSummary: Leverage Windows PowerShell for some simple on-screen animation.\n\nHonorary Scripting Guy, Sean Kearney, here. I’m filling in for our good friend, Ed Wilson. Ed got hungry today and asked me to make him some popcorn. So today we’ll use Windows PowerShell to make some—just some little bits for fun.\n\nIn actual reality I’m going to have Windows PowerShell generate some simple animations on the screen. This is for fun. Nothing else. After all, it’s the weekend. That’s my excuse!\n\nSo first we’ll define an array of the characters that will participate in our little animated fun:\n\n[Array]$Popcorn=$NULL\n\n$Popcorn+=\"( 0 )\"\n\n$Popcorn+=\" ( ) \"\n\n$Popcorn+=\" O \"\n\n$Popcorn+=\" o \"\n\n$Popcorn+=\" * \"\n\n$Popcorn+=\" | \"\n\n$Popcorn+=\" \\ \"\n\n$Popcorn+=\" - \"\n\n$Popcorn+=\" . \"\n\n$Popcorn+=\" . \"\n\nIf you’re feeling particularly creative and have too much time on your hands like I do, feel free to tweak or expand to this list.\n\nWe’re going to have a simple animation occur to show our piece of popcorn moving up the screen. If you remember, last week we used the $Host variable to move the position of the cursor on the screen.\n\nToday we’ll have our piece of popcorn rise up the screen in random positions. That should be fairly easy. We’ll pick a random position to place our “kernel.” To determine where we can “pop” on the screen, we’ll use a little simple logic.\n\nOur column can be anywhere from the left to the right side of the console. Well almost. We have to ensure that we don’t go too far to the left or right.\n\nWe’re going to pop in an upwards direction, so we’ll have to make sure that we start as low on the screen as we have elements within our array.\n\nThis is all fine and dandy, but wouldn’t it make sense to know just how big the Windows PowerShell window is? We can use the $Host variable. Under RawUI, there is a property called WindowSize, which contains the width and height of our Windows PowerShell window.\n\nWhen we know this information, we can use Get-Random to accurately place the piece of popcorn. We can use the Width to determine our maximum column position and the Height to figure out just how low we can go (I sense a limbo):\n\n$MaximumX=$Host.UI.RawUI.WindowSize.Width\n\n$MaximumY=$Host.UI.RawUI.WindowSize.Height\n\nNow for the row, we’re going to have to take into account the amount of array elements. So we’ll subtract the total values contained within the array:\n\n$StartColumn=([int](($popcorn[0].Length/2)+.1)\n\n$MaximumX=$Host.UI.RawUI.WindowSize.Width-$StartColumn\n\n$TotalPopcorn=$Popcorn.Count\n\n$MaximumY=$Host.UI.RawUI.WindowSize.Height-$TotalPopcorn\n\nNow we’ll just use a simple Get-Random for our starting position:\n\n$StartX=$StartColumn=GET-RANDOM $MaximumX\n\n$StartY=(GET-RANDOM $MaximumY)+$TotalPopcorn\n\nBefore we get going, we’ll have to obtain the location of the cursor so that we can manipulate it:\n\n$Location=$Host.UI.RawUI.CursorPosition\n\nNow to draw our bits (or technically, bytes) on the screen. For this, we’ll execute a simple loop to start from the bottom of the array to the top:\n\nFor ($p=$TotalPopcorn-1;$p --; $p –ge 0)\n\n{\n\n$Location.Y=($StartY+$p)\n\n$Host.UI.RawUI.CursorPosition=$Location\n\nWRITE-HOST $Popcorn[$p]\n\nDuring our loop we’re going to make sure that whatever might have been below the cursor will be erased. So move the cursor precisely down one position and draw a blank.\n\n$Erase=$Location\n\n$Erase.Y=($StartY+$p+1)\n\n$Host.UI.RawUI.CursorPosition=$Erase\n\nWRITE-HOST \" \"\n\nstart-sleep -milliseconds 10\n\n}\n\nNow if we just randomly looped through all of this, we’d see some basic little animations popping on the screen. But popcorn seems to pop randomly. So we’ll use a simple “flip of the coin” to decide in the parent loop on whether the popcorn will “pop”:\n\nIf ((GET-RANDOM 50) –lt 30)\n\n{ ScriptBlock for Popping Corn}\n\nELSE\n\n{ START-SLEEP –milliseconds 1000 }\n\nOh. One more thing for fun (and possibly to annoy our coworkers—a random “POP” sound:\n\n[console]::beep(4000+(GET-RANDOM 4000),100)\n\nSo let’s put this all together. I’ll call our loop that draws our $Popcorn on the screen a function called “POP-corn” (Oh come on, I had to…I really just had to):\n\n# PowerShell Popcorn\n\n# Define our array of Kernel pieces\n\n[Array]$Popcorn=$NULL\n\n$Popcorn+=\"( 0 )\"\n\n$Popcorn+=\" ( ) \"\n\n$Popcorn+=\" O \"\n\n$Popcorn+=\" o \"\n\n$Popcorn+=\" * \"\n\n$Popcorn+=\" | \"\n\n$Popcorn+=\" \\ \"\n\n$Popcorn+=\" - \"\n\n$Popcorn+=\" . \"\n\n$Popcorn+=\" . \"\n\n# Grab the cursor position\n\n$Location=$Host.UI.RawUI.CursorPosition\n\n# Get our parameters within the Console\n\n$StartColumn=([int](($popcorn[0].Length/2)+.1)\n\n$MaximumX=$Host.UI.RawUI.WindowSize.Width-$StartColumn\n\n$TotalPopcorn=$Popcorn.Count\n\n$MaximumY=$Host.UI.RawUI.WindowSize.Height-$TotalPopcorn\n\n#Clear the Screen\n\nCLEAR-HOST\n\n# Declare our popping cool function\n\nFunction pop-corn()\n\n{\n\n#Grab a random position\n\n$StartX=GET-RANDOM $MaximumX\n\n$StartY=(GET-RANDOM $MaximumY)+$TotalPopcorn\n\n$Location.X=$StartX\n\nFor ($p=$TotalPopcorn-1;$p --; $p –ge 0)\n\n{\n\n$Location.Y=($StartY+$p)\n\n# Move the cursor\n\n$Host.UI.RawUI.CursorPosition=$Location\n\n# Drop a Kernel\n\nWRITE-HOST $Popcorn[$p]\n\n# Move the cursor\n\n$Erase=$Location\n\n$Erase.Y=($StartY+$p+1)\n\n# Krush an older Kernel\n\n$Host.UI.RawUI.CursorPosition=$Erase\n\nWRITE-HOST \" \"\n\n# Grab a quick nap\n\nstart-sleep -milliseconds 10\n\n}\n\n}\n\n# Let’s decorate the console\n\n$Host.Ui.RawUI.WindowTitle=\"PowerShell Popcorn\"\n\ndo {\n\n# You can adjust the 30 Higher or Lower\n\n# to increase or decrease the possibility of\n\n# popping\n\nif ((GET-RANDOM 50) -lt 30)\n\n{\n\n# irritate your coworkers with noise\n\n[console]::beep(4000+(GET-RANDOM 4000),100)\n\n# Pop some Corn\n\nPop-Corn }\n\nELSE\n\n# 1000 milliseconds equals one second.\n\n# You could make this larger or smaller or even sleep\n\n# RANDOM amount of time using\n\n#\n\n# START-SLEEP –milliseconds (GET-RANDOM 5000)\n\n{ START-SLEEP -milliseconds 1000 }\n\n}\n\nuntil ($FALSE)\n\nSave this as popcornscreen.ps1, run it, and watch the pieces appear all over the screen.\n\nOK, no much silliness in console land. Back to work and more cool Windows PowerShell fun tomorrow!\n\nDoes anyone have some butter? I’m getting hungry.\n\nI invite you to follow the Scripting Guys on Twitter and Facebook. If you have any questions, send email to scripter@microsoft.com, or post your questions on the Official Scripting Guys Forum. See you tomorrow. Until then, peace.\n\nSean Kearney,\n\nHonorary Scripting Guy and Windows PowerShell MVP\n\nSummary: Microsoft Scripting Guy, Ed Wilson, talks about adding array index numbers to Windows PowerShell custom objects.\n\nHey, Scripting Guy! Our software application returns arrays of information. What I need is a way to artificially add the array element number to the object that the cmdlet outputs. For example, I want to add the highlighted information to the following output, and I need the highlighted numbers to be the array indexes:\n\nCan you help me?\n\n—WS\n\nHello WS,\n\nMicrosoft Scripting Guy, Ed Wilson, is here. Well it is just a couple of days until the Scripting Wife’s birthday. Shhhhhh…don’t tell her that I have not forgotten. It is sort of a game we like to play. I pretend to forget it is her birthday, she pretends to be upset. In the end, I wind up getting her great presents that she really likes—such as the complete series of the old Get Smart television show. She is still talking about that present!\n\nSo WS, when I first read your email sent to scripter@microsoft.com, I thought, “Well, that will not be too hard. Maybe I will use Select-Object, add a custom column, and pick up the index number.”\n\nWell unfortunately, that did not work out too well.\n\nI do not have your custom software package installed, but that really does not matter because PowerShell is PowerShell is PowerShell. It always behaves the same.\n\nWhat I ended up doing was creating a custom PSObject and using the IndexOf method to pick up the index number. Then I added in the value of the array element. Here is an example of what I am talking about:\n\nPS C:\\> $array = \"dog\",\"cat\",\"mongoose\",\"bird\"\n\nPS C:\\> $array.IndexOf('dog')\n\n0\n\nPS C:\\> $array.IndexOf('mongoose')\n\n2\n\nPS C:\\>\n\nAs you can see in the previous script, the IndexOf method will accept an array value and return the associated index number from it. So here is how I added this into a little demo script:\n\n# -----------------------------------------------------------------------------\n\n# Script: ArrayIndexAndValues.ps1\n\n# Author: ed wilson, msft\n\n# Date: 09/06/2013 11:33:26\n\n# Keywords: Scripting Techniques, Arrays, Custom PSObjects\n\n# comments:\n\n# HSG-9-23-2013\n\n# -----------------------------------------------------------------------------\n\n$array = \"dog\",\"cat\",\"mongoose\",\"bird\"\n\nForeach($a in $array)\n\n{\n\nNew-Object -TypeName psobject -Property @{\n\nindex= $array.indexof($A)\n\nValue= $A } }\n\nBut I was not really happy with my answer. So I emailed Lee Holmes and asked his opinion. Here is his answer…\n\nFirst of all, there is no really nice way to do what you are attempting to do. There’s an example from my Windows PowerShell Cookbook, second version, which talks about how to add Add-FormatTableIndexParameter to Format-Table. But other than that, an approach similar to yours is good.\n\nUsing Array.IndexOf() will be a little slow. Here is an alternative:\n\ndir c:\\ | Foreach-Object { $index = 0 } {\n\n[PSCustomObject] @{ Index = $index; Object = $_ }; $index++\n\n}\n\nWS, that is all there is to using Windows PowerShell to add array index values to a custom object. Join me tomorrow when we will have a great guest blog post by Microsoft PowerShell MVP, Jeffrey Hicks. He’ll be talking about a script profile tool that he wrote. It is good stuff and you do not want to miss out.\n\nI invite you to follow me on Twitter and Facebook. If you have any questions, send email to me at scripter@microsoft.com, or post your questions on the Official Scripting Guys Forum. See you tomorrow. Until then, peace.\n\nEd Wilson, Microsoft Scripting Guy"
    }
}