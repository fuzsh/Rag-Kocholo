{
    "id": "dbpedia_5041_3",
    "rank": 24,
    "data": {
        "url": "https://ntrs.nasa.gov/citations/19960048009",
        "read_more_link": "",
        "language": "en",
        "title": "Algorithms for Automatic Alignment of Arrays",
        "top_image": "https://ntrs.nasa.gov/citations/favicon.ico",
        "meta_img": "https://ntrs.nasa.gov/citations/favicon.ico",
        "images": [
            "https://ntrs.nasa.gov/assets/NASA_logo.svg",
            "https://ntrs.nasa.gov/assets/NASA_logo.svg",
            "https://ntrs.nasa.gov/assets/sti-logo.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Thomas J",
            "John R"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Aggregate data objects (such as arrays) are distributed across the processor memories when compiling a data-parallel language for a distributed-memory machine. The mapping determines the amount of communication needed to bring operands of parallel operations into alignment with each other. A common approach is to break the mapping into two stages: an alignment that maps all the objects to an abstract template, followed by a distribution that maps the template to the processors. This paper describes algorithms for solving the various facets of the alignment problem: axis and stride alignment, static and mobile offset alignment, and replication labeling. We show that optimal axis and stride alignment is NP-complete for general program graphs, and give a heuristic method that can explore the space of possible solutions in a number of ways. We show that some of these strategies can give better solutions than a simple greedy approach proposed earlier. We also show how local graph contractions can reduce the size of the problem significantly without changing the best solution. This allows more complex and effective heuristics to be used. We show how to model the static offset alignment problem using linear programming, and we show that loop-dependent mobile offset alignment is sometimes necessary for optimum performance. We describe an algorithm with for determining mobile alignments for objects within do loops. We also identify situations in which replicated alignment is either required by the program itself or can be used to improve performance. We describe an algorithm based on network flow that replicates objects so as to minimize the total amount of broadcast communication in replication.",
        "meta_lang": "en",
        "meta_favicon": "favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Back to Results"
    }
}