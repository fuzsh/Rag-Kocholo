{
    "id": "dbpedia_8183_0",
    "rank": 63,
    "data": {
        "url": "https://stackoverflow.com/questions/1486077/good-way-to-encapsulate-integer-parseint",
        "read_more_link": "",
        "language": "en",
        "title": "Good way to encapsulate Integer.parseInt()",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/6a35e59a085e9c62bc977ef22f8bc75b?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/6d8ebb117e8d83d74ea95fbdd0f87e13?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a648ccb47bbbe9497c073315aac4d33e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/AmYnj.jpg?s=64",
            "https://www.gravatar.com/avatar/a8c80f308366c37fb6835606d612636a?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/2f7b3f016fb0f78e5f6cf082469738d8?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/SXxig.jpg?s=64",
            "https://www.gravatar.com/avatar/19ad6afeec66f9154a766605af2dec81?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/1dc604233d8a0c48f0884769acb1fb93?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/eZvFj.jpg?s=64",
            "https://www.gravatar.com/avatar/c02cce9c2205923a41d8dc57ebe545b8?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/864e17f0a0508aa55342560afe64d6aa?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/589c835efbea96d4b47f2f3bf8cec645?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/ffc2b77580ffa2516f2e7ce524dc67ab?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/4b343c594df34f881fda9df94a94b5f3?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/afb5648c274c70edab85608a6e9ffff7?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/pKB8y.png?s=64",
            "https://i.sstatic.net/enNdg.jpg?s=64",
            "https://www.gravatar.com/avatar/4f114223f6a38683d92ad30e5f0616da?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/7fc9b5b520c6d0117e7b530a55fc39a1?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/3aa19ed7a02313cbdee217e9a493b18c?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/CdBpe.jpg?s=64",
            "https://i.sstatic.net/7kqxm.jpg?s=64",
            "https://i.sstatic.net/mme83.jpg?s=64",
            "https://i.sstatic.net/lbFcw.png?s=64",
            "https://i.sstatic.net/yz2yy.jpg?s=64",
            "https://i.sstatic.net/sdFYU.png?s=64",
            "https://www.gravatar.com/avatar/e07d58f15f822bb37b8b4bf3fe6f1ed3?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/5e44a15ecb4ee475548612da03c81f33?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/6OgdA.jpg?s=64",
            "https://stackoverflow.com/posts/1486077/ivc/9d4e?prg=4ad9ff72-0170-4082-b32a-150f9d675e31"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Wilian Z. Wilian Z"
        ],
        "publish_date": "2009-09-28T09:02:09",
        "summary": "",
        "meta_description": "I have a project in which we often use Integer.parseInt() to convert a String to an int. When something goes wrong (for example, the String is not a number but the letter a, or whatever) this metho...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/1486077/good-way-to-encapsulate-integer-parseint",
        "text": "You could return an Integer instead of an int, returning null on parse failure.\n\nIt's a shame Java doesn't provide a way of doing this without there being an exception thrown internally though - you can hide the exception (by catching it and returning null), but it could still be a performance issue if you're parsing hundreds of thousands of bits of user-provided data.\n\nEDIT: Code for such a method:\n\npublic static Integer tryParse(String text) { try { return Integer.parseInt(text); } catch (NumberFormatException e) { return null; } }\n\nNote that I'm not sure off the top of my head what this will do if text is null. You should consider that - if it represents a bug (i.e. your code may well pass an invalid value, but should never pass null) then throwing an exception is appropriate; if it doesn't represent a bug then you should probably just return null as you would for any other invalid value.\n\nOriginally this answer used the new Integer(String) constructor; it now uses Integer.parseInt and a boxing operation; in this way small values will end up being boxed to cached Integer objects, making it more efficient in those situations.\n\nAfter reading the answers to the question I think encapsulating or wrapping the parseInt method is not necessary, maybe even not a good idea.\n\nYou could return 'null' as Jon suggested, but that's more or less replacing a try/catch construct by a null-check. There's just a slight difference on the behaviour if you 'forget' error handling: if you don't catch the exception, there's no assignment and the left hand side variable keeps it old value. If you don't test for null, you'll probably get hit by the JVM (NPE).\n\nyawn's suggestion looks more elegant to me, because I do not like returning null to signal some errors or exceptional states. Now you have to check referential equality with a predefined object, that indicates a problem. But, as others argue, if again you 'forget' to check and a String is unparsable, the program continous with the wrapped int inside your 'ERROR' or 'NULL' object.\n\nNikolay's solution is even more object orientated and will work with parseXXX methods from other wrapper classes aswell. But in the end, he just replaced the NumberFormatException by an OperationNotSupported exception - again you need a try/catch to handle unparsable inputs.\n\nSo, its my conclusion to not encapsulate the plain parseInt method. I'd only encapsulate if I could add some (application depended) error handling as well.\n\nThis is an answer to question 8391979, \"Does java have a int.tryparse that doesn't throw an exception for bad data? [duplicate]\" which is closed and linked to this question.\n\nEdit 2016 08 17: Added ltrimZeroes methods and called them in tryParse(). Without leading zeroes in numberString may give false results (see comments in code). There is now also public static String ltrimZeroes(String numberString) method which works for positive and negative \"numbers\"(END Edit)\n\nBelow you find a rudimentary Wrapper (boxing) class for int with an highly speed optimized tryParse() method (similar as in C#) which parses the string itself and is a little bit faster than Integer.parseInt(String s) from Java:\n\npublic class IntBoxSimple { // IntBoxSimple - Rudimentary class to implement a C#-like tryParse() method for int // A full blown IntBox class implementation can be found in my Github project // Copyright (c) 2016, Peter Sulzer, FÃ¼rth // Program is published under the GNU General Public License (GPL) Version 1 or newer protected int _n; // this \"boxes\" the int value // BEGIN The following statements are only executed at the // first instantiation of an IntBox (i. e. only once) or // already compiled into the code at compile time: public static final int MAX_INT_LEN = String.valueOf(Integer.MAX_VALUE).length(); public static final int MIN_INT_LEN = String.valueOf(Integer.MIN_VALUE).length(); public static final int MAX_INT_LASTDEC = Integer.parseInt(String.valueOf(Integer.MAX_VALUE).substring(1)); public static final int MAX_INT_FIRSTDIGIT = Integer.parseInt(String.valueOf(Integer.MAX_VALUE).substring(0, 1)); public static final int MIN_INT_LASTDEC = -Integer.parseInt(String.valueOf(Integer.MIN_VALUE).substring(2)); public static final int MIN_INT_FIRSTDIGIT = Integer.parseInt(String.valueOf(Integer.MIN_VALUE).substring(1,2)); // END The following statements... // ltrimZeroes() methods added 2016 08 16 (are required by tryParse() methods) public static String ltrimZeroes(String s) { if (s.charAt(0) == '-') return ltrimZeroesNegative(s); else return ltrimZeroesPositive(s); } protected static String ltrimZeroesNegative(String s) { int i=1; for ( ; s.charAt(i) == '0'; i++); return (\"-\"+s.substring(i)); } protected static String ltrimZeroesPositive(String s) { int i=0; for ( ; s.charAt(i) == '0'; i++); return (s.substring(i)); } public static boolean tryParse(String s,IntBoxSimple intBox) { if (intBox == null) // intBoxSimple=new IntBoxSimple(); // This doesn't work, as // intBoxSimple itself is passed by value and cannot changed // for the caller. I. e. \"out\"-arguments of C# cannot be simulated in Java. return false; // so we simply return false s=s.trim(); // leading and trailing whitespace is allowed for String s int len=s.length(); int rslt=0, d, dfirst=0, i, j; char c=s.charAt(0); if (c == '-') { if (len > MIN_INT_LEN) { // corrected (added) 2016 08 17 s = ltrimZeroesNegative(s); len = s.length(); } if (len >= MIN_INT_LEN) { c = s.charAt(1); if (!Character.isDigit(c)) return false; dfirst = c-'0'; if (len > MIN_INT_LEN || dfirst > MIN_INT_FIRSTDIGIT) return false; } for (i = len - 1, j = 1; i >= 2; --i, j *= 10) { c = s.charAt(i); if (!Character.isDigit(c)) return false; rslt -= (c-'0')*j; } if (len < MIN_INT_LEN) { c = s.charAt(i); if (!Character.isDigit(c)) return false; rslt -= (c-'0')*j; } else { if (dfirst >= MIN_INT_FIRSTDIGIT && rslt < MIN_INT_LASTDEC) return false; rslt -= dfirst * j; } } else { if (len > MAX_INT_LEN) { // corrected (added) 2016 08 16 s = ltrimZeroesPositive(s); len=s.length(); } if (len >= MAX_INT_LEN) { c = s.charAt(0); if (!Character.isDigit(c)) return false; dfirst = c-'0'; if (len > MAX_INT_LEN || dfirst > MAX_INT_FIRSTDIGIT) return false; } for (i = len - 1, j = 1; i >= 1; --i, j *= 10) { c = s.charAt(i); if (!Character.isDigit(c)) return false; rslt += (c-'0')*j; } if (len < MAX_INT_LEN) { c = s.charAt(i); if (!Character.isDigit(c)) return false; rslt += (c-'0')*j; } if (dfirst >= MAX_INT_FIRSTDIGIT && rslt > MAX_INT_LASTDEC) return false; rslt += dfirst*j; } intBox._n=rslt; return true; } // Get the value stored in an IntBoxSimple: public int get_n() { return _n; } public int v() { // alternative shorter version, v for \"value\" return _n; } // Make objects of IntBoxSimple (needed as constructors are not public): public static IntBoxSimple makeIntBoxSimple() { return new IntBoxSimple(); } public static IntBoxSimple makeIntBoxSimple(int integerNumber) { return new IntBoxSimple(integerNumber); } // constructors are not public(!=: protected IntBoxSimple() {} { _n=0; // default value an IntBoxSimple holds } protected IntBoxSimple(int integerNumber) { _n=integerNumber; } }\n\nTest/example program for class IntBoxSimple:\n\nimport java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class IntBoxSimpleTest { public static void main (String args[]) { IntBoxSimple ibs = IntBoxSimple.makeIntBoxSimple(); String in = null; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); do { System.out.printf( \"Enter an integer number in the range %d to %d:%n\", Integer.MIN_VALUE, Integer.MAX_VALUE); try { in = br.readLine(); } catch (IOException ex) {} } while(! IntBoxSimple.tryParse(in, ibs)); System.out.printf(\"The number you have entered was: %d%n\", ibs.v()); } }\n\nI've been using a helper class that contains a static Queue of parsed values, and I find it to look quite clean. This would be the helper class could look like:\n\npublic static class Parsing { // Could optimise with specific queues for primitive types // and also using a circular queue, instead of LinkedList private static final Queue<Number> QUEUE = new LinkedList<Number>(); public static boolean parseInt(String value) { // Could implement custom integer parsing here, which does not throw try { QUEUE.offer(Integer.parseInt(value)); return true; } catch (Throwable ignored) { return false; } } public static int getInt() { return QUEUE.remove().intValue(); // user's fault if this throws :) } }\n\nAnd then in code, you use it like this:\n\npublic Vector3 parseVector(String content) { if (Parsing.parseInt(content)) { return new Vector3(Parsing.getInt()); } else { String[] parts = content.split(\",\"); if (Parsing.parseInt(parts[0]) && Parsing.parseInt(parts[1]) && Parsing.parseInt(parts[2])) { // the queue ensures these are in the same order they are parsed return new Vector3(Parsing.getInt(), Parsing.getInt(), Parsing.getInt()); } else { throw new RuntimeException(\"Invalid Vector3\"); } } }\n\nThe only problem with this, is that if you use multiple calls like i did above, but maybe the last one fails, then you'd have to roll back or clear the queue\n\nEdit: You could remove the above problem and include some thread safely, by making the class non-static and, maybe for slightly cleaner code, make the class implement AutoCloseable so that you could do something like this:\n\npublic Vector3 parseVector(String content) { try (Parsing parser = Parsing.of()) { if (parser.parseInt(content)) { return new Vector3(parser.getInt()); } else { String[] parts = content.split(\",\"); if (parser.parseInt(parts[0]) && parser.parseInt(parts[1]) && parser.parseInt(parts[2])) { // the queue ensures these are in the same order they are parsed return new Vector3(parser.getInt(), parser.getInt(), parser.getInt()); } else { throw new RuntimeException(\"Invalid Vector3\"); } } } }"
    }
}