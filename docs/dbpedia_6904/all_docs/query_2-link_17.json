{
    "id": "dbpedia_6904_2",
    "rank": 17,
    "data": {
        "url": "https://en.wikipedia.org/wiki/Hungarian_algorithm",
        "read_more_link": "",
        "language": "en",
        "title": "Hungarian algorithm",
        "top_image": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "meta_img": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/ae98b94e039c8eafabf6fe6a0128d232ed7d21f6",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6b04f5c5cfea38f43406d9442387ad28555e2609",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/c887cffa7f281a971ecc0e1283ec7f376911a781",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/19279c22d75f6b0a371cfdf17df3d8c62f6a8219",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6daa352058a7ba2cf2b4d1faee57c37669bc89fe",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/4d1b0dc6f1768cde09d95d780d20032225b95f0c",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/adf07322592c8f0b4f04512478b24c4351e8b072",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/fcd07db8ddd7ca161fd0a4a1ecfc26dbef961b69",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2860bc12144fb8083b455f424d09ee01400a802b",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/53fcc7b57da64979c370eb150eb5a61a625a08e8",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/bb0ebc7f369036d7d53f98a091b17049c8d678d2",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9edc1535536d90898dcc0aea79aa3b1919c54b2d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9edc1535536d90898dcc0aea79aa3b1919c54b2d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9edc1535536d90898dcc0aea79aa3b1919c54b2d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/494c7745f5b60faa2c5c741eb5dea0d4fe7342eb",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/7e84a3e87343472d38b88d4206813eecf85c2d3c",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/0dff9fe111d2b4fa70593e264ea7f17a2fba1279",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e5aad493910032da9a1e9ebd853fb6f5b6dceffd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9eb988dc610b1c617907dbb02121ac853d79ebd1",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/494c7745f5b60faa2c5c741eb5dea0d4fe7342eb",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e5aad493910032da9a1e9ebd853fb6f5b6dceffd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/125c5b85c5caee0d2c87e75ef711066326f4e221",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/494c7745f5b60faa2c5c741eb5dea0d4fe7342eb",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e5aad493910032da9a1e9ebd853fb6f5b6dceffd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9eb988dc610b1c617907dbb02121ac853d79ebd1",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/125c5b85c5caee0d2c87e75ef711066326f4e221",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/1e915eac548d688cb6c04d1cc4a1dde4df877712",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/53fcc7b57da64979c370eb150eb5a61a625a08e8",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2fc25d84714cf124ab31bcf47b1b154c6e056234",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/5cdea6b7ee22a9815856bbcacc1d78d0b5b8b9ce",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2fc25d84714cf124ab31bcf47b1b154c6e056234",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/df2e5aa7a71bbe86aa28b1bb8bbdc61fe5218f23",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9edc1535536d90898dcc0aea79aa3b1919c54b2d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e5aad493910032da9a1e9ebd853fb6f5b6dceffd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/ae98b94e039c8eafabf6fe6a0128d232ed7d21f6",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6cd9594a16cb898b8f2a2dff9227a385ec183392",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9edc1535536d90898dcc0aea79aa3b1919c54b2d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e5aad493910032da9a1e9ebd853fb6f5b6dceffd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/5cdea6b7ee22a9815856bbcacc1d78d0b5b8b9ce",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2fc25d84714cf124ab31bcf47b1b154c6e056234",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9edc1535536d90898dcc0aea79aa3b1919c54b2d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9edc1535536d90898dcc0aea79aa3b1919c54b2d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e5aad493910032da9a1e9ebd853fb6f5b6dceffd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9eb988dc610b1c617907dbb02121ac853d79ebd1",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e5aad493910032da9a1e9ebd853fb6f5b6dceffd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9edc1535536d90898dcc0aea79aa3b1919c54b2d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/4e6b4c628431f1c0bdf17baf5b94d2f46caa4c5f",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/b11a6f1f16f4fb9077149b8c00485b434561bcd5",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e5aad493910032da9a1e9ebd853fb6f5b6dceffd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/0a5ca3e8cb08e2700ccc8b6988533df691de0761",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/ef4efa52c8f47f06136f6ebfd1d68c1249aaca39",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/0a5ca3e8cb08e2700ccc8b6988533df691de0761",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/0a5ca3e8cb08e2700ccc8b6988533df691de0761",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/ef4efa52c8f47f06136f6ebfd1d68c1249aaca39",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/ef4efa52c8f47f06136f6ebfd1d68c1249aaca39",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9edc1535536d90898dcc0aea79aa3b1919c54b2d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/fd112fc91ea85d4600b8b83d18e4f9976ba87788",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/f0ee6526e0c9c0af1d20de1f50730181097954d8",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/b11a6f1f16f4fb9077149b8c00485b434561bcd5",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e5aad493910032da9a1e9ebd853fb6f5b6dceffd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e5aad493910032da9a1e9ebd853fb6f5b6dceffd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/72b8a0663dd228ba5aa33523cea544907daa0d29",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/20b6a58177fff9c50e2b2c9ad9471d653ab03bc1",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/b8b4a02a07d3ad7514499890c0701943d2ed73e5",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/58df9172091f3cd09d81c18cfe95ba978285aec9",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/3de23b6f2229d48350b663d16fddea6337e9848a",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/7f5468ff8e6c1df5eaa63c15b420392d5ee59e2e",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/03dd6bd614b22696c0137a3520a140046e2296d0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/359e4f407b49910e02c27c2f52e87a36cd74c053",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/54a9c4c547f4d6111f81946cad242b18298d70b7",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/57fa295fb5a352bc9b8f0c2773c6b164616dbbb6",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/03b094f501c0da905422e9102b6ba5e4558106c6",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/4ac1dd95cb2a8d98285119828d9bb490c32205e5",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/79d0aefe692984b182a988c0a990576f990a3c9f",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/222db49df2eefdb67737ba2d2dbd221a1bae0bf0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/f79b8087e75b789e45fec918eb3600d200b88a08",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/5d41ecb2ba9e797804eb886947015b1d65915701",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/5d41ecb2ba9e797804eb886947015b1d65915701",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/222db49df2eefdb67737ba2d2dbd221a1bae0bf0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/43f1c5d47efe2dfef65df80d600274bafcbb99f6",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/1cc6b75e09a8aa3f04d8584b11db534f88fb56bd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9edc1535536d90898dcc0aea79aa3b1919c54b2d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/1cc6b75e09a8aa3f04d8584b11db534f88fb56bd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/34a88634f09c9d78c3240b60a3d7234cd8736a0e",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/879e575621f56ce3188484f5535519e667ffe751",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/88b1e0c8e1be5ebe69d18a8010676fa42d7961e6",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/1cc6b75e09a8aa3f04d8584b11db534f88fb56bd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/879e575621f56ce3188484f5535519e667ffe751",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/879e575621f56ce3188484f5535519e667ffe751",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/879e575621f56ce3188484f5535519e667ffe751",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/879e575621f56ce3188484f5535519e667ffe751",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/1cc6b75e09a8aa3f04d8584b11db534f88fb56bd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/3aaf57b9c4b15cb1a208d90f3640b2cbba704af6",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/32769037c408874e1890f77554c65f39c523ebe2",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/879e575621f56ce3188484f5535519e667ffe751",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/1cc6b75e09a8aa3f04d8584b11db534f88fb56bd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/3aaf57b9c4b15cb1a208d90f3640b2cbba704af6",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/0f14166afa81127e8e7a2e093dec9e3f9d1a95de",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/03b094f501c0da905422e9102b6ba5e4558106c6",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/25521d8625b30df217dd2e35f30d255009593bb1",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/4e1eb3d4f142c423f48e1f4e93f8daf81ffd8ff4",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/32769037c408874e1890f77554c65f39c523ebe2",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/32769037c408874e1890f77554c65f39c523ebe2",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6edb3c4a73a497ab3fef970c290e00528c12a3a4",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/b26be3e694314bc90c3215047e4a2010c6ee184a",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9b43d5814f3988603bcb83ebaf4b6eca1bb597db",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/f82cade9898ced02fdd08712e5f0c0151758a0dd",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/39540268f2893dcf3d13b91ec768ec96deeb815c",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/879e575621f56ce3188484f5535519e667ffe751",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/54a9c4c547f4d6111f81946cad242b18298d70b7",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/25dcc2a2a37c4bfafb26542489d56d0e6adacf8e",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/d3e1a01c0cf537f6435eb7b35eb8491875dd4476",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6daa352058a7ba2cf2b4d1faee57c37669bc89fe",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/9acac33460567c532f2648cb7b727bc05f8da41c",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/ddb0f8c601f53ade459502f9d33370e097ee41b0",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/b7b99a58a3961acac90855097541085b89c2b301",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6b04f5c5cfea38f43406d9442387ad28555e2609",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/ae98b94e039c8eafabf6fe6a0128d232ed7d21f6",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6b04f5c5cfea38f43406d9442387ad28555e2609",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6b04f5c5cfea38f43406d9442387ad28555e2609",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6b04f5c5cfea38f43406d9442387ad28555e2609",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6b04f5c5cfea38f43406d9442387ad28555e2609",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6b04f5c5cfea38f43406d9442387ad28555e2609",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6b04f5c5cfea38f43406d9442387ad28555e2609",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/6b04f5c5cfea38f43406d9442387ad28555e2609",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2005-09-04T01:15:42+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/Hungarian_algorithm",
        "text": "Polynomial-time algorithm for the assignment problem\n\nThe Hungarian method is a combinatorial optimization algorithm that solves the assignment problem in polynomial time and which anticipated later primal–dual methods. It was developed and published in 1955 by Harold Kuhn, who gave it the name \"Hungarian method\" because the algorithm was largely based on the earlier works of two Hungarian mathematicians, Dénes Kőnig and Jenő Egerváry.[1][2] However, in 2006 it was discovered that Carl Gustav Jacobi had solved the assignment problem in the 19th century, and the solution had been published posthumously in 1890 in Latin.[3]\n\nJames Munkres reviewed the algorithm in 1957 and observed that it is (strongly) polynomial.[4] Since then the algorithm has been known also as the Kuhn–Munkres algorithm or Munkres assignment algorithm. The time complexity of the original algorithm was O ( n 4 ) {\\displaystyle O(n^{4})} , however Edmonds and Karp, and independently Tomizawa, noticed that it can be modified to achieve an O ( n 3 ) {\\displaystyle O(n^{3})} running time.[5][6] Ford and Fulkerson extended the method to general maximum flow problems in form of the Ford–Fulkerson algorithm.\n\nThe problem\n\n[edit]\n\nMain article: Assignment problem\n\nExample\n\n[edit]\n\nIn this simple example, there are three workers: Alice, Bob and Carol. One of them has to clean the bathroom, another sweep the floors and the third washes the windows, but they each demand different pay for the various tasks. The problem is to find the lowest-cost way to assign the jobs. The problem can be represented in a matrix of the costs of the workers doing the jobs. For example:\n\nTask\n\nWorker\n\nClean\n\nbathroom Sweep\n\nfloors Wash\n\nwindows Alice $8 $4 $7 Bob $5 $2 $3 Carol $9 $4 $8\n\nThe Hungarian method, when applied to the above table, would give the minimum cost: this is $15, achieved by having Alice clean the bathroom, Carol sweep the floors, and Bob wash the windows. This can be confirmed using brute force:\n\nClean\n\nSweep\n\nAlice Bob Carol Alice — $17 $16 Bob $18 — $18 Carol $15 $16 —\n\n(the unassigned person washes the windows)\n\nMatrix formulation\n\n[edit]\n\nIn the matrix formulation, we are given an n×n matrix, where the element in the i-th row and j-th column represents the cost of assigning the j-th job to the i-th worker. We have to find an assignment of the jobs to the workers, such that each job is assigned to one worker and each worker is assigned one job, such that the total cost of assignment is minimum.\n\nThis can be expressed as permuting the rows of a cost matrix C to minimize the trace of a matrix,\n\nmin P Tr ⁡ ( P C ) , {\\displaystyle \\min _{P}\\operatorname {Tr} (PC)\\;,}\n\nwhere P is a permutation matrix. (Equivalently, the columns can be permuted using CP.)\n\nIf the goal is to find the assignment that yields the maximum cost, the problem can be solved by negating the cost matrix C.\n\nBipartite graph formulation\n\n[edit]\n\nThe algorithm can equivalently be described by formulating the problem using a bipartite graph. We have a complete bipartite graph G = ( S , T ; E ) {\\displaystyle G=(S,T;E)} with n worker vertices (S) and n job vertices (T), and the edges (E) each have a cost c ( i , j ) {\\displaystyle c(i,j)} . We want to find a perfect matching with a minimum total cost.\n\nThe algorithm in terms of bipartite graphs\n\n[edit]\n\nLet us call a function y : ( S ∪ T ) → R {\\displaystyle y:(S\\cup T)\\to \\mathbb {R} } a potential if y ( i ) + y ( j ) ≤ c ( i , j ) {\\displaystyle y(i)+y(j)\\leq c(i,j)} for each i ∈ S , j ∈ T {\\displaystyle i\\in S,j\\in T} . The value of potential y is the sum of the potential over all vertices: ∑ v ∈ S ∪ T y ( v ) {\\displaystyle \\sum _{v\\in S\\cup T}y(v)} .\n\nThe cost of each perfect matching is at least the value of each potential: the total cost of the matching is the sum of costs of all edges; the cost of each edge is at least the sum of potentials of its endpoints; since the matching is perfect, each vertex is an endpoint of exactly one edge; hence the total cost is at least the total potential.\n\nThe Hungarian method finds a perfect matching and a potential such that the matching cost equals the potential value. This proves that both of them are optimal. In fact, the Hungarian method finds a perfect matching of tight edges: an edge i j {\\displaystyle ij} is called tight for a potential y if y ( i ) + y ( j ) = c ( i , j ) {\\displaystyle y(i)+y(j)=c(i,j)} . Let us denote the subgraph of tight edges by G y {\\displaystyle G_{y}} . The cost of a perfect matching in G y {\\displaystyle G_{y}} (if there is one) equals the value of y.\n\nDuring the algorithm we maintain a potential y and an orientation of G y {\\displaystyle G_{y}} (denoted by G y → {\\displaystyle {\\overrightarrow {G_{y}}}} ) which has the property that the edges oriented from T to S form a matching M. Initially, y is 0 everywhere, and all edges are oriented from S to T (so M is empty). In each step, either we modify y so that its value increases, or modify the orientation to obtain a matching with more edges. We maintain the invariant that all the edges of M are tight. We are done if M is a perfect matching.\n\nIn a general step, let R S ⊆ S {\\displaystyle R_{S}\\subseteq S} and R T ⊆ T {\\displaystyle R_{T}\\subseteq T} be the vertices not covered by M (so R S {\\displaystyle R_{S}} consists of the vertices in S with no incoming edge and R T {\\displaystyle R_{T}} consists of the vertices in T with no outgoing edge). Let Z be the set of vertices reachable in G y → {\\displaystyle {\\overrightarrow {G_{y}}}} from R S {\\displaystyle R_{S}} by a directed path. This can be computed by breadth-first search.\n\nIf R T ∩ Z {\\displaystyle R_{T}\\cap Z} is nonempty, then reverse the orientation of all edges along a directed path in G y → {\\displaystyle {\\overrightarrow {G_{y}}}} from R S {\\displaystyle R_{S}} to R T {\\displaystyle R_{T}} . Thus the size of the corresponding matching increases by 1.\n\nIf R T ∩ Z {\\displaystyle R_{T}\\cap Z} is empty, then let\n\nΔ := min { c ( i , j ) − y ( i ) − y ( j ) : i ∈ Z ∩ S , j ∈ T ∖ Z } . {\\displaystyle \\Delta :=\\min\\{c(i,j)-y(i)-y(j):i\\in Z\\cap S,j\\in T\\setminus Z\\}.}\n\nΔ is well defined because at least one such edge i j {\\displaystyle ij} must exist whenever the matching is not yet of maximum possible size (see the following section); it is positive because there are no tight edges between Z ∩ S {\\displaystyle Z\\cap S} and T ∖ Z {\\displaystyle T\\setminus Z} . Increase y by Δ on the vertices of Z ∩ S {\\displaystyle Z\\cap S} and decrease y by Δ on the vertices of Z ∩ T {\\displaystyle Z\\cap T} . The resulting y is still a potential, and although the graph G y {\\displaystyle G_{y}} changes, it still contains M (see the next subsections). We orient the new edges from S to T. By the definition of Δ the set Z of vertices reachable from R S {\\displaystyle R_{S}} increases (note that the number of tight edges does not necessarily increase).\n\nWe repeat these steps until M is a perfect matching, in which case it gives a minimum cost assignment. The running time of this version of the method is O ( n 4 ) {\\displaystyle O(n^{4})} : M is augmented n times, and in a phase where M is unchanged, there are at most n potential changes (since Z increases every time). The time sufficient for a potential change is O ( n 2 ) {\\displaystyle O(n^{2})} .\n\nProof that the algorithm makes progress\n\n[edit]\n\nWe must show that as long as the matching is not of maximum possible size, the algorithm is always able to make progress — that is, to either increase the number of matched edges, or tighten at least one edge. It suffices to show that at least one of the following holds at every step:\n\nM is of maximum possible size.\n\nG y {\\displaystyle G_{y}} contains an augmenting path.\n\nG contains a loose-tailed path: a path from some vertex in R S {\\displaystyle R_{S}} to a vertex in T ∖ Z {\\displaystyle T\\setminus Z} that consists of any number (possibly zero) of tight edges followed by a single loose edge. The trailing loose edge of a loose-tailed path is thus from Z ∩ S {\\displaystyle Z\\cap S} , guaranteeing that Δ is well defined.\n\nIf M is of maximum possible size, we are of course finished. Otherwise, by Berge's lemma, there must exist an augmenting path P with respect to M in the underlying graph G. However, this path may not exist in G y {\\displaystyle G_{y}} : Although every even-numbered edge in P is tight by the definition of M, odd-numbered edges may be loose and thus absent from G y {\\displaystyle G_{y}} . One endpoint of P is in R S {\\displaystyle R_{S}} , the other in R T {\\displaystyle R_{T}} ; w.l.o.g., suppose it begins in R S {\\displaystyle R_{S}} . If every edge on P is tight, then it remains an augmenting path in G y {\\displaystyle G_{y}} and we are done. Otherwise, let u v {\\displaystyle uv} be the first loose edge on P. If v ∉ Z {\\displaystyle v\\notin Z} then we have found a loose-tailed path and we are done. Otherwise, v is reachable from some other path Q of tight edges from a vertex in R S {\\displaystyle R_{S}} . Let P v {\\displaystyle P_{v}} be the subpath of P beginning at v and continuing to the end, and let P ′ {\\displaystyle P'} be the path formed by traveling along Q until a vertex on P v {\\displaystyle P_{v}} is reached, and then continuing to the end of P v {\\displaystyle P_{v}} . Observe that P ′ {\\displaystyle P'} is an augmenting path in G with at least one fewer loose edge than P. P can be replaced with P ′ {\\displaystyle P'} and this reasoning process iterated (formally, using induction on the number of loose edges) until either an augmenting path in G y {\\displaystyle G_{y}} or a loose-tailed path in G is found.\n\nProof that adjusting the potential y leaves M unchanged\n\n[edit]\n\nTo show that every edge in M remains after adjusting y, it suffices to show that for an arbitrary edge in M, either both of its endpoints, or neither of them, are in Z. To this end let v u {\\displaystyle vu} be an edge in M from T to S. It is easy to see that if v is in Z then u must be too, since every edge in M is tight. Now suppose, toward contradiction, that u ∈ Z {\\displaystyle u\\in Z} but v ∉ Z {\\displaystyle v\\notin Z} . u itself cannot be in R S {\\displaystyle R_{S}} because it is the endpoint of a matched edge, so there must be some directed path of tight edges from a vertex in R S {\\displaystyle R_{S}} to u. This path must avoid v, since that is by assumption not in Z, so the vertex immediately preceding u in this path is some other vertex v ′ ∈ T {\\displaystyle v'\\in T} . v ′ u {\\displaystyle v'u} is a tight edge from T to S and is thus in M. But then M contains two edges that share the vertex u, contradicting the fact that M is a matching. Thus every edge in M has either both endpoints or neither endpoint in Z.\n\nProof that y remains a potential\n\n[edit]\n\nTo show that y remains a potential after being adjusted, it suffices to show that no edge has its total potential increased beyond its cost. This is already established for edges in M by the preceding paragraph, so consider an arbitrary edge uv from S to T. If y ( u ) {\\displaystyle y(u)} is increased by Δ, then either v ∈ Z ∩ T {\\displaystyle v\\in Z\\cap T} , in which case y ( v ) {\\displaystyle y(v)} is decreased by Δ, leaving the total potential of the edge unchanged, or v ∈ T ∖ Z {\\displaystyle v\\in T\\setminus Z} , in which case the definition of Δ guarantees that y ( u ) + y ( v ) + Δ ≤ c ( u , v ) {\\displaystyle y(u)+y(v)+\\Delta \\leq c(u,v)} . Thus y remains a potential.\n\nThe algorithm in O(n3) time\n\n[edit]\n\nSuppose there are J {\\displaystyle J} jobs and W {\\displaystyle W} workers ( J ≤ W {\\displaystyle J\\leq W} ). We describe how to compute for each prefix of jobs the minimum total cost to assign each of these jobs to distinct workers. Specifically, we add the j {\\displaystyle j} th job and update the total cost in time O ( j W ) {\\displaystyle O(jW)} , yielding an overall time complexity of O ( ∑ j = 1 J j W ) = O ( J 2 W ) {\\displaystyle O\\left(\\sum _{j=1}^{J}jW\\right)=O(J^{2}W)} . Note that this is better than O ( W 3 ) {\\displaystyle O(W^{3})} when the number of jobs is small relative to the number of workers.\n\nAdding the j-th job in O(jW) time\n\n[edit]\n\nWe use the same notation as the previous section, though we modify their definitions as necessary. Let S j {\\displaystyle S_{j}} denote the set of the first j {\\displaystyle j} jobs and T {\\displaystyle T} denote the set of all workers.\n\nBefore the j {\\displaystyle j} th step of the algorithm, we assume that we have a matching on S j − 1 ∪ T {\\displaystyle S_{j-1}\\cup T} that matches all jobs in S j − 1 {\\displaystyle S_{j-1}} and potentials y {\\displaystyle y} satisfying the following condition: the matching is tight with respect to the potentials, and the potentials of all unmatched workers are zero, and the potentials of all matched workers are non-positive. Note that such potentials certify the optimality of the matching.\n\nDuring the j {\\displaystyle j} th step, we add the j {\\displaystyle j} th job to S j − 1 {\\displaystyle S_{j-1}} to form S j {\\displaystyle S_{j}} and initialize Z = { j } {\\displaystyle Z=\\{j\\}} . At all times, every vertex in Z {\\displaystyle Z} will be reachable from the j {\\displaystyle j} th job in G y {\\displaystyle G_{y}} . While Z {\\displaystyle Z} does not contain a worker that has not been assigned a job, let\n\nΔ := min { c ( j , w ) − y ( j ) − y ( w ) : j ∈ Z ∩ S j , w ∈ T ∖ Z } {\\displaystyle \\Delta :=\\min\\{c(j,w)-y(j)-y(w):j\\in Z\\cap S_{j},w\\in T\\setminus Z\\}}\n\nand w next {\\displaystyle w_{\\text{next}}} denote any w {\\displaystyle w} at which the minimum is attained. After adjusting the potentials in the way described in the previous section, there is now a tight edge from Z {\\displaystyle Z} to w next {\\displaystyle w_{\\text{next}}} .\n\nIf w next {\\displaystyle w_{\\text{next}}} is unmatched, then we have an augmenting path in the subgraph of tight edges from j {\\displaystyle j} to w next {\\displaystyle w_{\\text{next}}} . After toggling the matching along this path, we have now matched the first j {\\displaystyle j} jobs, and this procedure terminates.\n\nOtherwise, we add w next {\\displaystyle w_{\\text{next}}} and the job matched with it to Z {\\displaystyle Z} .\n\nAdjusting potentials takes O ( W ) {\\displaystyle O(W)} time. Recomputing Δ {\\displaystyle \\Delta } and w next {\\displaystyle w_{\\text{next}}} after changing the potentials and Z {\\displaystyle Z} also can be done in O ( W ) {\\displaystyle O(W)} time. Case 1 can occur at most j − 1 {\\displaystyle j-1} times before case 2 occurs and the procedure terminates, yielding the overall time complexity of O ( j W ) {\\displaystyle O(jW)} .\n\nImplementation in C++\n\n[edit]\n\nFor convenience of implementation, the code below adds an additional worker w W {\\displaystyle w_{W}} such that y ( w W ) {\\displaystyle y(w_{W})} stores the negation of the sum of all Δ {\\displaystyle \\Delta } computed so far. After the j {\\displaystyle j} th job is added and the matching updated, the cost of the current matching equals the sum of all Δ {\\displaystyle \\Delta } computed so far, or − y ( w W ) {\\displaystyle -y(w_{W})} .\n\nThis code is adapted from e-maxx :: algo.[7]\n\n/** * Solution to https://open.kattis.com/problems/cordonbleu using Hungarian * algorithm. */ #include<cassert> #include<iostream> #include<limits> #include<vector> usingnamespacestd; /** * Sets a = min(a, b) * @return true if b < a */ template<classT>boolckmin(T&a,constT&b){returnb<a?a=b,1:0;} /** * Given J jobs and W workers (J <= W), computes the minimum cost to assign each * prefix of jobs to distinct workers. * * @tparam T a type large enough to represent integers on the order of J * * max(|C|) * @param C a matrix of dimensions JxW such that C[j][w] = cost to assign j-th * job to w-th worker (possibly negative) * * @return a vector of length J, with the j-th entry equaling the minimum cost * to assign the first (j+1) jobs to distinct workers */ template<classT>vector<T>hungarian(constvector<vector<T>>&C){ constintJ=(int)size(C),W=(int)size(C[0]); assert(J<=W); // job[w] = job assigned to w-th worker, or -1 if no job assigned // note: a W-th worker was added for convenience vector<int>job(W+1,-1); vector<T>ys(J),yt(W+1);// potentials // -yt[W] will equal the sum of all deltas vector<T>answers; constTinf=numeric_limits<T>::max(); for(intj_cur=0;j_cur<J;++j_cur){// assign j_cur-th job intw_cur=W; job[w_cur]=j_cur; // min reduced cost over edges from Z to worker w vector<T>min_to(W+1,inf); vector<int>prv(W+1,-1);// previous worker on alternating path vector<bool>in_Z(W+1);// whether worker is in Z while(job[w_cur]!=-1){// runs at most j_cur + 1 times in_Z[w_cur]=true; constintj=job[w_cur]; Tdelta=inf; intw_next; for(intw=0;w<W;++w){ if(!in_Z[w]){ if(ckmin(min_to[w],C[j][w]-ys[j]-yt[w])) prv[w]=w_cur; if(ckmin(delta,min_to[w]))w_next=w; } } // delta will always be nonnegative, // except possibly during the first time this loop runs // if any entries of C[j_cur] are negative for(intw=0;w<=W;++w){ if(in_Z[w])ys[job[w]]+=delta,yt[w]-=delta; elsemin_to[w]-=delta; } w_cur=w_next; } // update assignments along alternating path for(intw;w_cur!=W;w_cur=w)job[w_cur]=job[w=prv[w_cur]]; answers.push_back(-yt[W]); } returnanswers; } /** * Sanity check: https://en.wikipedia.org/wiki/Hungarian_algorithm#Example * First job (5): * clean bathroom: Bob -> 5 * First + second jobs (9): * clean bathroom: Bob -> 5 * sweep floors: Alice -> 4 * First + second + third jobs (15): * clean bathroom: Alice -> 8 * sweep floors: Carol -> 4 * wash windows: Bob -> 3 */ voidsanity_check_hungarian(){ vector<vector<int>>costs{{8,5,9},{4,2,4},{7,3,8}}; assert((hungarian(costs)==vector<int>{5,9,15})); cerr<<\"Sanity check passed.\\n\"; } // solves https://open.kattis.com/problems/cordonbleu voidcordon_bleu(){ intN,M; cin>>N>>M; vector<pair<int,int>>B(N),C(M); vector<pair<int,int>>bottles(N),couriers(M); for(auto&b:bottles)cin>>b.first>>b.second; for(auto&c:couriers)cin>>c.first>>c.second; pair<int,int>rest; cin>>rest.first>>rest.second; vector<vector<int>>costs(N,vector<int>(N+M-1)); autodist=[&](pair<int,int>x,pair<int,int>y){ returnabs(x.first-y.first)+abs(x.second-y.second); }; for(intb=0;b<N;++b){ for(intc=0;c<M;++c){// courier -> bottle -> restaurant costs[b][c]= dist(couriers[c],bottles[b])+dist(bottles[b],rest); } for(int_=0;_<N-1;++_){// restaurant -> bottle -> restaurant costs[b][_+M]=2*dist(bottles[b],rest); } } cout<<hungarian(costs).back()<<\"\\n\"; } intmain(){ sanity_check_hungarian(); cordon_bleu(); }\n\nConnection to successive shortest paths\n\n[edit]\n\nThe Hungarian algorithm can be seen to be equivalent to the successive shortest path algorithm for minimum cost flow,[8][9] where the reweighting technique from Johnson's algorithm is used to find the shortest paths. The implementation from the previous section is rewritten below in such a way as to emphasize this connection; it can be checked that the potentials h {\\displaystyle h} for workers 0 … W − 1 {\\displaystyle 0\\dots W-1} are equal to the potentials y {\\displaystyle y} from the previous solution up to a constant offset. When the graph is sparse (there are only M {\\displaystyle M} allowed job, worker pairs), it is possible to optimize this algorithm to run in O ( J M + J 2 log ⁡ W ) {\\displaystyle O(JM+J^{2}\\log W)} time by using a Fibonacci heap to determine w next {\\displaystyle w_{\\text{next}}} instead of iterating over all W {\\displaystyle W} workers to find the one with minimum distance (alluded to here).\n\ntemplate<classT>vector<T>hungarian(constvector<vector<T>>&C){ constintJ=(int)size(C),W=(int)size(C[0]); assert(J<=W); // job[w] = job assigned to w-th worker, or -1 if no job assigned // note: a W-th worker was added for convenience vector<int>job(W+1,-1); vector<T>h(W);// Johnson potentials vector<T>answers; Tans_cur=0; constTinf=numeric_limits<T>::max(); // assign j_cur-th job using Dijkstra with potentials for(intj_cur=0;j_cur<J;++j_cur){ intw_cur=W;// unvisited worker with minimum distance job[w_cur]=j_cur; vector<T>dist(W+1,inf);// Johnson-reduced distances dist[W]=0; vector<bool>vis(W+1);// whether visited yet vector<int>prv(W+1,-1);// previous worker on shortest path while(job[w_cur]!=-1){// Dijkstra step: pop min worker from heap Tmin_dist=inf; vis[w_cur]=true; intw_next=-1;// next unvisited worker with minimum distance // consider extending shortest path by w_cur -> job[w_cur] -> w for(intw=0;w<W;++w){ if(!vis[w]){ // sum of reduced edge weights w_cur -> job[w_cur] -> w Tedge=C[job[w_cur]][w]-h[w]; if(w_cur!=W){ edge-=C[job[w_cur]][w_cur]-h[w_cur]; assert(edge>=0);// consequence of Johnson potentials } if(ckmin(dist[w],dist[w_cur]+edge))prv[w]=w_cur; if(ckmin(min_dist,dist[w]))w_next=w; } } w_cur=w_next; } for(intw=0;w<W;++w){// update potentials ckmin(dist[w],dist[w_cur]); h[w]+=dist[w]; } ans_cur+=h[w_cur]; for(intw;w_cur!=W;w_cur=w)job[w_cur]=job[w=prv[w_cur]]; answers.push_back(ans_cur); } returnanswers; }\n\nMatrix interpretation\n\n[edit]\n\nThis variant of the algorithm follows the formulation given by Flood,[10] and later described more explicitly by Munkres, who proved it runs in O ( n 4 ) {\\displaystyle {\\mathcal {O}}(n^{4})} time.[4] Instead of keeping track of the potentials of the vertices, the algorithm operates only on a matrix:\n\na i j := c ( i , j ) − y ( i ) − y ( j ) {\\displaystyle a_{ij}:=c(i,j)-y(i)-y(j)}\n\nwhere c ( i , j ) {\\displaystyle c(i,j)} is the original cost matrix and y ( i ) , y ( j ) {\\displaystyle y(i),y(j)} are the potentials from the graph interpretation. Changing the potentials corresponds to adding or subtracting from rows or columns of this matrix. The algorithm starts with a i j = c ( i , j ) {\\displaystyle a_{ij}=c(i,j)} . As such, it can be viewed as taking the original cost matrix and modifying it.\n\nGiven n workers and tasks, the problem is written in the form of an n×n cost matrix\n\na1 a2 a3 a4 b1 b2 b3 b4 c1 c2 c3 c4 d1 d2 d3 d4\n\nwhere a, b, c and d are workers who have to perform tasks 1, 2, 3 and 4. a1, a2, a3, and a4 denote the penalties incurred when worker \"a\" does task 1, 2, 3, and 4 respectively.\n\nThe problem is equivalent to assigning each worker a unique task such that the total penalty is minimized. Note that each task can only be worked on by one worker.\n\nStep 1\n\n[edit]\n\nFor each row, its minimum element is subtracted from every element in that row. This causes all elements to have nonnegative values. Therefore, an assignment with a total penalty of 0 is by definition a minimum assignment.\n\nThis also leads to at least one zero in each row. As such, a naive greedy algorithm can attempt to assign all workers a task with a penalty of zero. This is illustrated below.\n\n0 a2 a3 a4 b1 b2 b3 0 c1 0 c3 c4 d1 d2 0 d4\n\nThe zeros above would be the assigned tasks.\n\nWorst-case there are n! combinations to try, since multiple zeroes can appear in a row if multiple elements are the minimum. So at some point this naive algorithm should be short circuited.\n\nStep 2\n\n[edit]\n\nSometimes it may turn out that the matrix at this stage cannot be used for assigning, as is the case for the matrix below.\n\n0 a2 0 a4 b1 0 b3 0 0 c2 c3 c4 0 d2 d3 d4\n\nTo overcome this, we repeat the above procedure for all columns (i.e. the minimum element in each column is subtracted from all the elements in that column) and then check if an assignment with penalty 0 is possible.\n\nIn most situations this will give the result, but if it is still not possible then we need to keep going.\n\nStep 3\n\n[edit]\n\nAll zeros in the matrix must be covered by marking as few rows and/or columns as possible. Steps 3 and 4 form one way to accomplish this.\n\nFor each row, try to assign an arbitrary zero. Assigned tasks are represented by starring a zero. Note that assignments can't be in the same row or column.\n\nWe assign the first zero of Row 1. The second zero of Row 1 can't be assigned.\n\nWe assign the first zero of Row 2. The second zero of Row 2 can't be assigned.\n\nZeros on Row 3 and Row 4 can't be assigned, because they are on the same column as the zero assigned on Row 1.\n\nWe could end with another assignment if we choose another ordering of the rows and columns.\n\n0* a2 0 a4 b1 0* b3 0 0 c2 c3 c4 0 d2 d3 d4\n\nStep 4\n\n[edit]\n\nCover all columns containing a (starred) zero.\n\n× × 0* a2 0 a4 b1 0* b3 0 0 c2 c3 c4 0 d2 d3 d4\n\nFind a non-covered zero and prime it (mark it with a prime symbol). If no such zero can be found, meaning all zeroes are covered, skip to step 5.\n\nIf the zero is on the same row as a starred zero, cover the corresponding row, and uncover the column of the starred zero.\n\nThen, GOTO \"Find a non-covered zero and prime it.\"\n\nHere, the second zero of Row 1 is uncovered. Because there is another zero starred on Row 1, we cover Row 1 and uncover Column 1.\n\nThen, the second zero of Row 2 is uncovered. We cover Row 2 and uncover Column 2.\n\n× 0* a2 0' a4 × b1 0* b3 0 0 c2 c3 c4 0 d2 d3 d4\n\n0* a2 0' a4 × b1 0* b3 0' × 0 c2 c3 c4 0 d2 d3 d4\n\nElse the non-covered zero has no assigned zero on its row. We make a path starting from the zero by performing the following steps:\n\nSubstep 1: Find a starred zero on the corresponding column. If there is one, go to Substep 2, else, stop.\n\nSubstep 2: Find a primed zero on the corresponding row (there should always be one). Go to Substep 1.\n\nThe zero on Row 3 is uncovered. We add to the path the first zero of Row 1, then the second zero of Row 1, then we are done.\n\n0* a2 0' a4 × b1 0* b3 0' × 0' c2 c3 c4 0 d2 d3 d4\n\n(Else branch continued) For all zeros encountered during the path, star primed zeros and unstar starred zeros.\n\nAs the path begins and ends by a primed zero when swapping starred zeros, we have assigned one more zero.\n\n0 a2 0* a4 b1 0* b3 0 0* c2 c3 c4 0 d2 d3 d4\n\n(Else branch continued) Unprime all primed zeroes and uncover all lines.\n\nRepeat the previous steps (continue looping until the above \"skip to step 5\" is reached).\n\nWe cover columns 1, 2 and 3. The second zero on Row 2 is uncovered, so we cover Row 2 and uncover Column 2:\n\n× × 0 a2 0* a4 b1 0* b3 0' × 0* c2 c3 c4 0 d2 d3 d4\n\nAll zeros are now covered with a minimal number of rows and columns.\n\nThe aforementioned detailed description is just one way to draw the minimum number of lines to cover all the 0s. Other methods work as well.\n\nStep 5\n\n[edit]\n\nIf the number of starred zeros is n (or in the general case m i n ( n , m ) {\\displaystyle min(n,m)} , where n is the number of people and m is the number of jobs), the algorithm terminates. See the Result subsection below on how to interpret the results.\n\nOtherwise, find the lowest uncovered value. Subtract this from every unmarked element and add it to every element covered by two lines. Go back to step 4.\n\nThis is equivalent to subtracting a number from all rows which are not covered and adding the same number to all columns which are covered. These operations do not change optimal assignments.\n\nResult\n\n[edit]\n\nIf following this specific version of the algorithm, the starred zeros form the minimum assignment.\n\nFrom Kőnig's theorem,[11] the minimum number of lines (minimum vertex cover[12]) will be n (the size of maximum matching[13]). Thus, when n lines are required, minimum cost assignment can be found by looking at only zeroes in the matrix.\n\nBibliography\n\n[edit]\n\nR.E. Burkard, M. Dell'Amico, S. Martello: Assignment Problems (Revised reprint). SIAM, Philadelphia (PA.) 2012. ISBN 978-1-61197-222-1\n\nM. Fischetti, \"Lezioni di Ricerca Operativa\", Edizioni Libreria Progetto Padova, Italia, 1995.\n\nR. Ahuja, T. Magnanti, J. Orlin, \"Network Flows\", Prentice Hall, 1993.\n\nS. Martello, \"Jeno Egerváry: from the origins of the Hungarian algorithm to satellite communication\". Central European Journal of Operational Research 18, 47–58, 2010\n\nReferences\n\n[edit]\n\nBruff, Derek, The Assignment Problem and the Hungarian Method (matrix formalism).\n\nMordecai J. Golin, Bipartite Matching and the Hungarian Method (bigraph formalism), Course Notes, Hong Kong University of Science and Technology.\n\nHungarian maximum matching algorithm (both formalisms), in Brilliant website.\n\nR. A. Pilgrim, Munkres' Assignment Algorithm. Modified for Rectangular Matrices, Course notes, Murray State University.\n\nMike Dawes, The Optimal Assignment Problem, Course notes, University of Western Ontario.\n\nOn Kuhn's Hungarian Method – A tribute from Hungary, András Frank, Egervary Research Group, Pazmany P. setany 1/C, H1117, Budapest, Hungary.\n\nLecture: Fundamentals of Operations Research - Assignment Problem - Hungarian Algorithm, Prof. G. Srinivasan, Department of Management Studies, IIT Madras.\n\nExtension: Assignment sensitivity analysis (with O(n^4) time complexity), Liu, Shell.\n\nSolve any Assignment Problem online, provides a step by step explanation of the Hungarian Algorithm.\n\nImplementations\n\n[edit]\n\nNote that not all of these satisfy the O ( n 3 ) {\\displaystyle O(n^{3})} time complexity, even if they claim so. Some may contain errors, implement the slower O ( n 4 ) {\\displaystyle O(n^{4})} algorithm, or have other inefficiencies. In the worst case, a code example linked from Wikipedia could later be modified to include exploit code. Verification and benchmarking is necessary when using such code examples from unknown authors."
    }
}