{
    "id": "dbpedia_4778_0",
    "rank": 21,
    "data": {
        "url": "https://datatracker.ietf.org/doc/html/draft-duffy-csmp-06",
        "read_more_link": "",
        "language": "en",
        "title": "Cisco's CoAP Simple Management Protocol",
        "top_image": "https://static.ietf.org/dt/12.22.0/ietf/images/ietf-logo-nor-32.png",
        "meta_img": "https://static.ietf.org/dt/12.22.0/ietf/images/ietf-logo-nor-32.png",
        "images": [
            "https://analytics.ietf.org/piwik.php?idsite=7"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Paul Duffy"
        ],
        "publish_date": "2023-12-11T00:00:00",
        "summary": "",
        "meta_description": "Cisco's CoAP Simple Management Protocol (Internet-Draft, 2023)",
        "meta_lang": "en",
        "meta_favicon": "https://static.ietf.org/dt/12.22.0/ietf/images/ietf-logo-nor-180.png",
        "meta_site_name": "IETF Datatracker",
        "canonical_link": "https://datatracker.ietf.org/doc/html/draft-duffy-csmp-06",
        "text": "syntax = \"proto3\"; /* The definitions for CSMP TLVs. This file is directly consumable by the Protocol Buffer tool chain. Requirements are specified using the terminology and conventions as referenced in [RFC2119]. Requirements key words referenced in [RFC2119] must be capitalized. Full details re: Protocol Buffers are accessible at https://developers.google.com/protocol-buffers */ /* CSMP TLV ID Mapping to Protocol Buffer messages. A unique TLV ID MUST be assigned to each CSMP Protocol Buffer message (defined within). An unused TLV ID MAY be assigned to a new message (the new TLV ID assignment MUST be recorded within, along with the defintion of the new message). A Reserved TLV ID MUST NOT be assigned to a message. An existing TLV ID assignment MUST NOT be re-assigned to a new message. NOTE the legend. - Unused: available for assignment. - Reserved: not available for assignment. - All other named messages are currently used by CSMP. All TLV assignments MUST be recorded in the table below. Take care to maintain the numbering. TLVID Message 1 TlvIndex 2 DeviceID 3 Reserved 4 Unused 5 Unused 6 NMSRedirectRequest 7 SessionID 8 DescriptionRequest 9 Unused 10 Reserved 11 HardwareDesc 12 InterfaceDesc 13 ReportSubscribe 14 Reserved 15 Reserved 16 IPAddress 17 IPRoute 18 CurrentTime 19 Reserved 20 Reserved 21 RPLSettings 22 Uptime 23 InterfaceMetrics 24 Reserved 25 IPRouteRPLMetrics 26 Unused 27-29 Reserved 30 PingRequest 31 PingResponse 32 RebootRequest 33 Ieee8021xStatus 34 Ieee80211iStatus 35 WPANStatus 36 DHCP6ClientStatus 37-41 Reserved 42 NMSSettings 43 NMSStatus 44-46 Reserved 47 Ieee8021xSettings 48 Ieee802154BeaconStats 49-52 Reserved 53 RPLInstance 54 Reserved 55 GroupAssign 56 GroupEvict 57 GroupMatch 58 GroupInfo 59 Unused 60 Unused 61 Reserved 62 LowpanMacStats 63 LowpanPhySettings 64 Unused 65 TransferRequest 66 Reserved 67 ImageBlock 68 LoadRequest 69 CancelLoadRequest 70 SetBackupRequest 71 TransferResponse 72 LoadResponse 73 CancelLoadResponse 74 SetBackupResponse 75 FirmwareImageInfo 76 SignatureValidity 77 Signature 78 Reserved 79 SignatureSettings 80 Reserved 81 Reserved 82 Unused 83 Unused 84 Reserved 85 Unused 86 SysResetStats 87 Unused 88 Reserved 89 Unused 90 Unused 91-97 Reserved 98 Unused 99 Unused 100 Reserved 101 Unused 102 Unused 103 Unused 104 Unused 105 Unused 106 Unused 107 Reserved 108 Reserved 109 Unused 110-112 Reserved 113 Unused 114 Unused 115-117 Reserved 118 Unused 119 Unused 120-122 Reserved 123 Unused 124 NetStat 125 Reserved 126 Reserved 127 Vendor Defined TLV 128-131 Reserved 132-139 Unused 140 Reserved 141 NetworkRole 142-151 Reserved 152-154 Unused 155-157 Reserved 158-159 Unused 160-165 Reserved 166-169 Unused 170-171 Reserved 172 CertBundle 173-179 Unused 180 Reserved 181-199 Unused 200-202 Reserved 203-209 Unused 210 Reserved 211 Reserved 212-216 Unused 217-220 Reserved 221-239 Unused 240 Reserved 241 MplStats 242 MplReset 243-299 Unused 301-303 Reserved 304 Unused 305-307 Reserved 308-309 Unused 310-312 Reserved 313 RPLStats 314 DHCP6Stats 315 Reserved 316 Reserved 317-324 Unused 325-337 Reserved 338-339 Unused 340-399 Reserved 400-499 Unused 500 Reserved 501 Reserved 502 Reserved 503-509 Unused 510 Reserved 511 Reserved 512-519 Unused 520 Reserved 521 Reserved 522-529 Unused 530 Reserved 531 Reserved 532-539 Unused 540 Reserved 541-599 Unused 600-607 Reserved 608 ... Unused */ /* Message definitions follow. Tag notation used within ... Class:: designates class of device for which the TLV is relevant. Generic (any IP addressable device) Mesh (Wi-SUN mesh devices) Others TBD. */ package csmp.tlvs; option java_package = \"com.cisco.cgms.protocols.csmp.tlvs\"; // TLV 1 // A list of zero or more TLV IDs // Class:: Generic // message TlvIndex { // list of TLV IDs (string encoded) supported by the device. repeated string tlvid = 1; } // TLV 2 // Primary identifier for a specific device. // Class:: Generic // message DeviceID { oneof type_present { // Set to 1 to indicate EUI-64 format. uint32 type = 1; } oneof id_present { // The unique identifier of the device in EUI-64 format string id = 2; } } // TLV 6 // Used by NMS to force device registration to a specific NMS. // Class:: Generic // message NMSRedirectRequest { oneof url_present { // NMS <base-url> to which the device registration will be directed. // MUST be formatted per section 6 of RFC 7252 string url = 1; } oneof immediate_present { // True == device should immediately send registration request // to the specificed NMS url. bool immediate = 2; } } // TLV 7 // Session ID used by NMS to track device CSMP messaging. // Assigned by the NMS, used in all subsequent Device to NMS messaging. // Class:: Generic // message SessionID { oneof id_present { string id = 1; // session ID } } // TLV 8 // List of zero or more TLVs requested by the NMS from a Device. // The requested TLV values will be sent to the NMS asynchronously. // Class:: Generic // message DescriptionRequest { // list of TLV IDs in string format. repeated string tlvid = 1; } // A list of hardware modules with their firmware versions. // message HardwareModule { oneof moduleType_present { // hardware module type. Rf Dsp=1, PLC Dsp=2, CPU=3, FPGA=4 uint32 moduleType = 1; } oneof firmwareRev_present { // firmware version of the hardware module string firmwareRev = 2; } } // TLV 11 // This TLV contains hardware description information for the device. // The contents of the fields are defined by the equivalently-named // fields in the entry of the SNMP MIB object entPhysicalTable. // Class:: Generic // message HardwareDesc { oneof entPhysicalIndex_present { // index of this hardware being described. int32 entPhysicalIndex = 1; } oneof entPhysicalDescr_present { // A textual description of physical entity. string entPhysicalDescr = 2; } oneof entPhysicalVendorType_present { // An indication of the vendor-specific hardware type of the // physical entity. bytes entPhysicalVendorType = 3; } oneof entPhysicalContainedIn_present { // The value of entPhysicalIndex for the physical entity which // 'contains' this physical entity. int32 entPhysicalContainedIn = 4; } oneof entPhysicalClass_present { // An indication of the general hardware type of the physical // entity. int32 entPhysicalClass = 5; } oneof entPhysicalParentRelPos_present { // An indication of the relative position of this 'child' component // among all its 'sibling' components. int32 entPhysicalParentRelPos = 6; } oneof entPhysicalName_present { // The textual name of the physical entity. string entPhysicalName = 7; } oneof entPhysicalHardwareRev_present { // The vendor-specific hardware revision string for the physical // entity. string entPhysicalHardwareRev = 8; } oneof entPhysicalFirmwareRev_present { // The vendor-specific firmware revision string for the physical // entity. string entPhysicalFirmwareRev = 9; } oneof entPhysicalSoftwareRev_present { // The vendor-specific software revision string for the physical // entity. string entPhysicalSoftwareRev = 10; } oneof entPhysicalSerialNum_present { // The vendor-specific serial number string for the physical // entity. string entPhysicalSerialNum = 11; } oneof entPhysicalMfgName_present { // The name of the manufacturer of this physical component. string entPhysicalMfgName = 12; } oneof entPhysicalModelName_present { // The vendor-specific model name identifier string associated // with this physical component. string entPhysicalModelName = 13; } oneof entPhysicalAssetID_present { // This object is a user-assigned asset tracking identifier for // the physical entity and provides non-volatile storage of this // information. string entPhysicalAssetID = 14; } oneof entPhysicalMfgDate_present { // This object contains the date of manufacturing of the managed // entity. uint32 entPhysicalMfgDate = 15; } oneof entPhysicalURIs_present { // This object contains additional identification information about // the physical entity. string entPhysicalURIs = 16; } oneof entPhysicalFunction_present { // This field can take the following values: METER = 1, // RANGE_EXTENDER = 2, DA_GATEWAY = 3, CGE = 4, ROOT = 5, // CONTROLLER = 6, SENSOR = 7, NETWORKNODE = 8. uint32 entPhysicalFunction = 17; } oneof entPhysicalOUI_present { // uniquely identifies a vendor bytes entPhysicalOUI = 18; } // This defines a list of hardware modules with their // firmware versions repeated HardwareModule hwModule = 19; } // TLV 12 // This TLV contains description information for an interface on // the device. The contents of these fields are defined by the // equivalently-named fields in the SNMP MIB object ifTable. // Class:: Generic // message InterfaceDesc { oneof ifIndex_present { // A unique value, greater than zero, for each interface. int32 ifIndex = 1; } oneof ifName_present { // The textual name of the interface. string ifName = 2; } oneof ifDescr_present { // A textual string containing information about the interface. string ifDescr = 3; } oneof ifType_present { // The type of interface. int32 ifType = 4; } oneof ifMtu_present { // The size of the largest packet which can be sent/received // on the interface, specified in octets. int32 ifMtu = 5; } oneof ifPhysAddress_present { // The interface's address at its protocol sub-layer. bytes ifPhysAddress = 6; } } // TLV 13 // This TLV specifies the periodic reporting of a set of TLVs. // Class:: Generic // message ReportSubscribe { oneof interval_present { // The periodic time interval (in seconds) at which the device // sends the tlvid set of tlvs. uint32 interval = 1; } // The tlvs to be sent on the interval. repeated string tlvid = 2; oneof intervalHeartBeat_present { // The periodic time interval at which the device sends the // tlvidHeartBeat set of tlvs. uint32 intervalHeartBeat = 3; } // The tlvs to be sent on the heartbeat interval. repeated string tlvidHeartBeat = 4; } // TLV 16 // Describes a particular IP address (identified by the index) attached // to an interface. // Class:: Generic // message IPAddress { oneof ipAddressIndex_present { // A unique value, greater than zero, for each IP address int32 ipAddressIndex = 1; } oneof ipAddressAddrType_present { // Address type defined as integers : // ipv4=1, ipvv6=2, ipv4z=3, ipv6z=4, ipv6am=5 uint32 ipAddressAddrType = 2; } oneof ipAddressAddr_present { // The IP address bytes ipAddressAddr = 3; } oneof ipAddressIfIndex_present { // Index of the associated interface int32 ipAddressIfIndex = 4; } oneof ipAddressType_present { // IP type defined as integers : // unicast=1, anycast=2, broadcast=3 uint32 ipAddressType = 5; } oneof ipAddressOrigin_present { // Address origin defined as integers: // other=1, manual=2, dhcp=4, linklayer=5, random=6 uint32 ipAddressOrigin = 6; } oneof ipAddressStatus_present { // status defined as integers: // preferred=1, deprecated=2, invalid=3, inaccessible=4, unknown=5, // tentative=6, duplicate=7, optimistic=8 uint32 ipAddressStatus = 7; } reserved 8; reserved 9; oneof ipAddressPfxLen_present { // The prefix length associated with the IP address. uint32 ipAddressPfxLen = 10; } } // TLV 17 // Describes a particular IP route (identified by the index) attached // to an interface. // Class:: Generic // message IPRoute { oneof inetCidrRouteIndex_present { // A unique value, greater than zero, for each route. int32 inetCidrRouteIndex = 1; } oneof inetCidrRouteDestType_present { // Destination Addresss type defined as integers: // ipv4=1, ipvv6=2, ipv4z=3, ipv6z=4, ipv6am=5. uint32 inetCidrRouteDestType = 2; } oneof inetCidrRouteDest_present { // IP address of the destination of the route. bytes inetCidrRouteDest = 3; } oneof inetCidrRoutePfxLen_present { // Associated prefix length of the route destination. uint32 inetCidrRoutePfxLen = 4; } oneof inetCidrRouteNextHopType_present { // Next hop Addresss type defined as integers: // ipv4=1, ipvv6=2, ipv4z=3, ipv6z=4, ipv6am=5. uint32 inetCidrRouteNextHopType = 5; } oneof inetCidrRouteNextHop_present { // IP address of the next hop of the route (device parent). bytes inetCidrRouteNextHop = 6; } oneof inetCidrRouteIfIndex_present { // Index of the associated interface. int32 inetCidrRouteIfIndex = 7; } reserved 8; reserved 9; reserved 10; } // TLV 18 // Contains the current time as maintainced on the device. // For time stamping purposes, this tlvid MUST also be sent along with // every periodic metric report. It MAY contain a POSIX timestamp // or an ISO 8601 timestamp. // Class:: Generic // message CurrentTime { oneof posix_present { // posix timestamp. uint32 posix = 1; } oneof iso8601_present { // iso 8601 timestamp. string iso8601 = 2; } oneof source_present { // time service from: // local=1, admin=2, network=3. uint32 source = 3; } } // TLV 21 // For retrieving the RPL Settings on the device. // Class:: Mesh // message RPLSettings { oneof ifIndex_present { // interface id int32 ifIndex = 1; } oneof enabled_present { // whether RPL feature is enabled. bool enabled = 2; } oneof dioIntervalMin_present { // min interval of DIO trickle timer in milliseconds. uint32 dioIntervalMin = 3; } oneof dioIntervalMax_present { // max interval of DIO trickle timer in milliseconds. uint32 dioIntervalMax = 4; } oneof daoIntervalMin_present { // min interval of DAO trickle timer in milliseconds. uint32 daoIntervalMin = 5; } oneof daoIntervalMax_present { // max interval of DAO trickle timer in milliseconds. uint32 daoIntervalMax = 6; } oneof mopType_present { // mode of operation for RPL. 1: non-storing mode; 2: storing mode. uint32 mopType = 7; } } // TLV 22 // Contains the total system uptime of the device (seconds). // Class:: Generic // message Uptime { oneof sysUpTime_present { // uptime info in seconds. uint32 sysUpTime = 1; } } // TLV 23 // The statistics of an interface // Class:: Generic // message InterfaceMetrics { oneof ifIndex_present { // A unique value, greater than zero, for each interface. // Is same as in InterfaceDesc's ifIndex for the same interface. int32 ifIndex = 1; } oneof ifInSpeed_present { // The speed at which the incoming packets are received on the // interface. uint32 ifInSpeed = 2; } oneof ifOutSpeed_present { // The speed at which the outgoing packets are transmitted on // the interface. uint32 ifOutSpeed = 3; } oneof ifAdminStatus_present { // The desired state of the interface. uint32 ifAdminStatus = 4; } oneof ifOperStatus_present { // The current operational state of the interface. uint32 ifOperStatus = 5; } oneof ifLastChange_present { // The value of sysUpTime at the time the interface entered its // current operational state. uint32 ifLastChange = 6; } oneof ifInOctets_present { // The total number of octets received on the interface, // including framing characters. uint32 ifInOctets = 7; } oneof ifOutOctets_present { // The total number of octets transmitted out of the interface, // including framing characters. uint32 ifOutOctets = 8; } oneof ifInDiscards_present { // The number of inbound packets which were chosen to be discarded // even though no errors had been detected to prevent their being // deliverable to a higher-layer protocol (application dependant). uint32 ifInDiscards = 9; } oneof ifInErrors_present { // For packet-oriented interfaces, the number of inbound packets // that contained errors preventing them from being deliverable to // a higher-layer protocol (subset of ifInDiscards). uint32 ifInErrors = 10; } oneof ifOutDiscards_present { // The number of outbound packets which were chosen to be discarded // even though no errors had been detected to prevent their being // transmitted. uint32 ifOutDiscards = 11; } oneof ifOutErrors_present { // For packet-oriented interfaces, the number of outbound packets // that could not be transmitted because of errors. uint32 ifOutErrors = 12; } } // TLV 25 // Describes status of each RPL router // Class:: Mesh // message IPRouteRPLMetrics { oneof inetCidrRouteIndex_present { // refers to a particular index in the IPRoute table. int32 inetCidrRouteIndex = 1; } oneof instanceIndex_present { // Corresponding RPL instance of this route. int32 instanceIndex = 2; } oneof rank_present { // advertised rank. int32 rank = 3; } oneof hops_present { // Not currently used, future use of hops metric. int32 hops = 4; } oneof pathEtx_present { // advertised path ethx. int32 pathEtx = 5; } oneof linkEtx_present { // next-hop link ETX. int32 linkEtx = 6; } oneof rssiForward_present { // forward RSSI value (relative to the device). sint32 rssiForward = 7; } oneof rssiReverse_present { // reverse RSSI value (relative to the device). sint32 rssiReverse = 8; } oneof lqiForward_present { // forward LQI value. int32 lqiForward = 9; } oneof lqiReverse_present { // reverse LQI value. int32 lqiReverse = 10; } oneof dagSize_present { // nodes count of this pan (number of joined devices). uint32 dagSize = 11; } reserved 12 to 17; // forward phy mode value. PhyModeInfo phyModeForward = 18; // reverse phy mode value. PhyModeInfo phyModeReverse = 19; } // TLV 30 // Request the device to perform a ping operation to a // destination address. // Class:: Generic // message PingRequest { oneof dest_present { // IP address to be pinged from the device. string dest = 1; } oneof count_present { // number of times to ping. uint32 count = 2; } oneof delay_present { // delay between ping in seconds. uint32 delay = 3; } } // TLV 31 // Acquire the current status of the last PingRequest. // Class:: Generic // message PingResponse { oneof sent_present { // number of packets sent uint32 sent = 1; } oneof received_present { // number of packets received uint32 received = 2; } oneof minRtt_present { // min round trip time uint32 minRtt = 3; } oneof meanRtt_present { // mean round trip time uint32 meanRtt = 4; } oneof maxRtt_present { // max round trip time uint32 maxRtt = 5; } oneof stdevRtt_present { // standard deviation of the round trip time uint32 stdevRtt = 6; } oneof src_present { // source IP address for the ping string src = 7; } } // TLV 32 // Request a device to reboot. // Class:: Generic // message RebootRequest { oneof flag_present { // 0 : reboot and transfer to designated running image. // 1 : reboot and stop at bootloader CLI. uint32 flag = 1; } } // TLV 33 // 802.1x status // Class:: Mesh // message Ieee8021xStatus { oneof ifIndex_present { // It is RECOMMENDED this be set to 2 for the 6LowPAN interface. int32 ifIndex = 1; } oneof enabled_present { // 802.1x enabled or not? bool enabled = 2; } oneof identity_present { // subject name of certificate, max len 32 string identity = 3; } oneof state_present { // state of tls handshake uint32 state = 4; } oneof pmKId_present { // hash value of pmk, len 16 bytes pmkId = 5; } oneof clientCertValid_present { // whether client cert is valid bool clientCertValid = 6; } oneof caCertValid_present { // whether ca cert is valid bool caCertValid = 7; } oneof privateKeyValid_present { // whether private key of client cert is valid bool privateKeyValid = 8; } oneof rlyPanid_present { // panid of relay node uint32 rlyPanid = 9; } oneof rlyAddress_present { // eui64 address of relay node, len 8 bytes rlyAddress = 10; } oneof rlyLastHeard_present { // last heard from relay node in seconds uint32 rlyLastHeard = 11; } } // TLV 34 // 802.11i status // Class:: Mesh // message Ieee80211iStatus { oneof ifIndex_present { // It is RECOMMENDED this be set to 2 for the 6LowPAN interface. int32 ifIndex = 1; } oneof enabled_present { // 802.11i is eabled or not bool enabled = 2; } oneof pmkId_present { // hash value of pmk, len 16 bytes pmkId = 3; } oneof ptkId_present { // hash value of ptk, len 16 bytes ptkId = 4; } oneof gtkIndex_present { // index of gtk int32 gtkIndex = 5; } oneof gtkAllFresh_present { // whether all gtk are fresh bool gtkAllFresh = 6; } // list of hash value for each gtk, hash len 8, max repeat 4 repeated bytes gtkList = 7; // list of lifetime for each gtk, hash len 8, max repeat 4 repeated uint32 gtkLifetimes = 8; oneof authAddress_present { // eui64 address of authenticate node bytes authAddress = 9; } } message PhyModeInfo { oneof phyMode_present { // phy operating mode value (as defined in section 5.2 of // PHYWG Wi-SUN PHY Technical Specification - Amendment 1VA8) uint32 phyMode = 1; } oneof txPower_present { // transmit power value in dbm. int32 txPower = 2; } } // TLV 35 // Configuration of WPAN-specific interface settings // Class:: Mesh // message WPANStatus { oneof ifIndex_present { // It is RECOMMENDED this be set to 2 for the 6LowPAN interface. int32 ifIndex = 1; } oneof SSID_present { // Max len 32 (Wi-SUN NetName). bytes SSID = 2; } oneof panid_present { uint32 panid = 3; } reserved 4; oneof dot1xEnabled_present { // Is dot1x enabled? bool dot1xEnabled = 5; } oneof securityLevel_present { // Security level uint32 securityLevel = 6; } oneof rank_present { uint32 rank = 7; } oneof beaconValid_present { // Is beacon valid (where invalid means receipt has // timed-out/contact with PAN was lost)? (PC frame for Wi-SUN) bool beaconValid = 8; } oneof beaconVersion_present { // Beacon version (Wi-SUN PAN version). uint32 beaconVersion = 9; } oneof beaconAge_present { // Last heard beacon message in seconds (PC frame for Wi-SUN). uint32 beaconAge = 10; } oneof txPower_present { // Transmit power value in dbm int32 txPower = 11; } oneof dagSize_present { // Count of nodes joined to this PAN uint32 dagSize = 12; } oneof metric_present { // Metric to border router (Wi-SUN Routing Cost) uint32 metric = 13; } oneof lastChanged_present { // seconds since last PAN change (PAN ID change). uint32 lastChanged = 14; } oneof lastChangedReason_present { // Reason for last PAN change: // -1 == unknown, // 0 == mesh initializing, // 1 == mesh connectivity lost, // 2 == GTK timeout, // 3 == default route lost, // 4 == migrated to better PAN, // 5 == reserved. uint32 lastChangedReason = 15; } oneof demoModeEnabled_present { // Is demo mode enabled? bool demoModeEnabled = 16; } oneof txFec_present { // Is FEC enabled? bool txFec = 17; } oneof phyMode_present { // Phy operating mode value (as defined in section 5.2 of // PHYWG Wi-SUN PHY Technical Specification - Amendment 1VA8) uint32 phyMode = 18; } reserved 19; // Multi phy mode and transmit power value for adaptive modulation. repeated PhyModeInfo phyModeList = 20; } // TLV 36 // Status of DHCP6 client // Class:: Generic // message DHCP6ClientStatus { oneof ifIndex_present { // It is RECOMMENDED this be set to 2 for the 6LowPAN interface int32 ifIndex = 1; } oneof ianaIAID_present { // TA ID value. uint32 ianaIAID = 2; } oneof ianaT1_present { // T1 value. uint32 ianaT1 = 3; } oneof ianaT2_present { // T2 value. uint32 ianaT2 = 4; } } // TLV 42 // Configure device reporting settings. // Class:: Generic // message NMSSettings { oneof regIntervalMin_present { // Min interval of register trickle timer in seconds. uint32 regIntervalMin = 1; } oneof regIntervalMax_present { // Max interval of register trickle timer in seconds. uint32 regIntervalMax = 2; } reserved 3 to 6; } // TLV 43 // Registration status to NMS. // NMS uses this TLV to record the reason for the registration // operation as recorded in the lastRegReason field of the TLV. // Class:: Generic // message NMSStatus { oneof registered_present { // True if device is registerd with NMS. bool registered = 1; } oneof NMSAddr_present { // IPv6 address of NMS. bytes NMSAddr = 2; } oneof NMSAddrOrigin_present { // Mechanism used to get NMS's IPv6 address. // (fixed/DHCPv6/redirect by TLV6 ... values). uint32 NMSAddrOrigin = 3; } oneof lastReg_present { // Time since last succesful registration in seconds. uint32 lastReg = 4; } oneof lastRegReason_present { // Reason for last registration: // 1: coldstart, // 2: administrative, // 3: IP address changed, // 4: NMS changed, // 5: NMS redirect, // 6: NMS error, // 7: IDevID, LDevID, or NMS certificate changed, // 8: outage recovery. uint32 lastRegReason = 5; } oneof nextReg_present { // Time to next registration attempt in seconds. uint32 nextReg = 6; } oneof NMSCertValid_present { // True if NMS certificate is valid. bool NMSCertValid = 7; } } // TLV 47 // Device settings for 802.1x // Class:: Mesh // message Ieee8021xSettings { oneof ifIndex_present { // It is RECOMMENDED this be set to 2 for the 6LowPAN interface. int32 ifIndex = 1; } oneof secMode_present { // Security mode, non-security or security (Security Level from // Aux Security Header of IEEE 802.15.4-2020). uint32 secMode = 2; } oneof authIntervalMin_present { // Min interval of 802.1x trickle timer in seconds. uint32 authIntervalMin = 3; } oneof authIntervalMax_present { // Max interval of 802.1x trickle timer in seconds. uint32 authIntervalMax = 4; } oneof immediate_present { // True == do 802.1x authentication immediately, // False == do 802.1x authentication at next authentication // interval. bool immediate = 5; } } // TLV 48 // Statistic of 802.15.4 beacon packets // Class:: Mesh // message Ieee802154BeaconStats { oneof ifIndex_present { // It is RECOMMENDED this be set to 2 for the 6LowPAN interface. int32 ifIndex = 1; } oneof inFrames_present { // Count of received beacon. uint32 inFrames = 10; } oneof inFramesBeaconPAS_present { // Count of received PAS beacon. uint32 inFramesBeaconPAS = 11; } oneof inFramesBeaconPA_present { // Count of received PA beacon. uint32 inFramesBeaconPA = 12; } oneof inFramesBeaconPCS_present { // Count of received PCS beacon. uint32 inFramesBeaconPCS = 13; } oneof inFramesBeaconPC_present { // Count of received PC beacon. uint32 inFramesBeaconPC = 14; } oneof outFrames_present { // Count of all sent out beacon. uint32 outFrames = 20; } oneof outFramesBeaconPAS_present { // Count of sent out PAS beacon. uint32 outFramesBeaconPAS = 21; } oneof outFramesBeaconPA_present { // Count of sent out PA beacon. uint32 outFramesBeaconPA = 22; } oneof outFramesBeaconPCS_present { // Count of sent out PCS beacon. uint32 outFramesBeaconPCS = 23; } oneof outFramesBeaconPC_present { // Count of sent out PC beacon. uint32 outFramesBeaconPC = 24; } } // TLV 53 // Indicates RPL instance information // Class:: Mesh // message RPLInstance { oneof instanceIndex_present { // Index for instance. int32 instanceIndex = 1; } oneof instanceId_present { // Instance id. int32 instanceId = 2; } oneof doDagId_present { // DODAG id, len 16. bytes doDagId = 3; } oneof doDagVersionNumber_present { // DODAG version number of instance. int32 doDagVersionNumber = 4; } oneof rank_present { // Rank value. int32 rank = 5; } oneof parentCount_present { // Count of available parents (Wi-SUN candidate parent set). int32 parentCount = 6; } oneof dagSize_present { // Node count of this DODAG. uint32 dagSize = 7; } // Max repeat 3. repeated RPLParent parents = 8; // Max repeat 3. repeated RPLParent candidates = 9; } message RPLParent { oneof parentIndex_present { // This parent's index in the RPLParent table. int32 parentIndex = 1; } oneof instanceIndex_present { // A particular index in the RPLInstance table that this // parent underlies. int32 instanceIndex = 2; } oneof routeIndex_present { // A particular index in the IPRoute table that this // parent underlies. int32 routeIndex = 3; } oneof ipv6AddressLocal_present { // IPv6 linklocal address. bytes ipv6AddressLocal = 4; } oneof ipv6AddressGlobal_present { // IPv6 global address. bytes ipv6AddressGlobal = 5; } oneof doDagVersionNumber_present { // DODAG version number if RPL parent. uint32 doDagVersionNumber = 6; } oneof pathEtx_present { // The parent's ETX back to the root. int32 pathEtx = 7; } oneof linkEtx_present { // The node's ETX to its next-hop. int32 linkEtx = 8; } oneof rssiForward_present { // Forward RSSI value. sint32 rssiForward = 9; } oneof rssiReverse_present { // Reverse RSSI value. sint32 rssiReverse = 10; } oneof lqiForward_present { // Forward LQI value. int32 lqiForward = 11; } oneof lqiReverse_present { // Reverse LQI value. int32 lqiReverse = 12; } oneof hops_present { // parent's hop value. int32 hops = 13; } } // Groups in CSMP provide a mechanism to realize application // layer multicast in the network. A group is uniquely defined by // a type, id pair. Membership within a group type is exclusive, // i.e., a device can be a member of only one group-id within a // group-type. However, a device can be a member of more than one // group of different group-types. // A device is informed about its membership to a group using the // GroupAssign TLV. On their very first boot, devices do not // belong to any group. A device is added to a group by sending a // GroupAssign TLV to the device. Receipt of a GroupAssign TLV // replaces any existing group assignments. GroupAssign may occur // either by direct unicast to a device or in the registration // response from the NMS to the device. Note that a GroupAssign // should not be sent over multicast, because it would possibly // cause some group members to change and some group members not // to change. // Group membership information MUST be stored in persistent // storage so that once a device has been assigned any group it is // remembered across reboots. A device will only process multicast // messages containing a GroupMatch TLV if the device belongs to a // group specified by the GroupMatch TLV. // TLV 55 // Class:: Generic // message GroupAssign { oneof type_present { uint32 type = 1; } oneof id_present { uint32 id = 2; } } // TLV 57 // Class:: Generic // message GroupMatch { oneof type_present { uint32 type = 1; } oneof id_present { uint32 id = 2; } } // TLV 58 // Class:: Generic // GET to a device for this TLV MAY illicit a response with one or // more GroupInfo TLVs. // message GroupInfo { oneof type_present { uint32 type = 1; } oneof id_present { uint32 id = 2; } } message LowpanMacCounters { oneof inFrames_present { // Count of all received frames. uint32 inFrames = 1; } oneof inFramesBeacon_present { // Count of received beacon frames (Note: Wi-SUN does // not use Beacon frames). uint32 inFramesBeacon = 2; } oneof inFramesData_present { // Count of received data frames. uint32 inFramesData = 3; } oneof inFramesAck_present { // Count of received ack frames. uint32 inFramesAck = 4; } oneof inFramesCmd_present { // Count of received command frames. uint32 inFramesCmd = 5; } oneof inFramesAsync_present { // Count of received async frames. uint32 inFramesAsync = 6; } oneof inFramesBcast_present { // Count of received broadcast frames. uint32 inFramesBcast = 7; } oneof inFramesUcast_present { // Count of received unicast frames. uint32 inFramesUcast = 8; } oneof outFrames_present { // Count of all sent out frames. uint32 outFrames = 9; } oneof outFramesBeacon_present { // Count of sent out beacon frames. uint32 outFramesBeacon = 10; } oneof outFramesData_present { // Count of sent out data frames. uint32 outFramesData = 11; } oneof outFramesAck_present { // Count of sent out ack frames. uint32 outFramesAck = 12; } oneof outFramesCmd_present { // Count of sent out command frames. uint32 outFramesCmd = 13; } oneof outFramesAsync_present { // Count of sent out async frames. uint32 outFramesAsync = 14; } oneof outFramesBcast_present { // Count of recesent outived broadcast frames. uint32 outFramesBcast = 15; } oneof outFramesUcast_present { // Count of sent out unicast frames. uint32 outFramesUcast = 16; } } // TLV 62 // Statistic of lowpan mac layer // Class:: Mesh // message LowpanMacStats { // Total counter of lowpan mac layer. LowpanMacCounters total = 1; // RF counter of lowpan mac layer. LowpanMacCounters rf = 2; reserved 3; } // TLV 63 // Configuration of RF PHY // Class:: Mesh // message LowpanPhySettings { oneof lowpanRF_present { // 1 == enable lowpan RF, 0 == disable. uint32 lowpanRF = 1; } reserved 2; } // TLV 65 - 75 are for firmware upgrade. // Usage is detailed in main body of the CSMP specification. // message HardwareInfo { oneof hwId_present { // Hardware information, max len 32. string hwId = 1; } oneof vendorHwId_present { // Sub hardware information, max len 32. string vendorHwId = 2; } } // TLV 65 // Start to transfer firmware // Class:: Generic // message TransferRequest { // Hardware information. HardwareInfo hwInfo = 1; oneof fileHash_present { // SHA256 hash value of image file, len 32. bytes fileHash = 2; } oneof fileName_present { // Name of image file, max len 128. string fileName = 3; } oneof version_present { // Version number, max len 32. string version = 4; } oneof fileSize_present { // Total size of image file. uint32 fileSize = 5; } oneof blockSize_present { // Block size of image file. uint32 blockSize = 6; } reserved 7 to 11; } // TLV 67 // Class:: Generic // message ImageBlock { oneof fileHash_present{ // SHA256 hash value of image file, len 32. bytes fileHash = 1; } oneof blockNum_present { // Block number 0, 1, 2, etc. uint32 blockNum = 2; } oneof blockData_present { // Block context, max len 1024. bytes blockData = 4; } } // TLV 68 // Firmware load request // Class:: Generic // message LoadRequest { oneof fileHash_present { // SHA256 hash value of image file, len 32. bytes fileHash = 1; } oneof loadTime_present { // UTC time to load image, set to 1 to load immediately. uint32 loadTime = 2; } } // TLV 69 // Firmware cancel load request // Class:: Generic // message CancelLoadRequest { oneof fileHash_present { // SHA256 hash value of image file, len 32. bytes fileHash = 1; } } // TLV 70 // Set firmware to backup slot // Class:: Generic // message SetBackupRequest { oneof fileHash_present { // SHA256 hash value of image file, len 32. bytes fileHash = 1; } } /* ResponseCodes enum { // The request was successfully processed. OK = 0; // Device hardware type does not match // the request's hardware type. INCOMPATIBLE_HW = 1; // Image operation cannot be completed, // device only has partial image. IMAGE_INCOMPLETE = 2; // File hash does not match any image // available on the device. UNKNOWN_HASH = 3; // Image download is denied, filesize // of the new image is too large. FILE_SIZE_TOO_BIG = 4; // Image signature check failed. SIGNATURE_FAILED = 5; // Invalid request. INVALID_REQ = 6; // Invalid image block size. INVALID_BLOCK_SIZE = 7; // Request cannot be processed, // conflict with a pending device reboot. PENDING_REBOOT = 8; // Cancel reboot request cannot be processed, // image is already running. IMAGE_RUNNING = 9; } */ // TLV 71 // Response for TLV 65 TransferRequest // Class:: Generic // message TransferResponse { oneof fileHash_present { // SHA256 hash value of image file, len 32. bytes fileHash = 1; } oneof response_present { // Refer to ResponseCodes. uint32 response = 2; } } // TLV 72 // Response for TLV 68 LoadRequest // Class:: Generic // message LoadResponse { oneof fileHash_present { // SHA256 hash value of image file, len 32. bytes fileHash = 1; } oneof response_present { // refer to ResponseCodes. uint32 response = 2; } oneof loadTime_present { // UTC time to load image. uint32 loadTime = 3; } } // TLV 73 // Response for TLV 69 CancelLoadRequest // Class:: Generic // message CancelLoadResponse { oneof fileHash_present { // SHA256 hash value of image file, len 32. bytes fileHash = 1; } oneof response_present { // Refer to ResponseCodes. uint32 response = 2; } } // TLV 74 // Class:: Generic // message SetBackupResponse { oneof fileHash_present { // SHA256 hash value of image file, len 32. bytes fileHash = 1; } oneof response_present { // Refer to ResponseCodes. uint32 response = 2; } } // TLV 75 // Image information // Class:: Generic // message FirmwareImageInfo { oneof index_present { uint32 index = 1; } oneof fileHash_present { // SAH256 hash value of image file, len 32. bytes fileHash = 2; } oneof fileName_present { // name of image file, max len 128. string fileName = 3; } oneof version_present { // version number, man len 32. string version = 4; } oneof fileSize_present { // total size of image file. uint32 fileSize = 5; } oneof blockSize_present { // block size of image file. uint32 blockSize = 6; } oneof bitmap_present { // bitmap of image file, max len 128. Big endian. // 1 means block was received, 0 means block was not received. bytes bitmap = 7; } oneof isDefault_present { // True if default image. bool isDefault = 8; } oneof isRunning_present { // True if running image. bool isRunning = 9; } oneof loadTime_present { // UTC time to load. 1 means load immediately. uint32 loadTime = 10; } // hardware information HardwareInfo hwInfo = 11; oneof bitmapOffset_present { // When present, MUST be set to indicate the start block // number of bitmap. Block numbering is 0 based. uint32 bitmapOffset = 12; } reserved 13 to 15; } // TLV 76 // Class:: Generic // message SignatureValidity { oneof notBefore_present { // Posix time. uint32 notBefore = 1; } oneof notAfter_present { // Posix time. uint32 notAfter = 2; } } // TLV 77 // Class:: Generic // message Signature { oneof value_present { bytes value = 1; } } // TLV 79 // Configuration of signature check settings about message from NMS // Class:: Generic // message SignatureSettings { oneof reqSignedPost_present { // Check signature in POST message from NMS? bool reqSignedPost = 1; } oneof reqValidCheckPost_present { // Time valid check in POST message from NMS? bool reqValidCheckPost = 2; } oneof reqTimeSyncPost_present { // Return fail when node doesn't have global time in // POST message from NMS? bool reqTimeSyncPost = 3; } oneof reqSecLocalPost_present { // Check signature in POST message from console? bool reqSecLocalPost = 4; } oneof reqSignedResp_present { // Check signature in response message from NMS // during registration? bool reqSignedResp = 5; } oneof reqValidCheckResp_present { // Time valid check in response message from NMS // during registration? bool reqValidCheckResp = 6; } oneof reqTimeSyncResp_present { // Return fail when node doesn't have global time in // response message from NMS during registration? bool reqTimeSyncResp = 7; } oneof reqSecLocalResp_present { // Check signature in response message from console // during registation? bool reqSecLocalResp = 8; } oneof cert_present { // Certificate context, used to change NMS's // certificate, max len 512. bytes cert = 9; } } message HardwareResetCount { oneof total_present { uint32 total = 1; } oneof externalReset_present { // External reset reason. uint32 externalReset = 2; } oneof powerOnReset_present { // Power on reset reason. uint32 powerOnReset = 3; } } message SoftwareResetCount { oneof total_present { uint32 total = 1; } oneof FWLoadReset_present { // Firmware reload. uint32 FWLoadReset = 2; } oneof CSMPRebootReset_present { // Reload forced by CSMP TLV. uint32 CSMPRebootReset = 3; } oneof vendorProgramReset_present { // Reload forced by vendor's APP. uint32 vendorProgramReset = 4; } oneof cfgLoadReset_present { // Reload config file. uint32 cfgLoadReset = 5; } } message ExceptionResetCount { oneof total_present { uint32 total = 1; } oneof IWDGReset_present { // Watchdog forced reset. uint32 IWDGReset = 2; } oneof cstackOverflowReset_present { // Stack over flow reset. uint32 cstackOverflowReset = 3; } oneof EPFReset_present { // GPIO reset. uint32 EPFReset = 4; } } // TLV 86 // Count of all types of reset in the system, include hardware reset, // software reset and exception reset. // Class:: Generic // message SysResetStats { oneof total_present { // Reset counters. uint32 total = 1; } HardwareResetCount hardwareReset = 2; SoftwareResetCount softwareReset = 3; ExceptionResetCount exceptionReset = 4; } // TLV 124 // Status of device network module, similar as netstat command in linux // Class:: Generic // message NetStat { oneof sessionIndex_present { // Session index. int32 sessionIndex = 1; } oneof protocol_present { // 6 TCP, // 17 UDP. uint32 protocol = 2; } oneof localAddress_present { //IPv4 or IPv6 local address. bytes localAddress = 3; } oneof localPort_present { // Local port number. uint32 localPort = 4; } oneof peerAddress_present { // IPv4 or IPv6 peer address. bytes peerAddress = 5; } oneof peerPort_present { // Peer port number. uint32 peerPort = 6; } oneof state_present { uint32 state = 7; } oneof role_present { // 1 - server/incoming, // 2 - client/outgoing. uint32 role = 8; } } // TLV 141 // Indicate the network role of device // Class:: Generic // message NetworkRole { // 0 - SYSTEM_DEFAULT, // 1 - TRANSIT_NODE, // 2 - LEAF_NODE. uint32 preference = 1; } message CertInfoEntry { oneof type_present { // 1 - FND public key, // 2 - 802.1x CA, // 3 - 802.1x public key, // 4 - iDevID public key. uint32 type = 1; } oneof certSubj_present { // Certificate subject name, max length 128. string certSubj = 2; } oneof certValidNotBefore_present { // Not before of valid time, max length 16. string certValidNotBefore = 3; } oneof certValidNotAfter_present { // Not after of valid time, max length 16. string certValidNotAfter = 4; } oneof certFingerprint_present { // Certificate finger print, max length 20. bytes certFingerprint = 5; } } // TLV 172 // Device Certificate Bundle TLV. // message CertBundle { // Max repeat is 5. repeated CertInfoEntry certInfo = 1; } // TLV 241 // Statistic of MPL packet // Class:: Mesh // message MplStats { oneof dataSent_present { // Count of sent data packets. uint32 dataSent = 1; } oneof dataReceived_present { // Count of received data packets. uint32 dataReceived = 2; } oneof dataError_present { // Count of error data packets. uint32 dataError = 3; } oneof dataSentDuplicate_present { // Count of duplicate sent data packets. uint32 dataSentDuplicate = 4; } oneof dataReceivedDuplicate_present { // Count of duplicate received data packets. uint32 dataReceivedDuplicate = 5; } oneof controlSent_present { // Count of send control packets. uint32 controlSent = 6; } oneof controlReceived_present { // Count of received control packets. uint32 controlReceived = 7; } oneof controlError_present { // Count of error control packets. uint32 controlError = 8; } } // TLV 242 // Reset statistic of MPL packet // Class:: Mesh // message MplReset { oneof stats_present { // True means reset MPL statistics. bool stats = 8; } } // TLV 313 // Statistics for RPL messages // Class:: Mesh // message RPLStats { oneof inFramesDIS_present { // Count of received DIS packets. uint32 inFramesDIS = 1; } oneof inFramesDIO_present { // Count of received DIO packets. uint32 inFramesDIO = 2; } oneof inFramesDAO_present { // Count of received DAO packets. uint32 inFramesDAO = 3; } oneof outFramesDIS_present { // Count of sent DIS packets. uint32 outFramesDIS = 4; } oneof outFramesDIO_present { // Count of sent DIO packets. uint32 outFramesDIO = 5; } oneof outFramesDAO_present { // Count of sent DAO packets. uint32 outFramesDAO = 6; } oneof outFramesNoPathDAO_present { // Count of sent no-path DAO packets. uint32 outFramesNoPathDAO = 7; } oneof outFramesNS_present { // Count of sent neighbor solicit packets. uint32 outFramesNS = 8; } } // TLV 314 // Statistics for DHCPv6 messages // Class:: Generic // message DHCP6Stats { oneof clientFramesSolicit_present { // Count of sent solicit packets. uint32 clientFramesSolicit = 1; } oneof clientFramesAdvertise_present { // Count of sent advertise packets. uint32 clientFramesAdvertise = 2; } oneof clientFramesRequest_present { // Count of sent request packets. uint32 clientFramesRequest = 3; } oneof clientFramesReply_present { // Count of sent reply packets. uint32 clientFramesReply = 4; } oneof relayFramesForward_present { // Count of DHCP relay packets forwarded by node. uint32 relayFramesForward = 5; } oneof relayFramesReply_present { // Count of DHCP relay packets relayed by node. uint32 relayFramesReply = 6; } }\n\n¶"
    }
}