{
    "id": "dbpedia_2453_3",
    "rank": 20,
    "data": {
        "url": "https://arxiv.org/html/2403.09682v1",
        "read_more_link": "",
        "language": "en",
        "title": "On the Theory of Quantum and Towards Practical Computation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://arxiv.org/html/x1.png",
            "https://arxiv.org/html/x2.png",
            "https://arxiv.org/html/x3.png",
            "https://arxiv.org/html/x4.png",
            "https://arxiv.org/html/x5.png",
            "https://arxiv.org/html/x6.png",
            "https://arxiv.org/html/x7.png",
            "https://arxiv.org/html/x8.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Quantum Computation Fundamentals Review History Open Questions Quantum Phenomena Technology Algorithm Design Pattern Application."
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "HTML conversions sometimes display errors due to content that did not convert correctly from the source. This paper uses the following packages that are not yet supported by the HTML conversion tool. Feedback on these issues are not necessary; they are known and are being worked on.\n\nfailed: chronology\n\nAuthors: achieve the best HTML results from your LaTeX submissions by following these best practices.\n\nLicense: CC BY 4.0\n\narXiv:2403.09682v1 [physics.pop-ph] 07 Feb 2024\n\n11institutetext: University of Zagreb Faculty of Organization and Informatics,\n\nRepublic of Croatia\n\nOn the Theory of Quantum and Towards Practical Computation\n\nRobert Kudelić\n\nAbstract\n\nQuantum computing exposes the brilliance of quantum mechanics through computer science and, as such, gives oneself a marvelous and exhilarating journey to go through. This article leads along that journey with a historical and current outlook on quantum computation that is geared toward computer experts but also to experts from other disciplines as well. It is an article that will bridge the vast gap between classical and quantum computation and open an entering wedge through which one will be able to both bring himself up to speed on quantum computation and, intrinsically, in a straightforward manner, become acquainted with it. We are indeed in luck to be living in an age where computing is being reinvented, and not only seeing history in the making firsthand but, in fact, having the opportunity to be the ones who are reinventing–and that is quite a thought.\n\nKeywords:\n\nQuantum Computation Fundamentals Review History Open Questions Quantum Phenomena Technology Algorithm Design Pattern Application.\n\n1 For Once It All Began\n\nHow vast the chasm is, how difficult it is to grasp it, and how steep the learning curve has become–and perhaps always has been–is a realization to which one arrives when, for the first time, tries to bring oneself to a destination called quantum (QTM) computation. It is an awe-inspiring journey that through this article we will relive, unsealing its complex secrets, and gradually grasping computation known as quantum computation .\n\nBefore we therefore begin with the subject at hand, it would be of interest to give a brief historical background and a more forward motivation behind this work . It all began long ago, perhaps some years before what is typically remembered. All the way back in 1935, the principles of quantum mechanics where already heavily discussed [27, 66], namely superposition (particle being in multiple states at the same time, until observed [64]) and entanglement (correlation between particle states no matter the distance between them [64]), which we will soon define in more detail, that are so crucial to quantum computation as well [4]. A number of decades prior to those events, on December 14, 1900, to be exact, Max Planck struck the beginning of quantum mechanics \"at a meeting of the German Physical Society\". [191] Those were tumultuous and exciting days, I presume , but the best was yet to come. A few decades have passed, and ideas and research were advancing to and fro. Some scientists, excited, trying to advance the theory of quantum mechanics, while others were working against it, but not only against it, even fighting it –which in science is business as usual: That which nature’s physical systems deny, needs to perish.\n\nThen one day, as the knowledge increased, some started pondering about computation that is microscopic and able to simulate physical systems with which classical computers have difficulty. [204] That person, right at the forefront, thinking these \"microscopic\" thoughts that were far beyond the abilities of those days was Richard Feynman. [204, 5] It is not known when exactly he first started pondering the idea of a quantum computer, but what is known is that in his 1959 talk, he was predicting an enormous miniaturization of technology, even to the size of an atom. [204, 5] There was nothing that he saw in the laws of nature that wouldn’t allow this miniaturization, and he was speaking about it. [204, 5] Time has passed, and Feynman, together with other scientists, tried to advance the issue. Then something happened, and a theory so necessary for practical quantum computation started to emerge .\n\nIn 1981, Feynman gave a conference talk on \"simulating physics with computers\" [204, 38], which was later published as an edited transcript [204] in a scientific journal [70]–and for all intents and purposes this event launched \"quantum computing as a field of study\" [204, 5], \"which established the beginning of quantum information theory\" [38]. At about the same time, others were investigating as well, and from then onward, nothing was ever the same. What is fascinating is that both Manin [140] and Benioff [17] were just a year prior, in 1980, bringing into the foreground ideas of large significance. Manin was in his book Computable and Uncomputable [97, 204] discussing how simulating a many-particle system requires exponential cost on a classical computer [204, 140, 5], while Benioff went further down the quantum line, complementing Manin, in explaining how one would describe computation from the quantum outlook and suggesting by the construction of such a model that quantum computation might be a possibility [17].\n\nOn a bit different note, the question that was continually puzzling Einstein, whether two particles really can be entangled and have correlation between their states without a hidden information, was being experimentally answered by Alain Aspect et al., and the answer was yes , they can. [38] With the first real-world experiments that were successful and conducted a decade earlier, in 1972 by Freedman and Clauser (which in turn depended on the work of Carl Kocher [120]), and with an extra-strong correlation being observed [43, 74], Aspect’s work, where \"the greatest violation of generalized Bell’s inequalities\" [9] ever was achieved, has put the predictions of quantum mechanics strongly on the map.\n\nOnly a few years later, in 1985, another important advance came when David Deutsch \"formalized the notion of a quantum computer\" [204, 60] and raised the question: \"Whether quantum computers might have an advantage over classical computers at solving problems that have nothing to do with quantum physics\" [204, 60]. True, the algorithm that Deutsch and Jozsa later published [61] was of little practical significance, but it showed superiority in efficiency of the quantum algorithm over its deterministic classical counterpart. [61, 237] Thinking about quantum computation and ideas that came through Benioff [17] and Feynman [70] Deutsch was led to in 1989 propose what later became the standard model for describing quantum computation, the well-known circuit-gate model [62]. [5]\n\nWith Deutsch formalizing the notion of quantum computer, Umesh Vazirani and his student Ethan Bernstein were formulating \"a contrived problem that a quantum computer could solve with a super-polynomial speedup over a classical computer\" [204, 23]–that was in 1993 [22], that is . The same superiority was presented in 1994 by Daniel Simon, who showed that by solving the idealized version of the problem, which is finding the function period, quantum computers could indeed achieve an exponential improvement in speed when compared to their classical counterparts. [237, 238, 204] And despite the fact that Simon’s idea, just like the one from Deutsch, had little practical weight and no application in sight, that was soon to change, for in just a short while, tremendous happenings will occur for quantum computation. [204]\n\nThe same idea and an instance where quantum computers would show their superiority has, in 1994, inspired Peter Shor to baffle the world and publish the paper in which he presented an efficient way for Fourier transform calculation, which he used for a definition of an efficient algorithm for computing discrete logarithms–and all this was done for a quantum computer. [232, 235, 204] But that was not the end. A few days later, after the aforementioned breakthrough, and by using similar ideas [204], in the same seminal paper, Shor presented \"an efficient quantum algorithm for factoring large numbers\" [232, 204]. [232, 235] The implications for cryptanalysis were enormous , and the interest in quantum computing has once again exploded. [204]\n\nAll was not well in the land called Q-Country, though, and at the same time those great achievements were being made, a dark cloud was looming over quantum computation, and that dark cloud was called decoherence –an inability for a computer to compute in a quantum manner because of interaction with the outside world . [204, 127, 256, 92] But the question of decoherence was already being tackled and is one of the main issues with quantum hardware that remains to be tackled to this day. [144, 33, 44, 32] Shor himself has already, in 1995 and 1996, published research on quantum error-correcting codes and on fault-tolerant methods by which one could compute on quantum hardware, which is rather noisy, in a reliable manner. [234, 246, 233, 204] And with that, \"by the end of 1996 it was understood, at least in principle, that quantum computing could be scaled up to large devices that solve very hard problems, assuming that errors afflicting the hardware are not too common or strongly correlated\" [204, 3, 119, 202]–which is confirmed by the latest research dealing with quantum computation, scalability, and decoherence : \"fault-tolerant quantum computation will be practically realizable.\" [123].\n\nDuring those same exciting times [204], as John Preskill adequately called them [204, 201], another important realization was happening. It was the year 1995 when Cirac and Zoller published that, with the tools in atomic physics and quantum optics, one could implement a quantum computer and perform quantum logical operations. [47] Building on that foundation, a few months later in the same year, Monroe et. al. demonstrated a fundamental quantum logic gate, \"operation of a two-bit controlled-NOT quantum logic gate\", to be exact [150], which, coupled with simple single-bit operations, formed a universal quantum logic gate [150]–this was quite important piece of the quantum computing puzzle, since if correct and practical model of computation can not be found, then all efforts, perspiration and tears would be in vain. With previous breakthroughs, especially those that happened during the last decennia of the 20th century, a strong foundation was laid, and it seemed quite possible that one day quantum computation would be a reality. The possibility of that reality was never given up, and research continued.\n\nThen, soon after Shor presented his Las Vegas quantum algorithms [232], in 1996 Lov Grover emerged with another fascinating discovery: it is possible to search a database for an entry in N𝑁\\sqrt{N}square-root start_ARG italic_N end_ARG time and identify a record with a probability of 1212\\frac{1}{2}divide start_ARG 1 end_ARG start_ARG 2 end_ARG [87]–which then represents quantum Monte Carlo, and is asymptotically optimal [89], and by repeated sampling, this probability can arbitrarily grow [87]. A substantial achievement since classical machines, both deterministic and probabilistic, will need N2𝑁2\\frac{N}{2}divide start_ARG italic_N end_ARG start_ARG 2 end_ARG time to achieve the same probability bound of 1212\\frac{1}{2}divide start_ARG 1 end_ARG start_ARG 2 end_ARG, and only in an ordered list via Binary search can classical machines achieve log2⁡Nsubscript2𝑁\\log_{2}Nroman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_N time. [88] Some, as well researching in quantum computing, were advancing tools for better understanding such computations and developing theories for quantum state machines, 1997 was the year. [154, 155, 121]\n\nShortly after, just a few years have passed, in 2001, the company was IBM, and scientists there have announced that successful testing of a quantum computer has been conducted. The capacity of the machine was 7777 qubits (first register 3333, second register 4444), and the quantum computer itself was implemented by nuclear magnetic resonance . [222] Shor’s algorithm was executed on this machine, and by employing quantum effects, number 15151515 was factorized [222]–this achievement was for the history books, deserving of noting big success. Then again, in 2007 , a validation came when scientists at the University of Queensland (UQ) experimentally demonstrated execution of Shor’s algorithm for large number factorization by \"using quantum logic gates based on photon polarization\"–they have also factorized number 15151515 (first register 3333 qubits, second register 4444 qubits). [222] At this stage, quantum computation has gone from theory to practice. By the end of the 1990s, enough foundational theory had been discovered, and the beginning of the 21st century was the dawn of practical quantum computation. Machines are being built, and algorithms are being implemented , and now theory and practice go together.\n\nAnd so in 2009 and 2012 new experiments have confirmed the reality of quantum computation, making it even stronger; one more successful experimental demonstration of Shor’s algorithm has taken place, the method was an integrated wave-guide based on a silicon chip, with only 4444 qubits based on photons used for factorization of number 15151515 (first register 1111 qubit, second register 3333 qubits). [222] And as a supplementation, in 2012, at the University of California (UC), one more experiment successfully factored number 15151515, Shor’s algorithm in action, \"using phase qubits and superconducting wave resonators\", with 4444 qubits, just like the previous group of researchers (but in the first register there were 2222 qubits, and in the second 2222 as well). [222]\n\nThis series of implementations of quantum computers and successful algorithm runs continued, and soon there was quite a group of scientists that have dabbled in quantum computing and have witnessed its strangeness and marvelousness at the same time, e.g. Martin-Lopez et al. in [141] with factoring number 21212121, via Shor, \"using only two photon-based qubits\" (2012), Nanyang Xu et al. in [273] turning factorization problem into optimization problem, by a scheme from Burges from Microsoft Research, and factoring number 143143143143 with 4444 qubits only, this was an adiabatic algorithm run on a liquid crystal nuclear magnetic resonance quantum processor, and for example, Thomas Monz et al. in [152], via five trapped calcium ions on a quantum computer, implemented a scalable version of Shor’s algorithm, with the approach providing \"potential for designing a powerful quantum computer, but with fewer resources.\" [222]\n\nNext, it was to IBM again, which has seriously grabbed quantum computation and was making strides. It was 2016, when the company announced the creation of a 5555 qubit quantum computer, where one qubit would correct errors, with the computing device being based on a \"five-qubit superconducting chip with star geometry and implementation of the complete Clifford algebra .\" [222] The machine was programmable; it allowed for the creation of gates and the modeling of operations. [222] But the progress has not stopped there, as in 2017, in May, to be exact, another announcement was to be made: quantum computers with 16161616 and 17171717 qubits have been implemented; and then an enormous leap, in November of 2017, IBM announced a quantum device with 50505050 qubits, where 20202020 qubits were used for computation and 30303030 were used for error correction. [222] It was possible for this quantum device to maintain its qubits in a coherent state for up to 90909090 μ⁢s𝜇𝑠\\mu sitalic_μ italic_s, and the device was with consumption of 10−15101510-1510 - 15 k⁢W𝑘𝑊kWitalic_k italic_W of power \"sufficiently energy-efficient\"–without including the energy for device cooling outside work. [222]\n\nQuantum computing research was now beyond its fledgling days, and in 2016, the first quantum satellite was launched from China , Micius it was called. [38] The goal of the space mission was to \"perform quantum experiments at space scale\", which was an important achievement for quantum communication and space science at the same time. [38] This attempt at a space-scale quantum leap in 2020 resulted in a new milestone for space quantum communications when, via Micius, a secure link, by quantum key distribution , was established between two on-ground stations that were separated by 1120 kilometers. [275] While these events were happening, another breakthrough was in the making.\n\nIntel was interested in quantum computation, and this they loudly expounded in January 2018 when a declaration was made of superconducting quantum chip implementation, the name was Tangle Lake, quite an Intelish name, I might add, and the number of qubits was 49494949. [222, 104] This event was followed by one coming from Google, for they presented in March 2018 a new quantum superconducting processor, Bristlecone, with a capacity of 72727272 qubits. [222, 115] This device was a continuation of a previous one announced a few years ago with 9999 qubits and a rather low level of error, which was 1%percent11\\%1 % for data reading, with 0.1%percent0.10.1\\%0.1 % and 0.6%percent0.60.6\\%0.6 % for one-qubit and two-qubit quantum gates, respectively. [222] With a two-dimensional structure of two 6⋅6⋅666\\cdot 66 ⋅ 6 arrays that are placed one above the other, the system can track the errors happening during computation and correct them . [222]\n\nWith the ever-moving advance of quantum devices, research was continuing in different aspects of quantum mechanics, an important element for quantum computation, and although evidence is still not conclusive, in 2018, quantum entanglement was observed in objects almost visible to the naked eye, a potential application of which could be seen in quantum internet and physics research. [214, 198]\n\nIn 2019, the Google AI Quantum group declaimed [204] \"a 52-qubit superconducting chip named Sycamore, which they claim has demonstrated quantum supremacy\" [213, 156]. A first claim of this type and a very exciting one, however, when one looks back from a distance, only then it is often the case that a man can clearly see what was the event that made something of something; it might be that it was this one, but perhaps it was not just yet. [222, 193]\n\nAs it seems that the previous question has not been answered yet, let us jump to one that is, namely, quantum entanglement. In 2022, after decades of effort and research, it seems that Einstein’s \"spooky action at a distance\" has finally been thoroughly investigated and brought into the realm of fact, since in the year mentioned, Aspect, Clauser, and Zeilinger received the Nobel Prize in Physics [253], and while this research article is not about rewards, a question that has for many decades puzzled some of the best minds deserves a mention . The last loophole in a well known Bell’s test has been closed in 2015 [94], thus supporting quantum theory [146], the universe we live in is not anymore strange; it is quantum entangled and magnificently fascinating.\n\nIf the previous event seemed imposing, the next one is in at least the same category, for in 2023 a reversing protocol for a quantum system has been demonstrated, with authors noting that this new understanding of quantum mechanics could have application in quantum information technology. [225, 255] The protocol is a universal time-reversing mechanism with an arbitrarily high probability of success, where interference of different paths in the end causes the system to jump to the state it had some T𝑇Titalic_T time units before–the protocol is \"requiring no knowledge of the quantum process to be rewound, is optimal in its running time, and brings quantum rewinding into a regime of practical relevance.\" [225, 255]\n\nWhat brings us at the cusp of time, it is still unknown what technology will prevail [213], or if it will perhaps be a mixture of the two, quantum and classical working in tandem, a most probable outcome, but what can be stated with greater certainty is that the next ten years will probably reveal and answer far more in terms of quantum machines usefulness and area of their specialty.\n\nWhile the history of quantum computing is for the time being concluded, what comes next is an open question, a choice, and a work that is yours.\n\n2 Quantumness of Quantum Computing\n\nEven though quantum computing has seen great progress, it seems that it is a subject with which scientists and practitioners are still not that familiar. There are probably at least these reasons behind it: their education has not covered the topic, they still do not see the use of such a tool, the state of quantum computing is still far from mainstream, and the link between quantum physics and computing is not an easy one to make. It is also a matter of fact that quantum computation is a sub-discipline that is multidisciplinary in its essence and requires experts with vastly different backgrounds [157], as such, it represents a sub-discipline for which it is difficult to get your brain around.\n\nIf one searches through existing scientific papers, a substantial number of articles will now be found, and the articles range from theory to practice, from the synthesis of knowledge to algorithms. Naturally, the papers include important elements that one needs when dealing with quantum computing. It is, however, problematic that so many of these elements present a stumbling block in that learning curve towards quantum way of conducting work–quantum computation is so vastly different from classical computing, and it is perhaps in the beginning quite daunting to come from classical computation, where one knows much, to quantum computation, where one knows little.\n\nFor example, right at the start of one’s journey to the universe of quantum, instead of a classical bit for information storage, one is confronted with a quantum bit, i.e. a qubit. And instead of storing one value, as in a bit, in quantum computation, one has a situation where one qubit is in both states [153] (both levels) simultaneously.\n\nAfter dealing with the qubit question, one is confronted with other quantum computing peculiarities like entanglement and collapse of quantum states through observation. It is almost one big thing after another, and to get to grips with these and other questions, the goals of this research article on quantum computation are the following:\n\nHistorical Outlook\n\nDevelop a never-before-published historical context of quantum computing that is encompassing and detailed without missing valuable information, precise, covering milestones, and presenting the most significant achievements.\n\nTheory Chronology\n\nSynthesize a one-of-a-kind broad, deep, precise, and thoroughly referenced chronological outlook on quantum computing, both textually and visually, through a timeline presenting a broad picture of the field and segments of its history that will expound on the progression of the theory, present those that came before, and show links between quantum phenomena and other fields.\n\nFoundational Terminology\n\nThe basis of any theory, together with axioms, theorems, lemmas, and corollaries, is its terminology and definitions of those terms. The literature at the moment offers no complete, deep, and well-referenced material. Such a state of the matter leads to confusion and a lack of understanding in terms of quantum computing. A compendium of such nature is therefore a must; thus, to construct and present such a work is one of the goals of this paper.\n\nStandard Model\n\nAs a way of delving into the practical part of quantum computing and gearing toward computer experts in a streamlined and straightforward manner , quantum computing knowledge will be combined through a standard model of computation, with special emphasis on foundational high-level quantum algorithm modeling and a design pattern.\n\nGeneral Outlook\n\nSynthesis of the present state of the art with the future importance and possibilities of quantum computing. Embedding discussion on problems still in need of solving while not forgetting those pervasive open questions.\n\nFrom Now to Beyond\n\nProvide a number of quality literature materials that will present themselves as an extended arm of this research. Facilitating an even broader reach of the research conducted and enabling future research and algorithm development through a compact number of reliable steps to the next breakthroughs and game-changers.\n\nIn order to achieve previous goals, an effort will be made to cater to the computer science mind and to build a strong theoretical foundation and intuition. Thus enabling a correct, consistent, and deep understanding of quantum computation and quantum mechanics’ phenomena. With the introduction over, the next step in the journey is foundational terminology.\n\n3 Foundational Terminology\n\nWhen one is dealing with any subject, there are primarily two ways in which he can proceed to expose the issue. The first is to start with a general and then build in a top-down manner. The second is, of course, to start with concrete and then build in a bottom-up manner. They both have their pros and cons, with the latter being more fascinating and interesting, but perhaps in certain instances it is more difficult to understand in such a way, with the former being more conceptual and gradual, but not a stumbling block on the mind while trying to grasp some complex new idea. One would choose one or the other depending on the subject, audience, and perhaps some other factors as well.\n\nIt is often the case, perhaps even exclusively, in the scientific literature, at least in the discipline of quantum computation, that the more practical approach, which is bottom-up, is used. Considering that quantum computation at its best is physics in action, that approach is logical and has its merits. However, quantum mechanics is so strange and at times so counter-intuitive that it is quite challenging to understand its complex essence, and the mind has an issue combing all those different threads of thought at the same time–for thinking, one needs time, and for thinking about quantum computation, one needs a considerable amount of time. And if learning is impeded, if the subject has not been understood, one cannot expect great results from then on.\n\nTherefore, in order to continue the strain of thought from previous sections, to give the mind the necessary time for information incubation, and to build up essential intuition, before we delve into some concrete examples of quantum computation essential for the review and an outlook that is being written, we will first define a broad range of terms that will be linked to that practical quantum computation and revealing of fascinating knowledge about it, but not so overwhelming that it will impede progress more than it would be expected. The first stop will then, fittingly, be the definition of quantum mechanics.\n\nQuantum Mechanics It is said of physicists that quantum mechanics represents the most complete as well as the most accurate description of the universe we live in. [157] It is a theory consisting of rules and principles that define a framework that is then, in turn, used in order to develop other physical theories. [157] What these rules, principles, and mathematics are, we will soon see.\n\nQuantum Computing The act of using those rules and principles of quantum mechanics in order to carry out computation is then called quantum computing. [213] Quantum computing has two powerful mechanisms through which computation is performed, namely superposition and entanglement, and these have no counterpart in classical computation. [213] Such is the nature of computation that is quantum, and these are its key advantages. [213] It is well known what data is and what information is, but how is that transferred into the realm of quantum? We will answer that next.\n\nQuantum Information Those well-established definitions and understandings of data and information are at a general level unchanged; however, at the practical level, the situation is quite different. According to the well-known no-cloning theorem, quantum data cannot be copied, and as such, it lasts only as long as the program lasts . [268, 213] Data is, to a physicist, an encodable and storable feature that can be processed \"in some physical system using some physical process.\" [204] Data may then be regarded as a feature that one stores and processes in a quantum state. [204]\n\nQuantum Bit A qubit, or quantum bit, represents an indivisible unit of quantum data. [204] Abstract qubits can be encoded in a physical quantum system, and that qubit can be \"an atom, an electron, a photon, an electrical circuit, or something else.\" [204] Unlike a classical bit that can be 00 or 1111, a qubit can be in multiple states simultaneously, mathematically described as a vector in a complex Hilbert space , \"with two mutually orthogonal basis states which we can label |0⟩ket0|0\\rangle| 0 ⟩ and |1⟩ket1|1\\rangle| 1 ⟩.\" [204] These orthonormal states can, for example, correspond to a different polarization of a photon or perhaps to a different spin of an electron. [215]\n\nSuperposition Feature of being quantized, Fig. 5, and having infinite degrees of freedom, that is, being in multiple states at the same time (linear combination)–until observation has been made. [249, 280] This feature represents one of the two main pillars of quantum mechanics, the other being entanglement. [29] Through superposition, one has access to the real power of quantum computation via the exponential state space of multiple qubits. [215] \"Just as a single qubit can be in a superposition of 00 and 1111, a register of n𝑛nitalic_n qubits can be in a superposition of all 2nsuperscript2𝑛2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT possible values.\" [215]\n\nEntanglement Quantum state where particles, Fig. 6, and in quantum computing qubits, are locked, with one exhibiting an influence on the other (there is a correlation between particle states, e.g. one particle collapses to 00, the consequence of which is that the other then measures to 1111). [213] Distance between particles does not play a role; that is, entanglement correlation works regardless of the distance between particles–this is a phenomenon of which Einstein did not speak so kindly when he said, \"spooky action at a distance\" [213], but it turned out to be correct nevertheless [188, 190]. Data is in quantum computation and is therefore stored both in qubits and in relationships between them, with the amount of stored data being exponential in the number of qubits. [204]\n\nBell State Quantum state, also known as EPR (Einstein, Podolsky, Rosen) pair of two qubits that are in superposition and are maximally, in regard to correlation, quantumly entangled. [250, 16] These Bell states can be both symmetric and asymmetric (e.g. 1111 and 1111, or 1111 and 00), [250, 76] with applications in quantum teleportation [230], dense coding [197], information processing [59], privacy protection [129], cryptography [252], networks [281], optics [132], etc.\n\nTeleportation Enabled by particles that are in a quantum state and entangled, where an unknown particle state is transferred between far apart parties, from one party to another, from one particle to another, but the particle itself is not sent. [4] In the procedure for such an event, before teleportation can take place, some source S𝑆Sitalic_S needs to generate an entangled pair and send particles to their respective destinations. [196] Then, when quantum communication can begin and data transfer happen, after one side has made a measurement, the other side needs to be contacted via classical channels, bound by no faster than light communication, so as to inform them of the measurement parameters for observation, through which the other side will ultimately receive quantum data via the obtained state. [215, 196]\n\nDense Coding Protocol that is dual to teleportation, Fig. 7, and depends on the entanglement that is described in the EPR experiment; it uses a single qubit in order to transfer, that is, transmit, two bits (in terms of classical information). [215] If source and destination have a particle of EPR entangled pair with maximal correlation, which source has prepared and then sent one particle to destination, it is then possible to transmit two bits of classical data via only one qubit by applying a unitary operator at destination and returning that particle back to source, where party at the source can now jointly measure both particles, that is, the entire EPR pair, and naturally, also learn of the operator party at the destination used in order to manipulate the particle that it received. [21]\n\nMeasurement Disturbing the quantum state by making an observation, Fig. 8, intended or otherwise. [215] Quantum measurement is probabilistic, and it is not an easy task to \"pick\" the result one would like to receive. [215] Since data from a qubit can only be obtained by measurement, regardless of the superposition of states, in the end it is possible to extract only one classical state, in terms of data, from a qubit–and the reason is that when measurement takes place, the superposition collapses and the state is changed to one of the basis states. [215] In order to describe the phenomena of quantum mechanics, scientists have used complex numbers, but as the imaginary part of the phenomenon description is not observable in the physical world, out of the four dimensions that we would need for two base states of quantum computing, one would have only two dimensions; thus, the Bloch sphere has three dimensions, two for polarization and one for the base states. [248] New information is however coming into focus, as it seems that there are entangled states that are distinguishable only by their imaginary component [270, 271, 212, 39, 135]–as fascinating as these discoveries are, whether the imaginary number mathematical trick used to facilitate calculations is necessary for the physical world is yet to be determined via the mountain of evidence that future research needs to provide.\n\nQuantum Gate An operator, also known as a quantum logic gate, is used to both create and manipulate quantum states. [150, 285] It is an elementary quantum circuit that makes operations on a small number of quantum bits. [150, 285] With these, one is building a complex quantum circuit, and this complex circuit is enabling the execution of an algorithm on the quantum machine. [150, 285]\n\nQuantum Circuit Model of computation consisting of a series of qubits (or some sort of quantum data storage), initializations, gates, and measurements. [63, 40, 72]\n\nQuantum Algorithm An algorithm, much like a classical algorithm, that uses quantum effects and represents a sequence of steps, which in turn, by a number of operations, manipulate the initial quantum state for some input, and at the final stage, with measurement being taken, the algorithm returns the correct answer. [4]\n\nQuantum Parallelism The effect present in quantum systems where the amount of parallelism increases exponentially as the size of the system itself, that is, the physical space required, increases linearly. [61] As n𝑛nitalic_n qubits allow one to work at the same time with 2nsuperscript2𝑛2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT states, quantum parallelism is the effect that gives quantum computing its superiority as it bypasses the classical restriction of time/space tradeoff by giving an exponential quantity of computation space in a linear quantity of real physical space, and therefore quantum machines can compute solutions to all possibilities at the same time, while classical computers can compute only for one input state at the same time. [215]\n\nInterference When measurement is performed on a superposition of output states for a particular input, what one will receive is a random collapse to one state out of all states in the superposition, Fig. 9, with all other states, that is, values, being destroyed. [215] In this way, one cannot reliably compute, and such a behavior needs to somehow be guided. Interference allows us to do exactly that, guide towards desirable output. With interference, it is possible to cause a cancellation between exponentially many input parallel states , with the goal being to produce such an interference between states, that is of the wave function , so as to destroy all undesirable states and collapse into exactly the one we need. [4] The combination of quantum parallelism and interference gives quantum computation tremendous power, and its use in quantum algorithms is essential. [4, 38]\n\nDecoherence For the reason of the interaction of the quantum system and its environment, which is inevitable, the state of a quantum system is extremely fragile, Fig. 10, and thus due to this interaction, the quantum nature of the system can be lost–this loss of quantum information, this distortion , and collapse of superposition due to interaction of the quantum system with its surroundings is called decoherence. [4, 215]\n\nBy reading the text to this point, a first quantum computation has already been performed; in fact, probably more than a few were done in one’s mind. This incubation of data and information has not only made one knowledgeable about the subject of quantum computing but has also developed intuition and a crucial way of thinking needed for such a topic as quantum computation. And now, with neurons and pathways of the brain speaking quantum computation, we will deal in a bit more detail with topics that were touched upon, but for which one’s scientific curiosity, trying to decode the universe we live in, wants more.\n\n4 Quantum Effects and the Universe we Live in\n\nSome time has passed since the event, when during one of his talks, Nobel Prize winner Ivar Giaever told the story of his youth and a job that he applied for and received. After getting the job, his mentor told him a story about quantum mechanics, more specifically tunneling–the story was so strange that Giaever’s own words will best explain his disposition: \"I did not believe a word of what he told me, nothing.\" Giaever got his job and decided to be quiet, but what is it that his mentor, John Fisher, told young Giaever?\n\nHe told him a story of small particles; he told him a story of the underlying laws of physics that are the foundation of the world we live in; he told him that if one would throw a tennis ball in the wall, that ball would eventually cross the wall and end up on the other side, in the same condition in which it was before it went through the wall; and to top it off, he told Giaever that there would be no hole in the wall. Now that was some story, like something from a fairytale, and Giaever’s reaction of not believing a word of what he was told was expected.\n\nDuring that fascinating talk, Giaever expositioned, explaining that what if one would take an extremely small particle for a ball, i.e. electron, and throw that ball toward obstacles that are very close to one another, distanced in a few atoms, and are not touching? In that case, there is a finite probability that an electron will find itself on the other side of the obstacle, never being in between. That is quantum tunneling, and that is for what Giaever shared his Nobel Prize, in 1973. [176] Quantum effects are real and are typically observable only with very small particles , on an atomic and subatomic level.\n\nQuantum effects are dependent on a wave function and its accompanying probability that a state will be observed. This wave-particle duality was an outstanding discovery with profound consequences that are shaking science to this day. [7] The differences between classical and quantum systems are many, with one of the more intricate being the answer to the question of what one knows about one type of system and, of course, the other. If we know everything about a classical system, including all its characteristics, we naturally know everything about its components; however, this does not hold for quantum systems, which can clearly be seen in a quantum phenomenon called entanglement. [204, 206, 227] One could, for example, have a composite quantum system, i.e. A⁢B𝐴𝐵ABitalic_A italic_B, and know everything about that system’s laws of physics would allow us to know, despite of that fact, if one would observe just part of the system, i.e. B𝐵Bitalic_B, information needed to completely characterize that part of the system is missing, as the series of expectations for the subsystem depends on an unknown value of the variable for some other subsystem, in this instance, on the observation of A𝐴Aitalic_A. [227, 204]\n\nThis series of expectations, being a consequence of superposition, is linked to entanglement in a meaningful way. Extra states, with no analog in a classical system, leading \"to the exponential size of the quantum state space are the entangled states\". [215] In this way, by undergoing initialization, quantum state transformations, and measurement, a quantum system achieves its result. [215]\n\nEven though we live in the quantum world, seldom do we think about it, but the macroscopic world we are surrounded with is not isolated from its own surroundings and is therefore in uninterrupted interactions with the environment, meaning it is continually measured, a phenomenon aforementioned and called decoherence. [204] Such a quantum system, continually being observed, represents a system known from the down of time and \"is well described by classical physics.\" [204] Though \"weird,\" a vast number of experiments have shown that quantum mechanics correctly describes physical reality. In order to combat decoherence in quantum computers, a breakthrough came, but not from the physical side, as was perhaps expected. [215] It was theorized by some that quantum error correction is beyond our abilities \"because of the impossibility of reliably copying an unknown quantum state\", yet it was not so, as it is possible via error-correcting techniques to design error-correcting codes by which one can detect specific errors and reconstruct \"the exact error-free quantum state.\" [215]\n\nAnd so this battle between decoherence and superposition continually \"rages.\" A quantum system can perform an enormous amount of computation in parallel, but accessing the desired result is far from easy. [215, 157] In order to read the result, quantum state is disturbed, only one of those parallel threads is read, and as the measurement is probabilistic in nature, \"we cannot even choose which one we get.\" [215] It is, however, possible to skillfully deal with the problem of measurement and thus exploit quantum parallelism; \"this sort of manipulation has no classical analog and requires nontraditional programming techniques.\" [215] Shor’s factorization algorithm manipulates quantum states in such a way that the \"common property of all of the output values can be read off\" [215], and in this way direct toward the output one would like to achieve, while, for example, Grover’s search algorithm makes amplification through which the probability that the result of interest will be read is increased, thus manipulating quantum states. [87, 232, 215]\n\nBasic operations in any classical algorithm are data copying and data deletion. While trying to project this to a quantum computer, one comes to a brick wall, as this is not possible in a quantum system, perfect copying of an unknown quantum state is an intrinsic impossibility, as per the no-cloning theorem , not just a limitation of laboratory conditions. [215, 223] If, on the other hand, we disregard the notion that the copy needs to be perfect (producing a perfect copy of a limited number of quantum states with probability <1absent1<1< 1), then one can devise an apparatus (a copier or cloner) by which copying can be conducted, reproducing the desired state through an approximation or to a degree of probability. [98]\n\nAs one might presume, with copying being such a stepping stone, data deletion also differs substantially from the classical case. If one assumes that there are two identical copies of an arbitrary and unknown quantum state to be deleted, this process actually cannot be accomplished (as per the no-deleting theorem), aside from deleting approximately –as is the case for quantum cloning; however, just as is the case for cloning, the process of deletion is possible if one deals with known orthogonal states. [221, 192] This inability to clone and delete quantum information, but only express possibilities already in existence, postulates conservation of quantum information, as information cannot be created nor destroyed. [192, 288]\n\nRelated to cloning and deleting quantum information is the inability to hide information, known as the no-hiding theorem. [192] If a quantum system interacts with its surroundings and loses information, that information actually is not missing; it simply resides somewhere else in the universe–that is, correlations between the system and the environment are not able to hide information . [192, 288]\n\nIn spite of all the hurdles we go through when trying to discover new knowledge and understand the universe in which we are, this same quantum universe works perfectly and mindbogglingly precise, with quantum computers being devised and in operation. That being said, scientific discovery and painstaking experimentation have produced criteria for successful implementation of a device that would be called a quantum computer; they are found in [63], and are as follows:\n\nI\n\n\"A scalable physical system with well characterized qubits\", that is, a collection of qubits with physical parameters that are accurately known,\n\nII\n\n\"The ability to initialize the state of the qubits to a simple fiducial state, such as 000000000000\", that is, initializing quantum registers to a known value before one starts computing,\n\nIII\n\n\"Long relevant decoherence times, much longer than the gate operation time\", that is, dynamics with the environment brings about quantum state decay with which quantum computation is possible,\n\nIV\n\n\"A ’universal’ set of quantum gates\", that is, a set of quantum gates that are able to implement via a finite sequence of gates any quantum operation,\n\nV\n\n\"A qubit-specific measurement capability\", that is, the capacity to be able to measure specific qubits.\n\nIn addition to the previous five, two additional ones are added, namely \"the ability to inter-convert stationary and flying qubits\" and \"the ability to faithfully transmit flying qubits between specified locations\", in order to achieve quantum communication, as not all information processing is only computation. [63] The need for the additional two criteria is clearly seen in quantum key distribution [20], and quantum cryptography [63]. It is, however, not an easy task to transmit a qubit from one place to another, and when this is done, decoherence plays an important hurdle to overcome. [82, 204]\n\nIn spite of all of its strangeness, quantum mechanics has withstood the test of time, and for the time being, it stands supreme. But just as is the case for the theory of relativity and Newtonian physics, so is the case for quantum and classical physics; both are needed. In fact, classical is quantum, but simply for large objects for which wavelengths are so small that they cannot be measured. Thus, if something functions specifically, it does not mean that it functions generally, but if it does not function generally, it does not mean that it is not useful. With the next section most definitely being useful, as it deals with quantum gates and algorithms.\n\n5 Computation with Quantum Gates\n\nFundamentally speaking, as is the case when one does classical computation, by analogy, so is the situation for quantum computation, since in order to manipulate quantum information, one needs quantum gates that are then forming a quantum circuit and consequently a quantum algorithm. There is a myriad of quantum gates, e.g. Identity (I), Not (NOT or PauliX), Controlled Not (CNOT), Controlled Controlled Not (CCNOT or Toffoli), Swap (SWAP or S), Hadamard (H), Phase (P), etc. [145, 245], with some being a single qubit gate while others are multiple qubit.\n\nBefore we proceed into a more in-depth look at quantum computation, we will first expound on a number of quantum gates, as this knowledge is essential for understanding quantum circuits. Let’s start with the quantum gate, whose classical equivalent should be known to every computer expert and physicist: the NOT gate. Let us assume that superposition states, from now on, that we will use shall be |0⟩ket0\\ket{0}| start_ARG 0 end_ARG ⟩ and |1⟩ket1\\ket{1}| start_ARG 1 end_ARG ⟩, with |ψ⟩=a⁢|0⟩+b⁢|1⟩ket𝜓𝑎ket0𝑏ket1\\ket{\\psi}=a\\ket{0}+b\\ket{1}| start_ARG italic_ψ end_ARG ⟩ = italic_a | start_ARG 0 end_ARG ⟩ + italic_b | start_ARG 1 end_ARG ⟩. This basis is called the computational or standard basis and is in three-dimensional space represented by the axes Z, therefore the Z-basis, which is \"generally the only basis in which we can make measurements of the system.\" [53]\n\nNOT Not gate is a single qubit gate. [145] Denoted as well as PauliX (named after Wolfgang Pauli, who received the Nobel Prize in Physics in 1945, proposing \"that no two electrons in an atom could have identical sets of quantum numbers\" that correspond to \"distinct states of energy and movement.\" [170]), as the operation it makes is a rotation by π𝜋\\piitalic_π radians around the X𝑋Xitalic_X axis. [145] As a consequence of this rotation, there is a mapping, |0⟩→|1⟩→ket0ket1\\ket{0}\\rightarrow\\ket{1}| start_ARG 0 end_ARG ⟩ → | start_ARG 1 end_ARG ⟩ and |1⟩→|0⟩→ket1ket0\\ket{1}\\rightarrow\\ket{0}| start_ARG 1 end_ARG ⟩ → | start_ARG 0 end_ARG ⟩. [145] The transformation matrix used in order to calculate an output for the gate and its input is [145],\n\nN⁢O⁢T=[0110]𝑁𝑂𝑇matrix0110NOT=\\begin{bmatrix}0&1\\\\ 1&0\\end{bmatrix}italic_N italic_O italic_T = [ start_ARG start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW end_ARG ] (1)\n\nH Hadamard gate is a single qubit gate. [145] Known also as the Walsh-Hadamard gate (named after Jacques Hadamard [113] and Joseph Walsh [103]), the gate makes an operation of superposition–for a basis state, the superposition that is created is equal in probability. [145, 113] Superposition is created by making a rotation of π𝜋\\piitalic_π radians around the axis between the X𝑋Xitalic_X axis and the Z𝑍Zitalic_Z axis. [265] As a consequence of this superposition operation, there is a mapping, |0⟩→|0⟩+|1⟩2→ket0ket0ket12\\ket{0}\\rightarrow\\frac{\\ket{0}+\\ket{1}}{\\sqrt{2}}| start_ARG 0 end_ARG ⟩ → divide start_ARG | start_ARG 0 end_ARG ⟩ + | start_ARG 1 end_ARG ⟩ end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG and |1⟩→|0⟩−|1⟩2→ket1ket0ket12\\ket{1}\\rightarrow\\frac{\\ket{0}-\\ket{1}}{\\sqrt{2}}| start_ARG 1 end_ARG ⟩ → divide start_ARG | start_ARG 0 end_ARG ⟩ - | start_ARG 1 end_ARG ⟩ end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG. [145] If we apply the Hadamard operation twice, a particle is placed into a superposition of states and then returned to its original state. [231] The transformation matrix used in order to calculate an output for the gate and its input is [145],\n\nH=12⁢[111−1]𝐻12matrix1111H=\\dfrac{1}{\\sqrt{2}}\\begin{bmatrix}1&1\\\\ 1&-1\\end{bmatrix}italic_H = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG [ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL 1 end_CELL start_CELL - 1 end_CELL end_ROW end_ARG ] (2)\n\nP Phase gate is a single qubit gate . [145] Known also as the Phase Shift gate, as the gate makes an operation of shifting a qubit’s phase with probabilities for the qubit staying unchanged, that is, probabilities for basis states, |0⟩ket0\\ket{0}| start_ARG 0 end_ARG ⟩ and |1⟩ket1\\ket{1}| start_ARG 1 end_ARG ⟩, remain the same. [145] As the phase is shifted, there is a mapping, |0⟩→|0⟩→ket0ket0\\ket{0}\\rightarrow\\ket{0}| start_ARG 0 end_ARG ⟩ → | start_ARG 0 end_ARG ⟩ and |1⟩→ei⁢θ⁢|1⟩→ket1superscript𝑒𝑖𝜃ket1\\ket{1}\\rightarrow e^{i\\theta}\\ket{1}| start_ARG 1 end_ARG ⟩ → italic_e start_POSTSUPERSCRIPT italic_i italic_θ end_POSTSUPERSCRIPT | start_ARG 1 end_ARG ⟩, with θ𝜃\\thetaitalic_θ being a phase shift and the period being 2⁢π2𝜋2\\pi2 italic_π. [145, 75] The transformation matrix used in order to calculate an output for the gate and its input is [145],\n\nPθ=[100ei⁢θ]subscript𝑃𝜃matrix100superscript𝑒𝑖𝜃P_{\\theta}=\\begin{bmatrix}1&0\\\\ 0&e^{i\\theta}\\end{bmatrix}italic_P start_POSTSUBSCRIPT italic_θ end_POSTSUBSCRIPT = [ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL italic_e start_POSTSUPERSCRIPT italic_i italic_θ end_POSTSUPERSCRIPT end_CELL end_ROW end_ARG ] (3)\n\nThe term ei⁢θsuperscript𝑒𝑖𝜃e^{i\\theta}italic_e start_POSTSUPERSCRIPT italic_i italic_θ end_POSTSUPERSCRIPT is a part of the well-known Euler’s formula, ei⁢θ=cos⁡(θ)+i⁢sin⁡(θ)superscript𝑒𝑖𝜃𝜃𝑖𝜃e^{i\\theta}=\\cos(\\theta)+i\\sin(\\theta)italic_e start_POSTSUPERSCRIPT italic_i italic_θ end_POSTSUPERSCRIPT = roman_cos ( start_ARG italic_θ end_ARG ) + italic_i roman_sin ( start_ARG italic_θ end_ARG ) (a complex number x+y⁢i𝑥𝑦𝑖x+yiitalic_x + italic_y italic_i that has magnitude 1111 can be stated via the aforementioned formula)–with the numbers sitting on the unit circle in a complex plane, closing an angle θ𝜃\\thetaitalic_θ with the axis of the circle. [247]\n\nI Identity gate is a single qubit gate. [248] This gate does not modify the quantum state in any way–it is typically used in a quantum circuit when we want to show what is happening to a qubit at a certain step or when we want to cause a delay (which the researchers sometimes want to do in order to \"calculate measurements of the decoherence of a qubit\"). [248] The transformation matrix used in order to calculate an output for the gate and its input is the identity matrix [248],\n\nI=[1001]𝐼matrix1001I=\\begin{bmatrix}1&0\\\\ 0&1\\end{bmatrix}italic_I = [ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW end_ARG ] (4)\n\nCNOT Controlled Not gate is a two qubit gate. [145] This gate is very similar to the Not gate, the difference being that the target qubit is flipped only if the first qubit is in an excited state, that is, there is a mapping, |00⟩→|00⟩→ket00ket00\\ket{00}\\rightarrow\\ket{00}| start_ARG 00 end_ARG ⟩ → | start_ARG 00 end_ARG ⟩ and |01⟩→|01⟩→ket01ket01\\ket{01}\\rightarrow\\ket{01}| start_ARG 01 end_ARG ⟩ → | start_ARG 01 end_ARG ⟩ and |10⟩→|11⟩→ket10ket11\\ket{10}\\rightarrow\\ket{11}| start_ARG 10 end_ARG ⟩ → | start_ARG 11 end_ARG ⟩ and |11⟩→|10⟩→ket11ket10\\ket{11}\\rightarrow\\ket{10}| start_ARG 11 end_ARG ⟩ → | start_ARG 10 end_ARG ⟩. [215] The transformation matrix used in order to calculate an output for the gate and its input is [215],\n\nC⁢N⁢O⁢T=[1000010000010010]𝐶𝑁𝑂𝑇matrix1000010000010010CNOT=\\begin{bmatrix}1&0&0&0\\\\ 0&1&0&0\\\\ 0&0&0&1\\\\ 0&0&1&0\\\\ \\end{bmatrix}italic_C italic_N italic_O italic_T = [ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW end_ARG ] (5)\n\nS Swap gate is a two-qubit gate. As the name suggests, this gate makes an operation of swapping the values of two qubits; the order of the qubits is not important for this gate. [145] There is also a version of the Swap gate called the Fredkin gate (a three-qubit gate [145]), which makes an operation of a controlled swap. [215] The transformation matrix used in order to calculate an output for the Swap gate and its input is [145],\n\nS=[1000001001000001]𝑆matrix1000001001000001S=\\begin{bmatrix}1&0&0&0\\\\ 0&0&1&0\\\\ 0&1&0&0\\\\ 0&0&0&1\\\\ \\end{bmatrix}italic_S = [ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW end_ARG ] (6)\n\nCCNOT Controlled Controlled Not gate is a three-qubit gate. Similarly to the two-qubit Controlled Not gate, this gate takes two controlled qubits, and depending on the values of these, the value of a third qubit is flipped–that is, iff the first two qubits have a value of 1, then the value of a third qubit is flipped. [215] This gate is also known by the name Toffoli gate. [215] The transformation matrix used in order to calculate an output for the gate and its input is [248],\n\nC⁢C⁢N⁢O⁢T=[1000000001000000001000000001000000001000000001000000000100000010]𝐶𝐶𝑁𝑂𝑇matrix1000000001000000001000000001000000001000000001000000000100000010CCNOT=\\begin{bmatrix}1&0&0&0&0&0&0&0\\\\ 0&1&0&0&0&0&0&0\\\\ 0&0&1&0&0&0&0&0\\\\ 0&0&0&1&0&0&0&0\\\\ 0&0&0&0&1&0&0&0\\\\ 0&0&0&0&0&1&0&0\\\\ 0&0&0&0&0&0&0&1\\\\ 0&0&0&0&0&0&1&0\\\\ \\end{bmatrix}italic_C italic_C italic_N italic_O italic_T = [ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW end_ARG ] (7)\n\nWhile not all of these will be used in our own calculations, they represent some of the elementary quantum gates and foundational quantum operations and are therefore mentioned as part of one’s necessary quantum arsenal. For a number of other quantum gates, both frequently and infrequently in use, one can consult [53]. It is useful to have quantum transformations represented graphically , therefore, a single-bit operations are typically graphically represented by labeled boxes, while multiple-qubit operations are typically represented by circles, marks, and lines–as other authors have dealt with this satisfactorily, we will not repeat it here. [215, 53]\n\nIn order to know the output of a quantum algorithm, we need to be able to calculate that result, just like with a classical algorithm. There is, however, a twist in a quantum situation. Since we are dealing with particle states and quantum operations represented by matrices, we transform input into output by using vector notation for probability amplitudes and then calculate the tensor product for the expression, after which we perform matrix multiplication, which in turn transforms amplitudes, which in turn changes probability density and the end result. Let us therefore perform a few interesting calculations.\n\nIf we had a qubit that we wanted to place into a superposition of states, we would use the Hadamard gate, abbreviated as H. By following the aforementioned procedure, a qubit needs to be had. Let us therefore define the following qubit, |ψ0⟩=1⁢|0⟩+0⁢|1⟩ketsubscript𝜓01ket00ket1\\ket{\\psi_{0}}=1\\ket{0}+0\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT end_ARG ⟩ = 1 | start_ARG 0 end_ARG ⟩ + 0 | start_ARG 1 end_ARG ⟩. On this qubit, one now needs to apply the H gate, an operation needs to be performed on the operand, so as to achieve the desired result, namely, superposition. By placing the qubit amplitudes into a column vector and using the H gate matrix, we will have the following.\n\n12⁢[111−1]⁢[10]=12+1212matrix1111matrix101212\\dfrac{1}{\\sqrt{2}}\\begin{bmatrix}1&1\\\\ 1&-1\\end{bmatrix}\\begin{bmatrix}1\\\\ 0\\end{bmatrix}=\\dfrac{1}{\\sqrt{2}}+\\dfrac{1}{\\sqrt{2}}divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG [ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL 1 end_CELL start_CELL - 1 end_CELL end_ROW end_ARG ] [ start_ARG start_ROW start_CELL 1 end_CELL end_ROW start_ROW start_CELL 0 end_CELL end_ROW end_ARG ] = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG + divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG (8)\n\nSuch a result has given us a qubit in a superposition; thus, by performing the above multiplication, we have |ψ1⟩=12⁢|0⟩+12⁢|1⟩ketsubscript𝜓112ket012ket1\\ket{\\psi_{1}}=\\frac{1}{\\sqrt{2}}\\ket{0}+\\frac{1}{\\sqrt{2}}\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_ARG ⟩ = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 0 end_ARG ⟩ + divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 1 end_ARG ⟩. Perfect, we have a qubit in a superposition with both states having the same amplitude, and by squaring the state values, we see that both states have a 50%percent5050\\%50 % chance of being observed after superposition collapse. By applying the H gate again, what one can freely try, the original state would again be a reality. It is also good to note here that a qubit is always in a superposition, although for the reason that one of the amplitudes is 0, the original state is often not called such.\n\nWith the Hadamard-gained superposition state, we can proceed to another operation. Let us next perform the CNOT operation. We know what the CNOT gate does, and we also know that such a gate is a two-qubit gate. With that in mind, we will define one more qubit, |ψ2⟩=1⁢|0⟩+0⁢|1⟩ketsubscript𝜓21ket00ket1\\ket{\\psi_{2}}=1\\ket{0}+0\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_ARG ⟩ = 1 | start_ARG 0 end_ARG ⟩ + 0 | start_ARG 1 end_ARG ⟩. By placing the qubit amplitudes into a column vector , and using the CNOT gate matrix, we will have the following.\n\n[1000010000010010]⁢[120120]=12+0+0+12matrix1000010000010010matrix120120120012\\begin{bmatrix}1&0&0&0\\\\ 0&1&0&0\\\\ 0&0&0&1\\\\ 0&0&1&0\\\\ \\end{bmatrix}\\begin{bmatrix}\\dfrac{1}{\\sqrt{2}}\\\\ 0\\\\ \\dfrac{1}{\\sqrt{2}}\\\\ 0\\end{bmatrix}=\\dfrac{1}{\\sqrt{2}}+0+0+\\dfrac{1}{\\sqrt{2}}[ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW end_ARG ] [ start_ARG start_ROW start_CELL divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG end_CELL end_ROW start_ROW start_CELL 0 end_CELL end_ROW start_ROW start_CELL divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG end_CELL end_ROW start_ROW start_CELL 0 end_CELL end_ROW end_ARG ] = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG + 0 + 0 + divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG (9)\n\nTherefore, the final state of the operation performed is, |ψ3⟩=12⁢|00⟩+0⁢|01⟩+0⁢|10⟩+12⁢|11⟩=12⁢|00⟩+12⁢|11⟩ketsubscript𝜓312ket000ket010ket1012ket1112ket0012ket11\\ket{\\psi_{3}}=\\frac{1}{\\sqrt{2}}\\ket{00}+0\\ket{01}+0\\ket{10}+\\frac{1}{\\sqrt{2% }}\\ket{11}=\\frac{1}{\\sqrt{2}}\\ket{00}+\\frac{1}{\\sqrt{2}}\\ket{11}| start_ARG italic_ψ start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_ARG ⟩ = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 00 end_ARG ⟩ + 0 | start_ARG 01 end_ARG ⟩ + 0 | start_ARG 10 end_ARG ⟩ + divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 11 end_ARG ⟩ = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 00 end_ARG ⟩ + divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 11 end_ARG ⟩. The situation we have here is different than the usual CNOT gate example given above, yet if we think about what has actually happened, this is exactly the result one would expect. We have stated that the CNOT gate will flip the target qubit only if the first qubit is raised, which is 1. Here we had a qubit that served as a control in a superposition, with equal amplitudes, while the target qubit was in a state of 1⁢|0⟩1ket01\\ket{0}1 | start_ARG 0 end_ARG ⟩. Therefore, as the control is in a superposition, if the control is 0, then the second qubit would be the same, while if the control were 1, the target would be raised to 1, which means that the resulting states need to be |00⟩+|11⟩ket00ket11\\ket{00}+\\ket{11}| start_ARG 00 end_ARG ⟩ + | start_ARG 11 end_ARG ⟩, precisely what we have obtained by performing calculation. And as the amplitudes are 1212\\frac{1}{\\sqrt{2}}divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG, this has \"spilled\" over to the transformed state |ψ3⟩ketsubscript𝜓3\\ket{\\psi_{3}}| start_ARG italic_ψ start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_ARG ⟩. Two states of the |ψ3⟩ketsubscript𝜓3\\ket{\\psi_{3}}| start_ARG italic_ψ start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_ARG ⟩ whose amplitudes are 0 do not represent a logical outcome, as the tensor product pairs are not in line with the CNOT gate operation.\n\nBy observing what has happened with the CNOT gate calculation, one might wonder what else might be in store with various gates and qubit states. We will therefore perform one more operation, and that operation will be Swap, denoted with the S. Swap gate is a two-qubit gate that swaps qubit states. This time, let us take the qubit with the state |ψ1⟩=12⁢|0⟩+12⁢|1⟩ketsubscript𝜓112ket012ket1\\ket{\\psi_{1}}=\\frac{1}{\\sqrt{2}}\\ket{0}+\\frac{1}{\\sqrt{2}}\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_ARG ⟩ = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 0 end_ARG ⟩ + divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 1 end_ARG ⟩ and the qubit with the same state denoted |ψ4⟩ketsubscript𝜓4\\ket{\\psi_{4}}| start_ARG italic_ψ start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT end_ARG ⟩. Yet again, by placing the qubit amplitudes into a column vector and using the S gate matrix, we will have the following.\n\n[1000001001000001]⁢[12121212]=12+12+12+12matrix1000001001000001matrix1212121212121212\\begin{bmatrix}1&0&0&0\\\\ 0&0&1&0\\\\ 0&1&0&0\\\\ 0&0&0&1\\\\ \\end{bmatrix}\\begin{bmatrix}\\dfrac{1}{2}\\\\[6.99997pt] \\dfrac{1}{2}\\\\[6.99997pt] \\dfrac{1}{2}\\\\[6.99997pt] \\dfrac{1}{2}\\end{bmatrix}=\\dfrac{1}{2}+\\dfrac{1}{2}+\\dfrac{1}{2}+\\dfrac{1}{2}[ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW end_ARG ] [ start_ARG start_ROW start_CELL divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_CELL end_ROW start_ROW start_CELL divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_CELL end_ROW start_ROW start_CELL divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_CELL end_ROW start_ROW start_CELL divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_CELL end_ROW end_ARG ] = divide start_ARG 1 end_ARG start_ARG 2 end_ARG + divide start_ARG 1 end_ARG start_ARG 2 end_ARG + divide start_ARG 1 end_ARG start_ARG 2 end_ARG + divide start_ARG 1 end_ARG start_ARG 2 end_ARG (10)\n\nThe final state of the operation performed is, |ψ5⟩=12⁢|00⟩+12⁢|01⟩+12⁢|10⟩+12⁢|11⟩ketsubscript𝜓512ket0012ket0112ket1012ket11\\ket{\\psi_{5}}=\\frac{1}{2}\\ket{00}+\\frac{1}{2}\\ket{01}+\\frac{1}{2}\\ket{10}+% \\frac{1}{2}\\ket{11}| start_ARG italic_ψ start_POSTSUBSCRIPT 5 end_POSTSUBSCRIPT end_ARG ⟩ = divide start_ARG 1 end_ARG start_ARG 2 end_ARG | start_ARG 00 end_ARG ⟩ + divide start_ARG 1 end_ARG start_ARG 2 end_ARG | start_ARG 01 end_ARG ⟩ + divide start_ARG 1 end_ARG start_ARG 2 end_ARG | start_ARG 10 end_ARG ⟩ + divide start_ARG 1 end_ARG start_ARG 2 end_ARG | start_ARG 11 end_ARG ⟩. This example of the S gate is perhaps not as intuitive as the one where we have qubits in extreme states, that is, in |0⟩ket0\\ket{0}| start_ARG 0 end_ARG ⟩ and in |1⟩ket1\\ket{1}| start_ARG 1 end_ARG ⟩–with a probability of 1. However, we observe that amplitudes are present for every individual state for both qubits, which means that every tensor product pair needs to be a candidate for swapping, and as it can be seen from the result, they are all there, on the other side, as an output. By taking into account amplitude values and the equality thereof, the probability of observing a particular swapped state as a result also needs to be equal, which it is. If we take, for example, the amplitude state |01⟩ket01\\ket{01}| start_ARG 01 end_ARG ⟩ with the amplitude of 1212\\frac{1}{2}divide start_ARG 1 end_ARG start_ARG 2 end_ARG, by squaring the amplitude and thus obtaining the probability of observing that characteristic, we have 1414\\frac{1}{4}divide start_ARG 1 end_ARG start_ARG 4 end_ARG–and that is exactly what we expect as per our own reasoning, as input and output are linked.\n\nIn previous examples, we were performing calculations in a single sequence, but it is also possible to perform them in parallel and then, at some point, \"merge\" results and continue, for example, in a single sequence. How an algorithm will look depends on the problem and the designer of the algorithm. By constructing a quantum circuit, one can manipulate events and, in turn, the probability of amplitude states, transforming input into output and a problem into a solution. Therefore, with that in mind, we will in the continuation show the often-used algorithm design pattern useful to solve various quantum conundrums, namely the Bernstein-Vazirani design pattern.\n\n5.1 Bernstein–Vazirani Algorithm Design Pattern\n\nOne might think that quantum computers have an upper hand over classical computers in terms of computability; however, this is not the case. [257] Every problem that a quantum machine can solve can also be solved on a classical computer, thus not making a quantum machine superior in that respect; as a consequence, problems that are undecidable in a classical case, which are the hardest problems in existence [159], are also undecidable for quantum computers. [257] What makes quantum computers of interest are superposition, quantum parallelism, and entanglement, as these make quantum machines perform faster. [159, 257, 4]\n\n\"The heart of any quantum algorithm is the way in which it manipulates quantum parallelism so that desired results will be measured with high probability.\" [215] What brings us to the Bernstein-Vazirani algorithm, which uses superposition, quantum parallelism, and an effect called phase-kickback, so as to achieve its result. [23] These manipulations have no analog in the classical computer world; therefore, a quantum computer is necessary to bring the aforementioned algorithm into reality. [215]\n\nThere is a problem of determining the value of each character in a string. [158] For example, one might have the following string, 1100110011001100. The question then is: what algorithm could we devise in order to determine in which place the string has a raised bit? As the reader might already guess, we would need to perform a logical conjunction for every bit, as presented in the following equation. [23, 158]\n\n1100&101100&101100&111100&11matrixmissing-subexpression1100missing-subexpressionmissing-subexpressionmissing-subexpression1missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression0matrixmissing-subexpression1100missing-subexpressionmissing-subexpression1missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression0missing-subexpressionmatrixmissing-subexpression1100missing-subexpression1missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression1missing-subexpressionmissing-subexpressionmatrixmissing-subexpression11001missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression1missing-subexpressionmissing-subexpressionmissing-subexpression\\begin{matrix}&1&1&0&0\\\\ \\&&&&&1\\\\ \\hline\\cr&&&&0\\end{matrix}{\\mkern 30.0mu}\\begin{matrix}&1&1&0&0\\\\ \\&&&&1&\\\\ \\hline\\cr&&&0&\\end{matrix}{\\mkern 30.0mu}\\begin{matrix}&1&1&0&0\\\\ \\&&&1&&\\\\ \\hline\\cr&&1&&\\end{matrix}{\\mkern 30.0mu}\\begin{matrix}&1&1&0&0\\\\ \\&&1&&&\\\\ \\hline\\cr&1&&&\\end{matrix}start_ARG start_ROW start_CELL end_CELL start_CELL 1 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL & end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL end_CELL end_ROW start_ROW start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL 0 end_CELL end_ROW end_ARG start_ARG start_ROW start_CELL end_CELL start_CELL 1 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL & end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL 1 end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL end_CELL end_ROW start_ROW start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL 0 end_CELL start_CELL end_CELL end_ROW end_ARG start_ARG start_ROW start_CELL end_CELL start_CELL 1 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL & end_CELL start_CELL end_CELL start_CELL 1 end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL end_CELL end_ROW start_ROW start_CELL end_CELL start_CELL end_CELL start_CELL 1 end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW end_ARG start_ARG start_ROW start_CELL end_CELL start_CELL 1 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL & end_CELL start_CELL 1 end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL end_CELL end_ROW start_ROW start_CELL end_CELL start_CELL 1 end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW end_ARG (11)\n\nAnd now, by reading from the back, we have the result, 1100110011001100, the original bit string is decoded. It is clearly seen from the example that for a n𝑛nitalic_n-bit string, we would need n𝑛nitalic_n operations to find the source bit string–that is, with the linear increase of the input, the complexity of the algorithm increases linearly. This is not an inefficient algorithm; however, for a bit string of length 109superscript10910^{9}10 start_POSTSUPERSCRIPT 9 end_POSTSUPERSCRIPT the number of steps needed to be performed is substantial, and this is where a quantum computer can excel. By employing characteristics that a quantum machine would have, the aforementioned algorithm could be adapted and the entire calculation done in only one step, and thus regardless of the input string, if the quantum machine can match the problem, the calculation would be completed in one step only–this is outstanding, and the procedure that accomplishes the aforementioned is called the Bernstein-Vazirani algorithm; for a visual representation, one can consult Figure 12.\n\nBefore we perform some calculations, let us expound on a fundamental idea behind the Bernstein-Vazirani algorithm. Since our string is four bits long, we also need four qubits for the quantum algorithm as well. The quantum algorithm, however, needs one additional qubit through which the essence of the algorithm will be delivered. All the qubits are at the beginning in the ground state of |0⟩ket0\\ket{0}| start_ARG 0 end_ARG ⟩. These qubits are then placed in a superposition of values, while the last qubit is first placed in a |1⟩ket1\\ket{1}| start_ARG 1 end_ARG ⟩ and then into a superposition, which means that the last qubit has a phase added to its superposition, and this is crucial.\n\nIn the next series of operations, there are CNot gates added to every qubit on which we need to decode 1, an excited state, with the last qubit, a qubit with a phase in its superposition, being a target of the CNot. This part of the algorithm is the part where the flash happens, as the phase from the target qubit transfers onto the control qubits, a target has had an influence on the control; this unexpected event is known under the name phase-kickback [189] and is a crucial part of the algorithm. When we, after this step, perform an additional step with the Hadamard gate and return qubits out of superposition, the phase-kickback will have, as a consequence, a qubit in the state |1⟩ket1\\ket{1}| start_ARG 1 end_ARG ⟩ where before it was |0⟩ket0\\ket{0}| start_ARG 0 end_ARG ⟩. By making measurements on qubits, as a last step of the algorithm, we will read the final state and receive the desired result of the decoded string. This read data is then stored on a classical storage. And so, by using a phase-kickback effect, we were able to detect a desirable characteristic and make a transformation by which the end result was obtained. [189, 23]\n\nBy performing actual calculations, it can be more clearly seen why this has happened and what the algorithm’s inner workings are. At the very start of the algorithm, we need to place qubits into superposition, and as we have already shown this in Equation 8, and as it is quite clear what will happen by applying the Not operation from Equation 1, these steps will be skipped. Suffice to say, Hadamard gate will produce, |ψ1,2,3,4⟩=12⁢|0⟩+12⁢|1⟩ketsubscript𝜓123412ket012ket1\\ket{\\psi_{1,2,3,4}}=\\frac{1}{\\sqrt{2}}\\ket{0}+\\frac{1}{\\sqrt{2}}\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 1 , 2 , 3 , 4 end_POSTSUBSCRIPT end_ARG ⟩ = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 0 end_ARG ⟩ + divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 1 end_ARG ⟩, the X gate will produce, |ψ5⟩=0⁢|0⟩+1⁢|1⟩ketsubscript𝜓50ket01ket1\\ket{\\psi_{5}}=0\\ket{0}+1\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 5 end_POSTSUBSCRIPT end_ARG ⟩ = 0 | start_ARG 0 end_ARG ⟩ + 1 | start_ARG 1 end_ARG ⟩, and the Hadamard applied after the X gate will produce, |ψ5⟩=12⁢|0⟩−12⁢|1⟩ketsubscript𝜓512ket012ket1\\ket{\\psi_{5}}=\\frac{1}{\\sqrt{2}}\\ket{0}-\\frac{1}{\\sqrt{2}}\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 5 end_POSTSUBSCRIPT end_ARG ⟩ = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 0 end_ARG ⟩ - divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 1 end_ARG ⟩–with this, the first series of operations is finished, and now we are onto phase-kickback.\n\nIn the second series of steps, the CNot gate is applied to the qubits where we need to decode 1, and so we have |ψ3,4⟩=12⁢|0⟩+12⁢|1⟩ketsubscript𝜓3412ket012ket1\\ket{\\psi_{3,4}}=\\frac{1}{\\sqrt{2}}\\ket{0}+\\frac{1}{\\sqrt{2}}\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 3 , 4 end_POSTSUBSCRIPT end_ARG ⟩ = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 0 end_ARG ⟩ + divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 1 end_ARG ⟩ as the control for their respective CNot gate, while we have |ψ5⟩=12⁢|0⟩−12⁢|1⟩ketsubscript𝜓512ket012ket1\\ket{\\psi_{5}}=\\frac{1}{\\sqrt{2}}\\ket{0}-\\frac{1}{\\sqrt{2}}\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 5 end_POSTSUBSCRIPT end_ARG ⟩ = divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 0 end_ARG ⟩ - divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG | start_ARG 1 end_ARG ⟩ as the target for both instances. By performing the tensor product |ψ3⟩⊗|ψ5⟩tensor-productketsubscript𝜓3ketsubscript𝜓5\\ket{\\psi_{3}}\\otimes\\ket{\\psi_{5}}| start_ARG italic_ψ start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_ARG ⟩ ⊗ | start_ARG italic_ψ start_POSTSUBSCRIPT 5 end_POSTSUBSCRIPT end_ARG ⟩ we have the following.\n\n[1000010000010010]⁢[12−1212−12]=12⁢|00⟩−12⁢|01⟩−12⁢|10⟩+12⁢|11⟩matrix1000010000010010matrix1212121212ket0012ket0112ket1012ket11\\begin{bmatrix}1&0&0&0\\\\ 0&1&0&0\\\\ 0&0&0&1\\\\ 0&0&1&0\\\\ \\end{bmatrix}\\begin{bmatrix}[r]\\dfrac{1}{2}\\\\[6.99997pt] -\\dfrac{1}{2}\\\\[6.99997pt] \\dfrac{1}{2}\\\\[6.99997pt] -\\dfrac{1}{2}\\end{bmatrix}=\\dfrac{1}{2}\\ket{00}-\\dfrac{1}{2}\\ket{01}-\\dfrac{1}% {2}\\ket{10}+\\dfrac{1}{2}\\ket{11}[ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW end_ARG ] [ start_ARG start_ROW start_CELL divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_CELL end_ROW start_ROW start_CELL - divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_CELL end_ROW start_ROW start_CELL divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_CELL end_ROW start_ROW start_CELL - divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_CELL end_ROW end_ARG ] = divide start_ARG 1 end_ARG start_ARG 2 end_ARG | start_ARG 00 end_ARG ⟩ - divide start_ARG 1 end_ARG start_ARG 2 end_ARG | start_ARG 01 end_ARG ⟩ - divide start_ARG 1 end_ARG start_ARG 2 end_ARG | start_ARG 10 end_ARG ⟩ + divide start_ARG 1 end_ARG start_ARG 2 end_ARG | start_ARG 11 end_ARG ⟩ (12)\n\nBy applying the CNot gate, probabilities have not changed, and if we were to measure the states now, at this moment, nothing extraordinary would happen. But, if we observe the mixed state more closely, a change of phase has happened, and this is exactly what we wanted; the target has influenced the control, and thus we have, |ψ3⟩=+|0⟩−|1⟩ketsubscript𝜓3ket0ket1\\ket{\\psi_{3}}=+\\ket{0}-\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_ARG ⟩ = + | start_ARG 0 end_ARG ⟩ - | start_ARG 1 end_ARG ⟩. What brings us to the last step, just before we are ready to measure the result. If we apply the H gate one more time, we will reverse the superposition, yet as we have changed the phase of certain qubits, these will no longer collapse to their original state but to the opposite one. Let us collapse |ψ3⟩ketsubscript𝜓3\\ket{\\psi_{3}}| start_ARG italic_ψ start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_ARG ⟩.\n\n12⁢[111−1]⁢[12−12]=0+112matrix1111matrix121201\\dfrac{1}{\\sqrt{2}}\\begin{bmatrix}1&1\\\\ 1&-1\\end{bmatrix}\\begin{bmatrix}[r]\\dfrac{1}{\\sqrt{2}}\\\\ -\\dfrac{1}{\\sqrt{2}}\\end{bmatrix}=0+1divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG [ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL 1 end_CELL start_CELL - 1 end_CELL end_ROW end_ARG ] [ start_ARG start_ROW start_CELL divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG end_CELL end_ROW start_ROW start_CELL - divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG end_CELL end_ROW end_ARG ] = 0 + 1 (13)\n\nWhich makes the finals state, |ψ3⟩=0⁢|0⟩+1⁢|1⟩ketsubscript𝜓30ket01ket1\\ket{\\psi_{3}}=0\\ket{0}+1\\ket{1}| start_ARG italic_ψ start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_ARG ⟩ = 0 | start_ARG 0 end_ARG ⟩ + 1 | start_ARG 1 end_ARG ⟩, a 100%percent100100\\%100 % chance of observing 1–by which the desired result was obtained, the binary string was decoded, and the information now only needs to be recorded, an operation conducted via a classical storage device. The string 1100110011001100 was the one to find, and while the string 1100110011001100 was the one found, the algorithm works well.\n\nPhase-kickback is a mechanism that is often found in quantum algorithms, like, for example, Grover’s [87, 93], and in Deutsch-Josza [61, 189], and it is therefore important to conquer this design pattern. The basic idea behind such algorithms is to develop a quantum \"oracle\" that will only apply the negative phase to a state one is looking for, which is by no means an easy task to do, and when that is achieved, we can perform, as necessary, amplitude amplification, thus diminishing undesirable amplitudes and increasing the desirable ones, which is the way by which a quantum computer increases the probability of success so as to ensure a sought-after result is measured with high occurrence probability. [87, 93, 61, 189, 232]\n\n6 Questions that Puzzle the Mind\n\nAmong many intriguing problems in quantum computing that are in need of solving and that are also of interest, there are some that are of special stake for us here. In spite of all the accomplishments, the more reliable and broader reality of quantum computers is still a dream. The main issues standing in the way of quantum computer construction are the following:\n\nI\n\n\"The possibility in principle to construct a scalable quantum computer.\" [222]\n\nII\n\n\"Instability (decoherence) because of the influence of external environment.\" [222]\n\nIII\n\n\"A physical implementation of a scalable quantum computer with a sufficient (for practical problems) number of jointly operating qubits .\" [222]\n\nIV\n\n\"The uncertainty of the degree of dependence of errors since a very fast accumulation of errors with increasing the number of qubits will give no way to obtain the sought-for result when executing computations with an acceptable number of repetitions.\" [222]\n\nV\n\n\"The construction of new mathematical algorithms that will allow to considerably accelerate computations and the search for solutions for a wide class of problems.\" [222]\n\nAnother area of research that is quite significant is finding the position of quantum computation with regard to classical computation in terms of computational cost and complexity classes, as well as exploring the limitations of models of computation. [207] As such, there exists a complexity class BQP (bounded-error quantum polynomial time) that consists of decision problems that can be solved by a quantum machine in polynomial time, with the probability of a correct answer being ≥23absent23\\geq\\frac{2}{3}≥ divide start_ARG 2 end_ARG start_ARG 3 end_ARG. [30, 277] This complexity class is a quantum analogue for the classical BPP (bounded-error probabilistic polynomial time) that \"consists of problems for which there exists a polynomial-time Atlantic City algorithm with a two-sided error.\" [124] These classes are related in the following way, B⁢P⁢P⊆B⁢Q⁢P𝐵𝑃𝑃𝐵𝑄𝑃BPP\\subseteq BQPitalic_B italic_P italic_P ⊆ italic_B italic_Q italic_P, with both classes belonging to PSPACE and needing a polynomial amount of space. [124] The question of BQP and its relation to NP is a matter that is more difficult. There are indications that perhaps NP is contained in BQP, as there are results for the opposite being true–this then still represents a question that is an issue in science and is considered unresolved. [277]\n\nQuantum computation is fascinating from yet another perspective, which is the very basis of it, that is because of quantum mechanics. Quantum mechanics is the fundamental theory in physics describing nature at the smallest of scale, at the atomic and subatomic level [71], yet it seems that even quantum mechanics does not give all the answers, and not only for the reason of Gödel’s incompleteness theorems [242]. There are certain aspects that escape us, at least for the time being, with entanglement and non-locality representing parts of the picture. [194] The issue is, however, broader, as the theory of quantum mechanics fails to address the question of, \"how even a single particle, by being in a given quantum state, causes the frequency distribution of measurement values specified by the state.\" [194] And so, the never-ending pursuit in science, for new knowledge and discoveries, continues.\n\n7 Moving Forward\n\nIt is tempting to think that one should use a quantum computer for every problem and for every task; quantum computers, however, are not a key that fits into every lock. There are problems that naturally fit quantum computing and those that do not. The most obvious application of a quantum computer is naturally quantum simulation [78]. By using a quantum computer, one can cope well with the complexity that overwhelms a classical machine. Examples of such modeling include superconductivity [107], chemical processes [13], photosynthesis [262], physics processes [78], cosmology [137], etc. Other, more classical examples, so to speak, are cryptography [195], optimization [134], search [276], and also machine learning and artificial intelligence [46, 65].\n\nThere are two main types of quantum computer implementation: universal [126], and non-universal [222]. \"The main distinction is that universal quantum computing devices are developed with a view to executing arbitrary allowed operations and solving arbitrary problems; while non-universal computing devices are created to solve some limited class of problems, for example, to optimize definite machine learning algorithms.\" [222]\n\nThese quantum machines can be implemented in various ways, with different physical technologies in mind, like trapped ions, superconductors, or photons. [213] Each individual technology has its ups and downs; in each case, however, quantum computers \"are very hard to build\"; with the thread that permeates all implementations being quantum noise. [213] \"Quantum mechanical states are extremely fragile and require near-absolute isolation from the environment; such conditions are hard to create and typically require temperatures near absolute zero and shielding from radiation.\" [213] Which makes quantum computers expensive to build and difficult to operate. [213] As the size of a quantum computer increases, so do the challenges, which get mounted one upon the other (in terms of the \"number of qubits and the length of time they must be coherent\"). [213]\n\nWhen computation is being done on a quantum machine, that is, on encoded states, \"qubits interact with each other through the gates, and this way errors can propagate through the gates, from one qubit to another.\" [4] In such a manner, the error can quickly be spread to all of the qubits. [4] To solve this problem, computation and error correction can be performed in a distributed way so that \"each qubit can effect only a small number of other qubits.\" [4] An estimation was made that \"more than 99%percent9999\\%99 % of the computation performed by a quantum computer will be for error correction.\" [213, 122] If that is the case, then the calculations that a quantum computer should perform become of secondary nature, thus making the goal of fault-tolerant quantum operations of extremely high importance. [122] By taking that fact into context, quantum practicality will be a difficult goal to achieve, as a commercial quantum computer would need thousands and millions of qubits–efforts are, however, being made in order to solve the issue. [100, 35]\n\nQuantum computers have limitations that go beyond their applicability. In spite of having a general scheme for speeding up computation, it is not expected to solve efficiently and in an exact manner NP-hard optimization problems. [204, 96] In order to make quantum practicality a reality, significant algorithmic improvements are yet to be achieved, while \"due to limitations of input and output bandwidth, quantum computers will be practical for \"big compute\" problems on small data, not big data problems.\" [100] Nevertheless, through continuing progress and innovation, it is expected that a quantum computer able to break RSA-4096, with a probability of 1212\\frac{1}{2}divide start_ARG 1 end_ARG start_ARG 2 end_ARG, will be constructed within the next 10-15 years. [222] With that in mind, it is necessary to already prepare options for replacement so as to ensure post-quantum cryptography viability. [222]\n\nIn the meantime, until commercial quantum computers are a reality, it is possible to create variational quantum algorithms that are trying to merge the classical and quantum approaches to problems. [36] In order to deal with the limitations of quantum computers, such as the limit on the number of qubits and the limit on the circuit depth as per noise, a variational quantum algorithm can be used instead. [36] Such an algorithm uses \"a classical optimizer to train a parameterized quantum circuit.\" [36] In spite of the challenges of these algorithms as well, like trainability, accuracy, and efficiency, they are, for the short term at least, perhaps the best option for making the quantum dream a reality in the here and now. [36]\n\nIn order to start building quantum algorithms now, the following resources represent possible starting positions. In [142] one can read about a quantum singular value transformation (QSVT), which represents a general framework for a number of quantum algorithms, with the possibility of suggesting a unification of quantum algorithms. [142] While the following materials represent practical and hands-on foundational experience in quantum computing: [248], [97] , [143], [108], [106], [147], [84].\n\n8 Few Last Words\n\nIt was the goal of this research to present to the scientific community an in-depth historical and current survey of quantum computing, with a special emphasis on foundational concepts that are difficult to grasp while also gazing into the future–and almost all of it has been done, from history to terminology, from quantum effects to quantum computation, and from the standard model algorithmics to the related literature. It is therefore left for us to touch upon wrapping issues, consider open questions, and draw conclusions.\n\nEven tough, at times it might seem hopeless that a true, large-scale quantum computer will some day be a reality. Science is advancing, and every year there comes some new experimental success, and this ambitious dream of quantum computation might be possible. [4, 35, 260]\n\nQuantum entanglement is of special interest as it allows for the teleportation of quantum states, and as it is currently known, there is no limit on the distance, which could perhaps enable a large-scale network, a marvel that would be quantum internet. [213] Considering that quantum encryption can’t be broken, even in theory, such a communication network is of great interest and would be of incredible value–it would be the absolute security realized. [213, 275]\n\nIf we have learned anything thus far, it is the fact that realizing a quantum computer, even of any kind, is not an easy task; however, Quantum David just might overpower Classical Goliath. [204] By superconducting quantum technology, Google was successful in constructing Sycamore, a programmable quantum machine that has 53 qubits. [204] For the reason of errors, \"the final measurement yields the correct output only once in 500 runs\", yet if one makes repeated calculations \"millions of times in just a few minutes\", a statistically useful result can be obtained. [204] The Sycamore quantum computer is only a single chip, compared to a classical computer that spans tennis courts and uses megawatts of power. [204] And Google is not the only one; IBM, for example, paves the way for an error-resilient quantum computer with thousands of qubits. [35] Indeed, sufficient progress has still not been achieved in realizing a scalable quantum device, it is nevertheless perceived that, with the developments at hand, \"a full-fledged quantum computer will be created in the next 10-15 years.\" [222]\n\nAt the present, quantum mechanics is \"considered the most accurate description of the Universe\", although the theory might need modifications in the future. [4, 194] If and when such a scenario becomes a reality, it is unclear how will that change in the theory of quantum mechanics reflect on quantum computing and quantum information; however, \"the novel physical theory that will emerge may give rise to a new computational paradigm, maybe even more powerful than quantum computing.\" [4] There is a possibility that large-scale commercial quantum devices won’t be feasible, perhaps because of a currently unknown or unsolvable issue–in such a case, a quantum computer can still be useful, e.g. for being \"the simulator Feynman first envisaged\", or for allowing experimental research in physics, and thus, by manipulating a small number of qubits, physicists will be performing tests and validating predictions of quantum theory. [4]\n\nEven though it is not expected that quantum computers, via quantum algorithms, will be able to solve NP-complete problems in a manner that is exact and efficient, there is a possibility of finding efficient algorithms for those problems for which we do not know whether they belong to a class of NP-complete problems and do not have known and efficient classical algorithms, like, for example, the problem of \"checking whether two graphs are isomorphic, known as Graph Isomorphism .\" [4, 204, 96]\n\nIn spite of all of its marvels and all of the scientific contributions, there are many unsolved/partially solved open problems in the realm of quantum computing and quantum mechanics. Here we will list just a small fraction of those, which are likely also the most pressing and fascinating.\n\n∙∙\\bullet∙\n\nReduction of quantum error rates. [91, 123, 42]\n\n∙∙\\bullet∙\n\nSuppression of quantum decoherence. [234, 269]\n\n∙∙\\bullet∙\n\nFinding a type of technology best suited for quantum computation and an implementation thereof. [112, 278, 282, 95, 90, 205]\n\n∙∙\\bullet∙\n\nThe relationship in regard to NP and BQP. [19, 52]\n\n∙∙\\bullet∙\n\nScalability of a quantum computer. [69, 240]\n\n∙∙\\bullet∙\n\nVerification of a quantum system. [80, 229]\n\n∙∙\\bullet∙\n\nSeparation of BQP and PH outside of a black-box model. [210]\n\n∙∙\\bullet∙\n\nEfficient quantum memory. [216, 118]\n\n∙∙\\bullet∙\n\nNetworking protocols and devices for the quantum internet. [31, 11]\n\n∙∙\\bullet∙\n\nBalance of connectivity between qubits. [51, 279]\n\n∙∙\\bullet∙\n\nPerformance of a quantum gate set. [51, 125]\n\n∙∙\\bullet∙\n\nCompilers and software stack performance. [51, 138, 55]\n\n∙∙\\bullet∙\n\nMaterials challenges in quantum computing. "
    }
}