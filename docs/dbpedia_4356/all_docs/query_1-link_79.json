{
    "id": "dbpedia_4356_1",
    "rank": 79,
    "data": {
        "url": "https://github.com/ggerganov/llama.cpp/issues/1571",
        "read_more_link": "",
        "language": "en",
        "title": "OpenCl compiling issue · Issue #1571 · ggerganov/llama.cpp",
        "top_image": "https://opengraph.githubassets.com/3c3c04daa8eea151bde806a529de978b2157e180b497522b957a32c27c6fc015/ggerganov/llama.cpp/issues/1571",
        "meta_img": "https://opengraph.githubassets.com/3c3c04daa8eea151bde806a529de978b2157e180b497522b957a32c27c6fc015/ggerganov/llama.cpp/issues/1571",
        "images": [
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/79321648?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=32&v=4",
            "https://avatars.githubusercontent.com/u/11707594?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=32&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/11707594?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/11707594?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=32&v=4",
            "https://avatars.githubusercontent.com/u/11707594?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/11707594?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=32&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=32&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/16426284?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/16426284?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=80&v=4",
            "https://avatars.githubusercontent.com/u/10137?s=32&v=4",
            "https://avatars.githubusercontent.com/u/59344?s=40&v=4",
            "https://avatars.githubusercontent.com/u/795193?s=52&v=4",
            "https://avatars.githubusercontent.com/u/11707594?s=52&v=4",
            "https://avatars.githubusercontent.com/u/16426284?s=52&v=4",
            "https://avatars.githubusercontent.com/u/79321648?s=52&v=4"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Hi, I'm trying to compile llama.cpp using my opencl drivers. My device is a Samsung s10+ with termux. On downloading and attempting make with LAMA_CLBLAST=1, I receive an error: ggml-opencl.cpp:8:10: fatal error: 'clblast.h' file not fou...",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/ggerganov/llama.cpp/issues/1571",
        "text": "main: build = 0 (unknown) main: seed = 1684965335 llama.cpp: loading model from /data/data/com.termux/files/home/llama.cpp/models/Wizard-Vicuna-7B-Uncensored.ggmlv2.q4_0.bin llama_model_load_internal: format = ggjt v2 (latest) llama_model_load_internal: n_vocab = 32000 llama_model_load_internal: n_ctx = 2048 llama_model_load_internal: n_embd = 4096 llama_model_load_internal: n_mult = 256 llama_model_load_internal: n_head = 32 llama_model_load_internal: n_layer = 32 llama_model_load_internal: n_rot = 128 llama_model_load_internal: ftype = 2 (mostly Q4_0) llama_model_load_internal: n_ff = 11008 llama_model_load_internal: n_parts = 1 llama_model_load_internal: model size = 7B llama_model_load_internal: ggml ctx size = 68.20 KB llama_model_load_internal: mem required = 5809.33 MB (+ 1026.00 MB per state) Initializing CLBlast (First Run)... Attempting to use: Platform=0, Device=0 (If invalid, program will crash) Using Platform: clvk Device: Adreno (TM) 640 source:1:81: error: 8-bit storage is not supported for SSBOs struct block_q4_0 { float d; uchar qs[16]; }; __kernel void dequantize_row_q4_0(__global struct block_q4_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = ((vi & 0xf) - 8)*d; result[index + 1] = ((vi >> 4) - 8)*d; } struct block_q4_1 { float d; float m; uchar qs[16]; }; __kernel void dequantize_row_q4_1(__global struct block_q4_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const float m = blocks[i].m; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = (vi & 0xf) * d + m; result[index + 1] = (vi >> 4) * d + m; } struct block_q5_0 { float d; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_0(__global struct block_q5_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = (((vi & 0xf) | vh0) - 16)*d; result[index + 1] = (((vi >> 4) | vh1) - 16)*d; } struct block_q5_1 { ushort d; ushort m; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_1(__global struct block_q5_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = vload_half(0, (__global half*) &blocks[i].d); const float m = vload_half(0, (__global half*) &blocks[i].m); const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = ((vi & 0xf) | vh0)*d + m; result[index + 1] = ((vi >> 4) | vh1)*d + m; } struct block_q8_0 { float d; char qs[32]; }; __kernel void dequantize_row_q8_0(__global struct block_q8_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); result[i*32 + l] = blocks[i].qs[l] * blocks[i].d; } ^ source:1:477: error: 8-bit storage is not supported for SSBOs struct block_q4_0 { float d; uchar qs[16]; }; __kernel void dequantize_row_q4_0(__global struct block_q4_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = ((vi & 0xf) - 8)*d; result[index + 1] = ((vi >> 4) - 8)*d; } struct block_q4_1 { float d; float m; uchar qs[16]; }; __kernel void dequantize_row_q4_1(__global struct block_q4_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const float m = blocks[i].m; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = (vi & 0xf) * d + m; result[index + 1] = (vi >> 4) * d + m; } struct block_q5_0 { float d; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_0(__global struct block_q5_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = (((vi & 0xf) | vh0) - 16)*d; result[index + 1] = (((vi >> 4) | vh1) - 16)*d; } struct block_q5_1 { ushort d; ushort m; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_1(__global struct block_q5_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = vload_half(0, (__global half*) &blocks[i].d); const float m = vload_half(0, (__global half*) &blocks[i].m); const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = ((vi & 0xf) | vh0)*d + m; result[index + 1] = ((vi >> 4) | vh1)*d + m; } struct block_q8_0 { float d; char qs[32]; }; __kernel void dequantize_row_q8_0(__global struct block_q8_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); result[i*32 + l] = blocks[i].qs[l] * blocks[i].d; } ^ source:1:1185: warning: implicit conversion loses integer precision: 'uint' (aka 'unsigned int') to 'uchar' (aka 'unsigned char') struct block_q4_0 { float d; uchar qs[16]; }; __kernel void dequantize_row_q4_0(__global struct block_q4_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = ((vi & 0xf) - 8)*d; result[index + 1] = ((vi >> 4) - 8)*d; } struct block_q4_1 { float d; float m; uchar qs[16]; }; __kernel void dequantize_row_q4_1(__global struct block_q4_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const float m = blocks[i].m; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = (vi & 0xf) * d + m; result[index + 1] = (vi >> 4) * d + m; } struct block_q5_0 { float d; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_0(__global struct block_q5_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = (((vi & 0xf) | vh0) - 16)*d; result[index + 1] = (((vi >> 4) | vh1) - 16)*d; } struct block_q5_1 { ushort d; ushort m; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_1(__global struct block_q5_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = vload_half(0, (__global half*) &blocks[i].d); const float m = vload_half(0, (__global half*) &blocks[i].m); const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = ((vi & 0xf) | vh0)*d + m; result[index + 1] = ((vi >> 4) | vh1)*d + m; } struct block_q8_0 { float d; char qs[32]; }; __kernel void dequantize_row_q8_0(__global struct block_q8_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); result[i*32 + l] = blocks[i].qs[l] * blocks[i].d; } ~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~ source:1:1256: warning: implicit conversion loses integer precision: 'uint' (aka 'unsigned int') to 'uchar' (aka 'unsigned char') struct block_q4_0 { float d; uchar qs[16]; }; __kernel void dequantize_row_q4_0(__global struct block_q4_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = ((vi & 0xf) - 8)*d; result[index + 1] = ((vi >> 4) - 8)*d; } struct block_q4_1 { float d; float m; uchar qs[16]; }; __kernel void dequantize_row_q4_1(__global struct block_q4_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const float m = blocks[i].m; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = (vi & 0xf) * d + m; result[index + 1] = (vi >> 4) * d + m; } struct block_q5_0 { float d; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_0(__global struct block_q5_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = (((vi & 0xf) | vh0) - 16)*d; result[index + 1] = (((vi >> 4) | vh1) - 16)*d; } struct block_q5_1 { ushort d; ushort m; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_1(__global struct block_q5_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = vload_half(0, (__global half*) &blocks[i].d); const float m = vload_half(0, (__global half*) &blocks[i].m); const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = ((vi & 0xf) | vh0)*d + m; result[index + 1] = ((vi >> 4) | vh1)*d + m; } struct block_q8_0 { float d; char qs[32]; }; __kernel void dequantize_row_q8_0(__global struct block_q8_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); result[i*32 + l] = blocks[i].qs[l] * blocks[i].d; } ~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~ source:1:902: error: 8-bit storage is not supported for SSBOs struct block_q4_0 { float d; uchar qs[16]; }; __kernel void dequantize_row_q4_0(__global struct block_q4_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = ((vi & 0xf) - 8)*d; result[index + 1] = ((vi >> 4) - 8)*d; } struct block_q4_1 { float d; float m; uchar qs[16]; }; __kernel void dequantize_row_q4_1(__global struct block_q4_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const float m = blocks[i].m; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = (vi & 0xf) * d + m; result[index + 1] = (vi >> 4) * d + m; } struct block_q5_0 { float d; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_0(__global struct block_q5_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = (((vi & 0xf) | vh0) - 16)*d; result[index + 1] = (((vi >> 4) | vh1) - 16)*d; } struct block_q5_1 { ushort d; ushort m; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_1(__global struct block_q5_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = vload_half(0, (__global half*) &blocks[i].d); const float m = vload_half(0, (__global half*) &blocks[i].m); const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = ((vi & 0xf) | vh0)*d + m; result[index + 1] = ((vi >> 4) | vh1)*d + m; } struct block_q8_0 { float d; char qs[32]; }; __kernel void dequantize_row_q8_0(__global struct block_q8_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); result[i*32 + l] = blocks[i].qs[l] * blocks[i].d; } ^ source:1:1869: warning: implicit conversion loses integer precision: 'uint' (aka 'unsigned int') to 'uchar' (aka 'unsigned char') struct block_q4_0 { float d; uchar qs[16]; }; __kernel void dequantize_row_q4_0(__global struct block_q4_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = ((vi & 0xf) - 8)*d; result[index + 1] = ((vi >> 4) - 8)*d; } struct block_q4_1 { float d; float m; uchar qs[16]; }; __kernel void dequantize_row_q4_1(__global struct block_q4_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const float m = blocks[i].m; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = (vi & 0xf) * d + m; result[index + 1] = (vi >> 4) * d + m; } struct block_q5_0 { float d; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_0(__global struct block_q5_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = (((vi & 0xf) | vh0) - 16)*d; result[index + 1] = (((vi >> 4) | vh1) - 16)*d; } struct block_q5_1 { ushort d; ushort m; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_1(__global struct block_q5_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = vload_half(0, (__global half*) &blocks[i].d); const float m = vload_half(0, (__global half*) &blocks[i].m); const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = ((vi & 0xf) | vh0)*d + m; result[index + 1] = ((vi >> 4) | vh1)*d + m; } struct block_q8_0 { float d; char qs[32]; }; __kernel void dequantize_row_q8_0(__global struct block_q8_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); result[i*32 + l] = blocks[i].qs[l] * blocks[i].d; } ~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~ source:1:1940: warning: implicit conversion loses integer precision: 'uint' (aka 'unsigned int') to 'uchar' (aka 'unsigned char') struct block_q4_0 { float d; uchar qs[16]; }; __kernel void dequantize_row_q4_0(__global struct block_q4_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = ((vi & 0xf) - 8)*d; result[index + 1] = ((vi >> 4) - 8)*d; } struct block_q4_1 { float d; float m; uchar qs[16]; }; __kernel void dequantize_row_q4_1(__global struct block_q4_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const float m = blocks[i].m; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = (vi & 0xf) * d + m; result[index + 1] = (vi >> 4) * d + m; } struct block_q5_0 { float d; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_0(__global struct block_q5_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = (((vi & 0xf) | vh0) - 16)*d; result[index + 1] = (((vi >> 4) | vh1) - 16)*d; } struct block_q5_1 { ushort d; ushort m; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_1(__global struct block_q5_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = vload_half(0, (__global half*) &blocks[i].d); const float m = vload_half(0, (__global half*) &blocks[i].m); const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = ((vi & 0xf) | vh0)*d + m; result[index + 1] = ((vi >> 4) | vh1)*d + m; } struct block_q8_0 { float d; char qs[32]; }; __kernel void dequantize_row_q8_0(__global struct block_q8_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); result[i*32 + l] = blocks[i].qs[l] * blocks[i].d; } ~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~ source:1:1491: error: 16-bit storage is not supported for SSBOs struct block_q4_0 { float d; uchar qs[16]; }; __kernel void dequantize_row_q4_0(__global struct block_q4_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = ((vi & 0xf) - 8)*d; result[index + 1] = ((vi >> 4) - 8)*d; } struct block_q4_1 { float d; float m; uchar qs[16]; }; __kernel void dequantize_row_q4_1(__global struct block_q4_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const float m = blocks[i].m; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = (vi & 0xf) * d + m; result[index + 1] = (vi >> 4) * d + m; } struct block_q5_0 { float d; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_0(__global struct block_q5_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = (((vi & 0xf) | vh0) - 16)*d; result[index + 1] = (((vi >> 4) | vh1) - 16)*d; } struct block_q5_1 { ushort d; ushort m; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_1(__global struct block_q5_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = vload_half(0, (__global half*) &blocks[i].d); const float m = vload_half(0, (__global half*) &blocks[i].m); const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = ((vi & 0xf) | vh0)*d + m; result[index + 1] = ((vi >> 4) | vh1)*d + m; } struct block_q8_0 { float d; char qs[32]; }; __kernel void dequantize_row_q8_0(__global struct block_q8_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); result[i*32 + l] = blocks[i].qs[l] * blocks[i].d; } ^ source:1:1491: error: 8-bit storage is not supported for SSBOs source:1:2331: warning: no newline at end of file struct block_q4_0 { float d; uchar qs[16]; }; __kernel void dequantize_row_q4_0(__global struct block_q4_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = ((vi & 0xf) - 8)*d; result[index + 1] = ((vi >> 4) - 8)*d; } struct block_q4_1 { float d; float m; uchar qs[16]; }; __kernel void dequantize_row_q4_1(__global struct block_q4_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const float m = blocks[i].m; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = (vi & 0xf) * d + m; result[index + 1] = (vi >> 4) * d + m; } struct block_q5_0 { float d; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_0(__global struct block_q5_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = (((vi & 0xf) | vh0) - 16)*d; result[index + 1] = (((vi >> 4) | vh1) - 16)*d; } struct block_q5_1 { ushort d; ushort m; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_1(__global struct block_q5_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = vload_half(0, (__global half*) &blocks[i].d); const float m = vload_half(0, (__global half*) &blocks[i].m); const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = ((vi & 0xf) | vh0)*d + m; result[index + 1] = ((vi >> 4) | vh1)*d + m; } struct block_q8_0 { float d; char qs[32]; }; __kernel void dequantize_row_q8_0(__global struct block_q8_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); result[i*32 + l] = blocks[i].qs[l] * blocks[i].d; } ^ source:1:2148: error: 8-bit storage is not supported for SSBOs struct block_q4_0 { float d; uchar qs[16]; }; __kernel void dequantize_row_q4_0(__global struct block_q4_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = ((vi & 0xf) - 8)*d; result[index + 1] = ((vi >> 4) - 8)*d; } struct block_q4_1 { float d; float m; uchar qs[16]; }; __kernel void dequantize_row_q4_1(__global struct block_q4_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const float m = blocks[i].m; const uchar vi = blocks[i].qs[l]; const uint index = i*32 + l*2; result[index + 0] = (vi & 0xf) * d + m; result[index + 1] = (vi >> 4) * d + m; } struct block_q5_0 { float d; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_0(__global struct block_q5_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = blocks[i].d; const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = (((vi & 0xf) | vh0) - 16)*d; result[index + 1] = (((vi >> 4) | vh1) - 16)*d; } struct block_q5_1 { ushort d; ushort m; uint qh; uchar qs[16]; }; __kernel void dequantize_row_q5_1(__global struct block_q5_1* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); const float d = vload_half(0, (__global half*) &blocks[i].d); const float m = vload_half(0, (__global half*) &blocks[i].m); const uchar vi = blocks[i].qs[l]; const uint l2 = l * 2; const uchar vh0 = ((blocks[i].qh & (1 << (l2 + 0))) >> (l2 + 0)) << 4; const uchar vh1 = ((blocks[i].qh & (1 << (l2 + 1))) >> (l2 + 1)) << 4; const uint index = i*32 + l2; result[index + 0] = ((vi & 0xf) | vh0)*d + m; result[index + 1] = ((vi >> 4) | vh1)*d + m; } struct block_q8_0 { float d; char qs[32]; }; __kernel void dequantize_row_q8_0(__global struct block_q8_0* blocks, __global float* result) { const uint i = get_global_id(0) / 32; const uint l = get_local_id(0); result[i*32 + l] = blocks[i].qs[l] * blocks[i].d; } ^"
    }
}