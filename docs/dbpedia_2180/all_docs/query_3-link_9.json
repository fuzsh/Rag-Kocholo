{
    "id": "dbpedia_2180_3",
    "rank": 9,
    "data": {
        "url": "https://docs.sqlalchemy.org/20/glossary.html",
        "read_more_link": "",
        "language": "en",
        "title": "Glossary — SQLAlchemy 2.0 Documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.sqlalchemy.org/img/sqla_logo.png",
            "https://www.sqlalchemy.org/img/dbtoolkit6.gif",
            "https://www.sqlalchemy.org/img/python-logo.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "//www.sqlalchemy.org/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "http://docs.sqlalchemy.org/en/latest/glossary.html",
        "text": "1.x style¶\n\n2.0 style¶\n\n1.x-style¶\n\n2.0-style¶\n\nThese terms are new in SQLAlchemy 1.4 and refer to the SQLAlchemy 1.4-> 2.0 transition plan, described at SQLAlchemy 2.0 - Major Migration Guide. The term “1.x style” refers to an API used in the way it’s been documented throughout the 1.x series of SQLAlchemy and earlier (e.g. 1.3, 1.2, etc) and the term “2.0 style” refers to the way an API will look in version 2.0. Version 1.4 implements nearly all of 2.0’s API in so-called “transition mode”, while version 2.0 still maintains the legacy Query object to allow legacy code to remain largely 2.0 compatible.\n\nSee also\n\nSQLAlchemy 2.0 - Major Migration Guide\n\nACID¶\n\nACID model¶\n\nAn acronym for “Atomicity, Consistency, Isolation, Durability”; a set of properties that guarantee that database transactions are processed reliably. (via Wikipedia)\n\nSee also\n\natomicity\n\nconsistency\n\nisolation\n\ndurability\n\nACID Model (via Wikipedia)\n\nassociation relationship¶\n\nA two-tiered relationship which links two tables together using an association table in the middle. The association relationship differs from a many to many relationship in that the many-to-many table is mapped by a full class, rather than invisibly handled by the sqlalchemy.orm.relationship() construct as in the case with many-to-many, so that additional attributes are explicitly available.\n\nFor example, if we wanted to associate employees with projects, also storing the specific role for that employee with the project, the relational schema might look like:\n\nCREATETABLEemployee( idINTEGERPRIMARYKEY, nameVARCHAR(30) ) CREATETABLEproject( idINTEGERPRIMARYKEY, nameVARCHAR(30) ) CREATETABLEemployee_project( employee_idINTEGERPRIMARYKEY, project_idINTEGERPRIMARYKEY, role_nameVARCHAR(30), FOREIGNKEYemployee_idREFERENCESemployee(id), FOREIGNKEYproject_idREFERENCESproject(id) )\n\nA SQLAlchemy declarative mapping for the above might look like:\n\nclass Employee(Base): __tablename__ = \"employee\" id = Column(Integer, primary_key=True) name = Column(String(30)) class Project(Base): __tablename__ = \"project\" id = Column(Integer, primary_key=True) name = Column(String(30)) class EmployeeProject(Base): __tablename__ = \"employee_project\" employee_id = Column(Integer, ForeignKey(\"employee.id\"), primary_key=True) project_id = Column(Integer, ForeignKey(\"project.id\"), primary_key=True) role_name = Column(String(30)) project = relationship(\"Project\", backref=\"project_employees\") employee = relationship(\"Employee\", backref=\"employee_projects\")\n\nEmployees can be added to a project given a role name:\n\nproj = Project(name=\"Client A\") emp1 = Employee(name=\"emp1\") emp2 = Employee(name=\"emp2\") proj.project_employees.extend( [ EmployeeProject(employee=emp1, role_name=\"tech lead\"), EmployeeProject(employee=emp2, role_name=\"account executive\"), ] )\n\nSee also\n\nmany to many\n\natomicity¶\n\nAtomicity is one of the components of the ACID model, and requires that each transaction is “all or nothing”: if one part of the transaction fails, the entire transaction fails, and the database state is left unchanged. An atomic system must guarantee atomicity in each and every situation, including power failures, errors, and crashes. (via Wikipedia)\n\nSee also\n\nACID\n\nAtomicity (via Wikipedia)\n\nattached¶\n\nIndicates an ORM object that is presently associated with a specific Session.\n\nSee also\n\nQuickie Intro to Object States\n\nbackref¶\n\nbidirectional relationship¶\n\nAn extension to the relationship system whereby two distinct relationship() objects can be mutually associated with each other, such that they coordinate in memory as changes occur to either side. The most common way these two relationships are constructed is by using the relationship() function explicitly for one side and specifying the backref keyword to it so that the other relationship() is created automatically. We can illustrate this against the example we’ve used in one to many as follows:\n\nclass Department(Base): __tablename__ = \"department\" id = Column(Integer, primary_key=True) name = Column(String(30)) employees = relationship(\"Employee\", backref=\"department\") class Employee(Base): __tablename__ = \"employee\" id = Column(Integer, primary_key=True) name = Column(String(30)) dep_id = Column(Integer, ForeignKey(\"department.id\"))\n\nA backref can be applied to any relationship, including one to many, many to one, and many to many.\n\nSee also\n\nrelationship\n\none to many\n\nmany to one\n\nmany to many\n\nbound parameter¶\n\nbound parameters¶\n\nbind parameter¶\n\nbind parameters¶\n\nBound parameters are the primary means in which data is passed to the DBAPI database driver. While the operation to be invoked is based on the SQL statement string, the data values themselves are passed separately, where the driver contains logic that will safely process these strings and pass them to the backend database server, which may either involve formatting the parameters into the SQL string itself, or passing them to the database using separate protocols.\n\nThe specific system by which the database driver does this should not matter to the caller; the point is that on the outside, data should always be passed separately and not as part of the SQL string itself. This is integral both to having adequate security against SQL injections as well as allowing the driver to have the best performance.\n\nSee also\n\nPrepared Statement - at Wikipedia\n\nbind parameters - at Use The Index, Luke!\n\nSending Parameters - in the SQLAlchemy Unified Tutorial\n\nA relational algebra term referring to an attribute or set of attributes that form a uniquely identifying key for a row. A row may have more than one candidate key, each of which is suitable for use as the primary key of that row. The primary key of a table is always a candidate key.\n\nSee also\n\nprimary key\n\nCandidate key (via Wikipedia)\n\nhttps://www.databasestar.com/database-keys/\n\ncartesian product¶\n\nGiven two sets A and B, the cartesian product is the set of all ordered pairs (a, b) where a is in A and b is in B.\n\nIn terms of SQL databases, a cartesian product occurs when we select from two or more tables (or other subqueries) without establishing any kind of criteria between the rows of one table to another (directly or indirectly). If we SELECT from table A and table B at the same time, we get every row of A matched to the first row of B, then every row of A matched to the second row of B, and so on until every row from A has been paired with every row of B.\n\nCartesian products cause enormous result sets to be generated and can easily crash a client application if not prevented.\n\nSee also\n\nCartesian Product (via Wikipedia)\n\ncascade¶\n\nA term used in SQLAlchemy to describe how an ORM persistence action that takes place on a particular object would extend into other objects which are directly associated with that object. In SQLAlchemy, these object associations are configured using the relationship() construct. relationship() contains a parameter called relationship.cascade which provides options on how certain persistence operations may cascade.\n\nThe term “cascades” as well as the general architecture of this system in SQLAlchemy was borrowed, for better or worse, from the Hibernate ORM.\n\nSee also\n\nCascades\n\ncheck constraint¶\n\nA check constraint is a condition that defines valid data when adding or updating an entry in a table of a relational database. A check constraint is applied to each row in the table.\n\n(via Wikipedia)\n\nA check constraint can be added to a table in standard SQL using DDL like the following:\n\nALTERTABLEdistributorsADDCONSTRAINTzipchkCHECK(char_length(zipcode)=5);\n\nSee also\n\nCHECK constraint (via Wikipedia)\n\ncolumns clause¶\n\nThe portion of the SELECT statement which enumerates the SQL expressions to be returned in the result set. The expressions follow the SELECT keyword directly and are a comma-separated list of individual expressions.\n\nE.g.:\n\nSELECTuser_account.name,user_account.email FROMuser_accountWHEREuser_account.name='fred'\n\nAbove, the list of columns user_acount.name, user_account.email is the columns clause of the SELECT.\n\ncomposite primary key¶\n\nA primary key that has more than one column. A particular database row is unique based on two or more columns rather than just a single value.\n\nSee also\n\nprimary key\n\nconsistency¶\n\nConsistency is one of the components of the ACID model, and ensures that any transaction will bring the database from one valid state to another. Any data written to the database must be valid according to all defined rules, including but not limited to constraints, cascades, triggers, and any combination thereof. (via Wikipedia)\n\nSee also\n\nACID\n\nConsistency (via Wikipedia)\n\nconstraint¶\n\nconstraints¶\n\nconstrained¶\n\nRules established within a relational database that ensure the validity and consistency of data. Common forms of constraint include primary key constraint, foreign key constraint, and check constraint.\n\ncorrelates¶\n\ncorrelated subquery¶\n\ncorrelated subqueries¶\n\nA subquery is correlated if it depends on data in the enclosing SELECT.\n\nBelow, a subquery selects the aggregate value MIN(a.id) from the email_address table, such that it will be invoked for each value of user_account.id, correlating the value of this column against the email_address.user_account_id column:\n\nSELECTuser_account.name,email_address.email FROMuser_account JOINemail_addressONuser_account.id=email_address.user_account_id WHEREemail_address.id=( SELECTMIN(a.id)FROMemail_addressASa WHEREa.user_account_id=user_account.id )\n\nThe above subquery refers to the user_account table, which is not itself in the FROM clause of this nested query. Instead, the user_account table is received from the enclosing query, where each row selected from user_account results in a distinct execution of the subquery.\n\nA correlated subquery is in most cases present in the WHERE clause or columns clause of the immediately enclosing SELECT statement, as well as in the ORDER BY or HAVING clause.\n\nIn less common cases, a correlated subquery may be present in the FROM clause of an enclosing SELECT; in these cases the correlation is typically due to the enclosing SELECT itself being enclosed in the WHERE, ORDER BY, columns or HAVING clause of another SELECT, such as:\n\nSELECTparent.idFROMparent WHEREEXISTS( SELECT*FROM( SELECTchild.idASid,child.parent_idASparent_id,child.posASpos FROMchild WHEREchild.parent_id=parent.idORDERBYchild.pos LIMIT3) WHEREid=7)\n\nCorrelation from one SELECT directly to one which encloses the correlated query via its FROM clause is not possible, because the correlation can only proceed once the original source rows from the enclosing statement’s FROM clause are available.\n\ncrud¶\n\nCRUD¶\n\nAn acronym meaning “Create, Update, Delete”. The term in SQL refers to the set of operations that create, modify and delete data from the database, also known as DML, and typically refers to the INSERT, UPDATE, and DELETE statements.\n\ncursor¶\n\nA control structure that enables traversal over the records in a database. In the Python DBAPI, the cursor object is in fact the starting point for statement execution as well as the interface used for fetching results.\n\nSee also\n\nCursor Objects (in pep-249)\n\nCursor (via Wikipedia)\n\ncyclomatic complexity¶\n\nA measure of code complexity based on the number of possible paths through a program’s source code.\n\nSee also\n\nCyclomatic Complexity\n\nDBAPI¶\n\npep-249¶\n\nDBAPI is shorthand for the phrase “Python Database API Specification”. This is a widely used specification within Python to define common usage patterns for all database connection packages. The DBAPI is a “low level” API which is typically the lowest level system used in a Python application to talk to a database. SQLAlchemy’s dialect system is constructed around the operation of the DBAPI, providing individual dialect classes which service a specific DBAPI on top of a specific database engine; for example, the create_engine() URL postgresql+psycopg2://@localhost/test refers to the psycopg2 DBAPI/dialect combination, whereas the URL mysql+mysqldb://@localhost/test refers to the MySQL for Python DBAPI/dialect combination.\n\nSee also\n\nPEP 249 - Python Database API Specification v2.0\n\nDDL¶\n\nAn acronym for Data Definition Language. DDL is the subset of SQL that relational databases use to configure tables, constraints, and other permanent objects within a database schema. SQLAlchemy provides a rich API for constructing and emitting DDL expressions.\n\nSee also\n\nDescribing Databases with MetaData\n\nDDL (via Wikipedia)\n\nDML\n\nDQL\n\ndeleted¶\n\nThis describes one of the major object states which an object can have within a Session; a deleted object is an object that was formerly persistent and has had a DELETE statement emitted to the database within a flush to delete its row. The object will move to the detached state once the session’s transaction is committed; alternatively, if the session’s transaction is rolled back, the DELETE is reverted and the object moves back to the persistent state.\n\nSee also\n\nQuickie Intro to Object States\n\ndescriptor¶\n\ndescriptors¶\n\nIn Python, a descriptor is an object attribute with “binding behavior”, one whose attribute access has been overridden by methods in the descriptor protocol. Those methods are __get__(), __set__(), and __delete__(). If any of those methods are defined for an object, it is said to be a descriptor.\n\nIn SQLAlchemy, descriptors are used heavily in order to provide attribute behavior on mapped classes. When a class is mapped as such:\n\nclass MyClass(Base): __tablename__ = \"foo\" id = Column(Integer, primary_key=True) data = Column(String)\n\nThe MyClass class will be mapped when its definition is complete, at which point the id and data attributes, starting out as Column objects, will be replaced by the instrumentation system with instances of InstrumentedAttribute, which are descriptors that provide the above mentioned __get__(), __set__() and __delete__() methods. The InstrumentedAttribute will generate a SQL expression when used at the class level:\n\n>>> print(MyClass.data == 5)\n\ndata=:data_1\n\nand at the instance level, keeps track of changes to values, and also lazy loads unloaded attributes from the database:\n\n>>> m1 = MyClass() >>> m1.id = 5 >>> m1.data = \"some data\" >>> from sqlalchemy import inspect >>> inspect(m1).attrs.data.history.added \"some data\"\n\ndetached¶\n\nThis describes one of the major object states which an object can have within a Session; a detached object is an object that has a database identity (i.e. a primary key) but is not associated with any session. An object that was previously persistent and was removed from its session either because it was expunged, or the owning session was closed, moves into the detached state. The detached state is generally used when objects are being moved between sessions or when being moved to/from an external object cache.\n\nSee also\n\nQuickie Intro to Object States\n\ndialect¶\n\nIn SQLAlchemy, the “dialect” is a Python object that represents information and methods that allow database operations to proceed on a particular kind of database backend and a particular kind of Python driver (or DBAPI) for that database. SQLAlchemy dialects are subclasses of the Dialect class.\n\nSee also\n\nEngine Configuration\n\ndiscriminator¶\n\nA result-set column which is used during polymorphic loading to determine what kind of mapped class should be applied to a particular incoming result row.\n\nSee also\n\nMapping Class Inheritance Hierarchies\n\nDML¶\n\nAn acronym for Data Manipulation Language. DML is the subset of SQL that relational databases use to modify the data in tables. DML typically refers to the three widely familiar statements of INSERT, UPDATE and DELETE, otherwise known as CRUD (acronym for “Create, Read, Update, Delete”).\n\nSee also\n\nDML (via Wikipedia)\n\nDDL\n\nDQL\n\ndomain model¶\n\nA domain model in problem solving and software engineering is a conceptual model of all the topics related to a specific problem. It describes the various entities, their attributes, roles, and relationships, plus the constraints that govern the problem domain.\n\n(via Wikipedia)\n\nSee also\n\nDomain Model (via Wikipedia)\n\nDQL¶\n\nAn acronym for Data Query Language. DQL is the subset of SQL that relational databases use to read the data in tables. DQL almost exclusively refers to the SQL SELECT construct as the top level SQL statement in use.\n\nSee also\n\nDQL (via Wikipedia)\n\nDML\n\nDDL\n\ndurability¶\n\nDurability is a property of the ACID model which means that once a transaction has been committed, it will remain so, even in the event of power loss, crashes, or errors. In a relational database, for instance, once a group of SQL statements execute, the results need to be stored permanently (even if the database crashes immediately thereafter). (via Wikipedia)\n\nSee also\n\nACID\n\nDurability (via Wikipedia)\n\neager load¶\n\neager loads¶\n\neager loaded¶\n\neager loading¶\n\neagerly load¶\n\nIn object relational mapping, an “eager load” refers to an attribute that is populated with its database-side value at the same time as when the object itself is loaded from the database. In SQLAlchemy, the term “eager loading” usually refers to related collections and instances of objects that are linked between mappings using the relationship() construct, but can also refer to additional column attributes being loaded, often from other tables related to a particular table being queried, such as when using inheritance mappings.\n\nEager loading is the opposite of lazy loading.\n\nSee also\n\nRelationship Loading Techniques\n\nexecutemany¶\n\nThis term refers to a part of the PEP 249 DBAPI specification indicating a single SQL statement that may be invoked against a database connection with multiple parameter sets. The specific method is known as cursor.executemany(), and it has many behavioral differences in comparison to the cursor.execute() method which is used for single-statement invocation. The “executemany” method executes the given SQL statement multiple times, once for each set of parameters passed. The general rationale for using executemany is that of improved performance, wherein the DBAPI may use techniques such as preparing the statement just once beforehand, or otherwise optimizing for invoking the same statement many times.\n\nSQLAlchemy typically makes use of the cursor.executemany() method automatically when the Connection.execute() method is used where a list of parameter dictionaries were passed; this indicates to SQLAlchemy Core that the SQL statement and processed parameter sets should be passed to cursor.executemany(), where the statement will be invoked by the driver for each parameter dictionary individually.\n\nA key limitation of the cursor.executemany() method as used with all known DBAPIs is that the cursor is not configured to return rows when this method is used. For most backends (a notable exception being the cx_Oracle, / OracleDB DBAPIs), this means that statements like INSERT..RETURNING typically cannot be used with cursor.executemany() directly, since DBAPIs typically do not aggregate the single row from each INSERT execution together.\n\nTo overcome this limitation, SQLAlchemy as of the 2.0 series implements an alternative form of “executemany” which is known as “Insert Many Values” Behavior for INSERT statements. This feature makes use of cursor.execute() to invoke an INSERT statement that will proceed with multiple parameter sets in one round trip, thus producing the same effect as using cursor.executemany() while still supporting RETURNING.\n\nSee also\n\nSending Multiple Parameters - tutorial introduction to “executemany”\n\n“Insert Many Values” Behavior for INSERT statements - SQLAlchemy feature which allows RETURNING to be used with “executemany”\n\nexpire¶\n\nexpired¶\n\nexpires¶\n\nexpiring¶\n\nExpiring¶\n\nIn the SQLAlchemy ORM, refers to when the data in a persistent or sometimes detached object is erased, such that when the object’s attributes are next accessed, a lazy load SQL query will be emitted in order to refresh the data for this object as stored in the current ongoing transaction.\n\nSee also\n\nRefreshing / Expiring\n\nfacade¶\n\nAn object that serves as a front-facing interface masking more complex underlying or structural code.\n\nSee also\n\nFacade pattern (via Wikipedia)\n\nflush¶\n\nflushing¶\n\nflushed¶\n\nThis refers to the actual process used by the unit of work to emit changes to a database. In SQLAlchemy this process occurs via the Session object and is usually automatic, but can also be controlled manually.\n\nSee also\n\nFlushing\n\nforeign key constraint¶\n\nA referential constraint between two tables. A foreign key is a field or set of fields in a relational table that matches a candidate key of another table. The foreign key can be used to cross-reference tables. (via Wikipedia)\n\nA foreign key constraint can be added to a table in standard SQL using DDL like the following:\n\nALTERTABLEemployeeADDCONSTRAINTdep_id_fk FOREIGNKEY(employee)REFERENCESdepartment(dep_id)\n\nSee also\n\nForeign Key Constraint (via Wikipedia)\n\nFROM clause¶\n\nThe portion of the SELECT statement which indicates the initial source of rows.\n\nA simple SELECT will feature one or more table names in its FROM clause. Multiple sources are separated by a comma:\n\nSELECTuser.name,address.email_address FROMuser,address WHEREuser.id=address.user_id\n\nThe FROM clause is also where explicit joins are specified. We can rewrite the above SELECT using a single FROM element which consists of a JOIN of the two tables:\n\nSELECTuser.name,address.email_address FROMuserJOINaddressONuser.id=address.user_id\n\nidentity key¶\n\nA key associated with ORM-mapped objects that identifies their primary key identity within the database, as well as their unique identity within a Session identity map.\n\nIn SQLAlchemy, you can view the identity key for an ORM object using the inspect() API to return the InstanceState tracking object, then looking at the InstanceState.key attribute:\n\n>>> from sqlalchemy import inspect >>> inspect(some_object).key (<class '__main__.MyTable'>, (1,), None)\n\nSee also\n\nidentity map\n\nidentity map¶\n\nA mapping between Python objects and their database identities. The identity map is a collection that’s associated with an ORM Session object, and maintains a single instance of every database object keyed to its identity. The advantage to this pattern is that all operations which occur for a particular database identity are transparently coordinated onto a single object instance. When using an identity map in conjunction with an isolated transaction, having a reference to an object that’s known to have a particular primary key can be considered from a practical standpoint to be a proxy to the actual database row.\n\nSee also\n\nIdentity Map (via Martin Fowler)\n\nGet by Primary Key - how to look up an object in the identity map by primary key\n\nimperative¶\n\ndeclarative¶\n\nIn the SQLAlchemy ORM, these terms refer to two different styles of mapping Python classes to database tables.\n\nSee also\n\nDeclarative Mapping\n\nImperative Mapping\n\ninsertmanyvalues¶\n\nThis refers to a SQLAlchemy-specific feature which allows INSERT statements to emit thousands of new rows within a single statement while at the same time allowing server generated values to be returned inline from the statement using RETURNING or similar, for performance optimization purposes. The feature is intended to be transparently available for selected backends, but does offer some configurational options. See the section “Insert Many Values” Behavior for INSERT statements for a full description of this feature.\n\nSee also\n\n“Insert Many Values” Behavior for INSERT statements\n\ninstrumentation¶\n\ninstrumented¶\n\ninstrumenting¶\n\nInstrumentation refers to the process of augmenting the functionality and attribute set of a particular class. Ideally, the behavior of the class should remain close to a regular class, except that additional behaviors and features are made available. The SQLAlchemy mapping process, among other things, adds database-enabled descriptors to a mapped class each of which represents a particular database column or relationship to a related class.\n\nisolation¶\n\nisolated¶\n\nisolation level¶\n\nThe isolation property of the ACID model ensures that the concurrent execution of transactions results in a system state that would be obtained if transactions were executed serially, i.e. one after the other. Each transaction must execute in total isolation i.e. if T1 and T2 execute concurrently then each should remain independent of the other. (via Wikipedia)\n\nSee also\n\nACID\n\nIsolation (via Wikipedia)\n\nread uncommitted\n\nread committed\n\nrepeatable read\n\nserializable\n\nlazy initialization¶\n\nA tactic of delaying some initialization action, such as creating objects, populating data, or establishing connectivity to other services, until those resources are required.\n\nSee also\n\nLazy initialization (via Wikipedia)\n\nlazy load¶\n\nlazy loads¶\n\nlazy loaded¶\n\nlazy loading¶\n\nIn object relational mapping, a “lazy load” refers to an attribute that does not contain its database-side value for some period of time, typically when the object is first loaded. Instead, the attribute receives a memoization that causes it to go out to the database and load its data when it’s first used. Using this pattern, the complexity and time spent within object fetches can sometimes be reduced, in that attributes for related tables don’t need to be addressed immediately.\n\nLazy loading is the opposite of eager loading.\n\nWithin SQLAlchemy, lazy loading is a key feature of the ORM, and applies to attributes which are mapped on a user-defined class. When attributes that refer to database columns or related objects are accessed, for which no loaded value is present, the ORM makes use of the Session for which the current object is associated with in the persistent state, and emits a SELECT statement on the current transaction, starting a new transaction if one was not in progress. If the object is in the detached state and not associated with any Session, this is considered to be an error state and an informative exception is raised.\n\nSee also\n\nLazy Load (via Martin Fowler)\n\nN plus one problem\n\nColumn Loading Options - includes information on lazy loading of ORM mapped columns\n\nRelationship Loading Techniques - includes information on lazy loading of ORM related objects\n\nPreventing Implicit IO when Using AsyncSession - tips on avoiding lazy loading when using the Asynchronous I/O (asyncio) extension\n\nmany to many¶\n\nA style of sqlalchemy.orm.relationship() which links two tables together via an intermediary table in the middle. Using this configuration, any number of rows on the left side may refer to any number of rows on the right, and vice versa.\n\nA schema where employees can be associated with projects:\n\nCREATETABLEemployee( idINTEGERPRIMARYKEY, nameVARCHAR(30) ) CREATETABLEproject( idINTEGERPRIMARYKEY, nameVARCHAR(30) ) CREATETABLEemployee_project( employee_idINTEGERPRIMARYKEY, project_idINTEGERPRIMARYKEY, FOREIGNKEYemployee_idREFERENCESemployee(id), FOREIGNKEYproject_idREFERENCESproject(id) )\n\nAbove, the employee_project table is the many-to-many table, which naturally forms a composite primary key consisting of the primary key from each related table.\n\nIn SQLAlchemy, the sqlalchemy.orm.relationship() function can represent this style of relationship in a mostly transparent fashion, where the many-to-many table is specified using plain table metadata:\n\nclass Employee(Base): __tablename__ = \"employee\" id = Column(Integer, primary_key=True) name = Column(String(30)) projects = relationship( \"Project\", secondary=Table( \"employee_project\", Base.metadata, Column(\"employee_id\", Integer, ForeignKey(\"employee.id\"), primary_key=True), Column(\"project_id\", Integer, ForeignKey(\"project.id\"), primary_key=True), ), backref=\"employees\", ) class Project(Base): __tablename__ = \"project\" id = Column(Integer, primary_key=True) name = Column(String(30))\n\nAbove, the Employee.projects and back-referencing Project.employees collections are defined:\n\nproj = Project(name=\"Client A\") emp1 = Employee(name=\"emp1\") emp2 = Employee(name=\"emp2\") proj.employees.extend([emp1, emp2])\n\nSee also\n\nassociation relationship\n\nrelationship\n\none to many\n\nmany to one\n\nmany to one¶\n\nA style of relationship() which links a foreign key in the parent mapper’s table to the primary key of a related table. Each parent object can then refer to exactly zero or one related object.\n\nThe related objects in turn will have an implicit or explicit one to many relationship to any number of parent objects that refer to them.\n\nAn example many to one schema (which, note, is identical to the one to many schema):\n\nCREATETABLEdepartment( idINTEGERPRIMARYKEY, nameVARCHAR(30) ) CREATETABLEemployee( idINTEGERPRIMARYKEY, nameVARCHAR(30), dep_idINTEGERREFERENCESdepartment(id) )\n\nThe relationship from employee to department is many to one, since many employee records can be associated with a single department. A SQLAlchemy mapping might look like:\n\nclass Department(Base): __tablename__ = \"department\" id = Column(Integer, primary_key=True) name = Column(String(30)) class Employee(Base): __tablename__ = \"employee\" id = Column(Integer, primary_key=True) name = Column(String(30)) dep_id = Column(Integer, ForeignKey(\"department.id\")) department = relationship(\"Department\")\n\nSee also\n\nrelationship\n\none to many\n\nbackref\n\nmapping¶\n\nmapped¶\n\nmapped class¶\n\nORM mapped class¶\n\nWe say a class is “mapped” when it has been associated with an instance of the Mapper class. This process associates the class with a database table or other selectable construct, so that instances of it can be persisted and loaded using a Session.\n\nSee also\n\nORM Mapped Class Overview\n\nmarshalling¶\n\ndata marshalling¶\n\nThe process of transforming the memory representation of an object to a data format suitable for storage or transmission to another part of a system, when data must be moved between different parts of a computer program or from one program to another. In terms of SQLAlchemy, we often need to “marshal” data into a format appropriate for passing into the relational database.\n\nSee also\n\nMarshalling (via Wikipedia)\n\nAugmenting Existing Types - SQLAlchemy’s TypeDecorator is commonly used for data marshalling as data is sent into the database for INSERT and UPDATE statements, and “unmarshalling” data as it is retrieved using SELECT statements.\n\nmetadata¶\n\ndatabase metadata¶\n\ntable metadata¶\n\nThe term “metadata” generally refers to “data that describes data”; data that itself represents the format and/or structure of some other kind of data. In SQLAlchemy, the term “metadata” typically refers to the MetaData construct, which is a collection of information about the tables, columns, constraints, and other DDL objects that may exist in a particular database.\n\nSee also\n\nMetadata Mapping (via Martin Fowler)\n\nWorking with Database Metadata - in the SQLAlchemy Unified Tutorial\n\nmethod chaining¶\n\ngenerative¶\n\n“Method chaining”, referred to within SQLAlchemy documentation as “generative”, is an object-oriented technique whereby the state of an object is constructed by calling methods on the object. The object features any number of methods, each of which return a new object (or in some cases the same object) with additional state added to the object.\n\nThe two SQLAlchemy objects that make the most use of method chaining are the Select object and the Query object. For example, a Select object can be assigned two expressions to its WHERE clause as well as an ORDER BY clause by calling upon the Select.where() and Select.order_by() methods:\n\nstmt = ( select(user.c.name) .where(user.c.id > 5) .where(user.c.name.like(\"e%\")) .order_by(user.c.name) )\n\nEach method call above returns a copy of the original Select object with additional qualifiers added.\n\nmixin class¶\n\nmixin classes¶\n\nA common object-oriented pattern where a class that contains methods or attributes for use by other classes without having to be the parent class of those other classes.\n\nSee also\n\nMixin (via Wikipedia)\n\nN plus one problem¶\n\nN plus one¶\n\nThe N plus one problem is a common side effect of the lazy load pattern, whereby an application wishes to iterate through a related attribute or collection on each member of a result set of objects, where that attribute or collection is set to be loaded via the lazy load pattern. The net result is that a SELECT statement is emitted to load the initial result set of parent objects; then, as the application iterates through each member, an additional SELECT statement is emitted for each member in order to load the related attribute or collection for that member. The end result is that for a result set of N parent objects, there will be N + 1 SELECT statements emitted.\n\nThe N plus one problem is alleviated using eager loading.\n\nSee also\n\nLoader Strategies\n\nRelationship Loading Techniques\n\none to many¶\n\nA style of relationship() which links the primary key of the parent mapper’s table to the foreign key of a related table. Each unique parent object can then refer to zero or more unique related objects.\n\nThe related objects in turn will have an implicit or explicit many to one relationship to their parent object.\n\nAn example one to many schema (which, note, is identical to the many to one schema):\n\nCREATETABLEdepartment( idINTEGERPRIMARYKEY, nameVARCHAR(30) ) CREATETABLEemployee( idINTEGERPRIMARYKEY, nameVARCHAR(30), dep_idINTEGERREFERENCESdepartment(id) )\n\nThe relationship from department to employee is one to many, since many employee records can be associated with a single department. A SQLAlchemy mapping might look like:\n\nclass Department(Base): __tablename__ = \"department\" id = Column(Integer, primary_key=True) name = Column(String(30)) employees = relationship(\"Employee\") class Employee(Base): __tablename__ = \"employee\" id = Column(Integer, primary_key=True) name = Column(String(30)) dep_id = Column(Integer, ForeignKey(\"department.id\"))\n\nSee also\n\nrelationship\n\nmany to one\n\nbackref\n\nORM-annotated¶\n\nannotations¶\n\nThe phrase “ORM-annotated” refers to an internal aspect of SQLAlchemy, where a Core object such as a Column object can carry along additional runtime information that marks it as belonging to a particular ORM mapping. The term should not be confused with the common phrase “type annotation”, which refers to Python source code “type hints” used for static typing as introduced at PEP 484.\n\nMost of SQLAlchemy’s documented code examples are formatted with a small note regarding “Annotated Example” or “Non-annotated Example”. This refers to whether or not the example is PEP 484 annotated, and is not related to the SQLAlchemy concept of “ORM-annotated”.\n\nWhen the phrase “ORM-annotated” appears in documentation, it is referring to Core SQL expression objects such as Table, Column, and Select objects, which originate from, or refer to sub-elements that originate from, one or more ORM mappings, and therefore will have ORM-specific interpretations and/or behaviors when passed to ORM methods such as Session.execute(). For example, when we construct a Select object from an ORM mapping, such as the User class illustrated in the ORM Tutorial:\n\n>>> stmt = select(User)\n\nThe internal state of the above Select refers to the Table to which User is mapped. The User class itself is not immediately referenced. This is how the Select construct remains compatible with Core-level processes (note that the ._raw_columns member of Select is private and should not be accessed by end-user code):\n\n>>> stmt._raw_columns [Table('user_account', MetaData(), Column('id', Integer(), ...)]\n\nHowever, when our Select is passed along to an ORM Session, the ORM entities that are indirectly associated with the object are used to interpret this Select in an ORM context. The actual “ORM annotations” can be seen in another private variable ._annotations:\n\n>>> stmt._raw_columns[0]._annotations immutabledict({ 'entity_namespace': <Mapper at 0x7f4dd8098c10; User>, 'parententity': <Mapper at 0x7f4dd8098c10; User>, 'parentmapper': <Mapper at 0x7f4dd8098c10; User> })\n\nTherefore we refer to stmt as an ORM-annotated select() object. It’s a Select statement that contains additional information that will cause it to be interpreted in an ORM-specific way when passed to methods like Session.execute().\n\npending¶\n\nThis describes one of the major object states which an object can have within a Session; a pending object is a new object that doesn’t have any database identity, but has been recently associated with a session. When the session emits a flush and the row is inserted, the object moves to the persistent state.\n\nSee also\n\nQuickie Intro to Object States\n\npersistent¶\n\nThis describes one of the major object states which an object can have within a Session; a persistent object is an object that has a database identity (i.e. a primary key) and is currently associated with a session. Any object that was previously pending and has now been inserted is in the persistent state, as is any object that’s been loaded by the session from the database. When a persistent object is removed from a session, it is known as detached.\n\nSee also\n\nQuickie Intro to Object States\n\nplugin¶\n\nplugin-enabled¶\n\nplugin-specific¶\n\n“plugin-enabled” or “plugin-specific” generally indicates a function or method in SQLAlchemy Core which will behave differently when used in an ORM context.\n\nSQLAlchemy allows Core constructs such as Select objects to participate in a “plugin” system, which can inject additional behaviors and features into the object that are not present by default.\n\nSpecifically, the primary “plugin” is the “orm” plugin, which is at the base of the system that the SQLAlchemy ORM makes use of Core constructs in order to compose and execute SQL queries that return ORM results.\n\nSee also\n\nORM Query Unified with Core Select\n\npolymorphic¶\n\npolymorphically¶\n\nRefers to a function that handles several types at once. In SQLAlchemy, the term is usually applied to the concept of an ORM mapped class whereby a query operation will return different subclasses based on information in the result set, typically by checking the value of a particular column in the result known as the discriminator.\n\nPolymorphic loading in SQLAlchemy implies that a one or a combination of three different schemes are used to map a hierarchy of classes; “joined”, “single”, and “concrete”. The section Mapping Class Inheritance Hierarchies describes inheritance mapping fully.\n\nprimary key¶\n\nprimary key constraint¶\n\nread committed¶\n\nOne of the four database isolation levels, read committed features that the transaction will not be exposed to any data from other concurrent transactions that has not been committed yet, preventing so-called “dirty reads”. However, under read committed there can be non-repeatable reads, meaning data in a row may change when read a second time if another transaction has committed changes.\n\nread uncommitted¶\n\nOne of the four database isolation levels, read uncommitted features that changes made to database data within a transaction will not become permanent until the transaction is committed. However, within read uncommitted, it may be possible for data that is not committed in other transactions to be viewable within the scope of another transaction; these are known as “dirty reads”.\n\nreflection¶\n\nreflected¶\n\nIn SQLAlchemy, this term refers to the feature of querying a database’s schema catalogs in order to load information about existing tables, columns, constraints, and other constructs. SQLAlchemy includes features that can both provide raw data for this information, as well as that it can construct Core/ORM usable Table objects from database schema catalogs automatically.\n\nSee also\n\nReflecting Database Objects - complete background on database reflection.\n\nMapping Declaratively with Reflected Tables - background on integrating ORM mappings with reflected tables.\n\nregistry¶\n\nAn object, typically globally accessible, that contains long-lived information about some program state that is generally useful to many parts of a program.\n\nSee also\n\nRegistry (via Martin Fowler)\n\nrelational¶\n\nrelational algebra¶\n\nAn algebraic system developed by Edgar F. Codd that is used for modelling and querying the data stored in relational databases.\n\nSee also\n\nRelational Algebra (via Wikipedia)\n\nrelationship¶\n\nrelationships¶\n\nA connecting unit between two mapped classes, corresponding to some relationship between the two tables in the database.\n\nThe relationship is defined using the SQLAlchemy function relationship(). Once created, SQLAlchemy inspects the arguments and underlying mappings involved in order to classify the relationship as one of three types: one to many, many to one, or many to many. With this classification, the relationship construct handles the task of persisting the appropriate linkages in the database in response to in-memory object associations, as well as the job of loading object references and collections into memory based on the current linkages in the database.\n\nSee also\n\nRelationship Configuration\n\nrelease¶\n\nreleases¶\n\nreleased¶\n\nIn the context of SQLAlchemy, the term “released” refers to the process of ending the usage of a particular database connection. SQLAlchemy features the usage of connection pools, which allows configurability as to the lifespan of database connections. When using a pooled connection, the process of “closing” it, i.e. invoking a statement like connection.close(), may have the effect of the connection being returned to an existing pool, or it may have the effect of actually shutting down the underlying TCP/IP connection referred to by that connection - which one takes place depends on configuration as well as the current state of the pool. So we used the term released instead, to mean “do whatever it is you do with connections when we’re done using them”.\n\nThe term will sometimes be used in the phrase, “release transactional resources”, to indicate more explicitly that what we are actually “releasing” is any transactional state which as accumulated upon the connection. In most situations, the process of selecting from tables, emitting updates, etc. acquires isolated state upon that connection as well as potential row or table locks. This state is all local to a particular transaction on the connection, and is released when we emit a rollback. An important feature of the connection pool is that when we return a connection to the pool, the connection.rollback() method of the DBAPI is called as well, so that as the connection is set up to be used again, it’s in a “clean” state with no references held to the previous series of operations.\n\nSee also\n\nConnection Pooling\n\nrepeatable read¶\n\nOne of the four database isolation levels, repeatable read features all of the isolation of read committed, and additionally features that any particular row that is read within a transaction is guaranteed from that point to not have any subsequent external changes in value (i.e. from other concurrent UPDATE statements) for the duration of that transaction.\n\nRETURNING¶\n\nThis is a non-SQL standard clause provided in various forms by certain backends, which provides the service of returning a result set upon execution of an INSERT, UPDATE or DELETE statement. Any set of columns from the matched rows can be returned, as though they were produced from a SELECT statement.\n\nThe RETURNING clause provides both a dramatic performance boost to common update/select scenarios, including retrieval of inline- or default- generated primary key values and defaults at the moment they were created, as well as a way to get at server-generated default values in an atomic way.\n\nAn example of RETURNING, idiomatic to PostgreSQL, looks like:\n\nINSERTINTOuser_account(name)VALUES('new name')RETURNINGid,timestamp\n\nAbove, the INSERT statement will provide upon execution a result set which includes the values of the columns user_account.id and user_account.timestamp, which above should have been generated as default values as they are not included otherwise (but note any series of columns or SQL expressions can be placed into RETURNING, not just default-value columns).\n\nThe backends that currently support RETURNING or a similar construct are PostgreSQL, SQL Server, Oracle, and Firebird. The PostgreSQL and Firebird implementations are generally full featured, whereas the implementations of SQL Server and Oracle have caveats. On SQL Server, the clause is known as “OUTPUT INSERTED” for INSERT and UPDATE statements and “OUTPUT DELETED” for DELETE statements; the key caveat is that triggers are not supported in conjunction with this keyword. On Oracle, it is known as “RETURNING…INTO”, and requires that the value be placed into an OUT parameter, meaning not only is the syntax awkward, but it can also only be used for one row at a time.\n\nSQLAlchemy’s UpdateBase.returning() system provides a layer of abstraction on top of the RETURNING systems of these backends to provide a consistent interface for returning columns. The ORM also includes many optimizations that make use of RETURNING when available.\n\nselectable¶\n\nA term used in SQLAlchemy to describe a SQL construct that represents a collection of rows. It’s largely similar to the concept of a “relation” in relational algebra. In SQLAlchemy, objects that subclass the Selectable class are considered to be usable as “selectables” when using SQLAlchemy Core. The two most common constructs are that of the Table and that of the Select statement.\n\nsentinel¶\n\ninsert sentinel¶\n\nThis is a SQLAlchemy-specific term that refers to a Column which can be used for a bulk insertmanyvalues operation to track INSERTed data records against rows passed back using RETURNING or similar. Such a column configuration is necessary for those cases when the insertmanyvalues feature does an optimized INSERT..RETURNING statement for many rows at once while still being able to guarantee the order of returned rows matches the input data.\n\nFor typical use cases, the SQLAlchemy SQL compiler can automatically make use of surrogate integer primary key columns as “insert sentinels”, and no user-configuration is required. For less common cases with other varieties of server-generated primary key values, explicit “insert sentinel” columns may be optionally configured within table metadata in order to optimize INSERT statements that are inserting many rows at once.\n\nSee also\n\nCorrelating RETURNING rows to parameter sets - in the section “Insert Many Values” Behavior for INSERT statements\n\nserializable¶\n\nOne of the four database isolation levels, serializable features all of the isolation of repeatable read, and additionally within a lock-based approach guarantees that so-called “phantom reads” cannot occur; this means that rows which are INSERTed or DELETEd within the scope of other transactions will not be detectable within this transaction. A row that is read within this transaction is guaranteed to continue existing, and a row that does not exist is guaranteed that it cannot appear of inserted from another transaction.\n\nSerializable isolation typically relies upon locking of rows or ranges of rows in order to achieve this effect and can increase the chance of deadlocks and degrade performance. There are also non-lock based schemes however these necessarily rely upon rejecting transactions if write collisions are detected.\n\nSession¶\n\nThe container or scope for ORM database operations. Sessions load instances from the database, track changes to mapped instances and persist changes in a single unit of work when flushed.\n\nSee also\n\nUsing the Session\n\nsubquery¶\n\nscalar subquery¶\n\nRefers to a SELECT statement that is embedded within an enclosing SELECT.\n\nA subquery comes in two general flavors, one known as a “scalar select” which specifically must return exactly one row and one column, and the other form which acts as a “derived table” and serves as a source of rows for the FROM clause of another select. A scalar select is eligible to be placed in the WHERE clause, columns clause, ORDER BY clause or HAVING clause of the enclosing select, whereas the derived table form is eligible to be placed in the FROM clause of the enclosing SELECT.\n\nExamples:\n\na scalar subquery placed in the columns clause of an enclosing SELECT. The subquery in this example is a correlated subquery because part of the rows which it selects from are given via the enclosing statement.\n\nSELECTid,(SELECTnameFROMaddressWHEREaddress.user_id=user.id) FROMuser\n\na scalar subquery placed in the WHERE clause of an enclosing SELECT. This subquery in this example is not correlated as it selects a fixed result.\n\nSELECTid,nameFROMuser WHEREstatus=(SELECTstatus_idFROMstatus_codeWHEREcode='C')\n\na derived table subquery placed in the FROM clause of an enclosing SELECT. Such a subquery is almost always given an alias name.\n\nSELECTuser.id,user.name,ad_subq.email_address FROM userJOIN (selectuser_id,email_addressFROMaddressWHEREaddress_type='Q')ASad_subq ONuser.id=ad_subq.user_id\n\ntransient¶\n\nThis describes one of the major object states which an object can have within a Session; a transient object is a new object that doesn’t have any database identity and has not been associated with a session yet. When the object is added to the session, it moves to the pending state.\n\nSee also\n\nQuickie Intro to Object States\n\nunique constraint¶\n\nunique key index¶\n\nA unique key index can uniquely identify each row of data values in a database table. A unique key index comprises a single column or a set of columns in a single database table. No two distinct rows or data records in a database table can have the same data value (or combination of data values) in those unique key index columns if NULL values are not used. Depending on its design, a database table may have many unique key indexes but at most one primary key index.\n\n(via Wikipedia)\n\nSee also\n\nUnique key (via Wikipedia)\n\nunit of work¶\n\nA software architecture where a persistence system such as an object relational mapper maintains a list of changes made to a series of objects, and periodically flushes all those pending changes out to the database.\n\nSQLAlchemy’s Session implements the unit of work pattern, where objects that are added to the Session using methods like Session.add() will then participate in unit-of-work style persistence.\n\nFor a walk-through of what unit of work persistence looks like in SQLAlchemy, start with the section Data Manipulation with the ORM in the SQLAlchemy Unified Tutorial. Then for more detail, see Basics of Using a Session in the general reference documentation.\n\nSee also\n\nUnit of Work (via Martin Fowler)\n\nData Manipulation with the ORM\n\nBasics of Using a Session\n\nversion id column¶\n\nIn SQLAlchemy, this refers to the use of a particular table column that tracks the “version” of a particular row, as the row changes values. While there are different kinds of relational patterns that make use of a “version id column” in different ways, SQLAlchemy’s ORM includes a particular feature that allows for such a column to be configured as a means of testing for stale data when a row is being UPDATEd with new information. If the last known “version” of this column does not match that of the row when we try to put new data into the row, we know that we are acting on stale information.\n\nThere are also other ways of storing “versioned” rows in a database, often referred to as “temporal” data. In addition to SQLAlchemy’s versioning feature, a few more examples are also present in the documentation, see the links below.\n\nSee also\n\nConfiguring a Version Counter - SQLAlchemy’s built-in version id feature.\n\nVersioning Objects - other examples of mappings that version rows temporally.\n\nWHERE clause¶\n\nThe portion of the SELECT statement which indicates criteria by which rows should be filtered. It is a single SQL expression which follows the keyword WHERE.\n\nSELECTuser_account.name,user_account.email FROMuser_account WHEREuser_account.name='fred'ANDuser_account.status='E'\n\nAbove, the phrase WHERE user_account.name = 'fred' AND user_account.status = 'E' comprises the WHERE clause of the SELECT."
    }
}