{
    "id": "dbpedia_2180_2",
    "rank": 26,
    "data": {
        "url": "https://cwiki.apache.org/confluence/display/hive/hive%2Btransactions",
        "read_more_link": "",
        "language": "en",
        "title": "Apache Software Foundation",
        "top_image": "https://cwiki.apache.org/confluence/s/p9b4rx/8804/1naq7q0/1/_/favicon.ico",
        "meta_img": "https://cwiki.apache.org/confluence/s/p9b4rx/8804/1naq7q0/1/_/favicon.ico",
        "images": [
            "https://cwiki.apache.org/confluence/download/attachments/27362113/Hive?version=2&modificationDate=1317659390000&api=v2"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Alan Gates"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/confluence/s/p9b4rx/8804/1naq7q0/1/_/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://cwiki.apache.org/confluence/display/Hive/Hive+Transactions",
        "text": "ACID and Transactions in Hive\n\nWhat is ACID and why should you use it?\n\nACID stands for four traits of database transactions: Atomicity (an operation either succeeds completely or fails, it does not leave partial data), Consistency (once an application performs an operation the results of that operation are visible to it in every subsequent operation), Isolation (an incomplete operation by one user does not cause unexpected side effects for other users), and Durability (once an operation is complete it will be preserved even in the face of machine or system failure). These traits have long been expected of database systems as part of their transaction functionality.\n\nUp until Hive 0.13, atomicity, consistency, and durability were provided at the partition level. Isolation could be provided by turning on one of the available locking mechanisms (ZooKeeper or in memory). With the addition of transactions in Hive 0.13 it is now possible to provide full ACID semantics at the row level, so that one application can add rows while another reads from the same partition without interfering with each other.\n\nTransactions with ACID semantics have been added to Hive to address the following use cases:\n\nStreaming ingest of data. Many users have tools such as Apache Flume, Apache Storm, or Apache Kafka that they use to stream data into their Hadoop cluster. While these tools can write data at rates of hundreds or more rows per second, Hive can only add partitions every fifteen minutes to an hour. Adding partitions more often leads quickly to an overwhelming number of partitions in the table. These tools could stream data into existing partitions, but this would cause readers to get dirty reads (that is, they would see data written after they had started their queries) and leave many small files in their directories that would put pressure on the NameNode. With this new functionality this use case will be supported while allowing readers to get a consistent view of the data and avoiding too many files.\n\nSlow changing dimensions. In a typical star schema data warehouse, dimensions tables change slowly over time. For example, a retailer will open new stores, which need to be added to the stores table, or an existing store may change its square footage or some other tracked characteristic. These changes lead to inserts of individual records or updates of records (depending on the strategy chosen). Starting with 0.14, Hive is able to support this.\n\nData restatement. Sometimes collected data is found to be incorrect and needs correction. Or the first instance of the data may be an approximation (90% of servers reporting) with the full data provided later. Or business rules may require that certain transactions be restated due to subsequent transactions (e.g., after making a purchase a customer may purchase a membership and thus be entitled to discount prices, including on the previous purchase). Or a user may be contractually required to remove their customer’s data upon termination of their relationship. Starting with Hive 0.14 these use cases can be supported via INSERT, UPDATE, and DELETE.\n\nBulk updates using SQL MERGE statement.\n\nLimitations\n\nBEGIN, COMMIT, and ROLLBACK are not yet supported. All language operations are auto-commit. The plan is to support these in a future release.\n\nOnly ORC file format is supported in this first release. The feature has been built such that transactions can be used by any storage format that can determine how updates or deletes apply to base records (basically, that has an explicit or implicit row id), but so far the integration work has only been done for ORC.\n\nBy default transactions are configured to be off. See the Configuration section below for a discussion of which values need to be set to configure it.\n\nTables must be bucketed to make use of these features. Tables in the same system not using transactions and ACID do not need to be bucketed. External tables cannot be made ACID tables since the changes on external tables are beyond the control of the compactor (HIVE-13175).\n\nReading/writing to an ACID table from a non-ACID session is not allowed. In other words, the Hive transaction manager must be set to org.apache.hadoop.hive.ql.lockmgr.DbTxnManager in order to work with ACID tables.\n\nAt this time only snapshot level isolation is supported. When a given query starts it will be provided with a consistent snapshot of the data. There is no support for dirty read, read committed, repeatable read, or serializable. With the introduction of BEGIN the intention is to support snapshot isolation for the duration of transaction rather than just a single query. Other isolation levels may be added depending on user requests.\n\nThe existing ZooKeeper and in-memory lock managers are not compatible with transactions. There is no intention to address this issue. See Basic Design below for a discussion of how locks are stored for transactions.\n\nSchema changes using ALTER TABLE is NOT supported for ACID tables. HIVE-11421 is tracking it. Fixed in 1.3.0/2.0.0.\n\nUsing Oracle as the Metastore DB and \"datanucleus.connectionPoolingType=BONECP\" may generate intermittent \"No such lock..\" and \"No such transaction...\" errors. Setting \"datanucleus.connectionPoolingType=DBCP\" is recommended in this case.\n\nLOAD DATA... statement is not supported with transactional tables. (This was not properly enforced until HIVE-16732)\n\nStreaming APIs\n\nHive offers APIs for streaming data ingest and streaming mutation:\n\nHive HCatalog Streaming API\n\nHive Streaming API (Since Hive 3)\n\nHCatalog Streaming Mutation API (available in Hive 2.0.0 and later)\n\nA comparison of these two APIs is available in the Background section of the Streaming Mutation document.\n\nGrammar Changes\n\nINSERT...VALUES, UPDATE, and DELETE have been added to the SQL grammar, starting in Hive 0.14. See LanguageManual DML for details.\n\nSeveral new commands have been added to Hive's DDL in support of ACID and transactions, plus some existing DDL has been modified.\n\nA new command SHOW TRANSACTIONS has been added, see Show Transactions for details.\n\nA new command SHOW COMPACTIONS has been added, see Show Compactions for details.\n\nThe SHOW LOCKS command has been altered to provide information about the new locks associated with transactions. If you are using the ZooKeeper or in-memory lock managers you will notice no difference in the output of this command. See Show Locks for details.\n\nA new option has been added to ALTER TABLE to request a compaction of a table or partition. In general users do not need to request compactions, as the system will detect the need for them and initiate the compaction. However, if compaction is turned off for a table or a user wants to compact the table at a time the system would not choose to, ALTER TABLE can be used to initiate the compaction. See Alter Table/Partition Compact for details. This will enqueue a request for compaction and return. To watch the progress of the compaction the user can use SHOW COMPACTIONS.\n\nA new command ABORT TRANSACTIONS has been added, see Abort Transactions for details.\n\nBasic Design\n\nHDFS does not support in-place changes to files. It also does not offer read consistency in the face of writers appending to files being read by a user. In order to provide these features on top of HDFS we have followed the standard approach used in other data warehousing tools. Data for the table or partition is stored in a set of base files. New records, updates, and deletes are stored in delta files. A new set of delta files is created for each transaction (or in the case of streaming agents such as Flume or Storm, each batch of transactions) that alters a table or partition. At read time the reader merges the base and delta files, applying any updates and deletes as it reads.\n\nBase and Delta Directories\n\nPreviously all files for a partition (or a table if the table is not partitioned) lived in a single directory. With these changes, any partitions (or tables) written with an ACID aware writer will have a directory for the base files and a directory for each set of delta files. Here is what this may look like for an unpartitioned table \"t\":\n\nCompactor\n\nCompactor is a set of background processes running inside the Metastore to support ACID system. It consists of Initiator, Worker, Cleaner, AcidHouseKeeperService and a few others.\n\nDelta File Compaction\n\nAs operations modify the table more and more delta files are created and need to be compacted to maintain adequate performance. There are three types of compactions, minor, major and rebalance.\n\nMinor compaction takes a set of existing delta files and rewrites them to a single delta file per bucket.\n\nMajor compaction takes one or more delta files and the base file for the bucket and rewrites them into a new base file per bucket. Major compaction is more expensive but is more effective.\n\nMore information about rebalance compaction can be found here: Rebalance compaction\n\nAll compactions are done in the background. Minor and major compactions do not prevent concurrent reads and writes of the data. Rebalance compaction uses exclusive write lock, therefore it prevents concurrent writes. After a compaction the system waits until all readers of the old files have finished and then removes the old files.\n\nInitiator\n\nThis module is responsible for discovering which tables or partitions are due for compaction. This should be enabled in a Metastore using hive.compactor.initiator.on. There are several properties of the form *.threshold in \"New Configuration Parameters for Transactions\" table below that control when a compaction task is created and which type of compaction is performed. Each compaction task handles 1 partition (or whole table if the table is unpartitioned). If the number of consecutive compaction failures for a given partition exceeds hive.compactor.initiator.failed.compacts.threshold, automatic compaction scheduling will stop for this partition. See Configuration Parameters table for more info.\n\nWorker\n\nEach Worker handles a single compaction task. A compaction is a MapReduce job with name in the following form: <hostname>-compactor-<db>.<table>.<partition>. Each worker submits the job to the cluster (via hive.compactor.job.queue if defined) and waits for the job to finish. hive.compactor.worker.threads determines the number of Workers in each Metastore. The total number of Workers in the Hive Warehouse determines the maximum number of concurrent compactions.\n\nCleaner\n\nThis process is a process that deletes delta files after compaction and after it determines that they are no longer needed.\n\nAcidHouseKeeperService\n\nThis process looks for transactions that have not heartbeated in hive.txn.timeout time and aborts them. The system assumes that a client that initiated a transaction stopped heartbeating crashed and the resources it locked should be released.\n\nSHOW COMPACTIONS\n\nThis commands displays information about currently running compaction and recent history (configurable retention period) of compactions. This history display is available since HIVE-12353.\n\nAlso see LanguageManual DDL#ShowCompactions for more information on the output of this command and NewConfigurationParametersforTransactions/Compaction History for configuration properties affecting the output of this command. The system retains the last N entries of each type: failed, succeeded, attempted (where N is configurable for each type).\n\nTransaction/Lock Manager\n\nA new logical entity called \"transaction manager\" was added which incorporated previous notion of \"database/table/partition lock manager\" (hive.lock.manager with default of org.apache.hadoop.hive.ql.lockmgr.zookeeper.ZooKeeperHiveLockManager). The transaction manager is now additionally responsible for managing of transactions locks. The default DummyTxnManager emulates behavior of old Hive versions: has no transactions and uses hive.lock.manager property to create lock manager for tables, partitions and databases. A newly added DbTxnManager manages all locks/transactions in Hive metastore with DbLockManager (transactions and locks are durable in the face of server failure). This means that previous behavior of locking in ZooKeeper is not present anymore when transactions are enabled. To avoid clients dying and leaving transaction or locks dangling, a heartbeat is sent from lock holders and transaction initiators to the metastore on a regular basis. If a heartbeat is not received in the configured amount of time, the lock or transaction will be aborted.\n\nAs of Hive 1.3.0, the length of time that the DbLockManger will continue to try to acquire locks can be controlled via hive.lock.numretires and hive.lock.sleep.between.retries. When the DbLockManager cannot acquire a lock (due to existence of a competing lock), it will back off and try again after a certain time period. In order to support short running queries and not overwhelm the metastore at the same time, the DbLockManager will double the wait time after each retry. The initial back off time is 100ms and is capped by hive.lock.sleep.between.retries. hive.lock.numretries is the total number of times it will retry a given lock request. Thus the total time that the call to acquire locks will block (given values of 100 retries and 60s sleep time) is (100ms + 200ms + 400ms + ... + 51200ms + 60s + 60s + ... + 60s) = 91m:42s:300ms.\n\nMore details on locks used by this Lock Manager.\n\nNote that the lock manager used by DbTxnManager will acquire locks on all tables, even those without \"transactional=true\" property. By default, Insert operation into a non-transactional table will acquire an exclusive lock and thus block other inserts and reads. While technically correct, this is a departure from how Hive traditionally worked (i.e. w/o a lock manger). For backwards compatibility, hive.txn.strict.locking.mode (see table below) is provided which will make this lock manager acquire shared locks on insert operations on non-transactional tables. This restores previous semantics while still providing the benefit of a lock manager such as preventing table drop while it is being read. Note that for transactional tables, insert always acquires share locks since these tables implement MVCC architecture at the storage layer and are able to provide strong read consistency (Snapshot Isolation) even in presence of concurrent modification operations.\n\nConfiguration\n\nMinimally, these configuration parameters must be set appropriately to turn on transaction support in Hive:\n\nClient Side\n\nhive.support.concurrency – true\n\nhive.enforce.bucketing – true (Not required as of Hive 2.0)\n\nhive.exec.dynamic.partition.mode – nonstrict\n\nhive.txn.manager – org.apache.hadoop.hive.ql.lockmgr.DbTxnManager\n\nServer Side (Metastore)\n\nhive.compactor.initiator.on – true (See table below for more details)\n\nhive.compactor.cleaner.on – true (See table below for more details)\n\nhive.compactor.worker.threads – a positive number on at least one instance of the Thrift metastore service\n\nThe following sections list all of the configuration parameters that affect Hive transactions and compaction. Also see Limitations above and Table Properties below.\n\nNew Configuration Parameters for Transactions\n\nA number of new configuration parameters have been added to the system to support transactions.\n\n1hive.txn.max.open.batch controls how many transactions streaming agents such as Flume or Storm open simultaneously. The streaming agent then writes that number of entries into a single file (per Flume agent or Storm bolt). Thus increasing this value decreases the number of delta files created by streaming agents. But it also increases the number of open transactions that Hive has to track at any given time, which may negatively affect read performance.\n\n2Worker threads spawn MapReduce jobs to do compactions. They do not do the compactions themselves. Increasing the number of worker threads will decrease the time it takes tables or partitions to be compacted once they are determined to need compaction. It will also increase the background load on the Hadoop cluster as more MapReduce jobs will be running in the background. Each compaction can handle one partition at a time (or whole table if it's unpartitioned).\n\n3Decreasing this value will reduce the time it takes for compaction to be started for a table or partition that requires compaction. However, checking if compaction is needed requires several calls to the NameNode for each table or partition that has had a transaction done on it since the last major compaction. So decreasing this value will increase the load on the NameNode.\n\n4If the compactor detects a very high number of delta files, it will first run several partial minor compactions (currently sequentially) and then perform the compaction actually requested.\n\n5If the value is not the same active transactions may be determined to be \"timed out\" and consequently Aborted. This will result in errors like \"No such transaction...\", \"No such lock ...\"\n\nIn addition to the new parameters listed above, some existing parameters need to be set to support INSERT ... VALUES, UPDATE, and DELETE.\n\nConfiguration Values to Set for Compaction\n\nIf the data in your system is not owned by the Hive user (i.e., the user that the Hive metastore runs as), then Hive will need permission to run as the user who owns the data in order to perform compactions. If you have already set up HiveServer2 to impersonate users, then the only additional work to do is assure that Hive has the right to impersonate users from the host running the Hive metastore. This is done by adding the hostname to hadoop.proxyuser.hive.hosts in Hadoop's core-site.xml file. If you have not already done this, then you will need to configure Hive to act as a proxy user. This requires you to set up keytabs for the user running the Hive metastore and add hadoop.proxyuser.hive.hosts and hadoop.proxyuser.hive.groups to Hadoop's core-site.xml file. See the Hadoop documentation on secure mode for your version of Hadoop (e.g., for Hadoop 2.5.1 it is at Hadoop in Secure Mode).\n\nCompaction pooling\n\nMore in formation on compaction pooling can be found here: Compaction pooling\n\nTable Properties\n\nIf a table is to be used in ACID writes (insert, update, delete) then the table property \"transactional=true\" must be set on that table, starting with Hive 0.14.0. Note, once a table has been defined as an ACID table via TBLPROPERTIES (\"transactional\"=\"true\"), it cannot be converted back to a non-ACID table, i.e., changing TBLPROPERTIES (\"transactional\"=\"false\") is not allowed. Also, hive.txn.manager must be set to org.apache.hadoop.hive.ql.lockmgr.DbTxnManager either in hive-site.xml or in the beginning of the session before any query is run. Without those, inserts will be done in the old style; updates and deletes will be prohibited prior to HIVE-11716. Since HIVE-11716 operations on ACID tables without DbTxnManager are not allowed. However, this does not apply to Hive 0.13.0.\n\nIf a table owner does not wish the system to automatically determine when to compact, then the table property \"NO_AUTO_COMPACTION\" can be set. This will prevent all automatic compactions. Manual compactions can still be done with Alter Table/Partition Compact statements.\n\nTable properties are set with the TBLPROPERTIES clause when a table is created or altered, as described in the Create Table and Alter Table Properties sections of Hive Data Definition Language. The \"transactional\" and \"NO_AUTO_COMPACTION\" table properties are case-sensitive in Hive releases 0.x and 1.0, but they are case-insensitive starting with release 1.1.0 (HIVE-8308).\n\nMore compaction related options can be set via TBLPROPERTIES as of Hive 1.3.0 and 2.1.0. They can be set at both table-level via CREATE TABLE, and on request-level via ALTER TABLE/PARTITION COMPACT. These are used to override the Warehouse/table wide settings. For example, to override an MR property to affect a compaction job, one can add \"compactor.<mr property name>=<value>\" in either CREATE TABLE statement or when launching a compaction explicitly via ALTER TABLE. The \"<mr property name>=<value>\" will be set on JobConf of the compaction MR job. Similarly, \"tblprops.<prop name>=<value>\" can be used to set/override any table property which is interpreted by the code running on the cluster. Finally, \"compactorthreshold.<prop name>=<value>\" can be used to override properties from the \"New Configuration Parameters for Transactions\" table above that end with \".threshold\" and control when compactions are triggered by the system. Examples:\n\nTalks and Presentations\n\nTransactional Operations In Hive by Eugene Koifman at Dataworks Summit 2017, San Jose, CA, USA\n\nSlides\n\nVideo\n\nDataWorks Summit 2018, San Jose, CA, USA - Covers Hive 3 and ACID V2 features\n\nSlides\n\nVideo\n\nSave\n\nSave"
    }
}