{
    "id": "dbpedia_2180_3",
    "rank": 35,
    "data": {
        "url": "https://en.wikipedia.org/wiki/Eventual_consistency",
        "read_more_link": "",
        "language": "en",
        "title": "Eventual consistency",
        "top_image": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "meta_img": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/f/f2/Edit-clear.svg/40px-Edit-clear.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2005-04-18T00:48:40+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/Eventual_consistency",
        "text": "Consistency model used in distributed computing to achieve high availability\n\nEventual consistency is a consistency model used in distributed computing to achieve high availability that informally guarantees that, if no new updates are made to a given data item, eventually all accesses to that item will return the last updated value.[1] Eventual consistency, also called optimistic replication,[2] is widely deployed in distributed systems and has origins in early mobile computing projects.[3] A system that has achieved eventual consistency is often said to have converged, or achieved replica convergence.[4] Eventual consistency is a weak guarantee â€“ most stronger models, like linearizability, are trivially eventually consistent.\n\nEventually-consistent services are often classified as providing BASE semantics (basically-available, soft-state, eventual consistency), in contrast to traditional ACID (atomicity, consistency, isolation, durability).[5][6] In chemistry, a base is the opposite of an acid, which helps in remembering the acronym.[7] According to the same resource, these are the rough definitions of each term in BASE:\n\nBasically available: reading and writing operations are available as much as possible (using all nodes of a database cluster), but might not be consistent (the write might not persist after conflicts are reconciled, and the read might not get the latest write)\n\nSoft-state: without consistency guarantees, after some amount of time, we only have some probability of knowing the state, since it might not yet have converged\n\nEventually consistent: If we execute some writes and then the system functions long enough, we can know the state of the data; any further reads of that data item will return the same value\n\nEventual consistency is sometimes criticized[8] as increasing the complexity of distributed software applications. This is partly because eventual consistency is purely a liveness guarantee (reads eventually return the same value) and does not guarantee safety: an eventually consistent system can return any value before it converges.\n\nConflict resolution\n\n[edit]\n\nIn order to ensure replica convergence, a system must reconcile differences between multiple copies of distributed data. This consists of two parts:\n\nexchanging versions or updates of data between servers (often known as anti-entropy);[9] and\n\nchoosing an appropriate final state when concurrent updates have occurred, called reconciliation.\n\nThe most appropriate approach to reconciliation depends on the application. A widespread approach is \"last writer wins\".[1] Another is to invoke a user-specified conflict handler.[4] Timestamps and vector clocks are often used to detect concurrency between updates. Some people use \"first writer wins\" in situations where \"last writer wins\" is unacceptable.[10]\n\nReconciliation of concurrent writes must occur sometime before the next read, and can be scheduled at different instants:[3][11]\n\nRead repair: The correction is done when a read finds an inconsistency. This slows down the read operation.\n\nWrite repair: The correction takes place during a write operation, slowing down the write operation.\n\nAsynchronous repair: The correction is not part of a read or write operation.\n\nStrong eventual consistency\n\n[edit]\n\nWhereas eventual consistency is only a liveness guarantee (updates will be observed eventually), strong eventual consistency (SEC) adds the safety guarantee that any two nodes that have received the same (unordered) set of updates will be in the same state. If, furthermore, the system is monotonic, the application will never suffer rollbacks. A common approach to ensure SEC is conflict-free replicated data types.[12]\n\nSee also\n\n[edit]\n\nACID\n\nCAP theorem\n\nReferences\n\n[edit]\n\nFurther reading\n\n[edit]"
    }
}