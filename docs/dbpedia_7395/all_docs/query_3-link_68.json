{
    "id": "dbpedia_7395_3",
    "rank": 68,
    "data": {
        "url": "https://superuser.com/questions/12972/how-can-you-see-the-actual-hard-link-by-ls",
        "read_more_link": "",
        "language": "en",
        "title": "How can you see the actual hard link by ls?",
        "top_image": "https://cdn.sstatic.net/Sites/superuser/Img/apple-touch-icon@2.png?v=e869e4459439",
        "meta_img": "https://cdn.sstatic.net/Sites/superuser/Img/apple-touch-icon@2.png?v=e869e4459439",
        "images": [
            "https://cdn.sstatic.net/Sites/superuser/Img/logo.svg?v=4bc8a703ebac",
            "https://www.gravatar.com/avatar/ec198cb6fc38d98bb88dd390e0bed8e3?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/0VZ1V.png?s=64",
            "https://www.gravatar.com/avatar/101d0d120e66a378a0303c754e5f6073?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/tK3A3.jpg?s=64",
            "https://www.gravatar.com/avatar/af83d13281fbdd223b1d6ec8175c16a2?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/fa02b7e167326634588159f10682b517?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/17df7ff467bef1a81d4bf586548c88f2?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/N4ivW.png?s=64",
            "https://www.gravatar.com/avatar/8f37f83e6cd60e024b588ac3eb543060?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/XqOCC.png",
            "https://i.sstatic.net/9DqJ8.png?s=64",
            "https://www.gravatar.com/avatar/8f37f83e6cd60e024b588ac3eb543060?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/4ba6792909358469b10d420e640f892c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/78924423e11c5111e3b18a2cdda102e1?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a91dc0b6446b853d05272d8b5b46314e?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/VnFfE.jpg?s=64",
            "https://superuser.com/posts/12972/ivc/6e48?prg=4c45ff4a-67b1-47e5-aa6e-a531bc0d5ba8"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-07-25T09:41:26",
        "summary": "",
        "meta_description": "I run \n\nln /a/A /b/B\r\nI would like to see at the folder a where the file A points to by ls.",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/superuser/Img/favicon.ico?v=4852d6fb3f5d",
        "meta_site_name": "Super User",
        "canonical_link": "https://superuser.com/questions/12972/how-can-you-see-the-actual-hard-link-by-ls",
        "text": "There isn't really a well-defined answer to your question. Unlike symlinks, hardlinks are indistinguishable from the \"original file\".\n\nDirectory entries consist of a filename and a pointer to an inode. The inode in turn contains the file metadata and (pointers to) the actual file contents). Creating a hard link creates another directory entry that references the same inode. These references are unidirectional (in typical filesystems, at least) -- the inode only keeps a reference count. There is no intrinsic way to find out which is the \"original\" filename.\n\nBy the way, this is why the system call to \"delete\" a file is called unlink. It just removes a hardlink. The inode and attached data are deleted only if the inode's reference count drops to 0.\n\nThe only way to find the other references to a given inode is to exhaustively search over the file system checking which files refer to the inode in question. You can use 'test A -ef B' from the shell to perform this check.\n\nUNIX has hard links and symbolic links (made with \"ln\" and \"ln -s\" respectively). Symbolic links are simply a file that contains the real path to another file and can cross filesystems.\n\nHard links have been around since the earliest days of UNIX (that I can remember anyway, and that's going back quite a while). They are two directory entries that reference the exact same underlying data. The data in a file is specified by its inode. Each file on a file system points to an inode but there's no requirement that each file point to a unique inode - that's where hard links come from.\n\nSince inodes are unique only for a given filesystem, there's a limitation that hard links must be on the same filesystem (unlike symbolic links). Note that, unlike symbolic links, there is no privileged file - they are all equal. The data area will only be released when all the files using that inode are deleted (and all processes close it as well, but that's a different issue).\n\nYou can use the \"ls -i\" command to get the inode of a particular file. You can then use the \"find <filesystemroot> -inum <inode>\" command to find all files on the filesystem with that given inode.\n\nHere's a script which does exactly that. You invoke it with:\n\nfindhardlinks ~/jquery.js\n\nand it will find all files on that filesystem which are hard links for that file:\n\npax@daemonspawn:~# ./findhardlinks /home/pax/jquery.js Processing '/home/pax/jquery.js' '/home/pax/jquery.js' has inode 5211995 on mount point '/' /home/common/jquery-1.2.6.min.js /home/pax/jquery.js\n\nHere's the script.\n\n#!/bin/bash if [[ $# -lt 1 ]] ; then echo \"Usage: findhardlinks <fileOrDirToFindFor> ...\" exit 1 fi while [[ $# -ge 1 ]] ; do echo \"Processing '$1'\" if [[ ! -r \"$1\" ]] ; then echo \" '$1' is not accessible\" else numlinks=$(ls -ld \"$1\" | awk '{print $2}') inode=$(ls -id \"$1\" | awk '{print $1}' | head -1l) device=$(df \"$1\" | tail -1l | awk '{print $6}') echo \" '$1' has inode ${inode} on mount point '${device}'\" find ${device} -inum ${inode} 2>/dev/null | sed 's/^/ /' fi shift done\n\nThere are a lot of answers with scripts to find all hardlinks in a filesystem. Most of them do silly things like running find to scan the whole filesystem for -samefile for EACH multiply-linked file. This is crazy; all you need is to sort on inode number and print duplicates.\n\nWith only one pass over the filesystem to find and group all sets of hardlinked files\n\nfind dirs -xdev \\! -type d -links +1 -printf '%20D %20i %p\\n' | sort -n | uniq -w 42 --all-repeated=separate\n\nThis is much faster than the other answers for finding multiple sets of hardlinked files.\n\nfind /foo -samefile /bar is excellent for just one file.\n\n-xdev : limit to one filesystem. Not strictly needed since we also print the FS-id to uniq on\n\n! -type d reject directories: the . and .. entries mean they're always linked.\n\n-links +1 : link count strictly > 1\n\n-printf ... print FS-id, inode number, and path. (With padding to fixed column widths that we can tell uniq about.)\n\nsort -n | uniq ... numeric sort and uniquify on the first 42 columns, separating groups with a blank line\n\nUsing ! -type d -links +1 means that sort's input is only as big as the final output of uniq so we aren't doing a huge amount of string sorting. Unless you run it on a subdirectory that only contains one of a set of hardlinks. Anyway, this will use a LOT less CPU time re-traversing the filesystem than any other posted solution.\n\nsample output:\n\n... 2429 76732484 /home/peter/weird-filenames/test/.hiddendir/foo bar 2429 76732484 /home/peter/weird-filenames/test.orig/.hiddendir/foo bar 2430 17961006 /usr/bin/pkg-config.real 2430 17961006 /usr/bin/x86_64-pc-linux-gnu-pkg-config 2430 36646920 /usr/lib/i386-linux-gnu/dri/i915_dri.so 2430 36646920 /usr/lib/i386-linux-gnu/dri/i965_dri.so 2430 36646920 /usr/lib/i386-linux-gnu/dri/nouveau_vieux_dri.so 2430 36646920 /usr/lib/i386-linux-gnu/dri/r200_dri.so 2430 36646920 /usr/lib/i386-linux-gnu/dri/radeon_dri.so ...\n\nTODO?: un-pad the output with awk or cut. uniq has very limited field-selection support, so I pad the find output and use fixed-width. 20chars is wide enough for the maximum possible inode or device number (2^64-1 = 18446744073709551615). XFS chooses inode numbers based on where on disk they're allocated, not contiguously from 0, so large XFS filesystems can have >32bit inode numbers even if they don't have billions of files. Other filesystems might have 20-digit inode numbers even if they aren't gigantic.\n\nTODO: sort groups of duplicates by path. Having them sorted by mount point then inode number mixes things together, if you have a couple different subdirs that have lots of hardlinks. (i.e. groups of dup-groups go together, but the output mixes them up).\n\nA final sort -k 3 would sort lines separately, not groups of lines as a single record. Preprocessing with something to transform a pair of newlines into a NUL byte, and using GNU sort --zero-terminated -k 3 might do the trick. tr only operates on single characters, not 2->1 or 1->2 patterns, though. perl would do it (or just parse and sort within perl or awk). sed might also work.\n\nWhat are hardlinks, really?\n\nSymlinks are when one name points to another name. Hard links are when multiple names exist for the same file (inode); they all just refer to the inode, not each other.\n\nA directory entry is a string (name) and an inode number. So a filename effectively \"points to\" an inode. We call it \"hard linking\" when you have multiple names pointing to the same inode.\n\nWhen you make a hard link with ln, you specify two file names, but the newly created hard link just references the inode directly, not the filename or path. After a link(2) system call, there's no sense in which one is the original and one is the link.\n\nThis is why, as the answers point out, the only way to find all the links is find / -samefile /foo/bar to search the FS for one with the same inode number. One directory entry for an inode doesn't \"know about\" other directory entries for the same inode, and the inode itself doesn't have references back to dirents that point at it.\n\nThe inode only has a reference count. This lets the kernel delete it and free the disk space (for it and the file contents it points to) when the last name for it is unlink(2)ed (and the last open file descriptor is closed, and mmap is munmapped).\n\nThis is the \"link count\" in ls output."
    }
}