{
    "id": "dbpedia_7395_2",
    "rank": 16,
    "data": {
        "url": "https://docs.freebsd.org/en/books/handbook/basics/",
        "read_more_link": "",
        "language": "en",
        "title": "Chapter 3. FreeBSD Basics",
        "top_image": "https://docs.freebsd.org/favicon.ico",
        "meta_img": "https://docs.freebsd.org/favicon.ico",
        "images": [
            "https://docs.freebsd.org/images/FreeBSD-monochromatic.svg",
            "https://docs.freebsd.org/images/books/handbook/basics/example-dir1.png",
            "https://docs.freebsd.org/images/books/handbook/basics/example-dir2.png",
            "https://docs.freebsd.org/images/books/handbook/basics/example-dir3.png",
            "https://docs.freebsd.org/images/books/handbook/basics/example-dir4.png",
            "https://docs.freebsd.org/images/books/handbook/basics/example-dir5.png",
            "https://docs.freebsd.org/images/books/handbook/basics/disk-layout.png",
            "https://docs.freebsd.org/images/FreeBSD-colors.svg",
            "https://docs.freebsd.org/images/language.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "basics",
            "virtual consoles",
            "users",
            "management",
            "permissions",
            "directory structure",
            "disk organization",
            "mounting",
            "processes",
            "daemons",
            "shell",
            "editor",
            "manual pages",
            "devices"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Basic commands and functionality of the FreeBSD operating system",
        "meta_lang": "en",
        "meta_favicon": "https://docs.freebsd.org/favicon.ico",
        "meta_site_name": "FreeBSD Documentation Portal",
        "canonical_link": "https://docs.freebsd.org/en/books/handbook/basics/",
        "text": "Unless FreeBSD has been configured to automatically start a graphical environment during startup, the system will boot into a command line login prompt, as seen in this example:\n\nFreeBSD/amd64 (pc3.example.org) (ttyv0) login:\n\nThe first line contains some information about the system. The amd64 indicates that FreeBSD is running on a 64-bit x86 system. The hostname is pc3.example.org, and ttyv0 indicates that this is the \"system console\". The second line is the login prompt.\n\nSince FreeBSD is a multiuser system, it needs some way to distinguish between different users. This is accomplished by requiring every user to log into the system before gaining access to the programs on the system. Every user has a unique \"username\" and a personal \"password\".\n\nTo log into the system console, type the username that was configured during system installation, as described in Add Users, and press Enter. Then enter the password associated with the username and press Enter. The password is not echoed for security reasons.\n\nOnce the correct password is input, the message of the day (MOTD) will be displayed followed by a command prompt. Depending upon the shell that was selected when the user was created, this prompt will be a #, $, or % character. The prompt indicates that the user is now logged into the FreeBSD system console and ready to try the available commands.\n\n3.2.1. Virtual Consoles\n\nWhile the system console can be used to interact with the system, a user working from the command line at the keyboard of a FreeBSD system will typically instead log into a virtual console. This is because system messages are configured by default to display on the system console. These messages will appear over the command or file that the user is working on, making it difficult to concentrate on the work at hand.\n\nBy default, FreeBSD is configured to provide several virtual consoles for inputting commands. Each virtual console has its own login prompt and shell and it is easy to switch between virtual consoles. This essentially provides the command line equivalent of having several windows open at the same time in a graphical environment.\n\nThe key combinations Alt+F1 through Alt+F8 have been reserved by FreeBSD for switching between virtual consoles. Use Alt+F1 to switch to the system console (ttyv0), Alt+F2 to access the first virtual console (ttyv1), Alt+F3 to access the second virtual console (ttyv2), and so on. When using Xorg as a graphical console, the combination becomes Ctrl+Alt+F1 to return to a text-based virtual console.\n\nWhen switching from one console to the next, FreeBSD manages the screen output. The result is an illusion of having multiple virtual screens and keyboards that can be used to type commands for FreeBSD to run. The programs that are launched in one virtual console do not stop running when the user switches to a different virtual console.\n\nRefer to kbdcontrol(1), vidcontrol(1), atkbd(4), syscons(4), and vt(4) for a more technical description of the FreeBSD console and its keyboard drivers.\n\nIn FreeBSD, the number of available virtual consoles is configured in this section of /etc/ttys:\n\n# name getty type status comments # ttyv0 \"/usr/libexec/getty Pc\" xterm on secure # Virtual terminals ttyv1 \"/usr/libexec/getty Pc\" xterm on secure ttyv2 \"/usr/libexec/getty Pc\" xterm on secure ttyv3 \"/usr/libexec/getty Pc\" xterm on secure ttyv4 \"/usr/libexec/getty Pc\" xterm on secure ttyv5 \"/usr/libexec/getty Pc\" xterm on secure ttyv6 \"/usr/libexec/getty Pc\" xterm on secure ttyv7 \"/usr/libexec/getty Pc\" xterm on secure ttyv8 \"/usr/X11R6/bin/xdm -nodaemon\" xterm off secure\n\nTo disable a virtual console, put a comment symbol (#) at the beginning of the line representing that virtual console. For example, to reduce the number of available virtual consoles from eight to four, put a # in front of the last four lines representing virtual consoles ttyv5 through ttyv8. Do not comment out the line for the system console ttyv0. Note that the last virtual console (ttyv8) is used to access the graphical environment if Xorg has been installed and configured as described in The X Window System.\n\nFor a detailed description of every column in this file and the available options for the virtual consoles, refer to ttys(5).\n\n3.2.2. Single User Mode\n\nThe FreeBSD boot menu provides an option labelled as \"Boot Single User\". If this option is selected, the system will boot into a special mode known as \"single user mode\". This mode is typically used to repair a system that will not boot or to reset the root password when it is not known. While in single user mode, networking and other virtual consoles are not available. However, full root access to the system is available, and by default, the root password is not needed. For these reasons, physical access to the keyboard is needed to boot into this mode and determining who has physical access to the keyboard is something to consider when securing a FreeBSD system.\n\nThe settings which control single user mode are found in this section of /etc/ttys:\n\n# name getty type status comments # # If console is marked \"insecure\", then init will ask for the root password # when going to single-user mode. console none unknown off secure\n\nBy default, the status is set to secure. This assumes that who has physical access to the keyboard is either not important or it is controlled by a physical security policy. If this setting is changed to insecure, the assumption is that the environment itself is insecure because anyone can access the keyboard. When this line is changed to insecure, FreeBSD will prompt for the root password when a user selects to boot into single user mode.\n\n3.2.3. Changing Console Video Modes\n\nThe FreeBSD console default video mode may be adjusted to 1024x768, 1280x1024, or any other size supported by the graphics chip and monitor. To use a different video mode load the VESA module:\n\n# kldload vesa\n\nTo determine which video modes are supported by the hardware, use vidcontrol(1). To get a list of supported video modes issue the following:\n\n# vidcontrol -i mode\n\nThe output of this command lists the video modes that are supported by the hardware. To select a new video mode, specify the mode using vidcontrol(1) as the root user:\n\n# vidcontrol MODE_279\n\nIf the new video mode is acceptable, it can be permanently set on boot by adding it to /etc/rc.conf:\n\nallscreens_flags=\"MODE_279\"\n\nIn FreeBSD, every file and directory has an associated set of permissions and several utilities are available for viewing and modifying these permissions. Understanding how permissions work is necessary to make sure that users are able to access the files that they need and are unable to improperly access the files used by the operating system or owned by other users.\n\nThis section discusses the traditional UNIXÂ® permissions used in FreeBSD. For finer-grained file system access control, refer to Access Control Lists.\n\nIn UNIXÂ®, basic permissions are assigned using three types of access: read, write, and execute. These access types are used to determine file access to the fileâs owner, group, and others (everyone else). The read, write, and execute permissions can be represented as the letters r, w, and x. They can also be represented as binary numbers as each permission is either on or off (0). When represented as a number, the order is always read as rwx, where r has an on value of 4, w has an on value of 2 and x has an on value of 1.\n\nTable 4.1 summarizes the possible numeric and alphabetic possibilities. When reading the \"Directory Listing\" column, a - is used to represent a permission that is set to off.\n\nTable 2. UNIXÂ® PermissionsValuePermissionDirectory Listing\n\nUse the -l argument with ls(1) to view a long directory listing that includes a column of information about a fileâs permissions for the owner, group, and everyone else. For example, ls -l in an arbitrary directory may show:\n\n% ls -l\n\nThe output should be similar to the following:\n\ntotal 530 -rw-r--r-- 1 root wheel 512 Sep 5 12:31 myfile -rw-r--r-- 1 root wheel 512 Sep 5 12:31 otherfile -rw-r--r-- 1 root wheel 7680 Sep 5 12:31 email.txt\n\nFocusing on the line for myfile, the first (leftmost) character indicates whether this file is a regular file, a directory, a special character device, a socket, or any other special pseudo-file device. In this example, the - indicates a regular file. The next three characters, rw- in this example, give the permissions for the owner of the file. The next three characters, r--, give the permissions for the group that the file belongs to. The final three characters, r--, give the permissions for the rest of the world. A dash means that the permission is turned off. In this example, the permissions are set so the owner can read and write to the file, the group can read the file, and the rest of the world can only read the file. According to the table above, the permissions for this file would be 644, where each digit represents the three parts of the fileâs permission.\n\nHow does the system control permissions on devices? FreeBSD treats most hardware devices as a file that programs can open, read, and write data to. These special device files are stored in /dev/.\n\nDirectories are also treated as files. They have read, write, and execute permissions. The executable bit for a directory has a slightly different meaning than that of files. When a directory is marked executable, it means it is possible to change into that directory using cd(1). This also means that it is possible to access the files within that directory, subject to the permissions on the files themselves.\n\nIn order to perform a directory listing, the read permission must be set on the directory. In order to delete a file that one knows the name of, it is necessary to have write and execute permissions to the directory containing the file.\n\nThere are more permission bits, but they are primarily used in special circumstances such as setuid binaries and sticky directories. For more information on file permissions and how to set them, refer to chmod(1).\n\n3.4.1. Symbolic Permissions\n\nSymbolic permissions use characters instead of octal values to assign permissions to files or directories. Symbolic permissions use the syntax of (who) (action) (permissions), where the following values are available:\n\nOptionLetterRepresents\n\n(who)\n\nu\n\nUser\n\n(who)\n\ng\n\nGroup owner\n\n(who)\n\no\n\nOther\n\n(who)\n\na\n\nAll (\"world\")\n\n(action)\n\n+\n\nAdding permissions\n\n(action)\n\n-\n\nRemoving permissions\n\n(action)\n\n=\n\nExplicitly set permissions\n\n(permissions)\n\nr\n\nRead\n\n(permissions)\n\nw\n\nWrite\n\n(permissions)\n\nx\n\nExecute\n\n(permissions)\n\nt\n\nSticky bit\n\n(permissions)\n\ns\n\nSet UID or GID\n\nThese values are used with chmod(1), but with letters instead of numbers. For example, the following command would block both members of the group associated with FILE and all other users from accessing FILE:\n\n% chmod go= FILE\n\nA comma separated list can be provided when more than one set of changes to a file must be made. For example, the following command removes the group and \"world\" write permission on FILE, and adds the execute permissions for everyone:\n\n% chmod go-w,a+x FILE\n\n3.4.2. FreeBSD File Flags\n\nIn addition to file permissions, FreeBSD supports the use of \"file flags\". These flags add an additional level of security and control over files, but not directories. With file flags, even root can be prevented from removing or altering files.\n\nFile flags are modified using chflags(1). For example, to enable the system undeletable flag on the file file1, issue the following command:\n\n# chflags sunlink file1\n\nTo disable the system undeletable flag, put a \"no\" in front of the sunlink:\n\n# chflags nosunlink file1\n\nTo view the flags of a file, use -lo with ls(1):\n\n# ls -lo file1\n\n-rw-r--r-- 1 trhodes trhodes sunlnk 0 Mar 1 05:54 file1\n\nSeveral file flags may only be added or removed by the root user. In other cases, the file owner may set its file flags. Refer to chflags(1) and chflags(2) for more information.\n\n3.4.3. The setuid, setgid, and sticky Permissions\n\nOther than the permissions already discussed, there are three other specific settings that all administrators should know about. They are the setuid, setgid, and sticky permissions.\n\nThese settings are important for some UNIXÂ® operations as they provide functionality not normally granted to normal users. To understand them, the difference between the real user ID and effective user ID must be noted.\n\nThe real user ID is the UID who owns or starts the process. The effective UID is the user ID the process runs as. As an example, passwd(1) runs with the real user ID when a user changes their password. However, in order to update the password database, the command runs as the effective ID of the root user. This allows users to change their passwords without seeing a Permission Denied error.\n\nThe setuid permission may be added symbolically by adding the s permission for the user as in the following example:\n\n# chmod u+s suidexample.sh\n\nThe setuid permission may also be set by prefixing a permission set with the number four (4) as shown in the following example:\n\n# chmod 4755 suidexample.sh\n\nThe permissions on suidexample.sh now look like the following:\n\n-rwsr-xr-x 1 trhodes trhodes 63 Aug 29 06:36 suidexample.sh\n\nNote that a s is now part of the permission set designated for the file owner, replacing the executable bit. This allows utilities which need elevated permissions, such as passwd(1).\n\nTo view this in real time, open two terminals. On one, type passwd as a normal user. While it waits for a new password, check the process table and look at the user information for passwd(1):\n\nIn terminal A:\n\nChanging local password for trhodes Old Password:\n\nIn terminal B:\n\n# ps aux | grep passwd\n\ntrhodes 5232 0.0 0.2 3420 1608 0 R+ 2:10AM 0:00.00 grep passwd root 5211 0.0 0.2 3620 1724 2 I+ 2:09AM 0:00.01 passwd\n\nAlthough passwd(1) is run as a normal user, it is using the effective UID of root.\n\nThe setgid permission performs the same function as the setuid permission; except that it alters the group settings. When an application or utility executes with this setting, it will be granted the permissions based on the group that owns the file, not the user who started the process.\n\nTo set the setgid permission on a file symbolically, add the s permission for the group with chmod(1):\n\n# chmod g+s sgidexample.sh\n\nAlternatively, provide chmod(1) with a leading two (2):\n\n# chmod 2755 sgidexample.sh\n\nIn the following listing, notice that the s is now in the field designated for the group permission settings:\n\n-rwxr-sr-x 1 trhodes trhodes 44 Aug 31 01:49 sgidexample.sh\n\nThe setuid and setgid permission bits may lower system security, by allowing for elevated permissions. The third special permission, the sticky bit, can strengthen the security of a system.\n\nWhen the sticky bit is set on a directory, it allows file deletion only by the file owner. This is useful to prevent file deletion in public directories, such as /tmp, by users who do not own the file. To utilize this permission, add the t mode to the file:\n\n# chmod +t /tmp\n\nAlternatively, prefix the permission set with a one (1):\n\n# chmod 1777 /tmp\n\nThe sticky bit permission will display as a t at the very end of the permission set:\n\n# ls -al / | grep tmp\n\ndrwxrwxrwt 10 root wheel 512 Aug 31 01:49 tmp\n\nThe smallest unit of organization that FreeBSD uses to find files is the filename. Filenames are case-sensitive, which means that readme.txt and README.TXT are two separate files. FreeBSD does not use the extension of a file to determine whether the file is a program, document, or some other form of data.\n\nFiles are stored in directories. A directory may contain no files, or it may contain many hundreds of files. A directory can also contain other directories, allowing a hierarchy of directories within one another in order to organize data.\n\nFiles and directories are referenced by giving the file or directory name, followed by a forward slash, /, followed by any other directory names that are necessary. For example, if the directory foo contains a directory bar which contains the file readme.txt, the full name, or path, to the file is foo/bar/readme.txt. Note that this is different from WindowsÂ® which uses \\ to separate file and directory names. FreeBSD does not use drive letters, or other drive names in the path. For example, one would not type c:\\foo\\bar\\readme.txt on FreeBSD.\n\n3.6.1. File systems\n\nDirectories and files are stored in a file system. Each file system contains exactly one directory at the very top level, called the root directory for that file system. This root directory can contain other directories. One file system is designated the root file system or /. Every other file system is mounted under the root file system. No matter how many disks are on the FreeBSD system, every directory appears to be part of the same disk.\n\nConsider three file systems, called A, B, and C. Each file system has one root directory, which contains two other directories, called A1, A2 (and likewise B1, B2 and C1, C2).\n\nCall A the root file system. If ls(1) is used to view the contents of this directory, it will show two subdirectories, A1 and A2. The directory tree looks like this:\n\nA file system must be mounted on to a directory in another file system. When mounting file system B on to the directory A1, the root directory of B replaces A1, and the directories in B appear accordingly:\n\nAny files that are in the B1 or B2 directories can be reached with the path /A1/B1 or /A1/B2 as necessary. Any files that were in /A1 have been temporarily hidden. They will reappear if B is unmounted from A.\n\nIf B had been mounted on A2 then the diagram would look like this:\n\nand the paths would be /A2/B1 and /A2/B2 respectively.\n\nFile systems can be mounted on top of one another. Continuing the last example, the C file system could be mounted on top of the B1 directory in the B file system, leading to this arrangement:\n\nOr C could be mounted directly on to the A file system, under the A1 directory:\n\nIt is entirely possible to have one large root file system, and not need to create any others. There are some drawbacks to this approach, and one advantage.\n\nBenefits of Multiple File Systems\n\nDifferent file systems can have different mount options. For example, the root file system can be mounted read-only, making it impossible for users to inadvertently delete or edit a critical file. Separating user-writable file systems, such as /home, from other file systems allows them to be mounted nosuid. This option prevents the suid/guid bits on executables stored on the file system from taking effect, possibly improving security.\n\nFreeBSD automatically optimizes the layout of files on a file system, depending on how the file system is being used. So a file system that contains many small files that are written frequently will have a different optimization to one that contains fewer, larger files. By having one big file system this optimization breaks down.\n\nFreeBSDâs file systems are robust if power is lost. However, a power loss at a critical point could still damage the structure of the file system. By splitting data over multiple file systems it is more likely that the system will still come up, making it easier to restore from backup as necessary.\n\nBenefit of a Single File System\n\nFile systems are a fixed size. If you create a file system when you install FreeBSD and give it a specific size, you may later discover that you need to make the partition bigger. This is not easily accomplished without backing up, recreating the file system with the new size, and then restoring the backed up data.\n\n3.6.2. Disk partitions\n\nFile systems are contained in partitions. Disks are divided into partitions using one of several partitioning schemes; see [bsdinstall-part-manual]. The newer scheme is GPT; older BIOS-based computers use MBR. GPT supports division of a disk into partitions with a size, offset, and type. It supports a large number of partitions and partition types, and is recommended whenever its use is possible. GPT partitions use the disk name with a suffix, where the suffix is p1 for the first partition, p2 for the second, and so on. MBR, however, supports only a small number of partitions. The MBR partitions are known in FreeBSD as slices. Slices may be used for different operating systems. FreeBSD slices are subdivided into partitions using BSD labels (see bsdlabel(8)).\n\nSlice numbers follow the device name, prefixed with an s, starting at 1. So \"da0s1\" is the first slice on the first SCSI drive. There can only be four physical slices on a disk, but there can be logical slices inside physical slices of the appropriate type. These extended slices are numbered starting at 5, so \"ada0s5\" is the first extended slice on the first SATA disk. These devices are used by file systems that expect to occupy a slice.\n\nEach GPT or BSD partition can contain only one file system, which means that file systems are often described by either their typical mount point in the file system hierarchy, or the name of the partition they are contained in.\n\nFreeBSD also uses disk space for swap space to provide virtual memory. This allows your computer to behave as though it has much more memory than it actually does. When FreeBSD runs out of memory, it moves some of the data that is not currently being used to the swap space, and moves it back in (moving something else out) when it needs it. This is called paging.\n\nSome BSD partitions have certain conventions associated with them.\n\nSlices and \"dangerously dedicated\" physical drives contain BSD partitions, which are represented as letters from a to h. This letter is appended to the device name, so \"da0a\" is the a partition on the first da drive, which is \"dangerously dedicated\". \"ada1s3e\" is the fifth partition in the third slice of the second SATA disk drive.\n\nFinally, each disk on the system is identified. A disk name starts with a code that indicates the type of disk, and then a number, indicating which disk it is. Unlike partitions and slices, disk numbering starts at 0. Common codes are listed in Disk Device Names.\n\nWhen referring to a partition in a slice, include the disk name, s, the slice number, and then the partition letter. Examples are shown in Sample Disk, Slice, and Partition Names. GPT partitions include the disk name, p, and then the partition number.\n\nConceptual Model of a Disk shows a conceptual model of a disk layout using MBR slices.\n\nWhen installing FreeBSD, configure the disk slices if using MBR, and create partitions within the slice to be used for FreeBSD. If using GPT, configure partitions for each file system. In either case, create a file system or swap space in each partition, and decide where each file system will be mounted. See gpart(8) for information on manipulating partitions.\n\nTable 3. Disk Device NamesDrive TypeDrive Device Name\n\nTable 4. Sample Disk, Slice, and Partition NamesNameMeaning\n\nFreeBSD is a multi-tasking operating system. Each program running at any one time is called a process. Every running command starts at least one new process and there are a number of system processes that are run by FreeBSD.\n\nEach process is uniquely identified by a number called a process ID (PID). Similar to files, each process has one owner and group, and the owner and group permissions are used to determine which files and devices the process can open. Most processes also have a parent process that started them. For example, the shell is a process, and any command started in the shell is a process which has the shell as its parent process. The exception is a special process called init(8) which is always the first process to start at boot time and which always has a PID of 1.\n\nSome programs are not designed to be run with continuous user input and disconnect from the terminal at the first opportunity. For example, a web server responds to web requests, rather than user input. Mail servers are another example of this type of application. These types of programs are known as daemons. The term daemon comes from Greek mythology and represents an entity that is neither good nor evil, and which invisibly performs useful tasks. This is why the BSD mascot is the cheerful-looking daemon with sneakers and a pitchfork.\n\nThere is a convention to name programs that normally run as daemons with a trailing \"d\". For example, BIND is the Berkeley Internet Name Domain, but the actual program that executes is named. The Apache web server program is httpd and the line printer spooling daemon is lpd. This is only a naming convention. For example, the main mail daemon for the Sendmail application is sendmail, and not maild.\n\n3.8.1. Viewing Processes\n\nTo see the processes running on the system, use ps(1) or top(1). To display a static list of the currently running processes, their PIDs, how much memory they are using, and the command they were started with, use ps(1). To display all the running processes and update the display every few seconds in order to interactively see what the computer is doing, use top(1).\n\nBy default, ps(1) only shows the commands that are running and owned by the user. For example:\n\n% ps\n\nThe output should be similar to the following:\n\nPID TT STAT TIME COMMAND 8203 0 Ss 0:00.59 /bin/csh 8895 0 R+ 0:00.00 ps\n\nThe output from ps(1) is organized into a number of columns. The PID column displays the process ID. PIDs are assigned starting at 1, go up to 99999, then wrap around back to the beginning. However, a PID is not reassigned if it is already in use. The TT column shows the tty the program is running on and STAT shows the programâs state. TIME is the amount of time the program has been running on the CPU. This is usually not the elapsed time since the program was started, as most programs spend a lot of time waiting for things to happen before they need to spend time on the CPU. Finally, COMMAND is the command that was used to start the program.\n\nA number of different options are available to change the information that is displayed. One of the most useful sets is auxww, where a displays information about all the running processes of all users, u displays the username and memory usage of the process' owner, x displays information about daemon processes, and ww causes ps(1) to display the full command line for each process, rather than truncating it once it gets too long to fit on the screen.\n\nThe output from top(1) is similar:\n\n% top\n\nThe output should be similar to the following:\n\nlast pid: 9609; load averages: 0.56, 0.45, 0.36 up 0+00:20:03 10:21:46 107 processes: 2 running, 104 sleeping, 1 zombie CPU: 6.2% user, 0.1% nice, 8.2% system, 0.4% interrupt, 85.1% idle Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other Swap: 2048M Total, 2048M Free PID USERNAME THR PRI NICE SIZE RES STATE C TIME WCPU COMMAND 557 root 1 -21 r31 136M 42296K select 0 2:20 9.96% Xorg 8198 dru 2 52 0 449M 82736K select 3 0:08 5.96% kdeinit4 8311 dru 27 30 0 1150M 187M uwait 1 1:37 0.98% firefox 431 root 1 20 0 14268K 1728K select 0 0:06 0.98% moused 9551 dru 1 21 0 16600K 2660K CPU3 3 0:01 0.98% top 2357 dru 4 37 0 718M 141M select 0 0:21 0.00% kdeinit4 8705 dru 4 35 0 480M 98M select 2 0:20 0.00% kdeinit4 8076 dru 6 20 0 552M 113M uwait 0 0:12 0.00% soffice.bin 2623 root 1 30 10 12088K 1636K select 3 0:09 0.00% powerd 2338 dru 1 20 0 440M 84532K select 1 0:06 0.00% kwin 1427 dru 5 22 0 605M 86412K select 1 0:05 0.00% kdeinit4\n\nThe output is split into two sections. The header (the first five or six lines) shows the PID of the last process to run, the system load averages (which are a measure of how busy the system is), the system uptime (time since the last reboot) and the current time. The other figures in the header relate to how many processes are running, how much memory and swap space has been used, and how much time the system is spending in different CPU states. If the ZFS file system module has been loaded, an ARC line indicates how much data was read from the memory cache instead of from disk.\n\nBelow the header is a series of columns containing similar information to the output from ps(1), such as the PID, username, amount of CPU time, and the command that started the process. By default, top(1) also displays the amount of memory space taken by the process. This is split into two columns: one for total size and one for resident size. Total size is how much memory the application has needed and the resident size is how much it is actually using now.\n\ntop(1) automatically updates the display every two seconds. A different interval can be specified with -s.\n\n3.8.2. Killing Processes\n\nOne way to communicate with any running process or daemon is to send a signal using kill(1). There are a number of different signals; some have a specific meaning while others are described in the applicationâs documentation. A user can only send a signal to a process they own and sending a signal to someone elseâs process will result in a permission denied error. The exception is the root user, who can send signals to anyoneâs processes.\n\nThe operating system can also send a signal to a process. If an application is badly written and tries to access memory that it is not supposed to, FreeBSD will send the process the \"Segmentation Violation\" signal (SIGSEGV). If an application has been written to use the alarm(3) system call to be alerted after a period of time has elapsed, it will be sent the \"Alarm\" signal (SIGALRM).\n\nTwo signals can be used to stop a process: SIGTERM and SIGKILL. SIGTERM is the polite way to kill a process as the process can read the signal, close any log files it may have open, and attempt to finish what it is doing before shutting down. In some cases, a process may ignore SIGTERM if it is in the middle of some task that cannot be interrupted.\n\nSIGKILL cannot be ignored by a process. Sending a SIGKILL to a process will usually stop that process there and then. .\n\nOther commonly used signals are SIGHUP, SIGUSR1, and SIGUSR2. Since these are general purpose signals, different applications will respond differently.\n\nFor example, after changing a web serverâs configuration file, the web server needs to be told to re-read its configuration. Restarting httpd would result in a brief outage period on the web server. Instead, send the daemon the SIGHUP signal. Be aware that different daemons will have different behavior, so refer to the documentation for the daemon to determine if SIGHUP will achieve the desired results.\n\nA shell provides a command line interface for interacting with the operating system. A shell receives commands from the input channel and executes them. Many shells provide built in functions to help with everyday tasks such as file management, file globbing, command line editing, command macros, and environment variables. FreeBSD comes with several shells, including the Bourne shell (sh(1)) and the extended C shell (tcsh(1)). Other shells are available from the FreeBSD Ports Collection, such as zsh and bash.\n\nThe shell that is used is really a matter of taste. A C programmer might feel more comfortable with a C-like shell such as tcsh(1). A LinuxÂ® user might prefer bash. Each shell has unique properties that may or may not work with a userâs preferred working environment, which is why there is a choice of which shell to use.\n\nOne common shell feature is filename completion. After a user types the first few letters of a command or filename and presses Tab, the shell completes the rest of the command or filename. Consider two files called foobar and football. To delete foobar, the user might type rm foo and press Tab to complete the filename.\n\nBut the shell only shows rm foo. It was unable to complete the filename because both foobar and football start with foo. Some shells sound a beep or show all the choices if more than one name matches. The user must then type more characters to identify the desired filename. Typing a t and pressing Tab again is enough to let the shell determine which filename is desired and fill in the rest.\n\nAnother feature of the shell is the use of environment variables. Environment variables are a variable/key pair stored in the shellâs environment. This environment can be read by any program invoked by the shell, and thus contains a lot of program configuration. Common Environment Variables provides a list of common environment variables and their meanings. Note that the names of environment variables are always in uppercase.\n\nTable 5. Common Environment Variables\n\nHow to set an environment variable differs between shells. In tcsh(1) and csh(1), use setenv to set environment variables. In sh(1) and bash, use export to set the current environment variables. This example sets the default EDITOR to /usr/local/bin/emacs for the tcsh(1) shell:\n\n% setenv EDITOR /usr/local/bin/emacs\n\nThe equivalent command for bash would be:\n\n% export EDITOR=\"/usr/local/bin/emacs\"\n\nTo expand an environment variable in order to see its current setting, type a $ character in front of its name on the command line. For example, echo $TERM displays the current $TERM setting.\n\nShells treat special characters, known as meta-characters, as special representations of data. The most common meta-character is *, which represents any number of characters in a filename. Meta-characters can be used to perform filename globbing. For example, echo * is equivalent to ls because the shell takes all the files that match * and echo lists them on the command line.\n\nTo prevent the shell from interpreting a special character, escape it from the shell by starting it with a backslash (\\). For example, echo $TERM prints the terminal setting whereas echo \\$TERM literally prints the string $TERM.\n\n3.9.1. Changing the Shell\n\nThe easiest way to permanently change the default shell is to use chsh. Running this command will open the editor that is configured in the EDITOR environment variable, which by default is set to vi(1). Change the Shell: line to the full path of the new shell.\n\nAlternately, use chsh -s which will set the specified shell without opening an editor. For example, to change the shell to bash:\n\n% chsh -s /usr/local/bin/bash\n\nEnter your password at the prompt and press Return to change your shell. Log off and log in again to start using the new shell.\n\n3.9.2. Advanced Shell Techniques\n\nThe UNIXÂ® shell is not just a command interpreter, it acts as a powerful tool which allows users to execute commands, redirect their output, redirect their input and chain commands together to improve the final command output. When this functionality is mixed with built in commands, the user is provided with an environment that can maximize efficiency.\n\nShell redirection is the action of sending the output or the input of a command into another command or into a file. To capture the output of the ls(1) command, for example, into a file, redirect the output:\n\n% ls > directory_listing.txt\n\nThe directory contents will now be listed in directory_listing.txt. Some commands can be used to read input, such as sort(1). To sort this listing, redirect the input:\n\n% sort < directory_listing.txt\n\nThe input will be sorted and placed on the screen. To redirect that input into another file, one could redirect the output of sort(1) by mixing the direction:\n\n% sort < directory_listing.txt > sorted.txt\n\nIn all of the previous examples, the commands are performing redirection using file descriptors. Every UNIXÂ® system has file descriptors, which include standard input (stdin), standard output (stdout), and standard error (stderr). Each one has a purpose, where input could be a keyboard or a mouse, something that provides input. Output could be a screen or paper in a printer. And error would be anything that is used for diagnostic or error messages. All three are considered I/O based file descriptors and sometimes considered streams.\n\nThrough the use of these descriptors, the shell allows output and input to be passed around through various commands and redirected to or from a file. Another method of redirection is the pipe operator.\n\nThe UNIXÂ® pipe operator, \"|\" allows the output of one command to be directly passed or directed to another program. Basically, a pipe allows the standard output of a command to be passed as standard input to another command, for example:\n\n% cat directory_listing.txt | sort | less\n\nIn that example, the contents of directory_listing.txt will be sorted and the output passed to less(1). This allows the user to scroll through the output at their own pace and prevent it from scrolling off the screen.\n\nMost FreeBSD configuration is done by editing text files, so it is a good idea to become familiar with a text editor. FreeBSD comes with a few as part of the base system, and many more are available in the Ports Collection.\n\nA simple editor to learn is ee(1), which stands for easy editor. To start this editor, type ee filename where filename is the name of the file to be edited. Once inside the editor, all of the commands for manipulating the editorâs functions are listed at the top of the display. The caret (^) represents Ctrl, so ^e expands to Ctrl+e. To leave ee(1), press Esc, then choose the \"leave editor\" option from the main menu. The editor will prompt to save any changes if the file has been modified.\n\nFreeBSD also comes with more powerful text editors, such as vi(1), as part of the base system. Other editors, like editors/emacs and editors/vim, are part of the FreeBSD Ports Collection. These editors offer more functionality at the expense of being more complicated to learn. Learning a more powerful editor such as vim or Emacs can save more time in the long run.\n\nMany applications which modify files or require typed input will automatically open a text editor. To change the default editor, set the EDITOR environment variable as described in Shells.\n\nThe most comprehensive documentation on FreeBSD is in the form of manual pages. Nearly every program on the system comes with a short reference manual explaining the basic operation and available arguments. These manuals can be viewed using man:\n\n% man command\n\nwhere command is the name of the command to learn about. For example, to learn more about ls(1), type:\n\n% man ls\n\nManual pages are divided into sections which represent the type of topic. In FreeBSD, the following sections are available:\n\nUser commands.\n\nSystem calls and error numbers.\n\nFunctions in the C libraries.\n\nDevice drivers.\n\nFile formats.\n\nGames and other diversions.\n\nMiscellaneous information.\n\nSystem maintenance and operation commands.\n\nSystem kernel interfaces.\n\nIn some cases, the same topic may appear in more than one section of the online manual. For example, there is a chmod user command and a chmod() system call. To tell man(1) which section to display, specify the section number:\n\n% man 1 chmod\n\nThis will display the manual page for the user command chmod(1). References to a particular section of the online manual are traditionally placed in parenthesis in written documentation, so chmod(1) refers to the user command and chmod(2) refers to the system call.\n\nIf the name of the manual page is unknown, use man -k to search for keywords in the manual page descriptions:\n\n% man -k mail\n\nThis command displays a list of commands that have the keyword \"mail\" in their descriptions. This is equivalent to using apropos(1).\n\nTo read the descriptions for all of the commands in /usr/sbin, type:\n\n% cd /usr/sbin % man -f * | more\n\nor\n\n% cd /usr/sbin % whatis * |more\n\n3.12.1. GNU Info Files\n\nFreeBSD includes several applications and utilities produced by the Free Software Foundation (FSF). In addition to manual pages, these programs may include hypertext documents called info files. These can be viewed using info(1) or, if editors/emacs is installed, the info mode of emacs.\n\nTo use info(1), type:\n\n% info\n\nFor a brief introduction, type h. For a quick command reference, type ?."
    }
}