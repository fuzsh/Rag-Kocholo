{
    "id": "dbpedia_152_2",
    "rank": 43,
    "data": {
        "url": "https://e2e.ti.com/support/wireless-connectivity/other-wireless-group/other-wireless/f/other-wireless-technologies-forum/504681/trf7970a-sloc297-nxp-nt3h2211",
        "read_more_link": "",
        "language": "en",
        "title": "TRF7970A + SLOC297 + NXP NT3H2211",
        "top_image": "https://e2e.ti.com:443/cfs-file/__key/themefiles/tc-s-3fc3f82483d14ec485ef92e206116d49-00000000000000000000000000000000-favicon/tiicon.gif",
        "meta_img": "https://e2e.ti.com:443/cfs-file/__key/themefiles/tc-s-3fc3f82483d14ec485ef92e206116d49-00000000000000000000000000000000-favicon/tiicon.gif",
        "images": [
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/widgetcontainerfiles-3fc3f82483d14ec485ef92e206116d49-s-AAAAAAAAAAAAAAAAAAAAAA-header-header-dXWTWF6YJkCKrTvaFFZaDQ-logo/ic_2D00_logo.png_2D00_250x88.png_2D00_250x88.png?_=638278900268803910",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-groupavatars_2E00_/default.png_2D00_68x68x2.png?_=638256304222205490",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_32x32x2.png?_=638256251478916720",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/widgetfiles/95bd25baf0724cf2af03a74ebd4a607a-d/communitymember.gif?_=638373014223297770",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-18-96-15/4TYCXULA6UUZ.jpg_2D00_28x28x2.jpg?_=638279112426299670",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-01-39-08/4TIMJGJRRKKE.jpg_2D00_28x28x2.jpg?_=638279863483917940",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-01-39-08/4TIMJGJRRKKE.jpg_2D00_28x28x2.jpg?_=638279863483917940",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/filetypeimages_2E00_/pdf.png_2D00_1230x0.png?_=638257779767546420",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-01-39-08/4TIMJGJRRKKE.jpg_2D00_28x28x2.jpg?_=638279863483917940",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-01-39-08/4TIMJGJRRKKE.jpg_2D00_28x28x2.jpg?_=638279863483917940",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-18-96-15/4TYCXULA6UUZ.jpg_2D00_28x28x2.jpg?_=638279112426299670",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-18-96-15/4TYCXULA6UUZ.jpg_2D00_28x28x2.jpg?_=638279112426299670",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-18-96-15/4TYCXULA6UUZ.jpg_2D00_28x28x2.jpg?_=638279112426299670",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-18-96-15/4TYCXULA6UUZ.jpg_2D00_28x28x2.jpg?_=638279112426299670",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-18-96-15/4TYCXULA6UUZ.jpg_2D00_28x28x2.jpg?_=638279112426299670",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-18-96-15/4TYCXULA6UUZ.jpg_2D00_28x28x2.jpg?_=638279112426299670",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-18-96-15/4TYCXULA6UUZ.jpg_2D00_28x28x2.jpg?_=638279112426299670",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars-00-00-18-96-15/4TYCXULA6UUZ.jpg_2D00_28x28x2.jpg?_=638279112426299670",
            "https://e2e.ti.com:443/cfs-filesystemfile/__key/communityserver-components-imagefileviewer/communityserver-components-avatars_2E00_/default.png_2D00_28x28x2.png?_=638256308571005130"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "msp430g2553",
            "TRF7970A",
            "NT3H2211"
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2016-04-09T16:24:02.987000+00:00",
        "summary": "",
        "meta_description": "Other Parts Discussed in Thread: MSP430G2553 , TRF7970A , TRF7960A , TRF7960 , DLP-7970ABP Have been successfully using the MSP430G2553 launchpad in conjunction",
        "meta_lang": "en",
        "meta_favicon": "https://e2e.ti.com:443/cfs-file/__key/themefiles/tc-s-3fc3f82483d14ec485ef92e206116d49-00000000000000000000000000000000-favicon/tiicon.gif",
        "meta_site_name": "",
        "canonical_link": "https://e2e.ti.com/support/wireless-connectivity/other-wireless-group/other-wireless/f/other-wireless-technologies-forum/504681/trf7970a-sloc297-nxp-nt3h2211",
        "text": "Hi Karl,\n\nI don't have that particular tag in hand so I can't test with it directly right now. But I'll look into using some other NTAG's and sending erroneous commands in order to trigger the ACK/NAK and see how those are being reported back to the TRF7970A and how the driver handles it. It is possible that an extra case has to be added to the TRF driver to handle the case where the special function register is set for the 4 bit receives. Thanks for bringing this up, I will look into that behavior over the next week and see what needs to be done to allow for ACK's/NAK's to be properly handled in both the ISO14443a layer and the TRF driver. I'll keep you posted as I find out more.\n\nAlso good catch on the 0x88, you are right that it needs to be used in order to get ACK's and NAK's back. Looks like that needs to be modified with the Type 2 Read Block function to set that instead of 0x08.\n\nI appreciate that. My question is around accessing those actual ACK/NAK values. From NFCLink, it's clear that the capability is there:\n\nTransmitted PDU size: 6 bytes, data:\n\nA2 10 AB CD EF BB\n\nReceived PDU size: 1 bytes, data:\n\nA0\n\nMy question is actually from the G2553 code. That code does not inherently have write support. After adding support modeled after the exiting methods, and disabling the CRC checking for a WRITE/ FAST_WRITE operation with the tag, I am able to pass the requests back and forth as well as receive an RX_COMPLETE from the trf797x.c::Trf797xISR\n\nThe origin of my question is what needs to be set to receive the ACK/NAK values in the receive buffer. When I examine the g_ui8TrfBuffer for the ACK/NAK value, it is not present. There are just residual data bytes from prior operations.\n\nI have also attempted to set the special function register (0x10) BIT2 with the impression that this was needed to have the ACK/NAK values in the buffer. Instead it causes the Trf797xISR to treat the response as an error. The reason I'm seeking them is because I need to key off of specific NAK values that may be returned.\n\nIf this is explained elsewhere, then I have missed it. I had reviewed the powerpoint presentation at http://e2e.ti.com/cfs-file.ashx/__key/communityserver-discussions-components-files/667/3365.NFC-Forum-Type-2-Tag-Platform-Operations-with-TRF7970A_5F00_02_5F00_18_5F00_2014.pdf and followed the slide titled \"Writing Data / Formatting NFC Forum Type 2 Tag Platform\". The saleae logic traces show exactly what I was hoping to see appear in the return buffer.\n\nAt this point I've had little success in making this work with the NT3H2211 or even an NTAG203 using the G2553 sample code. Any assistance would be greatly appreciated.\n\nKarl\n\nHi Karl,\n\nSorry I hadn't gotten back to you yet, but I haven't yet had a chance to work on this on my end either. I plan to do so this week.\n\nI believe, as Josh alluded to in his last post, the primary change needed is the TRF7970A IRQ Handler in order to handle the negative cases not as an error but as an accepted response and then to ensure that the 4 bit value is properly stored inside of the buffer and not discarded.\n\nMy suspicion is that in the G2553, either the code to handle broken bits for anticollision does not translate to handling the 4 bit ACK/NAK replies, or some procedural in the RX_COMPLETE case needs to be tweaked. Once I get a chance to get an LSA capture to see what sort of IRQ is reported back to the TRF7970A, then it should be clearer what needs to be done - but I think those are the two most likely cases.\n\nDid you ever get a chance to sniff the TRF7970A SPI lines and see what IRQ value is given in 4 bit mode?\n\nThe WRITE conditions are working fine with SFR BIT2 set, which is great.\n\nThe READ conditions with the SFR (0x10) BIT2 set seem to be where the issue arises with the G2553 code. I had a trace at one point, but I apologize I have discarded it. The IRQ Status (0x0C) does have BIT4 and BIT6 set under the conditions of performing a READ operation on a Type2 tag with SFR (0x10) BIT2 set. (Whether it is an error or not).\n\nCurrently that is treated as a protocol error. In the type2.c from the TRF7970A firmware Josh provided, this similar clause in the interrupt handler was dealt with by not discarding the byte and placing it in reserved location at buf[200].\n\nI believe there may be some other changes needed, however, as this was not enough to resolve the issue alone in the G2553 code, and new data was not being populated into the receive buffer.\n\nI thought I had understood from Josh that during the READ conditions, one would actually not set SFR (0x10) BIT 2, and instead supplement the application with code to prevent the issue (if possible) and/or deal with negative cases as an error instead. If I misunderstood, I apologize.\n\nThanks, Karl\n\nHi Karl,\n\nSo I don't have your particular NXP tag in hand right now, but I worked with the NTAG213 and put together some ACK/NAK handling based on that. It should translate just fine for your own tag.\n\nSeems like no TRF driver changes are required at all though. The key was to enable the 4 bit RX and RX without CRC on. With these two settings, the TRF7970A reports back a 0x40 for all tag WRITE replies. I got no errors and since the TRF7970A registered the bits coming in from the RX_COMPLETE case, the buffer already had the data setup. That made things pretty easy in the end actually :)\n\nHere are the updated Type 2 Read and Write functions based on the G2553 code base:\n\n4201.Type_2_functions_4bit_RX.c\n\nuint8_t Iso14443a_Type2Read4Blocks(uint8_t ui8StartBlock) { uint8_t ui8Offset = 0; uint8_t ui8Status = STATUS_FAIL; #ifdef ENABLE_HOST uint8_t ui8LoopCount1 = 1; uint8_t ui8LoopCount2 = 0; #endif if (Trf797xGetIsoControlValue() != 0x88) { // Trf797x has not been properly configured for ISO14443A Trf797xWriteIsoControl(0x88); // Configure the TRF797x for ISO14443A @ 106kbps and Receive without CRC } if (Trf797xCheckRfField() == false) { // RF field is not enabled, VICC will not receive the command Trf797xTurnRfOn(); // Ensure TRF797x is outputting an RF Field // When a PICC is exposed to an unmodulated operating field // it shall be able to accept a quest within 5 ms. // PCDs should periodically present an unmodulated field of at least // 5.1 ms duration. (ISO14443-3) McuDelayMillisecond(6); } g_ui8TrfBuffer[ui8Offset++] = 0x8F; // Reset FIFO g_ui8TrfBuffer[ui8Offset++] = 0x91; // Send with CRC g_ui8TrfBuffer[ui8Offset++] = 0x3D; // Write Continuous g_ui8TrfBuffer[ui8Offset++] = 0x00; // Length of packet in bytes - upper and middle nibbles of transmit byte length g_ui8TrfBuffer[ui8Offset++] = 0x20; // Length of packet in bytes - lower and broken nibbles of transmit byte length g_ui8TrfBuffer[ui8Offset++] = 0x30; // Read Command g_ui8TrfBuffer[ui8Offset++] = ui8StartBlock; // Starting from Block # (called Bno) Trf797xRawWrite(&g_ui8TrfBuffer[0], ui8Offset); // Issue the Type 2 Read Command Trf797xIrqWaitTimeout(5,30); // 5 millisecond TX timeout, 30 millisecond RX timeout g_sTrfStatus = Trf797xGetTrfStatus(); if(g_sTrfStatus == RX_COMPLETE) // If block data has been received { if (Trf797xGetRxBytesReceived() > 0) { ui8Status = STATUS_SUCCESS; // Mark tag has been successfully read #ifdef ENABLE_HOST for(ui8LoopCount2 = 0; ui8LoopCount2 < 4; ui8LoopCount2++) { UartSendCString(\"Block \"); UartPutByte(ui8StartBlock++); UartSendCString(\": [\"); for(ui8LoopCount1 = (ui8LoopCount2*4); ui8LoopCount1 < 4+(ui8LoopCount2*4); ui8LoopCount1++) { UartPutByte(g_ui8TrfBuffer[ui8LoopCount1]); // Print out the received data } UartPutChar(']'); UartPutNewLine(); } #endif } else { #ifdef ENABLE_HOST UartSendCString(\"Read Fail\"); UartPutNewLine(); #endif } } else { // Otherwise return a fail ui8Status = STATUS_FAIL; } return ui8Status; } uint8_t Iso14443a_Type2WriteSingleBlock(uint8_t ui8StartBlock, uint8_t * pui8TagData) { uint8_t ui8Offset = 0; uint8_t ui8Status = STATUS_FAIL; uint8_t pui8TrfConfig[2]; uint8_t ui8TagResp; if (ui8StartBlock < 4) { // Attempt to write OTP blocks, do not allow // * This can be removed by experienced users who understand // that they can permanently break a tag by using this incorrectly return ui8Status; } // Read Register 0x10 - Special Functions Register pui8TrfConfig[1] = TRF797x_SPECIAL_FUNCTION_1; Trf797xReadSingle(&pui8TrfConfig[1]); // Set Bit 2 in Special Functions Register to 1 pui8TrfConfig[0] = TRF797x_SPECIAL_FUNCTION_1; pui8TrfConfig[1] |= 0x04; // Turn on 4-bit receive for ACK/NAK replies Trf797xWriteSingle(pui8TrfConfig); if (Trf797xGetIsoControlValue() != 0x88) { // Trf797x has not been properly configured for ISO14443A Trf797xWriteIsoControl(0x88); // Configure the TRF797x for ISO14443A @ 106kbps and Receive without CRC } if (Trf797xCheckRfField() == false) { // RF field is not enabled, VICC will not receive the command Trf797xTurnRfOn(); // Ensure TRF797x is outputting an RF Field // When a PICC is exposed to an unmodulated operating field // it shall be able to accept a quest within 5 ms. // PCDs should periodically present an unmodulated field of at least // 5.1 ms duration. (ISO14443-3) McuDelayMillisecond(6); } g_ui8TrfBuffer[ui8Offset++] = 0x8F; // Reset FIFO g_ui8TrfBuffer[ui8Offset++] = 0x91; // Send with CRC g_ui8TrfBuffer[ui8Offset++] = 0x3D; // Write Continuous g_ui8TrfBuffer[ui8Offset++] = 0x00; // Length of packet in bytes - upper and middle nibbles of transmit byte length g_ui8TrfBuffer[ui8Offset++] = 0x60; // Length of packet in bytes - lower and broken nibbles of transmit byte length g_ui8TrfBuffer[ui8Offset++] = 0xA2; // Write Command g_ui8TrfBuffer[ui8Offset++] = ui8StartBlock; // Starting from Block # (called Bno) g_ui8TrfBuffer[ui8Offset++] = pui8TagData[0]; // Four tag data bytes g_ui8TrfBuffer[ui8Offset++] = pui8TagData[1]; g_ui8TrfBuffer[ui8Offset++] = pui8TagData[2]; g_ui8TrfBuffer[ui8Offset++] = pui8TagData[3]; Trf797xRawWrite(&g_ui8TrfBuffer[0], ui8Offset); // Issue the Type 2 Read Command Trf797xIrqWaitTimeout(10,40); // 10 millisecond TX timeout, 40 millisecond RX timeout g_sTrfStatus = Trf797xGetTrfStatus(); if(g_sTrfStatus == RX_COMPLETE) // If an acknowledgment is received { ui8TagResp = g_ui8TrfBuffer[0] >> 4; // Only use upper four bits received for ACK/NAK check if (ui8TagResp == 0xA) { ui8Status = STATUS_SUCCESS; // Mark tag has been successfully read #ifdef ENABLE_HOST UartSendCString(\"Write Success\"); UartPutNewLine(); #endif } else { #ifdef ENABLE_HOST UartSendCString(\"Write Fail: \"); if (ui8TagResp == 0x0) { UartSendCString(\"Invalid Page Address\"); } else { UartSendCString(\"NAK = \"); UartPutChar(ui8TagResp); } UartPutNewLine(); #endif } } else { #ifdef ENABLE_HOST UartSendCString(\"Write Fail\"); UartPutNewLine(); #endif // Otherwise return a fail ui8Status = STATUS_FAIL; } // Read Register 0x10 - Special Functions Register pui8TrfConfig[1] = TRF797x_SPECIAL_FUNCTION_1; Trf797xReadSingle(&pui8TrfConfig[1]); // Set Bit 2 in Special Functions Register to 1 pui8TrfConfig[0] = TRF797x_SPECIAL_FUNCTION_1; pui8TrfConfig[1] &= ~0x04; // Clear 4-bit receive for ACK/NAK replies Trf797xWriteSingle(pui8TrfConfig); return ui8Status; }\n\nMy changes are:\n\nFor Write:\n\nActivate 4 bit RX at the start of the function\n\nOn RX complete, check the byte received for ACK (0xA) or NAK and print out either success or fail+NAK reason\n\nThen at the end, turn off the 4 bit RX again.\n\nFor Read\n\nTurn off RX with CRC\n\nOn RX complete, check length received.\n\nIf greater than 0 byte, print out data\n\nOtherwise print Read Fail as an RX Complete + 0 Bytes of data in the FIFO occurs when receiving a NAK from the Type 2 Tag.\n\nThere is no way to receive this NAK data unless 4 bit mode is enabled, but then tag data cannot be received correctly instead. Hence this implementation has been chosen.\n\nLet me know how this works for you.\n\nEDIT: This post has been edited following the subsequent discussions in the thread in order to remove misleading and erroneous information as well as a non-functional firmware example. The contents of this post now correctly reflect how the TRF7970A should be operated for Type 2 Read and Write commands.\n\nHi Karl,\n\nAlright did a whole battery of tests on trying to receive the NAK with the Read if incorrect commands are sent but also get the data correctly when a valid command is sent.\n\nThe conclusion for this firmware example is that it is not possible to do.\n\nThe issue at hand is that the TRF7970A has to be in one of two modes beforehand... 4 bit or 8 bit mode.\n\nIn 4 bit mode, the TRF7970A will receive the NAK correctly, but the data received will only be received as 4 bits and not 8 bits mean you will never get the correct block data from the tag.\n\nIn 8 bit mode, the TRF7970A will receive all 8 bit tag data correctly, but it cannot process the 4 bit value received (which is why the 4 bit receive had been added to begin with from the TRF7960 to the TRF7960A, for write cases) and while it gives an RX complete, the 4 bit value is lost and not retrievable for the user to view/process.\n\nI exhausted all settings I could think of and found no workaround for this. I was sure I had read data with the 4 bit on before, but was mistaken an erroneously thought that was the case. That's my mistake, as is not verifying it a final time before pushing that half of it out. I will be editing the prior post later to match the correct features of the chip.\n\nAs far as what you can do... well, I tried coming up with a software workaround but the NTAG213 I had did not like that solution it seems.\n\nThe idea was:\n\nSend Read command out\n\nIf RX Complete, check # of bytes received\n\nIf 1 or more bytes, assume Tag Data was provided and print out\n\nIf 0 bytes were received, this means an RX Complete with no data occurred and this was almost guaranteed to be a NAK so\n\nTurn on 4 bit RX mode\n\nProceed to send out the identical Read command again to get the NAK properly\n\nIf no RX occurred, treat it as an error and exit\n\nThe problem is... the NTAG213 went silent for the 2nd read command. Completely. I sniffed the connection over the air and clearly saw all packets including the NAK's and ACK's for writes, but that 2nd read command resulted in nothing. The tag simply won't reply to it.\n\nI tried to put it to sleep with a HLTA and then wake it up with a WUPA but even that didn't get it to behave. It's odd too, in that if I sent 2 correct read commands using that sequence, it would reply both times, but the second I sent two of the same erroneous commands, it would give a NAK to the first command and utterly ignore the second one. Very strange, and it killed my hopeful software workaround.\n\nIf you absolutely must have the NAK data for the Read command, the only option at play is to use Direct Mode 0 or Direct Mode 1. I am pretty sure Direct Mode 1 is sufficient to receive NAK/ACK and also tag data, but I'd need to verify that with a colleague. This adaptation is not planned for the example firmware, but we do have app note which discusses receiving in Direct Mode 1 you can read: http://www.ti.com.cn/cn/lit/an/sloa214/sloa214.pdf\n\nThe latest revision of the DLP-7970ABP BoosterPack (V4.5) supports the needed connections on a hardware level, so it would then become a software implementation for you to be able to get that feature to work.\n\nSorry I didn't have better news after all this time and testing."
    }
}