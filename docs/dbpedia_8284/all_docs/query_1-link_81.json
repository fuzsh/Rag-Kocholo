{
    "id": "dbpedia_8284_1",
    "rank": 81,
    "data": {
        "url": "https://www.sitepoint.com/mysql-data-web/",
        "read_more_link": "",
        "language": "en",
        "title": "Displaying Data from MySQL on the Web: an Introduction â SitePoint",
        "top_image": "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643604505mysql-web.jpg",
        "meta_img": "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643604505mysql-web.jpg",
        "images": [
            "https://secure.gravatar.com/avatar/70460c7edbf59037487fc1d9a285c307?s=96&#038;d=mm&#038;r=g",
            "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643604505mysql-web-768x435.jpg",
            "https://uploads.sitepoint.com/wp-content/uploads/2021/03/1651459137phpmysqlcta.jpg",
            "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643516419First_Principles.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643516445connect-success.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643516472connect-failure.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643516497table-exists.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643516522update.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643516543update2.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643516585jokelist.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643516613jokes-css.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2022/01/1643516647deletebutton.png",
            "https://secure.gravatar.com/avatar/70460c7edbf59037487fc1d9a285c307?s=96&#038;d=mm&#038;r=g",
            "https://cdn.sanity.io/images/708bnrs8/production/56eefa864f8139d1f9340235a77b6e7fdcf7ed52-282x352.png?w=282&h=352&auto=format",
            "https://cdn.sanity.io/images/708bnrs8/production/56eefa864f8139d1f9340235a77b6e7fdcf7ed52-282x352.png?w=282&h=352&auto=format",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2016/12/1481031081Fotolia_91823227_Subscription_Monthly_M-300x120.jpg",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://www.facebook.com/tr?id=721455246308784&ev=PageView&noscript=1"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Tom Butler"
        ],
        "publish_date": "2022-02-11T14:52:50+00:00",
        "summary": "",
        "meta_description": "Learn how to take information stored in a MySQL database and display it on a web page for all to see.",
        "meta_lang": "",
        "meta_favicon": "/favicons/48x48.png",
        "meta_site_name": "",
        "canonical_link": "https://www.sitepoint.com/mysql-data-web/",
        "text": "The following article is an excerpt from PHP & MySQL: Novice to Ninja, 7th Edition, a hands-on guide to learning all the tools, principles, and techniques needed to build a professional web application. In this final tutorial in the series, youâll learn how to take information stored in a MySQL database and display it on a web page for all to see.\n\nSetting Up Your PHP Development Environment with Docker\n\nA Beginnerâs Guide to PHP\n\nIntroducing MySQL: A Beginnerâs Guide\n\nDisplaying Data from MySQL on the Web: an Introduction\n\nThis is it â the stuff you signed up for! In this chapter, youâll learn how to take information stored in a MySQL database and display it on a web page for all to see.\n\nSo far, youâve written your first PHP code and learned the basics of MySQL, a relational database engine, and PHP, a server-side scripting language.\n\nNow youâre ready to learn how to use these tools together to create a website where users can view data from the database and even add their own.\n\nNote: as in Chapter 3, Iâm using âMySQLâ here to refer to the database protocol. Your PHP scripts will do the same. There are numerous references in this chapter â and in the PHP code youâll write â to âMySQLâ, even though weâre actually connecting to a MariaDB database.\n\nThe Big Picture\n\nBefore we leap forward, itâs worth taking a step back for a clear picture of our ultimate goal. We have two powerful tools at our disposal: the PHP scripting language and the MySQL database engine. Itâs important to understand how these will fit together.\n\nThe purpose of using MySQL for our website is to allow the content to be pulled dynamically from the database to create web pages for viewing in a regular browser. So, at one end of the system you have a visitor to your site using a web browser to request a page. That browser expects to receive a standard HTML document in return. At the other end you have the content of your site, which sits in one or more tables in a MySQL database that only understands how to respond to SQL queries (commands).\n\nAs shown in the image above, the PHP scripting language is the go-between that speaks both languages. It processes the page request and fetches the data from the MySQL database using SQL queries just like those you used to create a table of jokes in Chapter 3. It then spits it out dynamically as the nicely formatted HTML page that the browser expects.\n\nJust so itâs clear and fresh in your mind, this is what happens when thereâs a visitor to a page on your website:\n\nThe visitorâs web browser requests the web page from your web server.\n\nThe web server software (typically Apache or NGINX) recognizes that the requested file is a PHP script, so the server fires up the PHP interpreter to execute the code contained in the file.\n\nCertain PHP commands (which will be the focus of this chapter) connect to the MySQL database and request the content that belongs in the web page.\n\nThe MySQL database responds by sending the requested content to the PHP script.\n\nThe PHP script stores the content into one or more PHP variables, then uses echo statements to output the content as part of the web page.\n\nThe PHP interpreter finishes up by handing a copy of the HTML it has created to the web server.\n\nThe web server sends the HTML to the web browser as it would a plain HTML file, except that instead of coming directly from an HTML file, the page is the output provided by the PHP interpreter. The browser has no way of knowing this, however. As far as the browser is concerned, itâs requesting and receiving a web page like any other.\n\nCreating a MySQL User Account\n\nIn order for PHP to connect to your MySQL database server, it will need to use a username and password. So far, all that your joke database contains is a number of pithy bon mots, but before long it may contain sensitive information like email addresses and other private details about the users of your website. For this reason, MySQL is designed to be very secure, giving you tight control over what connections it will accept and what those connections are allowed to do.\n\nThe Docker environment already contains a MySQL user in Chapter 3, which youâve already used to log in to the MySQL server.\n\nYou could connect to the database from your PHP script using the same username (v.je) and password (v.je), but itâs useful to create a new account â because if you have a web server, you may want to use it to host more than one website. By giving each website its own user account, youâll have more control over who has access to the data for any given site. If youâre working with other developers, you can give them access to the sites theyâre working on, but no more.\n\nYou should create a new user account with only the specific privileges it needs to work on the ijdb database that your website depends upon. Letâs do that now.\n\nTo create a user, open up MySQL Workbench and connect to your server. Then run the following queries:\n\nCREATE USER 'ijdbuser'@'%' IDENTIFIED BY 'mypassword'; GRANT ALL PRIVILEGES ON `ijdb`.* TO 'ijdbuser'@'%';\n\nThe first query is fairly self explanatory: It creates a user called ijdbuser with the password mypassword. The % sign after the username indicates that the database can be connected to from any location. The second query gives the user full acces to the ijdb schema, as a result this user can see and modify all the tables, columns and data in the ijdb schema but has no access to anything outside it.\n\nNow that the user ijdbuser has been created, we can use it to connect to the database. Itâs possible to set up a connection in MySQL Workbench with this user, but since the permissions are limited, itâs better to keep MySQL Workbench using the v.je account. Instead, weâre going to use the new user when connecting from a PHP script.\n\nConnecting to MySQL with PHP\n\nBefore you can retrieve content from your MySQL database for inclusion in a web page, you must know how to establish a connection to MySQL from inside a PHP script. So far, youâve used an application called MySQL Workbench to connect to your database. Just as MySQL Workbench can connect directly to a running MySQL server, so too can your own PHP scripts.\n\nAlthough this chapter talks entirely about connecting to MySQL from PHP, weâre actually connecting to the MariaDB database discussed in the previous chapter. PHP canât see any difference between MySQL and MariaDB, as theyâre interchangeable. Iâll refer to the database as MySQL throughout, because all of the commands used could be used to connect to a MySQL or MariaDB database server.\n\nThe original MySQL database provided a standardized method for clients such as MySQL Workbench and PHP to communicate with the server. MariaDB copied that standard, and all the commands in PHP use the name MySQL, so to keep things simple, Iâll use the term MySQL throughout this chapter to refer to the database.\n\nThere are three methods of connecting to a MySQL server from PHP:\n\nthe MySQL library\n\nthe MySQLi library\n\nthe PDO library\n\nThese all essentially do the same job â connecting to the database and sending queries to it â but they use different code to achieve it.\n\nThe MySQL library is the oldest method of connecting to the database and was introduced in PHP 2.0. The features it contains are minimal, and it was superseded by MySQLi as of PHP 5.0 (released in 2004).\n\nTo connect and query the database using the old MySQL library, functions such as mysql_connect() and mysql_query() are used. These functions have been deprecated â meaning they should be avoided â since PHP 5.5, and have been removed from PHP entirely since PHP 7.0.\n\nAlthough most developers saw the reason for the change as soon as PHP 5.0 was released, there are still hundreds of articles and code examples on the Web using these now non-existent mysql_* functions â despite the fact that MySQLi has effectively been the preferred library for fifteen years.\n\nIf you come across a code example that contains the line mysql_connect(), check the date of the article. Itâs probably from the early 2000s, and in programming, you should never trust anything that old. Things change all the time â which is why this book is on its seventh edition!\n\nIn PHP 5.0, the MySQLi library â standing for âMySQL Improvedâ â was released to address some of the limitations in the original MySQL library. You can easily identify the use of MySQLi, because the code will use functions such as mysqli_connect() and mysqli_query().\n\nShortly after the release of the MySQLi library in PHP 5.0, PHP 5.1 was released, with a significant number of changes that helped shape the way we write PHP today (mostly to do with object-oriented programming, which youâll see plenty of later in this book). One of the major changes in PHP 5.1 was that it introduced a third library, PDO (PHP Data Objects), for connecting to MySQL databases.\n\nThere are several differences between PDO and MySQLi, but the main one is that you can use the PDO library to connect to almost any database server â such as an Oracle server, or Microsoft SQL Server. For developers, the biggest advantage of this generic approach is that, once youâve learned how to use the library to interact with a MySQL database, itâs very simple to interact with another database server.\n\nArguably, itâs simpler to write code for PDO, and there are some nuances that can make PDO code more readable â named parameters in prepared statements being the main benefit. (Donât worry, Iâll explain what that means later on.)\n\nFor these reasons, most recent PHP projects use the PDO library, and itâs the library Iâm going to show you how to use in this book. For more information on the differences, take a look at the SitePoint article âRe-introducing PDO â the Right Way to Access Databases in PHPâ.\n\nAfter that little history lesson, youâre probably eager to get back to writing code. Hereâs how you use PDO to establish a connection to a MySQL server:\n\nnew PDO('mysql:host=hostname;dbname=database', 'username', 'password')\n\nFor now, think of new PDO as a built-in function, just like the rand function we used in Chapter 2. If youâre thinking âHey, functions canât have spaces in their names!â, youâre smarter than the average bear, and Iâll explain exactly whatâs going on here in a moment. In any case, it takes three arguments:\n\na string specifying the type of database (mysql:), the hostname of the server (host=hostname;), and the name of the database (dbname=database)\n\nthe MySQL username you want PHP to use\n\nthe MySQL password for that username\n\nYou may remember from Chapter 2 that PHP functions usually return a value when theyâre called. This new PDO âfunctionâ returns a value called a PDO object that identifies the connection thatâs been established. Since we intend to make use of the connection, we should hold onto this value by storing it in a variable. Hereâs how that looks, with the necessary values filled in to connect to your database:\n\n$pdo = new PDO('mysql:host=mysql;dbname=ijdb', 'ijdbuser', 'mypassword');\n\nYou can probably see whatâs going on with the last two arguments: theyâre the username and password you created earlier in this chapter.\n\nThe first argument is a little more complicated. The dbname=ijdb part tells PDO to use the database (also referred to as a schema) called ijdb. Any query run from PHP will default to tables in that schema. SELECT * FROM joke will select records from the joke table in the ijdb schema.\n\nEven if youâre familiar with PHP, PDO and MySQL already, the host=mysql part looks confusing. Normally, this would be host=localhost (referring to the local computer, the same machine running PHP) or pointing to a specific domain name where the database is hosted, such as host=sitepoint.com.\n\nWhy is it host=mysql, and what does mysql refer to here? In Docker, each service is given a name. If you examine the docker-compose.yml file that configures the server, the database service is called mysql, and in Docker, one service can connect to another using the other serviceâs name.\n\nArguments aside, whatâs important to see here is that the value returned by new PDO is stored in a variable named $pdo.\n\nThe MySQL server is a completely separate piece of software from the web server. Therefore, we must consider the possibility that the server may be unavailable or inaccessible due to a network outage, or because the username/password combination you provided is rejected by the server, or because you just forgot to start your MySQL server! In such cases, new PDO wonât run, and will throw a PHP exception.\n\nNote: at least by default, PHP can be configured so that no exception is thrown and it simply wonât connect. This isnât generally desirable behavior, as it makes it much more difficult to work out what went wrong.\n\nIf youâre wondering what it means to âthrow a PHP exceptionâ, brace yourself! Youâre about to discover some more features of the PHP language.\n\nA PHP exception is what happens when you tell PHP to perform a task and itâs unable to do it. PHP will try to do what itâs told, but will fail; and in order to tell you about the failure, it will throw an exception at you. An exception is little more than PHP just crashing with a specific error message. When an exception is thrown, PHP stops. No lines of code after the error will be executed.\n\nAs a responsible developer, itâs your job to catch that exception and do something about it so the program can continue.\n\nNote: if you donât catch an exception, PHP will stop running your PHP script and display a spectacularly ugly error message. That error message will even reveal the code of your script that threw the error. In this case, that code contains your MySQL username and password, so itâs especially important to avoid the error message being seen by users!\n\nTo catch an exception, you should surround the code that might throw an exception with a try â¦ catch statement:\n\ntry { â® do something risky } catch (ExceptionType $e) { â® handle the exception }\n\nYou can think of a try â¦ catch statement like an if â¦ else statement, except that the second block of code is what happens if the first block of code fails to run.\n\nConfused yet? I know Iâm throwing (no pun intended) a lot of new concepts at you, but it will make more sense if I put it all together and show you what we have:\n\ntry { $pdo = new PDO('mysql:host=mysql;dbname=ijdb', 'ijdbuser', âmypasswordâ); $output = 'Database connection established.'; } catch (PDOException $e) { $output = 'Unable to connect to the database server.'; } include __DIR__ . '/../templates/output.html.php';\n\nAs you can see, this code is a try â¦ catch statement. In the try block at the top, we attempt to connect to the database using new PDO. If this succeeds, we store the resulting PDO object in $pdo so that we can work with our new database connection. If the connection is successful, the $output variable is set to a message that will be displayed later.\n\nImportantly, inside a try â¦ catch statement, any code after an exception has been thrown wonât get executed. In this case, if connecting to the database throws an exception (maybe the password is wrong, or the server isnât responding), the $output variable will never get set to âDatabase connection establishedâ.\n\nIf our database connection attempt fails, PHP will throw a PDOException, which is the type of exception that new PDO throws. Our catch block, therefore, says that it will catch a PDOException (and store it in a variable named $e). Inside that block, we set the variable $output to contain a message about what went wrong.\n\nHowever, this error message isnât particularly useful. All it tells us is that PDO couldnât connect to the database server. It would be better to have some information about why that was â for example, because the username and password were invalid.\n\nThe $e variable contains details about the exception that occurred, including an error message describing the problem. We can add this to the output variable using concatenation:\n\ntry { $pdo = new PDO('mysql:host=mysql;dbname=ijdb', 'ijdbuser', 'mypassword'); $output = 'Database connection established.'; } catch (PDOException $e) { $output = 'Unable to connect to the database server: ' . $e->getMessage(); } include __DIR__ . '/../templates/output.html.php';\n\nNote: the $e variable isnât a string, but an object. Weâll come to what that means shortly. For now, though, all you need to know is that the code $e->getMessage() gets the error message based on the specific exception that occurred.\n\nLike an if â¦ else statement, one of the two branches of a try â¦ catch statement is guaranteed to run. Either the code in the try block will execute successfully, or the code in the catch block will run. Regardless of whether the database connection was successful, there will be a message in the $output variable â either the error message, or the message saying the connection was successful.\n\nFinally, regardless of whether the try block was successful, or the catch block runs, the template output.html.php is included. This is a generic template that just displays some text to the page:\n\n<!doctype html> <html> <head> <meta charset=\"utf-8\"> <title>Script Output</title> </head> <body> <?php echo $output; ?> </body> </html>\n\nThe complete code can be found in Example: MySQL-Connect.\n\nWhen the template is included, it will display either the error message or the âDatabase connection establishedâ message.\n\nI hope the aforementioned code is now making some sense to you. Feel free to go back to the start of this section and read it all again if youâre lost, as there were some tricky concepts in there. Once you have a firm grip on the code, however, youâll probably realize that Iâve still left one mystery unexplained: PDOs. Just what exactly is new PDO, and when I said it returns a âPDO objectâ, just what exactly is an object?\n\nNote: all downloaded sample code includes a schema called ijdb_sample and a user called ijdb_sample, so that youâre able to run it regardless of what you called your schema and user. A file containing the database is provided as database.sql, which you can import.\n\nIf you use the web-based sample code viewer provided, the idbj_sample database will be created as you load a sample, but any changes to this schema will be lost when you view another sample. (You can mess things up, and switching to another sample and back will reset it, but if you want to keep any changes you make, make them in the schema you created.)\n\nIf you want to load the sample data into your schema using MySQL Workbench, import database.sql from the project directory by selecting Data Import/Restore. Then select Import from self-contained file, browse to database.sql, and select your schema name in default target schema. If you have created any tables with the same name, theyâll be overwritten and all records lost.\n\nA Crash Course in Object-oriented Programming\n\nYou may have noticed the word âobjectâ beginning to creep into my vocabulary in the previous section. PDO is the PHP Data Objects extension, and new PDO returns a PDO object. In this section, Iâd like to explain what objects are all about.\n\nPerhaps youâve come across the term object-oriented programming (OOP) in your own explorations of PHP or of programming in general. OOP is an advanced style of programming thatâs especially suited to building really complex programs with a lot of parts. Most programming languages in active use today support OOP. Some of them even require you to work in an OOP style. PHP is a little more easygoing about it, and leaves it up to the developer to decide whether or not to write their scripts in the OOP style.\n\nSo far, weâve written our PHP code in a simpler style called procedural programming, and weâll continue to do so for now, with a more detailed look at objects later on. Procedural style is well suited to the relatively simple projects weâre tackling at the moment. However, almost all complex projects youâll come across use OOP, and Iâll cover it in more detail later in this book.\n\nThat said, the PDO extension weâll use to connect to and work with a MySQL database is designed in the object-oriented programming style. This means that, rather than simply calling a function to connect to MySQL and then calling other functions that use that connection, we must first create a PDO object that will represent our database connection, and then use the features of that object to work with the database.\n\nCreating an object is a lot like calling a function. In fact, youâve already seen how to do it:\n\n$pdo = new PDO('mysql:host=mysql;dbname=ijdb', 'ijdbuser', 'mypassword');\n\nThe new keyword tells PHP that you want to create a new object. You then leave a space and specify a class name, which tells PHP what type of object you want to create. A class is a set of instructions that PHP will follow to create an object. You can think of a class as being a recipe, such as for a cake, and an object being the actual cake thatâs produced from following the recipe. Different classes can produce different objects, just as different recipes can produce different dishes.\n\nJust as PHP comes with a bunch of built-in functions that you can call, PHP comes with a library of classes that you can create objects from. new PDO, therefore, tells PHP to create a new PDO object â that is, a new object of the built-in PDO class.\n\nIn PHP, an object is a value, just like a string, number, or array. You can store an object in a variable or pass it to a function as an argument â all the same stuff you can do with other PHP values. Objects, however, have some useful additional features.\n\nFirst of all, an object behaves a lot like an array, in that it acts as a container for other values. As we saw in Chapter 2, you can access a value inside an array by specifying its index (for example, $birthdays['Kevin']). When it comes to objects, the concepts are similar but the names and code are different. Rather than accessing the value stored in an array index, we say that weâre accessing a property of the object. Instead of using square brackets to specify the name of the property we want to access, we use arrow notation (->) â for instance, $myObject->someProperty:\n\n$myObject = new SomeClass(); // create an object $myObject->someProperty = 123; // set a property's value echo $myObject->someProperty; // get a property's value\n\nWhereas arrays are normally used to store a list of similar values (such as an array of birthdays), objects are used to store a list of related values (for example, the properties of a database connection). Still, if thatâs all objects did, there wouldnât be much point to them: we might just as well use an array to store these values, right? Of course, objects do more.\n\nIn addition to storing a collection of properties and their values, objects can contain a group of functions designed to bring us more useful features. A function stored in an object is called a method (one of the more confusing names in the programming world, if you ask me). A method is just a function inside a class. More confusingly, when we get onto writing our own classes, methods are defined using the function keyword! Even experienced developers often wrongly use function and method interchangeably.\n\nTo call a method, we again use arrow notation â $myObject->someMethod():\n\n$myObject = new SomeClass(); // create an object $myObject->someMethod(); // call a method\n\nJust like standalone functions, methods can take arguments and return values.\n\nAt this stage, this is probably all sounding a little complicated and pointless, but trust me: pulling together collections of variables (properties) and functions (methods) into little bundles called objects results in much tidier and easier-to-read code for certain tasks â working with a database being just one of them. One day, you may even want to develop custom classes that you can use to create objects of your own devising.\n\nFor now, however, weâll stick with the classes that come included with PHP. Letâs keep working with the PDO object weâve created, and see what we can do by calling one of its methods.\n\nConfiguring the Connection\n\nSo far, Iâve shown you how to create a PDO object to establish a connection with your MySQL database, and how to display a meaningful error message when something goes wrong:\n\n<?php try { $pdo = new PDO('mysql:host=mysql;dbname=ijdb', 'ijdbuser', 'mypassword'); $output = 'Database connection established.'; } catch (PDOException $e) { $output = 'Unable to connect to the database server: ' . $e->getMessage(); } include __DIR__ . '/../templates/output.html.php';\n\nAssuming the connection succeeds, though, you need to configure it before use. You can configure your connection by calling some methods of your new PDO object.\n\nBefore sending queries to the database, weâll need to configure the character encoding of our database connection. As I mentioned briefly in Chapter 2, you should use UTF-8 encoded text in your websites to maximize the range of characters users have at their disposal when filling in forms on your site. By default, when PHP connects to MySQL, it uses the simpler ISO-8859-1 (or Latin-1) encoding instead of UTF-8. If we were to leave it as is, we wouldnât easily be able to insert Chinese, Arabic or most non-English characters.\n\nEven if youâre 100% sure that your website will only be used by English speakers, there are other problems caused by not setting the character set. If your web page is not set to UTF-8, youâll run into problems when people write certain characters such as curly quotes â into a text box, because theyâll appear in the database as a different character.\n\nTherefore, we now need to set our new PDO object to use the UTF-8 encoding.\n\nWe can instruct PHP to use UTF-8 when querying the database by appending ;charset=utf8mb4 to the connection string. There are no downsides to doing this, provided your PHP script is also being sent to the browser as UTF-8 (which is the default in recent PHP versions):\n\n$pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword');\n\nNote: if you go searching, youâll find different ways to set the charset, and earlier editions of this book instructed you to use this code:\n\n$pdo->exec('SET NAMES \"utf8\"');\n\nThis is because, until PHP 5.3.6, the charset option was not correctly applied by PHP. Since this is fixed in any PHP version youâre actually going to be using, setting the charset as part of the connection string is the preferred option.\n\nThe complete code we use to connect to MySQL and then configure that connection, therefore, is shown below.\n\nExample: MySQL-Connect-Complete\n\n<?php try { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $output = 'Database connection established.'; } catch (PDOException $e) { $output = 'Unable to connect to the database server: ' . $e->getMessage(); } include __DIR__ . '/../templates/output.html.php';\n\nFire up this example in your browser. (If youâve placed your database code in index.php inside the public directory and the output.html.php file in the templates directory, the URL for the page will be https://v.je/.)\n\nIf your server is up and running, and everything is working properly, you should see a message indicating success.\n\nIf PHP is unable to connect to your MySQL server, or if the username and password you provided are incorrect, youâll instead see a similar screen to that shown below. To make sure your error-handling code is working properly, you might want to misspell your password intentionally to test it out.\n\nThanks to our catch block, the error message from the database has been included on the page:\n\ncatch (PDOException $e) { $output = 'Unable to connect to the database server: ' . $e->getMessage(); }\n\nThe method getMessage() returns a message describing the exception that occurred. There are some other methods â including getFile() and getLine() â for returning the file name and line number that the exception was thrown on. You can generate a very detailed error message like this:\n\ncatch (PDOException $e) { $output = 'Unable to connect to the database server: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); }\n\nThis is incredibly useful if you have a large website with dozens of include files. The error message will tell you exactly which file to look in and which line the error occurred on.\n\nIf youâre curious, try inserting some other mistakes in your database connection code (for example, a misspelled database name) and observe the detailed error messages that result. When youâre done, and your database connection is working correctly, go back to the simple error message. This way, your visitors wonât be bombarded with technical gobbledygook if a genuine problem emerges with your database server.\n\nWith a connection established and a database selected, youâre ready to begin using the data stored in the database.\n\nYou might be wondering what happens to the connection with the MySQL server after the script has finished executing. If you really want to, you can force PHP to disconnect from the server by discarding the PDO object that represents your connection. You do this by setting the variable containing the object to null:\n\n$pdo = null;\n\nThat said, PHP will automatically close any open database connections when it finishes running your script, so you can usually just let PHP clean up after you.\n\nSending SQL Queries with PHP\n\nIn Chapter 3, we connected to the MySQL database server using MySQL Workbench, which allowed us to type SQL queries (commands) and view the results of those queries immediately. The PDO object offers a similar mechanism â the exec method:\n\n$pdo->exec($query)\n\nHere, $query is a string containing whatever SQL query you want to execute.\n\nAs you know, if thereâs a problem executing the query (for instance, if you made a typing mistake in your SQL query), this method will throw a PDOException for you to catch.\n\nConsider the following example, which attempts to produce the joke table we created in Chapter 3.\n\nExample: MySQL-Create\n\ntry { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'CREATE TABLE joke ( id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, joketext TEXT, jokedate DATE NOT NULL ) DEFAULT CHARACTER SET utf8 ENGINE=InnoDB'; $pdo->exec($sql); $output = 'Joke table successfully created.'; } catch (PDOException $e) { $output = 'Database error: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); } include __DIR__ . '/../templates/output.html.php';\n\nNote that we use the same try â¦ catch statement technique to handle possible errors produced by the query. It would be possible to use multiple try â¦ catch blocks to display different error messages â one for the connection and one for the query â but this can result in a considerable amount of extra code.\n\nInstead, Iâve opted to use the same try statement to contain both the connection and the query. The try â¦ catch block will stop executing code once an error occurs, so if an error occurs during the database connection, the $pdo->exec($run) line will never run, ensuring that, if a query is sent to the database, a connection must have been established.\n\nThis approach gives us a little less control over the error message thatâs displayed, but saves typing a try â¦ catch statement for each database operation. Later in this book, weâll break these up into different blocks, but for now, keep all the database operations in the same try block.\n\nThis example also uses the getMessage method to retrieve a detailed error message from the MySQL server. The following image shows the error thatâs displayed when, for example, the joke table already exists.\n\nFor DELETE, INSERT, and UPDATE queries (which serve to modify stored data), the exec method returns the number of table rows (entries) that were affected by the query. Consider the following SQL command, which we used in Chapter 3 to set the dates of all jokes that contained the word âprogrammerâ.\n\nExample: MySQL-Update\n\ntry { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'UPDATE joke SET jokedate=\"2021-04-01\" WHERE joketext LIKE \"%programmer%\"'; $affectedRows = $pdo->exec($sql); $output = 'Updated ' . $affectedRows .' rows.'; } catch (PDOException $e) { $output = 'Database error: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); } include __DIR__ . '/../templates/output.html.php';\n\nBy storing the value returned from the exec method in $affectedRows, we can use the variable in the $output variable for printing in the template.\n\nThe image below shows the output of this example, assuming thereâs only one âprogrammerâ joke in your database.\n\nIf you refresh the page to run the same query again, you should see the message change, as shown in the following image. It indicates that no rows were updated, since the new date being applied to the jokes is the same as the existing date.\n\nSELECT queries are treated a little differently, as they can retrieve a lot of data, and PHP provides ways to handle that information.\n\nHandling SELECT Result Sets\n\nFor most SQL queries, the exec method works just fine. The query does something to your database, and you get the number of affected rows (if any) from the methodâs return value. SELECT queries, however, require something a little fancier than exec. Youâll recall that SELECT queries are used to view stored data in the database. Instead of only affecting the database, SELECT queries have results â and we need a method to return them.\n\nThe query method looks just like exec, in that it accepts an SQL query as an argument to be sent to the database server. What it returns, however, is a PDOStatement object, which represents a result set containing a list of all the rows (entries) returned from the query:\n\n<?php try { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'SELECT `joketext` FROM `joke`'; $result = $pdo->query($sql); } catch (PDOException $e) { $error = 'Unable to connect to the database server: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); }\n\nProvided that no error was encountered in processing the query, this code will store a result set (in the form of a PDOStatement object) into the variable $result. This result set contains the text of all the jokes stored in the joke table. As thereâs no practical limit on the number of jokes in the database, the result set can be quite big.\n\nI mentioned back in Chapter 2 that the while loop is a useful control structure when we need to loop but donât know how many times. We canât use a for loop, because we donât know how many records the query returned. Indeed, you could use a while loop here to process the rows in the result set one at a time:\n\nwhile ($row = $result->fetch()) { â® process the row }\n\nThe condition for the while loop is probably different from the conditions youâre used to, so let me explain how it works. Consider the condition as a statement all by itself:\n\n$row = $result->fetch();\n\nThe fetch method of the PDOStatement object returns the next row in the result set as an array (we discussed arrays in Chapter 2). When there are no more rows in the result set, fetch returns false instead. (This is one case where asking a PDO object to do something it canât do â as fetch canât return the next row when there are no rows left in the result set â will not throw a PDOException. If it did, weâd be unable to use the fetch method in a while loop condition the way we do here.)\n\nNow, the above statement assigns a value to the $row variable, but, at the same time, the statement as a whole takes on that same value. This is what lets you use the statement as a condition in the while loop. Since a while loop will keep looping until its condition evaluates to false, this loop will occur as many times as there are rows in the result set, with $row taking on the value of the next row each time the loop executes. All thatâs left to figure out is how to retrieve the values out of the $row variable each time the loop runs.\n\nRows of a result set returned by fetch are represented as associative arrays, with the indices named after the table columns in the result set. If $row is a row in our result set, $row['joketext'] is the value in the joketext column of that row.\n\nOur goal in this code is to store away the text of all the jokes so that we can display them in a PHP template. The best way to do this is to store each joke as a new item in an array, $jokes:\n\nwhile ($row = $result->fetch()) { $jokes[] = $row['joketext']; }\n\nWith the jokes pulled out of the database, we can now pass them along to a PHP template jokes.html.php.\n\nTo summarize, hereâs the code of the controller for this example so far:\n\n<?php try { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'SELECT `joketext` FROM `joke`'; $result = $pdo->query($sql); while ($row = $result->fetch()) { $jokes[] = $row['joketext']; } } catch (PDOException $e) { $error = 'Unable to connect to the database server: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); } include __DIR__ . '/../templates/jokes.html.php';\n\nThe $jokes variable is an array that stores a list of jokes. If you wrote out the contents of the array in PHP, it would look something like this:\n\n$jokes = []; $jokes[0] = 'A programmer was found dead in the shower. The instructions read: lather, rinse, repeat.'; $jokes[1] = '!false - it\\'s funny because it\\'s true'; $jokes[2] = 'A programmer\\'s wife tells him to go to the store and \"get a gallon of milk, and if they have eggs, get a dozen.\" He returns with 13 gallons of milk.';\n\nHowever, the data has been retrieved from the database rather than being typed out manually in the code.\n\nYouâll have noticed that there are two different variables being set â $jokes and $error â depending on whether or not the try block executed successfully.\n\nIn the jokes.html.php template, we need to display the contents of the $jokes array or the error message contained in the $error variable.\n\nTo check whether or not a variable has been assigned a value, we can use the isset function that we used earlier for checking if a form has been submitted. The template can include an if statement to determine whether to display the error or the list of jokes:\n\nif (isset($error)) { ?> <p> <?php echo $error; ?> </p> } else { : display the jokes }\n\nThereâs nothing new here, but to display the jokes, we need to display the contents of the $jokes array. Unlike other variables weâve used up to this point, the $jokes array contains more than just a single value.\n\nThe most common way to process an array in PHP is to use a loop. Weâve already seen while loops and for loops. The foreach loop is particularly helpful for processing arrays:\n\nforeach (array as $item) { â® process each $item }\n\nInstead of a condition, the parentheses at the top of a foreach loop contain an array, followed by the keyword as, and then the name of a new variable that will be used to store each item of the array in turn. The body of the loop is then executed once for each item in the array. Each time that item is stored in the specified variable, so that the code can access it directly.\n\nItâs common to use a foreach loop in a PHP template to display each item of an array in turn. Hereâs how this might look for our $jokes array:\n\n<?php foreach ($jokes as $joke) { ?> â® HTML code to output each $joke <?php } ?>\n\nWith this blend of PHP code to describe the loop and HTML code to display it, the code looks rather untidy. Because of this, itâs common to use an alternative way of writing the foreach loop when itâs used in a template:\n\nforeach (array as $item): â® process each $item endforeach;\n\nThe two pieces of code are functionally identical, but the latter looks more friendly when mixed with HTML code. Hereâs how this form of the code looks in a template:\n\n<?php foreach ($jokes as $joke): ?> â® HTML code to output each $joke <?php endforeach; ?>\n\nThe same thing can be done with the if statement, making it nicer to look at inside HTML templates by avoiding the braces:\n\n<?php if (isset($error)): ?> <p> <?php echo $error; ?> </p> <?php else: ?> : display the jokes <?php endif; ?>\n\nWith these new tools in hand, we can write our template to display the list of jokes.\n\nExample: MySQL-ListJokes\n\n<!doctype html> <html> <head> <meta charset=\"utf-8\"> <title>List of jokes</title> </head> <body> <?php if (isset($error)): ?> <p> <?php echo $error; ?> </p> <?php else: ?> <?php foreach ($jokes as $joke): ?> <blockquote> <p> <?php echo htmlspecialchars($joke, ENT_QUOTES, 'UTF-8') ?> </p> </blockquote> <?php endforeach; ?> <?php endif; ?> </body> </html>\n\nEither the $error text is displayed on the page or each joke is displayed in a paragraph (<p>) contained within a block quote (<blockquote>), since weâre effectively quoting the author of each joke in this page.\n\nBecause jokes might conceivably contain characters that could be interpreted as HTML code (for example, <, >, or &), we must use htmlspecialchars to ensure theyâre translated into HTML character entities (that is, &lt;, &gt;, and &amp;) so that theyâll be displayed correctly.\n\nThe following image shows what this page looks like once youâve added a couple of jokes to the database.\n\nRemember how we used a while loop in our controller to fetch the rows out of the PDOStatement result set one at a time?\n\nwhile ($row = $result->fetch()) { $jokes[] = $row['joketext']; }\n\nIt turns out that PDOStatement objects are designed to behave just like arrays when you pass them to a foreach loop. You can therefore slightly simplify your database processing code using a foreach loop instead of a while loop:\n\nforeach ($result as $row) { $jokes[] = $row['joketext']; }\n\nIâll be using this tidier foreach form in the rest of this book.\n\nAnother neat tool PHP offers is a shorthand way to call the echo command â which, as youâve already seen, we need to use frequently. Our echo statements look like this:\n\n<?php echo $variable; ?>\n\nInstead, we can use this:\n\n<?=$variable?>\n\nThis does exactly the same thing. <?= means echo and gives you a slightly shorter way to print variables. Thereâs a limitation to this, though: if you use <?=, you can only print. You canât include if statements, for statements, and so on, although you can use concatenation, and it can be followed by a function call.\n\nHereâs an updated template using the shorthand echo.\n\nExample: MySQL-ListJokes-Shorthand\n\n<!doctype html> <html> <head> <meta charset=\"utf-8\"> <title>List of jokes</title> </head> <body> <?php if (isset($error)): ?> <p> <?=$error?> </p> <?php else: ?> <?php foreach ($jokes as $joke): ?> <blockquote> <p> <?=htmlspecialchars($joke, ENT_QUOTES, 'UTF-8')?> </p> </blockquote> <?php endforeach; ?> <?php endif; ?> </body> </html>\n\nIâll be using the shorthand notation when itâs applicable from this point on.\n\nNote: in versions of PHP prior to 5.4, this shorthand notation required a fairly uncommon PHP setting to be enabled, so it was discouraged for compatibility reasons. Using the shorthand notation may have caused your code to stop working when moving from a server that had it enabled to one that didnât.\n\nAs of PHP 5.4 (so any version youâre realistically going to encounter these days), the shorthand echo works regardless of PHP settings, so you can safely use it without worrying that it might not work on all servers.\n\nThinking Ahead\n\nIn the example we just looked at, we created a template, jokes.html.php, which contains all the HTML required to display the page. However, as our website grows, weâll add more pages. Weâll certainly want a page for people to be able to add jokes to the website, and weâll also need a home page with some introductory text, a page with the ownerâs contact details, and, as the site grows, perhaps even a page where people can log in to the website.\n\nIâm jumping ahead a quite a bit here, but itâs always worth considering how a project will grow. If we apply the approach we just used for jokes.html.php to the rest of the templates â addjoke.html.php, home.html.php, contact.html.php, login.html.php and so on â weâll end up with a lot of repeated code.\n\nEvery page on the website will require a template that will look something like this:\n\n<!doctype html> <html> <head> <meta charset=\"utf-8\"> <title>IJDB - Internet Joke Database</title> </head> <body> <?php if (isset($error)): ?> <p> <?=$error?> </p> <?php else: ?> : do whatever is required for this page: show text, : show a form, list records from the database, etc. <?php endif; ?> </body> </html>\n\nAs a programmer, repeating code is one of the worst things you can do. In fact, programmers often refer to the DRY principle, which stands for âDonât repeat yourselfâ. If you find yourself repeating sections of code, thereâs almost certainly a better solution.\n\nAll the best programmers are lazy, and repeating code means repeating work. Using this copy/paste approach for templates makes the website very difficult to maintain. Letâs imagine thereâs a footer and a navigation section that we want to appear on each page. Our templates would now look like this:\n\n<!doctype html> <html> <head> <meta charset=\"utf-8\"> <title>IJDB - Internet Joke Database</title> </head> <body> <nav> <ul> <li><a href=\"index.php\">Home</a></li> <li><a href=\"jokes.php\">Jokes List</a></li> </ul> </nav> <main> <?php if (isset($error)): ?> <p> <?=$error?> </p> <?php else: ?> : do whatever is required for this page: show text, : show a form, list jokes, etc. <?php endif; ?> </main> <footer> &copy; IJDB 2021 </footer> </body> </html>\n\nWeâll run into a problem in 2022! If the templates for all the pages on the website â for example, jokes.html.php addjoke.html.php, home.html.php, contact.html.php andlogin.html.php â contain code in the structure above, to update the year in the copyright notice to â2022â youâd need to open each of the templates and change the date.\n\nWe could be clever and have the date dynamically read from the serverâs clock (echo date('Y'); if youâre curious!) to avoid this issue, but what if we wanted to add a <script> tag that was included on every page? Or add a new link to the menu? Weâd still need to open every template file and change it!\n\nChanging five or six templates may be slightly annoying, but itâs not going to pose much of a problem. However, what if the website grows to dozens or hundreds of pages? Each time you wanted to add a link to the menu youâd have to open every single template and change it.\n\nThis problem could be solved with a series of include statements. For example:\n\n<!doctype html> <html> <head> <meta charset=\"utf-8\"> <title>IJDB - Internet Joke Database</title> </head> <body> <nav> <?php include 'nav.html.php'; ?> </nav> <main> <?php if (isset($error)): ?> <p> <?=$error?> </p> <?php else: ?> : do whatever is required for this page: show text, : show a form, list jokes, etc. <?php endif; ?> </main> <footer> <?php include 'footer.html.php'; ?> </footer> </body> </html>\n\nBut this method requires clairvoyance: we need to anticipate exactly what changes might need to be made in the future and use relevant include statements in the places we foresee changes will happen.\n\nIn the example above, for example, itâs easy to add new menu entries by adding them to nav.html.php, but adding a <script> tag to every page, or even something as trivial as adding a CSS class to the nav element, still means opening every template to make the change.\n\nThereâs no way to accurately predict all the changes that might be needed over the lifetime of the website, so instead the approach I showed you at the beginning of this chapter is actually better:\n\n<!doctype html> <html> <head> <meta charset=\"utf-8\"> <link rel=\"stylesheet\" href=\"jokes.css\"> <title><?=$title?></title> </head> <body> <header> <h1>Internet Joke Database</h1> </header> <nav> <ul> <li><a href=\"index.php\">Home</a></li> <li><a href=\"jokes.php\">Jokes List</a></li> </ul> </nav> <main> <?=$output?> </main> <footer> &copy; IJDB 2021 </footer> </body> </html>\n\nIf we always include this template, which weâll call layout.html.php, itâs possible to set the $output variable to some HTML code and have it appear on the page with the navigation and footer. The benefit of this is that, to change the date on every page of the website, weâll only need to change it in one location.\n\nIâve also snuck in a $title variable so each controller can define a value that appears between the <title> and </title> tags along with some CSS (available as jokes.css in the sample code) to make the page a little prettier.\n\nAny controller can now use include __DIR__ . '/../templates/layout.html.php'; and provide values for $output and $title.\n\nOur jokes.php using layout.html.php is coded as shown below.\n\nExample: MySQL-ListJokes-Layout-1\n\n<?php try { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'SELECT `joketext` FROM `joke`'; $result = $pdo->query($sql); while ($row = $result->fetch()) { $jokes[] = $row['joketext']; } $title = 'Joke list'; $output = ''; foreach ($jokes as $joke) { $output .= '<blockquote>'; $output .= '<p>'; $output .= $joke; $output .= '</p>'; $output .= '</blockquote>'; } } catch (PDOException $e) { $title = 'An error has occurred'; $output = 'Database error: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); } include __DIR__ . '/../templates/layout.html.php';\n\nBut wait! Whatâs going on with $output in the try block? The $output variable actually contains some HTML code: the loop builds a string containing the HTML code for the jokes list.\n\nIn principle, this is what we want to happen: the $output variable contains the HTML code thatâs going to be inserted between the navigation and the footer in layout.html.php, but I think youâll agree the code is incredibly ugly.\n\nI already showed you how to avoid mixing HTML and PHP code via the include statement. Like we did earlier, it would be good to move the HTML for displaying the jokes to its own file â but this time, only the HTML code thatâs unique to the joke list page.\n\njokes.html.php in the templates directory should contain this code:\n\n<?php foreach ($jokes as $joke): ?> <blockquote> <p> <?=htmlspecialchars($joke, ENT_QUOTES, 'UTF-8')?> </p> </blockquote> <?php endforeach; ?>\n\nImportantly, this is only the code for displaying the jokes. It doesnât contain the navigation, footer, <head> tag or anything we want repeated on every page; itâs only the HTML code thatâs unique to the joke list page.\n\nTo use this template, you might try the following:\n\nwhile ($row = $result->fetch()) { $jokes[] = $row['joketext']; } $title = 'Joke list'; include 'jokes.html.php'; }\n\nOr if youâre very clever:\n\nwhile ($row = $result->fetch()) { $jokes[] = $row['joketext']; } $title = 'Joke list'; $output = include 'jokes.html.php'; }\n\nWith this approach, your logic would be entirely sound. We need to include jokes.html.php. Unfortunately, the include statement just executes the code from the included file at the point itâs called. If you run the code above, the output will actually be something like this:\n\n<blockquote> <p> A programmer was found dead in the shower. The instructions read: lather, rinse, repeat. </p> </blockquote> <blockquote> <p> !false - it's funny because it's true </p> </blockquote> <!doctype html> <html> <head> <meta charset=\"utf-8\"> <title>Joke List</title> </head> <body> â¦\n\nBecause jokes.html.php is included first, itâs sent to the browser first. What we need to do is load jokes.html.php, but instead of sending the output straight to the browser, we need to capture it and store it in the $output variable so that it can be used later by layout.html.php.\n\nThe include statement doesnât return a value, so $output = include 'jokes.html.php'; doesnât have the desired effect, and PHP doesnât have an alternative statement to do that. However, that doesnât mean that itâs not possible.\n\nPHP does have a useful feature called âoutput bufferingâ. It might sound complicated, but the concept is actually very simple: when you use echo to print something, or include to include a file that contains HTML, usually itâs sent directly to the browser. By making use of output buffering, instead of having the output being sent straight to the browser, the HTML code is stored on the server in a âbufferâ, which is basically just a string containing everything thatâs been printed so far.\n\nEven better, PHP lets you turn on the buffer and read its contents at any time.\n\nThere are two functions we need:\n\nob_start(), which starts the output buffer. After calling this function, anything printed via echo or HTML printed via include will be stored in a buffer rather than sent to the browser.\n\nob_get_clean(), which returns the contents of the buffer and clears it.\n\nAs youâve probably guessed, âobâ in the function names stands for âoutput bufferâ.\n\nTo capture the contents of an included file, we just need to make use of these two functions:\n\nwhile ($row = $result->fetch()) { $jokes[] = $row['joketext']; } $title = 'Joke list'; // Start the buffer ob_start(); // Include the template. The PHP code will be executed, // but the resulting HTML will be stored in the buffer // rather than sent to the browser. include __DIR__ . '/../templates/jokes.html.php'; // Read the contents of the output buffer and store them // in the $output variable for use in layout.html.php $output = ob_get_clean(); }\n\nWhen this code runs, the $output variable will contain the HTML that was generated in the jokes.html.php template.\n\nWeâll use this approach from now on. Each page will be made up of two templates:\n\nlayout.html.php, which contains all of the common HTML needed by every page\n\na unique template that contains only the HTML code thatâs unique to that particular page\n\nThe complete jokes.php looks like this:\n\ntry { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'SELECT `joketext` FROM `joke`'; $result = $pdo->query($sql); while ($row = $result->fetch()) { $jokes[] = $row['joketext']; } $title = 'Joke list'; ob_start(); include __DIR__ . '/../templates/jokes.html.php'; $output = ob_get_clean(); } catch (PDOException $e) { $title = 'An error has occurred'; $output = 'Database error: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); } include __DIR__ . '/../templates/layout.html.php';\n\nLetâs make the âHomeâ link work by adding an index.php file. We could put anything on this page: the latest jokes, the best joke of the month, or whatever we like. For now, though, weâll keep it simple and just have a message that says âWelcome to the Internet Joke Databaseâ.\n\nCreate a file called home.html.php in the templates folder:\n\n<h2>Internet Joke Database</h2> <p>Welcome to the Internet Joke Database</p>\n\nOur index.php is considerably simpler than jokes.html.php. It doesnât get any information from the database, so it doesnât need a database connection and we donât need a try â¦ catch statement, so weâll just load the two templates and set the $title and $output variables.\n\nExample: MySQL-ListJokes-Layout-3\n\n<?php $title = 'Internet Joke Database'; ob_start(); include __DIR__ . '/../templates/home.html.php'; $output = ob_get_clean(); include __DIR__ . '/../templates/layout.html.php';\n\nNote: itâs good practice to only connect to the database if you need to. Databases are the most common performance bottleneck on many websites, so making as few connections as possible is preferred.\n\nTest that both pages work in your browser. You should have a list of jokes visible when you visit https://v.je/jokes.php and the welcome message on https://v.je/jokes.php. Both pages should contain the navigation and the footer.\n\nTry amending layout.html.php. The changes you make will appear on both pages. If the site had dozens of pages, changes to the layout would affect every page.\n\nInserting Data into the Database\n\nIn this section, Iâll demonstrate how to use the tools at your disposal to enable site visitors to add their own jokes to the database.\n\nIf you want to let your site visitors enter new jokes, youâll obviously need a form. Hereâs a template for a form that will fit the bill:\n\n<form action=\"\" method=\"post\"> <label for=\"joketext\">Type your joke here:</label> <textarea id=\"joketext\" name=\"joketext\" rows=\"3\" cols=\"40\"> </textarea> <input type=\"submit\" name=\"submit\" value=\"Add\"> </form>\n\nSave this as addjoke.html.php in the templates directory.\n\nThe most important part of the <form> element is the action attribute. The action attribute tells the browser where to send the data once the form is submitted. This can be the name of a file, such as \"addjoke.php\".\n\nHowever, if you leave the attribute empty by setting it to \"\", the data provided by the user will be sent back to the page youâre currently viewing. If the browserâs URL shows the page as addjoke.php, thatâs were the data will be sent when the user presses the Add button.\n\nLetâs tie this form into the preceding example, which displayed the list of jokes in the database. Open up layout.html.php and add a URL to the âAdd a new Jokeâ link that goes to addjoke.php:\n\n<!doctype html> <html> <head> <meta charset=\"utf-8\"> <link rel=\"stylesheet\" href=\"jokes.css\"> <title><?=$title?></title> </head> <body> <nav> <header> <h1>Internet Joke Database</h1> </header> <ul> <li><a href=\"index.php\">Home</a></li> <li><a href=\"jokes.php\">Jokes List</a></li> <li><a href=\"addjoke.php\">Add a new Joke</a></li> </ul> </nav> <main> <?=$output?> </main> <footer> &copy; IJDB 2021 </footer> </body> </html>\n\nWhile you have layout.html.php open, include the form.css stylesheet from Chapter 2 as I have above. Now, any form displayed inside the layout will have the styles we used before.\n\nWhen this form is submitted, the request will include a variable â joketext â that contains the text of the joke as typed into the text area. This variable will then appear in the $_POST array created by PHP.\n\nLetâs create addjoke.php in the public directory. The basic logic for this controller is:\n\nIf no joketext POST variable is set, display a form.\n\nOtherwise, insert the supplied joke into the database.\n\nCreate this skeleton addjoke.php:\n\n<?php if (isset($_POST['joketext'])) { try { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); } catch (PDOException $e) { $title = 'An error has occurred'; $output = 'Database error: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); } } else { $title = 'Add a new joke'; ob_start(); include __DIR__ . '/../templates/addjoke.html.php'; $output = ob_get_clean(); } include __DIR__ . '/../templates/layout.html.php';\n\nThis opening if statement checks if the $_POST array contains a variable called joketext. If itâs set, the form has been submitted. Otherwise, the form from addjoke.html.php is loaded into the $output variable for displaying in the browser.\n\nIf you do open addjoke.php in your browser at this point, youâll see the form, but typing in a joke and pressing Add wonât work, because we havenât yet done anything with the data contained in $_POST['joketext'].\n\nTo insert the submitted joke into the database, we must execute an INSERT query using the value stored in $_POST['joketext'] to fill in the joketext column of the joke table. This might lead you to write some code like this:\n\n$sql = 'INSERT INTO `joke` SET `joketext` =\"' . $_POST['joketext'] . '\", `jokedate` =\"2021-02-04\"'; $pdo->exec($sql);\n\nThereâs a serious problem with this code, however: the contents of $_POST['joketext'] are entirely under the control of the user who submitted the form. If a malicious user were to type some nasty SQL code into the form, this script would feed it to your MySQL server without question. This type of attack is called an SQL injection attack, and in the early days of PHP it was one of the most common security holes that hackers found and exploited in PHP-based websites. (In many programming niches, SQL injection attacks are still surprisingly effective, as developers donât expect them. Consider this remarkable attempt to cause traffic cameras to drop their databases: âSQL Injection License Plate Hopes to Foil Euro Traffic Camerasâ.)\n\nA user might type this into the text box:\n\nHow many programmers does it take to screw in a lightbulb? None. It's a hardware problem.\n\nThe query sent to the database would be as follows:\n\nINSERT INTO `joke` SET `joketext` =\"How many programmers does it take to screw in a lightbulb? None. It's a hardware problem.\", `jokedate` =\"2021-02-04\n\nBut what if the user types in the following:\n\nA programmer's wife tells him to go to the store and \"get a gallon of milk, and if they have eggs, get a dozen.\" He returns with 13 gallons of milk.\n\nIn this case, the query sent to the database will be this:\n\nINSERT INTO `joke` SET `joketext`=\"A programmer's wife tells him to go to the store and \"get a gallon of milk, and if they have eggs, get a dozen.\" He returns with 13 gallons of milk.\", `jokedate`=\"2021-02-04\n\nBecause the joke contains a quote character, MySQL will return an error, as it will see the quote before âgetâ as the end of the string.\n\nTo make this a valid query, we need to escape all quotes in the text so that the query sent to the database becomes this:\n\nINSERT INTO `joke` SET `joketext`=\"A programmer's wife tells him to go to the store and \\\"get a gallon of milk, and if they have eggs, get a dozen.\\\" He returns with 13 gallons of milk.\", `jokedate`=\"2021-02-04\n\nData not being inserted if it contains a quote is an annoying problem for users. Theyâll lose whatever they typed in. But malicious users are able to abuse this. In older versions of PHP, it was possible to run multiple queries from PHP by separating them with a semicolon (;).\n\nImagine if the user were to type this into the box:\n\n\"; DELETE FROM `joke`; --\n\nThis would send the following queries to the database:\n\nINSERT INTO `joke` SET `joketext`=\"\"; DELETE FROM `joke`; --`jokedate`=\"2021-02-04\n\n-- is a single line comment in MySQL, so the last line would be ignored, and the INSERT query would run, followed by the DELETE query the user had typed into the box. In fact, the user could type any query they liked into the box and it would be run on the database!\n\nMagic Quotes\n\nIn the early days of PHP, SQL injection attacks were so feared that the team behind PHP added some built-in protections against SQL injections to the language. Firstly, they disabled the ability to send multiple queries at once. Secondly, they added something called magic quotes. This protective feature of PHP automatically analyzed all values submitted by the browser and inserted backslashes (\\) in front of any âdangerousâ characters like apostrophes â which can cause problems if theyâre included in an SQL query inadvertently.\n\nThe problem with the magic quotes feature is that it caused as many problems as it prevented. First of all, the characters that it detected, and the method it used to sanitize them (prefixing them with a backslash), were only valid in some circumstances. Depending on the character encoding of your site and the database server you were using, these measures could be completely ineffective.\n\nSecond, when a submitted value was used for some purpose other than creating an SQL query, those backslashes could be really bothersome. The magic quotes feature would insert a spurious backslash into the userâs last name if it contained an apostrophe.\n\nIn short, the magic quotes feature was a bad idea â so much so that it was removed from PHP from version 5.4. However, due to PHPâs age and the amount of code out there, you might come across some references to it, so itâs worth having a basic understanding of what the magic quotes feature was supposed to do.\n\nOnce magic quotes was identified as a bad idea, the advice from PHP developers was to turn it off. However, this meant that there were some web servers with it turned off and others with it turned on. This was a headache for developers: they either had to instruct everyone who was ever going to use their code to turn it off â which wasnât possible on some shared servers â or write extra code to account for it.\n\nMost developers chose the latter, and you may come across some code like this:\n\nif (get_magic_quotes_gpc()) { // code here }\n\nIf you see an if statement like this in legacy code youâve been given to work with, you can safely delete the entire block, as no code inside the if statement will ever be executed on recent PHP versions.\n\nIf you do see code like this, it means the original developer understood the problems with magic quotes and was doing their best to prevent it. As of PHP 5.4 (which you should never come across, as itâs no longer supported), get_magic_quotes_gpc() will always return false and the code will never be executed.\n\nAll you really need to know about magic quotes is that it was a bad solution to the problem at hand. Of course, without magic quotes, you need to find a different solution to the problem. Luckily, the PDO class can do all the hard work for you, by using something called âprepared statementsâ.\n\nPrepared Statements\n\nA prepared statement is a special kind of SQL query that youâve sent to your database server ahead of time, giving the server a chance to prepare it for execution â but not actually execute it. Think of it like writing a .php script. The code is there, but it doesnât actually get run until you visit the page in your web browser. The SQL code in prepared statements can contain placeholders that youâll supply the values for later, when the query is to be executed. When filling in these placeholders, PDO is smart enough to guard against âdangerousâ characters automatically.\n\nHereâs how to prepare an INSERT query and then execute it safely with $_POST['joketext'] as the text of the joke:\n\n$sql = 'INSERT INTO `joke` SET `joketext` = :joketext, `jokedate` = \"today's date\"'; $stmt = $pdo->prepare($sql); $stmt->bindValue(':joketext', $_POST['joketext']); $stmt->execute();\n\nLetâs break this down, one statement at a time. First, we write our SQL query as a PHP string and store it in a variable ($sql) as usual. Whatâs unusual about this INSERT query, however, is that no value is specified for the joketext column. Instead, it contains a placeholder for this value (:joketext). Donât worry about the jokedate field just now; weâll circle back to it in a moment.\n\nNext, we call the prepare method of our PDO object ($pdo), passing it our SQL query as an argument. This sends the query to the MySQL server, asking it to prepare to run the query. MySQL canât run it yet, as thereâs no value for the joketext column. The prepare method returns a PDOStatement object (yes, the same kind of object that gives us the results from a SELECT query), which we store in $stmt.\n\nNow that MySQL has prepared our statement for execution, we can send it the missing value(s) by calling the bindValue method of our PDOStatement object ($stmt). We call this method once for each value to be supplied (in this case, we only need to supply one value â the joke text), passing as arguments the placeholder that we want to fill in (':joketext') and the value we want to fill it with ($_POST['joketext']). Because MySQL knows weâre sending it a discrete value, rather than SQL code that needs to be parsed, thereâs no risk of characters in the value being interpreted as SQL code. When using prepared statements, SQL injection vulnerabilities simply arenât possible!\n\nFinally, we call the PDOStatement objectâs execute method to tell MySQL to execute the query with the value(s) weâve supplied. (Yes, this PDOStatement method is called execute, unlike the similar method of PDO objects, which is called exec. PHP has many strengths, but consistency isnât one of them!)\n\nOne interesting thing youâll notice about this code is that we never placed quotes around the joke text. :joketext exists inside the query without any quotes, and when we called bindValue we passed it the plain joke text from the $_POST array. When using prepared statements, you donât need quotes because the database (in our case, MySQL) is smart enough to know that the text is a string and it will be treated as such when the query is executed.\n\nThe lingering question in this code is how to assign todayâs date to the jokedate field. We could write some fancy PHP code to generate todayâs date in the YYYY-MM-DD format that MySQL requires, but it turns out that MySQL itself has a function to do this â CURDATE:\n\n$sql = 'INSERT INTO `joke` SET `joketext` = :joketext, `jokedate` = CURDATE()'; $stmt = $pdo->prepare($sql); $stmt->bindValue(':joketext', $_POST['joketext']); $stmt->execute();\n\nThe MySQL CURDATE function is used here to assign the current date as the value of the jokedate column. MySQL actually has dozens of these functions, but Iâll introduce them only as required.\n\nNow that we have our query, we can complete the if statement we started earlier to handle submissions of the âAdd Jokeâ form:\n\nif (isset($_POST['joketext'])) { try { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'INSERT INTO `joke` SET `joketext` = :joketext, `jokedate` = CURDATE()'; $stmt = $pdo->prepare($sql); $stmt->bindValue(':joketext', $_POST['joketext']); $stmt->execute(); } catch (PDOException $e) { $title = 'An error has occurred'; $output = 'Database error: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); } }\n\nBut wait! This if statement has one more trick up its sleeve. Once weâve added the new joke to the database, instead of displaying the PHP template as previously, we want to redirect the userâs browser back to the list of jokes. That way, users are able to see the newly added joke among them. Thatâs what the two lines at the end of the if statement above do.\n\nIn order to achieve the desired result, your first instinct might be to allow the controller to simply fetch the list of jokes from the database after adding the new joke and displaying the list using the jokes.html.php template as usual. The problem with doing this is that the list of jokes, from the browserâs perspective, would be the result of having submitted the âAdd Jokeâ form. If the user were then to refresh the page, the browser would resubmit that form, causing another copy of the new joke to be added to the database! This is rarely the desired behavior.\n\nInstead, we want the browser to treat the updated list of jokes as a normal web page thatâs able to be reloaded without resubmitting the form. The way to do this is to answer the browserâs form submission with an HTTP redirect â a special response that tells the browser to navigate to a different page. (HTTP stands for HyperText Transfer Protocol, and is the language that describes the request/response communications that are exchanged between the visitorâs web browser and your web server.)\n\nThe PHP header function provides the means of sending special server responses like this one, by letting you insert specific headers into the response sent to the browser. In order to signal a redirect, you must send a Location header with the URL of the page you want to direct the browser to:\n\nheader('Location: URL');\n\nIn this case, we want to send the browser to jokes.php. Here are the two lines that redirect the browser back to our controller after adding the new joke to the database:\n\nheader('Location: jokes.php');\n\nBelow is the complete code of the addjoke.php controller.\n\nExample: MySQL-AddJoke\n\n<?php if (isset($_POST['joketext'])) { try { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'INSERT INTO `joke` SET `joketext` = :joketext, `jokedate` = CURDATE()'; $stmt = $pdo->prepare($sql); $stmt->bindValue(':joketext', $_POST['joketext']); $stmt->execute(); header('location: jokes.php'); } catch (PDOException $e) { $title = 'An error has occurred'; $output = 'Database error: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); } } else { $title = 'Add a new joke'; ob_start(); include __DIR__ . '/../templates/addjoke.html.php'; $output = ob_get_clean(); } include __DIR__ . '/../templates/layout.html.php';\n\nAs you review this to ensure it all makes sense to you, note that the code that connects to the database by creating a new PDO object must come before any of the code that runs database queries. But a database connection isnât required for displaying the âAdd Jokeâ form. The connection is only made when the form has been submitted.\n\nLoad this up and add a new joke or two to the database via your browser.\n\nThere you have it: youâre able to view existing jokes in â and add new jokes to â your MySQL database.\n\nDeleting Data from the Database\n\nIn this section, weâll make one final enhancement to our joke database site. Next to each joke on the jokes page (jokes.php), weâll place a button labeled Delete. When clicked, it will remove that joke from the database and display the updated joke list.\n\nIf you like a challenge, you might want to take a stab at writing this feature yourself before you read on to see my solution. Although weâre implementing a brand new feature, weâll mainly be using the same tools as employed in the previous examples in this chapter. Here are a few hints to start you off:\n\nYouâll need a new controller (deletejoke.php).\n\nThe SQL DELETE command will be required, which I introduced in Chapter 3.\n\nTo delete a particular joke in your controller, youâll need to identify it uniquely. The id column in the joke table was created to serve this purpose. Youâre going to have to pass the ID of the joke to be deleted with the request to delete a joke. The easiest way to do this is to use a hidden form field.\n\nAt the very least, take a few moments to think about how youâd approach this. When youâre ready to see the solution, read on!\n\nTo begin with, we need to modify the SELECT query that fetches the list of jokes from the database. In addition to the joketext column, we must also fetch the id column so that we can identify each joke uniquely:\n\ntry { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'SELECT `id`, `joketext` FROM `joke`'; $result = $pdo->query($sql); // â¦\n\nWe also have to modify the while loop that stores the database results into the $jokes array. Instead of simply storing the text of each joke as an item in the array, we store both the ID and text of each joke. One way to do this is to make each item in the $jokes array an array in its own right:\n\nwhile ($row = $result->fetch()) { $jokes[] = ['id' => $row['id'], 'joketext' => $row['joketext']]; }\n\nNote: if youâve already switched to using a foreach loop to process your database result rows, that will work just fine too:\n\nforeach ($result as $row) { $jokes[] = array('id' => $row['id'], 'joketext' => $row['joketext']); }\n\nOnce this loop runs its course, weâll have the $jokes array, each item of which is an associative array with two items: the ID of the joke and its text. For each joke ($jokes[n]), we can therefore retrieve its ID ($jokes[n]['id']) and its text ($jokes[n]['text']).\n\nOur next step is to update the jokes.html.php template to retrieve each jokeâs text from this new array structure, as well as provide a Delete button for each joke:\n\n<?php foreach ($jokes as $joke): ?> <blockquote> <p> <?=htmlspecialchars($joke['joketext'], ENT_QUOTES, 'UTF-8')?> <form action=\"deletejoke.php\" method=\"post\"> <input type=\"hidden\" name=\"id\" value=\"<?=$joke['id']?>\"> <input type=\"submit\" value=\"Delete\"> </form> </p> </blockquote> <?php endforeach; ?>\n\nHere are the highlights of this updated code:\n\nEach joke will be displayed with a form, which, if submitted, will delete that joke. We signal this to a new controller, deletejoke.php, using the formâs action attribute.\n\nSince each joke in the $jokes array is now represented by a two-item array instead of a simple string, we must update this line to retrieve the text of the joke. We do this using $joke['text'] instead of just $joke.\n\nWhen we submit the form to delete this joke, we send along the ID of the joke to be deleted. To do this, we need a form field containing the jokeâs ID, but weâd prefer to keep this field hidden from the user; thatâs why we use a hidden form field (input type=\"hidden\"). The name of this field is id, and its value is the ID of the joke to be deleted ($joke['id']).Unlike the text of the joke, the ID is not a user-submitted value, so thereâs no need to worry about making it HTML-safe with htmlspecialchars. We can rest assured it will be a number, since itâs automatically generated by MySQL for the id column when the joke is added to the database.\n\nThe submit button (input type=\"submit\") submits the form when clicked. Its value attribute gives it a label of Delete.\n\nFinally, we close the form for this joke.\n\nNote: if you know your HTML, youâre probably thinking the form and input tags belong outside of the blockquote element, since they arenât a part of the quoted text (the joke).\n\nStrictly speaking, thatâs true: the form and its inputs should really be either before or after the blockquote. Unfortunately, making that tag structure display clearly requires a little CSS (cascading style sheets) code thatâs really beyond the scope of this book.\n\nRather than teach you CSS layout techniques in a book about PHP and MySQL, Iâve decided to go with this imperfect markup. If you plan to use this code in the real world, you should invest some time into learning CSS (or at least secure the services of a CSS guru). That way, you can take complete control of your HTML markup without worrying about the CSS required to make it look nice. If you want to learn more about CSS layouts, take a look at CSS Master, 3rd Edition, by Tiffany Brown.\n\nAdd the following CSS to jokes.css to make the buttons appear to the right of the jokes and draw a line between them:\n\nblockquote {display: table; margin-bottom: 1em; border-bottom: 1px solid #ccc; padding: 0.5em;} blockquote p {display: table-cell; width: 90%; vertical-align: top;} blockquote form {display: table-cell; width: 10%;}\n\nThe following image shows what the joke list looks like with the Delete buttons added.\n\nBut wait! Before we move on to making the Delete button work, letâs briefly step back and take a careful look at this line:\n\n$jokes[] = ['id' => $row['id'], 'joketext' => $row['joketext']];\n\nHere, weâre looping over the PDOStatement object, which gives us a $row variable containing the keys id and joketext along with corresponding values, and weâre using that to build another array with the same keys and values.\n\nYou may have already realized this is terribly inefficient. We could achieve the same thing using this code:\n\nwhile ($row = $result->fetch()) { $jokes[] = $row; }\n\nBut as we know, this can also be achieved with a foreach loop:\n\nforeach ($result as $row) { $jokes[] = $row; }\n\nIn this instance, weâre using foreach to iterate over the records from the database and build an array. Weâre then looping over the array with another foreach loop in the template. We could just write this:\n\n$jokes = $result;\n\nNow, when $jokes is iterated over in the template, itâs not an array but a PDOStatement object. However, that has no effect on the output and saves us some code. In fact, we can omit the $result variable altogether and load the PDOStatement object directly into the $jokes variable. The complete jokes.php controller now looks like this:\n\ntry { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'SELECT `joketext`, `id` FROM joke'; $jokes = $pdo->query($sql); $title = 'Joke list'; ob_start(); include __DIR__ . '/../templates/jokes.html.php'; $output = ob_get_clean(); } catch (PDOException $e) { $title = 'An error has occurred'; $output = 'Database error: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); } include __DIR__ . '/../templates/layout.html.php';\n\nNow we donât even have a while loop iterating over the records in the controller, but just iterate over the records directly in the template, saving some code and making the page execute slightly faster, as it now only loops over the records once.\n\nBack to our new Delete button: all that remains to make this new feature work is to add a relevant deletejoke.php to issue a DELETE query to the database:\n\ntry { $pdo = new PDO('mysql:host=mysql;dbname=ijdb;charset=utf8mb4', 'ijdbuser', 'mypassword'); $sql = 'DELETE FROM `joke` WHERE `id` = :id'; $stmt = $pdo->prepare($sql); $stmt->bindValue(':id', $_POST['id']); $stmt->execute(); header('location: jokes.php'); } catch (PDOException $e) { $title = 'An error has occurred'; $output = 'Unable to connect to the database server: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine(); } include __DIR__ . '/../templates/layout.html.php';\n\nThe complete code for the updated jokes.php and deletejoke.php is available as Example: MySQL-DeleteJoke.\n\nThis chunk of code works exactly like the one we added to process the âAdd Jokeâ code earlier in the chapter. We start by preparing a DELETE query with a placeholder for the joke ID that we want to delete.\n\nTip: you might think that a prepared statement is unnecessary in this instance to protect our database from SQL injection attacks, since the joke ID is provided by a hidden form field invisible to the user. In fact, all form fields â even hidden ones â are ultimately under the userâs control. There are widely distributed browser add-ons, for example, that will make hidden form fields visible and available for editing by the user. Remember: any value submitted by the browser is ultimately suspect when it comes to protecting your siteâs security.\n\nWe then bind the submitted value of $_POST['id'] to that placeholder and execute the query. Once that query is achieved, we use the PHP header function to ask the browser to send a new request to view the updated list of jokes.\n\nNote: if you tackled this example yourself, your first instinct might have been to provide a Delete hyperlink for each joke, instead of going to the trouble of writing an entire HTML form containing a Delete button for each joke on the page. Indeed, the code for such a link would be much simpler:\n\n<?php foreach ($jokes as $joke): ?> <blockquote> <p> <?=htmlspecialchars($joke['joketext'], ENT_QUOTES, 'UTF-8')?> <a href=\"deletejoke.php&amp;id=<?=$joke['id']?>\">Delete</a> </p> </blockquote> <?php endforeach; ?>\n\nIn short, hyperlinks should never be used to perform actions (such as deleting a joke). They must only be used to provide a link to some related content. The same goes for forms with method=\"get\", which should only be used to perform queries of existing data. Actions must only ever be performed as a result of a form with method=\"post\" being submitted.\n\nThe reason for this is that forms with method=\"post\" are treated differently by browsers and related software. If you were to submit a form with method=\"post\" and then click the refresh button in your browser, for example, the browser would ask if youâre certain you want to resubmit the form. Browsers have no similar protection against resubmission when it comes to links and forms with method=\"get\".\n\nSearch engines and other web crawlers will also follow all the links on your site in order to work out when to show your siteâs pages in search results.\n\nIf your site deleted a joke as a result of a hyperlink being followed, you could find your jokes being deleted whenever a search engine finds your site.\n\nMission Accomplished\n\nIn this chapter, you learned all about PHP Data Objects (PDO), a collection of built-in PHP classes (PDO, PDOException, and PDOStatement) that allow you to interface with a MySQL database server by creating objects and then calling the methods they provide. While you were at it, you also picked up the basics of object-oriented programming (OOP) â which is no mean feat for a PHP beginner!\n\nUsing PDO objects, you built your first database-driven website, which published the ijdb database online and allowed visitors to add and delete jokes.\n\nIn a way, you could say this chapter achieved the stated mission of this book: to teach you how to build a database-driven website. Of course, the example in this chapter contained only the bare essentials. In the rest of the book, Iâll show you how to flesh out the skeleton you learned to build in this chapter.\n\nIn Chapter 5, weâll return to the SQL Query window in MySQL Workbench. Weâll learn how to use relational database principles and advanced SQL queries to represent more complex types of information, and give our visitors credit for the jokes they add!\n\nWe hope youâve enjoyed this excerpt from PHP & MySQL: Novice to Ninja, 7th Edition. The full book is available on SitePoint Premium and from your favorite book and ebook retailers.\n\nFAQs About Displaying Data from MySQL on the Web"
    }
}