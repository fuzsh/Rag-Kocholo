{
    "id": "dbpedia_8284_1",
    "rank": 54,
    "data": {
        "url": "https://www.sitepoint.com/using-node-mysql-javascript-client/",
        "read_more_link": "",
        "language": "en",
        "title": "Using MySQL with Node.js and the mysql JavaScript Client",
        "top_image": "https://uploads.sitepoint.com/wp-content/uploads/2018/01/1579220934node-mysql.png",
        "meta_img": "https://uploads.sitepoint.com/wp-content/uploads/2018/01/1579220934node-mysql.png",
        "images": [
            "https://uploads.sitepoint.com/wp-content/uploads/2019/02/1550836753jim1-150x150.jpg",
            "https://uploads.sitepoint.com/wp-content/uploads/2015/05/1432813633pic_enhached-96x96.jpg",
            "https://uploads.sitepoint.com/wp-content/uploads/2018/01/1579220934node-mysql.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2019/12/1576846289adminer-01.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2019/12/1576861579adminer-02.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2019/02/1550836753jim1-150x150.jpg",
            "https://uploads.sitepoint.com/wp-content/uploads/2015/05/1432813633pic_enhached-96x96.jpg",
            "https://cdn.sanity.io/images/708bnrs8/production/56eefa864f8139d1f9340235a77b6e7fdcf7ed52-282x352.png?w=282&h=352&auto=format",
            "https://cdn.sanity.io/images/708bnrs8/production/56eefa864f8139d1f9340235a77b6e7fdcf7ed52-282x352.png?w=282&h=352&auto=format",
            "https://uploads.sitepoint.com/wp-content/uploads/2016/12/1484049395node2017A-01-300x167.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://uploads.sitepoint.com/wp-content/uploads/2016/09/1472890331raspberrypiandbluemixfeature3-300x168.png",
            "https://uploads.sitepoint.com/wp-content/uploads/2023/08/1692781397fallback.svg",
            "https://www.facebook.com/tr?id=721455246308784&ev=PageView&noscript=1"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "James Hibbard",
            "Jay Raj"
        ],
        "publish_date": "2020-01-20T22:00:55+00:00",
        "summary": "",
        "meta_description": "This guide shows how to use the mysql module to connect to your database and perform basic CRUD operations.",
        "meta_lang": "",
        "meta_favicon": "/favicons/48x48.png",
        "meta_site_name": "",
        "canonical_link": "https://www.sitepoint.com/using-node-mysql-javascript-client/",
        "text": "NoSQL databases are rather popular among Node developers, with MongoDB (the âMâ in the MEAN stack) leading the pack. When starting a new Node project, however, you shouldnât just accept Mongo as the default choice. Rather, the type of database you choose should depend on your projectâs requirements. If, for example, you need dynamic table creation, or real-time inserts, then a NoSQL solution is the way to go. If your project deals with complex queries and transactions, on the other hand, an SQL database makes much more sense.\n\nIn this tutorial, weâll have a look at getting started with the mysql module â a Node.js client for MySQL, written in JavaScript. Iâll explain how to use the module to connect to a MySQL database and perform the usual CRUD operations, before looking at stored procedures and escaping user input.\n\nThis popular article was updated in 2020 to reflect current practices for using MySQL with Node.js. For more on MySQL, read Jump Start MySQL.\n\nQuick Start: How to Use MySQL in Node\n\nIf youâve arrived here looking for a quick way to get up and running with MySQL in Node, weâve got you covered!\n\nHereâs how to use MySQL in Node in five easy steps:\n\nCreate a new project: mkdir mysql-test && cd mysql-test.\n\nCreate a package.json file: npm init -y.\n\nInstall the mysql module: npm install mysql.\n\nCreate an app.js file and copy in the snippet below (editing the placeholders as appropriate).\n\nRun the file: node app.js. Observe a âConnected!â message.\n\nconst mysql = require('mysql'); const connection = mysql.createConnection({ host: 'localhost', user: 'user', password: 'password', database: 'database name' }); connection.connect((err) => { if (err) throw err; console.log('Connected!'); });\n\nInstalling the mysql Module\n\nNow letâs take a closer look at each of those steps.\n\nmkdir mysql-test cd mysql-test npm init -y npm install mysql\n\nFirst of all weâre using the command line to create a new directory and navigate to it. Then weâre creating a package.json file using the command npm init -y. The -y flag means that npm will use defaults without going through an interactive process.\n\nThis step also assumes that you have Node and npm installed on your system. If this is not the case, then check out this SitePoint article to find out how to do that: Install Multiple Versions of Node.js using nvm.\n\nAfter that, weâre installing the mysql module from npm and saving it as a project dependency. Project dependencies (as opposed to devDependencies) are those packages required for the application to run. You can read more about the differences between the two here.\n\nIf you need further help using npm, then be sure to check out this guide, or ask in our forums.\n\nGetting Started\n\nBefore we get on to connecting to a database, itâs important that you have MySQL installed and configured on your machine. If this is not the case, please consult the installation instructions on their home page.\n\nThe next thing we need to do is to create a database and a database table to work with. You can do this using a\n\ngraphical interface, such as Adminer, or using the command line. For this article Iâll be using a database called sitepoint and a table called authors. Hereâs a dump of the database, so that you can get up and running quickly if you wish to follow along:\n\nCREATE DATABASE sitepoint CHARACTER SET utf8 COLLATE utf8_general_ci; USE sitepoint; CREATE TABLE authors ( id int(11) NOT NULL AUTO_INCREMENT, name varchar(50), city varchar(50), PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=5 ; INSERT INTO authors (id, name, city) VALUES (1, 'Michaela Lehr', 'Berlin'), (2, 'Michael Wanyoike', 'Nairobi'), (3, 'James Hibbard', 'Munich'), (4, 'Karolina Gawron', 'WrocÅaw');\n\nConnecting to the Database\n\nNow, letâs create a file called app.js in our mysql-test directory and see how to connect to MySQL from Node.js.\n\nconst mysql = require('mysql'); const con = mysql.createConnection({ host: 'localhost', user: 'user', password: 'password', }); con.connect((err) => { if(err){ console.log('Error connecting to Db'); return; } console.log('Connection established'); }); con.end((err) => { });\n\nNow open up a terminal and enter node app.js. Once the connection is successfully established you should be able to see the âConnection establishedâ message in the console. If something goes wrong (for example, you enter the wrong password), a callback is fired, which is passed an instance of the JavaScript Error object (err). Try logging this to the console to see what additional useful information it contains.\n\nUsing nodemon to Watch the Files for Changes\n\nRunning node app.js by hand every time we make a change to our code is going to get a bit tedious, so letâs automate that. This part isnât necessary to follow along with the rest of the tutorial, but will certainly save you some keystrokes.\n\nLetâs start off by installing a the nodemon package. This is a tool that automatically restarts a Node application when file changes in a directory are detected:\n\nnpm install --save-dev nodemon\n\nNow run ./node_modules/.bin/nodemon app.js and make a change to app.js. nodemon should detect the change and restart the app.\n\nNote: weâre running nodemon straight from the node_modules folder. You could also install it globally, or create an npm script to kick it off.\n\nExecuting Queries\n\nReading\n\nNow that you know how to establish a connection to a MySQL database from Node.js, letâs see how to execute SQL queries. Weâll start by specifying the database name (sitepoint) in the createConnection command:\n\nconst con = mysql.createConnection({ host: 'localhost', user: 'user', password: 'password', database: 'sitepoint' });\n\nOnce the connection is established, weâll use the con variable to execute a query against the database table authors:\n\ncon.query('SELECT * FROM authors', (err,rows) => { if(err) throw err; console.log('Data received from Db:'); console.log(rows); });\n\nWhen you run app.js (either using nodemon or by typing node app.js into your terminal), you should be able to see the data returned from the database logged to the terminal:\n\n[ RowDataPacket { id: 1, name: 'Michaela Lehr', city: 'Berlin' }, RowDataPacket { id: 2, name: 'Michael Wanyoike', city: 'Nairobi' }, RowDataPacket { id: 3, name: 'James Hibbard', city: 'Munich' }, RowDataPacket { id: 4, name: 'Karolina Gawron', city: 'WrocÅaw' } ]\n\nData returned from the MySQL database can be parsed by simply looping over the rows object.\n\nrows.forEach( (row) => { console.log(`${row.name} lives in ${row.city}`); });\n\nThis gives you the following:\n\nMichaela Lehr lives in Berlin Michael Wanyoike lives in Nairobi James Hibbard lives in Munich Karolina Gawron lives in WrocÅaw\n\nCreating\n\nYou can execute an insert query against a database, like so:\n\nconst author = { name: 'Craig Buckler', city: 'Exmouth' }; con.query('INSERT INTO authors SET ?', author, (err, res) => { if(err) throw err; console.log('Last insert ID:', res.insertId); });\n\nNote how we can get the ID of the inserted record using the callback parameter.\n\nUpdating\n\nSimilarly, when executing an update query, the number of rows affected can be retrieved using result.affectedRows:\n\ncon.query( 'UPDATE authors SET city = ? Where ID = ?', ['Leipzig', 3], (err, result) => { if (err) throw err; console.log(`Changed ${result.changedRows} row(s)`); } );\n\nDestroying\n\nThe same thing goes for a delete query:\n\ncon.query( 'DELETE FROM authors WHERE id = ?', [5], (err, result) => { if (err) throw err; console.log(`Deleted ${result.affectedRows} row(s)`); } );\n\nAdvanced Use\n\nIâd like to finish off by looking at how the mysql module handles stored procedures and the escaping of user input.\n\nStored Procedures\n\nPut simply, a stored procedure is prepared SQL code that you can save to a database, so that it can easily be reused. If youâre in need of a refresher on stored procedures, then check out this tutorial.\n\nLetâs create a stored procedure for our sitepoint database which fetches all the author details. Weâll call it sp_get_authors. To do this, youâll need some kind of interface to the database. Iâm using Adminer. Run the following query against the sitepoint database, ensuring that your user has admin rights on the MySQL server:\n\nDELIMITER $ CREATE PROCEDURE `sp_get_authors`() BEGIN SELECT id, name, city FROM authors; END $\n\nThis will create and store the procedure in the information_schema database in the ROUTINES table.\n\nNote: if the delimiter syntax looks strange to you, itâs explained here.\n\nNext, establish a connection and use the connection object to call the stored procedure as shown:\n\ncon.query('CALL sp_get_authors()',function(err, rows){ if (err) throw err; console.log('Data received from Db:'); console.log(rows); });\n\nSave the changes and run the file. Once itâs executed, you should be able to view the data returned from the database:\n\n[ [ RowDataPacket { id: 1, name: 'Michaela Lehr', city: 'Berlin' }, RowDataPacket { id: 2, name: 'Michael Wanyoike', city: 'Nairobi' }, RowDataPacket { id: 3, name: 'James Hibbard', city: 'Leipzig' }, RowDataPacket { id: 4, name: 'Karolina Gawron', city: 'WrocÅaw' }, OkPacket { fieldCount: 0, affectedRows: 0, insertId: 0, serverStatus: 34, warningCount: 0, message: '', protocol41: true, changedRows: 0 } ]\n\nAlong with the data, it returns some additional information, such as the affected number of rows, insertId etc. You need to iterate over the 0th index of the returned data to get employee details separated from the rest of the information:\n\nrows[0].forEach( (row) => { console.log(`${row.name} lives in ${row.city}`); });\n\nThis gives you the following:\n\nMichaela Lehr lives in Berlin Michael Wanyoike lives in Nairobi James Hibbard lives in Leipzig Karolina Gawron lives in WrocÅaw\n\nNow letâs consider a stored procedure which requires an input parameter:\n\nDELIMITER $ CREATE PROCEDURE `sp_get_author_details`( in author_id int ) BEGIN SELECT name, city FROM authors where id = author_id; END $\n\nWe can pass the input parameter while making a call to the stored procedure:\n\ncon.query('CALL sp_get_author_details(1)', (err, rows) => { if(err) throw err; console.log('Data received from Db:\\n'); console.log(rows[0]); });\n\nThis gives you the following:\n\n[ RowDataPacket { name: 'Michaela Lehr', city: 'Berlin' } ]\n\nMost of the time when we try to insert a record into the database, we need the last inserted ID to be returned as an out parameter. Consider the following insert stored procedure with an out parameter:\n\nDELIMITER $ CREATE PROCEDURE `sp_insert_author`( out author_id int, in author_name varchar(25), in author_city varchar(25) ) BEGIN insert into authors(name, city) values(author_name, author_city); set author_id = LAST_INSERT_ID(); END $\n\nTo make a procedure call with an out parameter, we first need to enable multiple calls while creating the connection. So, modify the connection by setting the multiple statement execution to true:\n\nconst con = mysql.createConnection({ host: 'localhost', user: 'user', password: 'password', database: 'sitepoint', multipleStatements: true });\n\nNext, when making a call to the procedure, set an out parameter and pass it in:\n\ncon.query( \"SET @author_id = 0; CALL sp_insert_author(@author_id, 'Craig Buckler', 'Exmouth'); SELECT @author_id\", (err, rows) => { if (err) throw err; console.log('Data received from Db:\\n'); console.log(rows); } );\n\nAs seen in the above code, we have set an @author_id out parameter and passed it while making a call to the stored procedure. Once the call has been made we need to select the out parameter to access the returned ID.\n\nRun app.js. On successful execution you should be able to see the selected out parameter along with various other information. rows[2] should give you access to the selected out parameter:\n\n[ RowDataPacket { '@author_id': 6 } ] ]\n\nNote: To delete a stored procedure you need to run the command DROP PROCEDURE <procedure-name>; against the database you created it for.\n\nEscaping User Input\n\nIn order to avoid SQL Injection attacks, you should always escape any data you receive from users before using it inside an SQL query. Letâs demonstrate why:\n\nconst userSubmittedVariable = '1'; con.query( `SELECT * FROM authors WHERE id = ${userSubmittedVariable}`, (err, rows) => { if(err) throw err; console.log(rows); } );\n\nThis seems harmless enough and even returns the correct result:\n\n{ id: 1, name: 'Michaela Lehr', city: 'Berlin' }\n\nHowever, try changing the userSubmittedVariable to this:\n\nconst userSubmittedVariable = '1 OR 1=1';\n\nWe suddenly have access to the entire data set. Now change it to this:\n\nconst userSubmittedVariable = '1; DROP TABLE authors';\n\nWeâre now in proper trouble!\n\nThe good news is that help is at hand. You just have to use the mysql.escape method:\n\ncon.query( `SELECT * FROM authors WHERE id = ${mysql.escape(userSubmittedVariable)}`, (err, rows) => { if(err) throw err; console.log(rows); } );\n\nYou can also use a question mark placeholder, as we did in the examples at the beginning of the article:\n\ncon.query( 'SELECT * FROM authors WHERE id = ?', [userSubmittedVariable], (err, rows) => { if(err) throw err; console.log(rows); } );\n\nWhy Not Just USE an ORM?\n\nBefore we get into the pros and cons of this approach, letâs take a second to look at what ORMs are. The following is taken from an answer on Stack Overflow:\n\nObject-Relational Mapping (ORM) is a technique that lets you query and manipulate data from a database using an object-oriented paradigm. When talking about ORM, most people are referring to a library that implements the Object-Relational Mapping technique, hence the phrase âan ORMâ.\n\nSo this means you write your database logic in the domain-specific language of the ORM, as opposed to the vanilla approach weâve been taking so far. To give you an idea of what this might look like, hereâs an example using Sequelize, which queries the database for all authors and logs them to the console:\n\nconst sequelize = new Sequelize('sitepoint', 'user', 'password', { host: 'localhost', dialect: 'mysql' }); const Author = sequelize.define('author', { name: { type: Sequelize.STRING, }, city: { type: Sequelize.STRING }, }, { timestamps: false }); Author.findAll().then(authors => { console.log(\"All authors:\", JSON.stringify(authors, null, 4)); });\n\nWhether or not using an ORM makes sense for you will depend very much on what youâre working on and with whom. On the one hand, ORMS tend to make developers more productive, in part by abstracting away a large part of the SQL so that not everyone on the team needs to know how to write super efficient database specific queries. Itâs also easy to move to different database software, because youâre developing to an abstraction.\n\nOn the other hand however, it is possible to write some really messy and inefficient SQL as a result of not understanding how the ORM does what it does. Performance is also an issue in that itâs much easier to optimize queries that donât have to go through the ORM.\n\nWhichever path you take is up to you, but if this is a decision youâre in the process of making, check out this Stack Overflow thread: Why should you use an ORM?. Also check out this post on SitePoint: 3 JavaScript ORMs You Might Not Know.\n\nConclusion\n\nIn this tutorial, weâve installed the mysql client for Node.js and configured it to connect to a database. Weâve also seen how to perform CRUD operations, work with prepared statements and escape user input to mitigate SQL injection attacks. And yet, weâve only scratched the surface of what the mysql client offers. For more detailed information, I recommend reading the official documentation.\n\nAnd please bear in mind that the mysql module is not the only show in town. There are other options too, such as the popular node-mysql2.\n\nFAQs on Using MySQL with Node.js"
    }
}