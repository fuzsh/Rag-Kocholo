A new campaign has started to try and preserve video games that become unplayable when the developer and/or publisher no longer wishes to support them.

This post is mostly a collection of random commentary on games that I have tried to order as coherently as possible.

For a more succinct description of the problem and what you can do to support, visit StopKillingGames.com.

Growing up with games

This is a topic that I feel strongly about. I grew up playing video games. The first games I remember playing were on a Commodore 64. The first that were my own were on a Nintendo GameBoy and Sega Master System. Since then I’ve owned many consoles and computers. I’ve owned a few that were essentially “before my time” like an Atari 2600. In fact I first got into programming on a Sinclair ZX Spectrum.

This means I have a lot of memories playing video games, and for most of that time I knew that those games would remain playable indefinitely. The reality of hardware degradation means that for practical purposes most people would have to resort to emulation, but in theory someone who owned the original game would always be able to play it.

That is no longer the case for many modern games.

New games

There are some games that fundamentally require server resources to run. For some those those can be run by individuals - many early MMOs like Ultima Online have private servers for instance. Others like EVE Online might never be reasonable to run locally. And despite the fact that I would like these to remain playable indefinitely, these are not really the games that concern me the most.

Live service games

The games for which this is a problem is live service games, especially ones with a significant single player component. I think if a practical solution is to be found, then the “single player” aspect is going to have to be important - after all a mostly multiplayer live service game is pretty close to an MMO.

One sticking point is disagreement between the people running the game and the people playing the game what kind of game it is. Both Diablo III* and Diablo IV require an online connection to play, and the latter certainly adds quite a lot of content that only really works online. But a large number of players, including myself, only play it solo. But I have also played both Star Trek Online and Elder Scrolls Online (which are definitely MMOs) predominantly alone.

* Interestingly, Diablo III on console did not require an online connection. The result was hacked save files, which meant choosing to play with strangers online was awkward. But playing alone was fine.

Ubisoft and The Crew

This issue has come to prominence recently after Ubisoft decided to shut down The Crew. This is not a game I have played but it sounds like it falls to the sticking point I mention above. A lot of the game is based around being online and playing with others, but not all of it.

Ubisoft are making the opinion of the problem quite clear though, apparently taking things a step further and revoking digital licenses. This seems like a crazy move - I can imagine people making well reasoned arguments about companies not having to put resources into supporting games, but that doesn’t really hold any water when considering removing all access to people with digital games.

What to do

StopKillingGames.com is probably the bast place to go for information on how you can help. I would also suggest being as selective as you are able in the developers and publishers you support. For me, I personally spend more time playing single player indie games which generally don’t have this problem (being the digital license issue).

My games

For my own games (currently this means Tic-Tac-Toe Collection but I intend it to apply to anything else I ever make) I will always follow the principle of not requiring an online connection unnecessarily. That means that core functionality should not require it at all, and any features that do require it should not impact the rest of the game.

I have accidentally proven this a few times by managing online resources badly and allowing services to go offline. The game continued to work fine.

In .NET 7 (previewed in .NET 6) a series of new interfaces were introduced to make work with mathematical operations easier.

.NET has had generics almost forever allowing you to write algorithms that work with many different types, but this hasn’t been possible for basic maths until this was introduced.

The main reason this has been done now is for machine learning and AI implementations where the classic computing tradeoff of speed vs. space appears - if you’re dealing with very large arrays of numbers, maybe you want to switch from a 64 bit double to 32 bit float (or even the newly introduced 16 bit half).

The in-progress implementation of my expanded Elo rating system is based on this for that reason.

Fixed-point arithmetic

There is another reason to use the interfaces though - perhaps you want a completely different implementation of the basic mathematical operations. One example would be fixed-point arithmetic instead of floating-point arithmetic.

The biggest reason to do this is because floating-point arithmetic is not, in practice, deterministic.

More about floating-point arithmetic determinism

This is a subtle topic. Any specific IEE 754 floating point operation is deterministic for the same inputs. But those inputs include various settings that might change unexpectedly, and things like reordering of operations will give you different results due to rounding.

And it is even worse in .NET (ironically) because of its portable nature. Your code could be JIT compiled completely out of your control on many different processor architectures.

Here are some more resources about it:

Floating Point Determinism - Gaffer on Games

Floting-Point Determinism - Bruce Dawson

Understanding Determinism Part 1: Intro and Floating Points - Shader Fun

There have been a few implementations of fixed-point arithmetic in .NET:

FixedPointy

FixedMath.Net

FixPointCS

That last one is fairly recent (it targets .NET 6) and is MIT licensed, so I decided to see if I could modify it to support the generic math interfaces.

GamesWithGravitas.FixMath

The (still in-progress) result is available here in GitHub.

It takes the F32 and F64 types from FixPointCS and implements the following interfaces:

INumber

IBinaryNumber

ISignedNumber

IRootFunctions

ITrigonometricFunction

Most of the work is forwarding to the existing implementations. Some of the things that I had to actually write code for:

Formatting and parsing

There are a bunch of methods relating to converting to and from strings. My implementation uses double as an intermediate type. I guess these have the chance to not be deterministic but for the things I’d use it for it would not matter.

TryConvertFrom… and TryConvertTo…

These methods are used to convert between these types and others. They come in three versions: Checked, Truncating and Saturating. I have currently implemented all three to do the same thing.

A while ago I bought Mapominoes Europe on a whim, and I’m now having to fight the urge to buy its many variations/expansions.

As the title suggests it is broadly based on dominoes, but instead of placing tiles by the numbers they have in common, it is based on countries with shared borders. Also unlike dominoes the cards are played not in a line but in a grid, and all neighbours have to be compatible.

The mechanics are simple enough to pick up and the game is quite suitable for children - I’m having fun playing with my six year old. It does hide some surprising depth though.

All the cards are dealt between the players and the goal is to be the first to play all your cards. Every player also starts with a pair of transit cards which can be played as stand-ins for either a sea (which are listed on the cards just like countries) or as another country. You get an extra turn if you can play a card bordering more than one card, and miss a turn if you are forced to draw another transit card because you can’t go.

There are several versions of the game, some of which are compatible with each other and can be combined into a larger game. The compatibles ones are:

Europe

Asia & Australasia

Africa

Americas (N&S)

There are also two standalone games:

USA (states)

United Kingdom (counties)

After getting the Europe set I also got the Asia & Australasia set. Despite it taking up a lot of space, playing with those two was a lot of fun. Trying to play game with more than two would be challenging I think (although specifically in the case of those two it is helped by both sets containing Russia and Turkey).

One final feature my expanded Elo rating needs (or at least the last I can think of) is the ability to deal with ad hoc teams.

By “ad hoc teams”, I mean teams of individual players with their own ratings that are on the same team for a specific game, but don’t generally stay as a team (established teams that always play together should be treated as their own “players” with their own rating).

This is not a common requirement, but the specific use case I had was an office ping pong table. Some times people would play singles and some times they would play doubles, but with no really established teams.

Necessary features

Firstly, the two key ratings operations need to work:

Estimate the result of an unplayed game

Updating ratings after an actual result

And all the existing features should be supported:

Two or more teams

Unfair games

Ties

Additionally, it should support teams of arbitrary (and mixed) sizes, including teams of size one. This brings us to one of our first less-obvious requirements - since this is expanding an existing system, it should be compatible with the existing system where it overlaps. So the following additional requirement makes sense:

Teams of one should give the same result as just using individuals

Simple solution

Just like with unfair games in which an adjusted rating is calculated first, and then used in the rest of the algorithm, and adjusted rating should be calculated for a team. This would trivially allow all the existing features to just work.

The most obvious way to calculate such a rating would be a simple arithmetic mean of all the players. This would definitely support our key requirement, but would it produce meaningful results?

At this point I think simplicity has to win out over sophistication. The most general solution would allow players to be weighted on each team (perhaps different roles in a team have different impacts on the result) but I think those situations are more likely to be handled with a per team rating.