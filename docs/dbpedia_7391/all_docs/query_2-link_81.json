{
    "id": "dbpedia_7391_2",
    "rank": 81,
    "data": {
        "url": "https://nrich.maths.org/2199",
        "read_more_link": "",
        "language": "en",
        "title": "The Knapsack Problem and Public Key Cryptography",
        "top_image": "https://nrich.maths.org/sites/default/files/nrich_logo_D_0.png",
        "meta_img": "https://nrich.maths.org/sites/default/files/nrich_logo_D_0.png",
        "images": [
            "https://nrich.maths.org/sites/default/files/styles/large/public/2023-12/University_of_Cambridge_logo_white_600.png?itok=eUDcO68D",
            "https://nrich.maths.org/sites/default/files/2023-12/nrich-logo_white.svg",
            "https://nrich.maths.org/sites/default/files/styles/large/public/thumbnails/content-04-03-article3-knapsack-export.png?itok=IYbx4kw4",
            "https://nrich.maths.org/themes/nrich/images/twitter-x_white.png",
            "https://nrich.maths.org/themes/nrich/images/facebook-logo.png",
            "https://nrich.maths.org/sites/default/files/styles/large/public/2023-12/University_of_Cambridge_logo_white_600.png?itok=eUDcO68D",
            "https://nrich.maths.org/sites/default/files/2023-12/nrich-logo_white.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2011-02-01T00:00:01+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/sites/default/files/nrich_logo_D_0.png",
        "meta_site_name": "",
        "canonical_link": "https://nrich.maths.org/articles/knapsack-problem-and-public-key-cryptography",
        "text": "Image\n\nPublic-Key cryptography was invented in the 1970s by Whitfield Diffie, Martin Hellman and Ralph Merkle.\n\nPublic-key cryptography needs two keys. One key tells you how to encrypt (or code) a message and this is \"public\" so anyone can use it. The other key allows you to decode (or decrypt) the message. This decryption code is kept secret (or private) so only the person who knows the key can decrypt the message. It is also possible for the person with the private key to encrypt a message with the private key, then anyone holding the public key can decrypt the message, although this seems to be of little use if you are trying to keep something secret!\n\nThe First General Public-Key Algorithm used what we call the Knapsack Algorithm. Although we now know that this algorithm is not secure we can use it to look at how these types of encryption mechanisms work.\n\nThe knapsack algorithm works like this:\n\nImagine you have a set of different weights which you can use to make any total weight that you need by adding combinations of any of these weights together.\n\nLet us look at an example:\n\nImagine you had a set of weights 1, 6, 8, 15 and 24. To pack a knapsack weighing 30, you could use weights 1, 6, 8 and 15. It would not be possible to pack a knapsack that weighs 17 but this might not matter.\n\nYou might represent the weight 30 by the binary code 11110 (one 1, one 6, one 8, one 15 and no 24).\n\nExample:\n\nPlain text 10011 11010 01011 00000 Knapsack 1 6 8 15 24 1 6 8 15 24 1 6 8 15 24 1 6 8 15 24 Cipher text 1 + 15 + 24 = 40 1 + 6 + 15 = 22 6 + 15 + 24 = 45 0 = 0\n\nWhat total weights is it possible to make?\n\nSo, if someone sends you the code 38 this can only have come from the plain text 01101.\n\nWhen the Knapsack Algorithm is used in public key cryptography, the idea is to create two different knapsack problems. One is easy to solve, the other not. Using the easy knapsack, the hard knapsack is derived from it. The hard knapsack becomes the public key. The easy knapsack is the private key. The public key can be used to encrypt messages, but cannot be used to decrypt messages. The private key decrypts the messages.\n\nThe Superincreasing Knapsack Problem\n\nAn easy knapsack problem is one in which the weights are in a superincreasing sequence. A superincreasing sequence is one in which the next term of the sequence is greater than the sum of all preceding terms. For example, the set {1, 2, 4, 9, 20, 38} is superincreasing, but the set {1, 2, 3, 9, 10, 24} is not because 10 < 1+2+3+9.\n\nIt is easy to solve a superincreasing knapsack. Simply take the total weight of the knapsack and compare it with the largest weight in the sequence. If the total weight is less than the number, then it is not in the knapsack. If the total weight is greater then the number, it is in the knapsack. Subtract the number from the total, and compare with the next highest number. Keep working this way until the total reaches zero. If the total doesn't reach zero, then there is no solution.\n\nSo, for example, if you have a knapsack that weighs 23 that has been made from the weights of the superincreasing series {1, 2, 4, 9, 20, 38} then it does not contain the weight 38 (as 38 > 23)\n\nbut it does contain the weight 20; leaving 3;\n\nwhich does not contain the weight 9 still leaving 3;\n\nwhich does not contain the weight 4 still leaving 3;\n\nwhich contains the weight 2, leaving 1; which contains the weight 1.\n\nThe binary code is therefore 110010.\n\nIt is much harder to decrypt a non-superincreasing knapsack problem. Give a friend a non-superincreasing knapsack and a total and see why this is the case.\n\nOne algorithm that uses a superincreasing knapsack for the private (easy) key and a non-superincreasing knapsack for the public key was created by Merkle and Hellman They did this by taking a superincreasing knapsack problem and converting it into a non-superincreasing one that could be made public, using modulus arithmetic.\n\nMaking the Public Key\n\nTo produce a normal knapsack sequence, take a superincreasing sequence; e.g. {1, 2, 4, 10, 20, 40}. Multiply all the values by a number, n, modulo m. The modulus should be a number greater than the sum of all the numbers in the sequence, for example, 110. The multiplier should have no factors in common with the modulus. So let's choose 31. The normal knapsack sequence would be:\n\n1$\\times$31 mod(110) = 31\n\n2$\\times$31 mod(110) = 62\n\n4$\\times$31 mod(110) = 14\n\n10$\\times$31 mod(110) = 90\n\n20$\\times$31 mod(110) = 70\n\n40$\\times$31 mod(110) = 30\n\nSo the public key is: {31, 62, 14, 90, 70, 30} and\n\nthe private key is {1, 2, 4, 10, 20.40}.\n\nLet's try to send a message that is in binary code:\n\n100100111100101110\n\nThe knapsack contains six weights so we need to split the message into groups of six:\n\n100100\n\n111100\n\n101110\n\nThis corresponds to three sets of weights with totals as follows\n\n100100 = 31 + 90 = 121\n\n111100 = 31+62+14+90 = 197\n\n101110 = 31+14+90+70 =205\n\nSo the coded message is 121 197 205.\n\nNow the receiver has to decode the message...\n\nThe person decoding must know the two numbers 110 and 31 (the modulus and the multiplier). Let's call the modulus \"m\" and the number you multiply by \"n\".\n\nWe need $n^{-1}$, which is a multiplicative inverse of n mod m, i.e. $n(n^{-1})$ = 1 mod m\n\nIn this case I have calculated $n^{-1}$ to be 71.\n\nAll you then have to do is multiply each of the codes 71 mod 110 to find the total in the knapsack which contains {1, 2, 4, 10, 20, 40} and hence to decode the message.\n\nThe coded message is 121 197 205:\n\n121$\\times$71 mod(110) = 11 = 100100\n\n197$\\times$71 mod(110) = 17 = 111100\n\n205$\\times$71 mod(110) = 35 = 101110\n\nThe decoded message is:\n\n100100111100101110.\n\nJust as I thought!\n\nSimple and short knapsack codes are far too easy to break to be of any real use. For a knapsack code to be reasonably secure it would need well over 200 terms each of length 200 bits."
    }
}