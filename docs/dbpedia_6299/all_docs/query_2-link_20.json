{
    "id": "dbpedia_6299_2",
    "rank": 20,
    "data": {
        "url": "https://www.instructables.com/The-Simpsons-TV-35-Screen-Version/",
        "read_more_link": "",
        "language": "en",
        "title": "The Simpsons TV - 3.5\" Screen Version",
        "top_image": "https://content.instructables.com/F1B/N7UR/KZQZW38R/F1BN7URKZQZW38R.png?auto=webp&frame=1&width=2100",
        "meta_img": "https://content.instructables.com/F1B/N7UR/KZQZW38R/F1BN7URKZQZW38R.png?auto=webp&frame=1&width=2100",
        "images": [
            "https://www.instructables.com/assets/img/instructables-logo-2023.svg",
            "https://www.instructables.com/assets/img/license/by-nc-sa_small.png",
            "https://content.instructables.com/F1B/N7UR/KZQZW38R/F1BN7URKZQZW38R.png?auto=webp&fit=bounds&frame=1&height=1024&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FB4/0R0D/KZ9UMYF1/FB40R0DKZ9UMYF1.png?auto=webp&fit=bounds&frame=1&height=1024&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FVP/PE1T/KZTUTN3L/FVPPE1TKZTUTN3L.png?auto=webp&fit=bounds&frame=1&height=1024&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FTQ/LFTB/LDU95H60/FTQLFTBLDU95H60.png?auto=webp&fit=bounds&frame=1&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FB4/FTQK/KZ9UNH35/FB4FTQKKZ9UNH35.png?auto=webp&fit=bounds&frame=1&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FLC/ZPBH/KZBA259A/FLCZPBHKZBA259A.png?auto=webp&fit=bounds&frame=1&height=1024&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/F6J/S7XV/L01C2QBK/F6JS7XVL01C2QBK.png?auto=webp&fit=bounds&frame=1&height=1024&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/static/image/file.default.gif",
            "https://content.instructables.com/static/image/file.default.gif",
            "https://content.instructables.com/FI8/8L0H/KZSFCL6P/FI88L0HKZSFCL6P.png?auto=webp&fit=bounds&frame=1&height=1024&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FX7/T7TK/KZVAABGT/FX7T7TKKZVAABGT.png?auto=webp&fit=bounds&frame=1&height=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FR9/2XK8/KZTUTWF8/FR92XK8KZTUTWF8.png?auto=webp&fit=bounds&frame=1&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FY7/C9T9/KZTUTWE7/FY7C9T9KZTUTWE7.png?auto=webp&fit=bounds&frame=1&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FWX/70K1/KZTUTWI3/FWX70K1KZTUTWI3.png?auto=webp&fit=bounds&frame=1&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FWX/PSCW/KZTUTWNM/FWXPSCWKZTUTWNM.png?auto=webp&fit=bounds&frame=1&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FWY/O3BK/KZ7C4WR4/FWYO3BKKZ7C4WR4.png?auto=webp&fit=bounds&frame=1&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FDW/LLXY/KZ7C4X7Z/FDWLLXYKZ7C4X7Z.png?auto=webp&fit=bounds&frame=1&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FD0/EGRE/KZ7C4X80/FD0EGREKZ7C4X80.png?auto=webp&fit=bounds&frame=1&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/F0R/OUP6/KZLA737C/F0ROUP6KZLA737C.png?auto=webp&fit=bounds&frame=1auto=webp&frame=1&height=300",
            "https://content.instructables.com/static/image/file.default.gif",
            "https://content.instructables.com/static/image/file.default.gif",
            "https://content.instructables.com/FES/4A7M/KZVA9NSO/FES4A7MKZVA9NSO.png?auto=webp&fit=bounds&frame=1&height=1024&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/FCR/D6E3/KZVA9NSP/FCRD6E3KZVA9NSP.png?auto=webp&fit=bounds&frame=1&height=1024&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/F2A/LHQQ/KZVA9NSQ/F2ALHQQKZVA9NSQ.png?auto=webp&fit=bounds&frame=1&width=1024auto=webp&frame=1&height=300",
            "https://content.instructables.com/F34/ZSUI/KZWPOUFZ/F34ZSUIKZWPOUFZ.png?auto=webp&fit=bounds&frame=1auto=webp&frame=1&height=300",
            "https://content.instructables.com/FIT/LALT/M09L1S7P/FITLALTM09L1S7P.jpg?auto=webp&crop=1.2%3A1&frame=1&width=306",
            "https://content.instructables.com/FIT/LALT/M09L1S7P/FITLALTM09L1S7P.jpg?auto=webp&crop=1.2%3A1&frame=1&width=306",
            "https://content.instructables.com/FKW/KF0I/LZIFL01X/FKWKF0ILZIFL01X.jpg?auto=webp&crop=1.2%3A1&frame=1&width=306",
            "https://content.instructables.com/FKW/KF0I/LZIFL01X/FKWKF0ILZIFL01X.jpg?auto=webp&crop=1.2%3A1&frame=1&width=306",
            "https://content.instructables.com/F0A/YNA7/M02SN0FM/F0AYNA7M02SN0FM.png?auto=webp&crop=1.2%3A1&frame=1&width=306",
            "https://content.instructables.com/F0A/YNA7/M02SN0FM/F0AYNA7M02SN0FM.png?auto=webp&crop=1.2%3A1&frame=1&width=306",
            "https://content.instructables.com/F86/RLOQ/LZTV38V5/F86RLOQLZTV38V5.png?auto=webp&crop=1.2%3A1&frame=1&width=306",
            "https://content.instructables.com/F86/RLOQ/LZTV38V5/F86RLOQLZTV38V5.png?auto=webp&crop=1.2%3A1&frame=1&width=306",
            "https://content.instructables.com/F0P/EWRI/LZVJW1CA/F0PEWRILZVJW1CA.jpg?auto=webp&crop=1240%2C600&frame=1&width=320",
            "https://content.instructables.com/F0P/EWRI/LZVJW1CA/F0PEWRILZVJW1CA.jpg?auto=webp&crop=1240%2C600&frame=1&width=320",
            "https://content.instructables.com/F6K/D4XP/LYEF8Y3Q/F6KD4XPLYEF8Y3Q.jpg?auto=webp&crop=1240%2C600&frame=1&width=320",
            "https://content.instructables.com/F6K/D4XP/LYEF8Y3Q/F6KD4XPLYEF8Y3Q.jpg?auto=webp&crop=1240%2C600&frame=1&width=320",
            "https://content.instructables.com/FCA/3VGX/LYHJZS5E/FCA3VGXLYHJZS5E.jpg?auto=webp&crop=1240%2C600&frame=1&width=320",
            "https://content.instructables.com/FCA/3VGX/LYHJZS5E/FCA3VGXLYHJZS5E.jpg?auto=webp&crop=1240%2C600&frame=1&width=320",
            "https://www.instructables.com/assets/img/footer/autodesk-logo-primary-white.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Instructables"
        ],
        "publish_date": "2022-02-25T00:00:00",
        "summary": "",
        "meta_description": "The Simpsons TV - 3.5\" Screen Version: I discovered the \"Build A Simpsons TV\" article in the Volume 79 issue of Make: magazine. The article is by Brandon Withrow and he did an excellent job documenting the build process in the article and on a dedicated web site: www.withrow.io/simpsons-…",
        "meta_lang": "en",
        "meta_favicon": "/assets/img/siteassets/favicon.ico",
        "meta_site_name": "Instructables",
        "canonical_link": "https://www.instructables.com/The-Simpsons-TV-35-Screen-Version/",
        "text": "19,616\n\n131\n\nFeatured\n\nIntroduction: The Simpsons TV - 3.5\" Screen Version\n\nI discovered the \"Build A Simpsons TV\" article in the Volume 79 issue of Make: magazine. The article is by Brandon Withrow and he did an excellent job documenting the build process in the article and on a dedicated web site: www.withrow.io/simpsons-tv-build-guide. As I embarked building my own Simpsons TV, I ran into issues being able to obtain the 2.8\" display specified in the build instructions as well as audio and OS issues. So, I thought I would take my learnings and present them here for others who might find them useful. In the end, I built my Simpsons TV using a 3.5\" display available on Amazon, fixed the audio issues, and enhanced the functionality of the project by adding play/pause, rewind, next video, change \"channel\", exit python script, and safe power shutdown features.\n\nOf particular note is the safe power shutdown feature. The Raspberry Pi OS features a journaling file system. This means that it can be writing to the SD card at any time. This can potentially be bad if you just remove power without executing a proper shutdown sequence. How bad can this be? Well, let's just say that I've completely ruined several SD cards on Raspberry Pis before I learned this lesson (they had to be thrown away - nonrecoverable). To address this, I created a simple circuit using an Atmega ATtiny microcontroller to monitor the power switch, send a signal to the Pi to shutdown, monitor the activity LED signal on the Pi, then safely remove power from the Pi once all activity has ceased. There are other options to address the safe power shutdown needed by the Pi without using a dedicated microcontroller, which I'll also cover in this Instructable.\n\nThis Instructable is rather long due to me including a lot of low-level details about all the steps required to build this project. My intent is to provide a fun learning experience on topics such as 3D printing, ATtiny microcontrollers, Raspberry Pi, Python, some Arduino, and soldering. I hope you enjoy!\n\nNow, let's get started...\n\nSupplies\n\nMost of the supplies are the same as those called out on Brandon's website. I've copied them here for completeness with modifications based on my build.\n\n3D Printed Parts (https://www.thingiverse.com/thing:5257326):\n\nTV Housing\n\nTV Front\n\nVCR\n\nAntennae Balls (2x)\n\nPower Switch Actuator\n\nPower Switch Base\n\nVolume Knob\n\nVolume Knob Base\n\nTV Foot (4x - Front Left, Front Right, Rear Left, Rear Right)\n\nFront Grille\n\nElectronic Parts:\n\nAC to DC power adapter - 5VDC @3A with micro USB output connector\n\nRaspberry Pi Zero 2 W\n\niUniker 3.5-inch Raspberry Pi Zero display, 480 x 320 resolution (Amazon)\n\nAdafruit mono 2.5W class D audio amplifier board (Amazon)\n\n64GB Ultra Micro SDHC memory card (Amazon)\n\nATtiny25 microcontroller (NOTE: ATtiny45 or ATtiny85 will work as well - they have the same pinout and functionality, just more memory - any variant will work, just get the DIP package version: Amazon)\n\n8-pin IC DIP socket (Amazon)\n\n1k Ohm potentiometer (I bought a kit of multiple values: Amazon)\n\n6mm x 6mm x 6mm push micro momentary push button (2x - kit of switches: Amazon)\n\n7mm x 7mm push-on/off push button (included in the kit of switches above)\n\nMicro USB to DIP adapter (Amazon)\n\nGikfun 4 Ohm 40mm diameter 3W speaker (Amazon)\n\nIRF4905 P-FET power transistor or similar (Amazon)\n\n40-pin, 2 x 20, extended pin socket header (Amazon)\n\nPC Board\n\n100 Ohm, 1/4 W resistor (included in resistor assortment kit: Amazon or similar)\n\n220 Ohm, 1/4 W resistor (included in resistor assortment kit)\n\n330 Ohm, 1/4 W resistor (2x) (included in resistor assortment kit)\n\n0.1uF 50V ceramic capacitor (2x) (Amazon)\n\n1N4148 rectifier diode (2x) (Amazon)\n\n1 pin header (snap off larger header - crimp sockets and header pin kit: Amazon or similar)\n\n2 pin header, 0.1\" spacing (2x) (snap off larger header from header kit above)\n\n1 pin DuPont socket with female crimp pin (3x) (included with crimp socket kit above)\n\n2 pin DuPont socket with female crimp pins (4x) (included with crimp socket kit above)\n\n3 pin DuPont socket with female crimp pins (included with crimp socket kit above)\n\nSignal Wire (included with crimp socket kit above - usually 28 AWG)\n\n22 AWG Wire - about 2 feet (half red/half black or similar: Amazon)\n\n~1\" / 25mm of 30AWG solid wire (Amazon).\n\nTools & Misc Supplies:\n\nSoldering Iron\n\nSolder (I prefer Kester 0.020\" diameter 24-7068 lead-free as 60/40 Sn/Pb lead-based solders are toxic).\n\nHot Melt Glue Gun\n\nHot Melt Glue\n\nSuper Glue (cyanoacrylate)\n\nCrimpers (for socket crimps - included with the crimp sockets and header pin kit mentioned above)\n\nWire cutters\n\nWire strippers\n\nMini file set (with round and flat files - used to clean up 3D printed parts)\n\nRustoleum Universal Paint and Primer gloss black spray paint or whatever paint you want to use to paint the bezel.\n\nPainter's tape (for masking off the bezel area for painting)\n\nCotton swabs\n\nIsopropyl alcohol\n\nProgrammer for ATtiny (Arduino UNO or dedicated programmer such as AVRISP mkII or similar)\n\n10uF capacitor (for Arduino UNO if it is used to program the ATtiny)\n\nUSB keyboard (to set up Pi)\n\nUSB micro to USB B converter (if needed to connect keyboard and USB thumb drive to Pi)\n\nHDMI mini to HDMI converter (if needed to connect HDMI monitor to Pi)\n\nBreadboard (used to aid in programming the ATtiny microcontroller)\n\nDuPont wires (used to connect programmer to ATtiny on breadboard for programming) (Amazon)\n\n1/4\" diameter x 1/16\" thick (6mm x 1.5mm) neodymium magnets (4x) (Amazon). Other similar sizes can be used, but you may have to modify the TV housing and TV front 3D model files to fit.\n\n#6 x 3/8\" machine screws (2x)\n\nStep 1: 3D Design\n\nThe 3D STL files Brandon provided were for a 2.8\" screen version. Unfortunately, STL files are not ideal for the significant modifications I needed to make to fit my 3.5\" screen version. So, I went searching on Thingiverse for possible alternates that would fit my 3.5\" screen. I did not find anything that fit it directly. However, I found the next best thing! On Thingiverse, I found that highping had remodeled the 3D design for Brandon's Simpsons TV from the ground up for a 4\" HDMI screen - and - he was kind enough to include the Fusion 360 source files for his design. Also, his design featured two buttons on the VCR box that sits on top of the TV, so I was able to make use of those to implement the play/pause, rewind, next video, change \"channel\", and exit Python script features (more on these later).\n\nFor my project, I made the following modifications to the Fusion 360 files from highping:\n\nChanged the display bezel area to accommodate my 3.5\" display\n\nAdded screw holes to the VCR box and TV case to make it easy to service the buttons in the VCR should the need arise. This allows you to mount the VCR using two #6 x 3/8\" screws to the TV instead of gluing it.\n\nChanged the volume knob, volume knob base, power switch actuator, and power switch base to be compatible with the volume knob and power switch from Brandon's original design.\n\nExtended the top front alignment edge to traverse the entire front - this acts as a light block to prevent the display's backlight from bleeding out around the top gap between the TV housing and the TV front.\n\nResized the circular holes for the speaker and the four magnets to fit the parts I had on hand.\n\nAdded \"foot stop\" feature at the four bottom corners of the housing to act as secure stops and glue points for the four feet.\n\nI have posted STLs, Fusion360, Autodesk 123D Design, and STEP file variants on Thingiverse (https://www.thingiverse.com/thing:5257326) to make it easy for most anyone to modify for their purposes.\n\nStep 2: 3D Printing\n\nA total of (14) 3D printed parts are needed (reference 3D Printed Parts in the Supplies section). I printed everything using a 0.4mm nozzle, 0.2mm layer height, and 30% infill out of black, light blue, and purple PLA plastic (I used 3D Solutech plastic from Amazon - but most any PLA will do - use what works best for you and your 3D printer).\n\nThe picture shows the print orientation and color I used for each part. I didn't use any supports on the TV Housing, TV Feet, or Antennae Balls. I used minimal supports on everything else. I did not use any rafts, but printed multiple parts at the same time (or multiple copies) for smaller parts to allow some cooling time for each part in between printing layers - this helps improve print quality for the smaller parts (i.e. TV Feet, Knobs/Bases, Front Grille, and Antennae Balls).\n\nAfter 3D printing, some light filing is usually needed around the base (where the part made contact with the 3D printer bed) or where support material meets a side edge of some of the parts (knobs/bases, front grille, VCR button holes, and antennae feet) in order for them to fit correctly with mating parts. I used a set of small files to do this. You can use a hot-air rework station after filing to remove the \"whiting\" effect of filing; Use minimal heat and quick passes of the hot air to prevent warping of the part. If you've never done this before, I suggest trying this on a piece of scrap 3D printed plastic to perfect your technique.\n\nStep 3: Electronic Parts\n\nThe picture above Provides a visual reference of all the electronic parts used in this build variant of The Simpsons TV.\n\nStep 4: Raspberry Pi Zero 2 W Pinout & Resource Usage\n\nAs you can see from the figure above, most of the Pi's GPIO pins are used by the LCD screen.\n\nThe usage entries with the shaded backgrounds indicate DuPont socket connectors used to connect power, audio, VCR buttons, and the safe shutdown signal (Pi pins 2, 4, 6, 10, 22, 23, 35, 37, and 39 are used) . Additionally, the Status LED signal will be used; but, it must be accessed via a test point on the back of the board.\n\nStep 5: Wire Audio Amplifier Circuitry\n\nThe audio output on the Raspberry Pi Zero 2 W is generally provided via PWM signals on GPIO18 and GPIO19. This project only uses one channel of audio, so it only uses GPIO19 and a mono audio amplifier. The original design uses this same approach, but I changed the audio circuit to:\n\nReposition the 1k Ohm volume potentiometer from the output side of the audio amplifier to the input side. This is because these small potentiometers can be damaged by the larger current that they can be exposed to on the audio output side (at high volume / low resistance). Moving the volume potentiometer to the input side of the amplifier greatly reduces the current to which the volume potentiometer may be exposed.\n\nAdded a Volume Knob circuit to address the \"tinny\" and scratchy audio issue. This circuit is comprised of a 100 Ohm resistor, 220 Ohm resistor, and 0.1uF capacitor (Note: The 1k Ohm volume potentiometer was added to the output of this circuit to provide the volume control on the input side of the audio amplifier). These components create a filter for the harsh PWM audio signal to smooth it out before feeding it into the audio amplifier. This greatly improves the audio quality.\n\nThe picture above shows the six steps to build the audio circuit. Steps one through five show the construction of the volume knob circuit while step 6 shows how to wire the complete audio circuit (volume control knob circuit, audio amplifier, speaker, and Raspberry Pi connectors). Details for each step are as follows:\n\nStep 1 - Cut a piece of the PC Board so that it is 3 holes wide by 5 holes high as shown in Step 1. This PC Board will be used to build the volume knob circuit.\n\nStep 2 - Position the 1k Ohm potentiometer on the 3 x 5 piece of PC Board. The orientation of the potentiometer matters as the knob is NOT centered top-to-bottom (but it IS centered side-to-side); note the position of the notched end of the potentiometer shown in Step 2.\n\nStep 3 - Flip the PC Board over, make sure the pins of the potentiometer are positioned as shown in the Step 3 picture, then solder the three pins.\n\nStep 4 - Solder the 220 Ohm resistor across the two outermost pins of the potentiometer on the bottom side of the PC Board. Then, solder one end of the 100 Ohm resistor to the right pin of the potentiometer/220 Ohm resistor junction. Insert the other end of the 100 Ohm resistor in the 4th hole as shown in the Step 4 picture - solder in place. Trim all component leads using flush-cut wire cutters.\n\nStep 5 - Solder the 0.1uF capacitor across the 220 Ohm resistor leads as shown in the Step 5 picture. Trim the capacitor leads.\n\nStep 6 - Use 28 AWG signal wire to wire the speaker, audio amplifier board, volume knob circuit and Raspberry Pi connectors as shown in the Step 6 picture:\n\nWire the speaker to the amplifier with two signal wires about 4\" long (Purple and Blue). Solder all ends.\n\nSolder one end of a ~1/2\" piece of 30AWG solid wire (small blue wire) to the audio amplifier's Audio IN(-) connection. Place the other end in of the 30AWG wire into the GND hole on the audio amplifier (BUT DO NOT SOLDER YET! - two more wires will need to be inserted into this hole before soldering).\n\nSolder three signal wires (Green, Yellow, and Orange) about 6\" long to the volume knob circuit board; one wire to the GND connection (Green), one wire to the Audio OUT connection (Yellow), and one wire to the Audio IN(+) connection (Orange). Crimp a female crimp pin on the other end of the Audio IN(+) wire (Orange) and then insert it into position 3 of a 3-position socket connector as shown in the picture.\n\nSolder the other end of the Audio OUT wire (Yellow) from the volume knob circuit to the Audio IN(+) connection on the amplifier board.\n\nCut two more signal wires (Red and Brown) about 6\" long and solder one (Red) into the +5V power connection on the audio amplifier board. Crimp a female crimp pin on other other end of this wire and insert the female crimp pin into a 1-position socket connector. Insert the other wire (Brown) into the audio amplifier board's GND connection hole along with the existing 30AWG solid wire (small blue wire) previously inserted there and the GND wire from the volume knob circuit (Green) - solder all three wires in this hole. On the other end of the audio amplifier GND wire (Brown), crimp a female crimp pin and insert it into position 1 of the 3-position socket as shown in the picture above.\n\nNOTE: Of course, you can use whatever colors you like for the wiring scheme. The colors are mentioned here to match the pictures so that it's easier to keep track of what wire goes where.\n\nStep 6: Getting Ready to Program the ATtiny for Safe Shutdown Circuit\n\nThe ATmega ATtiny microcontroller can be programmed using the Arduino IDE. But, The Arduino IDE does not have this capability natively. So, this must be set up first. If you don't have the Arduino IDE, install it by going to Arduin.CC.\n\nStep 1 - Open the Arduino IDE and select File -> Preferences. In the \"Additional Manager URLs:\" field, copy/paste the following URL: https://raw.githubusercontent.com/damellis/attiny/ide-1.6.x-boards-manager/package_damellis_attiny_index.json as shown in the first picture above.\n\nStep 2 - Click \"OK\". Next, click on Tools -> Board -> Board Manager as shown in the picture above.\n\nStep 3 - In the Board Manager, scroll down the list to where it says \"attiny by Davis A. Mellis\". Click on that and then click \"INSTALL\".\n\nThis should add new entries in the Tools -> Board menu. However, there is additional functionality needed that is not installed by the attiny package.\n\nStep 7: Adding Programming Brownout Protection Capability to the Arduino IDE\n\nEven though the attiny package provides the ability to program the ATtiny microcontroller, it's abilities to program configuration options are limited to just selecting the system operating frequency of the microcontroller; it does not provide a way to set brownout protection options. If brownout protection is not enabled, it might be possible to corrupt the microcontroller's memory if voltage powering it falls below required operating levels. An external voltage monitor could serve this function as well, but why add the cost when the functionality is provided within the ATtiny itself? Luckily, adding the required functionality to the attiny package is easily accomplished.\n\nThere are three Fuse Bytes within the ATtiny that configure different options such as system clock source, brownout detection enable/disable and level, watchdog timer enable/disable, external reset enable/disable, and self-programming enable/disable to name a few. To enable brownout protection, the proper value must be programmed into the Fuse High Byte of the ATtiny microcontroller. If you want, you can read more on the ATtiny system architecture by reading the datasheet.\n\nThe attiny package provides the ability to program these three Fuse Bytes using the \"Burn Bootloader\" command in the \"Tools\" menu. But, the options are limited to just specifying the system clock source. Fortunately, it is simple to add the ability to program brownout detection and its level by making a simple modification to the \"boards.txt\" file installed by the attiny package. To do this, navigate to the \"boards.txt\" file in the \".../Arduino15/pacakages/attiny/hardware/avr/1.0.2/\" directory on your computer. On a windows PC, this is usually located at the following location:\n\n\"C:\\Users\\<user>\\AppData\\Local]Arduino15\\packages\\attiny\\hardware\\avr\\1.0.2\\\"\n\nwhere \"<user>\" is the user profile logged into the computer and \"1.0.2\" is the version of the attiny package installed.\n\nOnce you have located the \"boards.txt\" file, open it in a text editor such as Notepad, Wordpad, Notepad++ or other. Locate and replace the following text:\n\nATtinyX5.menu.clock.internal8=Internal 8 MHz\n\nATtinyX5.menu.clock.internal8.bootloader.low_fuses=0xe2\n\nATtinyX5.menu.clock.internal8.bootloader.high_fuses=0xdf\n\nATtinyX5.menu.clock.internal8.bootloader.extended_fuses=0xff\n\nATtinyX5.menu.clock.internal8.build.f_cpu=8000000L\n\nwith the following text:\n\nATtinyX5.menu.clock.internal8a=Internal 8 MHz, No BOD\n\nATtinyX5.menu.clock.internal8a.bootloader.low_fuses=0xe2\n\nATtinyX5.menu.clock.internal8a.bootloader.high_fuses=0xdf\n\nATtinyX5.menu.clock.internal8a.bootloader.extended_fuses=0xff\n\nATtinyX5.menu.clock.internal8a.build.f_cpu=8000000L\n\nATtinyX5.menu.clock.internal8b=Internal 8 MHz, BOD = 1.8V\n\nATtinyX5.menu.clock.internal8b.bootloader.low_fuses=0xe2\n\nATtinyX5.menu.clock.internal8b.bootloader.high_fuses=0xde\n\nATtinyX5.menu.clock.internal8b.bootloader.extended_fuses=0xff\n\nATtinyX5.menu.clock.internal8b.build.f_cpu=8000000L\n\nATtinyX5.menu.clock.internal8c=Internal 8 MHz, BOD = 2.7V\n\nATtinyX5.menu.clock.internal8c.bootloader.low_fuses=0xe2\n\nATtinyX5.menu.clock.internal8c.bootloader.high_fuses=0xdd\n\nATtinyX5.menu.clock.internal8c.bootloader.extended_fuses=0xff\n\nATtinyX5.menu.clock.internal8c.build.f_cpu=8000000L\n\nATtinyX5.menu.clock.internal8d=Internal 8 MHz, BOD = 4.3V\n\nATtinyX5.menu.clock.internal8d.bootloader.low_fuses=0xe2\n\nATtinyX5.menu.clock.internal8d.bootloader.high_fuses=0xdc\n\nATtinyX5.menu.clock.internal8d.bootloader.extended_fuses=0xff\n\nATtinyX5.menu.clock.internal8d.build.f_cpu=8000000L\n\nSave the file and exit. If you notice, only the high_fuses value is changed in each of the four code groups added above (the low_fuses and extended_fuses values are all the same). These four groups of code replace the one \"Internal 8 MHz\" clock selection option in the menu tree with four new menu options as follows:\n\nInternal 8 MHz, No BOD - This is the same as the original \"Internal 8 MHz\" option\n\nInternal 8 MHz, BOD = 1.8V - This option selects the Internal 8 MHz option AND enables 1.8V Brownout detection\n\nInternal 8 MHz, BOD = 2.7V - This option selects the Internal 8 MHz option AND enables 2.7V Brownout detection\n\nInternal 8 MHz, BOD = 4.3V - This option selects the Internal 8 MHz option AND enables 4.3V Brownout detection\n\nThat's it - we're all done with this step. Moving on...\n\nStep 8: Program the Arduino UNO As an In-system-programmer\n\nThere are multiple ways of programming the ATtiny microcontroller. Probably the least expensive and most accessible way is to use the Arduino IDE with an Arduino UNO as an In-System-Programmer (ISP). So, that is the approach I'm going to take in this instructable.\n\nThe first step is to set up an Arduino UNO as an ISP. To do this:\n\nConnect an Arduino UNO to your computer\n\nOpen the Arduino IDE\n\nIn the Arduino IDE, select File -> Examples -> ArduinoISP\n\nMake sure the UNO is the selected board by selecting Tools -> Board -> Arduino AVR Boards -> Arduino UNO\n\nSelect the COM port connected to your UNO by selecting Tools -> Port -> <COM PORT of UNO>\n\nUpload to the Arduino using the \"Upload\" button on the menu bar or by selecting Sketch -> Upload in the Arduino IDE\n\nAt this point, the Arduino UNO is an ISP. Remove power (USB cable) from the Arduino UNO so that you can wire it up to the ATtiny microcontroller on a breadboard as detailed in the next step.\n\nStep 9: Wire the Arduino UNO ISP to the ATtiny for Programming\n\nFollowing the picture above, perform the following steps to wire up the Arduino UNO ISP to the ATtiny microcontroller to prepare for programming:\n\nInsert the ATtiny microcontroller into a breadboard. Note the end of the ATtiny with the notch or the dot - the pin to the left of the notch or dot is pin 1. The pin numbers are in sequence and go in a circle counterclockwise to pin 1 (reference the ATtiny pinout shown in the bottom of the picture).\n\nConnect six DuPont style (or appropriately sized solid) wires from the Arduino UNO ISP to the ATtiny on the breadboard as shown in the picture and detailed in the \"Programming Connections\" table.\n\nInsert a 10uF capacitor between the Arduino ISP's \"Reset\" and \"GND\" connections as shown in the picture. If the capacitor is electrolytic or polarized, be careful to insert the (-) lead of the capacitor into the \"GND\" connection of the UNO (reversing polarity on a polarized capacitor can cause damage!). This capacitor is used to prevent the UNO from auto-resetting during programming operations of the ATtiny.\n\nThat's it - pretty simple. Now on to programming the ATtiny...\n\nStep 10: Program the ATtiny Microcontroller\n\nFinally, it's time to program the ATtiny25, 45, or 85 microcontroller. This occurs in two sequences; one to program the configuration fuses (this has to occur first as it erases the program area of the microcontroller) and the second is to program the actual program. So, let's get started.\n\nFirst, we program the configuration fuses:\n\nConnect the Arduino UNO ISP to the USB port of your computer.\n\nOpen the Arduino IDE and select Tools -> Board -> ATtiny Microcontrollers -> ATtiny25/45/85\n\nIn the Arduino IDE, select Tools -> Processor -> ATtiny25 (or ATtiny45 or ATtiny85)\n\nIn the Arduino IDE, select Tools -> Clock -> Internal 8 MHz, BOD = 2.7V\n\nSelect COM port of the Arduino UNO ISP by selecting Tools -> Port -> <COM PORT of UNO>\n\nIn the Arduino IDE, select Tools -> Burn Bootloader\n\nOnce complete, you should get a message in the Arduino IDE message window stating, \"avrdude done. Thank you.\". If you get errors, check your connections and try again.\n\nIf you get nothing in the Arduino IDE message window, click on File -> Preferences and make sure the \"upload\" checkbox is checked for the \"Show verbose output during:\" parameter\n\nOnce you get the ATtiny configuration fuses successfully programmed, you will need to open up the Pi_Power Arduino sketch and upload it to the ATtiny. This is accomplished by the following actions:\n\nIn the Arduino IDE, select File -> New. Select all (Ctrl-a) and hit the Delete key. Or, download the Pi_power.ino file attached to this step and save it in a directory named \"Pi_power\" (must match the same name as the \"Pi_power.ino\" file) and open this file in the Arduino IDE - if you do this, you can skip the next bullet.\n\nCopy the Pi_power C code provided below into the blank sketch in the Ardunio IDE. Save this file as \"Pi_power.ino\" on your computer.\n\nUpload the \"Pi_power.ino\" file to the ATtiny using the \"Upload\" button on the menu bar or by selecting Sketch -> Upload in the Arduino IDE\n\nOnce complete, you should get a message in the Arduino IDE message window stating, \"avrdude done. Thank you.\". If you get errors, check your connections and try again.\n\nIf you get nothing in the Arduino IDE message window, click on File -> Preferences and make sure the \"upload\" checkbox is checked for the \"Show verbose output during:\" parameter\n\nThat's it! - you're all done programming the ATtiny microcontroller. Power down the Ardunio UNO ISP now by unplugging the USB cable from it. Carefully remove the ATtiny from the breadboard and put it someplace safe while you solder up the power control board in the next step. You can put away the Arduino UNO and breadboard now - you won't be needing them anymore for this project.\n\nFeel free to peruse the Pi_power.ino file in the Arduino IDE editor. The code is not too long and should be easy to understand as it is chock full of comments. Well, enough dabbling - on to building the power control circuit...\n\nPi_power.ino C code:\n\n/*\n\n//////////////////////////////////////////////////////////////////////\n\nPi_power.ino\n\nVersion: 1.0\n\nAuthor: D.J. Hatfield\n\nDate: 2/6/2022\n\nDevices: ATtiny25, ATtiny45, ATtiny85\n\nPurpose: Controls power up and shutdown/power off sequences for a\n\nRaspberry Pi. It monitors the Power_IN pin to determine when\n\nto power up the Raspberry Pi and issue a shutdown sequence on\n\nthe Pi via the Pi_Shutdown pin. Once a Shutdown has been\n\ninitiated, the Pi_Status pin is monitored to verify when the\n\nPi has completed its shutdown sequence and no more disk\n\nactivity is occurring on the Pi's SD card. Once no activity\n\nis detected for 1 Second, power is removed from the system.\n\nPower is restored once the Power up signal is observed on the\n\nPower_IN pin. Power is controlled via the Power_OUT pin.\n\n////////////////////////////////////////////////////////////////////////\n\n*/\n\n//Define physical inputs and outputs\n\n//Power_IN - connect to push ON/OFF power button switching GND\n\n//Power_OUT - connect to Power P-FET through 330 Ohm resistor\n\n//Pi_Status - connect to LED activity signal from Pi (soldered to test pad on Pi)\n\n//Pi_Shutdown - connect to input-with-pullup pin on Pi to initiate Shutdown\n\n// requires Python script to be running on Pi to monitor this signal\n\n// and initiate a shutdown.\n\n#define Power_IN B00010000 //PORTB4 pin INPUT - Active LOW indicates to power ON\n\n#define Power_OUT B00001000 //PORTB3 pin OUTPUT - Active LOW turns power ON\n\n#define Pi_Status B00000100 //PORTB2 pin INPUT - Active LOW indicates Pi activity\n\n#define Pi_Shutdown B00000010 //PORTB1 pin OUTPUT - Active HIGH initiates Pi shutdown\n\n//Define named states for the overall control state machine. State machine sequence\n\n//is 0-1-2-3-4-0...\n\n#define Power_OFF 0 //Power is OFF state\n\n#define Power_ON 1 //Power is ON state\n\n#define Power_Delay 2 //Power Delay state - used to wait several mS after initiating\n\n//a shutdown command before starting to check the Pi_Status\n\n//signal\n\n#define Powering_Down 3 //Powering Down state monitors Pi_Status for no activity for 1S\n\n#define Power_Delay2 4 //Another power delay state used to allow pi to complete power\n\n//down before allowing possibility of powering back up\n\n//define variables used in this program\n\nint State; //Integer - keeps track of the controller's state machine\n\nbyte DebounceTimer; //Byte - tracks number of milliseconds for input debouncing\n\nint PiActivityTimer; //Integer - tracks number of milliseconds for monitoring Pi_Status\n\n//----------------------------------------------------------------------------------------\n\n//setup: Used to initialize processor - only executed once at startup or controller reset\n\n//----------------------------------------------------------------------------------------\n\nvoid setup()\n\n{\n\nPORTB = B00010100; //Enable resistive Pullup on inputs PORTB2 & PORTB4\n\nSetOutput(Power_OUT); //Insure power does not glitch ON during boot of controller\n\nDDRB = B00001010; //Set PORTB1 and PORTB3 as outputs\n\n//Configure Timer/Counter1 Control Register 1 (TCCR1)\n\n//CTC1 = 1 Clear Timer/Counter on Compare Match\n\n//PWM1A = 0 Disable PWM A\n\n//COM1A1:0 = 00 disconnect from output pin OC1A\n\n//CS13:0 = 0111 prescale select CK/64 (8MHz / 64) >> count every 8uS\n\nTCCR1 = B10000111;\n\n//setup OCR1C compare register to cause ISR to occur once every 1mS\n\nOCR1C = 125; //125 * 8 uS = 1 mS\n\nTIMSK = B01000000; //Enable Timer/Counter 1 Compare matchA interrupt\n\nDebounceTimer = 0; //Initialize DebounceTimer to 0mS\n\nPiActivityTimer = 0; //Initialize PiActivityTimer to 0mS\n\nState = Power_OFF; //Initialize state machine to Power_OFF state (state 0)\n\nSetOutput(Pi_Shutdown); //Initialize Pi_Shutdown signal pin to inactive state\n\ninterrupts(); //Enable interrupts (start 1mS timer interrupts)\n\n}\n\n//----------------------------------------------------------------------------------------\n\n//loop: Loops continuously. This is the main program - implements the controller's\n\n// state machine.\n\n//----------------------------------------------------------------------------------------\n\nvoid loop()\n\n{\n\n//Powered OFF State - just wait for Power ON switch\n\nif(State == Power_OFF){\n\nif(CheckInput(Power_IN) == false){ //If Power_IN signal is active->debounce\n\nif(DebounceTimer >= 50){ //Debounce power ON command for 50mS\n\nClearOutput(Power_OUT); //Power is turned ON by clearing the output\n\nState = Power_ON; //Go to Power_ON state\n\nDebounceTimer = 0; //Clear the Debounce Timer\n\n}\n\n}\n\nelse{\n\nDebounceTimer = 0; //Keep clearing Debounce Timer if Power_IN indicates\n\n} // Power_OFF (i.e. stay in the Power_OFF state)\n\n}\n\n//Powered ON State - just wait for Power OFF switch\n\nif(State == Power_ON){\n\nif(CheckInput(Power_IN) == true){ //If Power_IN signal is inactive->debounce\n\nif(DebounceTimer >= 50){ //Debounce power OFF command for 50mS\n\nState = Power_Delay; //Go to Power_Delay state\n\nClearOutput(Pi_Shutdown); //Initiate Shutdown of Pi\n\nDebounceTimer = 0; //Clear the Debounce Timer\n\n}\n\n}\n\nelse{\n\nDebounceTimer = 0; //Keep clearing Debounce Timer if Power_IN indicates\n\n} // Power_ON (i.e. stay in the Power_ON state)\n\n}\n\n//Power_Delay State - Waits 100 milliseconds for Raspberry pi to start shutdown process\n\n// before starting to monitor Pi_Status. This gives the Pi time to\n\n// get started with the shutdownprocess.\n\nif(State == Power_Delay){\n\nif(DebounceTimer >= 100){ //Use Debounce timer to simply wait for 100mS\n\nState = Powering_Down; //Once 100mS timer times out, go to Powering_Down state\n\nPiActivityTimer = 0; //Clear PiActivityTimer\n\n}\n\n}\n\n//Powering_Down State - Waits for Pi Activity to stop for >1S before shutting power OFF\n\n// to Raspberry Pi\n\nif(State == Powering_Down){\n\nif(CheckInput(Pi_Status) == true){ //If Pi_Status is inactive (i.e. HIGH), delay for\n\nif(PiActivityTimer >= 1000){ // 1S to insure all Pi activity is done\n\nState = Power_Delay2; //Once 1S of no activity, go to Power_Delay2 state\n\nDebounceTimer = 0; //Clear the Debounce timer\n\nSetOutput(Power_OUT); //Power is turned OFF by setting the output\n\n}\n\n}\n\nelse{\n\nPiActivityTimer = 0; //Keep clearing PiActivity Timer as long as\n\n} // activity is detected from the Pi\n\n}\n\n//Power_Delay2 State - Waits several milliseconds for Raspberry pi to complete power down before allowing possibility of powering back up\n\nif(State == Power_Delay2){\n\nif(DebounceTimer >= 100){ //Use Debounce timer to simply wait for 100mS\n\nState = Power_OFF; //Once 100mS timer times out, go to Power_OFF state\n\nDebounceTimer = 0; //Clear the Debounce timer\n\nSetOutput(Pi_Shutdown); //Turn off the Pi_Shutdown signal now that Pi is OFF\n\n}\n\n}\n\n}\n\n//----------------------------------------------------------------------------------------\n\n//CheckInput: Reads PORTB input pin specified by byte \"value\" passed to it. Returns TRUE\n\n// if the input is HIGH or FALSE if the input is LOW.\n\n//----------------------------------------------------------------------------------------\n\nbool CheckInput(byte value){\n\nif((PINB & value) == value){\n\nreturn true;\n\n}\n\nreturn false;\n\n}\n\n//----------------------------------------------------------------------------------------\n\n//SetOutput: Sets PORTB output pin specified by byte \"value\" passed to it.\n\n//----------------------------------------------------------------------------------------\n\nvoid SetOutput(byte value){\n\nPORTB = PORTB | value;\n\n}\n\n//----------------------------------------------------------------------------------------\n\n//ClearOutput: Clears PORTB output pin specified by byte \"value\" passed to it.\n\n//----------------------------------------------------------------------------------------\n\nvoid ClearOutput(byte value){\n\nPORTB = PORTB &~value;\n\n}\n\n//----------------------------------------------------------------------------------------\n\n//Interrupt Service Routine: Fires every 1mS. Increments the DebounceTimer and\n\n// PiActivityTimer variables once every 1mS.\n\n//----------------------------------------------------------------------------------------\n\nISR (TIMER1_COMPA_vect) //Interrupt vector for Timer1 - should fire every 1mS\n\n{\n\n++DebounceTimer;\n\n++PiActivityTimer;\n\n}\n\nStep 11: Build the Safe Shutdown Circuit\n\nThe Safe Shutdown Circuit utilizes the Atmega ATtiny25, 45, or 85 microcontroller to coordinate an ordered shutdown of the Raspberry Pi before removing power. You can use any one of these three microcontrollers to implement this circuit. They all have the same pinout and features. The only difference amongst them is the amount of RAM, Program Flash, and EEPROM memory they have. The ATtiny25 has the least and the ATtiny85 has the most. The program written for this project will easily fit in the smallest one.\n\nIt works by monitoring a signal from the power button that tells the microcontroller when to power the system up and when to power it down. When the power button indicates to power down, the ATtiny sends a signal to Raspberry Pi's GPIO11, which signals the player.py python script to execute a system shutdown command. After the ATtiny sends the shutdown signal, it monitors the status LED signal from the Pi to determine when the shutdown has completed. The ATtiny will turn power OFF to the system once the LED signal is inactive for > 1 second. The ATtiny will then monitor for a power up signal from the power button. Once it gets the power up signal, it applies power to the system. This safe shutdown circuit allows the Simpsons TV to independently control complete power ON/OFF functions of the system safely while still allowing the Pi to utilize a writable file system, which allows you to add/delete content from the Pi at any time without messing with any configuration options.\n\nFor most, this will be the most challenging part of this project due to the amount of soldering. Try to have patience as you work through it - the circuit is not that complex and parts are fairly minimal.\n\nStep 1: Cut a blank piece of PC Board 6 holes tall x 13 holes wide. You may want to leave extra on the ends to allow for easy mounting in the case with hot-melt glue.\n\nStep 2: Insert the 8-pin DIP socket as shown in the picture, leaving four holes to the left and five holes to the right. Note the notch in the DIP socket – It should be positioned toward the top. This notch indicates that pin 1 is to the immediate left. Pin numbering goes counter-clockwise as shown.\n\nStep 3: Insert one of the 1N4148 diodes as shown in the picture. The cathode end (the end with the black band) should go into the hole to the immediate right of pin 8 of the DIP socket. The other end should go in the hole above the cathode end. The purpose of this diode is to provide reverse polarity protection and, in conjunction with the 0.1uF capacitor, provide a filter to prevent the brownout detection from resetting the ATtiny when it applies power to the Pi, screen, and audio amplifier – the current surge at power-up can cause the 5V power rail to dip momentarily.\n\nStep 3b: On the back of the PC Board, solder all eight pins of the DIP socket and the two pins of the diode (clip the diode leads after soldering). Use additional solder to make a solder bridge between the diode’s cathode pin and pin 8 of the DIP socket. A lower soldering iron temperature (~550F / 288C for lead-free solder) and/or short applied heat time will help make the solder bridge easier to form.\n\nStep 4: Insert one of the 330 Ohm resistors as shown in the picture. One end should be in the hole to the immediate right of pin 7 of the DIP socket. The other end should be placed into the hole to the immediate right of the first pin of the resistor.\n\nStep 5: Insert a single-pin header to the immediate right of the 330 Ohm resistor as shown in the picture. This header pin will connect to the Status LED signal from the Pi.\n\nStep 5b: On the back of the PC Board, solder both pins of the 330 Ohm resistor and the one pin of the single-pin header (clip the resistor leads after soldering). Use additional solder to make a solder bridge between Pin 7 of the DIP socket and the closest pin of the 330 Ohm resistor. Create another solder bridge between the other pin of the 330 Ohm resistor and the single-pin header.\n\nStep 6: Insert the other 1N4148 diode as shown in the picture. The cathode end (the end with the black band) should be inserted into the hole to the immediate right of pin 6. The other end should be inserted into the hole to the immediate right of the first pin of the diode. This diode protects the Pi’s 3.3V “Shutdown” signal pin from the 5V signal level of the ATtiny. The Pi implements a pull-up to 3.3V for this signal and the ATtiny drives it to GND to indicate a command to shutdown.\n\nStep 7: Referencing the picture, insert the 0.1uF capacitor’s leads into the holes to the right of pins 2 and 3 of the DIP socket – the body of the cap will go into the hole located in the center of the DIP socket. Bend the leads of the capacitor so that one goes to pin 4 of the DIP socket and the other goes to pin 8 of the DIP socket.\n\nStep 7b: On the back of the PC Board, solder the pins of the 1N4148 diode and the 0.1uF capacitor (clip the diode’s leads after soldering – DO NOT clip the capacitor leads just yet). Use additional solder to make a solder bridge between the diode’s cathode pin and Pin 6 of the DIP socket. Solder one of the capacitor’s leads to pin 4 of the DIP socket and the other capacitor lead to pin 8 of the DIP socket as shown in the picture (clip the excess leads of the capacitor after soldering).\n\nStep 8: Referencing the picture, insert one lead of the other 330 Ohm resistor into the hole to the immediate left of pin 2 of the DIP socket. Insert the resistor’s other lead into the hole 3-positions to the left of the first lead. This resistor helps slow the turn-ON speed of the P-FET, which helps to minimize the current surge when turning on power to the Pi, Screen, and audio amplifier and it protects the ATtiny pin in case of a short circuit with the P-FET circuits. .\n\nStep 8b: On the back of the PC Board, solder the pins of the 330 Ohm resistor (clip the resistor’s leads after soldering. Use additional solder to make a solder bridge between pin 2 of the DIP socket and the resistor pin closest to it as shown in the picture.\n\nStep 9: Referencing the picture, insert the IRF4905 P-FET, side with part markings as shown, into three holes, skipping one hole to the immediate left of pin 1 of the DIP socket (the left-most pin of the P-FET should be in the same hole column as the end of the 330 Ohm resistor). The P-FET is used as a switch to turn ON/OFF power to the Pi, screen, and audio amplifier.\n\nStep 9b: On the back of the PC Board, solder the three pins of the P-FET (clip the two left-most leads of the P-FET [the GATE and DRAIN pins] - bend the third pin of the P-FET down and over as shown in the picture). Use additional solder to make a solder bridge between the left-most pin of the PFET (GATE pin) and the adjacent pin of the 330 Ohm resistor as shown in the picture.\n\nStep 10: Referencing the picture, insert a two-position header down one hole and to the left one hole from the immediate left of pin 4 of the DIP socket. This header will connect to the power switch.\n\nStep 10b: On the back of the PC Board, solder the two pins of the two-position header. Use additional solder to make a solder bridge trace between the left-most pin of the two-position header and pin 3 of the DIP socket as shown in the picture.\n\nStep 11: Referencing the picture, insert the other two-position header down one hole and to the right two holes from the immediate right of pin 5 of the DIP socket. This header will connect to incoming 5VDC power.\n\nStep 11b: On the back of the PC Board, solder the two pins of the two-position header.\n\nStep 12: Insert a DuPont female crimp socket into a crimping tool as shown in the picture. Gently close the crimp tool jaws to captivate the crimp socket.\n\nStep 12b: Slide the crimp socket as needed to make sure the back of the crimp socket is flush with the crimping die jaws.\n\nStep 12c: Strip about 0.1\" (2mm) from the end of a RED 22AWG wire (about 6\" / 15mm long) and insert that end into the crimp socket as shown in the picture. Be sure not to insert the wire too far; the insulation should only go far enough to be crimped by the insulation crimp (reference picture of Step 12d).\n\nStep 12d: Squeeze the crimp handles to crimp the female socket onto the wire. Open the crimper jaws after crimping and remove the female crimp socket form the jaws. Inspect to verify that the wire crimp portion of the female crimp socket is crimped around the bare wire and the insulation portion of the female crimp socket is crimped around the insulation of the wire as shown in Step 12d of the picture.\n\nStep 12e: Repeat steps 12 through 12d with a BLACK 22AWG wire (about 6\" / 15mm long). Insert the female crimp socket ends of the RED and BLACK wires into a 2-position DuPont socket as shown in Step 12e of the picture. Repeat steps 12 through 12d with a BROWN signal wire (about 6\" / 15mm long). Insert the female crimp socket end of the BROWN wire into a 1-position DuPont socket.\n\nStep 13: Strip about 1/8\" / 3mm from the other end of the BROWN wire from Step 12. Insert this end of the BROWN wire into the PC Board immediately to the right of the 1N4148 diode installed in Step 6 (reference Step 13 of the picture). This BROWN wire signals a SHUTDOWN command to the Pi when the power button is turned OFF.\n\nStep 13b: On the back of the PC Board, solder the BROWN wire (trim, if needed, after soldering). Use additional solder to make a solder bridge trace between the BROWN wire and the anode pin of Step 6 1N4148 diode (pin closest to it) as shown in Step 13b of the picture.\n\nStep 14: Strip about 1/8\" / 3mm from the other end of the RED wire from Step 12. Insert this end of the RED wire into the PC Board immediately behind the middle pin of the P-FET(reference Step 14 of the picture). This RED wire provides (+)5VDC to the Pi.\n\nStep 14b: Strip about 1/8\" / 3mm from the other end of the BLACK wire from Step 12. Insert this end of the BLACK wire into the PC Board immediately below pin 4 of the DIP socket (reference Step 14b of the picture). This BLACK wire provides GND to the Pi.\n\nStep 14c: On the back of the PC Board, solder the RED and BLACK wires (trim, if needed, after soldering).n\n\nStep 14d: Use additional solder to make a solder bridge trace to connect all the GND connections (BLACK wire, pin 4 of the DIP socket, 0.1uF capacitor, right-most pin of Step 10 2-pin header, and left-most pin of Step 11 2-pin header) as shown in Step 14d of the picture.\n\nStep 14e: Use additional solder to make a solder bridge trace to connect all the (+)5VDC connections (anode pin of Step 3 1N4148 diode, SOURCE pin of the P-FET, and right-most pin of Step 11 2-pin header) as shown in Step 14e of the picture.\n\nStep 15: Insert the ATtiny microcontroller chip into the 8-pin DIP socket (Reference \"Safe Shutdown Board Connections\" Picture). NOTE: The notch on the top of the microcontroller must be oriented with the notch on the DIP socket. Alternatively, a small dot on the ATtiny marks pin 1 of the microcontroller - this must be matched to pin 1 of the DIP socket (Reference Step 2 of the picture for the DIP socket pinout).\n\nStep 16: It is usually a good idea to place some hot-melt glue around the base of wires soldered into a PC Board. This will help prevent the wires from breaking at the connection point with the PC Board as soldering wires embrittles them and makes them more susceptible to breaking with back and forth movement. The hot-melt glue moves the point of flexure further away from the solder joint on the PC Board.\n\nAlternate Option 1: Configure the Raspberry Pi for a read-only file system and wire the power button between incoming (+)5VDC power and the rest of the system's (+)5VDC power rail (NOTE: If you implement this option, you need to use at least 22AWG wire on the power button). This option does not need the ATtiny safe shutdown circuit nor does the system require a shutdown command to be executed on the Pi - power can simply be removed at any time without worry of damaging or corrupting the SD card. The downside is that you cannot write additional video files to the Pi's SD Card while it is configured for a read-only file system. Enabling and Disabling the read-only file system configuration option for the Pi is fairly easy in the Buster Raspian OS Lite version. To do so, log into the Pi and type the following command at the system prompt:\n\nsudo raspi-config\n\nThen, select \"4 Performance Options\" -> \"P3 Overlay File System\".\n\nSelect \"<Yes>\" to the \"Would you like the overlay file system to be enabled?\" question.\n\nSelect \"<Ok>\".\n\nSelect \"<Yes>\" to the \"Would you like the boot partition to be write-protected?\" question.\n\nSelect \"<Ok>\".\n\nSelect \"<Finish>\" to exit.\n\nSelect \"<Yes>\" to the \"Would you like to reboot now?\" question.\n\nTo re-enable write capability on the SD card, execute the \"sudo raspi-config\" command again at a command prompt.\n\nThen, select \"4 Performance Options\" -> \"P3 Overlay File System\".\n\nSelect \"<No>\" to the \"Would you like the overlay file system to be enabled?\" question.\n\nSelect \"<Ok>\".\n\nSelect \"<Ok>\".\n\nSelect \"<Finish>\" to exit.\n\nSelect \"<Yes>\" to the \"Would you like to reboot now?\" question.\n\nAfter rebooting, execute the \"sudo raspi-config\" command again at a command prompt (we couldn't disable boot partition write-protection until after rebooting with the overlay file system set to disabled).\n\nSelect \"<No>\" to the \"Would you like the overlay file system to be enabled?\" question.\n\nSelect \"<Ok>\".\n\nSelect \"<No>\" to the \"Would you like the boot partition to be write-protected?\" question.\n\nSelect \"<Ok>\".\n\nSelect \"<Finish>\" to exit.\n\nSelect \"<Yes>\" to the \"Would you like to reboot now?\" question.\n\nNow the SD card is fully writable again.\n\nAlternate Option 2: Wire the power button directly between GND and Raspberry Pi GPIO11 (Pi pin 23). This option does not require the ATtiny circuit. When the power button is pressed, It will cause the Raspberry Pi to execute a shutdown command, but will not actually remove power from the system, so the LED backlight and audio amplifier will both remain ON. Also, you will need to remember to push the power button to disconnect GPIO11 from GND to prevent the Pi from shutting down immediately on the next power up. To power up again, power must be removed and re-applied. Not ideal, but it does provide a method of safely shutting down the Pi without the need for adding a keyboard or using a terminal to remote in over SSH to execute a shutdown command.\n\nStep 12: Construct Power Connector Assembly\n\nThis one's pretty easy. The power connector assembly takes incoming power from an AC power converter that provides 5VDC at 3A. Power up the soldering iron, grab the wire strippers, and let's get going...\n\nStep 1: Strip about 1/8\" / 3mm from about a 5\" / 127mm long piece of RED 22AWG wire and insert that end in the VBUS hole on the Micro USB to DIP adapter. Strip about 1/8\" / 3mm from a 5\" / 127mm long piece of BLACK 22AWG wire and insert that end in the GND hole on the Micro USB to DIP adapter.\n\nStep 2: Flip the Micro USB to DIP adapter board over, solder the BLACK and RED wires, and trim the wire on the back side as flush as possible with the board (it doesn't have to be perfectly flat) as shown in Step 2 of the picture.\n\nStep 3: Strip about 0.1\" (2mm) from the other ends of the two wires. On each wire, crimp a female crimp socket and insert them both into a 2-position DuPont socket connector as shown in Step 3 of the picture.\n\nStep 13: Construct Power Button Assembly\n\nThis one's also a pretty quick and easy one. The power button is used to signal power ON and OFF events to the Safe Shutdown control circuit. To assemble:\n\nStep 1: Strip about 1/8\" / 3mm from two signal wires (I used PURPLE and BLUE) about 8\" / 203mm long. Solder these signal wires onto a set of the Normally Open (NO) contacts of the push ON/push OFF power button (you can test this with a multimeter on a continuity or resistance setting - the continuity setting should beep or the resistance setting should show very low Ohms on the NO contacts with the button pushed ON). For the switch I purchased, I used the rear right two contacts with the switch positioned as shown in Step 1 of the picture. After soldering, install heat shrink tubing or hot-melt glue over the contacts to prevent accidental shorting and breakage of the wires due to excessive bending at the solder joints. .\n\nStep 2: Strip about 0.1\" / 2mm from the other ends of the two wires. On each wire , crimp a female crimp socket and insert them both into a 2-position DuPont socket connector as shown in Step 2 of the picture.\n\nStep 14: Construct VCR Assembly\n\nThe VCR assembly sits on top of the TV. It uses the two small 6mm x 6mm x 6mm momentary buttons that implement the pause/play, rewind, next video, and channel change features. There are four pins on each of the buttons; two on one side are always shorted together and the other two on the other side are always shorted together. When you press the button, the two sets of pins are connected together. Use a multimeter’s continuity or resistance setting to determine which pins are NOT connected together when the button is NOT pressed – these are the ones we want to use). NOTE: you may have to use a small round file in the 3D printed VCR button holes to insure free movement of the buttons. Test position and operation of the buttons before gluing. To build the VCR assembly:\n\nStep 1: Get three pieces of signal wire each about 6” / 152mm long (I used GREY, WHITE, and BLACK). Strip about 1/16” / 2mm from the WHITE and GREY wires. Solder these two wires to the top outer pins of the two buttons as shown in Step 1 of the picture (NOTE: the top inner pins are the ones that should NOT be connected to the top outer pins with the wires until the buttons are pressed).\n\nStep 2: Position the right button (the one with the WHITE wire) in the outermost button hole of the 3D printed VCR and use hot-melt glue to glue it in place as shown in Step 2 of the picture. Only cover the lower terminals with the hot-melt glue – do not glue the top terminals yet. Use something like a small screwdriver to hold the button in place while gluing (you may have to hold it for a few minutes while the glue cools and hardens).\n\nStep 3: Position the left button (the one with the GREY wire) in the innermost button hole of the 3D printed VCR and use hot-melt glue to glue it in place as shown in Step 3 of the picture. Only cover the lower terminals with the hot-melt glue – do not glue the top terminals yet. Use something like a small screwdriver to hold the button in place while gluing (you may have to hold it for a few minutes while the glue cools and hardens).\n\nStep 4: Bend the two top-inner terminals of the buttons so that they touch. Strip about 1/16” / 2mm from the BLACK wire. The BLACK wire is the GND (or common) for the left and right buttons. Solder the BLACK wire to the two top-inner terminals of the two buttons. Apply hot-melt glue on the top terminals and wires (but not too much – we only want to protect the terminals and wires from bending at the solder joints – we do not want the hot-melt glue to extend past the open bottom of the 3D printed VCR.\n\nStep 5: Strip about 0.1” / 3mm from the other end of the three wires and crimp on a female crimp socket on each of them.\n\nStep 6: Insert the BLACK (common) and WHITE (right button) crimp sockets into a 2-position DuPont socket connector as shown in Step 6 of the picture. NOTE: The crimp socket on the GREY (left button) wire will remain loose right now – it will later be inserted in the middle position of the 3-position DuPont socket connector of the audio amplifier.\n\nThat's it - we're done with this assembly.\n\nStep 15: Prepare Raspberry Pi Hardware\n\nThe Raspberry Pi electromechanical assembly is also pretty quick and easy. Basically, we're soldering on a 40-pin header with extended pins (the extended pins are used to connect to the DuPont connectors) and a single wire to make the Status LED signal of the Pi available to the Safe Shutdown circuit. Without further delay, let’s get going…\n\nStep 1: Insert the 2x20 extended pin socket header through the back side of the Raspberry Pi Zero 2 W’s circuit board and solder in place as shown in Step 1 of the picture. Keep the solder at the bottom of the extended pins to prevent interfering with connecting DuPont socket connectors. If you accidentally get some solder blobs on the upper part of extended pins 2, 4, 6, 20, 22, 23, 35, 37, or 39, use some solder wick to remove as much of it as you can. The other pins do not matter so much unless you want to use those signals for your own purposes.\n\nStep 2: : Strip about 0.1” / 3mm from a single signal wire about 6” long (I used YELLOW). Thread this signal wire through the lower left mounting hole of the Pi and solder the stripped end to the Status LED test point as shown in Step 2 of the picture. It is also a good idea to apply some hot-melt glue on the YELLOW wire at the mounting hole to help prevent the Status LED test point pad from accidentally being pulled off during handling.\n\nStep 3: Strip about 0.1” / 3mm from the other end of the YELLOW wire and crimp on a female crimp socket. Insert this crimp socket into a 1-position DuPont socket connector as shown in Step 3 of the picture.\n\nAll done with this section – see, not too bad.\n\nStep 16: Set Up the Raspberry Pi: Installing the OS on the Micro SD Card\n\nInsert the 64GB micro SD Card in a computer. Then, use the Raspberry Pi Imager to install the headless version of the Operating System on the 64GB SD card. Select “Operating System” -> “Raspberry Pi OS (other)” -> “Raspberry Pi OS Lite (Legacy)”. Be sure to select the “Buster” version and not the “Bullseye” version as OMX Player is not supported in newer versions of the Raspberry Pi OS.\n\nThen, in the Raspberry Pi Imager, click on the \"Storage\" button, select the SD card option, then click \"Write\". Click \"Yes\" on the pop-up prompt to overwrite the data on the SD card.\n\nOnce the process completes, you may need to remove and re-insert the micro SD card back into the computer for it to recognize the boot partition on it.\n\nIn a text editor such as Notepad, Notepad++, or Wordpad, create a new file and paste the following text into it:\n\ncountry=US\n\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\n\nupdate_config=1\n\nnetwork={\n\nssid=\"YOUR NETWORK NAME\"\n\npsk=\"YOUR NETWORK PASSWORD\"\n\n}\n\nChange \"YOUR NETWORK NAME\" to your WiFi's SSID name (keep the quotes) and \"YOUR NETWORK PASSWORD\" to your WiFi's password (again, keep the quotes). Save this file to the SD Card's \"Boot\" partition as:\n\nwpa_supplicant.conf\n\nNOTE: The Raspian OS will use this file to set up WiFi access during its first boot. After this first boot on the raspberry pi, the wpa_supplicant.conf file will be moved from the root directory on the boot partition to the \"/etc/wpa_supplicant/\" directory. So, if you need to change the network ssid and/or password later, simply edit the ssid and psk parameters in the wpa_supplicant.conf file located in the /etc/wpa_supplicant/ directory on the Pi and reboot.\n\nThen, in the text editor, create another new file. Type no text and simply save this empty file to the SD Card's \"Boot\" partition as:\n\nssh\n\nThis will enable the ssh service at bootup.\n\nOnce the process is complete, eject the SD card from the computer and install it into the Raspberry Pi.\n\nStep 17: Set Up the Raspberry Pi: Connect Monitor and Power\n\nConnect an HDMI monitor and power source to the Raspberry Pi as shown in the picture above. At this time, the IP address assigned to the Pi should scroll up on the screen, take a note and jot it down. You should now be able to log into the Raspberry Pi remotely on a computer logged into the same network as the Pi.\n\nUsing a terminal program, such as Putty, establish a SSH session with the Raspberry Pi at the IP address you noted on the HDMI screen connected to the Pi as it booted (reference example picture above). Alternately, in Windows, you can type the following at a system command prompt to establish an SSH session with the Pi:\n\nssh raspberrypi.local -l pi\n\nIf you didn't see the IP address or if it changed, you can type \"ping raspberrypi\" at a system command prompt on your computer to see what IP address is returned.\n\nOnce the SSH session is established, you will need to enter the login credentials of the Raspberry Pi. The default user is \"pi\" and the password is \"raspberry\" as shown below:\n\nlogin as: pi\n\npi@192.168.1.190's password:\n\nLinux raspberrypi 5.10.63-v7+ #1496 SMP Wed Dec 1 15:58:11 GMT 2021 armv7l\n\nThe programs included with the Debian GNU/Linux system are free software;\n\nthe exact distribution terms for each program are described in the\n\nindividual files in /usr/share/doc/*/copyright.\n\nDebian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent\n\npermitted by applicable law.\n\nLast login: Mon Feb 14 05:05:40 2022\n\nSSH is enabled and the default password for the 'pi' user has not been changed.\n\nThis is a security risk - please login as the 'pi' user and type 'passwd' to set a new password.\n\npi@raspberrypi:~ $\n\nNow, we need to update the OS. In the terminal, type:\n\nsudo apt-get update\n\nAfter that finishes, type:\n\nsudo apt-get upgrade\n\nYou may get a prompt asking, \"Do you want to continue? [Y/n]\". Type Y and hit <ENTER>\n\nEnabling USB Drive Support:\n\nA USB drive will later be needed to copy your video files over to the Pi's SD card. We will need to install a couple of packages to allow easy mounting and dismounting of a USB drive to the Pi with the following commands:\n\nsudo apt-get install usbmount\n\nAgain, you may get a prompt asking, \"Do you want to continue? [Y/n]\". Type Y and hit <ENTER>\n\nsudo apt-get install eject\n\nNow, we will finish up USB drive support by editing the systemd-udevd.service file. To do this, type the following command:\n\nsudo nano /lib/systemd/system/systemd-udevd.service\n\nScroll down to where it says:\n\nPrivateMounts=yes\n\nChange it to:\n\nPrivateMounts=no\n\nSave the file by typing Ctrl-o, hit <ENTER>, then exit the editor by typing Ctrl-x\n\nConfigure Auto Log-In at Boot\n\nWe need to make sure the Raspberry Pi just boots up without being stopped to Login on the 3.5\" LCD. To do this, enter the following in the terminal at a command prompt:\n\nsudo raspi-config\n\nSelect \"1 System Options\"\n\nSelect \"S5 Boot / Auto Login\"\n\nSelect \"B2 Console Autologin\"\n\nSelect \"OK\"\n\nSelect \"Finish\"\n\nThe system will ask you, \"Would you like to reboot now?\"\n\nSelect \"Yes\".\n\nIf you accidentally select \"No\", no worries - you can still reboot by entering the following command:\n\nsudo reboot -h now\n\nInstall 3.5\" LCD Graphics Drivers:\n\nFirst, we will need to install the git package. Git allows you to clone files and file structures from github. This is needed to install the 3.5\" LCD graphics drivers. To install the git package, type the following command:\n\nsudo apt-get install git\n\nYou may get a prompt asking, \"Do you want to continue? [Y/n]\". Type Y and hit <ENTER>\n\nInstructions come with with the iUniker 3.5\" LCD that tell you how to install the display drivers. You should follow those instructions. For the one I got, the instructions state to type the following commands:\n\ncd ~/\n\ngit clone https://github.com/tianyoujian/MZDPI.git\n\ncd MZDPI/mzp351hv00br\n\nsudo chmod +x mzdpi-hvga-autoinstall\n\nsudo ./mzdpi-hvga-autoinstall\n\nMost likely, you will have encountered errors on that last command due to several package dependencies not being installed. You can install these dependencies manually or type the following command to install all the dependencies from the last command:\n\nsudo apt --fix-broken install\n\nThis will install several packages. You may get prompts asking \"Do you want to continue? [Y/n]\". Type Y and hit <ENTER> for each of these.\n\nOnce these package installations all complete, type the following command again:\n\nsudo ./mzdpi-hvga-autoinstall\n\nThis time, this command should complete successfully. At this point, if you reboot, system video will be sent to the 3.5\" LCD (if attached) - the HDMI port will not work. No worries though - your SSH session \"look\" will not change.\n\nNOTE: To re-enable the HDMI port, you can edit the config.txt file using the following command:\n\nsudo nano /boot/config.txt\n\nscroll to \"include mzp351hv00br.txt\" and comment it out by putting a \"#\" in front of it. This will look like, \"#include mzp351hv00br.txt\".\n\nSave the file by typing Ctrl-o, then exit the editor by typing Ctrl-x\n\nThe next time you reboot, the video will be sent back out the HDMI connector.\n\nTo re-enable output to the 3.5\" LCD, just re-edit the config.txt file again and remove the \"#\" so that you have \"include mzp351hv00br.txt\" again. Save and exit. The next time you reboot, the video will be sent to the 3.5\" LCD.\n\nEnable Audio Output:\n\nSome of the GPIO pins on the Raspberry Pi Zero 2 have special alternate functions. One of those functions happens to be PWM audio output on pins 18 and 19. This project utilizes only the audio output on GPIO 19. So, to enable the PWM audio output on pin 19, we need to first edit the config.txt file located in the /boot/ directory again. To do this, type the following command:\n\nsudo nano /boot/config.txt\n\nScroll to the bottom of this file and add the following text:\n\ndtparam=audio=on\n\ndtoverlay=audremap,enable_jack,pins_19\n\nSave the file by typing Ctrl-o, then exit the editor by typing Ctrl-x\n\nNext, we need to edit the rc.local file by typing the following command:\n\nsudo nano /etc/rc.local\n\nAdd the following text towards the bottom, but before Exit 0.\n\nsudo raspi-gpio set 19 op a5\n\nThis enables alternate function 5 (PWM output) on the GPIO19 pin.\n\nSave the file by typing Ctrl-o, then exit the editor by typing Ctrl-x.\n\nSimplify Boot Text:\n\nFor this next step, we will minimize the amount of boot text spewed out during the power ON process. We will also change the font size displayed on the screen so that channel and selection text will be clearly visible on the small display.\n\nTo start, type the following command:\n\nsudo nano /boot/cmdline.txt\n\nThis file consists of a single line of a long list of parameters. scroll across and locate where it says console=tty1. Change just this text to:\n\nconsole=tty3\n\ncontinue scrolling until you locate fsck.repair=yes. Remove this text.\n\nNow, go to the end of this line and add the following text:\n\nconsoleblank=0 logo.nologo quiet splash\n\nSave the file by typing Ctrl-o, then exit the editor by typing Ctrl-x.\n\nIncrease System Font Size:\n\nNow, we need to increase the system font size so that it is easier to see on the 3.5\" screen (needed for the program message outputs from the player.py python script). To increase the font size, type the following command:\n\nsudo dpkg-reconfigure console-setup\n\nSelect UTF-8 -> Guess Optimal Character Set -> Terminus -> 16X32\n\nNOTE: To revert back to the original font, type the above command again, but select:\n\nUTF-8 -> Guess Optimal Character Set -> Do not change the boot/kernel font\n\nInstall OMXPlayer:\n\nThe omxplayer is the application used to actually play the videos. There are two pieces to install the omxplayer, the application itself and the omxplayer wrapper that allows our python script to interface to the omxplayer application.\n\nSo, the first step is to install the omxplayer application. To do this, enter the following command:\n\nsudo apt-get install omxplayer\n\nYou may get a prompt asking, \"Do you want to continue? [Y/n]\". Type Y and hit <ENTER>\n\nTo install the omxplayer wrapper and its dependencies, follow these steps in order (NOTE: some of these packages may already be installed via previous steps - but, follow these steps just to be sure):\n\nsudo apt-get install -y libdbus-1-3\n\nsudo apt-get install -y libdbus-1-dev\n\nsudo apt-get install python-pip\n\nsudo apt-get install python-dev\n\nsudo apt-get install libglib2.0-dev\n\nsudo pip2 install omxplayer-wrapper\n\nsudo pip install --upgrade --no-deps --force-reinstall pathlib\n\nFor some of these steps, you may get a prompt asking, \"Do you want to continue? [Y/n]\". Type Y and hit <ENTER>\n\nSet Up Directory Structure:\n\nNow, we need to set up the directory structure for \"The Simpsons TV\". To do this, execute the following commands:\n\nsudo mkdir ~/simpsonstv\n\nsudo mkdir ~/simpsonstv/videos\n\nsudo mkdir ~/simpsonstv/videos/\"The Simpsons\"\n\nThe directories under ~/simpsonstv/videos/ are considered to be \"Channels\". So, continue using the sudo mkdir ~/simpsonstv/videos/<Channel> command for as many channels as you want. For example, on mine, I made directories(Channels) for Horror, Comedy, Action, Animated, Family, and Sci-Fi. When changing a \"channel\" in the python script, it is actually just switching to a different subdirectory. NOTE: If you want to make a directory with a space in it, be sure to put it in quotes just like was done in the command shown above making \"The Simpsons\" directory.\n\nCreating player.py Python script:\n\nWe now are ready to create the python script that will run everything. It will be named \"player.py\" to be consistent with the original project. To create this python script, enter the following command (or, you can download the player.py file in this section and copy it to the ~/simpsonstv/ directory on the Pi):\n\nsudo nano ~/simpsonstv/player.py\n\nThen copy/paste the following text into the nano text editor (paste in the nano editor by copying the text below, then selecting your terminal window, then right-clicking your mouse.):\n\n######################################################################################\n\n# player.py\n\n# Version: 1.0\n\n# Author: D.J. Hatfield\n\n# Date: 2/21/2022\n\n# Device: Raspberry Pi Zero 2 W\n\n# Purpose: At startup, this script will start playing videos in the first subdirectory\n\n# under the \"~/simpsonstv/videos/\" specified by the \"Directories\" string array.\n\n# The next video in the same directory will automatically be played once the\n\n# existing video has completed playing. All videos will be played in the current\n\n# specified directory and will loop around again once all are complete.\n\n#\n\n#\n\n# It also utilizes two \"VCR\" button inputs to implement the following features:\n\n# Right Button (GPIO 25):\n\n# -Quickly tap the button to select the next video in the current directory\n\n# -Press and hold the button for > 2 seconds to select the next \"Channel\"\n\n# (\"Channels\" are just subdirectories under the ~/simpsonstv/videos/ directory and\n\n# are specified in the \"Directories\" string array)\n\n# Left Button (GPIO 26):\n\n# -Quckly tap the button to pause or play the current video\n\n# -Press and hold the button for > 1 second to rewind current video by 10 seconds\n\n# (continue holding to keep rewinding additional 10 seconds every second the button\n\n# is pressed)\n\n# Press and hold BOTH the Right and Left buttons for > 5 seconds to shutdown the\n\n# OMXPlayer and exit this Python script and return to a command prompt. NOTE: once\n\n# this Python script is terminated, the safe shutdown functionality will not work.\n\n# You will need to either restart this Python script to re-enable this functionality\n\n# or issue a \"sudo shutdown now\" command from a command prompt to safely shutdown the\n\n# Pi.\n\n#\n\n# Additionally, this script monitors the Shutdown input (GPIO 11). If this pin\n\n# is asserted (active LOW) for > 50mS, the Pi will be Shut down.\n\n###########################################################################################\n\nfrom omxplayer.player import OMXPlayer\n\nfrom pathlib import Path\n\nimport os\n\nimport RPi.GPIO as GPIO\n\n#import time as time_ - makes sure we don't override time\n\nimport time as time_\n\nGPIO.setmode(GPIO.BCM)\n\nGPIO.setup(26, GPIO.IN, pull_up_down=GPIO.PUD_UP) #Set GPIO 26 as input with pull-up\n\nGPIO.setup(25, GPIO.IN, pull_up_down=GPIO.PUD_UP) #Set GPIO 25 as input with pull-up\n\nGPIO.setup(11, GPIO.IN, pull_up_down=GPIO.PUD_UP) #Set GPIO 11 as input with pull-up\n\n# Add/change your video subdirectories in the Directories string array\n\n# These are the \"Channels\"\n\nDirectories = [\"The Simpsons\", \"Horror\", \"Action\", \"Comedies\", \"Animated\", \"Sci-Fi\"]\n\n# <<<ROUTINES>>>\n\n#-----------------------------------------------------------------------------------------------------------------\n\n# millis(): Returns the number of milliseconds elapsed since power up.\n\ndef millis():\n\nreturn int(round(time_.time() * 1000))\n\n#-----------------------------------------------------------------------------------------------------------------\n\n# displayDirectoryVideo(): Displays the currently selected Video and Channel on the LCD\n\n# Returns nothing\n\ndef displayDirectoryVideo():\n\n#Must specify \"global\" variables - otherwise, the routine would create its own unique copy\n\n# of these variables when they are used.\n\nglobal Root_Path\n\nglobal Current_Directory\n\nglobal Current_Video\n\nglobal VIDEO_PATH\n\nglobal PlayTimer\n\nglobal playNew\n\nos.system(\"clear\") #clear the LCD screen\n\nCurrent_Video = videos[Video_Pointer] #Set current video to that specified by the Video_Pointer\n\nVIDEO_PATH = Path(Root_Path + Current_Directory + \"/\" + Current_Video)\n\nprint(\"\")\n\nprint(\"\")\n\nprint(\"\")\n\nprint(\" Channel: \" + Current_Directory) #Print the \"Channel\" (directory) on the LCD screen\n\nprint(\" \" + Current_Video[0:len(Current_Video)-4]) #Print the video selected on the LCD screen\n\nPlayTimer = millis()\n\nplayNew = True #Trigger starting the play of the new video in 1.5 seconds\n\n#-----------------------------------------------------------------------------------------------------------------\n\n# nextVideo(): Select the next video by incrementing the Video_Pointer; Loops around once the end is reached\n\n# Returns nothing\n\ndef nextVideo():\n\n#Must specify \"global\" variables - otherwise, the routine would create its own unique copy\n\n# of these variables when they are used.\n\nglobal Video_Pointer\n\nglobal videos\n\nglobal manualSelect\n\nglobal player\n\nmanualSelect = True #Set the flag to indicate the next video was manually selected\n\nplayer.quit() #Stop the currently playing video - this kills the current OMXPlayer instance\n\nVideo_Pointer += 1 # Increment Video_Pointer\n\nif(Video_Pointer > (len(videos)-1)):\n\nVideo_Pointer = 0 #Loop Video_Pointer back around once end of videos is reached\n\ndisplayDirectoryVideo() #Display Channel and Selected Video on the LCD screen\n\n#-----------------------------------------------------------------------------------------------------------------\n\n# getVideos(): Update the videos string array with a list of videos in the currently selected channel (directory)\n\n# Returns nothing\n\ndef getVideos():\n\n#Must specify \"global\" variables - otherwise, the routine would create its own unique copy\n\n# of these variables when they are used.\n\nglobal videos\n\nglobal Current_Directory\n\nglobal Root_Path\n\nvideos = [] #Clear out the videos string array\n\nfor file in os.listdir(Root_Path + Current_Directory): #Cycle through all files in the current directory and\n\nif file.lower().endswith('.mp4'): #add to videos string array if it is an mp4 video file\n\nvideos.append(file)\n\nvideos.sort() #Rearrange the videos in the videos array in alpha-numerical order\n\n#-----------------------------------------------------------------------------------------------------------------\n\n# switchDirectory(): Select the next channel (directory) in the Directories string array - also point to the first\n\n# video in this newly selected channel.\n\n# Returns nothing\n\ndef switchDirectory():\n\n#Must specify \"global\" variables - otherwise, the routine would create its own unique copy\n\n# of these variables when they are used.\n\nglobal Video_Pointer\n\nglobal Directory_Pointer\n\nglobal Current_Directory\n\nglobal Directories\n\nglobal manualSelect\n\nglobal player\n\nmanualSelect=True #Set the flag to indicate the next video was manually selected\n\nplayer.quit() #Stop the currently playing video - this kills the current OMXPlayer instance\n\nVideo_Pointer = 0 #Set video pointer to the first video in the newly specified channel\n\nDirectory_Pointer +=1 #Increment the Channel Pointer\n\nif(Directory_Pointer > (len(Directories)-1)):\n\nDirectory_Pointer = 0 #Loop the Channel pointer back around once end of channels is reached\n\nCurrent_Directory = Directories[Directory_Pointer] #Set current channel specified by the Directory_Pointer\n\ngetVideos() #Identify all videos in the newly specified channel (directory)\n\ndisplayDirectoryVideo() #Display Channel and Selected Video on the LCD screen\n\n#-----------------------------------------------------------------------------------------------------------------\n\n# autoPlayNext(): Executed when an instance of OMXPlayer exits. It automatically starts playing the next video in\n\n# the current channel if the last video played to completion. It will not try to play a video if\n\n# OMXPlayer was shutdown by the user manually (i.e. selecting through videos for the next video).\n\n# In the case of a manual video selection, the video will be played in the main loop.\n\n# Returns nothing\n\ndef autoPlayNext(code):\n\n#Must specify \"global\" variables - otherwise, the routine would create its own unique copy\n\n# of these variables when they are used.\n\nglobal Video_Pointer\n\nglobal videos\n\nglobal manualSelect\n\nglobal Video_Pointer\n\nif (manualSelect == True): #If this routine was entered by the user manually selecting the next video,\n\nmanualSelect = False # clear the manualSelect flag and,\n\nreturn # return doing nothing else - the main loop will handle manual select operations\n\nVideo_Pointer +=1 # If this routine was entered due to a video completing playback, increment the Video_Pointer\n\nif(Video_Pointer > (len(videos)-1)): #Loop the video pointer back around once the end of videos is reached\n\nVideo_Pointer = 0\n\ndisplayDirectoryVideo() #Display Channel and Selected Video on the LCD screen\n\n#--------------------------------------------------------------\n\n# <<<INITIALIZATION>>> Executed only once at script start\n\nos.system(\"clear\") #Clear the LCD screen\n\nVideo_Pointer = 0 #Set Video Pointer to point to the first video file in the current channel\n\noneShotNextVideo = False #Controls incrementing video pointer only ONCE per right button press\n\noneShotNextDirectory = False #Controls incrementing directory pointer only ONCE per extended right button press\n\nmanualSelect = False #Indicates manual video select vs automatic selection of new video file\n\nPlayTimer = 0 #Delays playing next video (allows user to read Channel/Video selection on LCD\n\nRoot_Path = \"/home/pi/simpsonstv/videos/\" #Path to this application's video channels(subdirectories)\n\nDirectory_Pointer = 0 #Set Channel (directory) pointer to first entry\n\nCurrent_Directory = Directories[0] #Point current Channel to first directory in the Directories string array\n\ngetVideos() #populate videos string array with all video files located in the current channel\n\nCurrent_Video = videos[0] #Point current video to first video in the videos string array\n\nVIDEO_PATH = Path(Root_Path + Current_Directory + \"/\" + Current_Video) #Set video path\n\nplayer = OMXPlayer(VIDEO_PATH) #Start playing video specified by the video path\n\nplayer.exitEvent += lambda _, exit_code: autoPlayNext(exit_code) #Set OMXPlayer exit event handler to call the\n\n# autoPlayNext() routine when OMXPlayer exits\n\nButton1Timer = millis() #Used to debounce VCR right button for select next video indication\n\nButton2Timer = millis() #Used to debounce VCR left button for select pause/play indication\n\nShutDownTimer = millis() #Used to debounce Shutdown signal from the safe shutdown circuit\n\nExitPythonTimer = millis() #Used to debounce the long press of BOTH left & right buttons to exit python script\n\nseekTimer = millis() #Used to debounce left button rewind long press\n\nseekToggle = True #Used to pulse a 10 second rewind for every second the left button is pressed\n\nplayNew = False #When true, triggers playing a new video 1.5 seconds after a new video selection.\n\noneShotPlayPause = False #Used to control executing a play or pause command only ONCE per left button press\n\nskipPause = False #Prevents executing a play/pause command during long (rewind) press of left button\n\n#----------------------------------------------------------------------------------------------------------------\n\n# <<<MAIN>>> Main program loop - continuously executes\n\nwhile (True):\n\ninput1 = GPIO.input(25) #Read VCR right button input\n\ninput2 = GPIO.input(26) #Read VCR left button input\n\nShutItDown = GPIO.input(11) #Read Shutdown signal input\n\n#Check GPIO 25 and debounce high and low going pulses to see if\n\n#commanded to switch to next video in the current directory\n\n#or if commanded to go to the next channel (directory) if button pressed longer than 2 seconds\n\nif((input1 == True) and (oneShotNextVideo == False)):\n\nButton1Timer = millis()\n\noneShotNextDirectory = False\n\n#Debounce right button (GPIO 25) going to the active state (LOW) for 100mS to select next video\n\nif((input1 == False)):\n\ntemp = millis()\n\nif((temp - Button1Timer) >= 100):\n\nPlayTimer = millis()\n\nif(oneShotNextVideo == False):\n\noneShotNextVideo = True\n\nnextVideo()\n\noneShotCheckLow = True\n\n#Continue checking for button press > 2 seconds for change channel (directory)\n\nif((temp - Button1Timer) >= 2000):\n\nif(oneShotNextDirectory == False):\n\nswitchDirectory()\n\noneShotNextDirectory = True\n\n#Debounce right button (GPIO 25) going to the inactive state (HIGH) for 50mS\n\nif((input1 == True) and (oneShotNextVideo == True) and (oneShotCheckLow == True)):\n\noneShotCheckLow = False\n\nButton1Timer = millis()\n\nif((input1 == True) and (oneShotNextVideo == True)):\n\ntemp = millis()\n\nif((temp - Button1Timer) >= 50):\n\noneShotNextVideo = False\n\n#-------------------------------------------------------------\n\n#Check GPIO 26 and debounce high and low going pulses to see if\n\n#commanded to switch to pause or rewind 10 seconds if pressed longer than 1 second\n\nif((input2 == True) and (oneShotPlayPause == False)):\n\nButton2Timer = millis()\n\nskipPause = False\n\n#Debounce left button (GPIO 26) going to the active state (LOW) for 100mS to toggle pause/play\n\nif((input2 == False)):\n\ntemp = millis()\n\nif((temp - Button2Timer) >= 100):\n\nif((oneShotPlayPause == False) and (skipPause == False)):\n\noneShotPlayPause = True\n\n#Continue checking for button press > 1 second for rewind\n\nif((temp - Button2Timer) >= 1000):\n\nif(seekToggle == True):\n\ntry: #Implement exception handler (try: and except:) - prevents python script from\n\n# crashing if exception occurs during (try:) code\n\nplayer.seek(-10) #Rewind video 10 seconds - causes exception if OMXPlayer has been terminated\n\nseekToggle = False\n\nseekTimer = millis()\n\noneShotPlayPause = False\n\nskipPause = True\n\nexcept Exception as e: #Exception handler - executes if exception occurs during above try:\n\nNothing = 0 # Exception code:does nothing-just catches exception/prevents Python crash\n\n#Continue rewinding 10 seconds for every 1 second the left button is pressed\n\nif((temp - seekTimer) >= 1000):\n\nseekToggle = True\n\nseekTimer = millis()\n\n#Debounce left button (GPIO 26) going to the inactive state (HIGH) for 50mS\n\nif((input2 == True) and (oneShotPlayPause == True)):\n\ntemp = millis()\n\nif((temp - Button2Timer) >= 50):\n\ntry: #Implement exception handler (try: and except:) - prevents python script from\n\n# crashing if exception occurs during (try:) code\n\nplayer.play_pause() #Toggle video play/pause - causes exception if OMXPlayer has been terminated\n\noneShotPlayPause = False\n\nexcept Exception as e: #Exception handler - executes if exception occurs during above try:\n\nNothing = 0 # Exception code:does nothing-just catches exception/prevents Python crash\n\n#-------------------------------------------------------------\n\n#Check for special case of both VCR buttons pressed > 5 seconds (command to exit player.py Python script)\n\nif ((input1 == False) and (input2 == False)):\n\ntemp = millis()\n\nif ((temp - ExitPythonTimer) >= 5000):\n\nplayer.quit() #Shut down OMXPlayer\n\nprint(\"Exiting Python script\")\n\nquit() #Exit player.py Python script\n\nelse:\n\nExitPythonTimer = millis()\n\n#-------------------------------------------------------------\n\n#Check GPIO pin 11 for signal to safetly shutdown Pi (active low)\n\n# this signal is only debounced on assertion for 50mS\n\ntemp = millis()\n\nif ((ShutItDown == False) and ((temp - ShutDownTimer) >= 50)):\n\nos.system(\"clear\") #Clear the LCD screen\n\nprint(\"\")\n\nprint(\"\")\n\nprint(\" Shutting Down...\") #Print \"Shutting Down...\" message on the LCD screen\n\nos.system(\"sudo shutdown -h now\") #Shut down the Raspberry Pi - the safe shutdown circuit will monitor the\n\n# status LED signal and remove power once activity ceases\n\nif (ShutItDown == True): #Reset ShutDown timer if ShutItDown signal deasserts before timer times out\n\nShutDownTimer = millis()\n\n#-------------------------------------------------------------\n\n#Play next selection 1.5 seconds after last command to change video or directory\n\n# This allows enough time for a user to read the channel (directory) and\n\n# new video selected on the screen\n\n# This is controlled by the playNew boolean variable. When playNew is set, it\n\n# triggers playing the new video 1.5 seconds later\n\ntemp = millis()\n\nif((temp - PlayTimer) >= 1500 and (playNew == True)):\n\nplayer=OMXPlayer(VIDEO_PATH) #Start playing video specified by the video path\n\nplayer.exitEvent = lambda _, exit_code: autoPlayNext(exit_code) #Set OMXPlayer exit event handler to call the\n\n# autoPlayNext() routine when OMXPlayer exits\n\nplayNew = False #Reset the playNew flag\n\nmanualSelect = False #Reset the manualSelect flag (indicates automatic play unless changed by user)\n\nBefore you save, you should modify line 51 of the python code with your directories (\"channels\"). Line 51 above defines a string array called Directories. This line of code is explicitly:\n\nDirectories = [\"The Simpsons\", \"Horror\", \"Action\", \"Comedies\", \"Animated\", \"Sci-Fi\"]\n\nChange the entries to match the sub-directories you created in the ~/simpsonstv/videos/ directory. The order in this string array determines the order that the \"channels\" will sequence through when you press the \"Next Channel\" function on the VCR. Feel free to add or delete \"channels\".\n\nWhen you are done editing, save the file by typing Ctrl-o. Give it the filename \"player.py\", then exit the editor by typing Ctrl-x.\n\nAlmost there! All that is left on the software side of things is to copy your video files into their \"Channels\" and configure the system to automatically start running the player.py python script at startup.\n\nStep 18: Copying Video Files Into Channels\n\nOn your computer, copy your legally-owned video files you generated onto a USB drive. The ideal format for these videos is .mp4 with a screen resolution of 480 pixels wide by 320 pixels tall (3:2 format). Although, 4:3 format videos play well on the screen with very little black banding at the top and bottom of the screen. Handbrake is an excellent, free program that you can use to re-format your videos into the 480 x 320 format. Also, be sure your videos are in the MP4 format.\n\nFor this step, I'm assuming you have videos already generated and ready to be copied onto your \"Simpsons TV\".\n\nSo, first copy the videos to a USB drive on your computer.\n\nThen, eject the USB drive from the computer.\n\nInsert the USB drive into your Raspberry Pi (NOTE: you will likely need a full-size USB-A to USB-micro-B adapter)\n\nThe USB drive will be automatically mounted to the /media/usb/ directory.\n\nTo copy your video files from the USB drive, enter the following command:\n\ncp /media/usb/* ~/simpsonstv/videos/<directory>/\n\nwhere /media/usb/* is the source directory and wildcard for all files and ~/simpsonstv/videos/<directory> is the \"Channel\" subdirectory to which you want to copy the videos (replace <directory> with the name of the subdirectory). Just a reminder, be sure to use quotes around the subdirectory name or filename if it has one or more spaces in it. Modify the directory structure as needed to match your source and destination directories.\n\nOnce you are done copying files from the USB drive, you can eject it by entering the following command:\n\nsudo eject /dev/sda1\n\nTo see how much memory space you have left on your SD card, enter the following command:\n\ndf -h\n\nThis shows the amount of free space in /dev/root is available to use for videos.\n\nThe last software configuration task is to configure the system to start the player.py python script at startup.\n\nConfiguring Automatic Startup of player.py\n\nI'm going to diverge from Brandon's implementation a bit more here. Brandon implemented a couple of services at boot time to start up and run his python scripts. This does not work well for my implementation as I want to print Channel and Video selection text on the LCD screen when a user presses the \"Next Video\" button or changes \"Channels\". If I used a service to start my python script, it would not show any text I printed out to the screen. This has to do with when the python.py script is started. If it is started during system initialization (as is done with the services method), then it does not get access to the screen.\n\nTo solve this problem, I used the .bashrc file to start up my player.py python script. This is easy to do. Simply modify the .bashrc file by entering the following command:\n\nsudo nano ~/.bashrc\n\nscroll to the end of the file and enter the following on the last line:\n\nsudo python ~/simpsonstv/player.py\n\nSave the file by typing Ctrl-o, hit <ENTER>, then exit the editor by typing Ctrl-x.\n\nShutdown the Pi by typing the following command:\n\nsudo shutdown now\n\nRemove all power and cables from the Raspberry Pi once the activity LED is fully OFF and no longer blinking.\n\nWhew! You've done a lot! - go take a break, get a snack, save the planet...We'll still be here when you get back. The final steps will be gluing and plugging everything together.\n\nStep 19: Finish Assembly (Glue Time!)\n\nWe’re now coming down the home stretch! All that is left is to assemble the 3D printed parts, mount the assemblies you’ve made, and connect all the electrical connections. There are a lot of steps, so let’s get going…\n\nStep 1: If you’re going to spray paint the bezel area of the TV front (like I did), apply painter’s tape to the TV front to mask off all the areas you don’t want the paint to go. Wrap the painter’s tape around the sides to prevent overspray from depositing there.\n\nStep 2: Paint the bezel area of the TV front. I used a gloss black spray paint compatible with plastic (I used Rustoleum Universal) because I’m better with spray paint than I am painting with a brush. Plus, I couldn’t find the spray paint in Dioxazine Purple (or similar color) that Brandon specified in his build. Remove the painter’s tape and, while the paint is still soft, use cotton swabs wetted with isopropyl alcohol to clean any overspray or leakage under the painter’s tape around the outer bezel edges.\n\nStep 3: Press fit two of the 1/4\" x 1/16” magnets into the TV housing as shown in Step 3 of the first assembly picture. If the holes are too tight for the magnets to fit, use a small round file to ream out the holes to fit. If the magnets fit too loosely, use a small amount of super glue to affix the magnets in the holes.\n\nStep 4: Identify the magnetic pole polarity of the other two 1/4\" x 1/16” magnets by placing them on the first two you installed in the TV housing. Since these will be used to hold the TV front onto the TV housing, they need to attract one another and not repel.\n\nStep 5: Insert the two magnets from Step 4 into the TV front (noting the proper orientation for attraction to the other magnets) as shown in Step 5 of the first assembly picture. Use the same techniques outlined in Step 3 if the magnets do not quite fit right or securely.\n\nStep 6: Using just a drop of super glue for each TV foot, glue the four TV feet into the recesses on the bottom of the TV housing. Test fit each TV foot before gluing. You will likely need to use a small flat file to file around the edges of each TV foot to get it to fit in the recess due to the first 3D-printed layer spreading out a bit. Use a small round file if you need to clean up any of the recesses on the TV housing. Note the proper orientation of each TV foot in Step 6 of the first assembly picture.\n\nStep 7: Use a sparing amount of super glue to glue in the front grille into the TV front. Test fit first before gluing. You may need to use a small flat file on the front grille sides to insure a proper fit.\n\nStep 8: Remove the potentiometer (pot) knob from the audio circuit by prying it off with a small screwdriver. Align the pot of the audio circuit assembly with the volume knob base (Note the orientation of the volume knob base relative to the pot position as the shaft of the pot is not symmetrically positioned in the body of the pot – the “T” on the volume knob base marks the TOP).\n\nStep 9: Using a sparing amount of super glue, affix the pot into the volume knob base (be careful and do not use too much glue as capillary action could cause the glue to flow into the front of the pot, which will ruin it – apply only to the sides of the inside of the volume knob base). Again, test the fit before gluing and note the proper orientation of the pot shaft in the volume knob base – it should be centered in the hole. Also, glue the volume knob on the pot knob with a small amount of super glue. You will likely need to use small round and flat files to clean up the insertion points of the 3D prints so that the pot and its knob will fit properly with the 3D printed parts.\n\nStep 10: Insert the assembled volume knob onto the pot shaft as shown in Step 10 of the first assembly picture.\n\nStep 11: Use a very small amount of super glue applied only to the inner sides of the power button base to affix the power button as shown in Step 11 of the first assembly picture. The switch is particularly prone to super glue flowing into it via capillary action, which will destroy it – so, again, a very small amount of super glue. Test fit before gluing and file the power button base as needed for proper fit. Note the switch orientation.\n\nStep 12: File or grind away the tips of the two #6 x 3/8” long machine screws to prevent them from causing a small bump in the VCR when they are screwed in.\n\nStep 13: Route the three wires of the VCR assembly through the square hole on the top of the TV housing. Use the two #6 x 3/8” long machine screws to attach the VCR assembly to the TV housing (don’t over tighten).\n\nStep 14: Remove the protective film from the LCD screen.\n\nStep 15: Position the LCD in the recess provided on the TV front with the orientation as shown in Step 15 of the first assembly picture. Affix the LCD in place using hot-melt glue in the locations shown. Be careful not to get any glue in the front latch area on the left and volume & power knob areas on the right.\n\nStep 16: Insert the 3D printed power button in the square power button hole on the TV front. File the base of the power button as needed for proper fit and movement in the hole.\n\nStep 17: Insert the power button base and volume knob base assemblies into their respective holes (Note the proper orientation of both). Use hot-melt glue to glue them in place.\n\nStep 18: Use hot-melt glue to glue the speaker into the back of the TV housing.\n\nStep 19: Insert the loose terminal (GREY wire for left button) from the VCR assembly into the middle position of the 3-position DuPont socket connector of the audio amplifier assembly (This is the only 3-position DuPont socket connector used in this project build, so it should be easy to identify).\n\nStep 20: Position the micro USB power connector assembly in the rear-left-bottom of the TV housing as shown in Step 20 of the second assembly picture. The connector should line up with the hole in the rear of the TV housing. Plug the unpowered micro USB plug from the AC to DC power supply into the micro USB power connector on the assembly to properly locate it and hold it in place while gluing. Use hot-melt glue to glue the micro USB power connector assembly in place taking care not to get glue in the connector itself – but, do put some glue around the two wires to prevent breakage due to bending. Unplug the power supply once the glue hardens.\n\nStep 21: Turn the micro volume potentiometer on the audio amplifier board all the way clockwise (maximum amplification) then use hot-melt glue to glue the audio amplifier board in the lower-right of the housing as shown in Step 21 of the second assembly picture taking care not to get glue on the micro potentiometer – but, do put some glue around each of the wires to prevent breakage.\n\nStep 22: Use hot-melt glue to affix the safe shutdown board assembly in the upper-left rear of the TV housing as shown in Step 22 of the second assembly picture. Connect the RED and BLACK wire 2-position DuPont connector from the micro USB power assembly onto the lower-right 2-position header on the safe shutdown board assembly as shown (BLACK wire must be on the left and RED wire must be on the right for proper polarity).\n\nStep 23: Install the Raspberry Pi Zero 2 W onto the LCD’s header as shown in Step 23 of the second assembly picture. Now would also be a good time to turn the black knob on the LCD fully clockwise – this is the brightness control for the LCD and fully clockwise is maximum brightness.\n\nStep 24: Connect the RED and BLACK wire 2-position DuPont connector from the safe shutdown board assembly to the Raspberry Pi header as shown in Step 24 of the second assembly picture (BLACK wire must be on Pi pin 6 and the RED wire must be on Pi pin 4 for proper polarity - if you get these backwards, you'll have a sad day when you try to power on the Simpsons TV).\n\nStep 25: Connect the BLUE and PURPLE wire 2-position DuPont connector from the power button assembly onto the lower-left 2-position header on the safe shutdown board assembly as shown in Step 25 of the second assembly picture (polarity of this connection does not matter).\n\nStep 26: Connect the YELLOW wire 1-position DuPont connector from the Raspberry Pi (Status LED signal) onto the upper-right 1-position header on the safe shutdown board assembly as shown in Step 26 of the second assembly picture.\n\nStep 27: Make the final electrical connections to the Raspberry Pi as shown in Step 27 of the third assembly drawing:\n\nConnect the audio amplifier (+) RED power wire 1-position DuPont connector to Pi pin 2.\n\nConnect the VCR WHITE and BLACK wire 2-position DuPont connector to Pi pins 22 and 20 respectively – polarity matters on this one (no damage will occur if you get these backwards, but the VCR buttons will not operate properly).\n\nConnect the safe shutdown board assembly's BROWN wire 1-position DuPont connector to Pi pin 23.\n\nConnect the BROWN audio wire, GREY VCR wire, and ORANGE audio wire 3-position DuPont connector to Pi pins 39, 37, and 35 respectively – polarity matters here as well.\n\nStep 28: Straighten two ~1” / 25mm pieces of black 1.75mm diameter 3D printer filament (hot air works well for this). Apply a small amount of super glue to the bottom of each and insert into the antennae holes on top of the VCR. Apply a small amount of super glue to the top and install the antenna balls. Test fit all parts before gluing and use a small round file to clean up insertion holes if needed.\n\nStep 29: Attach the TV front assembly to the TV housing by engaging the latch on the left then rotating the TV front towards the TV housing until the magnets secure the right end.\n\nAll done with assembly! – pat yourself on the back (if you haven't super glued your hands together) and get ready to power up.\n\nStep 20: Power Up and Operation\n\nOperation of the Simpsons TV is pretty straightforward:\n\nPress the power button to turn the TV ON/OFF. When powering ON, it will take about 15-20 seconds for the Pi to boot. Once booted, the Simpsons TV will automatically start playing videos from the first channel.\n\nTurn the audio volume knob to increase / decrease volume\n\nLeft Button Operation:\n\nQuickly tap the left button to pause or play the current video\n\nPress and hold the left button for > 1 second to rewind 10 seconds (continue holding to keep rewinding)\n\nRight Button Operation:\n\nQuickly tap the right button to select the next video in the current channel\n\nPress and hold the right button for > 2 seconds to select the next channel\n\nPress and hold BOTH the left and right buttons at the same time for > 5 seconds to stop video playing and exit the Python script to a command prompt (NOTE: None of the buttons will work at this point, including the power button – you will need to connect a keyboard or SSH into the TV and execute a “sudo shutdown now” command to properly shutdown the Pi or restart the player.py Python script to re-enable button functionality).\n\nStep 21: Useful Raspberry Pi Linux Commands\n\nThis section provides a list of Linux commands I found useful during development and use of this project. I hope you find them useful as well.\n\nHow to exit a Python terminal and Shutdown OMXPlayer instance:\n\nWhen you connect to \"The Simpsons TV\" via SSH, it will execute another instance of the python player.py script. This will start up another independent version of the omxplayer, which will start playing another video. This can result in multiple videos trying to play at the same time (glitchy video and overlapped audio). To kill this new omxplayer instance, do the following:\n\nWhen you establish a new SSH session, your terminal will be inside a python terminal window. To exit this terminal, type \"Ctrl-A-\\\".\n\nAt the resulting raspberry pi prompt, type, \"pgrep -a omxplayer\". This will list all current instances of the omxplayer and their process IDs.\n\nNote the process id of the LAST instance of omxplayer - type \"sudo kill <process id>\". This will kill the new omxplayer instance that was started by the SSH connection.\n\nBelow is an example of this sequence of commands:\n\npi@raspberrypi:~ $ pgrep -a omxplayer\n\n756 /bin/bash /usr/bin/omxplayer /home/pi/simpsonstv/videos/The Simpsons/Season 1 - Episode 01.mp4\n\n768 /usr/bin/omxplayer.bin /home/pi/simpsonstv/videos/The Simpsons/Season 1 - Episode 01.mp4\n\npi@raspberrypi:~ $ sudo kill 768\n\npi@raspberrypi:~ $ Terminated\n\nHow to Change WiFI SSID and/or Password:\n\nsudo nano /etc/wpa_supplicant.conf\n\nAfter making edits, save the file by typing Ctrl-o, hit <ENTER>, then exit the editor by typing Ctrl-x.\n\nHow to copy movies from USB drive to SD Card \"Channel\":\n\nsudo cp /media/usb/<directory>/* ~/simpsonstv/videos/<channel>\n\nwhere <directory> is the directory name on the USB drive to copy from, * is a wildcard to copy all files in the <directory> or explicit filename to copy, and <channel> is the directory on the Pi's SD card to copy to. Note: You must include quotes if the file or directory name has spaces in it (i.e. \"The Simpsons\" for example).\n\nHow to Eject a USB Drive from the Pi:\n\nsudo eject /dev/sda1\n\nHow to Automatically Install Package Dependencies for a Failed Package Install:\n\nsudo apt --fix-broken install\n\nThis w"
    }
}