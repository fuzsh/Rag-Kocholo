{
    "id": "dbpedia_1588_2",
    "rank": 29,
    "data": {
        "url": "https://martinfowler.com/agile.html",
        "read_more_link": "",
        "language": "en",
        "title": "Agile Software Guide",
        "top_image": "https://martinfowler.com/articles/poetta.jpg",
        "meta_img": "https://martinfowler.com/articles/poetta.jpg",
        "images": [
            "https://martinfowler.com/mf-name-white.png",
            "https://martinfowler.com/mf.jpg",
            "https://martinfowler.com/img/agile/agileManifestoBackground.jpg",
            "https://martinfowler.com/img/video/xconf-hands-up.png",
            "https://martinfowler.com/articles/agileFluency/agile-fluency-model-v2-simple-2-1.png",
            "https://refactoring.com/refactoring-logo.png",
            "https://martinfowler.com/articles/is-quality-worth-cost/card.png",
            "https://martinfowler.com/bliki/images/selfTestingCode/sketch.png",
            "https://martinfowler.com/articles/itsNotJustStandingUp/standingup.jpg",
            "https://martinfowler.com/articles/on-pair-programming/card.jpg",
            "https://martinfowler.com/bliki/images/conversationalStories/decreed.png",
            "https://martinfowler.com/bliki/images/frequency-reduces-difficulty/graph.png",
            "https://martinfowler.com/articles/remote-or-co-located/card.png",
            "https://martinfowler.com/bliki/images/outcomeOriented/outcome-oriented.png",
            "https://martinfowler.com/articles/agile-aus-2018/card.jpg",
            "https://martinfowler.com/thoughtworks_white.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Martin Fowler"
        ],
        "publish_date": "2019-08-01T00:00:00",
        "summary": "",
        "meta_description": "Agile software development is an approach designed to build software for uncertain and changing needs.",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "martinfowler.com",
        "canonical_link": "https://martinfowler.com/agile.html",
        "text": "In the last decade agile software development has moved from being a cult technique to an increasing part of the mainstream. I was lucky enough to be at the beginning of this story, with early experiences on the 'birth project' of Extreme Programming and a co-author of the Manifesto for Agile Software Development. Thoughtworks started using agile techniques in 2000 and we've since successfully used them on our projects world-wide. We've learned a huge amount about using agile methods in enterprise settings and are committed to sharing this learning to help foster their intelligent adoption.\n\nThe Essence of Agile Software Development\n\nIt's been over a decade since the developers of agile methods first started to talk about their approaches. In this time agile thinking has changed from a niche activity to an approach that is widely used. However, like any popular technique, agile software development has suffered from semantic diffusion, so much of what we see under the name of agile doesn't bear much resemblance to what the early pioneers were doing. So I think it's important to revisit the essential elements of agile thinking.\n\nI've always seen the essence of agile thinking resting on two contrasts with traditional plan-driven software engineering:\n\nAgile Development\n\nis adaptive rather than predictive\n\nis people-oriented rather than process-oriented\n\nPlan-driven engineering expects us to come up with a predictive plan that precedes development. The plan lays out the people, resources and timelines for the overall project. Software design is also done up-front, with implementation expected to conform with this design. Success is measured according to how well development follows this plan.\n\nAgile plans are a baseline that we use to help us control changes. Agile teams plan just as carefully as traditional teams, but the plans are constantly revising to reflect the things we learn during a project. Success is based on value delivered by the software.\n\nPlan-driven engineering seeks a process which provides enough structure to reduce individual variations to insignificance. Such an industrial process is more predictable, copes better when people transfer, and is easier to define skills and career paths.\n\nAgile engineering sees software development as a primarily human activity, where the people involved and how they bond as a team are the primary driver behind success. Processes (and tools) can enhance a team's effectiveness, but are always second-order influences.\n\nThe Agile Fluency Model\n\nAgile methods are solidly in the mainstream, but that popularity hasn't been without its problems. Organizational leaders are complaining that they’re not getting the benefits they expected. This article presents a fluency model that will help you get the most out of agile ideas. Fluency evolves through four distinct zones, each with its own benefits, required proficiencies, and key metrics.\n\nTechnical Practices\n\nTo make agile work, you need solid technical practices. A lot of agile education under-emphasizes these, but if you skimp on this you won't gain the productivity and responsiveness benefits that agile development can give you (stranding you in the first zone of agile fluency). This is one of the reasons that I still think that Extreme Programming is the most valuable of the named agile methods as a core and starting point.\n\nRefactoring Guide\n\nRefactoring is a disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behavior. Its heart is a series of small behavior preserving transformations. Each transformation (called a \"refactoring\") does little, but a sequence of these transformations can produce a significant restructuring. Since each refactoring is small, it's less likely to go wrong. The system is kept fully working after each refactoring, reducing the chances that a system can get seriously broken during the restructuring.\n\nIs High Quality Software Worth the Cost?\n\nA common debate in software development projects is between spending time on improving the quality of the software versus concentrating on releasing more valuable features. Usually the pressure to deliver functionality dominates the discussion, leading many developers to complain that they don't have time to work on architecture and code quality. This debate is based on the assumption that increasing quality also increases costs, which is our common experience. But the counter-intuitive reality is that internal software quality removes the cruft that slows down developing new features, thus decreasing the cost of enhancing the software.\n\nContinuous Delivery Guide\n\nIt’s hard enough for software developers to write code that works on their machine. But even when that’s done, there’s a long journey from there to software that’s producing value - since software only produces value when it’s in production. he essence of my philosophy to software delivery is to build software so that it is always in a state where it could be put into production. We call this Continuous Delivery because we are continuously running a deployment pipeline that tests if this software is in a state to be delivered.\n\nSelf Testing Code\n\nSelf-Testing Code is the name I used in Refactoring to refer to the practice of writing comprehensive automated tests in conjunction with the functional software. When done well this allows you to invoke a single command that executes the tests - and you are confident that these tests will illuminate any bugs hiding in your code.\n\nIs Design Dead?\n\nFor many that come briefly into contact with Extreme Programming, it seems that XP calls for the death of software design. Not just is much design activity ridiculed as \"Big Up Front Design\", but such design techniques as the UML, flexible frameworks, and even patterns are de-emphasized or downright ignored. In fact XP involves a lot of design, but does it in a different way than established software processes. XP has rejuvenated the notion of evolutionary design with practices that allow evolution to become a viable design strategy. It also provides new challenges and skills as designers need to learn how to do a simple design, how to use refactoring to keep a design clean, and how to use patterns in an evolutionary style.\n\nCode As Documentation\n\nOne of the common elements of agile methods is that they raise programming to a central role in software development - one much greater than the software engineering community usually does. Part of this is classifying the code as a major, if not the primary documentation of a software system.\n\nCollaboration\n\nImproving human collaboration is at the heart of agile thinking. Communication and feedback are two of the stated values of Extreme Programming, and agilists look to find ways to maximise these as part of their projects\n\nProblems\n\nWhile the agile mindset can help many teams deliver software more effectively, the world of agile software is far from free of problems. As with any popular approach semantic diffusion has set in, resulting in many things being done in the name of \"agile\" that have little to do with the ideas that motivated us to write the manifesto.\n\nThe State of Agile Software in 2018\n\nOn the surface, the world of agile software development is bright, since it is now mainstream. But the reality is troubling, because much of what is done is faux-agile, disregarding agile's values and principles. The three main challenges we should focus on are: fighting the Agile Industrial Complex and its habit of imposing process upon teams, raising the importance of technical excellence, and organizing our teams around products (rather than projects). Despite the problems, the community's great strength is its ability to learn and adapt, tackling problems that we original manifesto authors didn't imagine.\n\nSemantic Diffusion\n\nI have the habit of creating Neologisms to describe the things I see in software development. It's a common habit amongst writers in this field, for software development still lacks much useful jargon. One of the problems with building a jargon is that terms are vulnerable to losing their meaning, in a process of semantic diffusion - to use yet another potential addition to our jargon.\n\nAgile Imposition\n\nAccording to the current board of the Agile Alliance, agile methods have \"crossed the chasm\" , which I think means they are becoming more widespread. While this has its advantages, it also brings problems. As a methodology or design approach becomes fashionable, then we see a lot people using it, or teaching it, who are focusing on the fashion rather than the real details. This can lead to reports of things done in agile's name which are a polar opposite to the principles of movement's founders.\n\nFlaccid Scrum\n\nThere's a mess I've heard about with quite a few projects recently. It works out like this:\n\nThey want to use an agile process, and pick Scrum\n\nThey adopt the Scrum practices, and maybe even the principles\n\nAfter a while progress is slow because the code base is a mess\n\nFeature Devotion\n\nA common, perhaps dominant, practice of agile methods is to develop a list of features (often called stories) for the software that's being built. These features are tracked with index cards, work queues, burndown charts, backlogs, or whatever your tool of choice is."
    }
}