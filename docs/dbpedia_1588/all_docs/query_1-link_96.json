{
    "id": "dbpedia_1588_1",
    "rank": 96,
    "data": {
        "url": "https://worldofagile.com/blog/agile-methodology-and-frameworks/",
        "read_more_link": "",
        "language": "en",
        "title": "Agile Methodology and Frameworks",
        "top_image": "https://worldofagile.com/wp-content/uploads/2018/03/Agile-Umbrella.png",
        "meta_img": "https://worldofagile.com/wp-content/uploads/2018/03/Agile-Umbrella.png",
        "images": [
            "https://worldofagile.com/wp-content/uploads/2020/06/Intro_to_WOA.png",
            "https://worldofagile.com/wp-content/uploads/2018/03/Agile-Umbrella.png",
            "https://worldofagile.com/wp-content/uploads/2020/10/TDD-300x264.png",
            "https://worldofagile.com/wp-content/plugins/contact-forms-builder//assets/images/loader.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Amit Kulkarni"
        ],
        "publish_date": "2016-03-07T14:39:30+00:00",
        "summary": "",
        "meta_description": "This post describes the agile methodology and frameworks known in the industry. Some of the famous ones are Scrum, Extreme Programming, Kanban, Lean",
        "meta_lang": "en",
        "meta_favicon": "https://worldofagile.com/wp-content/uploads/2020/06/cropped-cropped-woa_logo-2-32x32.png",
        "meta_site_name": "Welcome to World of Agile",
        "canonical_link": "https://worldofagile.com/blog/agile-methodology-and-frameworks/",
        "text": "Agile is a philosophy and a mindset. Agile is not a methodology. Agile consists of a set of methodologies and frameworks which fulfill certain aspects of the Agile Manifesto described earlier. I look at Agile as a umbrella with various agile methodology and frameworks under the umbrella\n\nFollowing are some of the popular Agile Methodology (ies) and Frameworks\n\nScrum\n\nLean software development\n\nExtreme Programming(XP)\n\nDynamic Systems Development Method (DSDM)\n\nTest Driven Development (TDD)\n\nAcceptance Test Driven Development (ATDD)\n\nWe will also learn in this post about applying ITSM principles to Agile\n\nScrum\n\nScrum is an iterative and incremental Agile software development framework for managing software projects and product or application development. Its focus is on “a flexible, holistic product development strategy where developers works as a unit to reach a common goal” as opposed to a “traditional, sequential approach”. Scrum enables the creation of self-organizing teams by encouraging co-location of all team members, and verbal communication among all team members and disciplines in the project.\n\nScrum is a project Management framework which enables one to execute the projects. The other methodology tools and techniques work very well in the Scrum framework. Following picture depicts the Scrum as a framework working with tools and techniques from other methods such as Lean, Extreme Programming, TDD and DSDM.\n\nWe will be studying SCRUM in detail in the next few chapters.\n\nLean Software Development\n\nThe core idea is to maximize customer value while minimizing waste. Simply, lean means creating more value for customers with fewer resources.\n\nA lean organization understands customer value and focuses its key processes to continuously increase it. The ultimate goal is to provide perfect value to the customer through a perfect value creation process that has zero waste.\n\nTo accomplish this, lean thinking changes the focus of management from optimizing separate technologies, assets, and vertical departments to optimizing the flow of products and services through entire value streams that flow horizontally across technologies, assets, and departments to customers.\n\nEliminating waste along entire value streams, instead of at isolated points, creates processes that need less human effort, less space, less capital, and less time to make products and services at far less costs and with much fewer defects, compared with traditional business systems. Companies are able to respond to changing customer desires with high variety, high quality, low cost, and with very fast throughput times. Also, information management becomes much simpler and more accurate.\n\nExtreme Programming\n\nReference : http://www.extremeprogramming.org\n\nExtreme Programming (XP) is a software development agile methodology which is intended to improve software quality and responsiveness to changing customer requirements. As a type of agile software development, it advocates frequent “releases” in short development cycles, which is intended to improve productivity and introduce checkpoints at which new customer requirements can be adopted.\n\nExtreme Programming improves a software project in five essential ways;\n\ncommunication\n\nsimplicity\n\nfeedback\n\nrespect\n\ncourage\n\nDSDM\n\nDynamic systems development method (DSDM) is an agile methodology, primarily used as a software development method. First released in 1994, DSDM originally sought to provide some discipline to the rapid application development (RAD) method. In 2007 DSDM became a generic approach to project management and solution delivery. DSDM is an iterative and incremental approach that embraces principles of Agile development, including continuous user/customer involvement.\n\nDSDM fixes cost, quality and time at the outset and uses the MoSCoW prioritisation of scope into musts, shoulds, coulds and won’t haves to adjust the project deliverable to meet the stated time constraint. DSDM is one of a number of Agile methods for developing software and non-IT solutions, and it forms a part of the Agile Alliance.\n\nThe previous version of DSDM (released in May 2003) which is still widely used and is still valid is DSDM 4.2 which is a slightly extended version of DSDM version 4. The extended version contains guidance on how to use DSDM with Extreme Programming.\n\nDSDM Principles\n\nThere are eight principles underpinning DSDM. These principles direct the team in the attitude they must take and the mindset they must adopt in order to deliver consistently.\n\nFocus on the business need\n\nDeliver on time\n\nCollaborate\n\nNever compromise quality\n\nBuild incrementally from firm foundations\n\nDevelop iteratively\n\nCommunicate continuously and clearly\n\nDemonstrate control\n\nTest Driven Development – TDD\n\nTest-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle: first the developer writes an (initially failing) automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally refactors the new code to acceptable standards. Kent Beck, who is credited with having developed or ‘rediscovered’ the technique, stated in 2003 that TDD encourages simple designs and inspires confidence.\n\nTest-driven development is related to the test-first programming concepts of extreme programming, begun in 1999, but more recently has created more general interest in its own right.\n\nProgrammers also apply the concept to improving and debugging legacy code developed with older techniques\n\nTest-driven development cycle\n\nA graphical representation of the development cycle, using a basic flowchart\n\nThe following sequence is based on the book Test-Driven Development by Example.\n\nAdd a test\n\nIn test-driven development, each new feature begins with writing a test. This test must inevitably fail because it is written before the feature has been implemented. (If it does not fail, then either the proposed “new” feature already exists or the test is defective.) To write a test, the developer must clearly understand the feature’s specification and requirements. The developer can accomplish this through use cases and user stories to cover the requirements and exception conditions, and can write the test in whatever testing framework is appropriate to the software environment. This could also be a modification of an existing test. This is a differentiating feature of test-driven development versus writing unit tests after the code is written: it makes the developer focus on the requirements before writing the code, a subtle but important difference.\n\nRun all tests and see if the new one fails\n\nThis validates that the test harness is working correctly and that the new test does not mistakenly pass without requiring any new code. This step also tests the test itself, in the negative: it rules out the possibility that the new test always passes, and therefore is worthless. The new test should also fail for the expected reason. This increases confidence (though does not guarantee) that it is testing the right thing, and passes only in intended cases.\n\nWrite some code\n\nThe next step is to write some code that causes the test to pass. The new code written at this stage is not perfect, and may, for example, pass the test in an inelegant way. That is acceptable because later steps improve and hone it.\n\nAt this point, the only purpose of the written code is to pass the test; no further (and therefore untested) functionality should be predicted and ‘allowed for’ at any stage.\n\nRun tests\n\nIf all test cases now pass, the programmer can be confident that the code meets all the tested requirements. This is a good point from which to begin the final step of the cycle.\n\nRefactor code\n\nNow the code should be cleaned up as necessary. Move code from where it was convenient for passing the test to where it logically belongs. Remove any duplication you can find. Make sure that variable and method names represent their current use. Clarify any constructs that might be misinterpreted. Use Kent Beck’s four rules of simple design to guide you, as well as anything else you know about writing clean code. By re-running the test cases, the developer can be confident that code refactoring is not damaging any existing functionality.\n\nThe concept of removing duplication is an important aspect of any software design. In this case, however, it also applies to removing any duplication between the test code and the production code—for example magic numbers or strings repeated in both to make the test pass in step 3.\n\nRepeat\n\nStarting with another new test, the cycle is then repeated to push forward the functionality. The size of the steps should always be small, with as few as 1 to 10 edits between each test run. If new code does not rapidly satisfy a new test, or other tests fail unexpectedly, the programmer should undo or revert in preference to excessive debugging. Continuous integration helps by providing revertible checkpoints. When using external libraries it is important not to make increments that are so small as to be effectively merely testing the library itself, unless there is some reason to believe that the library is buggy or is not sufficiently feature-complete to serve all the needs of the main program being written.\n\nAcceptance Test Driven Development\n\nAcceptance Test Driven Development (ATDD) is the extension of Test Driven Development TDD in agile. The ATDD includes typical tests that test the behavior of the system. ATDD needs to test the expected behavior of the system from the user’s point of view.\n\nSteps followed by an agile team in ATDD agile:\n\nDiscuss : During the planning meeting we ask the product owner or customer questions that are designed to gather acceptance criteria.\n\nDistill : In this phase we get the tests ready (distill) to be entered into the acceptance test tool. .\n\nDevelop: In this phase we develop the code and hook up the tests. Initially the tests fail because they cannot find the necessary code. Once the code is written and tests are hooked to it, the tests validate the code. They may again fail, so the proeces of writing code and testing continues until the code passes the tests.\n\nDemo : The team does exploratory testing using the automated acceptance testing scripts and demos the software to the customer.\n\nApplying Agile Principles to ITSM\n\nFirst of all, using practices from Agile methodologies such as Scrum in the context of ITSM does not necessarily make ITSM Agile. There are instance where people have set up a support team using an issue backlog similar to the sprint backlog from Scrum, are doing daily stand-up meetings with that team to review progress and impediments to progress, and a number of other practices similar to Scrum. Doing Agile is not the same as being Agile, instead, it is actually about improving ITSM practices by applying Agile principles.\n\nLet us take a principles-based approach to applying Agile to ITSM, not a practice-based approach. The difference is that the principles give guidance on how to do things in a better way, whereas the practices just follow from these principles in the specific context of the services you provide.\n\nAgile principles, as per the Agile Manifesto and Principles discussed earlier, come down to a number of core items:"
    }
}