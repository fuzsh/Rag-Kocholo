{
    "id": "dbpedia_7816_3",
    "rank": 93,
    "data": {
        "url": "https://docs.python.org/3/library/ast.html",
        "read_more_link": "",
        "language": "en",
        "title": "ast â Abstract Syntax Trees",
        "top_image": "https://docs.python.org/3/_static/og-image.png",
        "meta_img": "https://docs.python.org/3/_static/og-image.png",
        "images": [
            "https://docs.python.org/3/_static/py.svg",
            "https://docs.python.org/3/_static/py.svg",
            "https://docs.python.org/3/_static/py.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Source code: Lib/ast.py The ast module helps Python applications to process trees of the Python abstract syntax grammar. The abstract syntax itself might change with each Python release; this modul...",
        "meta_lang": "en",
        "meta_favicon": "../_static/py.svg",
        "meta_site_name": "Python documentation",
        "canonical_link": "https://docs.python.org/3/library/ast.html",
        "text": "Parse the source into an AST node. Equivalent to compile(source, filename, mode, ast.PyCF_ONLY_AST).\n\nIf type_comments=True is given, the parser is modified to check and return type comments as specified by PEP 484 and PEP 526. This is equivalent to adding ast.PyCF_TYPE_COMMENTS to the flags passed to compile(). This will report syntax errors for misplaced type comments. Without this flag, type comments will be ignored, and the type_comment field on selected AST nodes will always be None. In addition, the locations of # type: ignore comments will be returned as the type_ignores attribute of Module (otherwise it is always an empty list).\n\nIn addition, if mode is 'func_type', the input syntax is modified to correspond to PEP 484 âsignature type commentsâ, e.g. (str, int) -> List[str].\n\nSetting feature_version to a tuple (major, minor) will result in a âbest-effortâ attempt to parse using that Python versionâs grammar. For example, setting feature_version=(3, 9) will attempt to disallow parsing of match statements. Currently major must equal to 3. The lowest supported version is (3, 4) (and this may increase in future Python versions); the highest is sys.version_info[0:2]. âBest-effortâ attempt means there is no guarantee that the parse (or success of the parse) is the same as when run on the Python version corresponding to feature_version.\n\nIf source contains a null character (\\0), ValueError is raised.\n\nWarning\n\nNote that successfully parsing source code into an AST object doesnât guarantee that the source code provided is valid Python code that can be executed as the compilation step can raise further SyntaxError exceptions. For instance, the source return 42 generates a valid AST node for a return statement, but it cannot be compiled alone (it needs to be inside a function node).\n\nIn particular, ast.parse() wonât do any scoping checks, which the compilation step does.\n\nWarning\n\nIt is possible to crash the Python interpreter with a sufficiently large/complex string due to stack depth limitations in Pythonâs AST compiler.\n\nChanged in version 3.8: Added type_comments, mode='func_type' and feature_version.\n\nEvaluate an expression node or a string containing only a Python literal or container display. The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, sets, booleans, None and Ellipsis.\n\nThis can be used for evaluating strings containing Python values without the need to parse the values oneself. It is not capable of evaluating arbitrarily complex expressions, for example involving operators or indexing.\n\nThis function had been documented as âsafeâ in the past without defining what that meant. That was misleading. This is specifically designed not to execute Python code, unlike the more general eval(). There is no namespace, no name lookups, or ability to call out. But it is not free from attack: A relatively small input can lead to memory exhaustion or to C stack exhaustion, crashing the process. There is also the possibility for excessive CPU consumption denial of service on some inputs. Calling it on untrusted data is thus not recommended.\n\nWarning\n\nIt is possible to crash the Python interpreter due to stack depth limitations in Pythonâs AST compiler.\n\nIt can raise ValueError, TypeError, SyntaxError, MemoryError and RecursionError depending on the malformed input.\n\nChanged in version 3.2: Now allows bytes and set literals.\n\nChanged in version 3.9: Now supports creating empty sets with 'set()'.\n\nChanged in version 3.10: For string inputs, leading spaces and tabs are now stripped.\n\nA node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the visit() method.\n\nThis class is meant to be subclassed, with the subclass adding visitor methods.\n\nvisit(node)Â¶\n\nVisit a node. The default implementation calls the method called self.visit_classname where classname is the name of the node class, or generic_visit() if that method doesnât exist.\n\ngeneric_visit(node)Â¶\n\nThis visitor calls visit() on all children of the node.\n\nNote that child nodes of nodes that have a custom visitor method wonât be visited unless the visitor calls generic_visit() or visits them itself.\n\nvisit_Constant(node)Â¶\n\nHandles all constant nodes.\n\nDonât use the NodeVisitor if you want to apply changes to nodes during traversal. For this a special visitor exists (NodeTransformer) that allows modifications.\n\nDeprecated since version 3.8: Methods visit_Num(), visit_Str(), visit_Bytes(), visit_NameConstant() and visit_Ellipsis() are deprecated now and will not be called in future Python versions. Add the visit_Constant() method to handle all constant nodes.\n\nA NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes.\n\nThe NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is None, the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place.\n\nHere is an example transformer that rewrites all occurrences of name lookups (foo) to data['foo']:\n\nclass RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load()), slice=Constant(value=node.id), ctx=node.ctx )\n\nKeep in mind that if the node youâre operating on has child nodes you must either transform the child nodes yourself or call the generic_visit() method for the node first.\n\nFor nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node.\n\nIf NodeTransformer introduces new nodes (that werenât part of original tree) without giving them location information (such as lineno), fix_missing_locations() should be called with the new sub-tree to recalculate the location information:\n\ntree = ast.parse('foo', mode='eval') new_tree = fix_missing_locations(RewriteName().visit(tree))\n\nUsually you use the transformer like this:\n\nnode = YourTransformer().visit(node)\n\nReturn a formatted dump of the tree in node. This is mainly useful for debugging purposes. If annotate_fields is true (by default), the returned string will show the names and the values for fields. If annotate_fields is false, the result string will be more compact by omitting unambiguous field names. Attributes such as line numbers and column offsets are not dumped by default. If this is wanted, include_attributes can be set to true.\n\nIf indent is a non-negative integer or string, then the tree will be pretty-printed with that indent level. An indent level of 0, negative, or \"\" will only insert newlines. None (the default) selects the single line representation. Using a positive integer indent indents that many spaces per level. If indent is a string (such as \"\\t\"), that string is used to indent each level.\n\nChanged in version 3.9: Added the indent option."
    }
}