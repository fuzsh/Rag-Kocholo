{
    "id": "correct_publicationDate_00119_2",
    "rank": 17,
    "data": {
        "url": "https://stackoverflow.com/questions/40349987/how-to-suppress-error-ts2533-object-is-possibly-null-or-undefined",
        "read_more_link": "",
        "language": "en",
        "title": "How to suppress \"error TS2533: Object is possibly 'null' or 'undefined'\"?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://cdn.sstatic.net/Img/teams/overflowai.svg?v=d706fa76cdae",
            "https://www.gravatar.com/avatar/5e4fa66a71e59fe32c2d602bdb5068b5?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/6c5b0663c367fc401502f289688f1ec6?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/d256baab2fcfd81b0f109d394404fd67?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/b497b4c29cda7b33149c5fb66d62b877?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a6919c8388bc3d388da7806ab415ef54?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/fa90a359777096c15258e207b3cb8b6c?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/dfGCY.png",
            "https://i.sstatic.net/Fl416.png?s=64",
            "https://www.gravatar.com/avatar/8e2131fa7e81da52df245914d4a9f693?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/QpHXt.png?s=64",
            "https://www.gravatar.com/avatar/e8bea8f9e6972dfd3113d67da68e6933?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/ffbc4706ba96370df96b97ee9bd31b37?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/woiQO.jpg?s=64",
            "https://i.sstatic.net/XH7hL.jpg?s=64",
            "https://www.gravatar.com/avatar/e57ddb14f23a80ca2de80331039a037e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/7fc2db839382b30434539fbc967c498e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/5xDHc.jpg?s=64",
            "https://lh3.googleusercontent.com/a-/AAuE7mAUZZ0QFwXF6VsF4rUik8aH4JPnA1ZUBkzhCYWN=k-s64",
            "https://www.gravatar.com/avatar/eac16c9fc481cb6825f8b3a35f916b5c?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/PU6IG.png?s=64",
            "https://lh6.googleusercontent.com/-Gz-YnvG197o/AAAAAAAAAAI/AAAAAAAAAWc/0mDc2l6SwlE/photo.jpg?sz=64",
            "https://i.sstatic.net/AJ0dpgw8.png?s=64",
            "https://i.sstatic.net/IvIuI.jpg?s=64",
            "https://www.gravatar.com/avatar/89dec2d7e69bfe3adc9e1bd6449c7177?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://graph.facebook.com/822172617902621/picture?type=large",
            "https://graph.facebook.com/10213172752592267/picture?type=large",
            "https://www.gravatar.com/avatar/e47ce75d1280956ddd5db93bc8ebd056?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/qSGq0.jpg?s=64",
            "https://www.gravatar.com/avatar/eac16c9fc481cb6825f8b3a35f916b5c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a63b28804f1eaac635b7e823190f32fc?s=64&d=identicon&r=PG",
            "https://lh5.googleusercontent.com/-BhqrwzKl8_8/AAAAAAAAAAI/AAAAAAAAAAA/AAN31DU5moEXPCkyt8MCTD-1Wdkzh_2n0w/mo/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/d22ec8e3f4ca03090d3f3367ea30a734?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/4hankSZL.png?s=64",
            "https://lh6.googleusercontent.com/-UU34KIKCsDo/AAAAAAAAAAI/AAAAAAAAAFs/ddSxo0F-UBc/photo.jpg?sz=64",
            "https://i.sstatic.net/TaKcK.png",
            "https://i.sstatic.net/0JK5s.png?s=64",
            "https://i.sstatic.net/TUczU.jpg?s=64",
            "https://lh3.googleusercontent.com/-UZ6z4lLq07Q/AAAAAAAAAAI/AAAAAAAAAVg/JGTK_1z573Q/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/93b40f413b34463de22c81d35b4c1930?s=64&d=identicon&r=PG",
            "https://lh3.googleusercontent.com/a/AGNmyxZ7qmSzfsurtckSYnCfvQQKajceEJr0aY5Y7OvvOYQ=k-s64",
            "https://stackoverflow.com/posts/40349987/ivc/b5b8?prg=de68a793-3d29-4112-a004-302598d49289"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2016-10-31T20:22:21",
        "summary": "",
        "meta_description": "I have a type:\n\ntype tSelectProtected = {\n  handleSelector?: string,\n  data?: tSelectDataItem[],\n\n  wrapperEle?: HTMLElement,\n  inputEle?: HTMLElement,\n  listEle?: HTMLElement,\n  resultEle?: HTMLEl...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/40349987/how-to-suppress-error-ts2533-object-is-possibly-null-or-undefined",
        "text": "This feature is called \"strict null checks\", to turn it off ensure that the --strictNullChecks compiler flag is not set.\n\nHowever, the existence of null has been described as The Billion Dollar Mistake, so it is exciting to see languages such as TypeScript introducing a fix. I'd strongly recommend keeping it turned on.\n\nOne way to fix this is to ensure that the values are never null or undefined, for example by initialising them up front:\n\ninterface SelectProtected { readonly wrapperElement: HTMLDivElement; readonly inputElement: HTMLInputElement; } const selectProtected: SelectProtected = { wrapperElement: document.createElement(\"div\"), inputElement: document.createElement(\"input\") };\n\nSee Ryan Cavanaugh's answer for an alternative option, though!\n\nOption 1 - Suppressing\n\nYou can suppress the compiler error if needed, by adding a comment (with CAUTION below)\n\n// @ts-ignore: Object is possibly 'null'.\n\nNot a direct answer to the OP's question, but in my React application with Typescript - v3.6.2\n\ntslint - v5.20.0\n\nAnd using the following code\n\nconst refToElement = useRef(null); if (refToElement && refToElement.current) { refToElement.current.focus(); // Object is possibly 'null' (for refToElement.current) }\n\nI moved on by suppressing the compiler for that line -\n\nconst refToElement = useRef(null); if (refToElement && refToElement.current) { // @ts-ignore: Object is possibly 'null'. refToElement.current.focus(); }\n\nCAUTION\n\nNote that since it's a compiler error and not the linter error, // tslint:disable-next-line doesn't work. Also, as per the documentation, this should be used rarely, only when necessary\n\nOption 2 - Optional chaining\n\nWith Typescript 3.7 onwards, optional chaining might be applicable in some cases\n\nrefToElement?.current?.focus();\n\nBut again, only if it's really needed, as in some cases the error might actually point to a bigger problem -\n\nOption 3 - Passing the right type\n\nAlso, sometimes it just might be a matter of passing in the appropriate type to the generic paramenter, while using useRef.\n\nEg: In case of an input element -\n\nconst refToElement = useRef<HTMLInputElement>(null);\n\nTo fix this you can simply use the exclamation mark if you're sure that the object is not null when accessing its property:\n\nlist!.values\n\nAt first sight, some people might confuse this with the safe navigation operator from angular, this is not the case!\n\nlist?.values\n\nThe ! post-fix expression will tell the TS compiler that variable is not null, if that's not the case it will crash at runtime\n\nuseRef\n\nfor useRef hook use like this\n\nconst value = inputRef?.current?.value\n\nIf you know the type will never be null or undefined, you should declare it as foo: Bar without the ?. Declaring a type with the ? Bar syntax means it could potentially be undefined, which is something you need to check for.\n\nIn other words, the compiler is doing exactly what you're asking it to. If you want it to be optional, you'll need to the check later.\n\nTip for RxJS\n\nI'll often have member variables of type Observable<string>, and I won't be initializing it until ngOnInit (using Angular). The compiler then assumes it to be uninitialized becasue it isn't 'definitely assigned in the constructor' - and the compiler is never going to understand ngOnInit.\n\nYou can use the ! assertion operator on the definition to avoid the error:\n\nfavoriteColor!: Observable<string>;\n\nAn uninitialized observable can cause all kinds of runtime pain with errors like 'you must provide a stream but you provided null'. The ! is fine if you definitely know it's going to be set in something like ngOnInit, but there may be cases where the value is set in some other less deterministic way.\n\nSo an alternative I'll sometimes use is :\n\npublic loaded$: Observable<boolean> = uninitialized('loaded');\n\nWhere uninitialized is defined globally somewhere as:\n\nexport const uninitialized = (name: string) => throwError(name + ' not initialized');\n\nThen if you ever use this stream without it being defined it will immediately throw a runtime error.\n\nIn ReactJS, I check in the constructor if the variables are null, if they are I treat it like an exception and manage the exception appropriately. If the variables are not null, code carries on and compiler does not complain anymore after that point:\n\nprivate variable1: any; private variable2: any; constructor(props: IProps) { super(props); // i.e. here I am trying to access an HTML element // which might be null if there is a typo in the name this.variable1 = document.querySelector('element1'); this.variable2 = document.querySelector('element2'); // check if objects are null if(!this.variable1 || !this.variable2) { // Manage the 'exception', show the user a message, etc. } else { // Interpreter should not complain from this point on // in any part of the file this.variable1.disabled = true; // i.e. this line should not show the error }\n\nI ran in to this with React when setting state and using map.\n\nIn this case I was making an API fetch call and the value of the response wasn't known, but should have a value \"Answer\". I used a custom type for this, but because the value could be null, I got a TS error anyway. Allowing the type to be null doesn't fix it; alternatively you could use a default parameter value, but this was messy for my case.\n\nI overcame it by providing a default value in the event the response was empty by just using a ternary operator:\n\nthis.setState({ record: (response.Answer) ? response.Answer : [{ default: 'default' }] });\n\nNote: it might not be a recommended action - maybe the solution is to actually address the errors. All the checks are in place for a reason, so disabling them is not always the right thing to do, but...\n\na similar answer to some of the above, but a little bit different in the end. I've had an issue with multiple different checks and what helped me was setting a strict property to false in tsconfig.json. Seems like a more generic variation of the specific checks mentioned above.\n\n\"compilerOptions\": { \"strict\": false },"
    }
}