{
    "id": "dbpedia_8579_2",
    "rank": 3,
    "data": {
        "url": "https://github.com/pixeljetstream/luxinia1/blob/master/engine/source/luxinia_prtscript.md",
        "read_more_link": "",
        "language": "en",
        "title": "luxinia1/engine/source/luxinia_prtscript.md at master Â· pixeljetstream/luxinia1",
        "top_image": "https://opengraph.githubassets.com/92d0b4c7a57299ee9a7200dc2f0e714b09da165000bb9fa06539bd264faf3962/pixeljetstream/luxinia1",
        "meta_img": "https://opengraph.githubassets.com/92d0b4c7a57299ee9a7200dc2f0e714b09da165000bb9fa06539bd264faf3962/pixeljetstream/luxinia1",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "engine source code for the luxinia game engine. Contribute to pixeljetstream/luxinia1 development by creating an account on GitHub.",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/pixeljetstream/luxinia1/blob/master/engine/source/luxinia_prtscript.md",
        "text": "Particle Script .PRT\n\nA particlesystem script allows easier setup of particles and defines how they behave. Particles are always drawn last within a scene.\n\nWhen a script is used, the emitter, or source partile for trails, will hand over following fixed attributes:\n\nposition\n\ndirection Depending on this information the values defined in a script are relative to.\n\nEmitter & Particle must be defined in a script, the rest is optional\n\nVariances are computed as followed:\n\nout = random between [in-variance,in+variance]\n\nAgefx are uint 0-99 = 0%-99% of lifetime\n\nAgetextures are not loaded into resource textures, but only for initialization. If you want to change the values afterwards, use api calls on the particlesystem\n\nThe header is necessary\n\ncurrent layout version:\n\nluxinia_ParticleSys_v120\n\nAll commands are case sensitive and closed by ; or \"newline\". A keyword and its arguments may not span multiple lines.\n\n<id> ranges from 0 to 7\n\n<vector4> is (float,float,float,float)\n\n<bool> is 1 = true, 0 = false\n\nYou can do branching with following commands. Enclose the branches in curly brackets { }\n\nIF:<condition string>\n\nELSEIF:<condition string>\n\nELSE\n\nThe condition string can be set from luxinia API with resource.condition, or it may be part of a \"define\" in the Cg Compiler string.\n\nYou can also negate a statement with !<condition string>.\n\nFollowing conditions are automatically set if applicable:\n\nCAP_POINTSPRITES is automatically set when point sprites (ie textured POINTS) are available.\n\nBe aware that the parser is not fully rock solid, so at best use COMMAND{<newline> <what><newline> }<newline> , when problems occur.\n\nAnnotations & Comments\n\nYou can add annotations anywhere in the file and later query them after load.\n\n<<_ \"name\"; serves as start and is skipped by branching or comments.\n\n_>> denotes the end of the custom string. Anything between the two will become part of the annotation, so use with caution.\n\n// comment until lineend // multi-line annotation <<_ \"A\" test = a * b // this will be part of annotation as well blahblubb _>> /* block commenting ... <<_ \"B\"; min=25,max=90 _>>; //inlined annotation but ignored, due to active block comment */\n\nC-style comments with // and /*...*/ may not start within command & keywords. So start comments always after ; in a line that contains command words.\n\nluxinia_ParticleSys_v110 RenderFlag{ // this is a comment blah blendmode VID_ADD; sort; } Emitter{ type VID_POINT; size 10; spread (0,45); rate 170; velocity 30; count 100; maxoffsetdist 200; /* blockcomment ... */ } Particle{ type VID_POINT; size 1; life 5000; } Texture{ numtex 2; TEX 0 \"test0.jpg\"; TEX 50 \"test1.jpg\"; } Color{ numcolor 1; RGBA 100 (1.0,0.3,0.3,0.5); } Forces{ gravity 1000 (0.0,-10.0,0.0) 5; } SubSystem{ trail \"blubb.prt\" 500 VID_DIR 40 100; }\n\nthey are applied to all particles and are optional.\n\nnodraw;\n\nthis system wont be drawn but subsystems would. Useful if you want to hide the source system for trailsubsystems\n\nlit;\n\nparticles are lit (default off)\n\ndepthmask;\n\nwill write into depthmask (ie. depth information stored, default off)\n\nnodepthtest;\n\nwill do no depth testing (ie. always on top when drawn)\n\nalphamask;\n\nquick for: alphafunc GL_GREATER (0.0)\n\nsort;\n\nwill sort the particles by z-value\n\nif blendfunc is defined then back to front\n\nif alphafunc is set then front to back\n\nif both are set front to back is taken\n\nnovistest;\n\nif set we will do no visibility testing but always update the emitters\n\nalphafunc <enum func> (<float ref>);\n\nto cap transparency of an object, same as in [[Api/Shader | ShaderScript]]\n\nblendmode <enum blendmode>;\n\nto make soft blends\n\nblendmode\n\nVID_MODULATE out = self * in\n\nVID_MODULATE2 out = self * in * 2\n\nVID_ADD out = self + in\n\nVID_AMODADD out = self * self.alpha + in\n\nVID_DECAL out = self * self.alpha + in * (1-self.alpha)\n\nnocull;\n\ndisables backface culling.\n\nlayer <int layer>;\n\nin which l3dset layer (0-15) the system should be drawn.\n\nHow the particles are emitted is defined in here. What you define is just the default emitter. During runtime when you create new emitters you can change their type and properties individually.\n\ntype <type enum>;\n\nwhat the source of particles is\n\nVID_POINT\n\njust a simple point\n\nstartvelocity = emitterdirection * velocity\n\nVID_CIRCLE\n\na flat circle area with its normal in emitterdirection\n\nthe size must be specified, particle will spawn somewhere within the circle\n\nstartvelocity = emitterdirection * velocity\n\nVID_SPHERE\n\nalong the sphere surface, radius must be specified\n\nstartvelocity = sphere's normal * velocity\n\nVID_RECTANGLE\n\nalong the axis aligned rectangle surface. Uses world axis for the plane. needs axis, width and height set\n\nstartvelocity = emitterdirection * velocity\n\nVID_RECTANGLELOCAL\n\nalong the local aligned rectangle surface. Uses local X- and Z- axis of emitter for the rectangle plane. needs width and height set\n\nstartvelocity = emitterdirection * velocity\n\nVID_MODEL\n\nspawns on a random vertex of given model\n\nstartvelocity = vertex normal * velocity\n\ncount <num uint>;\n\ntotal particles that can be displayed, you should somewhat find a good optimum how many you really need. Maximum is 8192\n\nsize <radius float>;\n\nsphere or circle radius\n\nwidth <radius float>;\n\nwidth of VID_RECTANGLE\n\nheight <radius float>;\n\nheight of VID_RECTANGLE\n\naxis <int 0-2>;\n\naxis of the plane's normal for VID_RECTANGLE, 0 = X, 1 = Y, 2 = Z\n\nmodel \"<modelfile string>\";\n\nmodelfile of VID_MODEL\n\nrate <rate uint>;\n\nhow many particles per second one emitter spawns\n\nvelocity <vel float>;\n\nthe starting velocity, units per second\n\nendtime <time uint>;\n\ntime in ms after creation it will stop emission, if 0 then constantly spawned, or user controlled\n\nmaxoffsetdist <dist float>;\n\nrandom offset from original spawnposition in velocity direction\n\nvelocityvar <var float>;\n\nvariance to velocity\n\nflipdirection <percent float>;\n\npercent of how many particles will use opposite direction\n\nspread (<inner degrees uint>,<outer degrees uint>);\n\nvariance added to emitterdirection, maximum angle a random direction can have from original direction, particle direction will be between inner and outer angle.\n\nrestarttime <time uint>;\n\ntime in ms after endtime when particles are spawned again\n\nrestarts <num uint>;\n\nhow often restarts will happen 1-254, 255 = infinite\n\nThis defines the appearance of the particle and certain variances to it.\n\ntype <geo enum>;\n\nthis defines the particle appearance\n\nVID_POINT\n\na simple point, implementation may vary on gl_driver. When gl_driver allows point sprites a single texture can be used. Particlesize will be in pixels on screen at 640x480. Particles cannot have individual sizes.\n\nVID_QUAD\n\na flat quad facing towards camera, e.g part | > eye. origin at center\n\nVID_TRIANGLE\n\na flat triangle facing towards camera\n\nVID_HSPHERE\n\na 5-sided hemisphere facing towards camera, e.g part ) > eye\n\nVID_SPHERE\n\na sphere (non textureable)\n\nVID_MODEL\n\na model, must be specified, particles will randomly pick a mesh inside the model and use its material, very expensive\n\nmodel \"<modelfile string>\";\n\nif VID_MODEL was picked as particle type, tell which model to use\n\nlife <time uint>;\n\ntime in ms until particle death\n\nsize <size float>;\n\nsize of particle (pixel,radius,width, model scale)\n\ninstancemesh \"<string meshname>\";\n\nif VID_MODEL is used, you can create instancing effects using a single mesh from the model.\n\nOnly small meshes (quads/triangles,max 32 vertices and 96 indices) can be instanced. If successful,\n\nall particles will use the same mesh.\n\nThe purpose of using a single instancemesh is speeding up rendering of lightweight meshes.\n\noriginoffset (<x float>,<y float>,<z float>);\n\nif VID_QUAD,TRIANGLE,INSTANCEMESH,HSPHERE are used you can offset the drawing center by this vector\n\nsizevar <percent float>;\n\nsize variance, minimum size is 1/10 of original\n\nlifevar <percent float>;\n\nvariance in the lifetime\n\nrotate <degrees uint> <dir enum>;\n\nrotates particle around center.\n\ndegrees\n\ndegrees per second\n\ndirection\n\nVID_POS, VID_NEG, VID_RAND\n\nrotatevar <percent float>;\n\nvariance to rotation degree\n\nrotateoffset <degrees uint>;\n\nangle on start is random(0 - degrees)\n\nrotatevelocity;\n\nif this flag is set rotation is linked to particle velocity\n\ndieonfrontplane;\n\nif flag is set particle will die when behind camera\n\ncamrotfix;\n\nif set we will rotate particles based in which direction the camera looks. Useful for getting rid of billboard alignment in top down situation.\n\noverriden by rotatevelocity. Another solution is using Luxinia Api and make the particles globally aligned.\n\nnoagedeath;\n\nif flag is set particle will not die if too old, but get age of 0 again\n\npointsmooth;\n\nif flag is set particles will be rendered as antialiased round dots\n\npointparams (<float minsize>,<float maxsize>)(<float alphathresh>)(<float const>,<float lin>,<float square>);\n\nfor points special parameters can be set to control size by distance attenuation.\n\noutsize = size * 1/(const + lindistance + squaredistance*distance)\n\nminsize,maxsize\n\noutsize will be capped by these values\n\nalphathresh enables a fading out of color.alpha when size gets below thresh\n\ncons,lin,square\n\ndistance attenuation parameters\n\nAge-Based Effects\n\nsizeage3 <age1 uint> (<size1 float>) <age2 uint> (<size2 float>) <age3 uint> (<size3 float>);\n\ncan control the size changing over time, size will grow/shrink depending on the values\n\nthere is 3 size groups, each size group contains\n\nage\n\ntime in percent of totallife\n\nsize\n\nsize multiplier of the particle\n\nspeedage3 <age1 uint> (<velm1 float>) <age2 uint> (<velm2 float>) <age3 uint> (<velm3 float>);\n\nscale velocity based on age\n\nrotateage3 <age1 uint> (<rotm1 float>) <age2 uint> (<rotm2 float>) <age3 uint> (<rotm3 float>);\n\ncan control the rotation changing over time. It works as multiplier of original rotation.\n\nsizeagetex \"<texturefile string>\" <row uint> (<scale float>) <subtract float>;\n\ncan control the size changing over time, size will grow/shrink depending on the values, pixel 0 = start, 127 = end.\n\ntexturefile\n\nThe texture must be 128 pixels wide, and ideally be a .tga file or other losless format.\n\nrow\n\nthe row within the texture to use (you can combine multiple effects in one texture)\n\nscale\n\neach value in the texture represents 0.0 - 1.0 (we take the R value in RGB/RGBA). you can scale this\n\nvalue with the given parameter. e.g. scale = 2 you will get 0.0 - 2.0.\n\nsubtract\n\nthis optional value will be subtracted from texture*scale, that way you can create sign changes if needed;\n\nrotateagetex \"<texturefile string>\" <row uint> (<scale float>) <subtract float>;\n\ncan control the rotation changing over time. It works as multiplier of original rotation.\n\nspeedagetex \"<texturefile string>\" <row uint> (<scale float>) <subtract float>;\n\nscale velocity based on age\n\nIn here the color of the particles are set. If no color is set default will be white.\n\nnumcolor <number uint>;\n\nthe number of colors a particle can have, must be specified first, minimum is 1\n\nRGBA <age uint> (<R cfloat>,<G cfloat>,<B cfloat>,<A cfloat>);\\\n\nage\n\nin percent of totallife, if just one color is given this is ignored **R G B A\n\nis color/alpha value\n\nRGBAagetex \"<texturefilename string>\" <uint row>;\n\ninstead of numcolor & RGBA this single command can be used. The 128 pixel wide texture contains all color values, 0 = start, 127 = end.\n\nrow\n\nthe pixelrow to use within the texture;\n\nnoage;\n\nif flag is set colors will be picked randomly for a new particle\n\ninterpolate;\n\nif flag is set then colors will be interpolated between ages\n\nRGBAvar (<percentR float>,<percentG float>,<percentB float>,<percentA float>);\n\nto add random variance to each color value, +/- SRC * var + SRC\n\nSame as color, if non is set we assume no texture given textures cannot have texshaders applied, and must all be same size,same format. Mind that depending on graphics card errors can come up with too many squence images.\n\nnumtex <number uint>;\n\nthe number of textures, must be specified first\n\nMATERIAL/TEX/TEXALPHA <age uint> \"<texname string>\";\n\nage\n\nin percent of totallife, if just one texture is given this is ignored\n\ntexname\n\nis the filename in a relative path\n\nTEX RGB/RGBA\n\nTEXCOMBINE1D/2D_16/2D_64 RGB/RGBA\n\nwe assume always the first specified texture is used, and has already horizontally(1d) or square(2d) combined textures in it.\n\nTEXALPHA ALPHA\n\nMATERIAL\n\na single material is used for all textures, the textures used in the material are combined images by the user and must contain power of 2 subimages. using combine draw with materials is not allowed. All should be of same type (the last will be used for all)\n\neventimed;\n\nif flag was set before you start with the textures, they will all get same difference in time.\n\nwhen you use TEXCOMBINEx or MATERIAL you wont have to specify the other textures, ie a single entry will be enough\n\nnoage;\n\nif flag is set random texture is picked for new particle\n\nsequence;\n\nif flag is set the defined textures are taken as a loopable sequence time delay of first is added to last\n\ne.g: 10 \"a\" 20 \"b\" 30 \"c\" > 10 \"a\" 20 \"b\" 30 \"c\" 40 \"a\" 50 \"b\" 60 \"c\" ... until 100\n\nagetex \"<texturefile string>\" <row uint>;\n\nwhich texture is used at what timestep is encoded in the texture, we use the pixel values and modulo them with numtex.\n\nrow the pixelrow within the texture, in (RGB/RGBA textures R is used)\n\nForces influence the particle motion, maximum is 32 forces per system.\n\nThere are more force types creatable by Luxinia Api such as\n\nmagnet\n\nrange based attraction/repulsion of particles. Uses quadratic distance falloff to target for effect strength.\n\ntarget\n\nsimilar to magnet, but without range falloff.\n\nStandard forces:\n\ngravity (<x float>,<y float>,<z float>) <turbulence float> [<uint starttime>] [<uint endtime>] [\"<string name>\"];\n\ncontains information of gravity, gravity is constant acceleration\n\n(x,y,z)\n\ndefine direction and strength in world coordinates\n\nturbulence\n\nis a wavey translation\n\nwind (<x float>,<y float>,<z float>) <turbulence float> <airres float> [<uint starttime>] [<uint endtime>] [\"<string name>\"];\n\n(x,y,z)\n\ndefine direction and strength in world coords, x,y ground plane\n\nturbulence\n\nis a wavey translation\n\nairres\n\nair resistance a particle wind is either accelerating or slowing down depending on particle velocity same as above\n\nstarttime\n\nthe minimum age a particle must have to be affected\n\nendtime\n\nthe maximum age to be affected by force\n\nname\n\nthe name handle (less than 16 characters). Useful if you want to access the force from Luxinia api.\n\nWith this other particle systems can be generated, maximum 8. The subsystems are drawn as listed after the original system, however if combinedraw flag is set they will get drawn with a single call.\n\ncombinedraw;\n\na special flag that will put all particles into a single draw call. however all textures must be same type (RGB/RGBA) and only the renderflag of the original system is used\n\nAlso it will use particletype of root system, if subsystems have subsystems themselves combinedraw will be ignored for all.\n\ntrail \"<psysname string>\" <delay uint> <dir enum> <minage uint> <nth uint>;\n\nparticle will leave a trail of of the specified particlesys. Its Subsystems will not be used, when it is used as a trail.\n\npsysname\n\nfilename of subsystem\n\ndelay\n\ntime in ms until subsys is launched\n\ndir\n\nVID_DIR particle's direction\n\nVID_ODIR opposite of direction\n\nminage\n\nminage of particle to leave a trail\n\nnth\n\nevery nth particle will create a trail\n\nnormal \"<psysname string>\" <delay uint>;\n\npsys will be generated after a time given, direction & position is same as original\n\npsysname\n\nfilename of subsystem\n\ndelay\n\ntime in ms until subsys is launched\n\ntranslated \"psys.prt\" <delay uint> (<px float>,<py float>,<pz float>) (<dx float>,<dy float>,<dz float>);\n\nsimilar to normal system but with specific position and direction, position is relative to original position\n\ndelay\n\ntime in ms until subsys is launched\n\n(px,py,pz)\n\nposition vector\n\n(dx,dy,dz)\n\ndirection vector is multiplied with original direction, eg. if you want the same direction then (1,1,1) would be used, if opposite (-1,-1,-1)\n\n1st Draft 20.6.2004:\n\nThis is just a basic idea about functionality. Depending on how hard it will be to do all, and how fast things can be done, the actual system may change. Also its not sure how the Trail system is done, it may done completely different, ie code uses point emitters from a different particle system.\n\n2nd Draft 21.6.2004:\n\nSome more changes, mostly moving variables from code into the script to make them fixed. Also throwing the old trail out and instead added a subsystem of particles that will be loaded and controlled by this system.\n\n3rd Draft 8.6.2004:\n\nMinor fiddling with the subsystems, mostly just changing minor stuff. It is yet unsure how force turbulences will look like. The other uncertainty is particles' directions\n\n4th Draft 20.9.2004:\n\nsubsystems can now be thrown into the same sorted drawlist using \"combinedraw\" flag\n\n5th Draft 22.9.2004:\n\nadded particle rotation\n\n6th Draft 27.9.2004:\n\nadded texture sequence\n\n7th Draft 22.12.2004:\n\nvectors are packed in () and separated by ,\n\n8th Draft 13.1.2005:\n\nadded rotation age effect\n\n9th Draft 28.1.2005:\n\nuse of VID blendmodes\n\n10th Draft 04.4.2005:\n\nadded flipdirection percentage\n\n11th Draft 11.6.2005:\n\ndie on backplane\n\n12th Draft 14.6.2005:\n\nadded start offset, point sprites, point smoothing and pointparams\n\n14th Draft 10.8.2005:\n\nadded MATERIAL as texture type\n\n15th Draft 6.9.2005:\n\ntrails allow any emitter type now\n\n16th Draft 12.11.2005:\n\nremoved delay in forces, for simplicity / better parallelism\n\n17th Draft 10.3.2006:\n\nremoved magnets, those are handled by lua\n\n18th Draft 13.3.2006:\n\nchanged the way forces are dealt with, timed forces are back\n\n19th Draft 4.6.2006:\n\nagebased effects can now be read from the texture\n\n20th Draft 14.6.2006:\n\nadded originoffset vector for billboards\n\n21st Draft 20.6.2006:\n\nparticle mesh instancing added\n\n22nd Draft 10.8.2006:\n\nadded \"preprocessor\" branching\n\n23rd Draft 11.9.2007:\n\nadded layer renderflag\n\n24th Draft 24.1.2008:\n\nproper block commenting with # { ... # }\n\n25th Draft 23.4.2008:\n\ncommenting now in C-Style, along with raised version number // and /* ... */\n\n26th Draft 18.5.2008:\n\nannotation system added\n\n27th Draft 20.7.2008:\n\nCAP_POINTSPRITES added"
    }
}