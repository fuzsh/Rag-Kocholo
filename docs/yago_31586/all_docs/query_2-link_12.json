{
    "id": "yago_31586_2",
    "rank": 12,
    "data": {
        "url": "https://en.wikipedia.org/wiki/MIX_(abstract_machine)",
        "read_more_link": "",
        "language": "en",
        "title": "MIX (abstract machine)",
        "top_image": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "meta_img": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2003-01-23T08:26:24+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/MIX_(abstract_machine)",
        "text": "Hypothetical computer by Donald Knuth\n\nMIXDesignerDonald KnuthBits31-bitIntroduced1968Designaccumulator machineTypehypotheticalEncodingFixedBranchingCondition code and register testEndiannessBigOpenYes, and royalty freeRegisters9 in total\n\nMIX is a hypothetical computer used in Donald Knuth's monograph, The Art of Computer Programming (TAOCP). MIX's model number is 1009, which was derived by combining the model numbers and names of several contemporaneous, commercial machines deemed significant by the author. Also, \"MIX\" read as a Roman numeral is 1009.\n\nThe 1960s-era MIX has since been superseded by a new (also hypothetical) computer architecture, MMIX, to be incorporated in forthcoming editions of TAOCP.\n\nSoftware implementations for both the MIX and MMIX architectures have been developed by Knuth and made freely available (named \"MIXware\" and \"MMIXware\", respectively). Several derivatives of Knuth's MIX/MMIX emulators also exist. GNU MDK is one such software package; it is free and runs on a wide variety of platforms.\n\nTheir purpose for education is quite similar to John L. Hennessy's and David A. Patterson's DLX architecture, from Computer Organization and Design - The Hardware Software Interface.\n\nMIX is a hybrid binary–decimal computer. When programmed in binary, each byte has 6 bits (values range from 0 to 63). In decimal, each byte has 2 decimal digits (values range from 0 to 99). Bytes are grouped into words of five bytes plus a sign. Most programs written for MIX will work in either binary or decimal, so long as they do not try to store a value greater than 63 in a single byte.\n\nA word has the range −1,073,741,823 to 1,073,741,823 (inclusive) in binary mode, and −9,999,999,999 to 9,999,999,999 (inclusive) in decimal mode. The sign-and-magnitude representation of integers in the MIX architecture distinguishes between “−0” and “+0.” This contrasts with modern computers, whose two's-complement representation of integer quantities includes a single representation for zero, but whose range for a given number of bits includes one more negative integer than the number of representable positive integers.\n\nThere are 9 registers in MIX:\n\nrA: Accumulator (full word, five bytes and a sign).\n\nrX: Extension (full word, five bytes and a sign).\n\nrI1, rI2, rI3, rI4, rI5, rI6: Index registers (two bytes and a sign).\n\nrJ: Jump address (two bytes, always positive).\n\nA byte is assumed to be at least 6 bits. Most instructions can specify which of the \"fields\" (bytes) of a register are to be altered, using a suffix of the form (first:last). The zeroth field is the one-bit sign.\n\nMIX also records whether the previous operation overflowed, and has a one-trit comparison indicator (less than, equal to, or greater than).\n\nThe MIX machine has 4000 words of memory (each with 5 bytes and a sign), addressed from 0 to 3999. A variety of input and output devices are also included:\n\nTape units (devices 0...7).\n\nDisk or drum units (devices 8...15).\n\nCard reader (device 16).\n\nCard punch (device 17).\n\nLine printer (device 18).\n\nTypewriter terminal (device 19).\n\nPaper tape (device 20).\n\nEach machine instruction in memory occupies one word, and consists of 4 parts: the address (2 bytes and the sign of the word) in memory to read or write; an index specification (1 byte, describing which rI index register to use) to add to the address; a modification (1 byte) that specifies which parts of the register or memory location will be read or altered; and the operation code (1 byte). All operation codes have an associated mnemonic.\n\n30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 ± Address Index Modification Operation\n\nMIX programs frequently use self-modifying code, in particular to return from a subroutine, as MIX lacks an automatic subroutine return stack. Self-modifying code is facilitated by the modification byte, allowing the program to store data to, for example, the address part of the target instruction, leaving the rest of the instruction unmodified.\n\nMIX programs are typically constructed using the MIXAL assembly language; for an example, see the list hello world programs page.\n\nLDAADDR,i(0:5) rA:=memory[ADDR+rIi]; LDXADDR,i(0:5) rX:=memory[ADDR+rIi]; LD? ADDR,i(0:5) rI? := memory[ADDR + rIi]; LDANADDR,i(0:5) rA:=-memory[ADDR+rIi]; LDXNADDR,i(0:5) rX:=-memory[ADDR+rIi]; LD?N ADDR,i(0:5) rI? := - memory[ADDR + rIi]; STAADDR,i(0:5) memory[ADDR+rIi]:=rA; STXADDR,i(0:5) memory[ADDR+rIi]:=rX; ST? ADDR,i(0:5) memory[ADDR + rIi] := rI?; STJADDR,i(0:5) memory[ADDR+rIi]:=rJ; STZADDR,i(0:5) memory[ADDR+rIi]:=0; ADDADDR,i(0:5) rA:=rA+memory[ADDR+rIi]; SUBADDR,i(0:5) rA:=rA-memory[ADDR+rIi]; MULADDR,i(0:5) (rA,rX):=rA*memory[ADDR+rIi]; DIVADDR,i(0:5)\n\nrA:=int((rA,rX)/memory[ADDR+rIi]); rX:=(rA,rX)%memory[ADDR+rIi];\n\nENTAADDR,i rA:=ADDR+rIi; ENTXADDR,i rX:=ADDR+rIi; ENT? ADDR,i rI? := ADDR + rIi; ENNAADDR,i rA:=-ADDR-rIi; ENNXADDR,i rX:=-ADDR-rIi; ENN? ADDR,i rI? := - ADDR - rIi; INCAADDR,i rA:=rA+ADDR+rIi; INCXADDR,i rX:=rX+ADDR+rIi; INC? ADDR,i rI? := rI? + ADDR + rIi; DECAADDR,i rA:=rA-ADDR-rIi; DECXADDR,i rX:=rX-ADDR-rIi; DEC? ADDR,i rI? := rI? - ADDR - rIi; CMPAADDR,i(0:5) compare rA with memory[ADDR + rIi] and set comparison flag; CMPXADDR,i(0:5) compare rX with memory[ADDR + rIi] and set comparison flag; CMP? ADDR,i(0:5) compare rI? with memory[ADDR + rIi] and set comparison flag; JMPADDR,i\n\nrJ:=addressofnextinstruction; gotoADDR+rIi;\n\nJSJADDR,i gotoADDR+rIi; JOVADDR,i\n\nif(overflow)then overflow:=false; gotoADDR+rIi;\n\nJ?N/J?Z/J?P ADDR,i\n\nJ?NN/J?NZ/J?NP ADDR,i\n\nif (rI?<0 or rI?==0 or rI?>0) then goto ADDR + rIi; if (rI?>=0 or rI?!=0 or rI?<=0) then goto ADDR + rIi;\n\nMOVEADDR,i(F)\n\nfor(n=0;n<F;n++,rI1++) memory[rI1]:=memory[ADDR+rIi+n];\n\nSLA/SRA ADDR,i\n\nSLAX/SRAX ADDR,i\n\nSLC/SRC ADDR,i shift rA to the left/right by ADDR+rIi bytes\n\nshift (rA,rX) to the left/right by ADDR+rIi bytes\n\nrotate (rA,rX) to the left/right by ADDR+rIi bytes NOP do nothing; HLT halt execution; INADDR,i(F) read in one block from input unit F\n\ninto memory[ADDR + rIi] onwards; OUTADDR,i(F) output one block to unit F\n\nfrom memory[ADDR + rIi] onwards; IOCADDR,i(F) send control instruction to i/o unit F; JREDADDR,i(F) if(i/ounitFisready)thengotoADDR+rIi; JBUSADDR,i(F) if(i/ounitFisbusy)thengotoADDR+rIi; NUM rA := numerical value of characters in (rA,rX); CHAR (rA,rX) := character codes representing value of rA;\n\nMIX has been implemented in software by:\n\nKnuth's MIXWare and the derived GNU MDK;\n\n9front's mix(1);[1] and\n\nHardware::Simulator::MIX on CPAN.[2]\n\nAn implementation of MIX was created for the iCE40HX8K FPGA board in 2021.[3]\n\nEducational programming language\n\nDLX\n\nLC-3\n\nLittle man computer\n\nMMIX\n\nMikroSim"
    }
}