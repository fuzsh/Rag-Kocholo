{
    "id": "dbpedia_7276_0",
    "rank": 64,
    "data": {
        "url": "https://web.dev/articles/lcp",
        "read_more_link": "",
        "language": "en",
        "title": "Largest Contentful Paint (LCP)",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.gstatic.com/devrel-devsite/prod/v4513918f2560a1fecca3cf64c2df2e8b263c90b977664567b98ccb062542a623/web/images/lockup.svg",
            "https://www.gstatic.com/devrel-devsite/prod/v4513918f2560a1fecca3cf64c2df2e8b263c90b977664567b98ccb062542a623/web/images/lockup.svg",
            "https://web.dev/images/authors/philipwalton.jpg",
            "https://web.dev/images/authors/tunetheweb.jpg",
            "https://web.dev/static/articles/lcp/image/good-lcp-values-are-25-s-28836be83d1aa.svg",
            "https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_36.png 36w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_48.png 48w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_72.png 72w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_96.png 96w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_480.png 480w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_720.png 720w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_856.png 856w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_960.png 960w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_1440.png 1440w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_1920.png 1920w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_2880.png 2880w",
            "https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_36.png 36w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_48.png 48w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_72.png 72w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_96.png 96w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_480.png 480w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_720.png 720w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_856.png 856w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_960.png 960w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_1440.png 1440w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_1920.png 1920w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_2880.png 2880w",
            "https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_36.png 36w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_48.png 48w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_72.png 72w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_96.png 96w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_480.png 480w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_720.png 720w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_856.png 856w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_960.png 960w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_1440.png 1440w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_1920.png 1920w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_2880.png 2880w",
            "https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_36.png 36w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_48.png 48w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_72.png 72w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_96.png 96w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_480.png 480w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_720.png 720w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_856.png 856w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_960.png 960w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_1440.png 1440w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_1920.png 1920w,https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_2880.png 2880w"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "This post introduces the Largest Contentful Paint (LCP) metric and explains how to measure it",
        "meta_lang": "en",
        "meta_favicon": "https://www.gstatic.com/devrel-devsite/prod/v4513918f2560a1fecca3cf64c2df2e8b263c90b977664567b98ccb062542a623/web/images/favicon.png",
        "meta_site_name": "web.dev",
        "canonical_link": "https://web.dev/articles/lcp",
        "text": "Historically, it's been a challenge for web developers to measure how quickly the main content of a web page loads and is visible to users. Older metrics like load or DOMContentLoaded don't work well because they don't necessarily correspond to what the user sees on their screen. And newer, user-centric performance metrics like First Contentful Paint (FCP) only capture the very beginning of the loading experience. If a page shows a splash screen or displays a loading indicator, this moment isn't very relevant to the user.\n\nIn the past, we've recommended performance metrics like First Meaningful Paint (FMP) and Speed Index (SI) (both available in Lighthouse) to help capture more of the loading experience after the initial paint, but these metrics are complex, hard to explain, and often wrong—meaning they still don't identify when the main content of the page has loaded.\n\nBased on discussions in the W3C Web Performance Working Group and research done at Google, we've found that a more accurate way to measure when the main content of a page is loaded is to look at when the largest element is rendered.\n\nWhat is LCP?\n\nLCP reports the render time of the largest image, text block, or video visible in the viewport, relative to when the user first navigated to the page.\n\nWhat is a good LCP score?\n\nTo provide a good user experience, sites should strive to have Largest Contentful Paint of 2.5 seconds or less. To ensure you're hitting this target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices.\n\nWhat elements are considered?\n\nAs currently specified in the Largest Contentful Paint API, the types of elements considered for Largest Contentful Paint are:\n\n<img> elements (the first frame presentation time is used for animated content such as GIFs or animated PNGs)\n\n<image> elements inside an <svg> element\n\n<video> elements (the poster image load time or first frame presentation time for videos is used—whichever is earlier)\n\nAn element with a background image loaded using the url() function, (as opposed to a CSS gradient)\n\nBlock-level elements containing text nodes or other inline-level text element children.\n\nNote that restricting the elements to this limited set was intentional in order to keep things simple in the beginning. Additional elements (like the full <svg> support) may be added in the future as more research is conducted.\n\nAs well as only considering some elements, LCP measurements use heuristics to exclude certain elements that users are likely to see as \"non-contentful\". For Chromium-based browsers, these include:\n\nElements with an opacity of 0, that are invisible to the user\n\nElements that cover the full viewport, that are likely considered as background rather than content\n\nPlaceholder images or other images with a low entropy, that likely don't reflect the true content of the page\n\nBrowsers are likely to continue to improve these heuristics to ensure we match user expectations of what the largest contentful element is.\n\nThese \"contentful\" heuristics may differ from those used by First Contentful Paint (FCP), which may consider some of these elements, such as placeholder images or full viewport images, even if they are ineligible to be LCP candidates. Despite both using \"contentful\" in their name, the aim of these metrics is different. FCP measures when any content is painted to screen and LCP when the main content is painted so LCP is intented to be more selective.\n\nHow is an element's size determined?\n\nThe size of the element reported for LCP is typically the size that's visible to the user within the viewport. If the element extends outside of the viewport, or if any of the element is clipped or has non-visible overflow, those portions don't count toward the element's size.\n\nFor image elements that have been resized from their intrinsic size, the size that gets reported is either the visible size or the intrinsic size, whichever is smaller.\n\nFor text elements, LCP considers only the smallest rectangle that can contain all text nodes.\n\nFor all elements, LCP doesn't consider margins, paddings, or borders applied using CSS.\n\nWhen is LCP reported?\n\nWeb pages often load in stages, and as a result, it's possible that the largest element on the page might change.\n\nTo handle this potential for change, the browser dispatches a PerformanceEntry of type largest-contentful-paint identifying the largest contentful element as soon as the browser has painted the first frame. But then, after rendering subsequent frames, it will dispatch another PerformanceEntry any time the largest contentful element changes.\n\nFor example, on a page with text and a hero image the browser may initially just render the text—at which point the browser would dispatch a largest-contentful-paint entry whose element property would likely reference a <p> or <h1>. Later, once the hero image finishes loading, a second largest-contentful-paint entry would be dispatched and its element property would reference the <img>.\n\nAn element can only be considered the largest contentful element after it has rendered and is visible to the user. Images that haven't yet loaded aren't considered \"rendered\". Neither are text nodes using web fonts during the font block period. In such cases, a smaller element might be reported as the largest contentful element, but as soon as the larger element finishes rendering, another PerformanceEntry is created.\n\nIn addition to late-loading images and fonts, a page may add new elements to the DOM as new content becomes available. If any of these new elements is larger than the previous largest contentful element, a new PerformanceEntry will also be reported.\n\nIf the largest contentful element is removed from the viewport, or even from the DOM, it remains the largest contentful element unless a larger element is rendered.\n\nThe browser will stop reporting new entries as soon as the user interacts with the page (via a tap, scroll, or keypress), as user interaction often changes what's visible to the user (which is especially true with scrolling).\n\nFor analysis purposes, you should only report the most recently dispatched PerformanceEntry to your analytics service.\n\nLoad time versus render time\n\nFor security reasons, the render timestamp of images is not exposed for cross-origin images that lack the Timing-Allow-Origin header. Instead, only their load time is exposed (since this is already exposed through many other web APIs).\n\nThis can lead to the seemingly impossible situation where LCP is reported by web APIs as earlier than FCP. This is not the case but only appears so due to this security restriction.\n\nWhen possible, it's always recommended to set the Timing-Allow-Origin header, so your metrics will be more accurate.\n\nHow are element layout and size changes handled?\n\nTo keep the performance overhead of calculating and dispatching new performance entries low, changes to an element's size or position don't generate new LCP candidates. Only the element's initial size and position in the viewport is considered.\n\nThis means images that are initially rendered off-screen and then transition on-screen may not be reported. It also means elements initially rendered in the viewport that then get pushed down, out of view will still report their initial, in-viewport size.\n\nExamples\n\nHere are some examples of when the Largest Contentful Paint occurs on a few popular websites:\n\nIn both of the timelines above, the largest element changes as content loads. In the first example, new content is added to the DOM and that changes what element is the largest. In the second example, the layout changes and content that was previously the largest is removed from the viewport.\n\nWhile it's often the case that late-loading content is larger than content already on the page, that's not necessarily the case. The next two examples show the LCP occurring before the page fully loads.\n\nIn the first example, the Instagram logo is loaded relatively early and it remains the largest element even as other content is progressively shown. In the Google Search results page example, the largest element is a paragraph of text that is displayed before any of the images or logo finish loading. Since all the individual images are smaller than this paragraph, it remains the largest element throughout the load process.\n\nHow to measure LCP\n\nLCP can be measured in the lab or in the field, and it's available in the following tools:\n\nChrome User Experience Report\n\nPageSpeed Insights\n\nSearch Console (Core Web Vitals report)\n\nweb-vitals JavaScript library\n\nChrome DevTools\n\nLighthouse\n\nPageSpeed Insights\n\nWebPageTest\n\nMeasure LCP in JavaScript\n\nTo measure LCP in JavaScript, you can use the Largest Contentful Paint API. The following example shows how to create a PerformanceObserver that listens for largest-contentful-paint entries and logs them to the console.\n\nnew PerformanceObserver((entryList) => { for (const entry of entryList.getEntries()) { console.log('LCP candidate:', entry.startTime, entry); } }).observe({type: 'largest-contentful-paint', buffered: true});\n\nIn the above example, each logged largest-contentful-paint entry represents the current LCP candidate. In general, the startTime value of the last entry emitted is the LCP value—however, that is not always the case. Not all largest-contentful-paint entries are valid for measuring LCP.\n\nThe following section lists the differences between what the API reports and how the metric is calculated.\n\nDifferences between the metric and the API\n\nThe API will dispatch largest-contentful-paint entries for pages loaded in a background tab, but those pages should be ignored when calculating LCP.\n\nThe API will continue to dispatch largest-contentful-paint entries after a page has been backgrounded, but those entries should be ignored when calculating LCP (elements may only be considered if the page was in the foreground the entire time).\n\nThe API does not report largest-contentful-paint entries when the page is restored from the back/forward cache, but LCP should be measured in these cases since users experience them as distinct page visits.\n\nThe API does not consider elements within iframes but the metric does as they are part of the user experience of the page. In pages with an LCP within an iframe—for example a poster image on an embedded video—this will show as a difference between CrUX and RUM. To properly measure LCP you should consider them. Sub-frames can use the API to report their largest-contentful-paint entries to the parent frame for aggregation.\n\nThe API measures LCP from navigation start, but for prerendered pages LCP should be measured from activationStart since that corresponds to the LCP time as experienced by the user.\n\nRather than memorizing all these subtle differences, developers can use the web-vitals JavaScript library to measure LCP, which handles these differences for you (where possible—note the iframe issue is not covered):\n\nimport {onLCP} from 'web-vitals'; // Measure and log LCP as soon as it's available. onLCP(console.log);\n\nRefer to the source code for onLCP() for a complete example of how to measure LCP in JavaScript.\n\nWhat if the largest element isn't the most important?\n\nIn some cases the most important element (or elements) on the page is not the same as the largest element, and developers may be more interested in measuring the render times of these other elements instead. This is possible using the Element Timing API, as described in the article on custom metrics.\n\nHow to improve LCP\n\nA full guide on optimizing LCP is available to guide you through the process of identifying LCP timings in the field and using lab data to drill down and optimize them.\n\nAdditional resources\n\nLessons learned from performance monitoring in Chrome by Annie Sullivan at performance.now() (2019)\n\nChangelog\n\nOccasionally, bugs are discovered in the APIs used to measure metrics, and sometimes in the definitions of the metrics themselves. As a result, changes must sometimes be made, and these changes can show up as improvements or regressions in your internal reports and dashboards.\n\nTo help you manage this, all changes to either the implementation or definition of these metrics will be surfaced in this Changelog."
    }
}