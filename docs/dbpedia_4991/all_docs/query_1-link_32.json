{
    "id": "dbpedia_4991_1",
    "rank": 32,
    "data": {
        "url": "https://dl.acm.org/doi/pdf/10.5555/3049832.3049865",
        "read_more_link": "",
        "language": "en",
        "title": "Software prefetching for indirect memory accesses",
        "top_image": "https://dl.acm.org/cms/asset/2006fd13-d027-4349-8b26-811a7d73b598/3049832.cover.jpg",
        "meta_img": "https://dl.acm.org/cms/asset/2006fd13-d027-4349-8b26-811a7d73b598/3049832.cover.jpg",
        "images": [
            "https://dl.acm.org/specs/products/acm/releasedAssets/images/acm-dl-logo-white-1ecfb82271e5612e8ca12aa1b1737479.png",
            "https://dl.acm.org/doi/pdf/10.5555/specs/products/acm/releasedAssets/images/acm-logo-1-ad466e729c8e2a97780337b76715e5cf.png",
            "https://dl.acm.org/action/showDoPubAsset?doi=10.1145/contrib-99659035136&format=rel-imgonly&assetId=99659035136.jpg",
            "https://dl.acm.org/action/showDoPubAsset?doi=10.1145/contrib-81100554757&format=rel-imgonly&assetId=img_5652_1500x2000.jpg",
            "https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1-45ae33115db81394d8bd25be65853b77.png",
            "https://dl.acm.org/specs/products/acm/releasedAssets/images/Default_image_lazy-0687af31f0f1c8d4b7a22b686995ab9b.svg",
            "https://dl.acm.org/pb-assets/icons/DOs/default-profile-1543932446943.svg",
            "https://dl.acm.org/pb-assets/icons/DOs/default-profile-1543932446943.svg",
            "https://dl.acm.org/pb-assets/icons/DOs/default-profile-1543932446943.svg",
            "https://dl.acm.org/specs/products/acm/releasedAssets/images/loader-7e60691fbe777356dc81ff6d223a82a6.gif",
            "https://dl.acm.org/action/showDoPubAsset?doi=10.1145/contrib-99659035136&format=rel-imgonly&assetId=99659035136.jpg",
            "https://dl.acm.org/action/showDoPubAsset?doi=10.1145/contrib-81100554757&format=rel-imgonly&assetId=img_5652_1500x2000.jpg",
            "https://dl.acm.org/specs/products/acm/releasedAssets/images/acm-logo-dl-8437178134fce530bc785276fc316cbf.png",
            "https://dl.acm.org/specs/products/acm/releasedAssets/images/acm-logo-3-10aed79f3a6c95ddb67053b599f029af.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "UK View Profile",
            "Sam Ainsworth",
            "Timothy M. Jones"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/pb-assets/head-metadata/apple-touch-icon-1574252172393.png",
        "meta_site_name": "ACM Conferences",
        "canonical_link": "https://dl.acm.org/doi/10.5555/3049832.3049865",
        "text": "Abstract\n\nMany modern data processing and HPC workloads are heavily memory-latency bound. A tempting proposition to solve this is software prefetching, where special non-blocking loads are used to bring data into the cache hierarchy just before being required. However, these are difficult to insert to effectively improve performance, and techniques for automatic insertion are currently limited.\n\nThis paper develops a novel compiler pass to automatically generate software prefetches for indirect memory accesses, a special class of irregular memory accesses often seen in high-performance workloads. We evaluate this across a wide set of systems, all of which gain benefit from the technique. We then evaluate the extent to which good prefetch instructions are architecture dependent. Across a set of memory-bound benchmarks, our automated pass achieves average speedups of 1.3× and 1.1× for an Intel Haswell processor and an ARM Cortex-A57, both out-of-order cores, and performance improvements of 2.1× and 3.7× for the in-order ARM Cortex-A53 and Intel Xeon Phi.\n\nReferences\n\n[1]\n\nD. H. Bailey, E. Barszcz, J. T. Barton, D. S. Browning, R. L. Carter, L. Dagum, R. A. Fatoohi, P. O. Frederickson, T. A. Lasinski, R. S. Schreiber, H. D. Simon, V. Venkatakrishnan, and S. K. Weeratunga. The NAS Parallel benchmarks – summary and preliminary results. In SC, 1991.\n\n[2]\n\nD. Callahan, K. Kennedy, and A. Porterfield. Software prefetching. In ASPLOS, 1991.\n\n[3]\n\nS. Chen, A. Ailamaki, P. B. Gibbons, and T. C. Mowry. Improving hash join performance through prefetching. ACM Trans. Database Syst., 32(3), Aug. 2007.\n\n[4]\n\nT.-F. Chen and J.-L. Baer. Reducing memory latency via nonblocking and prefetching caches. In ASPLOS, 1992.\n\n[5]\n\nA. Frumusanu. The ARM Cortex A73 – Artemis Unveiled. http://www.anandtech.com/show/10347/ arm-cortex-a73-artemis-unveiled/2, 2016.\n\n[6]\n\nA. Jimborean, K. Koukos, V. Spiliopoulos, D. Black-Schaffer, and S. Kaxiras. Fix the code. don’t tweak the hardware: A new compiler approach to voltage-frequency scaling. In CGO, 2014.\n\n[7]\n\nM. Khan and E. Hagersten. Resource conscious prefetching for irregular applications in multicores. In SAMOS, 2014.\n\n[8]\n\nM. Khan, M. A. Laurenzano, J. Mars, E. Hagersten, and D. Black-Schaffer. AREP : Adaptive resource efficient prefetching for maximizing multicore performance. In PACT, 2015.\n\n[9]\n\nD. Kim and D. Yeung. Design and evaluation of compiler algorithms for pre-execution. SIGPLAN Not., 37(10), Oct. 2002.\n\n[10]\n\nO. Kocberber, B. Grot, J. Picorel, B. Falsafi, K. Lim, and P. Ranganathan. Meet the Walkers: Accelerating index traversals for in-memory databases. In MICRO, 2013.\n\n[11]\n\nR. Krishnaiyer. Compiler prefetching for the Intel Xeon Phi coprocessor. https://software.intel.com/ sites/default/files/managed/54/77/5.3prefetching-on-mic-update.pdf, 2012.\n\n[12]\n\nR. Krishnaiyer, E. Kultursay, P. Chawla, S. Preis, A. Zvezdin, and H. Saito. Compiler-based data prefetching and streaming non-temporal store generation for the Intel(R) Xeon Phi(TM) coprocessor. In IPDPSW, 2013.\n\n[13]\n\nS. Kumar, A. Shriraman, V. Srinivasan, D. Lin, and J. Phillips. SQRL: Hardware accelerator for collecting software data structures. In PACT, 2014.\n\n[14]\n\nC. Lattner and V. Adve. LLVM: A compilation framework for lifelong program analysis &amp; transformation. In CGO, 2004.\n\n[15]\n\nJ. Lee, H. Kim, and R. Vuduc. When prefetching works, when it doesn’t, and why. ACM Trans. Archit. Code Optim., 9(1), Mar. 2012.\n\n[16]\n\nM. H. Lipasti, W. J. Schmidt, S. R. Kunkel, and R. R. Roediger. SPAID: Software prefetching in pointer- and callintensive environments. In MICRO, 1995.\n\n[17]\n\nC.-K. Luk and T. C. Mowry. Compiler-based prefetching for recursive data structures. In ASPLOS, 1996.\n\n[18]\n\nA. Lumsdaine, D. Gregor, B. Hendrickson, and J. Berry. Challenges in parallel graph processing. Parallel Processing Letters, 17(01), 2007.\n\n[19]\n\nP. R. Luszczek, D. H. Bailey, J. J. Dongarra, J. Kepner, R. F. Lucas, R. Rabenseifner, and D. Takahashi. The HPC challenge (HPCC) benchmark suite. In SC, 2006.\n\n[20]\n\nV. Malhotra and C. Kozyrakis. Library-based prefetching for pointer-intensive applications. Technical report, Computer Systems Laboratory, Stanford University, 2006.\n\n[21]\n\nJ. D. McCalpin. Native computing and optimization on the Intel Xeon Phi coprocessor. https: //portal.tacc.utexas.edu/documents/13601/ 933270/MIC_Native_2013-11-16.pdf, 2013.\n\n[22]\n\nT. C. Mowry. Tolerating Latency Through Software-Controlled Data Prefetching. PhD thesis, Stanford University, Computer Systems Laboratory, 1994.\n\n[23]\n\nT. C. Mowry, M. S. Lam, and A. Gupta. Design and evaluation of a compiler algorithm for prefetching. In ASPLOS, 1992.\n\n[24]\n\nR. C. Murphy, K. B. Wheeler, B. W. Barrett, and J. A. Ang. Introducing the Graph 500. Cray User’s Group (CUG), May 5, 2010.\n\n[25]\n\nK. Nilakant, V. Dalibard, A. Roy, and E. Yoneki. Prefedge: SSD prefetcher for large-scale graph traversal. In SYSTOR, 2014.\n\n[26]\n\nJ. Teubner, G. Alonso, C. Balkesen, and M. T. Ozsu. Mainmemory hash joins on multi-core cpus: Tuning to the underlying hardware. In ICDE, 2013.\n\n[27]\n\nS. VanderWiel and D. Lilja. A compiler-assisted data prefetch controller. In ICCD, 1999.\n\n[28]\n\nV. Viswanathan. Disclosure of h/w prefetcher control on some intel processors. https://software. intel.com/en-us/articles/disclosureof-hw-prefetcher-control-on-some-intelprocessors, Sept. 2014.\n\n[29]\n\nY. Wu, M. J. Serrano, R. Krishnaiyer, W. Li, and J. Fang. Value-profile guided stride prefetching for irregular code. In CC, 2002.\n\nCited By\n\nView all\n\nZhang YSobotka NPark SJamilan SKhan TKasikci BPokam GLitz HDevietti JTsafrir DMusuvathi MGupta RAbu-Ghazaleh NRPG2: Robust Profile-Guided Runtime Prefetch GenerationProceedings of the 29th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 210.1145/3620665.3640396(999-1013)\n\nDomingos JNeves NRoma NTomás PMartínez JDuato JJohn LUnlimited vector extension with data streaming supportProceedings of the 48th Annual International Symposium on Computer Architecture10.1109/ISCA52012.2021.00025(209-222)\n\nNaithani AAinsworth SJones TEeckhout LMartínez JDuato JJohn LVector runaheadProceedings of the 48th Annual International Symposium on Computer Architecture10.1109/ISCA52012.2021.00024(195-208)\n\nShow More Cited By\n\nRecommendations\n\nInformed Prefetching for Indirect Memory Accesses\n\nIndirect memory accesses have irregular access patterns that limit the performance of conventional software and hardware-based prefetchers. To address this problem, we propose the Array Tracking Prefetcher (ATP), which tracks array-based indirect memory ...\n\nSoftware Prefetching for Indirect Memory Accesses: A Microarchitectural Perspective\n\nMany modern data processing and HPC workloads are heavily memory-latency bound. A tempting proposition to solve this is software prefetching, where special non-blocking loads are used to bring data into the cache hierarchy just before being required. ...\n\nSoftware caching vs. prefetching\n\nMSP 2002 and ISMM 2002\n\nThe performance gap between memory subsystem and high-performance processors is ever-increasing. Prefetching is one method to bridge this performance gap. Prefetching has been proposed for array-based and pointer applications, typically using software-...\n\nInformation & Contributors\n\nInformation\n\nPublished In\n\n317 pages\n\nISBN:9781509049318\n\nGeneral Chair:\n\nVijay Janapa Reddi\n\nUniversity of Texas at Austin, USA\n\n,\n\nProgram Chairs:\n\nAaron Smith\n\nMicrosoft Research, UK / University of Edinburgh, UK\n\n,\n\nLingjia Tang\n\nUniversity of Michigan, USA\n\nPublisher\n\nIEEE Press\n\nPublication History\n\nPublished: 04 February 2017\n\nCheck for updates\n\nAuthor Tags\n\nCompiler Analysis\n\nSoftware Prefetching\n\nQualifiers\n\nArticle\n\nConference\n\nCGO '17\n\nAcceptance Rates\n\nCGO '17 Paper Acceptance Rate 26 of 116 submissions, 22%;\n\nOverall Acceptance Rate 312 of 1,061 submissions, 29%\n\nContributors\n\nOther Metrics\n\nBibliometrics & Citations\n\nBibliometrics\n\nArticle Metrics\n\n8\n\nTotal Citations\n\nView Citations\n\n614\n\nTotal Downloads\n\nDownloads (Last 12 months)32\n\nDownloads (Last 6 weeks)1\n\nOther Metrics\n\nCitations\n\nCited By\n\nView all\n\nZhang YSobotka NPark SJamilan SKhan TKasikci BPokam GLitz HDevietti JTsafrir DMusuvathi MGupta RAbu-Ghazaleh NRPG2: Robust Profile-Guided Runtime Prefetch GenerationProceedings of the 29th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 210.1145/3620665.3640396(999-1013)\n\nDomingos JNeves NRoma NTomás PMartínez JDuato JJohn LUnlimited vector extension with data streaming supportProceedings of the 48th Annual International Symposium on Computer Architecture10.1109/ISCA52012.2021.00025(209-222)\n\nNaithani AAinsworth SJones TEeckhout LMartínez JDuato JJohn LVector runaheadProceedings of the 48th Annual International Symposium on Computer Architecture10.1109/ISCA52012.2021.00024(195-208)\n\nZhou RWort GErdős MJones TSartor JNaik MRossbach CThe janus triad: exploiting parallelism through dynamic binary modificationProceedings of the 15th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments10.1145/3313808.3313812(88-100)\n\nTran KJimborean ACarlson TKoukos KSjälander MKaxiras SSWOOP: software-hardware co-design for non-speculative, execute-ahead, in-order coresACM SIGPLAN Notices10.1145/3296979.319239353:4(328-343)\n\nAinsworth SJones TAn Event-Triggered Programmable Prefetcher for Irregular WorkloadsACM SIGPLAN Notices10.1145/3296957.317318953:2(578-592)\n\nTran KJimborean ACarlson TKoukos KSjälander MKaxiras SFoster JGrossman DSWOOP: software-hardware co-design for non-speculative, execute-ahead, in-order coresProceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation10.1145/3192366.3192393(328-343)\n\nAinsworth SJones TShen XTuck JBianchini RSarkar VAn Event-Triggered Programmable Prefetcher for Irregular WorkloadsProceedings of the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems10.1145/3173162.3173189(578-592)\n\nView Options\n\nGet Access\n\nLogin options\n\nCheck if you have access through your login credentials or your institution to get full access on this article.\n\nSign in\n\nFull Access\n\nView options\n\nPDF\n\nView or Download as a PDF file.\n\nPDF\n\neReader\n\nView online with eReader.\n\neReader\n\nMedia\n\nFigures\n\nOther\n\nTables\n\nShare\n\nShare\n\nShare this Publication link\n\nCopied!\n\nCopying failed.\n\nShare on social media\n\nAffiliations\n\nSam Ainsworth\n\nUniversity of Cambridge, UK\n\nTimothy M. Jones\n\nUniversity of Cambridge, UK\n\nRequest permissions Authors Info & Affiliations"
    }
}