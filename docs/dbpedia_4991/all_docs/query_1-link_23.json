{
    "id": "dbpedia_4991_1",
    "rank": 23,
    "data": {
        "url": "https://en.wikichip.org/wiki/arm_holdings/microarchitectures/cortex-a76",
        "read_more_link": "",
        "language": "en",
        "title": "Microarchitectures",
        "top_image": "https://en.wikichip.org/w/resources/assets/og_wikichip_logo.png",
        "meta_img": "https://en.wikichip.org/w/resources/assets/og_wikichip_logo.png",
        "images": [
            "https://en.wikichip.org/w/resources/assets/wikichip_logo4.svg",
            "https://en.wikichip.org/w/resources/assets/wikichip/a minus.svg",
            "https://en.wikichip.org/w/resources/assets/wikichip/a plus.svg",
            "https://en.wikichip.org/w/images/thumb/4/45/arm_deimos_roadmap.png/300px-arm_deimos_roadmap.png",
            "https://en.wikichip.org/w/images/thumb/7/75/cortex-a76_soc_block_diagram.svg/550px-cortex-a76_soc_block_diagram.svg.png",
            "https://en.wikichip.org/w/images/thumb/5/57/cortex-a76_block_diagram.svg/850px-cortex-a76_block_diagram.svg.png",
            "https://en.wikichip.org/w/images/thumb/2/26/a76_perf_claims.png/300px-a76_perf_claims.png",
            "https://en.wikichip.org/w/images/thumb/5/56/a76_latency_comprison.svg/700px-a76_latency_comprison.svg.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/w/resources/assets/wikichip.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Edit ValuesCortex-A76 µarchGeneral InfoArch TypeCPUDesignerARM HoldingsManufacturerTSMCIntroductionMay 31, 2018Process12 nm, 7 nm, 5 nmCore Configs1, 2, 4, 6, 8PipelineTypeSuperscalar, PipelinedOoOEYesSpeculativeYesReg RenamingYesStages13Decode4-wayInstructionsISAARMv8.2ExtensionsFPU, NEONCacheL1I Cache64 KiB/core\n\n4-way set associativeL1D Cache64 KiB/core\n\n4-way set associativeL2 Cache128-512 KiB/core\n\n8-way set associativeL3 Cache0-4 MiB/Cluster\n\n16-way set associativeSuccession\n\nCortex-A76 (codename Enyo) is the successor to the Cortex-A75, a low-power high-performance ARM microarchitecture designed by ARM Holdings for the mobile market. Enyo was designed by Arm's Austin, Texas team. This microarchitecture is designed as a synthesizable IP core and is sold to other semiconductor companies to be implemented in their own chips. The Cortex-A76, which implemented the ARMv8.2 ISA, is the a performant core which is often combined with a number of lower power cores (e.g. Cortex-A55) in a DynamIQ big.LITTLE configuration to achieve better energy/performance.\n\nHistory[edit]\n\nDevelopment of the Cortex-A76 started in 2013. Arm formally announced Enyo during Computex on May 31 2018.\n\nProcess Technology[edit]\n\nThough the Cortex-A76 may be fabricated on various different process nodes, it has been primarily designed for the 12 nm, 7 nm, and 5 nm process nodes.\n\nCompiler support[edit]\n\nCompiler Arch-Specific Arch-Favorable Arm Compiler -mcpu=cortex-a76 -mtune=cortex-a76 GCC -mcpu=cortex-a76 -mtune=cortex-a76 LLVM -march=? -mtune=?\n\nIf the Cortex-A76 is coupled with the Cortex-A55 in a big.LITTLE system, GCC also supports the following option:\n\nCompiler Tune GCC -mtune=cortex-a76.cortex-a55\n\nArchitecture[edit]\n\nKey changes from Cortex-A75[edit]\n\nSignificant IPC uplift (Arm self-reported around 20% IPC on SPEC CPU2006/SPEC CPU2017 int)\n\nFront-end\n\nBranch-prediction\n\nImproved accuracy\n\nDecoupled from the instruction fetch\n\nRunahead 32B/cycle\n\nExecution engine\n\n1.33x wider decode (4-way, up from 3-way)\n\n1.33x wider rename/commit (4-way, up from 3-way)\n\n1.6x wider dispatch (8 µOPs/cycle, up from 5)\n\nThis list is incomplete; you can help by expanding it.\n\nBlock Diagram[edit]\n\nTypical SoC[edit]\n\nIndividual Core[edit]\n\nMemory Hierarchy[edit]\n\nThe Cortex-A76 has a private L1I, L1D, and L2 cache.\n\nCache\n\nL1I Cache\n\n64 KiB, 4-way set associative\n\n64-byte cache lines\n\nOptional parity protection\n\nWrite-back\n\nL1D Cache\n\n64 KiB, 4-way set associative\n\n64-byte cache lines\n\n4-cycle fastest load-to-use latency\n\nOptional ECC protection per 32 bits\n\nWrite-back\n\nL2 Cache\n\n256 KiB OR 512 KiB (2 banks)\n\n8-way set associative\n\n9-cycle fastest load-to-use latency\n\noptional ECC protection per 64 bits\n\nModified Exclusive Shared Invalid (MESI) coherency\n\nStrictly inclusive of the L1 data cache & non-inclusive of the L1 instruction cache\n\nWrite-back\n\nL3 Cache\n\n2 MiB to 4 MiB, 16-way set associative\n\n26-31 cycles load-to-use\n\nShared by all the cores in the cluster\n\nlocated in the DynamIQ Shared Unit (DSU)\n\nThe A76 TLB consists of dedicated L1 TLB for instruction cache (ITLB) and another one for data cache (DTLB). Additionally, there is a unified L2 TLB (STLB).\n\nTLBs\n\nITLB\n\n4 KiB, 16 KiB, 64 KiB, 2 MiB, and 32 MiB page sizes\n\n48-entry fully associative\n\nDTLB\n\n48-entry fully associative\n\n4 KiB, 16 KiB, 64 KiB, 2 MiB, and 512 MiB page sizes\n\nSTLB\n\n1280-entry 5-way set associative\n\nOverview[edit]\n\nThe Cortex-A76 is a high-performance synthesizable core designed by Arm as the successor to the Cortex-A75. It is delivered as Register Transfer Level (RTL) description in Verilog and is designed. This core supports the ARMv8.2 extension as well as a number of other partial extensions. The A76 is a 4-way superscalar out-of-order processor with a private level 1 and level 2 caches. It is designed to be implemented inside the DynamIQ Shared Unit (DSU) cluster along with other cores. The DSU cluster supports up to eight cores of any combination (e.g., with little cores such as the Cortex-A55 or other just more Cortex-A76).\n\nCore[edit]\n\nThe Cortex-A76 succeeds the Cortex-A75. It is designed to take advantage of the 7 nm node in order to deliver up to 40% higher performance at the same power level (measured at 750 mW/core), or alternatively, up to 50% lower power for the same performance compared to the Cortex-A75 on the 10 nm node. This is achieved through a combination of both microarchitectural improvements as well as process technology advantages. It's worth noting that the A76 brings higher performance at a slight hit to the area by going wider. On the 7 nm process, the Cortex-A76 targets frequencies of 3 GHz and higher.\n\nPipeline[edit]\n\nThe Cortex-A76 is a complex, 4-way superscalar out-of-order processor with an 8-issue back end. The pipeline is 13 stages with an 11-cycle branch misprediction penalty. It has a 64 KiB level 1 instruction cache and a 64 KiB level 1 data cache along with a private level 2 cache that is configurable as either 256 KiB (1 bank) or 512 KiB (2 banks).\n\nFront-end[edit]\n\nEach cycle, up to 16 bytes are fetched from the L1 instruction cache. The instruction fetch works in tandem with the branch predictor in order to ensure the instruction stream is constantly ready to be fetched. Additionally, there is a return stack which stores the address and instruction set state (AArch32/R14 or AArch64/X30) on branches. On a return (e.g., ret on AArch64), the return stack will pop.\n\nKeeping the instruction stream feed is the task of the branch prediction unit. The branch prediction unit on the A76 is decoupled from the instruction fetch, allowing it to run ahead and in parallel with the instruction fetch to hide branch prediction latency. To that end, it now operates on 32-byte instruction windows, twice the fetch size. The main branch target buffer on the A76 is 6K-entries deep. The BPU comprises three stages in order to reduce latency with a 64-entry micro-BTB and a smaller 16-entry BTB.\n\nThe Cortex-A76 has a fixed 64 KiB L1I cache. It is virtually indexed, physically tagged (VIPT), which behaves as a physically indexed, physically tagged (PIPT) 4-way set-associative cache. The L1I$ supports optional parity protection and implements a pseudo-LRU cache replacement policy. The instruction cache has a 256-bit read interface from the L2 cache. Each cycle up to 32 bytes may be transferred to the L1I cache from the shared L2 cache.\n\nFrom the instruction fetch, up to four 32-bit instructions are sent to the decode queue (DQ) each cycle. For narrower 16-bit instructions (i.e., Thumb), this means up to eight instructions get queued. The A76 features a 4-way decode. Each cycle, up to four instructions may be decoded into a relatively semi-complex macro-operations (MOPs). There are on average 6% more MOPs than instructions. In total two cycles are involved in this operation - one for alignment and one for decode.\n\nBack-end[edit]\n\nThe Cortex-A76 back-end handles the execution of out-of-order operations. The design is largely inherited from the Cortex-A75 but has been adjusted for higher throughput.\n\nRenaming & Allocation[edit]\n\nFrom the front-end, up to four macro-operations may be sent each cycle to be renamed. The A76 has a capacity to handle up to 128 instructions in flight, a number that has no increased for a long time (the Cortex-A72 and even the Cortex-A57 had an out-of-order window of 128 instructions). Micro-operations are broken down into their µOP constituents and are scheduled for execution. Roughly 20% more µOPs are generated from the MOPs. From here, µOPs are sent to the instruction issue which controls when they can be dispatched to the execution pipelines. µOPs are queued in eight independent issue queues (120 entries in total).\n\nExecution Units[edit]\n\nThe A76 issue is 8-wide, allow for up to eight µOPs to execute each cycle. The execution units can be grouped into three categories: integer, advanced SIMD, and memory.\n\nThere are four pipelines in the integer cluster - three for general math operations and a dedicate branch ALU. All three ports have a simple ALU. Those perform arithmetic and logical data processing operations. The third port has support for complex arithmetic (e.g. MAC, DIV). Each port is served by an independent 16-entry issue queue.\n\nThere are two ASIMD/FP execution pipelines. Those are served by two 16-entry issue queues of their own. In the Cortex-A75, each of the pipelines were 64-bit wide, on the A76, they were doubled to 128-bit. This means each pipeline is capable of 2 double-precision operations, 4 single-precision, 8 half-precision, or 16 8-bit integer operations. On the A76, those pipelines can also execute the cryptographic instructions if the extension is supported (not offered by default and requires an additional license from Arm).\n\nBeyond the throughput improvements, the A76 improved some critical execution latencies.\n\nMemory subsystem[edit]\n\nThe A76 includes two ports with an address-generation unit on each - each supporting both loads and stores. The level 1 data cache is fixed at 64 KiB and can have an optional ECC protection per 32 bits. It is virtually indexed, physically tagged which behaves as a physically indexed, physically tagged 4-way set-associative cache. The L1D cache implements a pseudo-LRU cache replacement policy. It features a 4-cycle fastest load-to-use latency with two read ports and one write port meaning it can do two 16B loads/cycle and one 32B store/cycle. From the L1, the A76 supports up to 20 outstanding non-prefetch misses. The load buffer is 68 entries deep while the store buffer is 72-entry deep. In total, the A76 can have 140 simultaneous memory operations in-flight which is actually 25% more than the A76 instruction window.\n\nThe A76 can be configured with either 128, 256 or 512 KiB of level 2 cache. It implements a dynamic biased replacement policy and is ECC protected per 64 bits. The L2 is strictly inclusive of the L1 data cache and non-inclusive of the L1 instruction cache. There is a 256-bit write interface to the L2 and a 256-bit read interface from the L2 cache. The fastest load-to-use latency is 9 cycles. The L2 can support up to 46 outstanding misses to the L3 which is located in the DSU itself. The L3, which is shared by all the cores in the DynamIQ big.LITTLE and is configurable in size ranging from 2 MiB to 4 MiB with load-to-use ranging from 26 to 31 cycles. As with the L2, up to two 32 bytes may be transferred from or to the L2 from the L3 cache. Up to 94 outstanding misses are supported from the L3 to main memory.\n\nIn addition to controlling memory accesses, ordering, and cache policies, the MMU is also responsible for the translation of virtual addresses to physical addresses on the system. This is done through a set of virtual-to-physical address mappings and attributes that are held in translation tables. The physical address size here is 40 bits. The Cortex-A76 incorporates a dedicated L1 TLB for instruction cache and another one for the data cache. Both the ITLB and the DTLB are 48-entry deep and are fully associative. On a memory access operation, the A76 will first perform lookup in there. If there is a miss in the L1 TLBs, the MMU will perform a lookup for the requested entry in the second-level TLB.\n\nThere is a unified level 2 TLB comprising of 1280 entries organized as 5-way set associative which is shared by both instruction and data. The STLB handles misses from the instruction and data L1 TLBs. Typically, STLB accesses take three cycles, however, longer latencies are possible when a different block or page size mapping is used. If there is a miss in the L2 TLB, the MMU will resort to a hardware translation table walk. Up to four TLB misses (i.e., translations table walks) can be performed in parallel. The STLB will stall if there are six successive misses. During table walks, the STLB can still perform up to two TLB lookups.\n\nThe TLB entries store one or both of the global indicator and an address space identifier (ASID), allowing context switching without TLB invalidation as well as a virtual machine identifier (VMID) which allows for VM switching by the hypervisor without TLB invalidation.\n\nAll Cortex-A76 Processors[edit]\n\nBibliography[edit]"
    }
}