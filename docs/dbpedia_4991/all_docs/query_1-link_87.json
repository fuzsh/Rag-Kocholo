{
    "id": "dbpedia_4991_1",
    "rank": 87,
    "data": {
        "url": "https://www.cnblogs.com/baiyw/p/3521596.html",
        "read_more_link": "",
        "language": "en",
        "title": "ARM architecture",
        "top_image": "http://upload.wikimedia.org/wikipedia/commons/thumb/8/85/ARMSoCBlockDiagram.svg/300px-ARMSoCBlockDiagram.svg.png",
        "meta_img": "",
        "images": [
            "https://img2024.cnblogs.com/blog/35695/202408/35695-20240814085308222-1995553638.jpg",
            "https://assets.cnblogs.com/logo.svg",
            "https://assets.cnblogs.com/icons/search.svg",
            "https://assets.cnblogs.com/icons/enter.svg",
            "https://assets.cnblogs.com/icons/search.svg",
            "https://assets.cnblogs.com/icons/search.svg",
            "https://assets.cnblogs.com/icons/newpost.svg",
            "https://assets.cnblogs.com/icons/myblog.svg",
            "https://assets.cnblogs.com/icons/message.svg",
            "https://assets.cnblogs.com/icons/lite-mode-on.svg",
            "https://assets.cnblogs.com/icons/avatar-default.svg",
            "https://www.cnblogs.com/images/lite-mode-check.svg",
            "http://upload.wikimedia.org/wikipedia/en/6/6a/ARM_architecture_logo.gif",
            "http://upload.wikimedia.org/wikipedia/commons/thumb/8/85/ARMSoCBlockDiagram.svg/300px-ARMSoCBlockDiagram.svg.png",
            "http://bits.wikimedia.org/static-1.23wmf9/skins/common/images/magnify-clip.png",
            "http://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/Acorn-ARM-Evaluation-System.jpg/220px-Acorn-ARM-Evaluation-System.jpg",
            "http://bits.wikimedia.org/static-1.23wmf9/skins/common/images/magnify-clip.png",
            "http://upload.wikimedia.org/wikipedia/commons/thumb/8/89/STM32F103VGT6-HD.jpg/220px-STM32F103VGT6-HD.jpg",
            "http://bits.wikimedia.org/static-1.23wmf9/skins/common/images/magnify-clip.png",
            "http://upload.wikimedia.org/wikipedia/en/thumb/3/3e/Quad-core_Android_%22mini_PC%22%2C_with_a_microSD_card_next_to_it_for_a_size_comparison.jpg/220px-Quad-core_Android_%22mini_PC%22%2C_with_a_microSD_card_next_to_it_for_a_size_comparison.jpg",
            "http://bits.wikimedia.org/static-1.23wmf9/skins/common/images/magnify-clip.png",
            "http://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Android_4.0.png/170px-Android_4.0.png",
            "http://bits.wikimedia.org/static-1.23wmf9/skins/common/images/magnify-clip.png",
            "http://upload.wikimedia.org/wikipedia/commons/thumb/1/10/Arm_5250_full_1.jpg/200px-Arm_5250_full_1.jpg",
            "http://upload.wikimedia.org/wikipedia/en/thumb/5/58/Padlock-olive.svg/20px-Padlock-olive.svg.png",
            "http://upload.wikimedia.org/wikipedia/commons/thumb/8/87/In_Kernel_Switcher.jpg/320px-In_Kernel_Switcher.jpg",
            "http://bits.wikimedia.org/static-1.23wmf9/skins/common/images/magnify-clip.png",
            "http://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Global_Task_Scheduling.jpg/320px-Global_Task_Scheduling.jpg",
            "http://bits.wikimedia.org/static-1.23wmf9/skins/common/images/magnify-clip.png",
            "http://static.cnbetacdn.com/newsimg/2014/0211/5_1392099596.jpg",
            "https://img2024.cnblogs.com/blog/35695/202408/35695-20240813180353098-2140851696.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "ARM"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "http://en.wikipedia.org/wiki/ARM_architectureARM architectureARM architecturesThe ARM logoDesignerARM HoldingsBits32-bitor64-bitIntroduced1985DesignRI",
        "meta_lang": "zh",
        "meta_favicon": "//assets.cnblogs.com/favicon.svg?v=2",
        "meta_site_name": "",
        "canonical_link": "https://www.cnblogs.com/baiyw/p/3521596.html",
        "text": "ARM architectures\n\nThe ARM logo\n\nDesigner ARM Holdings Bits 32-bit or 64-bit Introduced 1985 Design RISC Type Register-Register Branching Condition code Open Proprietary\n\n64/32-bit architecture Introduced 2011 Version ARMv8-A Encoding AArch64/A64 and AArch32/A32 use 32-bit instructions, T32 (Thumb2) uses mixed 16- and 32-bit instructions. ARMv7 user-space compatibility[1] Endianness Bi (Little as default) Extensions All mandatory: Thumb-2, NEON,Jazelle, VFPv4-D16, VFPv4 Registers General purpose 31x 64-bit integer registers[1] plus PC and SP, ELR, SPSR for exception levels Floating point 32× 128-bit registers,[1]scalar 32- and 64-bit FP,SIMD 64- and 128-bit FP and integer\n\n32-bit architectures (Cortex) Version ARMv8-R, ARMv7-A, ARMv7-R, ARMv7E-M, ARMv7-M, ARMv6-M Encoding 32-bit except Thumb2 extensions use mixed 16- and 32-bit instructions. Endianness Bi (Little as default) Extensions Thumb-2 (mandatory since ARMv7), NEON, Jazelle, FPv4-SP Registers General purpose 16x 32-bit integer registers including PC and SP Floating point Up to 32× 64-bit registers,[2] SIMD/floating-point (optional)\n\n32-bit architectures (legacy) Version ARMv6, ARMv5, ARMv4T, ARMv3, ARMv2 Encoding 32-bit except Thumb extension uses mixed 16- and 32-bit instructions. Endianness Bi (Little as default) in ARMv3 and above Extensions Thumb, Jazelle Registers General purpose 16x 32-bit integer registers including PC (26-bit addressing in older) and SP\n\nARM is a family of instruction set architectures for computer processors based on a reduced instruction set computing(RISC) architecture developed by British company ARM Holdings.\n\nA RISC-based computer design approach means ARM processors require significantly fewer transistors than typical processors in average computers. This approach reduces costs, heat and power use. These are desirable traits for light, portable, battery-powered devices—including smartphones, laptops, tablet and notepad computers, and other embedded systems. A simpler design facilitates more efficient multi-core CPUs and higher core counts at lower cost, providing higher processing power and improved energy efficiency for servers and supercomputers.[3][4][5]\n\nARM Holdings develops the instruction set and architecture for ARM-based products, but does not manufacture products. The company periodically releases updates to its cores. Current cores from ARM Holdings support a 32-bit address space and 32-bit arithmetic; the recently introduced ARMv8-A architecture adds support for a 64-bit address space and 64-bit arithmetic. Instructions for ARM Holdings' cores have 32-bit-wide fixed-length instructions, but later versions of the architecture also support a variable-length instruction set that provides both 32-bit and 16-bit-wide instructions for improved code density. Some cores can also provide hardware execution of Java bytecodes.\n\nARM Holdings licenses the chip designs and the ARM instruction set architectures to third-parties, who design their own products that implement one of those architectures—including systems-on-chips (SoC) that incorporate memory, interfaces, radios, etc. Currently, the widely used Cortex cores, older \"classic\" cores, and specialized SecurCore cores variants are available for each of these to include or exclude optional capabilities. Companies that produce ARM products include Apple, Nvidia, Qualcomm, Rockchip, Samsung Electronics, and Texas Instruments. Apple first implemented the ARMv8-A architecture in the Apple A7 chip in the iPhone 5S.\n\nIn 2005, about 98% of all mobile phones sold used at least one ARM processor.[6] The low power consumption of ARM processors has made them very popular: 37 billion ARM processors have been produced as of 2013, up from 10 billion in 2008.[7] The ARM architecture (32-bit) is the most widely used architecture in mobile devices, and most popular 32-bit one in embedded systems.[8]\n\nAccording to ARM Holdings, in 2010 alone, producers of chips based on ARM architectures reported shipments of 6.1 billion ARM-based processors, representing 95% of smartphones, 35% of digital televisions and set-top boxes and 10% of mobile computers. It is the most widely used 32-bit instruction set architecture in terms of quantity produced.[9][10]\n\nHistory[edit]\n\nThe British computer manufacturer Acorn Computers first developed ARM in the 1980s to use in its personal computers. Its first ARM-based products were coprocessor modules for the BBC Micro series of computers. After the successful BBC Micro computer, Acorn Computers considered how to move on from the relatively simple MOS Technology 6502 processor to address business markets like the one that was soon dominated by the IBM PC, launched in 1981. The Acorn Business Computer (ABC) plan required that a number of second processors be made to work with the BBC Micro platform, but processors such as the Motorola 68000 and National Semiconductor 32016 were considered unsuitable, and the 6502 was not powerful enough for a graphics based user interface.[11]\n\nAfter testing all available processors and finding them lacking, Acorn decided it needed a new architecture. Inspired by white papers on the Berkeley RISC project, Acorn considered designing its own processor.[12] A visit to the Western Design Center in Phoenix, where the 6502 was being updated by what was effectively a single-person company, showed Acorn engineers Steve Furber and Sophie Wilson they did not need massive resources and state-of-the-art research and development facilities.[13]\n\nWilson developed the instruction set, writing a simulation of the processor in BBC Basic that ran on a BBC Micro with a second 6502 processor. This convinced Acorn engineers they were on the right track. Wilson approached Acorn's CEO, Hermann Hauser, and requested more resources. Once he had approval, he assembled a small team to implement Wilson's model in hardware.\n\nAcorn RISC Machine: ARM2[edit]\n\nThe official Acorn RISC Machine project started in October 1983. They chose VLSI Technology as the silicon partner, as they were a source of ROMs and custom chips for Acorn. Wilson and Furber led the design. They implemented it with a similar efficiency ethos as the 6502.[14] A key design goal was achieving low-latency input/output (interrupt) handling like the 6502. The 6502's memory access architecture had let developers produce fast machines without costly direct memory access hardware.\n\nVLSI produced the first ARM silicon on 26 April 1985. It worked the first time, and was known as ARM1 by April 1985.[3] The first production systems named ARM2 were available the following year.\n\nThe first practical ARM application was as a second processor for the BBC Micro, where it helped developed simulation software to finish development of the support chips (VIDC, IOC, MEMC), and sped up the CAD software used in ARM2 development. Wilson subsequently rewrote BBC Basic in ARM assembly language. The in-depth knowledge gained from designing the instruction set enabled the code to be very dense, making ARM BBC Basic an extremely good test for any ARM emulator. The original aim of a principally ARM-based computer was achieved in 1987 with the release of the Acorn Archimedes.[15] In 1992, Acorn once more won the Queen's Award for Technology for the ARM.\n\nThe ARM2 featured a 32-bit data bus, 26-bit address space and 27 32-bit registers. 8 bits from the program counter register were available for other purposes; the top 6 bits (available because of the 26-bit address space), served as status flags, and the bottom 2 bits (available because the program counter was always word-aligned), were used for setting modes. The address bus was extended to 32 bits in the ARM6, but program code still had to lie within the first 64 MB of memory in 26-bit compatibility mode, due to the reserved bits for the status flags.[16] The ARM2 had a transistor count of just 30,000, compared to Motorola's six-year-older 68000 model with 68,000.[17] Much of this simplicity came from the lack of microcode (which represents about one-quarter to one-third of the 68000) and from (like most CPUs of the day) not including any cache. This simplicity enabled low power consumption, yet better performance than the Intel 80286. A successor, ARM3, was produced with a 4 KB cache, which further improved performance.[18]\n\nApple, DEC, Intel, Marvell: ARM6, StrongARM, XScale[edit]\n\nIn the late 1980s Apple Computer and VLSI Technology started working with Acorn on newer versions of the ARM core. In 1990, Acorn spun off the design team into a new company named Acorn RISC Machines Ltd., which became ARM Ltd when its parent company, ARM Holdings plc, floated on the London Stock Exchange and NASDAQ in 1998.[19]\n\nThe new Apple-ARM work would eventually evolve into the ARM6, first released in early 1992. Apple used the ARM6-based ARM610 as the basis for their Apple Newton PDA. In 1994, Acorn used the ARM610 as the main central processing unit (CPU) in their RiscPC computers. DEC licensed the ARM6 architecture and produced the StrongARM. At 233 MHz, this CPU drew only one watt (newer versions draw far less). This work was later passed to Intel as a part of a lawsuit settlement, and Intel took the opportunity to supplement their i960 line with the StrongARM. Intel later developed its own high performance implementation named XScale, which it has since sold to Marvell. Transistor count of the ARM core remained essentially the same size throughout these changes; ARM2 had 30,000 transistors, while ARM6 grew only to 35,000.[citation needed]\n\nLicensing[edit]\n\nSee also: ARM Holdings#Licensees\n\nCore license[edit]\n\nARM Holdings' primary business is selling IP cores, which licensees use to create microcontrollers (MCUs) and CPUs based on those cores. The original design manufacturer combines the ARM core with other parts to produce a complete CPU, typically one that can be built in existing semiconductor fabs at low cost and still deliver substantial performance. The most successful implementation has been the ARM7TDMI with hundreds of millions sold. Atmel has been a precursor design center in the ARM7TDMI-based embedded system.\n\nThe ARM architectures used in smartphones, PDAs and other mobile devices range from ARMv5, used in low-end devices, through ARMv6, to ARMv7 in current high-end devices. ARMv7 includes a hardware floating-point unit (FPU), with improved speed compared to software-based floating-point.\n\nIn 2009, some manufacturers introduced netbooks based on ARM architecture CPUs, in direct competition with netbooks based on Intel Atom.[20] According to analyst firm IHS iSuppli, by 2015, ARM ICs may be in 23% of all laptops.[21]\n\nARM Holdings offers a variety of licensing terms, varying in cost and deliverables. ARM Holdings provides to all licensees an integratable hardware description of the ARM core as well as complete software development toolset (compiler, debugger,software development kit) and the right to sell manufactured silicon containing the ARM CPU.\n\nSoC packages integrating ARM's core designs include Nvidia Tegra's first three generations, CSR plc's Quatro family, ST-Ericsson's Nova and NovaThor, Silicon Labs's Precision32 MCU, Texas Instruments's OMAP products, Samsung's Hummingbird and Exynos products, Apple's A4, A5, andA5X, and Freescale's i.MX.\n\nFabless licensees, who wish to integrate an ARM core into their own chip design, are usually only interested in acquiring a ready-to-manufacture verified IP core. For these customers, ARM Holdings delivers a gate netlist description of the chosen ARM core, along with an abstracted simulation model and test programs to aid design integration and verification. More ambitious customers, including integrated device manufacturers (IDM) and foundry operators, choose to acquire the processor IP in synthesizable RTL (Verilog) form. With the synthesizable RTL, the customer has the ability to perform architectural level optimisations and extensions. This allows the designer to achieve exotic design goals not otherwise possible with an unmodified netlist (high clock speed, very low power consumption, instruction set extensions, etc.). While ARM Holdings does not grant the licensee the right to resell the ARM architecture itself, licensees may freely sell manufactured product such as chip devices, evaluation boards, complete systems. Merchant foundries can be a special case; not only are they allowed to sell finished silicon containing ARM cores, they generally hold the right to re-manufacture ARM cores for other customers.\n\nARM Holdings prices its IP based on perceived value. Lower performing ARM cores typically have lower licence costs than higher performing cores. In implementation terms, a synthesizable core costs more than a hard macro (blackbox) core. Complicating price matters, a merchant foundry that holds an ARM licence, such as Samsung or Fujitsu, can offer fab customers reduced licensing costs. In exchange for acquiring the ARM core through the foundry's in-house design services, the customer can reduce or eliminate payment of ARM's upfront licence fee.\n\nCompared to dedicated semiconductor foundries (such as TSMC and UMC) without in-house design services, Fujitsu/Samsung charge two- to three-times(2~3) more per manufactured wafer.[citation needed] For low to mid volume applications, a design service foundry offers lower overall pricing (through subsidisation of the licence fee). For high volume mass-produced parts, the long term cost reduction achievable through lower wafer pricing reduces the impact of ARM's NRE (Non-Recurring Engineering) costs, making the dedicated foundry a better choice.\n\nARM 公司本身并不靠自有的设计来制造或出售CPU，而是将处理器架构授权给有兴趣的厂家。ARM 提供了多样的授权条款，包括售价与散播性等项目。对于授权方来说，ARM 提供了ARM内核的整合硬件叙述，包含完整的软件开发工具（编译器、debugger、SDK），以及针对内含ARM CPU硅芯片的销售权。对于无晶圆厂的授权方来说，其希望能将ARM 内核整合到他们自行研发的芯片设计中，通常就仅针对取得一份生产就绪的知识产权内核（IP Core）认证。对这些客户来说，ARM 会释出所选的ARM 核心的闸极电路图，连同抽象模拟模型和测试程式，以协助设计整合和验证。需求更多的客户，包括整合元件制造商（IDM）和晶圆厂家，就选择可合成的RTL（暂存器转移层级，如Verilog）形式来取得处理器的知识产权（IP）。借助可整合的RTL，客户就有能力能进行架构上的最佳化与加强。这个方式能让设计者完成额外的设计目标（如高震荡频率、低能量耗损、指令集延伸等）而不会受限于无法更动的电路图。虽然 ARM 并不授予受权方再次出售ARM 架构本身，但受权方可以任意地出售制品（如芯片元件、评估板、完整系统等）。商用晶圆厂是特殊例子，因为他们不仅授予能出售包含ARM 内核的硅晶成品，对其它客户来讲，他们通常也保留重制ARM 内核的权利。\n\n就像大多数IP 出售方，ARM 依照使用价值来决定IP 的售价。在架构上而言，更低效能的ARM 内核比更高效能的内核拥有较低的授权费。以硅芯片实作而言，一颗可整合的内核要比一颗硬件宏（黑箱）内核要来得贵。更复杂的价位问题来讲，持有ARM 授权的商用晶圆厂（例如韩国三星和日本富士通）可以提供更低的授权价格给他们的晶圆厂客户。透过晶圆厂自有的设计技术，客户可以更低或是免费的ARM预付授权费来取得ARM 内核。相较于不具备自有设计技术的专门半导体晶圆厂（如台积电和联电），富士通/三星对每片晶圆多收取了两至三倍的费用。对中少量的应用而言，具备设计部门的晶圆厂提供较低的整体价格（透过授权费用的补助）。对于量产而言，由于长期的成本缩减可借由更低的晶圆价格，减少ARM的NRE成本，使得专门的晶圆厂也成了一个更好的选择。\n\nArchitectural licence[edit]\n\nCompanies can also obtain an ARM architectural licence for designing their own CPU cores using the ARM instruction sets. These cores must comply fully with the ARM architecture.\n\nCores[edit]\n\nMain article: List of ARM cores\n\nArchitectureBit\n\nwidthCores designed by ARM HoldingsCores designed by 3rd partiesCortex profileReferences ARMv1 32/26 ARM1 ARMv2 32/26 ARM2, ARM3 Amber ARMv3 32 ARM6, ARM7 ARMv4 32 ARM8 StrongARM, FA526 ARMv4T 32 ARM7TDMI, ARM9TDMI ARMv5 32 ARM7EJ, ARM9E, ARM10E XScale, FA626TE, Feroceon, PJ1/Mohawk ARMv6 32 ARM11 ARMv6-M 32 ARM Cortex-M0, ARM Cortex-M0+, ARM Cortex-M1 Microcontroller ARMv7-M 32 ARM Cortex-M3 Microcontroller ARMv7E-M 32 ARM Cortex-M4 Microcontroller ARMv7-R 32 ARM Cortex-R4, ARM Cortex-R5, ARM Cortex-R7 Real-time ARMv7-A 32 ARM Cortex-A5, ARM Cortex-A7, ARM Cortex-A8,\n\nARM Cortex-A9, ARM Cortex-A12, ARM Cortex-A15 Krait, Scorpion, PJ4/Sheeva, Apple A6/A6X (Swift) Application ARMv8-A 64/32 ARM Cortex-A53, ARM Cortex-A57[22] X-Gene, Denver, Apple A7 (Cyclone) Application [23][24] ARMv8-R 32 No announcements yet Real-time [25][26]\n\nA list of vendors who implement ARM cores in their design (application specific standard products (ASSP), microprocessor and microcontrollers) is provided by ARM Holdings.[27]\n\nExample applications of ARM cores[edit]\n\nARM cores are used in a number of products, particularly PDAs and smartphones. Some computing examples are the Microsoft Surface, Apple's iPad and ASUS Eee Pad Transformer. Others include Apple's iPhone smartphone and iPod portable media player,Canon PowerShot A470 digital camera, Nintendo DS handheld game console and TomTom turn-by-turn navigation system.\n\nIn 2005, ARM Holdings took part in the development of Manchester University's computer, SpiNNaker, which used ARM cores to simulate the human brain.[28]\n\nARM chips are also used in Raspberry Pi, BeagleBoard, BeagleBone, PandaBoard and other single-board computers, because they are very small, inexpensive and consume very little power.\n\n32-bit architecture[edit]\n\nThe 32-bit ARM architecture, such as ARMv7-A, is the most widely used architecture in mobile devices.[8]\n\nFrom 1995, the ARM Architecture Reference Manual has been the primary source of documentation on the ARM processor architecture and instruction set, distinguishing interfaces that all ARM processors are required to support (such as instruction semantics) from implementation details that may vary. The architecture has evolved over time, and version 7 of the architecture, ARMv7, that defines the architecture for the first of the Cortex series of cores, defines three architecture \"profiles\":\n\nA-profile, the \"Application\" profile: Cortex-A series\n\nR-profile, the \"Real-time\" profile: Cortex-R series\n\nM-profile, the \"Microcontroller\" profile: Cortex-M series\n\nAlthough the architecture profiles were first defined for ARMv7, ARM subsequently defined the ARMv6-M architecture (used by the Cortex M0/M0+/M1) as a subset of the ARMv7-M profile with fewer instructions.\n\nCPU modes[edit]\n\nExcept in the M-profile, the 32-bit ARM architecture specifies several CPU modes, depending on the implemented architecture features. At any moment in time, the CPU can be in only one mode, but it can switch modes due to external events (interrupts) or programmatically.[29]\n\nUser mode\n\nThe only non-privileged mode.\n\nFIQ mode\n\nA privileged mode that is entered whenever the processor accepts an FIQ interrupt.\n\nIRQ mode\n\nA privileged mode that is entered whenever the processor accepts an IRQ interrupt.\n\nSupervisor (svc) mode\n\nA privileged mode entered whenever the CPU is reset or when an SVC instruction is executed.\n\nAbort mode\n\nA privileged mode that is entered whenever a prefetch abort or data abort exception occurs.\n\nUndefined mode\n\nA privileged mode that is entered whenever an undefined instruction exception occurs.\n\nSystem mode (ARMv4 and above)\n\nThe only privileged mode that is not entered by an exception. It can only be entered by executing an instruction that explicitly writes to the mode bits of the CPSR.\n\nMonitor mode (ARMv6 and ARMv7 Security Extensions, ARMv8 EL3)\n\nA monitor mode is introduced to support TrustZone extension in ARM cores.\n\nHyp mode (ARMv7 Virtualization Extensions, ARMv8 EL2)\n\nA hypervisor mode that supports virtualization of the non-secure operation of the CPU.[30]\n\nInstruction set[edit]\n\nThe original ARM implementation was hardwired without microcode, like the much simpler 8-bit 6502 processor used in prior Acorn microcomputers.\n\nThe 32-bit ARM architecture (and the 64-bit architecture for the most part) includes the following RISC features:\n\nLoad/store architecture.\n\nNo support for unaligned memory accesses in the original version of the architecture. ARMv6 and later, except some microcontroller versions, support unaligned accesses for half-word and single-word load/store instructions with some limitations, such as no guaranteed atomicity.[31][32]\n\nUniform 16× 32-bit register file (including the Program Counter, Stack Pointer and the Link Register).\n\nFixed instruction width of 32 bits to ease decoding and pipelining, at the cost of decreased code density. Later, the Thumb instruction set added 16-bit instructions and increased code density.\n\nMostly single clock-cycle execution.\n\nTo compensate for the simpler design, compared with processors like the Intel 80286 and Motorola 68020, some additional design features were used:\n\nConditional execution of most instructions reduces branch overhead and compensates for the lack of a branch predictor.\n\nArithmetic instructions alter condition codes only when desired.\n\n32-bit barrel shifter can be used without performance penalty with most arithmetic instructions and address calculations.\n\nPowerful indexed addressing modes.\n\nA link register supports fast leaf function calls.\n\nA simple, but fast, 2-priority-level interrupt subsystem has switched register banks.\n\nArithmetic instructions[edit]\n\nThe ARM supports add, subtract, and multiply instructions. The integer divide instructions are only implemented by ARM cores based on the following ARM architectures:\n\nARMv7-M and ARMv7E-M architectures always include divide instructions.[33]\n\nARMv7-R architecture always includes divide instructions in the Thumb instruction set, but optionally in its 32-bit instruction set.[34]\n\nARMv7-A architecture optionally includes the divide instructions. The instructions might not be implemented, or implemented only in the Thumb instruction set, or implemented in both the Thumb and ARM instructions sets, or implemented if the Virtualization Extensions are included.[34]\n\nRegisters[edit]\n\nRegisters R0 through R7 are the same across all CPU modes; they are never banked.\n\nR13 and R14 are banked across all privileged CPU modes except system mode. That is, each mode that can be entered because of an exception has its own R13 and R14. These registers generally contain the stack pointer and the return address from function calls, respectively.\n\nRegisters across CPU modes usrsyssvcabtundirqfiq R0 R1 R2 R3 R4 R5 R6 R7 R8 R8_fiq R9 R9_fiq R10 R10_fiq R11 R11_fiq R12 R12_fiq R13 R13_svc R13_abt R13_und R13_irq R13_fiq R14 R14_svc R14_abt R14_und R14_irq R14_fiq R15 CPSR SPSR_svc SPSR_abt SPSR_und SPSR_irq SPSR_fiq\n\nAliases:\n\nR13 is also referred to as SP, the Stack Pointer.\n\nR14 is also referred to as LR, the Link Register.\n\nR15 is also referred to as PC, the Program Counter.\n\nCPSR has the following 32 bits.[35]\n\nM (bits 0–4) is the processor mode bits.\n\nT (bit 5) is the Thumb state bit.\n\nF (bit 6) is the FIQ disable bit.\n\nI (bit 7) is the IRQ disable bit.\n\nA (bit 8) is the imprecise data abort disable bit.\n\nE (bit 9) is the data endianness bit.\n\nIT (bits 10–15 and 25–26) is the if-then state bits.\n\nGE (bits 16–19) is the greater-than-or-equal-to bits.\n\nDNM (bits 20–23) is the do not modify bits.\n\nJ (bit 24) is the Java state bit.\n\nQ (bit 27) is the sticky overflow bit.\n\nV (bit 28) is the overflow bit.\n\nC (bit 29) is the carry/borrow/extend bit.\n\nZ (bit 30) is the zero bit.\n\nN (bit 31) is the negative/less than bit.\n\nConditional execution[edit]\n\nAlmost every ARM instruction has a conditional execution feature called predication, which is implemented with a 4-bit condition code selector (the predicate). To allow for unconditional execution, one of the four-bit codes causes the instruction to be always executed. Most other CPU architectures only have condition codes on branch instructions.\n\nThough the predicate takes up 4 of the 32 bits in an instruction code, and thus cuts down significantly on the encoding bits available for displacements in memory access instructions, it avoids branch instructions when generating code for small if statements. Apart from eliminating the branch instructions themselves, this preserves the fetch/decode/execute pipeline at the cost of only one cycle per skipped instruction.\n\nThe standard example of conditional execution is the subtraction-based Euclidean algorithm:\n\nIn the C programming language, the loop is:\n\nIn ARM assembly, the loop is:\n\nwhich avoids the branches around the then and else clauses. If Ri and Rj are equal then neither of the SUB instructions will be executed, eliminating the need for a conditional branch to implement the while check at the top of the loop, for example had SUBLE (less than or equal) been used.\n\nOne of the ways that Thumb code provides a more dense encoding is to remove the four bit selector from non-branch instructions.\n\nOther features[edit]\n\nAnother feature of the instruction set is the ability to fold shifts and rotates into the \"data processing\" (arithmetic, logical, and register-register move) instructions, so that, for example, the C statement\n\ncould be rendered as a single-word, single-cycle instruction:[36]\n\nThis results in the typical ARM program being denser than expected with fewer memory accesses; thus the pipeline is used more efficiently.\n\nThe ARM processor also has features rarely seen in other RISC architectures, such as PC-relative addressing (indeed, on the 32-bit[1] ARM the PC is one of its 16 registers) and pre- and post-increment addressing modes.\n\nThe ARM instruction set has increased over time. Some early ARM processors (before ARM7TDMI), for example, have no instruction to store a two-byte quantity.\n\nPipelines and other implementation issues[edit]\n\nThe ARM7 and earlier implementations have a three-stage pipeline; the stages being fetch, decode and execute. Higher-performance designs, such as the ARM9, have deeper pipelines: Cortex-A8 has thirteen stages. Additional implementation changes for higher performance include a faster adder and more extensive branch prediction logic. The difference between the ARM7DI and ARM7DMI cores, for example, was an improved multiplier; hence the added \"M\".\n\nCoprocessors[edit]\n\nThe ARM architecture provides a non-intrusive way of extending the instruction set using \"coprocessors\" that can be addressed using MCR, MRC, MRRC, MCRR, and similar instructions. The coprocessor space is divided logically into 16 coprocessors with numbers from 0 to 15, coprocessor 15 (cp15) being reserved for some typical control functions like managing the caches and MMU operation on processors that have one.\n\nIn ARM-based machines, peripheral devices are usually attached to the processor by mapping their physical registers into ARM memory space, into the coprocessor space, or by connecting to another device (a bus) that in turn attaches to the processor. Coprocessor accesses have lower latency, so some peripherals—for example an XScale interrupt controller—are accessible in both ways: through memory and through coprocessors.\n\nIn other cases, chip designers only integrate hardware using the coprocessor mechanism. For example, an image processing engine might be a small ARM7TDMI core combined with a coprocessor that has specialised operations to support a specific set of HDTV transcoding primitives.\n\nDebugging[edit]\n\nAll modern ARM processors include hardware debugging facilities, allowing software debuggers to perform operations such as halting, stepping, and breakpointing of code starting from reset. These facilities are built using JTAG support, though some newer cores optionally support ARM's own two-wire \"SWD\" protocol. In ARM7TDMI cores, the \"D\" represented JTAG debug support, and the \"I\" represented presence of an \"EmbeddedICE\" debug module. For ARM7 and ARM9 core generations, EmbeddedICE over JTAG was a de facto debug standard, though not architecturally guaranteed.\n\nThe ARMv7 architecture defines basic debug facilities at an architectural level. These include breakpoints, watchpoints and instruction execution in a \"Debug Mode\"; similar facilities were also available with EmbeddedICE. Both \"halt mode\" and \"monitor\" mode debugging are supported. The actual transport mechanism used to access the debug facilities is not architecturally specified, but implementations generally include JTAG support.\n\nThere is a separate ARM \"CoreSight\" debug architecture, which is not architecturally required by ARMv7 processors.\n\n[edit]\n\nThe ARM architecture is supported by a set of development tools such as Emprog ThunderBench for ARM. Such tools allow development engineers to program the ARM architecture device using a high level language like C.[37]\n\nDSP enhancement instructions[edit]\n\nTo improve the ARM architecture for digital signal processing and multimedia applications, DSP instructions were added to the set.[38] These are signified by an \"E\" in the name of the ARMv5TE and ARMv5TEJ architectures. E-variants also imply T,D,M and I.\n\nThe new instructions are common in digital signal processor architectures. They include variations on signed multiply–accumulate, saturated add and subtract, and count leading zeros.\n\nSIMD extensions for multimedia[edit]\n\nIntroduced in ARMv6 architecture.[39]\n\nJazelle[edit]\n\nMain article: Jazelle\n\nJazelle DBX (Direct Bytecode eXecution) is a technique that allows Java Bytecode to be executed directly in the ARM architecture as a third execution state (and instruction set) alongside the existing ARM and Thumb-mode. Support for this state is signified by the \"J\" in the ARMv5TEJ architecture, and in ARM9EJ-S and ARM7EJ-S core names. Support for this state is required starting in ARMv6 (except for the ARMv7-M profile), though newer cores only include a trivial implementation that provides no hardware acceleration.\n\nThumb[edit]\n\nTo improve compiled code-density, processors since the ARM7TDMI (released in 1994[40]) have featured Thumb instruction set, which have their own state. (The \"T\" in \"TDMI\" indicates the Thumb feature.) When in this state, the processor executes the Thumb instruction set, a compact 16-bit encoding for a subset of the ARM instruction set.[41] Most of the Thumb instructions are directly mapped to normal ARM instructions. The space-saving comes from making some of the instruction operands implicit and limiting the number of possibilities compared to the ARM instructions executed in the ARM instruction set state.\n\nIn Thumb, the 16-bit opcodes have less functionality. For example, only branches can be conditional, and many opcodes are restricted to accessing only half of all of the CPU's general-purpose registers. The shorter opcodes give improved code density overall, even though some operations require extra instructions. In situations where the memory port or bus width is constrained to less than 32 bits, the shorter Thumb opcodes allow increased performance compared with 32-bit ARM code, as less program code may need to be loaded into the processor over the constrained memory bandwidth.\n\nEmbedded hardware, such as the Game Boy Advance, typically have a small amount of RAM accessible with a full 32-bit datapath; the majority is accessed via a 16-bit or narrower secondary datapath. In this situation, it usually makes sense to compile Thumb code and hand-optimise a few of the most CPU-intensive sections using full 32-bit ARM instructions, placing these wider instructions into the 32-bit bus accessible memory.\n\nThe first processor with a Thumb instruction decoder was the ARM7TDMI. All ARM9 and later families, including XScale, have included a Thumb instruction decoder.\n\nThumb-2[edit]\n\nThumb-2 technology was introduced in the ARM1156 core, announced in 2003. Thumb-2 extends the limited 16-bit instruction set of Thumb with additional 32-bit instructions to give the instruction set more breadth, thus producing a variable-length instruction set. A stated aim for Thumb-2 was to achieve code density similar to Thumb with performance similar to the ARM instruction set on 32-bit memory. In ARMv7 this goal can be said to have been met.[citation needed]\n\nThumb-2 extends the Thumb instruction set with bit-field manipulation, table branches and conditional execution. At the same time, the ARM instruction set was extended to maintain equivalent functionality in both instruction sets. A new \"Unified Assembly Language\" (UAL) supports generation of either Thumb or ARM instructions from the same source code; versions of Thumb seen on ARMv7 processors are essentially as capable as ARM code (including the ability to write interrupt handlers). This requires a bit of care, and use of a new \"IT\" (if-then) instruction, which permits up to four successive instructions to execute based on a tested condition, or on its inverse. When compiling into ARM code this is ignored, but when compiling into Thumb it generates an actual instruction. For example:\n\nAll ARMv7 chips support the Thumb instruction set. All chips in the Cortex-A series, Cortex-R series, and ARM11 series support both \"ARM instruction set state\" and \"Thumb instruction set state\", while chips in the Cortex-M series support only the Thumb instruction set.[42][43][44]\n\nThumb Execution Environment (ThumbEE)[edit]\n\nThumbEE (erroneously called Thumb-2EE in some ARM documentation), marketed as Jazelle RCT (Runtime Compilation Target), was announced in 2005, first appearing in the Cortex-A8 processor. ThumbEE is a fourth Instruction set state, making small changes to the Thumb-2 extended Thumb instruction set. These changes make the instruction set particularly suited to code generated at runtime (e.g. by JIT compilation) in managed Execution Environments. ThumbEE is a target for languages such as Java, C#, Perl, and Python, and allows JIT compilers to output smaller compiled code without impacting performance.\n\nNew features provided by ThumbEE include automatic null pointer checks on every load and store instruction, an instruction to perform an array bounds check, and special instructions that call a handler. In addition, because it utilises Thumb-2 technology, ThumbEE provides access to registers r8-r15 (where the Jazelle/DBX Java VM state is held).[45] Handlers are small sections of frequently called code, commonly used to implement high level languages, such as allocating memory for a new object. These changes come from repurposing a handful of opcodes, and knowing the core is in the new ThumbEE Instruction set state.\n\nOn 23 November 2011, ARM Holdings deprecated any use of the ThumbEE instruction set,[46] and ARMv8 removes support for ThumbEE.\n\nFloating-point (VFP)[edit]\n\nVFP (Vector Floating Point) technology is an FPU coprocessor extension to the ARM architecture. It provides low-cost single-precision and double-precision floating-point computation fully compliant with the ANSI/IEEE Std 754-1985 Standard for Binary Floating-Point Arithmetic. VFP provides floating-point computation suitable for a wide spectrum of applications such as PDAs, smartphones, voice compression and decompression, three-dimensional graphics and digital audio, printers, set-top boxes, and automotive applications. The VFP architecture was intended to support execution of short \"vector mode\" instructions but these operated on each vector element sequentially and thus did not offer the performance of true single instruction, multiple data (SIMD) vector parallelism. This vector mode was therefore removed shortly after its introduction,[47] to be replaced with the much more powerful NEON Advanced SIMD unit.\n\nSome devices such as the ARM Cortex-A8 have a cut-down VFPLite module instead of a full VFP module, and require roughly ten times more clock cycles per float operation.[48] Other floating-point and/or SIMD coprocessors found in ARM-based processors include FPA, FPE, iwMMXt. They provide some of the same functionality as VFP but are not opcode-compatible with it.\n\nVFPv1\n\nObsolete.\n\nVFPv2\n\nAn optional extension to the ARM instruction set in the ARMv5TE, ARMv5TEJ and ARMv6 architectures.\n\nVFPv3 or VFPv3-D32\n\nImplemented on earlier ARMv7 processors (Cortex-A8 and A9) and is backwards compatible with VFPv2, except that it cannot trap floating-point exceptions. VFPv3 has 32x 64-bit FPU registers as standard, adds VCVT instructions to convert between scalar, float and double, adds immediate mode to VMOV such that constants can be loaded into FPU registers.\n\nVFPv3-D16\n\nAs above, but it has only 16 64-bit FPU registers.\n\nVFPv3-F16\n\nUncommon; it supports IEEE754-2008 half-precision (16-bit) floating point.\n\nVFPv4 or VFPv4-D32\n\nIs implemented on later ARMv7 processors (Cortex-A12 and A15). VFPv4 has 32x 64-bit FPU registers as standard, adds both half-precision extensions and fused multiply-accumulate instructions to the features of VFPv3.\n\nVFPv4-D16\n\nAs above, but it has only 16x 64-bit FPU registers. Implemented on Cortex-A5 and A7 processors.\n\nIn Debian Linux and derivatives armhf (ARM hard float) refers to the ARMv7 architecture including the additional VFP3-D16 floating-point hardware extension (and Thumb-2) above. Software packages and cross-compiler tools use the armhf vs. arm/armel suffixes to differentiate.[49]\n\nAdvanced SIMD (NEON)[edit]\n\nThe Advanced SIMD extension (aka NEON or \"MPE\" Media Processing Engine) is a combined 64- and 128-bit SIMD instruction set that provides standardized acceleration for media and signal processing applications. NEON is included in all Cortex-A8 devices but is optional in Cortex-A9 devices.[50] NEON can execute MP3 audio decoding on CPUs running at 10 MHz and can run the GSM adaptive multi-rate (AMR) speech codec at no more than 13 MHz. It features a comprehensive instruction set, separate register files and independent execution hardware.[51] NEON supports 8-, 16-, 32- and 64-bit integer and single-precision (32-bit) floating-point data and SIMD operations for handling audio and video processing as well as graphics and gaming processing. In NEON, the SIMD supports up to 16 operations at the same time. The NEON hardware shares the same floating-point registers as used in VFP. Devices such as the ARM Cortex-A8 and Cortex-A9 support 128-bit vectors but will execute with 64 bits at a time,[48] whereas newer Cortex-A15 devices can execute 128 bits at a time.\n\nProjectNe10 is ARM's first open source project (from its inception). The Ne10 library is a set of common, useful functions written in both NEON and C (for compatibility). The library was created to allow developers to use NEON optimizations without learning NEON but it also serves as a set of highly optimized NEON intrinsic and assembly code examples for common DSP, arithmetic and image processing routines. The code is available on GitHub.\n\nSecurity extensions (TrustZone)[edit]\n\nThe Security Extensions, marketed as TrustZone Technology, is in ARMv6KZ and later application profile architectures. It provides a low cost alternative to adding an additional dedicated security core to an SoC, by providing two virtual processors backed by hardware based access control. This lets the application core switch between two states, referred to as worlds (to reduce confusion with other names for capability domains), in order to prevent information from leaking from the more trusted world to the less trusted world. This world switch is generally orthogonal to all other capabilities of the processor, thus each world can operate independently of the other while using the same core. Memory and peripherals are then made aware of the operating world of the core and may use this to provide access control to secrets and code on the device.\n\nTypical applications of TrustZone Technology are to run a rich operating system in the less trusted world, and smaller security-specialized code in the more trusted world (named TrustZone Software, a TrustZone optimised version of the Trusted Foundations Software developed by Trusted Logic Mobility), allowing much tighter digital rights management for controlling the use of media on ARM-based devices,[52] and preventing any unapproved use of the device. Trusted Foundations Software was acquired by Gemalto. Giesecke & Devrient developed a rival implementation named Mobicore. In April 2012 ARM Gemalto and Giesecke & Devrient combined their TrustZone portfolios into a joint venture Trustonic.[53][54] Open Virtualization is an open source implementation of the trusted world architecture for TrustZone.[55]\n\nIn practice, since the specific implementation details of TrustZone are proprietary and have not been publicly disclosed for review, it is unclear what level of assurance is provided for a given threat model.[citation needed]\n\nNo-execute page protection[edit]\n\nAs of ARMv6, the ARM architecture supports no-execute page protection, which is referred to as XN, for eXecute Never.[56]\n\nARMv8-R[edit]\n\nThe ARMv8-R subarchitecture announced after the ARMv8-A shares some features except that it is not 64-bit.\n\n64/32-bit architecture[edit]\n\nARMv8-A[edit]\n\nAnnounced in October 2011,[57] ARMv8-A (often called ARMv8 although not all variants are 64-bit such as ARMv8-R) represents a fundamental change to the ARM architecture. It adds a 64-bit architecture, named \"AArch64\", and a new \"A64\" instruction set. AArch64 provides user-space compatibility with ARMv7-A ISA, the 32-bit architecture, therein referred to as \"AArch32\" and the old 32-bit instruction set, now named \"A32\". The Thumb instruction sets are referred to as \"T32\" and have no 64-bit counterpart. ARMv8-A allows 32-bit applications to be executed in a 64-bit OS, and a 32-bit OS to be under the control of a 64-bit hypervisor.[1] ARM announced their Cortex-A53 and Cortex-A57 cores on 30 October 2012.[22]\n\nTo both AArch32 and AArch64, ARMv8-A makes VFPv3/v4 and advanced SIMD (NEON) standard. It also adds cryptography instructions supporting AES and SHA-1/SHA-256.\n\nAArch64 features[edit]\n\nNew instruction set, A64\n\nHas 31 general-purpose 64-bit registers.\n\nHas separate dedicated SP and PC.\n\nInstructions are still 32 bits long and mostly the same as A32 (with LDM/STM instructions and most conditional execution dropped).\n\nHas paired loads/stores (in place of LDM/STM).\n\nMost instructions can take 32-bit or 64-bit arguments.\n\nAddresses assumed to be 64-bit.\n\nAdvanced SIMD (NEON) enhanced\n\nHas 32× 128-bit registers (up from 16), also accessible via VFPv4.\n\nSupports double-precision floating point.\n\nFully IEEE 754 compliant\n\nAES encrypt/decrypt and SHA-1/SHA-2 hashing instructions also use these registers.\n\nA new exception system\n\nFewer banked registers and modes.\n\nMemory translation from 48-bit virtual addresses based on the existing LPAE, which was designed to be easily extended to 64-bit.\n\nOperating system support[edit]\n\n32-bit operating systems[edit]\n\nHistorical operating systems\n\nThe first ARM-based personal computer, the Acorn Archimedes, ran an interim operating system called Arthur, which evolved into RISC OS, used on later ARM-based systems from Acorn and other vendors. Some Acorn machines also had a Unix port called RISC iX.\n\nEmbedded operating systems\n\nThe ARM architecture is supported by a large number of embedded and real-time operating systems, including Linux, Windows CE,Symbian, ChibiOS/RT, FreeRTOS, eCos, Integrity, Nucleus PLUS, MicroC/OS-II, PikeOS,[58] QNX, RTEMS, RTXC Quadros, ThreadX,VxWorks, DRYOS, MQX, T-Kernel, OSE, SCIOPTA and RISC OS.\n\nMobile device operating systems\n\nThe ARM architecture is the primary hardware environment for most mobile device operating systems such as iOS, Android, Windows Phone, Windows RT, Bada, Blackberry OS/Blackberry 10, MeeGo, Firefox OS, Tizen, Ubuntu Touch, Sailfish and Igelle OS.\n\nDesktop operating systems\n\nThe ARM architecture is supported by RISC OS and multiple Unix-like operating systems including BSD and various Linux distributions such as Ubuntu and Chrome OS.\n\n64-bit operating systems[edit]\n\nMobile device operating systems\n\niOS 7 on the 64-bit Apple A7 SOC has ARMv8-A application support.\n\nDesktop operating systems\n\nPatches to the Linux kernel adding ARMv8-A support have been posted for review by Catalin Marinas of ARM Ltd. The patches have been included in kernel version 3.7 in late 2012.[59] ARMv8-A is supported by some Linux distributions.\n\nSee also[edit]\n\nARM big.LITTLE, ARM's heterogeneous computing architecture\n\nARM Accredited Engineer certification program\n\nARMulator\n\nComparison of current ARM cores\n\nAmber (processor core), an open-source ARM-compatible processor core\n\nAMULET microprocessor, an asynchronous implementation of the ARM architecture"
    }
}