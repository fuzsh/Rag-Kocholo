{
    "id": "dbpedia_1549_0",
    "rank": 91,
    "data": {
        "url": "https://docs.zephyrproject.org/latest/hardware/peripherals/pwm.html",
        "read_more_link": "",
        "language": "en",
        "title": "Pulse Width Modulation (PWM) — Zephyr Project Documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.zephyrproject.org/latest/_static/logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "../../_static/favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://docs.zephyrproject.org/latest/hardware/peripherals/pwm.html",
        "text": "Static initializer for a struct pwm_dt_spec.\n\nThis returns a static initializer for a struct pwm_dt_spec given a devicetree node identifier and an index.\n\nExample devicetree fragment:\n\nn:node{ pwms=<&pwm111000PWM_POLARITY_NORMAL>, <&pwm232000PWM_POLARITY_INVERTED>; pwm-names=\"alpha\",\"beta\"; };\n\nExample usage:\n\nconststructpwm_dt_specspec= PWM_DT_SPEC_GET_BY_NAME(DT_NODELABEL(n),alpha); // Initializes 'spec' to: // { // .dev = DEVICE_DT_GET(DT_NODELABEL(pwm1)), // .channel = 1, // .period = 1000, // .flags = PWM_POLARITY_NORMAL, // }\n\nThe device (dev) must still be checked for readiness, e.g. using device_is_ready(). It is an error to use this macro unless the node exists, has the âpwmsâ property, and that âpwmsâ property specifies a PWM controller, a channel, a period in nanoseconds and optionally flags.\n\nParameters:\n\nnode_id â Devicetree node identifier.\n\nname â Lowercase-and-underscores name of a pwms element as defined by the nodeâs pwm-names property.\n\nReturns:\n\nStatic initializer for a struct pwm_dt_spec for the property.\n\nLike PWM_DT_SPEC_GET_BY_NAME(), with a fallback to a default value.\n\nIf the devicetree node identifier ânode_idâ refers to a node with a property âpwmsâ, this expands to PWM_DT_SPEC_GET_BY_NAME(node_id, name). The default_value parameter is not expanded in this case. Otherwise, this expands to default_value.\n\nParameters:\n\nnode_id â Devicetree node identifier.\n\nname â Lowercase-and-underscores name of a pwms element as defined by the nodeâs pwm-names property\n\ndefault_value â Fallback value to expand to.\n\nReturns:\n\nStatic initializer for a struct pwm_dt_spec for the property, or default_value if the node or property do not exist.\n\nStatic initializer for a struct pwm_dt_spec.\n\nThis returns a static initializer for a struct pwm_dt_spec given a devicetree node identifier and an index.\n\nExample devicetree fragment:\n\nn:node{ pwms=<&pwm111000PWM_POLARITY_NORMAL>, <&pwm232000PWM_POLARITY_INVERTED>; };\n\nExample usage:\n\nconststructpwm_dt_specspec= PWM_DT_SPEC_GET_BY_IDX(DT_NODELABEL(n),1); // Initializes 'spec' to: // { // .dev = DEVICE_DT_GET(DT_NODELABEL(pwm2)), // .channel = 3, // .period = 2000, // .flags = PWM_POLARITY_INVERTED, // }\n\nThe device (dev) must still be checked for readiness, e.g. using device_is_ready(). It is an error to use this macro unless the node exists, has the âpwmsâ property, and that âpwmsâ property specifies a PWM controller, a channel, a period in nanoseconds and optionally flags.\n\nParameters:\n\nnode_id â Devicetree node identifier.\n\nidx â Logical index into âpwmsâ property.\n\nReturns:\n\nStatic initializer for a struct pwm_dt_spec for the property.\n\nLike PWM_DT_SPEC_GET_BY_IDX(), with a fallback to a default value.\n\nIf the devicetree node identifier ânode_idâ refers to a node with a property âpwmsâ, this expands to PWM_DT_SPEC_GET_BY_IDX(node_id, idx). The default_value parameter is not expanded in this case. Otherwise, this expands to default_value.\n\nParameters:\n\nnode_id â Devicetree node identifier.\n\nidx â Logical index into âpwmsâ property.\n\ndefault_value â Fallback value to expand to.\n\nReturns:\n\nStatic initializer for a struct pwm_dt_spec for the property, or default_value if the node or property do not exist.\n\nSet the period and pulse width for a single PWM output.\n\nThe PWM period and pulse width will synchronously be set to the new values without glitches in the PWM signal, but the call will not block for the change to take effect.\n\nPassing 0 as pulse will cause the pin to be driven to a constant inactive level. Passing a non-zero pulse equal to period will cause the pin to be driven to a constant active level.\n\nNote\n\nNot all PWM controllers support synchronous, glitch-free updates of the PWM period and pulse width. Depending on the hardware, changing the PWM period and/or pulse width may cause a glitch in the generated PWM signal.\n\nNote\n\nSome multi-channel PWM controllers share the PWM period across all channels. Depending on the hardware, changing the PWM period for one channel may affect the PWM period for the other channels of the same PWM controller.\n\nParameters:\n\ndev â [in] PWM device instance.\n\nchannel â PWM channel.\n\nperiod â Period (in clock cycles) set to the PWM. HW specific.\n\npulse â Pulse width (in clock cycles) set to the PWM. HW specific.\n\nflags â Flags for pin configuration.\n\nReturn values:\n\n0 â If successful.\n\n-EINVAL â If pulse > period.\n\n-errno â Negative errno code on failure.\n\nConfigure PWM period/pulse width capture for a single PWM input.\n\nAfter configuring PWM capture using this function, the capture can be enabled/disabled using pwm_enable_capture() and pwm_disable_capture().\n\nNote\n\nThis API function cannot be invoked from user space due to the use of a function callback. In user space, one of the simpler API functions (pwm_capture_cycles(), pwm_capture_usec(), or pwm_capture_nsec()) can be used instead.\n\nNote\n\nCONFIG_PWM_CAPTURE must be selected for this function to be available.\n\nParameters:\n\ndev â [in] PWM device instance.\n\nchannel â PWM channel.\n\nflags â PWM capture flags\n\ncb â [in] Application callback handler function to be called upon capture\n\nuser_data â [in] User data to pass to the application callback handler function\n\nReturn values:\n\n-EINVAL â if invalid function parameters were given\n\n-ENOSYS â if PWM capture is not supported or the given flags are not supported\n\n-EIO â if IO error occurred while configuring\n\n-EBUSY â if PWM capture is already in progress\n\nCapture a single PWM period/pulse width in clock cycles for a single PWM input.\n\nThis API function wraps calls to pwm_configure_capture(), pwm_enable_capture(), and pwm_disable_capture() and passes the capture result to the caller. The function is blocking until either the PWM capture is completed or a timeout occurs.\n\nNote\n\nCONFIG_PWM_CAPTURE must be selected for this function to be available.\n\nParameters:\n\ndev â [in] PWM device instance.\n\nchannel â PWM channel.\n\nflags â PWM capture flags.\n\nperiod â [out] Pointer to the memory to store the captured PWM period width (in clock cycles). HW specific.\n\npulse â [out] Pointer to the memory to store the captured PWM pulse width (in clock cycles). HW specific.\n\ntimeout â Waiting period for the capture to complete.\n\nReturn values:\n\n0 â If successful.\n\n-EBUSY â PWM capture already in progress.\n\n-EAGAIN â Waiting period timed out.\n\n-EIO â IO error while capturing.\n\n-ERANGE â If result is too large.\n\nCapture a single PWM period/pulse width in microseconds for a single PWM input.\n\nThis API function wraps calls to pwm_capture_cycles() and pwm_cycles_to_usec() and passes the capture result to the caller. The function is blocking until either the PWM capture is completed or a timeout occurs.\n\nNote\n\nCONFIG_PWM_CAPTURE must be selected for this function to be available.\n\nParameters:\n\ndev â [in] PWM device instance.\n\nchannel â PWM channel.\n\nflags â PWM capture flags.\n\nperiod â [out] Pointer to the memory to store the captured PWM period width (in usec).\n\npulse â [out] Pointer to the memory to store the captured PWM pulse width (in usec).\n\ntimeout â Waiting period for the capture to complete.\n\nReturn values:\n\n0 â If successful.\n\n-EBUSY â PWM capture already in progress.\n\n-EAGAIN â Waiting period timed out.\n\n-EIO â IO error while capturing.\n\n-ERANGE â If result is too large.\n\n-errno â Other negative errno code on failure.\n\nCapture a single PWM period/pulse width in nanoseconds for a single PWM input.\n\nThis API function wraps calls to pwm_capture_cycles() and pwm_cycles_to_nsec() and passes the capture result to the caller. The function is blocking until either the PWM capture is completed or a timeout occurs.\n\nNote\n\nCONFIG_PWM_CAPTURE must be selected for this function to be available.\n\nParameters:\n\ndev â [in] PWM device instance.\n\nchannel â PWM channel.\n\nflags â PWM capture flags.\n\nperiod â [out] Pointer to the memory to store the captured PWM period width (in nsec).\n\npulse â [out] Pointer to the memory to store the captured PWM pulse width (in nsec).\n\ntimeout â Waiting period for the capture to complete.\n\nReturn values:\n\n0 â If successful.\n\n-EBUSY â PWM capture already in progress.\n\n-EAGAIN â Waiting period timed out.\n\n-EIO â IO error while capturing.\n\n-ERANGE â If result is too large.\n\n-errno â Other negative errno code on failure."
    }
}