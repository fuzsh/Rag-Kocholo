{
    "id": "dbpedia_1403_3",
    "rank": 30,
    "data": {
        "url": "https://docs.flutter.dev/platform-integration/platform-channels",
        "read_more_link": "",
        "language": "en",
        "title": "Writing custom platform-specific code",
        "top_image": "https://docs.flutter.dev/assets/images/flutter-logo-sharing.png",
        "meta_img": "https://docs.flutter.dev/assets/images/flutter-logo-sharing.png",
        "images": [
            "https://docs.flutter.dev/assets/images/branding/flutter/logo+text/horizontal/default.svg",
            "https://docs.flutter.dev/assets/images/docs/PlatformChannels.png",
            "https://docs.flutter.dev/assets/images/branding/flutter/logo/flutter-mono-81x100.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Learn how to write custom platform-specific code in your app.",
        "meta_lang": "en",
        "meta_favicon": "/assets/images/branding/flutter/icon/64.png",
        "meta_site_name": "",
        "canonical_link": "https://docs.flutter.dev/platform-integration/platform-channels",
        "text": "This guide describes how to write custom platform-specific code. Some platform-specific functionality is available through existing packages; see using packages.\n\nFlutter uses a flexible system that allows you to call platform-specific APIs in a language that works directly with those APIs:\n\nKotlin or Java on Android\n\nSwift or Objective-C on iOS\n\nC++ on Windows\n\nObjective-C on macOS\n\nC on Linux\n\nFlutter's builtin platform-specific API support doesn't rely on code generation, but rather on a flexible message passing style. Alternatively, you can use the Pigeon package for sending structured typesafe messages with code generation:\n\nThe Flutter portion of the app sends messages to its host, the non-Dart portion of the app, over a platform channel.\n\nThe host listens on the platform channel, and receives the message. It then calls into any number of platform-specific APIs—using the native programming language—and sends a response back to the client, the Flutter portion of the app.\n\nArchitectural overview: platform channels\n\n#\n\nMessages are passed between the client (UI) and host (platform) using platform channels as illustrated in this diagram:\n\nMessages and responses are passed asynchronously, to ensure the user interface remains responsive.\n\nOn the client side, MethodChannel enables sending messages that correspond to method calls. On the platform side, MethodChannel on Android (MethodChannelAndroid) and FlutterMethodChannel on iOS (MethodChanneliOS) enable receiving method calls and sending back a result. These classes allow you to develop a platform plugin with very little 'boilerplate' code.\n\nPlatform channel data types support and codecs\n\n#\n\nThe standard platform channels use a standard message codec that supports efficient binary serialization of simple JSON-like values, such as booleans, numbers, Strings, byte buffers, and Lists and Maps of these (see StandardMessageCodec for details). The serialization and deserialization of these values to and from messages happens automatically when you send and receive values.\n\nThe following table shows how Dart values are received on the platform side and vice versa:\n\nExample: Calling platform-specific code using platform channels\n\n#\n\nThe following code demonstrates how to call a platform-specific API to retrieve and display the current battery level. It uses the Android BatteryManager API, the iOS device.batteryLevel API, the Windows GetSystemPowerStatus API, and the Linux UPower API with a single platform message, getBatteryLevel().\n\nThe example adds the platform-specific code inside the main app itself. If you want to reuse the platform-specific code for multiple apps, the project creation step is slightly different (see developing packages), but the platform channel code is still written in the same way.\n\nStep 1: Create a new app project\n\n#\n\nStart by creating a new app:\n\nIn a terminal run: flutter create batterylevel\n\nBy default, our template supports writing Android code using Kotlin, or iOS code using Swift. To use Java or Objective-C, use the -i and/or -a flags:\n\nIn a terminal run: flutter create -i objc -a java batterylevel\n\nStep 2: Create the Flutter platform client\n\n#\n\nThe app's State class holds the current app state. Extend that to hold the current battery state.\n\nFirst, construct the channel. Use a MethodChannel with a single platform method that returns the battery level.\n\nThe client and host sides of a channel are connected through a channel name passed in the channel constructor. All channel names used in a single app must be unique; prefix the channel name with a unique 'domain prefix', for example: samples.flutter.dev/battery.\n\nNext, invoke a method on the method channel, specifying the concrete method to call using the String identifier getBatteryLevel. The call might fail—for example, if the platform doesn't support the platform API (such as when running in a simulator), so wrap the invokeMethod call in a try-catch statement.\n\nUse the returned result to update the user interface state in _batteryLevel inside setState.\n\nFinally, replace the build method from the template to contain a small user interface that displays the battery state in a string, and a button for refreshing the value.\n\nStep 3: Add an Android platform-specific implementation\n\n#\n\nYou should now be able to run the app on Android. If using the Android Emulator, set the battery level in the Extended Controls panel accessible from the ... button in the toolbar.\n\nStep 4: Add an iOS platform-specific implementation\n\n#\n\nYou should now be able to run the app on iOS. If using the iOS Simulator, note that it doesn't support battery APIs, and the app displays 'Battery level not available'.\n\nStep 5: Add a Windows platform-specific implementation\n\n#\n\nStart by opening the Windows host portion of your Flutter app in Visual Studio:\n\nRun flutter build windows in your project directory once to generate the Visual Studio solution file.\n\nStart Visual Studio.\n\nSelect Open a project or solution.\n\nNavigate to the directory holding your Flutter app, then into the build folder, then the windows folder, then select the batterylevel.sln file. Click Open.\n\nAdd the C++ implementation of the platform channel method:\n\nExpand batterylevel > Source Files in the Solution Explorer.\n\nOpen the file flutter_window.cpp.\n\nFirst, add the necessary includes to the top of the file, just after #include \"flutter_window.h\":\n\nEdit the FlutterWindow::OnCreate method and create a flutter::MethodChannel tied to the channel name samples.flutter.dev/battery:\n\nNext, add the C++ code that uses the Windows battery APIs to retrieve the battery level. This code is exactly the same as you would write in a native Windows application.\n\nAdd the following as a new function at the top of flutter_window.cpp just after the #include section:\n\nFinally, complete the setMethodCallHandler() method added earlier. You need to handle a single platform method, getBatteryLevel(), so test for that in the call argument. The implementation of this platform method calls the Windows code written in the previous step. If an unknown method is called, report that instead.\n\nRemove the following code:\n\nAnd replace with the following:\n\nYou should now be able to run the application on Windows. If your device doesn't have a battery, it displays 'Battery level not available'.\n\nStep 6: Add a macOS platform-specific implementation\n\n#\n\nStart by opening the macOS host portion of your Flutter app in Xcode:\n\nStart Xcode.\n\nSelect the menu item File > Open....\n\nNavigate to the directory holding your Flutter app, and select the macos folder inside it. Click OK.\n\nAdd the Swift implementation of the platform channel method:\n\nExpand Runner > Runner in the Project navigator.\n\nOpen the file MainFlutterWindow.swift located under Runner > Runner in the Project navigator.\n\nFirst, add the necessary import to the top of the file, just after import FlutterMacOS:\n\nCreate a FlutterMethodChannel tied to the channel name samples.flutter.dev/battery in the awakeFromNib method:\n\nNext, add the macOS Swift code that uses the IOKit battery APIs to retrieve the battery level. This code is exactly the same as you would write in a native macOS app.\n\nAdd the following as a new method at the bottom of MainFlutterWindow.swift:\n\nFinally, complete the setMethodCallHandler method added earlier. You need to handle a single platform method, getBatteryLevel(), so test for that in the call argument. The implementation of this platform method calls the macOS code written in the previous step. If an unknown method is called, report that instead.\n\nYou should now be able to run the application on macOS. If your device doesn't have a battery, it displays 'Battery level not available'.\n\nStep 7: Add a Linux platform-specific implementation\n\n#\n\nFor this example you need to install the upower developer headers. This is likely available from your distribution, for example with:\n\nStart by opening the Linux host portion of your Flutter app in the editor of your choice. The instructions below are for Visual Studio Code with the \"C/C++\" and \"CMake\" extensions installed, but can be adjusted for other IDEs.\n\nLaunch Visual Studio Code.\n\nOpen the linux directory inside your project.\n\nChoose Yes in the prompt asking: Would you like to configure project \"linux\"?. This enables C++ autocomplete.\n\nOpen the file my_application.cc.\n\nFirst, add the necessary includes to the top of the file, just after #include <flutter_linux/flutter_linux.h:\n\nAdd an FlMethodChannel to the _MyApplication struct:\n\nMake sure to clean it up in my_application_dispose:\n\nEdit the my_application_activate method and initialize battery_channel using the channel name samples.flutter.dev/battery, just after the call to fl_register_plugins:\n\nNext, add the C code that uses the Linux battery APIs to retrieve the battery level. This code is exactly the same as you would write in a native Linux application.\n\nAdd the following as a new function at the top of my_application.cc just after the G_DEFINE_TYPE line:\n\nFinally, add the battery_method_call_handler function referenced in the earlier call to fl_method_channel_set_method_call_handler. You need to handle a single platform method, getBatteryLevel, so test for that in the method_call argument. The implementation of this function calls the Linux code written in the previous step. If an unknown method is called, report that instead.\n\nAdd the following code after the get_battery_level function:\n\nYou should now be able to run the application on Linux. If your device doesn't have a battery, it displays 'Battery level not available'.\n\nTypesafe platform channels using Pigeon\n\n#\n\nThe previous example uses MethodChannel to communicate between the host and client, which isn't typesafe. Calling and receiving messages depends on the host and client declaring the same arguments and datatypes in order for messages to work. You can use the Pigeon package as an alternative to MethodChannel to generate code that sends messages in a structured, typesafe manner.\n\nWith Pigeon, the messaging protocol is defined in a subset of Dart that then generates messaging code for Android, iOS, macOS, or Windows. You can find a more complete example and more information on the pigeon page on pub.dev.\n\nUsing Pigeon eliminates the need to match strings between host and client for the names and datatypes of messages. It supports: nested classes, grouping messages into APIs, generation of asynchronous wrapper code and sending messages in either direction. The generated code is readable and guarantees there are no conflicts between multiple clients of different versions. Supported languages are Objective-C, Java, Kotlin, C++, and Swift (with Objective-C interop).\n\nPigeon example\n\n#\n\nPigeon file:\n\nDart usage:\n\nSeparate platform-specific code from UI code\n\n#\n\nIf you expect to use your platform-specific code in multiple Flutter apps, you might consider separating the code into a platform plugin located in a directory outside your main application. See developing packages for details.\n\nPublish platform-specific code as a package\n\n#\n\nTo share your platform-specific code with other developers in the Flutter ecosystem, see publishing packages.\n\nCustom channels and codecs\n\n#\n\nBesides the above mentioned MethodChannel, you can also use the more basic BasicMessageChannel, which supports basic, asynchronous message passing using a custom message codec. You can also use the specialized BinaryCodec, StringCodec, and JSONMessageCodec classes, or create your own codec.\n\nYou might also check out an example of a custom codec in the cloud_firestore plugin, which is able to serialize and deserialize many more types than the default types.\n\nChannels and platform threading\n\n#\n\nWhen invoking channels on the platform side destined for Flutter, invoke them on the platform's main thread. When invoking channels in Flutter destined for the platform side, either invoke them from any Isolate that is the root Isolate, or that is registered as a background Isolate. The handlers for the platform side can execute on the platform's main thread or they can execute on a background thread if using a Task Queue. You can invoke the platform side handlers asynchronously and on any thread.\n\nUsing plugins and channels from background isolates\n\n#\n\nPlugins and channels can be used by any Isolate, but that Isolate has to be a root Isolate (the one created by Flutter) or registered as a background Isolate for a root Isolate.\n\nThe following example shows how to register a background Isolate in order to use a plugin from a background Isolate.\n\nExecuting channel handlers on background threads\n\n#\n\nIn order for a channel's platform side handler to execute on a background thread, you must use the Task Queue API. Currently, this feature is only supported on iOS and Android.\n\nIn Kotlin:\n\nIn Java:\n\nIn Swift:\n\nIn Objective-C:\n\nJumping to the UI thread in Android\n\n#\n\nTo comply with channels' UI thread requirement, you might need to jump from a background thread to Android's UI thread to execute a channel method. In Android, you can accomplish this by post()ing a Runnable to Android's UI thread Looper, which causes the Runnable to execute on the main thread at the next opportunity.\n\nIn Kotlin:\n\nIn Java:\n\nJumping to the main thread in iOS\n\n#\n\nTo comply with channel's main thread requirement, you might need to jump from a background thread to iOS's main thread to execute a channel method. You can accomplish this in iOS by executing a block on the main dispatch queue:\n\nIn Objective-C:\n\nIn Swift:"
    }
}