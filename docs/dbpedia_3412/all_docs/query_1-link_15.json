{
    "id": "dbpedia_3412_1",
    "rank": 15,
    "data": {
        "url": "http://lambda-the-ultimate.org/classic/message4891.html",
        "read_more_link": "",
        "language": "en",
        "title": "LtU Classic Archives",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://lambda-the-ultimate.org/classic/folder2.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif",
            "http://lambda-the-ultimate.org/classic/leftArrow.gif",
            "http://lambda-the-ultimate.org/classic/skull.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Do languages matter? Definitely, in my experience. Is it only source-code volume? Perhaps. There is certainly a correlation. It becomes difficult to deal with masses of source code, but with a powerful enough language you should be able to build enough abstraction layers that you raise the language to the level where the real work is done using a concise notation.\n\nSpecific complaints/comments about the paper:\n\n- First he says \" It is a very difficult argument to claim that the best way to organize expensive slow cycles is also the best way to organize cheap fast ones\" and then complains \"meeanwhile burning cycles by the bushel in the name of optimization\". So are cycles cheap or not? BTW, the C++ compile time problem is unique to that language.\n\n- C++ doesn't support threads or serialization. Well, that's not a strike against OO.\n\n- \"OOP Claims Unmasked\" He argues that domain specific languages perform better in their domain, and code reuse is hard. These are valid complaints. OOP is certainly not the last word in modularity. Recent research into units and staged evaluation has created systems where you can compose language layers and evaluation times. This is incredibly powerful and its possible that doing so can provide the abstractions to build the type of modularity the author is asking for.\n\nwith a powerful enough language you should be able to build enough abstraction layers that you raise the language to the level where the real work is done using a concise notation Thus reducing source-code volume. If we take that as given, what else is important in reducing source-code volume, and what else apart from source-code volume matters?\n\nQuality of code libraries? Specific techniques for composing behaviour? Functional composition vs implementation inheritance vs component interfaces (as-if it were an either-or choice!).\n\nWhat else matters? - Modularity. research into units and staged evaluation Sounds interesting! Please recommend some online reading.\n\nSpecific complaints/comments about the paper The theme of the paper seems to be - OOP is not a silver bullet. I find that hard to disagree with but not very interesting. More interesting would be - is OOP (or technology X) a better or worse bullet than Y, and specifically why?\n\nYou may enjoy his slides (there are available from his web site).\n\nI agree with the basic argument, but let's not take it too far. First of all, language research and language design are two different things. Good language design (esp. DSL design) is about problem domain abstractions. Thinking about these, is really not the job of programming language theorists.\n\nSecond, it is a bit extreme to say that the languages mentioned were not influenced by current thinking. Python, for example, has several language constructs that come from functional programming. Java was influenced by OOP (obviously) and OOP research (e.g., why choose single inheritance over multiple inheritance? Why work so hard to add genericity to the language?)\n\nAnd oh, all this has very little to do with reducing code size. Sure, when you raise the abstraction level of the language, the amount of code is reduced, but this is a very indirect and unreliable indicator.\n\nI did enjoy the slides and the presentation. More about that later.\n\n\"Do languages matter?\" I was hoping this extreme silly question was so open that it could go off in unforeseen directions. Do languages matter more than intelligent design? More than code libraries? More than...? What matters about languages?\n\nSo paraphrasing from one of the comments at LL2 it matters that a capability is in the language rather than in a code library because that changes the way programmers think about the problem.\n\nAnd oh, all this has very little to do with reducing code size Maybe we are just looking at the same thing from different directions. Source-code volume by itself makes programming complicated. We can address that by raising the abstraction level of language constructs. I'm looking at source-code volume as a fundamental problem not an \"indicator\"; it consumes brainpower so designing a language to encourage concise code should be a fundamental goal (Matz' LL2 Ruby talk). Wondering about the ways in which I find Java more painful than Smalltalk, reminded me how much more \"stuff\" you have to write/read/understand/debug in Java (language tithe?).\n\na bit extreme to say that the languages mentioned were not influenced by current thinking Much more extreme than that! The message was that it simply didn't matter - the languages became \"successful\" for a different reason, the introduction of a disruptive technology. Does the Java story support that premise? What I read is that Oak had been around for years, being used in a limited way on various projects. Then came web browsers and Two Demos That Changed The World - the introduction of a disruptive technology.\n\nOne of the amusing things about individual programming languages is that we choose to hold-tight their identity, after all manner of additions and mutations. Will we reach the point where different languages have more in common with each other, than they do with the original language spec?\n\nwhy choose single inheritance over multiple inheritance? After that long-winded introduction, one way to answer this is to look at the Oak spec: p18 \"Interfaces solve some of the same problems that multiple inheritance does without as much overhead at runtime.\" And to look at the histories \"The concepts of multiple-inheritance and operator overloading were identified as sources of potential errors, and eliminated in Oak.\" Was that the result of OOP Research or simply experience with C++?\n\nJava was influenced by OOP (obviously) Are we making a mistake to think Java was originally anything more than a variation on C++? \"His extensions and modifications to C++ (also know as C++ ++ --), were the first steps towards the development of an independent language\". OOP was already part of the cloth from which Java was cut.\n\nadd genericity to the language? I think this shows how little they were influenced by OOP research! Weren't generics part of Modula-3 before Oak existed?\n\nMaybe it's just that my perspective is that of a programming language user not a programming language designer?\n\nI am talking as a language user.\n\nSee, I agree that you can have disruptive language technologies. They don't even have to be particularly new in order to be disruptive. Java helped many programmer think about mobile code, simply by utilizing the very old concept of \"virtual machine.\"\n\nWhat I want to see is how the specific ideas discussed at the end of the talk would effect my programming. Would it be enough to get me to switch langugaes? I am not sure.\n\nBecause as a language user I think these crucial language features that make you want to switch, seem small but have great impact. Things like the subtle difference between lexical and dynamic scoping. Or template specialization.\n\nNot huge features that are problem domain specific, and don't really influence or interact with the rest of language, like CSP.\n\nNow parsing facilites would make a nice addition, but as I said - it's already here. Check Perl6, and modern macro facilities.\n\nNot everything that helps you think about programming is, or should be, part of the language. What kinds of thing are you thinking of?\n\nlanguage features that make you want to switch Let me suggest that your interest in programming languages makes you unrepresentative. Let me suggest that most programming is dominated by clichéd domain activities - pushing data from database to ui and back again, managing user sessions, blah blah... Give a better way to express solutions for those activities and they'll take functional programming as-part-of-the-package and learn to love it (later) ;-)\n\ndon't really influence or interact with the rest of language, like CSP I've never thought about what a good language-neutral CSP library would be like: I have to trust his judgement on that. Give me a way to express constraints on values in my programming language, and for a while everything will be a constraint satisfaction problem ;-)\n\nPerl6, and modern macro facilities You missed the smiley! Isn't this a reference to the repeated LL2 jokes on perl regular expressions and mit macros ;-)\n\nHow would you characterize Mozart/Oz? A single language? Several DSLs built on top of a core language?"
    }
}