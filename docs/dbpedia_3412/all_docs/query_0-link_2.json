{
    "id": "dbpedia_3412_0",
    "rank": 2,
    "data": {
        "url": "https://encode.su/threads/232-Lisaac-programming-language",
        "read_more_link": "",
        "language": "en",
        "title": "Lisaac programming language",
        "top_image": "https://encode.su/threads/favicon-16.png",
        "meta_img": "https://encode.su/threads/favicon-16.png",
        "images": [
            "https://encode.su/threads/images/misc/navbit-home.png",
            "https://encode.su/threads/images/statusicon/user-offline.png",
            "https://encode.su/threads/images/misc/progress.gif",
            "https://encode.su/threads/clear.gif",
            "https://encode.su/threads/images/buttons/collapse_40b.png",
            "https://encode.su/cron.php?s=8a61d5f63317f50a21d8ceba06f27bd2&rand=1723535544"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "lisaac",
            "code",
            "compiler",
            "language",
            "sather",
            "programming",
            "features",
            "design",
            "system",
            "contract",
            "eiffel",
            "berkeley",
            "format",
            "time",
            "goals",
            "university",
            "prototype-based",
            "type",
            "fast",
            "size",
            "faster",
            "memory",
            "static",
            "object-oriented",
            "based",
            "dynamic",
            "inheritance",
            "line",
            "typing",
            "version",
            "binary",
            "integration",
            "include",
            "objective",
            "multiple",
            "written",
            "compilation",
            "ides",
            "license",
            "options",
            "clang",
            "compiled",
            "languages",
            "functional",
            "takes",
            "international",
            "implementation",
            "source",
            "object",
            "explain"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Lisaac is the first compiled object-oriented programming language based on prototype concepts, with system programming facilities and design by contract. \n \nLisaac's developers admired both Self's flexibility and dynamic inheritance, and Eiffel's static typing and design by contract features. Seeking to combine these two apparently contradictory feature sets, Lisaac was created. \n \nLisaac was designed as the language in which the Isaac operating system would be programmed. \n \nThe Lisaac",
        "meta_lang": "en",
        "meta_favicon": "favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://encode.su/threads/232-Lisaac-programming-language?s=8a61d5f63317f50a21d8ceba06f27bd2",
        "text": "Lisaac is the first compiled object-oriented programming language based on prototype concepts, with system programming facilities and design by contract.\n\nLisaac's developers admired both Self's flexibility and dynamic inheritance, and Eiffel's static typing and design by contract features. Seeking to combine these two apparently contradictory feature sets, Lisaac was created.\n\nLisaac was designed as the language in which the Isaac operating system would be programmed.\n\nThe Lisaac compiler produces optimized ANSI C code, which can then be compiled on every architecture with an appropriate C compiler which makes Lisaac a real multi-platform language. Compiling results show that it is possible to obtain executables from a high-level prototype-based language that are as fast as C programs.\n\nconcept small prototype-based programming language\n\nThe ideas in Lisaac are mostly inspired by Smalltalk (all values are objects), Self (prototype-based)\n\nand Eiffel (design by contract)\n\nplatforms all platforms (host/target specific for GCC)\n\nfeatures pure object language\n\nvery fast (like C code)\n\ndynamic and multiple inheritance\n\ndynamic definition slot\n\nstatic typing (invariant)\n\ngenericity type\n\nauto-cast type system\n\nprogramming by contract\n\ninterrupt manager\n\ninclude C code facilities\n\nA mpeg2 decoder written in C was rigorously translated in Lisaac\n\n* Lisaac compilation options : -O -i20\n\n* Gcc compilation options : -O3 -fomit-frame-pointer -ftree-vectorize -msse -march=pentium4 -mtune=pentium4\n\n* System : Debian unstable/lenny\n\n* Video: 80Mo, 1m51s\n\nC version Lisaac version Lisaac Rate (%)\n\nCode line count 9888 6003 35.3% less\n\nBinary size 76Kb 88Kb 13.64% more\n\nText size 51427b 53887b 4.78% more\n\nRun time YUV format (s) 30.74 44.43 44.5% slower\n\nRun time SIF format (s) 60.67 59.15 2.5% faster\n\nRun time TGA format (s) 97.87 83.48 17.2% faster\n\nRun time PPM format (s) 97.33 83.70 16.3% faster\n\nIntel(R) Core(TM)2 Quad CPU @ 2.40GHz, 4Go DDR2\n\nLisaac is a hugh level language, so it explain 37,31% code line less than C program. Specialisations of the code made by the Lisaac compiler explain the 10% surplus of binary size. Data structure are heavier in Lisaac than C, but all memory is dynamically managed in Lisaac, so memory uses at runtime is about equal.\n\nhttp://isaacproject.u-strasbg.fr/li/li_download.html]\n\nC++ alternative:\n\nSather is an object-oriented programming language. It originated circa 1990 at the International Computer Science Institute at the University of California, Berkeley, developed by an international team led by Steve Omohundro. It supports garbage collection and generics by subtypes.\n\nOriginally, it was based on Eiffel, but it has diverged, and now includes several functional programming features. It is probably best to view it as an object-oriented language, with many ideas borrowed from Eiffel. Even the name is inspired by Eiffel; the Sather Tower is a recognizable landmark at Berkeley. Sather also takes inspiration from other programming languages and paradigms: iterators, design by contract, abstract classes, multiple inheritance, anonymous functions, operator overloading, contravariant type system. Some of these features are normally only found in functional programming languages.\n\nThe original Berkeley implementation is now maintained by many people, not all at Berkeley, and has been adopted by the Free Software Foundation therefore becoming GNU Sather. There are at least two other implementations: Sather-K from the University of Karlsruhe, and Sather-W from the University of Waikato.\n\nThe former ICSI sather compiler (now GNU Sather) is implemented as a compiler to C, i.e., the compiler does not output object or machine code, but takes Sather source code and generates C source code as an intermediate language. Optimizing is by the C compiler, Sather code often performs better than the corresponding C++ code, and the generated C code can always be optimized by hand.\n\nThe GNU Sather compiler, written in Sather itself, is dual licensed under the GNU GPL & LGPL.\n\nhttp://en.wikipedia.org/wiki/Sather\n\nLLVM clang:\n\nhttp://clang.llvm.org/index.html\n\nFeatures and Goals\n\nSome of the goals for the project include the following:\n\nEnd-User Features:\n\nFast compiles and low memory use\n\nExpressive diagnostics\n\nGCC compatibility\n\nUtility and Applications:\n\nModular library based architecture\n\nSupport diverse clients (refactoring, static analysis, code generation, etc)\n\nAllow tight integration with IDEs\n\nUse the LLVM 'BSD' License\n\nInternal Design and Implementation:\n\nA real-world, production quality compiler\n\nA simple and hackable code base\n\nA single unified parser for C, Objective C, C++, and Objective C++\n\nConformance with C/C++/ObjC and their variants\n\nOf course this is only a rough outline of the goals and features of Clang. To get a true sense of what it is all about, see the Features section, which breaks each of these down and explains them in more detail.\n\nWhy?\n\nThe development of a new front-end was started out of a need -- a need for a compiler that allows better diagnostics, better integration with IDEs, a license that is compatible with commercial products, and a nimble compiler that is easy to develop and maintain. All of these were motivations for starting work on a new front-end that could meet these needs."
    }
}