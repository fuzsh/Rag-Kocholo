{
    "id": "dbpedia_3412_0",
    "rank": 14,
    "data": {
        "url": "https://medium.com/%40SiliconJelly/are-these-11-programming-languages-still-alive-a51a2f280591",
        "read_more_link": "",
        "language": "en",
        "title": "ARE THESE ELEVEN PROGRAMMING LANGUAGES STILL ALIVE ?",
        "top_image": "https://miro.medium.com/v2/resize:fit:1000/1*3l98al6IHUoyyOedxMlVXA.png",
        "meta_img": "https://miro.medium.com/v2/resize:fit:1000/1*3l98al6IHUoyyOedxMlVXA.png",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/1*W0xXJZprh5ZKo4YPPKUbGw.jpeg",
            "https://miro.medium.com/v2/resize:fill:144:144/1*W0xXJZprh5ZKo4YPPKUbGw.jpeg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Tanjim Mohamed Nirjhor",
            "medium.com"
        ],
        "publish_date": "2022-11-05T09:02:29.967000+00:00",
        "summary": "",
        "meta_description": "A four-year-old Quora post from Flavian Mwasi appeared on my wall today. And while it’s actually true on his post that these 11 programming languages probably already have sounded their death knell —…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/1*m-R_BkNf1Qjr1YbyOIJY2w.png",
        "meta_site_name": "Medium",
        "canonical_link": "https://medium.com/@SiliconJelly/are-these-11-programming-languages-still-alive-a51a2f280591",
        "text": "A four-year-old Quora post from Flavian Mwasi appeared on my wall today. And while it’s actually true on his post that these 11 programming languages probably already have sounded their death knell — how many of this following list did you actually hear of?\n\nOn today’s episode of PL history, we shall grieve not, but rather find strength in what remains for us to move forward. And we shall draw a conclusion, about how the evolution of modern programming languages is driven thanks to their ancestors, as these 11 languages paved the way for scientists, developers, and engineers.\n\nAda\n\nNamed after English mathematician, Ada Lovelace, considered the first computer programmer, Ada was commissioned by the US Department of Defense (DoD) in 1991, to supersede over 450 programming languages used by the DoD at that time.\n\nAccording to Wikipedia,\n\n“Ada is a structured, statically typed, imperative, wide-spectrum, and object-oriented high-level computer programming language.”\n\nThe problem is that Ada was designed to do so much that it resulted in big, complex compilers and monolithic code.\n\nIn 1991, the US Department of Defense began to require the use of Ada (the Ada mandate) for all software, though exceptions to this rule were often granted.\n\nThe Department of Defense Ada mandate was effectively removed in 1997, as the DoD began to embrace Commercial Off-The-Shelf (COTS) technology [1] .\n\nCommercial use of Ada didn’t end with the end of the DoD mandate, though. Ada is still in wide use for medical and other mission-critical systems programming.\n\nAlgol\n\nAlgol was originally designed in the 1950s by a group of computer science heavyweights as a standard method of algorithm description used by the Association for Computing Machinery (ACM).\n\nDesigned to avoid some of the perceived problems with FORTRAN, Algol greatly influenced many of the other imperative languages that followed including PL/I, Simula, BCPL, B, Pascal, and C.\n\nActive development of Algol ended in 1960, which sounded a death knell that Algol had probably reached its end giving way to a number of other languages.\n\nAPL\n\nDeveloped in the 1960s, APL is a dynamically typed programming language whose central theme is the multidimensional array.\n\nAPL greatly influenced the development of concept modeling, spreadsheets, functional programming, and computer math packages, and inspired several other programming languages.\n\nBecause APL encouraged the use of multidimensional arrays and symbols, code written in APL eventually tended to become complex and unintelligible to anyone not conversant with the language.\n\nDie hard APL programmers still exist, especially in physics or math labs where very complicated algorithms are being done.\n\nForth\n\nForth is a typeless, stack-oriented programming language designed for embedded systems such as calculators, Computer Aided Design (CAD), astronomical and space applications. It is suitable for writing code that results in small, efficient and reliable applications, that execute very fast.\n\nAlthough Forth is mostly used in the embedded world, you can still find it used within a boot loader project that’s part of an operating system build.\n\nOutside of those areas, Forth is well among the growing list of programming languages more remembered than used.\n\nLISP\n\nDeveloped in the late 1950s, LISP is best known for one of its classic data structures — the linked list. Linked lists are very effective mechanisms for dealing with multiple data types in a single structure. In some ways, LISP foreshadowed concepts that came to be used in big data, but in very small, compact systems.\n\nLISP spawned a number of successors, but the best known general-purpose Lisp dialects are Common Lisp and Scheme.\n\nAfter years of steady decline, LISP has seen a late resurgence as researchers look for ways to add intelligent features to smaller systems.\n\nOutside the AI world, LISP has not been very successful.\n\nLogo\n\nLogo was originally designed in the late 1960s, as a programming language for teaching coding concepts. Logo is formally a dialect of the LISP programming language. Logo is also known as a logic-oriented programming language.\n\nLogo’s intellectual roots are in the areas of artificial intelligence, mathematical logic, and developmental psychology [2].\n\nBetter known for its use of turtle graphics, to illustrate graphics drawing, Logo’s use declined over time as a result of the confusion caused by many other programming languages that also used “turtle graphics” to described themselves something like “Logo” while having nothing to do with the real Logo language.\n\nPascal\n\nDesigned by Niklaus Wirth in the 1970s, Pascal was designed for teaching the concepts of structured programming. It also became the language that would play a major role in defining computer programming on the personal computer.\n\nIn the mid-1980s, Borland Turbo Pascal (different from Pascal) was a popular language for developing everything from building the software for the Apple Lisa to writing Donald Knuth’s TeX system.\n\nAs structured programming declined in favor of object-oriented programming, Pascal’s popularity declined as well.\n\nPascal die-hards still exist, but the language’s glory days are almost over.\n\nModula-2\n\nModula-2 is an imperative, structured, modular programming language, developed by Niklaus Wirth in the 1970s. It was designed as a successor to the Pascal programming language.\n\nThe most significant and visible feature of Modula-2 was the idea of the module (a block of code which can be more or less visible to the rest of the program).\n\nModula-2 and modular programming in general became the basis for future programming paradigms such as object-oriented programming.\n\nWhile Modula-2 had features similar or better than Pascal for commercial programming, it never developed a following for its older predecessor. Modula-2 is now almost a forgotten language.\n\nPL/I\n\nPL/I was designed by IBM in the 1960s as a general purpose, procedural, imperative, structured programming language.\n\nThe goal of PL/I was to improve on FORTRAN’s numerical capabilities, and enhance COBOL’s string and business-process abilities. The result was a monolithic, structured language that could be used for anything from control systems, to accounting, to scientific analysis.\n\nAs a programming language, PL/I never caught on the way IBM had hoped, and eventually lost popularity to other IBM languages such as CMS-2, SP/k, B, REXX and AS/400 Control Language.\n\nRPG\n\nRPG (Report Program Generator) is the premier, legacy application programming language for IBM computers from punch cards and IBM 1401 to IBM Power i mainframes to IBM’s mid-range computers like the AS/400.\n\nAlthough RPG shared the same market with FORTRAN and COBOL, IBM decided to keep it legacy — a position that perhaps led to its decline outside of IBM houses.\n\nThe current version, RPG IV, is still in wide use among die-hard RPG programmers who have no choice especially where IBM computers are hugely deployed.\n\nRPG, a language that used to be the talk of newspaper and magazine publications has gradually seen its popularity decline giving way to modern development platforms and hardware architectures like high-end LINUX/UNIX and JEE in the enterprise world.\n\nSmalltalk\n\nSmalltalk is perhaps the haiku of programming languages. Designed by a galaxy of computer science superstars at Xerox PARC in the late 1970s and early 1980, Smalltalk influenced many so-called object-oriented programming languages notably, AppleScript, Common Lisp Object System, Dart, Dylan, Erlang, Etoys, Falcon, Go, Groovy, Io, Ioke, Java, Lasso, Lisaac, Logtalk, Newspeak, NewtonScript, Object REXX, Objective-C, PHP 5, Perl 6, Python, Ruby, Scala, Scratch and Self.\n\nWith only six reserved keywords that operated on a message-passing model, Smalltalk was the “talk” of town.\n\nSmalltalk is still widely used as a teaching tool for object-oriented programming in universities, but did not find significant commercial use because it had a couple of major problems including:\n\nSmalltalk is a memory hog.\n\nSmalltalk didn’t produce applications that were very fast.\n\nSmalltalk missed the boat when it came to the Web\n\nThe Smalltalk syntax was too different from “conventional” languages like C++, PHP, Perl, Python, Pascal and Ruby, meaning it was harder to learn.\n\nThe Smalltalk IDE was too tightly coupled with the language\n\nThese among other factors, sounded the death knell for Smalltalk.\n\nIn Conclusion: The Torch Shall Be Passed\n\nToday programming languages are more than just their innate capabilities to satisfy a developer’s needs. They are more than the spread of their Abstract Syntax Trees. These languages are not just mere tools. They too evolve! From Hexadecimal (numbering system) to Assemblers. Till the mother language C, which helped brew higher level languages i.e. Python, JavaScript, Perl, PHP, Ruby, JAVA — making things automated, easier, and learner-friendly in the process.\n\nLanguages like Fortran or MATLAB were once heavily used in the twentieth century to get calculations done with less time yet with more elevated accuracy for solidifying mathematical research purposes. Fortran gave us the first do while loop constructs, (that, Algol called for loop) which later on helped recursive algorithms to get theorized. MATLAB began not as a traditional programming language but had to change itself during its growth to satisfy engineering and scientific endeavors [3].\n\nC became the mother language, because of it existing at the right time and at the right place. Most of the compilers and kernels are written in C today. C++ is still relied upon in order to save runtime, memory and optimize these resources inside the software, and game development industries. C++ and JAVA are two of the top-choice languages when it comes to competitive programming contestants. Ruby came in with mere simplicity, for web development, and is still one of the best open-source projects to have extensive community support for its popular web application frameworks i.e. Ruby on Rails [4].\n\nThanks to These 11 Ancestral Languages …\n\nOur lives as modern-day programmers have evolved to be more efficient and as time goes programming languages are becoming easier. From Ada to Smalltalk, every programming language had its prime time and had contributions passed to the next generation.\n\n“The best programs are written so that computing machines can perform them quickly and so that human beings can understand them clearly.\n\nA programmer is ideally an essayist who works with traditional aesthetic and literary forms as well as mathematical concepts, to communicate the way that an algorithm works and to convince a reader that the results will be correct.”\n\n― Donald E. Knuth, Selected Papers on Computer Science\n\nSo, the answer is obvious. Yes, these languages might be dead. But because of their dawn, now anyone from any discipline can hold the torch and start developing, they neither need to have Math/CS degrees nor to sit inside MIT Labs with IBM mainframes in front of them. That’s why there are so many successful self-taught programmers changing the scenes today. So, the question remains, with languages developing at such a fast pace, where will tomorrow take us?"
    }
}