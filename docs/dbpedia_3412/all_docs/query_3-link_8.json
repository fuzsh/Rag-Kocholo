{
    "id": "dbpedia_3412_3",
    "rank": 8,
    "data": {
        "url": "http://onsmalltalk.com/objects-classes-and-constructors-smalltalk-style",
        "read_more_link": "",
        "language": "en",
        "title": "Objects, Classes, and Constructors, Smalltalk Style",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Ruby Smalltalk"
        ],
        "tags": null,
        "authors": [
            "thoughts on Smalltalk",
            "programming in general"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Objects, classes, and constructors are an interesting thing in Smalltalk.  Coming from languages like C#, Visual Basic, or Java, one expects to be able to declare constructors in your classes.  You al...",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Ramon: Rejected is, what is rejected by the payers, not by geeky hobbyists, full stop. And Smalltalk and Lisp are explicitly rejected. Yes, you can create a nice success story using Lisp or Smalltalk, but as soon as the enterprise buys you out, the inevitable comes: the rewrite in a maintainable language. Not smart language, not innovative, but yes, maintainable one. Think static, manifest typed, imperative OO (but not fascist OO) one.\n\nAs to mainfest typing more maintainable being an urban legend, please stop ignoring facts, they don't cease to exist anyway. All evidence shows that if you have no declaration of what type a variable is, you have to figure it out during code maintenance as soon as you step on it. So this alone is a real maintenance pain. But add to this another thing to figure out: not only actual type, but intended type (the actual used interface) and you're doomed without a declaration for any non-trivial object. Read Cedric Beust's \"Perils of duck typing\" and you'll know what I mean.\n\n(And a Python maintenance horror story: someone has made a typo and written \"none\" where they should have written \"None\" - which later meant several hours of painful maintenance to find it... while a statically typed language where you declare everything would make it virtually impossible.)\n\nMicrosoft, they're trying to kill Java with lots and lots of features, crazy ones like lambdas or properties instead of explicit accessors. And know what? It is now clear that the more features they add, the further they are from their goal, killing Java. Too bad Java enters this nonsensical death race noone can win, but look at users, real users that pay the money for development: they are sticking to Java 1.4 and avoid even 1.5 (or 5.0 as Sun's marketing calls it) and for a good reason.\n\nSo make your smart decisions, when you run a startup, use Lisp or Smalltalk or whatever you want, you won't maintain it for a long time anyway - you'll go down bankrupt or get bought. And if you get bought, the business that buys you out will pay another money to rewrite your so brilliant code in a less brilliant way, in a less brilliant language, but that will save them another piles of money to spend within subsequent years.\n\nPat: no \"flexibility\" is ever needed, what is needed is the inflexibility, so people are forced to use a common language, which is always better than a \"powerful\" one. Python with their \"there should be only one way to do it\" could have a chance to become tomorrow's language, but they don't want to introduce static typing, so they've really given up.\n\nRamon, you are making up. What real programming is about is not creating abstractions, but using them. Look at Java - there are some abstractions built in, like classes or methods, or loops and you can use them but it is difficult or impossible to define your own. For example it was hard to define an abstraction to iterate over a collection, and though it was possible, the defined abstraction would have more code than a standard for loop, so everyone was using for. It was one of Java's shortcomings until it was built into the language, but with Java 1.4 it is explicit creation of an Iterator and using it in a loop. Now what would happen if Java made it easy and straightforward to create such abstractions? You'd have zillions of foreach loops, similar but different. One would break on exception, one would ignore it and continue, one would allow modifications of the underlying collection and one would not. And so on. Add possible bugs in many implementations of such foreach loops, and you have, well, lisp in 1980 :) And we still have static typing, if we were to give it up, we also have to count different behaviors when such a loop is asked to iterate over a non-collection. So now we really can have zillions of such utilities and explain how it helps maintenance.\n\nJava has got it wrong by not having such a foreach loop in the first place, but has got it right that it made homebrew implementations hard and, in fact, nonsense - as they would be harder to use than explicit coding such a loop using existing abstractions. So now I have no problem - I see what is written and don't have to dig which one of 100 foreaches in the project is this one?! See, it really helps maintenance.\n\nAnd re manifest typing, have you read Cedric Beust's article I pointed you to? I don't want to repeat him so please read it and comment, instead of repeated shouting \"four legs^W^Wmanifest typing bad!\".\n\nCedrick: With a debugger I will see the actual runtime type of a piece of data, yes. But it is the type in a given program execution, in another execution, under different conditions a piece of data assigned to the same variable might be of another type and I cannot examine all possible executions. And even if I could, I still can't see what type the original author intended to use. This is why I really need an explicit declaration and no type inference, even if it's possible statically.\n\nBesides, I think that except some very special situations (like dealing with external hardware) you shouldn't use the debugger and if you ever need it, it's a clear sign that you have screwed up your unit tests. The only situations I allow myself to use the debugger are those when writing unit tests is impossible.\n\nRamon: I see you write that you can't redefine ifTrue. But you lie! You can redefine, yet the redefinition will be ignored by the compiler because it is somehow \"optimized\". You knew that but I didn't - and if I did such a thing for whatever reason it'd cost me hours of pain... And now look at what would be if it were Java. Even if a method named ifTrue is being optimized away, you can define so named method for an unrelated type and it will work. And for a method to be optimized in such a way you have to declare it final, so redefinition on a subtype is not possible. See? Another obvious sign that manifest static typing rocks the world! :-))))\n\n\"But it is the type in a given program execution, in another execution, under different conditions a piece of data assigned to the same variable might be of another type and I cannot examine all possible executions.\" I find this is an advantage...\n\n\"And even if I could, I still can't see what type the original author intended to use.\" you see it generally in the initialize method, or in the getter (if lazy initialization)... Also, method name carry some information (enough for me about the type)... (from the more general anObject to the more specific aPoint, anInteger, aFigure ....) Smalltalk is plenty of such conventions (ST Best Practise Pattern is the book about that) which are not compulsary but recommended... You're free to use them or not... Dynamic is all about freedom, hence some pains especially at start since you don't have a process to follow or code to copy/paste and adapt (you don't have strict walls guiding you).\n\n\"Besides, I think that except some very special situations (like dealing with external hardware) you shouldn't use the debugger and if you ever need it, it's a clear sign that you have screwed up your unit tests. The only situations I allow myself to use the debugger are those when writing unit tests is impossible.\" Wow... I think we don't speak here of the same debugger ! And I'm sure now you only have a superficious knowledge of ST systems... ST 80 is an interactive development environment (SMALLTALK-80: the interactive programming environment - ISBN:0-201-11372-4) and the debuger is probably the best example of it... In ST, it's very common to write unit tests calling methods that doesn't exist yet, then you write them on the fly in the debugger, step by step...\n\n\"Ramon: I see you write that you can't redefine ifTrue. But you lie! You can redefine, yet the redefinition will be ignored by the compiler because it is somehow \"optimized\". You knew that but I didn't - and if I did such a thing for whatever reason it'd cost me hours of pain\" except, it's clearly said in the method comment... \"Execution doesn't actually reach here because the expression is compiled in-line\". But, I agree all this optimizations stuff and primitives calls makes the understanding of the system a bit difficult... but only if you go at a very low level ! Something wich is to me very very hard in static language... My squeak image is only 50Mb (plenty of packages and programs, networking, web server, seaside, scriptaculous, magritte, pier, interactive GUI, cryptography, ORM, etc etc...) and I've learned a lot (really a lot) since I'm using it... If you want to go low level, you can really easily (maybe at the price of some headaches ;) ) but you can...). Note I'm not a programer, some basic knowledges on C, C++, Java, Php before (mechanical engineering school), all seemed to me boring, repetitive and obscure, and now that I use ST, I just wish I had done CS studies !!!\n\nMy final 2 cents... :)\n\nps: About #ifTrue:, I put a self halt in the method and funny optimization stuff true ifTrue: [1] does't stop and answer 1 but it stops if I use the autocompletion stuf (hitting tab)... :)\n\nCharles, Ramon: Yes, there were some neat success stories of Smalltalk or Lisp companies, it's true. But it is also true that you Smalltalkers and Lispers take those stories and use them like queen's diamons - and for a reason: there are only so few. If I was to look out for a Java success story people would think I'm crazy, just as if I was to look out for trees in the middle of a forest.\n\nRamon: First, please, let's not get personal. I have never sent my CV to you so please don't tell me what I have programmed in. Second, please stop making straw men - I never said that static typing is an antidote against bugs, in fact I think advocating static typing as a recipe against errors is doing it harm. I am convinced that unit tests are a far better way and static typing adds very little here, so we can see it as a very degraded kind of unit tests (though it has an important property: ensured 100% code coverage).\n\nNow please do believe that runtime errors also do happen in Java apps, though not as stupid ones as misspelling 'none' for 'None'. But when a runtime error happens to me, I look at the tests, at the sources and at the log message or the exception stack trace. If I still don't know why the error happens, I know there is something wrong because that obviously means that I don't understand how the code works and how it should work. That is why I tell you I find debuggers bad. Of course I've never worked with a Smalltalk debugger, but I have worked with Lisp ones and imagine Smalltalk debugger is similar. I never let the debugger \"help\" me find the bug, that's what I meant. I think it's the bad way, I prefer to sit down for some more time and work hard to understand. But the time has shown, I can now fix most bugs in my code without the debugger faster than most of my coworkers with it.\n\nAs to ifTrue: this is wrong that you can write correct code which is just ignored because some other code has been \"optimized\". I don't know what else is so \"optimized\", but I do know, that if VM developers decide to \"optimize\" some method name I use in the next release, that means a hard time for me trying to figure what happened that my methods no longer are called. And that's simply atrocious.\n\nThe free market did reject PHP if you don't see it. Of course, from the Smalltalk standpoint it has wide wide acceptance, but it has been, in fact, rejected. It's a very good language to write simple three-page application but no more, and though there are some successful apps in PHP it's still nothing that real big money is paid for. Only Java and C# count.\n\njRave: But look even at evolution and the humans - humans are slow, weak, defenseless, if some alien biologist looked down at earth some 50k years ago, they'd think humans are doomed to extinction, but they were not, just because they had brains which made them king of the earth, but this alien would see no brains, just a lamentable creature which can't even climb trees anymore. And the same could be argued for programming languages, if we were to follow your metaphor: Java and C# compared to dynamic languages are slow to write code in, unimpressive and very strict on the programmer so for you as this alien they may look doomed, but they have something you don't see: good, valuable verbosity which serves as a communication tool, often for people who have never otherwise communicated or never will. Now why the humans dominated the planet? Because they had brains, yes, but really because having brains let them learn to communicate, work together and learn from each other. And the same is with languages, but more: the more they enforce communication, knowledge sharing the better they are. And it even holds further: a human would certainly lose a fight against many an animal, I mean really a fight: strength against strength, teeth against teeth, claws against, er, nails. But humans are who keep tigers and lions in cages, not the other way around, aren't they? Look now: a \"dynamic programmer\" will certainly win the race against a \"static\" one when they have a nearly equal start, yes, but what really happens is that such \"races\", though they let create nice success stories and make big money for some individuals are no longer significant because we \"static\" guys have created such an environment that, with exception of some very uncommon situations, there is no equal start - when the \"race\" starts the static guy has already won.\n\nIf you were to ask me about a successful language 20 years from now, how it will look like, I would tell that it will be mostly like Java 1.5, though with some things different: * no annotations, but some, like '@Override' will be promoted to keywords * properly implemented generics, with runtime checking * most of reflection removed, with exception of loading classes, instantiating objects; maybe method calling, but restricted to accessors * no exception chaining * no anonymous objects of any kind but numbers, * only interfaces and primitives allowed as formal method parameters, no concrete classes * more common control structures in the core language, other as hard to implement as just impossible.\n\nI even try to implement some of those as rules in projects I work on and it's very successful so far - we're slower to start but the more time passes the faster and more agile we are and coming back to the code 2 years after the project was finished because a bug has shown and the customer demands we correct it is nearly no pain it used to be before.\n\n(And think: I really hated this evolution analogy so far, but you've shown it to me, that it is so nice... smile)\n\nRamon: you might not want to accept it but what static languages do is make \"average\" guys better than you smart ones because they make commonness prevail over power. Not only they have better start - static languages are faster to learn, and unprecedented interest created so many good code just begging to be reused (especially for Java) which means real competitive advantage, but by simply following the rules they may (and probably will) write nd maintain better code than people smarter than them in more powerful languages.\n\nCedrick: No, I've never used Smalltalk, though I've used Lisp quite heavily - are their debuggers similar? In fact, I still do, as a hobby - and when I decide to start a startup it will certainly use a dynamic language even though I know that if someone bought this my hypothetical startup, they'd have to rewrite the entire code. But that would be their problem, I'd be already on some tropical beach by then... smile\n\nRamon: I just read and see but insults. I elect to ignore your \"bondage and discipline\" and \"pessimism and optimism\" parts, but you said another thing as if you were the pope speaking ex cathedra, yet this is simply false.\n\nTo some extent, people might be allowed to choose their own tools, but only through an accepted procedure within a company, ie. a programmer proposes to use X for a project, managers and other programmers comment and discuss and then a decision is taken (well, a negative decision might be taken much earlier, e.g. because of the X's license). What people must not be allowed is to choose their own tools individually or even in teams, 'cause that's a sure recipe for a disaster.\n\nBeen there - a project started using java.util.logging as a logging framework, then some people were moved to another projects, other people came and they decided to use log4j and even started to refactor earlier code to log4j, but they had no time to do it once and for all - and some modules' writers disliked both, so they have just written their own file loggers and used those. So we had just that: chaos. And it weren't only loggers such a disaster, nearly everything was written by programmers so smart as to think their way is the best, the only one. But with four average programmers we managed to clean it up and now it's doable to maintain that code further.\n\nI have no problem with smart (as in: I'm an evil genius) guys, BTW. As soon as they get to know they have to follow they rules, they choose to resign. Because serious programming has no place for cowboy coders, sorry. And those \"averages\" - yes, maybe they aren't so brilliant, maybe they don't do breathtaking solutions in hours, but I prefer calling them \"wise\", because they know they aren't the only ones that will use those solutions, so they choose to play by the rules.\n\nA startup is different; most projects I work on are planned for 10-15 years of life (and thus maintenance), startups need to quickly dominate the niche they found empty, faster than anyone else and it's usually decided after a year or two if they succeeded or failed. When they succeed, the enterprise buys them out and rewrite their code smile. So it's good for a startup to use Lisp or Smalltalk or Ruby because they just need to be fast, but when it stops being a startup it's better off to use a maintainable solution, not quick one.\n\n(On the rest, I think we really can agree to disagree...)\n\nRamon: Companies should invest not in tools or languages, but, above all, in uniformity, yes a moving uniformity but still. And yes, they have to mandate the rules, and it is not possible that everyone loves all the rules the company mandates but it is a must that everyone accept them or go away. Rules are not carved in stone, they may change - but this change must be under control, and may not happen because someone doesn't like some rules, or soon you will have no rules at all. So rules that are decided to have no sense are removed and others are added (e.g. once we decided that every class we create must implement an interface and that this interface, not the class is to be used in formal method parameters or variable declarations - but it was soon found that we've gone too far and this restriction has to be lifted for exception classes, so it was), but it's still decided at least project wide if not company wide.\n\nIt is wise to hire guys you call average and it's unwise to hire guys you call \"smart\", unless you're a startup. And one thing more - I haven't met two \"smart\" persons who, looking at another \"smart\" person's (or of anyone but themselves) code wouldn't start whining in terror at that \"dumbass\" who wrote this \"ugly, unintelligible, duct-taped piece of shit\". So, in fact, I might safely tell that there are no smart programmers at all evil grin. But this is a fact that those \"smart\" guys can do work impressingly fast, and, if you point a shotgun at them, even fix bugs from time to time, so they are good for startups.\n\nRe Google and Yahoo: This is exactly what I'm speaking of! Google was a startup created by some smart guys who noticed that search could be done better. And not only that - when they were starting most search engines' front pages were loaded up with \"portalose\" and they were not, their front page was light, their result pages as well. So they have obviously won. (The only difference is that they didn't decide to sell.) But mind now: Google is, very slowly yet inevitably, moving towards... Java; Python is still dominant there, yes, and it will be for years, but though they have so much money they can hire most of the smartest guys on the planet, and let them spend a day every week on whatever they want, yet pay for it, they are moving towards Java. Guess why smile?"
    }
}