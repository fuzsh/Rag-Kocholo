{
    "id": "dbpedia_3412_0",
    "rank": 30,
    "data": {
        "url": "https://www.artima.com/articles/generics-in-c-java-and-c/flat-comments",
        "read_more_link": "",
        "language": "en",
        "title": "Article Discussion",
        "top_image": "https://www.artima.com/assets/images/favicons/2aacd015ca6870a74bcb1c6d5a814a29-favicon-32x32.png",
        "meta_img": "https://www.artima.com/assets/images/favicons/2aacd015ca6870a74bcb1c6d5a814a29-favicon-32x32.png",
        "images": [
            "https://www.artima.com/assets/images/247172fe4a64de4f65e7f3cbbf41d1c9-artima_web_logo_171211b_20pct.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/assets/images/favicons/58ea8e9e1387316e74776b9a0fdbd5c0-apple-touch-icon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "> The thing you realize about typing is that it's a dial. The higher you place the dial, the more painful the programmer's\n\n> life becomes, but the safer it becomes too. But you can turn that dial too far in either direction.\n\nDoes the dial go from weak to strong, or from static to dynamic?\n\nI have personal experience of the pain of representing certain designs in C++, a strongly- and statically-typed language, so would agree with that. And once the compiler had bludgeoned me for half an hour, I suppose that the code was safe in certain limited respects.\n\nAnd turning the dial in the other direction, in languages such as Python, Ruby, or Smalltalk, I agree I was amazed at how /little/ pain was involved in clearly representing concepts in the code.\n\nBut were they 'less safe'? I for one don't think so. I tend to agree with Bruce Eckel's position (at http://mindview.net/WebLog/log-0025) that strong and static typing are both missteps towards unit-tested code. The sorts of assurances that typing can give you are really not that useful compared to unit-tests which check that a method's semantics are correct.\n\nDoes the dial go from weak to strong, or from static to dynamic?\n\n'So what is strong typing? As best as we can tell, this is a meaningless phrase, and people often use it in a nonsensical fashion. To some it seems to mean The language has a type checker. To others it means The language is sound (that is, the type checker and run-time system are related). To most, it seems to just mean, A language like Pascal, C or Java, related in a way I cant quite make precise. For amusement, when someone mentions the phrase strongly typed at a cocktail party, ask them to define it, then sit back and watch them squirm. And please, dont use the term yourself unless you want to sound poorly-trained and ignorant. Use the terminology of this course instead.'\n\nChapter 24 Type Soundness p205\n\nProgramming Languages: Application and Interpretation\n\nhttp://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/PDF/all.pdf\n\n> I have personal experience of the pain of representing\n\n> certain designs in C++, a strongly- and statically-typed\n\n> language\n\n\"C and C++ do not have sound type systems. That is, the type system may define certain abstractions, but the run time system does not honor and protect these.\" p205\n\n> And turning the dial in the other direction, in languages\n\n> such as Python, Ruby, or Smalltalk, I agree I was amazed\n\n> at how /little/ pain was involved in clearly representing\n\n> concepts in the code.\n\nI've used Smalltalk for over 10 years and like it.\n\nHowever, there are expressive statically checked languages: ML, Haskell, Nice http://nice.sourceforge.net/index.html, Scala http://scala.epfl.ch/index.html ...\n\n> But were they 'less safe'? I for one don't think so. I\n\n> tend to agree with Bruce Eckel's position (at\n\n> http://mindview.net/WebLog/log-0025) that strong and\n\n> static typing are both missteps towards unit-tested code.\n\n> The sorts of assurances that typing can give you are\n\n> really not that useful compared to unit-tests which check\n\n> that a method's semantics are correct.\n\nIt seems that folk experienced with expressive statically checked languages have a different programming style - they write code to actively use the type system to find errors, to them the type checker is another tool they can use to make their program better.\n\nScala and Nice look interesting. I'm a bit sceptic though about Nice's capability to prevent nullpointerexceptions in the case where data is originated from external sources like the user or a database. So that will be interesting to try out.\n\nBut then there are a lot of interesting features in Academic languages. The point where it gets exciting to me is where these cross over into the mainstream of languages that are used in the enterprises. Since then I can actually use it in everyday development.\n\nBut there's hope: it seems that one of the people behind Scala, Martin Odersky, was also behind the Pizza generics compiler. So maybe this will be of influence too. I seem to recall that James Gosling expressed some interest in type-inferencing. So, let's see, how long did it take for generics to make it into Java? Hm........\n\nNice's capability to prevent nullpointerexceptions in the case where data is originated from external sources like the user or a database\n\nIt's called Nice - not Magic ;-)\n\nThe programmer prevents NullPointerExceptions in these (and all other cases). Nice just provides a way to isolate the situations in which values may be null.\n\nIn Nice, the type String does not include null values - the type check will fail if we try to assign null to a String variable. The type ?String does include null - so we can bring in data as ?String, check that it isn't null and from then on use it as String.\n\nBut then there are a lot of interesting features in Academic languages\n\nYes, and in research languages generally - as you pointed out, there's plenty of language research taking place within Microsoft and other companies. It's wonderful that so many of those implementations are openly available.\n\ncross over into the mainstream of languages\n\nSure, it just takes soooo long.\n\nWhich is a reason to be interested in the language implementations that target jvm and clr (and interoperate with Java & C#) even though the implementations may suffer from limitations in those VMs - we can sometimes pretend to be using the mainstream language.\n\nGenerics has not been released in final form for etiher C# or Java, right?\n\nRegarding the distinctions he made between C# and Java ...\n\nI agree that there will potentially be a runtime disadvantage, but depending on how they implemented the extra information in the class file, it may not be bad. C# is at an advantage being able to design the CLR with generics in mind. However, I think it doesn't make a whole lot of difference to the programmer (for compile-time issues, at least).\n\nFor the second issue, when you get to runtime, you don't actually have a faithful representation of what you had at compile time, I'm not sure how often this will be a cause for problems for programmers. I guess the question is how much benefit do you get from compile time checking, and then how much additional benefit do you get from run time checking?\n\n> Generics has not been released in final form for etiher C#\n\n> or Java, right?\n\nThe spec has been out now for over 2 years for Java templates - changes could still occur at this stage but I imagine that they wouldn't be major.\n\n>\n\n> Regarding the distinctions he made between C# and Java\n\n> ...\n\n>\n\n> I agree that there will potentially be a runtime\n\n> disadvantage, but depending on how they implemented the\n\n> extra information in the class file, it may not be bad.\n\nAccording to the Java spec, runtime information on templates is added to the class file using named attributes. This is a backward compatible mechanism.\n\n> For the second issue, when you get to runtime, you\n\n> don't actually have a faithful representation of what you\n\n> had at compile time, I'm not sure how often this will\n\n> be a cause for problems for programmers. I guess the\n\n> question is how much benefit do you get from compile time\n\n> checking, and then how much additional benefit do you get\n\n> from run time checking?\n\nAs I mentioned in my post above, this statement by Anders is incorrect (unless he knows something that is not in the public spec). Attributes are added and the classes involved in relfection have been modified to take advantage of this information.\n\nRegards,\n\nRichard"
    }
}