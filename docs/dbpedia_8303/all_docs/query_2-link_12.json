{
    "id": "dbpedia_8303_2",
    "rank": 12,
    "data": {
        "url": "https://stackoverflow.com/questions/3033329/why-are-python-programs-often-slower-than-the-equivalent-program-written-in-c-or",
        "read_more_link": "",
        "language": "en",
        "title": "Why are Python Programs often slower than the Equivalent Program Written in C or C++?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/1aa48f7606f5b08595b0a0356a61e8b6?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/8a3226208a695630453bd84d3a4ddb27?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/ad240ed5cc406759f0fd72591dc8ca47?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/93ce59ea9096936b695d975bf4096e53?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/33d1848da81c469e3f19bd7e1d8919d9?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/2b2808fe325a143f9691ec37a9dc0b57?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/DVW9g.jpg?s=64",
            "https://www.gravatar.com/avatar/5bbcd267235bab78ec6710ef6654ba87?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e339541b2b4621e08e64e2c10af27c0d?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/3445f56229632874a44596385ed6d40c?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/ttNyA.png",
            "https://i.sstatic.net/ckWuR.png",
            "https://www.gravatar.com/avatar/af9ff639e361acfbce9430d162cb141c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e9a566d2afe6bb45d38749ce62d7f576?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e9246421d6d169b1a85a7e81b290713e?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://stackoverflow.com/posts/3033329/ivc/ccf8?prg=5b9ad0ba-a3e6-44ea-a824-64100e1aa1e1"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2010-06-13T18:09:11",
        "summary": "",
        "meta_description": "Why does Python seem slower, on average, than C/C++? I learned Python as my first programming language, but I've only just started with C and already I feel I can see a clear difference.",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/3033329/why-are-python-programs-often-slower-than-the-equivalent-program-written-in-c-or",
        "text": "Python is a higher level language than C, which means it abstracts the details of the computer from you - memory management, pointers, etc, and allows you to write programs in a way which is closer to how humans think.\n\nIt is true that C code usually runs 10 to 100 times faster than Python code if you measure only the execution time. However if you also include the development time Python often beats C. For many projects the development time is far more critical than the run time performance. Longer development time converts directly into extra costs, fewer features and slower time to market.\n\nInternally the reason that Python code executes more slowly is because code is interpreted at runtime instead of being compiled to native code at compile time.\n\nOther interpreted languages such as Java bytecode and .NET bytecode run faster than Python because the standard distributions include a JIT compiler that compiles bytecode to native code at runtime. The reason why CPython doesn't have a JIT compiler already is because the dynamic nature of Python makes it difficult to write one. There is work in progress to write a faster Python runtime so you should expect the performance gap to be reduced in the future, but it will probably be a while before the standard Python distribution includes a powerful JIT compiler.\n\nCPython is particularly slow because it has no Just in Time optimizer (since it's the reference implementation and chooses simplicity over performance in certain cases). Unladen Swallow is a project to add an LLVM-backed JIT into CPython, and achieves massive speedups. It's possible that Jython and IronPython are much faster than CPython as well as they are backed by heavily optimized virtual machines (JVM and .NET CLR).\n\nOne thing that will arguably leave Python slower however, is that it's dynamically typed, and there is tons of lookup for each attribute access.\n\nFor instance calling f on an object A will cause possible lookups in __dict__, calls to __getattr__, etc, then finally call __call__ on the callable object f.\n\nWith respect to dynamic typing, there are many optimizations that can be done if you know what type of data you are dealing with. For example in Java or C, if you have a straight array of integers you want to sum, the final assembly code can be as simple as fetching the value at the index i, adding it to the accumulator, and then incrementing i.\n\nIn Python, this is very hard to make code this optimal. Say you have a list subclass object containing ints. Before even adding any, Python must call list.__getitem__(i), then add that to the \"accumulator\" by calling accumulator.__add__(n), then repeat. Tons of alternative lookups can happen here because another thread may have altered for example the __getitem__ method, the dict of the list instance, or the dict of the class, between calls to add or getitem. Even finding the accumulator and list (and any variable you're using) in the local namespace causes a dict lookup. This same overhead applies when using any user defined object, although for some built-in types, it's somewhat mitigated.\n\nIt's also worth noting, that the primitive types such as bigint (int in Python 3, long in Python 2.x), list, set, dict, etc, etc, are what people use a lot in Python. There are tons of built in operations on these objects that are already optimized enough. For example, for the example above, you'd just call sum(list) instead of using an accumulator and index. Sticking to these, and a bit of number crunching with int/float/complex, you will generally not have speed issues, and if you do, there is probably a small time critical unit (a SHA2 digest function, for example) that you can simply move out to C (or Java code, in Jython). The fact is, that when you code C or C++, you are going to waste lots of time doing things that you can do in a few seconds/lines of Python code. I'd say the tradeoff is always worth it except for cases where you are doing something like embedded or real time programming and can't afford it.\n\nPython is typically implemented as a scripting language. That means it goes through an interpreter which means it translates code on the fly to the machine language rather than having the executable all in machine language from the beginning. As a result, it has to pay the cost of translating code in addition to executing it. This is true even of CPython even though it compiles to bytecode which is closer to the machine language and therefore can be translated faster. With Python also comes some very useful runtime features like dynamic typing, but such things typically cannot be implemented even on the most efficient implementations without heavy runtime costs.\n\nIf you are doing very processor-intensive work like writing shaders, it's not uncommon for Python to be somewhere around 200 times slower than C++. If you use CPython, that time can be cut in half but it's still nowhere near as fast. With all those runtmie goodies comes a price. There are plenty of benchmarks to show this and here's a particularly good one. As admitted on the front page, the benchmarks are flawed. They are all submitted by users trying their best to write efficient code in the language of their choice, but it gives you a good general idea.\n\nI recommend you try mixing the two together if you are concerned about efficiency: then you can get the best of both worlds. I'm primarily a C++ programmer but I think a lot of people tend to code too much of the mundane, high-level code in C++ when it's just a nuisance to do so (compile times as just one example). Mixing a scripting language with an efficient language like C/C++ which is closer to the metal is really the way to go to balance programmer efficiency (productivity) with processing efficiency.\n\nThis answer applies to python3. Most people do not know that a JIT-like compile occurs whenever you use the import statement. CPython will search for the imported source file (.py), take notice of the modification date, then look for compiled-to-bytecode file (.pyc) in a subfolder named \"_ _ pycache _ _\" (dunder pycache dunder). If everything matches then your program will use that bytecode file until something changes (you change the source file or upgrade Python)\n\nBut this never happens with the main program which is usually started from a BASH shell, interactively or via. Here is an example:\n\n#!/usr/bin/python3 # title : /var/www/cgi-bin/name2.py # author: Neil Rieck # edit : 2019-10-19 # ================== import name3 # name3.py will be cache-checked and/or compiled import name4 # name4.py will be cache-checked and/or compiled import name5 # name5.py will be cache-checked and/or compiled # def main(): # # code that uses the imported libraries goes here # if __name__ == \"__main__\": main() #\n\nOnce executed, the compiled output code will be discarded. However, your main python program will be compiled if you start up via an import statement like so:\n\n#!/usr/bin/python3 # title : /var/www/cgi-bin/name1 # author: Neil Rieck # edit : 2019-10-19 # ================== import name2 # name2.py will be cache-checked and/or compiled #name2.main() #\n\nAnd now for the caveats:\n\nif you were testing code interactively in the Apache area, your compiled file might be saved with privs that Apache can't read (or write on a recompile)\n\nsome claim that the subfolder \"_ _ pycache _ _\" (dunder pycache dunder) needs to be available in the Apache config\n\nwill SELinux allow CPython to write to subfolder (this was a problem in CentOS-7.5 but I believe a patch has been made available)\n\nOne last point. You can access the compiler yourself, generate the pyc files, then change the protection bits as a workaround to any of the caveats I've listed. Here are two examples:\n\nmethod #1 ========= python3 import py_compile py_compile(\"name1.py\") exit() method #2 ========= python3 -m py_compile name1.py\n\npython is interpreted language is not complied and its not get combined with CPU hardware\n\nbut I have a solutions for increase python as a faster programing language\n\n1.Use python3 for run and code python command like Ubuntu or any Linux distro use python3 main.py and update regularly your python so you python3 framework modules and libraries i will suggest use pip 3. 2.Use [Numba][1] python framework with JIT compiler this framework use for data visualization but you can use for any program this framework use GPU acceleration of your program. 3.Use [Profiler optimizing][1] so this use for see with function or syntax for bit longer or faster also have use full to change syntax as a faster for python its very god and work full so this give a with function or syntax using much more time execution of code. 4.Use multi threading so making multiprocessing of program for python so use CPU cores and threads so this make your code much more faster. 5.Using C,C#,C++ increasing python much more faster i think its called parallel programing use like a [cpython][1] . 6.Debug your code for test your code to make not bug in your code so then you will get little bit your code faster also have one more thing Application logging is for debugging code. and them some low things that makes your code faster: 1.Know the basic data structures for using good syntax use make best code. 2.make a best code have Reduce memory footprinting. 3.Use builtin functions and libraries. 4.Move calculations outside the loop. 5.keep your code base small.\n\nso using this thing then get your code much more faster yes so using this python not a slow programing language"
    }
}