{
    "id": "dbpedia_8303_2",
    "rank": 16,
    "data": {
        "url": "https://discuss.python.org/t/python-as-functional-programming-language/38402",
        "read_more_link": "",
        "language": "en",
        "title": "Python as functional programming language",
        "top_image": "https://global.discourse-cdn.com/business6/uploads/python1/original/1X/f93ff97c4f381b5e8add5a0c163b4ded29f20ed7.png",
        "meta_img": "https://global.discourse-cdn.com/business6/uploads/python1/original/1X/f93ff97c4f381b5e8add5a0c163b4ded29f20ed7.png",
        "images": [
            "https://sea2.discourse-cdn.com/business6/user_avatar/discuss.python.org/capymind/48/15179_2.png",
            "https://emoji.discourse-cdn.com/apple/slight_smile.png?v=12",
            "https://emoji.discourse-cdn.com/apple/wink.png?v=12",
            "https://sea2.discourse-cdn.com/business6/user_avatar/discuss.python.org/capymind/48/15179_2.png",
            "https://avatars.discourse-cdn.com/v4/letter/k/e47c2d/48.png",
            "https://sea2.discourse-cdn.com/business6/user_avatar/discuss.python.org/tinche/48/12507_2.png",
            "https://sea2.discourse-cdn.com/business6/user_avatar/discuss.python.org/tinche/48/12507_2.png",
            "https://sea2.discourse-cdn.com/business6/user_avatar/discuss.python.org/capymind/48/15179_2.png",
            "https://sea2.discourse-cdn.com/business6/user_avatar/discuss.python.org/sanderr/48/9401_2.png",
            "https://sea2.discourse-cdn.com/business6/user_avatar/discuss.python.org/onepythonuser/48/15131_2.png",
            "https://sea2.discourse-cdn.com/business6/user_avatar/discuss.python.org/ppentchev/48/11028_2.png",
            "https://emoji.discourse-cdn.com/apple/wink.png?v=12"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "defjaf (Andrew Jaffe)",
            "jamestwebber (James Webber)",
            "Ardenine (Alex)",
            "sanderr (Sander Van Balen)",
            "capymind (SoonShin",
            "Kwon (rodi))",
            "fungi (fungi)",
            "ppentchev (Peter Pentchev)",
            "majidaldo (Majid alDosari)",
            "kknechtel (Karl Knechtel)"
        ],
        "publish_date": "2023-11-10T16:56:05+00:00",
        "summary": "",
        "meta_description": "Hi everyone. \nI am a kind of python novice, sorry for dumb question here in advance… \nI recently watched a few conference talks about functional programming. \n(for example, Scott Wlaschin’s Domain Modeling Made Functiona&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://global.discourse-cdn.com/business6/uploads/python1/optimized/1X/9997f0605d56c4bfecd63594f52f42cdafd6b06a_2_32x32.png",
        "meta_site_name": "Discussions on Python.org",
        "canonical_link": "https://discuss.python.org/t/python-as-functional-programming-language/38402",
        "text": "Hi everyone.\n\nI am a kind of python novice, sorry for dumb question here in advance…\n\nI recently watched a few conference talks about functional programming.\n\n(for example, Scott Wlaschin’s Domain Modeling Made Functional, Composition, Functional design pattern etc using F#)\n\nWithout jargons (functor, monoid, monads etc.), the basic concepts and approaches are very attractive for me and make me not to be scared about type systems…So I want to give a try using Python in a kind of functional way.\n\nPython’s official website’s FAQ says\n\nPython is an interpreted, interactive, object-oriented programming language. It incorporates modules, exceptions, dynamic typing, very high level dynamic data types, and classes. It supports multiple programming paradigms beyond object-oriented programming, such as procedural and functional programming.\n\nAlthough Python is not designed for “functional programming languages” at first (to be honest I only have shallow understanding about difference in approach, philosophy, toolkit between OOP, and FP…), Is it okay and possible(even recommended sometimes) to write software fully in functional way using Python?\n\nThanks for reading this (dumb) question\n\nIs it possible? - It depends on what you mean by “functional”. If you want to be “strictly” or “purely” functional, it’s not possible. But it’s definitely possible to apply a functional style. Perhaps the single most important thing there is avoiding side-effects in functions. Functions with side-effects often are troublesome and make analyzing programs a lot harder, so this is sth that is good to always apply, imo.\n\nAvoiding statefullness is also sth that I think should generally be applied - again as far as possible. But here the question again is - how far do you want to go? (Python generators and coroutines for instance are very useful but maintain state.)\n\nIs it okay? – Nobody is going to forbid you (I hope)\n\nIf you want to look at examples:\n\nThe pandas APIs for the most part apply (and invite) a functional programming style; the pyspark API is similar.\n\nIn the stdlib functools and itertools use a functional style (see docs - itertools explicitly mentions it’s inspired by Haskell); functools is a bunch of convenience functions to create higher-order functions\n\nPython is described as an object-oriented language (and, in my view, it takes this idea more seriously than many other languages like Java that are commonly held up as archetypes of “object-oriented languages”); but it is still designed very much as a pragmatic language that supports multiple programming paradigms and allows for writing code in different styles. In that regard I think it is similar to C++ - only, far more pleasant to use\n\nBecause of Python’s commitment to the “everything is an object” principle of OO, functions (as well as other “callables”, such as classes) are first-class objects. This makes it natural to design and use higher-order functions.\n\nPython has a lambda (anonymous function) syntax, using the keyword lambda. It is restricted: the body of a lambda must be a single expression. (However, Python expressions can have side effects, and there is no general way to prevent this.) This syntax produces a function object (the same type as the def statement does); in the corresponding bytecode, the result of the expression is returned.\n\nThe decorator mechanism is implemented using higher-order functions, in fact. For example:\n\ndef spam(func): return lambda: ' '.join(func() for _ in range(10)) @spam def what_the_knights_say(): return 'Ni!' # The `@call_twice_and_sum` before the function is roughly equivalent to doing # `what_the_knights_say = spam(what_the_knights_say)` afterwards.\n\nAs mentioned, the standard library functools and itertools are invaluable here. In particular, functools.reduce implements a fold (a left fold, if I’m thinking clearly). map and filter are builtins, and there is a basic list-comprehension syntax that generalizes to set and tuple comprehensions and generator expressions. Most evaluation in Python is eager, but there are several lazy constructs available. Typically we use generator expressions to create generators (a kind of lazy iterable), and functionality from itertools is designed to accommodate lazy iterables.\n\nFunction composition is not supported out of the box, but it’s easy enough to implement simple cases using the above tools, and there are third-party packages for more robust solutions.\n\nIt is a maxim of Pythonistas that “practicality beats purity”. I personally have a fair affinity for functional style, and use list comprehensions in places that many other developers would write an explicit for loop. I even advocate for teaching list comprehensions to beginners first, as I sincerely believe they are easier to understand and analyze for most common cases than explicit iteration. However, when I write code I don’t try to avoid side effects and I certainly don’t succeed in doing so. Nor do I try to implement monads etc. or find myself wanting them. In the Python world, the assumption of imperative style for I/O is rarely questioned; it’s generally considered abusive to run a list comprehension (and discard the result) simply to cause I/O as a side effect, for example.\n\nThanks for your kind and helpful comments! It’s awesome.\n\nThe fact that function in python is first-class as you mentioned make me think it can be possible to write code in functional way.\n\nYeah… composition is key to functional programming I think.\n\nComposing functions, Composing types(algebraic type system?) bla bla…\n\nIt’s mind-blowing experience for me to watch pipeline-oriented and railway-oriented programming talks in Youtube (it’s all about composing functions), and see Rust’s official books about error and null? handling such as Result, Option.\n\nI found the open source projects related to above things such as\n\nGitHub - InvestmentSystems/function-pipe: Tools for extended function composition and pipelines in Python\n\nGitHub - dry-python/returns: Make your functions return something meaningful, typed, and safe!\n\nGitHub - ForeverWintr/metafunctions: metafunctions is a function composition library for python.\n\nand many others.\n\nI am a quite novice, so all thoses are not easy for me to understanding implementations and I want to build it by myself using plain, standard library python as possible as I can. I hope that It can be valuable for me to learn basic and core concepts about programming and python itself.\n\nAnyway, thanks for your reply. I have learned a lot from you!!\n\nHello,\n\nI have actually written embedded SW for microcontrollers using ‘C’. Now that I am learning Python,\n\nit appears that there is a strong emphasis for the OOP approach (especially for the application of the Tkinter module - I am sure it applies to other modules and Python in general). The main difference that I notice is that for python, you generally are strongly encouraged to create classes for everything (objects - inheritance, composition, etc.) with an emphasis on encapsulation.\n\nWith procedural programming for embedded applications, I never considered this in general. Writing programs for small embedded applications was generally written in a linear, procedural way. The closest I came to creating an object was creating C structures when I wanted to create multiple one to a few bit flags from one 16-bit structure (no reason to use a 16 bit/8 bit variable for example, if the flag’s value is only a ‘1’ or a ‘0’). Embedded applications tend to be memory (quantity) sensitive.\n\nSo, in a nutshell, kind of, in functional/procedural programming, we don’t worry about classes/encapsulation.\n\nIf you want to learn functional/procedural programming, try learning ‘C’.\n\nI typically try to use a functional programming style in Python as much as possible. But I think it is important not to force it. As others have already mentioned, itertools and functools are your friend. Iterators (although they’re stateful) can also support a functional programming style (just be aware of the iteration side effect). And try to limit side effects and make them explicit in docstrings. Some other things that have not been mentioned yet that fit well in the functional programming style in my opinion:\n\nmore-itertools, more functions like the ones in itertools\n\nFrozen dataclasses (dataclass package) are (pseudo) immutable\n\nIf you’re using type annotations, use the abstract types from collections.abc (e.g. Sequence) for function parameters rather than the concrete built-ins (e.g. list) to communicate clearly to the users of your functions that arguments will not be mutated.\n\nThese present a nice toolbox for functional programming, but in my opinion the other side is just as important: don’t force it. Python is not a purely functional programming language, and though it pains me sometimes, I will prefer an imperative style over a functional one in places where it just fits the language better. A good example are the built-in collection types (list, set, dict). They don’t have a functional manipulation API (at least not without creating an expensive copy), these operations have an inherent side effect. This makes it difficult to construct e.g. a dict by folding (functools.reduce) over another iterable. In these situations I will typically opt for a for loop, because it’s just more natural and more ideomatic, even if it still bothers me every time I have to do so.\n\nSo my advice would be to use the tools that are available and you’ll be able to use a functional programming style for a large part of your code. But whenever it feels like you have to go against the grain of the language itself, just make your peace with the imperative style and don’t force it.\n\nAs others have said, you won’t be able to do “pure” functional\n\nprogramming in Python the way you can in a language designed\n\nspecifically for it, e.g. LISP. I’m not sure that really matters\n\nmuch for the utility of the language, though, and in many cases\n\nbeing able to mix in constructs that aren’t purely functional opens\n\nup the possibility to create superior solutions…\n\nI started learning rudimentary computer programming in 1980. I’ve\n\nhad no formal training, but simply used the tools available to me in\n\norder to solve problems that needed solving. The first languages I\n\npicked up were essentially procedural in nature, interpreters that\n\ncame with my computer’s operating system. Later as I needed the\n\nperformance boost of compiled programs, I experimented with\n\nfunctional programming because those were some of the compilers I\n\ncould get my hands on. Over time, as portability became a concern\n\nfor me I switched languages more and started to write in some that\n\nleaned into object oriented design.\n\nI never really thought about procedural vs. functional vs. object\n\noriented design paradigms back then, I simply looked at examples of\n\nsource code similar to what I wanted to accomplish, played around\n\nwith them until I gained an understanding of how they worked, and\n\ninternalized that knowledge. These days Python is my go-to language,\n\nand a major reason is that it can be used in any of those ways (and\n\nmore). You’re not limited to using one specific kind of programming,\n\neven within the same body of source code.\n\nWhile the vast majority of problems you’ll encounter can be solved\n\nwith a program written in any of those styles, no one style is\n\nsuperior to the others, and different styles are often better for\n\ndifferent kinds of tasks. Unless your field is actually language\n\ntheory though, my recommendation is to not worry too much about what\n\nstyle you’re writing in. Learn to use the language hands-on through\n\nsolving problems that need solving, and when you come across a\n\nconstruct that you don’t understand play around with it until it\n\nmakes sense to you.\n\nAs you learn, you’ll find cleaner and more elegant solutions to\n\nproblems. Sometimes that will look “functional” from an academic\n\nperspective, sometimes it might look “procedural” or “object\n\noriented” or a mix of those and more. You’ll internalize the\n\nalgorithms, data models and relationships that work well in\n\ndifferent situations, but you won’t really waste time thinking about\n\nwhether what you’ve written is “proper” functional style. Making\n\nsoftware that works as intended and is easy for others to understand\n\nis usually far more important than language theory.\n\nI completely agree with the balanced opinions above: it is completely possible (and quite easy) to write parts of your Python program in a functional style, but if one clings blindly to the ways things are done in languages where the compilers/interpreters are specifically designed for that, the resulting code may turn out to be a) difficult to read by others, and b) inefficient. @sanderr did an excellent “pros and cons” list; I’d just like to add that the expensive copies problem does not only affect lists and dictionaries, but also immutable values. I love dataclasses, I love frozen dataclasses with a passion, but the compiler is simply not designed to optimize for methods that consume the original object and return a slightly modified version - the original object still remains in memory for a while, the modified version is a copy. If one tries to write a complex program with thousands of such consumed-and-thrown-away objects, things start to pile up (of course, in a well-designed program each individual consumed object will be garbage-collected pretty quickly, but still).\n\nNote that the above is NOT meant as a criticism of Python; as I wrote, it is not designed that way, and the things that it is designed for it does very well indeed."
    }
}