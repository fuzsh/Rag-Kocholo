{
    "id": "dbpedia_2196_3",
    "rank": 68,
    "data": {
        "url": "https://stackoverflow.com/questions/7387085/how-to-read-an-entire-file-to-a-string-using-c",
        "read_more_link": "",
        "language": "en",
        "title": "How to read an entire file to a string using C#?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://i.sstatic.net/ybD0C.png?s=64",
            "https://i.sstatic.net/5rbZ9.png?s=64",
            "https://www.gravatar.com/avatar/8c68413a839369d73dc9e9013faa0637?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/b4779212f57ff2e9549ea90a4499c2d7?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/ojUyh.png",
            "https://www.gravatar.com/avatar/df21e248e4530b7dd2cec828a646cd5c?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/UOdwH.png?s=64",
            "https://www.gravatar.com/avatar/fac42e3f137bfe0f34b8493c41d28f9e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/8576d8606612e422c08cccae38eacdad?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/DvyHk.jpg?s=64",
            "https://www.gravatar.com/avatar/2596d9baef66702ce5302a02bd831d95?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/10b66f400a161e930d137fc7715f5ed7?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/wK6TW.jpg",
            "https://i.sstatic.net/FdHky.jpg?s=64",
            "https://i.sstatic.net/9te2A.png?s=64",
            "https://www.gravatar.com/avatar/fb6480554ff15a1e365d51ecfedf235b?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/b6e0481b9cd5d0bcba035d568e832608?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/9604429f8f1f9e31503379bd5f240cc2?s=64&d=identicon&r=PG",
            "https://lh4.googleusercontent.com/-QS7egaB9kGc/AAAAAAAAAAI/AAAAAAAAAic/qz3Za3XdObQ/photo.jpg?sz=64",
            "https://i.sstatic.net/EDu5I.jpg?s=64",
            "https://graph.facebook.com/1354416559/picture?type=large",
            "https://i.sstatic.net/tBGZo.png",
            "https://i.sstatic.net/RZvXd.png",
            "https://lh5.googleusercontent.com/-gJNx3OSM0rI/AAAAAAAAAAI/AAAAAAAAAFc/PQQQxveLTAQ/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/329631e04ca9454ba30957db27dcdce4?s=64&d=identicon&r=PG",
            "https://stackoverflow.com/posts/7387085/ivc/0cff?prg=23766311-1531-4b37-b086-a1d341aae53d"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2011-09-12T11:22:48",
        "summary": "",
        "meta_description": "What is the quickest way to read a text file into a string variable?\n\nI understand it can be done in several ways, such as read individual bytes and then convert those to string. I was looking for a",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/7387085/how-to-read-an-entire-file-to-a-string-using-c",
        "text": "A benchmark comparison of File.ReadAllLines vs StreamReader ReadLine from C# file handling\n\nResults. StreamReader is much faster for large files with 10,000+ lines, but the difference for smaller files is negligible. As always, plan for varying sizes of files, and use File.ReadAllLines only when performance isn't critical.\n\nStreamReader approach\n\nAs the File.ReadAllText approach has been suggested by others, you can also try the quicker (I have not tested quantitatively the performance impact, but it appears to be faster than File.ReadAllText (see comparison below)). The difference in performance will be visible only in case of larger files though.\n\nstring readContents; using (StreamReader streamReader = new StreamReader(path, Encoding.UTF8)) { readContents = streamReader.ReadToEnd(); }\n\nComparison of File.Readxxx() vs StreamReader.Readxxx()\n\nViewing the indicative code through ILSpy I have found the following about File.ReadAllLines, File.ReadAllText.\n\nFile.ReadAllText - Uses StreamReader.ReadToEnd internally\n\nFile.ReadAllLines - Also uses StreamReader.ReadLine internally with the additionally overhead of creating the List<string> to return as the read lines and looping till the end of file.\n\nSo both the methods are an additional layer of convenience built on top of StreamReader. This is evident by the indicative body of the method.\n\nFile.ReadAllText() implementation as decompiled by ILSpy\n\npublic static string ReadAllText(string path) { if (path == null) { throw new ArgumentNullException(\"path\"); } if (path.Length == 0) { throw new ArgumentException(Environment.GetResourceString(\"Argument_EmptyPath\")); } return File.InternalReadAllText(path, Encoding.UTF8); } private static string InternalReadAllText(string path, Encoding encoding) { string result; using (StreamReader streamReader = new StreamReader(path, encoding)) { result = streamReader.ReadToEnd(); } return result; }\n\nFor the noobs out there who find this stuff fun and interesting, the fastest way to read an entire file into a string in most cases (according to these benchmarks) is by the following:\n\nusing (StreamReader sr = File.OpenText(fileName)) { string s = sr.ReadToEnd(); } //you then have to process the string\n\nHowever, the absolute fastest to read a text file overall appears to be the following:\n\nusing (StreamReader sr = File.OpenText(fileName)) { string s = String.Empty; while ((s = sr.ReadLine()) != null) { //do what you have to here } }\n\nPut up against several other techniques, it won out most of the time, including against the BufferedReader.\n\nTake a look at the File.ReadAllText() method\n\nSome important remarks:\n\nThis method opens a file, reads each line of the file, and then adds each line as an element of a string. It then closes the file. A line is defined as a sequence of characters followed by a carriage return ('\\r'), a line feed ('\\n'), or a carriage return immediately followed by a line feed. The resulting string does not contain the terminating carriage return and/or line feed.\n\nThis method attempts to automatically detect the encoding of a file based on the presence of byte order marks. Encoding formats UTF-8 and UTF-32 (both big-endian and little-endian) can be detected.\n\nUse the ReadAllText(String, Encoding) method overload when reading files that might contain imported text, because unrecognized characters may not be read correctly.\n\nThe file handle is guaranteed to be closed by this method, even if exceptions are raised\n\n@Cris sorry .This is quote MSDN Microsoft\n\nMethodology\n\nIn this experiment, two classes will be compared. The StreamReader and the FileStream class will be directed to read two files of 10K and 200K in their entirety from the application directory.\n\nStreamReader (VB.NET) sr = New StreamReader(strFileName) Do line = sr.ReadLine() Loop Until line Is Nothing sr.Close() FileStream (VB.NET) Dim fs As FileStream Dim temp As UTF8Encoding = New UTF8Encoding(True) Dim b(1024) As Byte fs = File.OpenRead(strFileName) Do While fs.Read(b, 0, b.Length) > 0 temp.GetString(b, 0, b.Length) Loop fs.Close()\n\nResult\n\nFileStream is obviously faster in this test. It takes an additional 50% more time for StreamReader to read the small file. For the large file, it took an additional 27% of the time.\n\nStreamReader is specifically looking for line breaks while FileStream does not. This will account for some of the extra time.\n\nRecommendations\n\nDepending on what the application needs to do with a section of data, there may be additional parsing that will require additional processing time. Consider a scenario where a file has columns of data and the rows are CR/LF delimited. The StreamReader would work down the line of text looking for the CR/LF, and then the application would do additional parsing looking for a specific location of data. (Did you think String. SubString comes without a price?)\n\nOn the other hand, the FileStream reads the data in chunks and a proactive developer could write a little more logic to use the stream to his benefit. If the needed data is in specific positions in the file, this is certainly the way to go as it keeps the memory usage down.\n\nFileStream is the better mechanism for speed but will take more logic."
    }
}