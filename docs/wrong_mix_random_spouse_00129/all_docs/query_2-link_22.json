{
    "id": "wrong_mix_random_spouse_00129_2",
    "rank": 22,
    "data": {
        "url": "https://neo4j.com/developer-blog/turn-a-harry-potter-book-into-a-knowledge-graph/",
        "read_more_link": "",
        "language": "en",
        "title": "Turn a Harry Potter Book into a Knowledge Graph",
        "top_image": "https://dist.neo4j.com/wp-content/uploads/20210721044425/harry-potter-knowledge-graph-e1626867892612.png",
        "meta_img": "https://dist.neo4j.com/wp-content/uploads/20210721044425/harry-potter-knowledge-graph-e1626867892612.png",
        "images": [
            "https://dist.neo4j.com/wp-content/uploads/20230926084108/Logo_FullColor_RGB_TransBG.svg",
            "https://dist.neo4j.com/wp-content/uploads/20230926084108/Logo_FullColor_RGB_TransBG.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240402072516/Icon-GraphAcademy.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240401103728/Icon-Documentation.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240401103728/Icon-Documentation.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240402072516/Icon-GraphAcademy.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240402072514/Icon-Events.svg",
            "https://dist.neo4j.com/wp-content/uploads/20230926084108/Logo_FullColor_RGB_TransBG.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240327092936/gdb.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240327092934/auradb.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240329130329/genai.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240401103728/Icon-Documentation.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240401103728/Icon-Documentation.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240402072516/Icon-GraphAcademy.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240402072514/Icon-Events.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240708132519/Logo-GraphSummit-reverse.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240402072012/Logo-Connections.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240517073021/tomaz-bratanic-150x150.jpeg",
            "https://dist.neo4j.com/wp-content/uploads/20210721042707/1_U_n3T1xuBsqMp1Y9_l8uA.jpeg",
            "https://dist.neo4j.com/wp-content/uploads/20210721042703/1kOHeWAXZ-U8oThhziNPUDw.png",
            "https://dist.neo4j.com/wp-content/uploads/20210721042659/1-doL05Oh3qh3SChKbXYPRA.png",
            "https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ffc1c45afcc8",
            "https://dist.neo4j.com/wp-content/uploads/20240321094132/Blog-Asset-AuraDB-Logo.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240321094136/Blog-Asset-AuraDB-Cloud.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240321094134/Blog-Asset-GraphAcademy-Trophy.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240514071251/node-24-logo.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240514071252/nodes-patterns.svg",
            "https://dist.neo4j.com/wp-content/uploads/20240517073021/tomaz-bratanic-150x150.jpeg",
            "https://dist.neo4j.com/wp-content/uploads/20240718095939/1wqqqBzPj1HYMk-R_joBW4A-e1721322291903.png",
            "https://dist.neo4j.com/wp-content/uploads/20240717084326/unstructured-io-knowledge-graph-e1721231081572.jpg",
            "https://dist.neo4j.com/wp-content/uploads/20240715065226/chemical-reaction-graph-e1721051577357.jpg",
            "https://dist.neo4j.com/wp-content/uploads/20230921083327/homepage-viz_ART-left.svg",
            "https://dist.neo4j.com/wp-content/uploads/20230921083329/homepage-viz_ART-right.svg",
            "https://dist.neo4j.com/wp-content/uploads/20230921082858/homepage-viz_left-side-art_375.svg",
            "https://dist.neo4j.com/wp-content/uploads/20230921082910/homepage-viz_right-side-art_375.svg",
            "https://dist.neo4j.com/wp-content/uploads/20210608133508/icon-tooltip-info.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-07-20T13:42:00+00:00",
        "summary": "",
        "meta_description": "Learn how to combine Selenium and SpaCy to create a Neo4j knowledge graph of the Harry Potter universeMost likely, you have already seen the Game of Thrones network created by Andrew Beveridge.Andrew constructed a co-occurrence network of book characters. If two… Read more →",
        "meta_lang": "en",
        "meta_favicon": "/apple-touch-icon.png?v=bOXynyJWa61",
        "meta_site_name": "Graph Database & Analytics",
        "canonical_link": "https://neo4j.com/developer-blog/turn-a-harry-potter-book-into-a-knowledge-graph/",
        "text": "Learn how to combine Selenium and SpaCy to create a Neo4j knowledge graph of the Harry Potter universe\n\nMost likely, you have already seen the Game of Thrones network created by Andrew Beveridge.\n\nAndrew constructed a co-occurrence network of book characters. If two characters appear within some distance of text between each other, we can assume that they are somehow related or they interact in the book.\n\nI decided to create a similar project but choose a popular book with no known (at least to me) network extraction. So, the project to extract a network of characters from the Harry Potter and the Philosopher’s Stone book was born.\n\nI did a lot of experiments to decide the best way to go about it. I’ve tried most of the open-source named entity recognition models to compare which worked best, but in the end, I decided that none were good enough.\n\nLuckily for us, the Harry Potter fandom page contains a list of characters in the first book. We also know in which chapter they first appeared, which will help us even further disambiguate the characters.\n\nArmed with this knowledge, we will use SpaCy’s rule-based matcher to find all mentions of a character. Once we have found all the occurrences of entities, the only thing left is to define the co-occurrence metric and store the results in Neo4j.\n\nWe will use the same co-occurrence threshold as was used in the Game of Thrones extraction. If two characters appear within 14 words of each other, we will assume they have interacted somehow and store the number of those interactions as the relationship weight.\n\nAgenda\n\nScrape Harry Potter fandom page\n\nPreprocess book text (Co-reference resolution)\n\nEntity recognition with SpaCy’s rule-based matching\n\nInfer relationships between characters\n\nStore results to Neo4j graph database\n\nI have prepared a Google Colab notebook if you want to follow along.\n\nHarry Potter Fandom Page Scraping\n\nWe will use Selenium for web scraping. As mentioned, we will begin by scraping the characters in the Harry Potter and the Philosopher’s Stone book. The list of characters by chapter is available under the CC-BY-SA license, so we don’t have to worry about any copyright infringement.\n\nWe now have a list of characters with information on which chapter they first appeared. Additionally, each of the characters has a web page with detailed information about the character.\n\nHermione Granger\n\nFor example, if you check out the Hermione Granger page, you can observe a structured table with additional information. We will use the alias section for the entity extraction and add other character details like house and blood type to enrich our knowledge graph.\n\nI haven’t added all code used to enrich information in this gist for readability and clarity. I have also added some exceptions for aliases. For example, Harry Potter has the following alias:\n\nGregory Goyle (under disguise of Polyjuice)\n\nWe want to ignore all the aliases under the disguise of Polyjuice. It seems he also told Stanley Shunpike that he was Neville Longbottom, which we will also skip.\n\nBefore we continue with named entity extraction from the book, we will store the scraped information about the characters to Neo4j.\n\nAttributes:\n\nname\n\nurl\n\naliases\n\nnationality\n\nblood-type\n\ngender\n\nspecies\n\nRelationships:\n\nHouse\n\nLoyalty\n\nFamily\n\nIf you have some experience with Cypher, you might have noticed that we have stored information such as blood, gender, aliases, but also family and loyalty relationships to our graph.\n\nIt seems that Hermione Granger is also known as Little Miss Perfect and is loyal to the Society for the Promotion of Elfish Welfare. Unfortunately, the data has no timeline, so Fred Weasley is already brother-in-law to Little Miss Perfect.\n\nText Preprocessing\n\nFirst of all, we have to get our hands on the text from the book. I’ve found a GitHub repository that contains the text of the first four Harry Potter books.\n\nThere is no license attached to the data, so I will assume we can use the data for educational purposes within the limits of fair use. If you actually want to read the book, please go and buy it.\n\nGetting the text from a GitHub file is quite easy:\n\nWe have to be careful to provide the link to the raw text content, and it should work.\n\nWhen I first did the entity extraction, I forgot to use the co-reference resolution technique beforehand. Co-reference resolution is the task of determining linguistic expressions that refer to the same real-world entity.\n\nIn simple terms, we replace the pronouns with the referenced entities.\n\nFor a real-world example, check out my Information extraction pipeline post.\n\nFrom text to knowledge. The information extraction pipeline\n\nI’ve been searching for open-source co-reference resolution models, but as far as I know, there are only two. The first is NeuralCoref that works on top of SpaCy, and AllenNLP provides the second model. Since I have already used NeuralCoref before, I decided to look at how the AllenNLP model works.\n\nUnfortunately, I quickly ran out of memory (Colab has 16GB RAM) when I input a whole chapter into the AllenNLP model. Then I sliced a chapter into a list of sentences, but it worked really slow, probably due to using the BERT framework.\n\nSo, I defaulted to use NeuralCoref, which can easily handle a whole chapter and works faster. I have copied the code I have already used before:\n\nNow that we have our text ready, it is time to extract mentioned characters from the text.\n\nEntity Recognition with SpaCy’s Rule-Based Matching\n\nFirst, I wanted to be cool and use a Named Entity Recognition model. I’ve tried models from SpaCy, HuggingFace, Flair, and even Stanford NLP.\n\nNone of them worked well enough to satisfy my requirements. So instead of training my model, I decided to use SpaCy’s rule-based pattern matching feature.\n\nWe already know which characters we are looking for based on the data we scraped from the HP fandom site. Now we just have to find a way to match them in the text as perfectly as possible.\n\nWe have to define the text patterns for each of the character.\n\nFirst, we add the full name as the pattern we are looking for. Then we split the name by whitespace and create a pattern out of every word of the term. So, for example, if we are defining matcher patterns for Albus Dumbledore, we will end up with three different text patterns that could represent the given character:\n\nFull name: Albus Dumbledore\n\nFirst name: Albus\n\nLast name: Dumbledore\n\nThere are some exceptions. I have defined a list of stop words that should not be included in the single word pattern for a given character.\n\nFor example, there is a “Keeper of the Zoo” character present in the book. It might be pretty intuitive not to define words like “of” or “the” as the matcher patterns of an entity.\n\nNext, we want all single words to be title-cased. This is to avoid all mentions of the color “black” being a reference to “Sirius Black”. Only if the “Black” is title-cased, will we assume that “Sirius Black” is referenced. It is not a perfect solution as “Black” could be title-cased due to being at the start of a sentence, but it is a good enough solution.\n\nA particular case I’ve introduced is that “Ronald Weasley” is mainly referred to as “Ron” in the text. Lastly, we do not split entities like “Vernon Dursley’s secretary” or “Draco Malfoy’s eagle owl”.\n\nThere are two obstacles we must overcome with this approach. The first issue is that the following text: “Albus Dumbledore is a nice wizard”\n\nwill produce three matches. We will get three results because we have used the whole and parts of names in our matcher pattern. To solve this issue, we will prefer more extended entities.\n\nIf there is a match that composes of multiple words and another match consisting of a single word in the same place, we will prefer the one with multiple words.\n\nMy implementation of longer-word entities prioritization is very basic. First, it checks if a more extended entity already exists. It then checks if the current result is longer than any existing entities in the same position, and lastly appends a new result if there are no existing entities yet.\n\nWhat is interesting is the very last “else” clause. Sometimes, more entities are assigned to a single position. Consider the following sentence:\n\n“Weasley, get over here!”\n\nThere are many Weasley characters that we can choose from. This is the second issue we must overcome. It mostly happens when a person is referenced by their last name, and there are many characters with that last name.\n\nWe must come up with a generic solution for entity disambiguation.\n\nThis is a bit longer function. We start by identifying which entities require disambiguation.\n\nI introduced a unique logic disambiguating the “Dursley” term. If “Mr.” is present before the “Dursley” term, then we reference Vernon, and if “Mrs.” is present, we choose “Petunia”.\n\nNext, we have a more generic solution. The algorithm assigns the reference to the nearest neighbor out of the options.\n\nFor example, suppose we can choose between “Harry Potter”, “James Potter”, and “Lily Potter”. In that case, the algorithm identifies the nearest of those three entities in the text and assigns the current item its value. There are some exceptions where their full or first name is not referenced within the same chapter, and I have added hard-coded options as a last resort.\n\nInfer Relationships Between Characters\n\nWe are finished with the hard part. Inferring relationships between characters is very simple. First, we need to define the distance threshold of interaction or relation between two characters. As mentioned, we will use the same distance threshold as was used in the GoT extraction.\n\nThat is, if two characters co-occur within the distance of 14 words, then we assume they must have interacted. I have also merged entities not to skew results.\n\nWhat do I mean by joining entities? Suppose we have the following two sentences:\n\n“Harry was having a good day. He went to talk to Dumbledore in the afternoon.”\n\nOur entity extraction process will identify three entities, “Harry”, “He” as a reference to Harry, and “Dumbledore”. If we took the naive approach, we could infer two interactions between Harry and Dumbledore as two references of “Harry” are close to “Dumbledore”.\n\nHowever, I want to avoid that, so I have merged entities in a sequence that refers to the same character as a single entity. Finally, we have to count the number of interactions between the pairs of characters.\n\nStore Results to Neo4j Graph Database\n\nWe have extracted the interactions network between character, and the only thing left is to store the results into a graph database. The import query is very straightforward as we are dealing with a monopartite network.\n\nIf you are using the Colab notebook I have prepared, then it would be easiest to create either a free Neo4j Sandbox or free Aura database instance to store the results.\n\nLet’s visualize the interaction network to examine the results.\n\nAt first glance, the results look pretty cool. In the center of the network is Harry Potter, which is understandable as the book is mostly from his point of view.\n\nI’ve noticed I should have added some additional stop words in the matcher pattern, but hey, you live, and you learn.\n\nConclusion\n\nI am quite proud of how good the rule-based matching based on predefined entities turned out. As always, the code is available on GitHub.\n\nYou could try this approach on the second or third book. Probably the only thing that would need a bit of fine-tuning is the entity disambiguation process.\n\nStay tuned till next time, when we will perform a network analysis of the Harry Potter universe.\n\nYou can use the Neo4j graph algorithms playground application to test out graph algorithms on the Harry Potter knowledge graph if you don’t want to wait."
    }
}