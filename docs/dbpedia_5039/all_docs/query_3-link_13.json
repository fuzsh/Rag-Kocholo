{
    "id": "dbpedia_5039_3",
    "rank": 13,
    "data": {
        "url": "https://www.digitalocean.com/community/tutorials/collections-in-java-tutorial",
        "read_more_link": "",
        "language": "en",
        "title": "Collections in Java - Everything You MUST Know",
        "top_image": "https://journaldev.nyc3.cdn.digitaloceanspaces.com/2013/01/java-collections.png",
        "meta_img": "https://journaldev.nyc3.cdn.digitaloceanspaces.com/2013/01/java-collections.png",
        "images": [
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdefault-avatar.14b0d31d.jpeg&width=48 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdefault-avatar.14b0d31d.jpeg&width=96 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=https%3A%2F%2Fjournaldev.nyc3.cdn.digitaloceanspaces.com%2F2013%2F01%2Fjava-collections.png&width=828 1x, https://www.digitalocean.com/api/static-content/v1/images?src=https%3A%2F%2Fjournaldev.nyc3.cdn.digitaloceanspaces.com%2F2013%2F01%2Fjava-collections.png&width=1920 2x",
            "https://journaldev.nyc3.cdn.digitaloceanspaces.com/2013/01/Java-Collections-Framework-1024x460.png",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdefault-avatar.14b0d31d.jpeg&width=64 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdefault-avatar.14b0d31d.jpeg&width=128 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=32 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=48 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=32 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=48 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=32 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=48 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=32 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=48 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=32 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=48 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=32 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=48 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=32 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=48 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=32 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=48 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=32 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=48 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=32 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdo-logo.d3eb8550.svg&width=48 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fcreativecommons.c0a877f1.png&width=128 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fcreativecommons.c0a877f1.png&width=256 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2FnewsLetter.c1eb26e3.jpeg&width=750 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2FnewsLetter.c1eb26e3.jpeg&width=1920 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2FhollieHub4Good.90285377.jpeg&width=750 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2FhollieHub4Good.90285377.jpeg&width=1920 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fwrite4DO.6a167f0c.jpeg&width=750 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fwrite4DO.6a167f0c.jpeg&width=1920 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fconsole-static.1b14cc64.svg&width=640 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fconsole-static.1b14cc64.svg&width=1080 2x"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Technical tutorials, Q&A, events â This is an inclusive place where developers can find or lend support and discover new ways to contribute to the community.",
        "meta_lang": "en",
        "meta_favicon": "/_next/static/media/apple-touch-icon.d7edaa01.png",
        "meta_site_name": "",
        "canonical_link": "https://www.digitalocean.com/community/tutorials/collections-in-java-tutorial",
        "text": "Java Collections Framework is one of the core parts of the Java programming language. Collections are used in almost every programming language. Most of the programming languages support various type of collections such as List, Set, Queue, Stack, etc.\n\nWhat is Java Collections Framework?\n\nCollections are like containers that group multiple items in a single unit. For example, a jar of chocolates, a list of names, etc.\n\nCollections are used in every programming language and when Java arrived, it also came with few Collection classes â Vector, Stack, Hashtable, Array.\n\nJava 1.2 provided Collections Framework that is the architecture to represent and manipulate Collections in java in a standard way. Java Collections Framework consists of the following parts:\n\n1. Interfaces\n\nJava Collections Framework interfaces provides the abstract data type to represent collection.\n\njava.util.Collection is the root interface of Collections Framework. It is on the top of the Collections framework hierarchy. It contains some important methods such as size(), iterator(), add(), remove(), clear() that every Collection class must implement.\n\nSome other important interfaces are java.util.List, java.util.Set, java.util.Queue and java.util.Map. The Map is the only interface that doesnât inherit from the Collection interface but itâs part of the Collections framework. All the collections framework interfaces are present in java.util package.\n\n2. Implementation Classes\n\nJava Collections framework provides implementation classes for core collection interfaces. We can use them to create different types of collections in the Java program.\n\nSome important collection classes are ArrayList, LinkedList, HashMap, TreeMap, HashSet, and TreeSet. These classes solve most of our programming needs but if we need some special collection class, we can extend them to create our custom collection class.\n\nJava 1.5 came up with thread-safe collection classes that allowed us to modify Collections while iterating over them. Some of them are CopyOnWriteArrayList, ConcurrentHashMap, CopyOnWriteArraySet. These classes are in java.util.concurrent package.\n\nAll the collection classes are present in java.util and java.util.concurrent package.\n\n3. Algorithms\n\nAlgorithms are useful methods to provide some common functionalities such as searching, sorting and shuffling.\n\nCollections Framework Class Diagram\n\nBelow class diagram shows Collections Framework hierarchy. For simplicity, I have included only commonly used interfaces and classes.\n\nBenefits of Java Collections Framework\n\nJava Collections framework have following benefits:\n\nReduced Development Effort â It comes with almost all common types of collections and useful methods to iterate and manipulate the data. So we can concentrate more on business logic rather than designing our collection APIs.\n\nBetter Quality â Using core collection classes that are well-tested increases our program quality rather than using any home-developed data structure.\n\nReusability and Interoperability\n\nReduce effort to maintain because everybody knows Collection API classes.\n\nJava Collections API Interfaces\n\nJava collection interfaces are the foundation of the Java Collections Framework. Note that all the core collection interfaces are generic; for example public interface Collection<E>. The <E> syntax is for Generics and when we declare Collection, we should use it to specify the type of Object it can contain. It helps in reducing run-time errors by type-checking the Objects at compile-time.\n\nTo keep the number of core collection interfaces manageable, the Java platform doesnât provide separate interfaces for each variant of each collection type. If an unsupported operation is invoked, a collection implementation throws an UnsupportedOperationException.\n\n1. Collection interface\n\nThis is the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Java platform doesnât provide any direct implementations of this interface.\n\nThe interface has methods to tell you how many elements are in the collection (size, isEmpty), to check whether a given object is in the collection (contains), to add and remove an element from the collection (add, remove), and to provide an iterator over the collection (iterator).\n\nCollection interface also provides bulk operations methods that work on the entire collection â containsAll, addAll, removeAll, retainAll, clear.\n\nThe toArray methods are provided as a bridge between collections and older APIs that expect arrays on input.\n\n2. Iterator Interface\n\nIterator interface provides methods to iterate over the elements of the Collection. We can get the instance of iterator using iterator() method. Iterator takes the place of Enumeration in the Java Collections Framework. Iterators allow the caller to remove elements from the underlying collection during the iteration. Iterators in collection classes implement Iterator Design Pattern.\n\n3. Set Interface\n\nSet is a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the deck of cards.\n\nThe Java platform contains three general-purpose Set implementations: HashSet, TreeSet, and LinkedHashSet. Set interface doesnât allow random-access to an element in the Collection. You can use iterator or foreach loop to traverse the elements of a Set.\n\n4. List Interface\n\nList is an ordered collection and can contain duplicate elements. You can access any element from its index. List is more like array with dynamic length. List is one of the most used Collection type. ArrayList and LinkedList are implementation classes of List interface.\n\nList interface provides useful methods to add an element at a specific index, remove/replace element based on the index and to get a sub-list using the index.\n\nList strList = new ArrayList<>(); strList.add(0, \"0\"); strList.add(1, \"1\"); strList.set(1, \"2\"); strList.remove(\"1\");\n\nCollections class provide some useful algorithm for List â sort, shuffle, reverse, binarySearch etc.\n\n5. Queue Interface\n\nQueue is a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations.\n\nQueues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elementsâ natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue.\n\n6. Dequeue Interface\n\nA linear collection that supports element insertion and removal at both ends. The name deque is short for âdouble-ended queueâ and is usually pronounced âdeckâ. Most Deque implementations place no fixed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no fixed size limit.\n\nThis interface defines methods to access the elements at both ends of the deque. Methods are provided to insert, remove, and examine the element.\n\n7. Map Interface\n\nJava Map is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value.\n\nThe Java platform contains three general-purpose Map implementations: HashMap, TreeMap, and LinkedHashMap.\n\nThe basic operations of Map are put, get, containsKey, containsValue, size, and isEmpty.\n\n8. ListIterator Interface\n\nAn iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, and obtain the iteratorâs current position in the list.\n\nJava ListIterator has no current element; its cursor position always lies between the element that would be returned by a call to previous() and the element that would be returned by a call to next().\n\n9. SortedSet Interface\n\nSortedSet is a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls.\n\n10. SortedMap Interface\n\nA map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories.\n\nJava Collections Classes\n\nJava Collections framework comes with many implementation classes for the interfaces. Most common implementations are ArrayList, HashMap and HashSet. Java 1.5 included Concurrent implementations; for example ConcurrentHashMap and CopyOnWriteArrayList. Usually Collection classes are not thread-safe and their iterator is fail-fast. In this section, we will learn about commonly used collection classes.\n\n1. HashSet Class\n\nJava HashSet is the basic implementation the Set interface that is backed by a HashMap. It makes no guarantees for iteration order of the set and permits the null element.\n\nThis class offers constant time performance for basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. We can set the initial capacity and load factor for this collection. The load factor is a measure of how full the hash map is allowed to get before its capacity is automatically increased.\n\n2. TreeSet Class\n\nA NavigableSet implementation based on a TreeMap. The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used.\n\nRefer: Java Comparable Comparator\n\nThis implementation provides guaranteed log(n) time cost for the basic operations (add, remove, and contains).\n\nNote that the ordering maintained by a set (whether or not an explicit comparator is provided) must be consistent with equals if it is to correctly implement the Set interface. (See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Set interface is defined in terms of the equals operation, but a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal.\n\n3. ArrayList Class\n\nJava ArrayList is the resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)\n\nThe size, isEmpty, get, set, iterator, and list iterator operations run in constant time. The add operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation.\n\nFurther reading: Java ArrayList and Iterator\n\n4. LinkedList Class\n\nDoubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).\n\nAll of the operations perform as expected for a doubly-linked list. Operations that index into the list will traverse the list from the start or the end, whichever is closer to the specified index.\n\n5. HashMap Class\n\nHash table based implementation of the Map interface. This implementation provides all of the optional map operations and permits null values and the null key. HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits null. This class makes no guarantees for the order of the map.\n\nThis implementation provides constant-time performance for the basic operations (get and put). It provides constructors to set initial capacity and load factor for the collection.\n\nFurther Read: HashMap vs ConcurrentHashMap\n\n6. TreeMap Class\n\nA Red-Black tree based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.\n\nThis implementation provides guaranteed log(n) time cost for the containsKey, get, put, and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivestâs Introduction to Algorithms.\n\nNote that the ordering maintained by a TreeMap, like any sorted map, and whether or not an explicit comparator is provided, must be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a sorted map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface.\n\n7. PriorityQueue Class\n\nQueue processes its elements in FIFO order but sometimes we want elements to be processed based on their priority. We can use PriorityQueue in this case and we need to provide a Comparator implementation while instantiation the PriorityQueue. PriorityQueue doesnât allow null values and itâs unbounded. For more details about this, please head over to Java Priority Queue where you can check its usage with a sample program.\n\nThe Collections class\n\nJava Collections class consists exclusively of static methods that operate on or return collections. It contains polymorphic algorithms that operate on collections, âwrappersâ, which return a new collection backed by a specified collection, and a few other odds and ends.\n\nThis class contains methods for collection framework algorithms, such as binary search, sorting, shuffling, reverse, etc.\n\nSynchronized Wrappers\n\nThe synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces â Collection, Set, List, Map, SortedSet, and SortedMap â has one static factory method.\n\npublic static Collection synchronizedCollection(Collection c); public static Set synchronizedSet(Set s); public static List synchronizedList(List list); public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m); public static SortedSet synchronizedSortedSet(SortedSet s); public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m);\n\nEach of these methods returns a synchronized (thread-safe) Collection backed up by the specified collection.\n\nUnmodifiable wrappers\n\nUnmodifiable wrappers take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an UnsupportedOperationException. Its main usage are;\n\nTo make a collection immutable once it has been built. In this case, itâs good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability.\n\nTo allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access.\n\npublic static Collection unmodifiableCollection(Collection<? extends T> c); public static Set unmodifiableSet(Set<? extends T> s); public static List unmodifiableList(List<? extends T> list); public static <K,V> Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m); public static SortedSet unmodifiableSortedSet(SortedSet<? extends T> s); public static <K,V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m);\n\nThread Safe Collections Classes\n\nJava 1.5 Concurrent package (java.util.concurrent) contains thread-safe collection classes that allow collections to be modified while iterating. By design, an iterator is fail-fast and throws ConcurrentModificationException. Some of these classes are CopyOnWriteArrayList, ConcurrentHashMap, CopyOnWriteArraySet.\n\nAvoid ConcurrentModificationException\n\nCopyOnWriteArrayList Example\n\nHashMap vs ConcurrentHashMap\n\nCollections API Algorithms\n\nJava Collections Framework provides algorithm implementations that are commonly used such as sorting and searching. Collections class contain these method implementations. Most of these algorithms work on List but some of them are applicable for all kinds of collections.\n\n1. Sorting\n\nThe sort algorithm reorders a List so that its elements are in ascending order according to an ordering relationship. Two forms of the operation are provided. The simple form takes a List and sorts it according to its elementsâ natural ordering. The second form of the sort takes a Comparator in addition to a List and sorts the elements with the Comparator.\n\n2. Shuffling\n\nThe shuffle algorithm destroys any trace of order that may have been present in a List. That is, this algorithm reorders the List based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance.\n\n3. Searching\n\nThe binarySearch algorithm searches for a specified element in a sorted list. This algorithm has two forms. The first takes a List and an element to search for (the âsearch keyâ).\n\nThis form assumes that the list is sorted in ascending order according to the natural ordering of its elements.\n\nThe second form takes a Comparator in addition to the List and the search key and assumes that the list is sorted into ascending order according to the specified Comparator.\n\nThe sort algorithm can be used to sort the List prior to calling binarySearch.\n\n4. Composition\n\nThe frequency and disjoint algorithms test some aspect of the composition of one or more Collections.\n\nfrequency: counts the number of times the specified element occurs in the specified collection\n\ndisjoint: determines whether two Collections are disjoint; that is, whether they contain no elements in common\n\n5. Min and Max values\n\nThe min and the max algorithms return, respectively, the minimum and maximum element contained in a specified Collection. Both of these operations come in two forms. The simple form takes only a Collection and returns the minimum (or maximum) element according to the elementsâ natural ordering.\n\nJava 8 Collections API Features\n\nJava 8 biggest changes are related to Collection APIs. Some of the important changes and improvements are:\n\nIntroduction of Stream API for sequential as well as parallel processing, you should read Java Stream API Tutorial for more details.\n\nIterable interface has been extended with forEach() default method for iterating over a collection.\n\nLambda Expression and Functional interfaces are mostly beneficial with Collection API classes.\n\nJava 10 Collections API Changes\n\nList.copyOf, Set.copyOf, and Map.copyOf methods to create unmodifiable collections.\n\nCollectors class gets various methods for collecting unmodifiable collections (Set, List, Map). These method names are toUnmodifiableList, toUnmodifiableSet, and toUnmodifiableMap.\n\nLetâs look at an example of these new Java 10 Collections API methods usage.\n\npackage com.journaldev.collections; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors; public class JDK10CollectionFunctions { public static void main(String[] args) { List<String> actors = new ArrayList<>(); actors.add(\"Jack Nicholson\"); actors.add(\"Marlon Brando\"); System.out.println(actors); List<String> copyOfActors = List.copyOf(actors); System.out.println(copyOfActors); actors.add(\"Robert De Niro\"); System.out.println(actors); System.out.println(copyOfActors); List<String> collect = actors.stream().collect(Collectors.toUnmodifiableList()); System.out.println(collect); } }\n\nJava 11 Collections API Changes\n\nA new default method toArray(IntFunction<T[]> generator) added in the Collection interface. This method returns an array containing all of the elements in this collection, using the provided generator function to allocate the returned array.\n\npackage com.journaldev.collections; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class JDK11CollectionFunctions { public static void main(String[] args) { List<String> strList = new ArrayList<>(); strList.add(\"Java\"); strList.add(\"Python\"); strList.add(\"Android\"); String[] strArray = strList.toArray(size -> new String[size]); System.out.println(Arrays.toString(strArray)); strArray = strList.toArray(size -> new String[size + 5]); System.out.println(Arrays.toString(strArray)); strArray = strList.toArray(size -> new String[size * 3]); System.out.println(Arrays.toString(strArray)); } }\n\nOutput:\n\n[Java, Python, Android] [Java, Python, Android, null, null] [Java, Python, Android]\n\nCollection classes in a Nutshell\n\nBelow table provides basic details of commonly used collection classes.\n\nDownload URL: Java Collection Classes\n\nI hope this tutorial explained most of the topics in the Java collections framework. Please share your opinion with comments."
    }
}