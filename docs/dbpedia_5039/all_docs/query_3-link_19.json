{
    "id": "dbpedia_5039_3",
    "rank": 19,
    "data": {
        "url": "https://weaviate.io/developers/weaviate/config-refs/schema",
        "read_more_link": "",
        "language": "en",
        "title": "Weaviate - Vector Database",
        "top_image": "https://weaviate.io/og/docs/configuration.jpg",
        "meta_img": "https://weaviate.io/og/docs/configuration.jpg",
        "images": [
            "https://static.scarf.sh/a.png?x-pxid=a41b0758-a3a9-4874-a880-8b5d5a363d40",
            "https://px.ads.linkedin.com/collect/?pid=6758089&fmt=gif",
            "https://weaviate.io/img/site/weaviate-nav-logo-light.svg",
            "https://weaviate.io/img/site/weaviate-nav-logo-light.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Introduction",
        "meta_lang": "en",
        "meta_favicon": "/img/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://weaviate.io/developers/weaviate/config-refs/schema",
        "text": "Collection schema\n\nA collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\n\nAn example of a complete collection object including properties:\n\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\n\nMutable parameters\n\nReplication factor change in v1.25\n\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\n\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\n\ndescription\n\ninvertedIndexConfig\n\nbm25\n\nb\n\nk1\n\ncleanupIntervalSeconds\n\nstopwords\n\nadditions\n\npreset\n\nremovals\n\nreplicationConfig\n\nfactor (not mutable in v1.25)\n\nvectorIndexConfig\n\ndynamicEfFactor\n\ndynamicEfMin\n\ndynamicEfMax\n\nflatSearchCutoff\n\nskip\n\nvectorCacheMaxObjects\n\npq\n\ncentroids\n\nenabled\n\nsegments\n\ntrainingLimit\n\nencoder\n\ntype\n\ndistribution\n\nMultiTenancyConfig\n\nautoTenantCreation (introduced in v1.25.0)\n\nautoTenantActivation (introduced in v1.25.2)\n\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\n\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and can be disabled (e.g. in docker-compose.yml) by setting AUTOSCHEMA_ENABLED: 'false'.\n\nIt will:\n\nCreate a collection if an object is added to a non-existent collection.\n\nAdd any missing property from an object being added.\n\nInfer array data types, such as int[], text[], number[], boolean[], date[] and object[].\n\nInfer nested properties for object and object[] data types (introduced in v1.22.0).\n\nThrow an error if an object being added contains a property that conflicts with an existing schema type. (e.g. trying to import text into a field that exists in the schema as int).\n\nAdditional configurations are available to help the auto-schema infer properties to suit your needs.\n\nAUTOSCHEMA_DEFAULT_NUMBER=number - create number columns for any numerical values (as opposed to int, etc).\n\nAUTOSCHEMA_DEFAULT_DATE=date - create date columns for any date-like values.\n\nThe following are not allowed:\n\nAny map type is forbidden, unless it clearly matches one of the two supported types phoneNumber or geoCoordinates.\n\nAny array type is forbidden, unless it is clearly a reference-type. In this case, Weaviate needs to resolve the beacon and see what collection the resolved beacon is from, since it needs the collection name to be able to alter the schema.\n\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you use different vectorization models and apply different metrics to the same object.\n\nIf you use multiple vectors, adjust your queries to specify a target vector for vector or hybrid queries.\n\nAdding a property after importing objects can lead to limitations in inverted-index related behavior, such as filtering by the new property's length or null status.\n\nThis is caused by the inverted index being built at import time. If you add a property after importing objects, the inverted index for metadata such as the length or the null status will not be updated to include the new properties. This means that the new property will not be indexed for existing objects. This can lead to unexpected behavior when querying.\n\nTo avoid this, you can either:\n\nAdd the property before importing objects.\n\nDelete the collection, re-create it with the new property and then re-import the data.\n\nWe are working on a re-indexing API to allow you to re-index the data after adding a property. This will be available in a future release.\n\nThe class is the name of the collection.\n\nThe collection name starts with an upper case letter. The upper case letter distinguishes collection names from primitive data types when the name is used as a property value.\n\nConsider these examples that use the dataType property:\n\ndataType: [\"text\"] is a text data type.\n\ndataType: [\"Text\"] is a cross-reference type to a collection named Text.\n\nAfter the first letter, collection names may use any GraphQL-compatible characters.\n\nThe collection name validation regex is /^[A-Z][_0-9A-Za-z]*$/.\n\nA description of the collection. This is for your reference only.\n\nThis configures the inverted index for the collection.\n\nThe settings for BM25 are the free parameters k1 and b, and they are optional. The defaults (k1 = 1.2 and b = 0.75) work well for most cases.\n\nThey can be configured per collection, and can optionally be overridden per property:\n\ntext properties may contain words that are very common and don't contribute to search results. Ignoring them speeds up queries that contain stopwords, as they can be automatically removed from queries as well. This speed up is very notable on scored searches, such as BM25.\n\nThe stopword configuration uses a preset system. You can select a preset to use the most common stopwords for a particular language (e.g. \"en\" preset). If you need more fine-grained control, you can add additional stopwords or remove stopwords that you believe should not be part of the list. Alternatively, you can create your custom stopword list by starting with an empty (\"none\") preset and adding all your desired stopwords as additions.\n\nThis configuration allows stopwords to be configured by collection. If not set, these values are set to the following defaults:\n\nParameterDefault valueAcceptable values\"preset\"\"en\"\"en\", \"none\"\"additions\"[]any list of custom words\"removals\"[]any list of custom words\n\nAs of v1.18, stopwords are indexed. Thus stopwords are included in the inverted index, but not in the tokenized query. As a result, when the BM25 algorithm is applied, stopwords are ignored in the input for relevance ranking but will affect the score.\n\nStopwords can now be configured at runtime. You can use the RESTful API to update the list of stopwords after your data has been indexed.\n\nNote that stopwords are only removed when tokenization is set to word.\n\nBelow is an example request on how to update the list of stopwords:\n\nTo perform queries that are filtered by timestamps, configure the target collection to maintain an inverted index based on the objects' internal timestamps. Currently the timestamps include creationTimeUnix and lastUpdateTimeUnix.\n\nTo configure timestamp based indexing, set indexTimestamps to true in the invertedIndexConfig object.\n\nTo perform queries that filter on null, configure the target collection to maintain an inverted index that tracks null values for each property in a collection .\n\nTo configure null based indexing, setting indexNullState to true in the invertedIndexConfig object.\n\nTo perform queries that filter by the length of a property, configure the target collection to maintain an inverted index based on the length of the properties.\n\nTo configure indexing based on property length, set indexPropertyLength to true in the invertedIndexConfig object.\n\nThe vectorizer (\"vectorizer\": \"...\") can be specified per collection in the schema object. Check the modules page for available vectorizer modules.\n\nYou can use Weaviate without a vectorizer by setting \"vectorizer\": \"none\". This is useful if you want to upload your own vectors from a custom model (see how here), or if you want to create a collection without any vectors.\n\nThe vectorIndexType parameter controls the type of vector index that is used for this collection. The options are hnsw (default) and flat.\n\nThe vectorIndexConfig parameter controls the configuration of the vector index. The available parameters depend on the vectorIndexType that is used.\n\nSee the vector index configuration page for more details.\n\nThe \"shardingConfig\" controls how a collection is sharded and distributed across multiple nodes. All values are optional and default to the following settings:\n\nThese parameters are explained below:\n\n\"desiredCount\": integer, immutable, optional, defaults to the number of nodes in the cluster. This value controls how many shards should be created for this collection index. The typical setting is that a collection should be distributed across all the nodes in the cluster, but you can explicitly set this value to a lower value. If the \"desiredCount\" is larger than the amount of physical nodes in the cluster, then some nodes will contain multiple shards.\n\n\"actualCount\": integer, read-only. Typically matches desired count, unless there was a problem initiating the shards at creation time.\n\n\"virtualPerPhysical\": integer, immutable, optional, defaults to 128. Weaviate uses virtual shards. This helps in reducing the amount of data moved when resharding.\n\n\"desiredVirtualCount\": integer, readonly. Matches desiredCount * virtualPerPhysical\n\n\"actualVirtualCount\": integer, readonly. Like actualCount, but for virtual shards, instead of physical.\n\n\"strategy\": string, optional, immutable. Only supports \"hash\". This value controls how Weaviate should decide which (virtual - and therefore physical) shard a new object belongs to. The hash is performed on the field specified in \"key\".\n\n\"key\": string, optional, immutable. Only supports \"_id\". This value controls the partitioning key that is used for the hashing function to determine the target shard. As of now, only the internal id-field (containing the object's UUID) can be used to determine the target shard. Custom keys may be supported at a later point.\n\n\"function\": string, optional, immutable. Only \"murmur3\" is supported as a hashing function. It describes the hashing function used on the \"key\" property to determine the hash which in turn determines the target (virtual - and therefore physical) shard. \"murmur3\" creates a 64bit hash making hash collisions very unlikely.\n\nReplication configurations can be set using the schema, through the replicationConfig parameter.\n\nThe factor parameter sets the number of copies of to be stored for objects in this collection.\n\nThe multiTenancyConfig value determines if multi-tenancy is enabled for this collection. If enabled, objects of this collection will be isolated for each tenant. It is disabled by default.\n\nTo enable it, set the enabled key to true, as shown below:\n\nProperties define the data structure of objects to be stored and indexed. For each property in the collection, you must specify at least the name and its dataType.\n\nProperty names can contain the following characters: /[_A-Za-z][_0-9A-Za-z]*/.\n\nAn example of a complete property object:\n\nThe following words are reserved and cannot be used as property names:\n\n_additional\n\nid\n\n_id\n\nAdditionally, we strongly recommend that you do not use the following words as property names, due to potential conflicts with future reserved words:\n\nvector\n\n_vector\n\nYou can customize how text data is tokenized and indexed in the inverted index. Tokenization influences the results returned by the bm25 and hybrid operators, and where filters.\n\nTokenization is a property-level configuration for text properties. See how to set the tokenization option using a client library\n\nExample property configuration\n\n{\n\n\"classes\":[\n\n{\n\n\"class\":\"Question\",\n\n\"properties\":[\n\n{\n\n\"dataType\":[\"text\"],\n\n\"name\":\"question\",\n\n\"tokenization\":\"word\"\n\n},\n\n],\n\n...\n\n\"vectorizer\":\"text2vec-openai\"\n\n}\n\n]\n\n}\n\nEach token will be indexed separately in the inverted index. For example, if you have a text property with the value Hello, (beautiful) world, the following table shows how the tokens would be indexed for each tokenization method:\n\nTokenization MethodExplanationIndexed Tokensword (default)Keep only alpha-numeric characters, lowercase them, and split by whitespace.hello, beautiful, worldlowercaseLowercase the entire text and split on whitespace.hello,, (beautiful), worldwhitespaceSplit the text on whitespace. Searches/filters become case-sensitive.Hello,, (beautiful), worldfieldIndex the whole field after trimming whitespace characters.Hello, (beautiful) worldtrigramSplit the property as rolling trigrams.Hel, ell, llo, lo,, ...gseUse the gse tokenizer to split the property.See gse docskagome_krUse the Kagome tokenizer with a Korean dictionary to split the property.See kagome docs and the Korean dictionary\n\nTokenization impacts how filters or keywords searches behave. The filter or keyword search query is also tokenized before being matched against the inverted index.\n\nThe following table shows an example scenario showing whether a filter or keyword search would identify a text property with value Hello, (beautiful) world as a hit.\n\nRow: Various tokenization methods.\n\nColumn: Various search strings.\n\nBeautiful(Beautiful)(beautiful)Hello, (beautiful) worldword (default)✅✅✅✅lowercase❌✅✅✅whitespace❌❌✅✅field❌❌❌✅\n\nFor Japanese and Chinese text, we recommend use of gse or trigram tokenization methods. These methods work better with these languages than the other methods as these languages are not easily able to be tokenized using whitespaces.\n\nThe gse tokenizer is not loaded by default to save resources. To use it, set the environment variable ENABLE_TOKENIZER_GSE to true on the Weaviate instance.\n\ngse tokenization examples:\n\n\"素早い茶色の狐が怠けた犬を飛び越えた\": [\"素早\", \"素早い\", \"早い\", \"茶色\", \"の\", \"狐\", \"が\", \"怠け\", \"けた\", \"犬\", \"を\", \"飛び\", \"飛び越え\", \"越え\", \"た\", \"素早い茶色の狐が怠けた犬を飛び越えた\"]\n\n\"すばやいちゃいろのきつねがなまけたいぬをとびこえた\": [\"すばや\", \"すばやい\", \"やい\", \"いち\", \"ちゃ\", \"ちゃい\", \"ちゃいろ\", \"いろ\", \"のき\", \"きつ\", \"きつね\", \"つね\", \"ねが\", \"がな\", \"なま\", \"なまけ\", \"まけ\", \"けた\", \"けたい\", \"たい\", \"いぬ\", \"を\", \"とび\", \"とびこえ\", \"こえ\", \"た\", \"すばやいちゃいろのきつねがなまけたいぬをとびこえた\"]\n\nFor Korean text, we recommend use of the kagome_kr tokenization method. This uses the Kagome tokenizer with a Korean MeCab (mecab-ko-dic) dictionary to split the property text.\n\nThe kagome_kr tokenizer is not loaded by default to save resources. To use it, set the environment variable ENABLE_TOKENIZER_KAGOME_KR to true on the Weaviate instance.\n\nkagome_kr tokenization examples:\n\n\"아버지가방에들어가신다\": [\"아버지\", \"가\", \"방\", \"에\", \"들어가\", \"신다\"]\n\n\"아버지가 방에 들어가신다\": [\"아버지\", \"가\", \"방\", \"에\", \"들어가\", \"신다\"]\n\n\"결정하겠다\": [\"결정\", \"하\", \"겠\", \"다\"]\n\nMultiple inverted index types are available in Weaviate. Not all inverted index types are available for all data types. The available inverted index types are:\n\nInverted index typeDescriptionApplicable data typesDefaultAvailabilityindexSearchableA searchable index for BM25-suitable Map index for BM25 or hybrid searching.text, text[],truev1.19indexFilterableA Roaring Bitmap index for match-based filtering.Everything except blob, geoCoordinates, object and phoneNumber data types including arrays thereoftruev1.19indexRangeFiltersA Roaring Bitmap index for numerical range-based filtering.int, number and date onlyfalsev1.26\n\nEnable one or both of indexFilterable and indexRangeFilters to index a property for faster filtering.\n\nIf only one is enabled, the respective index is used for filtering.\n\nIf both are enabled, indexRangeFilters is used for operations involving comparison operators, and indexFilterable is used for equality and inequality operations.\n\nWeaviate generates vector embeddings at the object level (rather than for individual properties). For instance text2vec-* modules can generate vectors from text objects. To produce the string to be vectorized from each object, Weaviate follows the schema configuration for the relevant class.\n\nUnless specified otherwise in the schema, the default behavior is to:\n\nOnly vectorize properties that use the text data type (unless skipped)\n\nSort properties in alphabetical (a-z) order before concatenating values\n\nIf vectorizePropertyName is true (false by default) prepend the property name to each property value\n\nJoin the (prepended) property values with spaces\n\nPrepend the class name (unless vectorizeClassName is false)\n\nConvert the produced string to lowercase\n\nFor example, this data object,\n\nwill be vectorized as:\n\nBy default, the calculation includes the collection name and all property values, but the property names are not indexed.\n\nTo configure vectorization behavior on a per-collection basis, use vectorizeClassName.\n\nTo configure vectorization on a per-property basis, use skip and vectorizePropertyName.\n\nWeaviate allows you to configure the DEFAULT_VECTOR_DISTANCE_METRIC which will be applied to every collection unless overridden individually. You can choose from: cosine (default), dot, l2-squared, manhattan, hamming.\n\nTutorial: Schema\n\nHow to: Configure a schema\n\nReferences: REST API: Schema\n\nConcepts: Data Structure\n\nIf you have any questions or feedback, let us know in the user forum."
    }
}