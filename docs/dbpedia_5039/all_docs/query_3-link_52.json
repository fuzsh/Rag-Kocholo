{
    "id": "dbpedia_5039_3",
    "rank": 52,
    "data": {
        "url": "https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/gathering-optimizer-statistics.html",
        "read_more_link": "",
        "language": "en",
        "title": "Gathering Optimizer Statistics",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/img/edit_window.jpg",
            "https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/img/tgsql_vm_036.png",
            "https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/img/tgsql_vm_074.png",
            "https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/img/tgsql_vm_075.png",
            "https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/img/mm-3242_tgsql_pb_001b.png",
            "https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/img/mm-3242_tgsql_pb_002b.png",
            "https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/img/tgsql_vm_019.png",
            "https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/img/report_gs_oe.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "optimizer statistics",
            "gathering",
            "statistics",
            "optimizer",
            "automatic collection",
            "pluggable databases",
            "automatic optimizer statistics collection",
            "pluggable databases and",
            "manageability features",
            "automatic statistics collection",
            "high-frequency automatic optimizer statistics collection",
            "configuring",
            "optimizer statistics collection",
            "high-frequency collection",
            "about",
            "enabling",
            "gathering manually",
            "manual collection",
            "DBMS_STATS package",
            "partitioned objects",
            "guideline for gathering statistics",
            "partitioned tables",
            "guideline for gathering external table",
            "external tables",
            "guideline for gathering optimizer statistics",
            "guideline for external tables",
            "FLUSH_DATABASE_MONITORING_INFO procedure",
            "DBA_TAB_MODIFICATIONS view",
            "DBA_IND_STATISTICS view",
            "DBA_TAB_STATISTICS view",
            "determining staleness",
            "fixed objects",
            "gathering statistics for",
            "dynamic statistics",
            "dynamic",
            "concurrent statistics gathering",
            "gathering concurrently",
            "ORA$AUTOTASK consumer group",
            "Database Resource Manager",
            "DBA_OPTSTAT_OPERATIONS view",
            "DBA_OPTSTAT_OPERATION_TASKS view",
            "monitoring collection",
            "gathering incremental statistics",
            "incremental",
            "incremental statistics",
            "maintenance",
            "global statistics",
            "synopses",
            "adaptive query optimization",
            "adaptive statistics",
            "adaptive sampling",
            "HyperLogLog algorithm",
            "gathering statistics",
            "considerations",
            "partitioning",
            "maintenance operations",
            "system",
            "CPU",
            "system statistics",
            "I/O",
            "workload",
            "noworkload",
            "deleting",
            "reporting mode"
        ],
        "tags": null,
        "authors": [
            "Hermann Baer",
            "Bjorn Bolltoft",
            "Ali Cakmak",
            "Sunil Chakkappen",
            "Immanuel Chan",
            "Deba Chatterjee",
            "Chris Chiappa",
            "Dinesh Das",
            "Kurt Engeleiter",
            "Leonidas Galanis"
        ],
        "publish_date": "2023-03-31T20:18:50+00:00",
        "summary": "",
        "meta_description": "This chapter explains how to use the DBMS_STATS.GATHER_*_STATS program units.",
        "meta_lang": "en",
        "meta_favicon": "/sp_common/book-template/ohc-common/img/favicon.ico",
        "meta_site_name": "Oracle Help Center",
        "canonical_link": null,
        "text": "Previous Next JavaScript must be enabled to correctly display this content\n\nSQL Tuning Guide\n\nOptimizer Statistics\n\nGathering Optimizer Statistics\n\n13 Gathering Optimizer Statistics\n\nThis chapter explains how to use the DBMS_STATS.GATHER_*_STATS program units.\n\nSee Also:\n\n\"Optimizer Statistics Concepts\"\n\n\"Query Optimizer Concepts\"\n\nOracle Database PL/SQL Packages and Types Reference to learn about DBMS_STATS.GATHER_TABLE_STATS\n\n13.1 Configuring Automatic Optimizer Statistics Collection\n\nOracle Database can gather optimizer statistics automatically.\n\n13.1.1 About Automatic Optimizer Statistics Collection\n\nThe automated maintenance tasks infrastructure (known as AutoTask) schedules tasks to run automatically in Oracle Scheduler windows known as maintenance windows.\n\nDifference Between Automatic and Manual Statistics Collection\n\nThe principal difference is that automatic collection prioritizes database objects that need statistics. Before the maintenance window closes, automatic collection assesses all objects and prioritizes objects that have no statistics or very old statistics.\n\nWhen gathering statistics manually, you can reproduce the object prioritization of automatic collection by using the DBMS_AUTO_TASK_IMMEDIATE package. This package runs the same statistics gathering job that is executed during the automatic nightly statistics gathering job.\n\nHow Automatic Statistics Collection Works\n\nAutomatic optimizer statistics collection runs as part of AutoTask. By default, the collection runs in all predefined maintenance windows. One window is scheduled for each day of the week.\n\nTo collect the optimizer statistics, the database calls an internal procedure that operates similarly to the GATHER_DATABASE_STATS procedure with the GATHER AUTO option. Automatic statistics collection honors all preferences set in the database.\n\nWhen an automatic optimizer statistics collection task gathers data for a PDB, it stores this data in the PDB. This data is included if the PDB is unplugged. A common user whose current container is the CDB root can view optimizer statistics data for PDBs. A user whose current container is a PDB can view optimizer statistics data for the PDB only.\n\n13.1.2 Configuring Automatic Optimizer Statistics Collection Using Cloud Control\n\nYou can enable and disable all automatic maintenance tasks, including automatic optimizer statistics collection, using Cloud Control.\n\nThe default window timing works well for most situations. However, you may have operations such as bulk loads that occur during the window. In such cases, to avoid potential conflicts that result from operations occurring at the same time as automatic statistics collection, Oracle recommends that you change the window accordingly.\n\nPrerequisites\n\nAccess the Database Home page, as described in \"Accessing the Database Home Page in Cloud Control.\"\n\nTo control automatic optimizer statistics collection using Cloud Control:\n\nFrom the Administration menu, select Oracle Scheduler, then Automated Maintenance Tasks.\n\nThe Automated Maintenance Tasks page appears.\n\nThis page shows the predefined tasks. To retrieve information about each task, click the corresponding link for the task.\n\nClick Configure.\n\nThe Automated Maintenance Tasks Configuration page appears.\n\nBy default, automatic optimizer statistics collection executes in all predefined maintenance windows in MAINTENANCE_WINDOW_GROUP.\n\nPerform the following steps:\n\nIn the Task Settings section for Optimizer Statistics Gathering, select either Enabled or Disabled to enable or disable an automated task.\n\nNote:\n\nOracle strongly recommends that you not disable automatic statistics gathering because it is critical for the optimizer to generate optimal plans for queries against dictionary and user objects. If you disable automatic collection, ensure that you have a good manual statistics collection strategy for dictionary and user schemas.\n\nTo disable statistics gathering for specific days in the week, check the appropriate box next to the window name.\n\nTo change the characteristics of a window group, click Edit Window Group.\n\nTo change the times for a window, click the name of the window (for example, MONDAY_WINDOW), and then in the Schedule section, click Edit.\n\nThe Edit Window page appears.\n\nIn this page, you can change the parameters such as duration and start time for window execution.\n\nClick Apply.\n\nSee Also:\n\nOnline Help for Oracle Enterprise Manager Cloud Control\n\n13.1.3 Configuring Automatic Optimizer Statistics Collection from the Command Line\n\nIf you do not use Cloud Control to configure automatic optimizer statistics collection, then you must use the command line.\n\nYou have the following options:\n\nRun the ENABLE or DISABLE procedure in the DBMS_AUTO_TASK_ADMIN PL/SQL package.\n\nThis package is the recommended command-line technique. For both the ENABLE and DISABLE procedures, you can specify a particular maintenance window with the window_name parameter.\n\nSet the STATISTICS_LEVEL initialization level to BASIC to disable collection of all advisories and statistics, including Automatic SQL Tuning Advisor.\n\nNote:\n\nBecause monitoring and many automatic features are disabled, Oracle strongly recommends that you do not set STATISTICS_LEVEL to BASIC.\n\nTo control automatic statistics collection using DBMS_AUTO_TASK_ADMIN:\n\nIn SQL*Plus or SQL Developer, log in to the database as a user with administrative privileges.\n\nDo one of the following:\n\nTo enable the automated task, execute the following PL/SQL block:\n\nBEGIN DBMS_AUTO_TASK_ADMIN.ENABLE ( client_name => 'auto optimizer stats collection' , operation => NULL , window_name => NULL ); END; /\n\nTo disable the automated task, execute the following PL/SQL block:\n\nBEGIN DBMS_AUTO_TASK_ADMIN.DISABLE ( client_name => 'auto optimizer stats collection' , operation => NULL , window_name => NULL ); END; /\n\nQuery the data dictionary to confirm the change.\n\nFor example, query DBA_AUTOTASK_CLIENT as follows:\n\nCOL CLIENT_NAME FORMAT a31 SELECT CLIENT_NAME, STATUS FROM DBA_AUTOTASK_CLIENT WHERE CLIENT_NAME = 'auto optimizer stats collection';\n\nSample output appears as follows:\n\nCLIENT_NAME STATUS ------------------------------- -------- auto optimizer stats collection ENABLED\n\nTo change the window attributes for automatic statistics collection:\n\nConnect SQL*Plus to the database with administrator privileges.\n\nChange the attributes of the maintenance window as needed.\n\nFor example, to change the Monday maintenance window so that it starts at 5 a.m., execute the following PL/SQL program:\n\nBEGIN DBMS_SCHEDULER.SET_ATTRIBUTE ( 'MONDAY_WINDOW' , 'repeat_interval' , 'freq=daily;byday=MON;byhour=05;byminute=0;bysecond=0' ); END; /\n\nSee Also:\n\nOracle Database PL/SQL Packages and Types Reference to learn about the DBMS_AUTO_TASK_ADMIN package\n\nOracle Database Reference to learn about the STATISTICS_LEVEL initialization parameter\n\n13.2 Configuring High-Frequency Automatic Optimizer Statistics Collection\n\nThis lightweight task supplements standard automatic statistics collection.\n\n13.2.1 About High-Frequency Automatic Optimizer Statistics Collection\n\nYou can configure automatic statistics collection to occur more frequently.\n\nPurpose of High-Frequency Automatic Optimizer Statistics Collection\n\nAutoTask schedules tasks to run automatically in maintenance windows. By default, one window is scheduled for each day of the week. Automatic optimizer statistics collection (DBMS_STATS) runs in all predefined maintenance windows.\n\nStatistics can go stale between two consecutive statistics collection tasks. If data changes frequently, the stale statistics could cause performance problems. For example, a brokerage company might receive tremendous data during trading hours, leading the optimizer to use stale statistics for queries executed during this period.\n\nHigh-frequency automatic optimizer statistics collection complements the standard statistics collection job. By default, the collection occurs every 15 minutes, meaning that statistics have less time in which to be stale.\n\nHow High-Frequency Automatic Optimizer Statistics Collection Works\n\nTo enable and disable the high-frequency task, set the execution interval, and set the maximum run time, use the DBMS_STATS.SET_GLOBAL_PREFS procedure. The high-frequency task is âlightweightâ and only gathers stale statistics. It does not perform actions such as purging statistics for non-existent objects or invoking Optimizer Statistics Advisor. The standard automated job performs these additional tasks.\n\nAutomatic statistics collection jobs that run in the maintenance window are not affected by the high-frequency jobs. The high-frequency task may execute in maintenance windows, but it will not execute while the maintenance window auto stats gathering job is executing. You can monitor the tasks by querying DBA_AUTO_STAT_EXECUTIONS.\n\n13.2.2 Setting Preferences for High-Frequency Automatic Optimizer Statistics Collection\n\nTo enable and disable the task, use DBMS_STATS.SET_GLOBAL_PREFS.\n\nYou can use DBMS_STATS.SET_GLOBAL_PREFS to set preferences to any of the following values:\n\nAUTO_TASK_STATUS\n\nEnables or disables the high-frequency automatic optimizer statistics collection. Values are:\n\nON â Enables high-frequency automatic optimizer statistics collection.\n\nOFF â Disables high-frequency automatic optimizer statistics collection. This is the default.\n\nAUTO_TASK_MAX_RUN_TIME\n\nConfigures the maximum run time in seconds of an execution of high-frequency automatic optimizer statistics collection. The maximum value is 3600 (equal to 1 hour), which is the default.\n\nAUTO_TASK_INTERVAL\n\nSpecifies the interval in seconds between executions of high-frequency automatic optimizer statistics collection. The minimum value is 60. The default is 900 (equal to 15 minutes).\n\nTo configure the high-frequency task, you must have administrator privileges.\n\nTo configure the high-frequency task:\n\nLog in to the database as a user with administrator privileges.\n\nTo enable the high-frequency task, set the AUTO_TASK_STATUS preference to ON.\n\nThe following example enables the automatic task:\n\nEXEC DBMS_STATS.SET_GLOBAL_PREFS('AUTO_TASK_STATUS','ON');\n\nTo set the maximum run time, set the AUTO_TASK_MAX_RUN_TIME preference to the desired number of seconds.\n\nThe following example sets the maximum run time to 10 minutes:\n\nEXEC DBMS_STATS.SET_GLOBAL_PREFS('AUTO_TASK_MAX_RUN_TIME','600');\n\nTo set the frequency, set the AUTO_TASK_INTERVAL preference to the desired number of seconds.\n\nThe following example sets the frequency to 8 minutes:\n\nEXEC DBMS_STATS.SET_GLOBAL_PREFS('AUTO_TASK_INTERVAL','240');\n\n13.2.3 High-Frequency Automatic Optimizer Statistics Collection: Example\n\nIn this example, you enable run DML statements, and then enable the high-frequency statistics collection job.\n\nThis example assumes the following:\n\nYou are logged in to the database as an administrator.\n\nThe statistics for the sh schema are fresh.\n\nHigh-frequency automatic optimizer statistics collection\n\nis not enabled.\n\nQuery the data dictionary for the statistics for the sales and customers tables (sample output included):\n\nSET LINESIZE 170 SET PAGESIZE 5000 COL TABLE_NAME FORMAT a20 COL PARTITION_NAME FORMAT a20 COL NUM_ROWS FORMAT 9999999 COL STALE_STATS FORMAT a3 SELECT TABLE_NAME, PARTITION_NAME, NUM_ROWS, STALE_STATS FROM DBA_TAB_STATISTICS WHERE OWNER = 'SH' AND TABLE_NAME IN ('CUSTOMERS','SALES') ORDER BY TABLE_NAME, PARTITION_NAME; TABLE_NAME PARTITION_NAME NUM_ROWS STA -------------------- -------------------- -------- --- CUSTOMERS 55500 NO SALES SALES_1995 0 NO SALES SALES_1996 0 NO SALES SALES_H1_1997 0 NO SALES SALES_H2_1997 0 NO SALES SALES_Q1_1998 43687 NO SALES SALES_Q1_1999 64186 NO SALES SALES_Q1_2000 62197 NO SALES SALES_Q1_2001 60608 NO SALES SALES_Q1_2002 0 NO SALES SALES_Q1_2003 0 NO SALES SALES_Q2_1998 35758 NO SALES SALES_Q2_1999 54233 NO SALES SALES_Q2_2000 55515 NO SALES SALES_Q2_2001 63292 NO SALES SALES_Q2_2002 0 NO SALES SALES_Q2_2003 0 NO SALES SALES_Q3_1998 50515 NO SALES SALES_Q3_1999 67138 NO SALES SALES_Q3_2000 58950 NO SALES SALES_Q3_2001 65769 NO SALES SALES_Q3_2002 0 NO SALES SALES_Q3_2003 0 NO SALES SALES_Q4_1998 48874 NO SALES SALES_Q4_1999 62388 NO SALES SALES_Q4_2000 55984 NO SALES SALES_Q4_2001 69749 NO SALES SALES_Q4_2002 0 NO SALES SALES_Q4_2003 0 NO SALES 918843 NO\n\nThe preceding output shows that none of the statistics are stale.\n\nPerform DML on sales and customers:\n\n-- insert 918K rows in sales INSERT INTO sh.sales SELECT * FROM sh.sales; -- update around 15% of sales rows UPDATE sh.sales SET amount_sold = amount_sold + 1 WHERE amount_sold > 100; -- insert 1 row into customers INSERT INTO sh.customers(cust_id, cust_first_name, cust_last_name, cust_gender, cust_year_of_birth, cust_main_phone_number, cust_street_address, cust_postal_code, cust_city_id, cust_city, cust_state_province_id, cust_state_province, country_id, cust_total, cust_total_id) VALUES(188710, 'Jenny', 'Smith', 'F', '1966', '555-111-2222', '400 oracle parkway','94065',51402, 'Redwood Shores', 52564, 'CA', 52790, 'Customer total', '52772'); COMMIT;\n\nThe total number of sales rows increased by 100%, but only 1 row was added to customers.\n\nSave the optimizer statistics to disk:\n\nEXEC DBMS_STATS.FLUSH_DATABASE_MONITORING_INFO;\n\nQuery the table statistics again (sample output included):\n\nSELECT TABLE_NAME, PARTITION_NAME, NUM_ROWS, STALE_STATS FROM DBA_TAB_STATISTICS WHERE OWNER = 'SH' AND TABLE_NAME IN ('CUSTOMERS','SALES') ORDER BY TABLE_NAME, PARTITION_NAME; TABLE_NAME PARTITION_NAME NUM_ROWS STA -------------------- -------------------- -------- --- CUSTOMERS 55500 NO SALES SALES_1995 0 NO SALES SALES_1996 0 NO SALES SALES_H1_1997 0 NO SALES SALES_H2_1997 0 NO SALES SALES_Q1_1998 43687 YES SALES SALES_Q1_1999 64186 YES SALES SALES_Q1_2000 62197 YES SALES SALES_Q1_2001 60608 YES SALES SALES_Q1_2002 0 NO SALES SALES_Q1_2003 0 NO SALES SALES_Q2_1998 35758 YES SALES SALES_Q2_1999 54233 YES SALES SALES_Q2_2000 55515 YES SALES SALES_Q2_2001 63292 YES SALES SALES_Q2_2002 0 NO SALES SALES_Q2_2003 0 NO SALES SALES_Q3_1998 50515 YES SALES SALES_Q3_1999 67138 YES SALES SALES_Q3_2000 58950 YES SALES SALES_Q3_2001 65769 YES SALES SALES_Q3_2002 0 NO SALES SALES_Q3_2003 0 NO SALES SALES_Q4_1998 48874 YES SALES SALES_Q4_1999 62388 YES SALES SALES_Q4_2000 55984 YES SALES SALES_Q4_2001 69749 YES SALES SALES_Q4_2002 0 NO SALES SALES_Q4_2003 0 NO SALES 1837686 SALES 918843 YES 31 rows selected.\n\nThe preceding output shows that the statistics are not stale for customers but are stale for sales.\n\nConfigure high-frequency automatic optimizer statistics collection:\n\nEXEC DBMS_STATS.SET_GLOBAL_PREFS('AUTO_TASK_STATUS','ON'); EXEC DBMS_STATS.SET_GLOBAL_PREFS('AUTO_TASK_MAX_RUN_TIME','180'); EXEC DBMS_STATS.SET_GLOBAL_PREFS('AUTO_TASK_INTERVAL','240');\n\nThe preceding PL/SQL programs enable high-frequency collection, set the maximum run time to 3 minutes, and set the task execution interval to 4 minutes.\n\nWait for a few minutes, and then query the data dictionary:\n\nCOL OPID FORMAT 9999 COL STATUS FORMAT a11 COL ORIGIN FORMAT a20 COL COMPLETED FORMAT 99999 COL FAILED FORMAT 99999 COL TIMEOUT FORMAT 99999 COL INPROG FORMAT 99999 SELECT OPID, ORIGIN, STATUS, TO_CHAR(START_TIME, 'DD/MM HH24:MI:SS' ) AS BEGIN_TIME, TO_CHAR(END_TIME, 'DD/MM HH24:MI:SS') AS END_TIME, COMPLETED, FAILED, TIMED_OUT AS TIMEOUT, IN_PROGRESS AS INPROG FROM DBA_AUTO_STAT_EXECUTIONS ORDER BY OPID;\n\nThe output shows that the high-frequency job executed twice, and the standard automatic statistics collection job executed once:\n\nID ORIGIN STATUS BEGIN_TIME END_TIME COMP FAIL TIMEO INPRO --- -------------------- -------- -------------- -------------- ---- ---- ----- ----- 790 HIGH_FREQ_AUTO_TASK COMPLETE 03/10 14:54:02 03/10 14:54:35 338 3 0 0 793 HIGH_FREQ_AUTO_TASK COMPLETE 03/10 14:58:11 03/10 14:58:45 193 3 0 0 794 AUTO_TASK COMPLETE 03/10 15:00:02 03/10 15:00:20 52 3 0 0\n\n13.3 Gathering Optimizer Statistics Manually\n\nAs an alternative or supplement to automatic statistics gathering, you can use the DBMS_STATS package to gather optimizer statistics manually.\n\nSee Also:\n\n\"Configuring Automatic Optimizer Statistics Collection\"\n\nOracle Database PL/SQL Packages and Types Reference to learn about the DBMS_STATS package\n\n13.3.1 About Manual Statistics Collection with DBMS_STATS\n\nUse the DBMS_STATS package to manipulate optimizer statistics. You can gather statistics on objects and columns at various levels of granularity: object, schema, and database. You can also gather statistics for the physical system.\n\nThe following table summarizes the DBMS_STATS procedures for gathering optimizer statistics. This package does not gather statistics for table clusters. However, you can gather statistics on individual tables in a table cluster.\n\nTable 13-1 DBMS_STATS Procedures for Gathering Optimizer Statistics\n\nProcedure Purpose\n\nWhen the OPTIONS parameter is set to GATHER STALE or GATHER AUTO, the GATHER_SCHEMA_STATS and GATHER_DATABASE_STATS procedures gather statistics for any table that has stale statistics and any table that is missing statistics. If a monitored table has been modified more than 10%, then the database considers these statistics stale and gathers them again.\n\nNote:\n\nAs explained in \"Configuring Automatic Optimizer Statistics Collection\", you can configure a nightly job to gather statistics automatically.\n\nSee Also:\n\n\"Gathering System Statistics Manually\"\n\nOracle Database PL/SQL Packages and Types Reference to learn more about the DBMS_STATS package\n\n13.3.2 Guidelines for Gathering Optimizer Statistics Manually\n\nIn most cases, automatic statistics collection is sufficient for database objects modified at a moderate speed.\n\nAutomatic collection may sometimes be inadequate or unavailable, as shown in the following table.\n\nTable 13-2 Reasons for Gathering Statistics Manually\n\nIssue To Learn More You perform certain types of bulk load and cannot wait for the maintenance window to collect statistics because queries must be executed immediately. \"Online Statistics Gathering for Bulk Loads\" During a nonrepresentative workload, automatic statistics collection gathers statistics for fixed tables. \"Gathering Statistics for Fixed Objects\" Automatic statistics collection does not gather system statistics. \"Gathering System Statistics Manually\" Volatile tables are being deleted or truncated, and then rebuilt during the day. \"Gathering Statistics for Volatile Tables Using Dynamic Statistics\"\n\n13.3.2.1 Guideline for Setting the Sample Size\n\nIn the context of optimizer statistics, sampling is the gathering of statistics from a random subset of table rows. By enabling the database to avoid full table scans and sorts of entire tables, sampling minimizes the resources necessary to gather statistics.\n\nThe database gathers the most accurate statistics when it processes all rows in the table, which is a 100% sample. However, larger sample sizes increase the time of statistics gathering operations. The challenge is determining a sample size that provides accurate statistics in a reasonable time.\n\nDBMS_STATS uses sampling when a user specifies the parameter ESTIMATE_PERCENT, which controls the percentage of the rows in the table to sample. To maximize performance gains while achieving necessary statistical accuracy, Oracle recommends that the ESTIMATE_PERCENT parameter use the default setting of DBMS_STATS.AUTO_SAMPLE_SIZE. In this case, Oracle Database chooses the sample size automatically. This setting enables the use of the following:\n\nA hash-based algorithm that is much faster than sampling\n\nThis algorithm reads all rows and produces statistics that are nearly as accurate as statistics from a 100% sample. The statistics computed using this technique are deterministic.\n\nIncremental statistics\n\nConcurrent statistics\n\nNew histogram types\n\nThe DBA_TABLES.SAMPLE_SIZE column indicates the actual sample size used to gather statistics.\n\nSee Also:\n\n\"Hybrid Histograms\"\n\nOracle Database PL/SQL Packages and Types Reference to learn more about DBMS_STATS.AUTO_SAMPLE_SIZE\n\n13.3.2.2 Guideline for Gathering Statistics in Parallel\n\nBy default, the database gathers statistics with the parallelism degree specified at the table or index level.\n\nYou can override this setting with the degree argument to the DBMS_STATS gathering procedures. Oracle recommends setting degree to DBMS_STATS.AUTO_DEGREE. This setting enables the database to choose an appropriate degree of parallelism based on the object size and the settings for the parallelism-related initialization parameters.\n\nThe database can gather most statistics serially or in parallel. However, the database does not gather some index statistics in parallel, including cluster indexes, domain indexes, and bitmap join indexes. The database can use sampling when gathering parallel statistics.\n\nNote:\n\nDo not confuse gathering statistics in parallel with gathering statistics concurrently.\n\nSee Also:\n\n\"About Concurrent Statistics Gathering\"\n\nOracle Database PL/SQL Packages and Types Reference to learn more about DBMS_STATS.AUTO_DEGREE\n\n13.3.2.3 Guideline for Partitioned Objects\n\nFor partitioned tables and indexes, DBMS_STATS can gather separate statistics for each partition and global statistics for the entire table or index.\n\nSimilarly, for composite partitioning, DBMS_STATS can gather separate statistics for subpartitions, partitions, and the entire table or index.\n\nTo determine the type of partitioning statistics to be gathered, specify the granularity argument to the DBMS_STATS procedures. Oracle recommends setting granularity to the default value of AUTO to gather subpartition, partition, or global statistics, depending on partition type. The ALL setting gathers statistics for all types.\n\nSee Also:\n\n\"Gathering Incremental Statistics on Partitioned Objects\"\n\n13.3.2.4 Guideline for Frequently Changing Objects\n\nWhen tables are frequently modified, gather statistics often enough so that they do not go stale, but not so often that collection overhead degrades performance.\n\nYou may only need to gather new statistics every week or month. The best practice is to use a script or job scheduler to regularly run the DBMS_STATS.GATHER_SCHEMA_STATS and DBMS_STATS.GATHER_DATABASE_STATS procedures.\n\n13.3.2.5 Guideline for External Tables\n\nBecause the database does not permit data manipulation against external tables, the database never marks statistics on external tables as stale. If new statistics are required for an external table, for example, because the underlying data files change, then regather the statistics.\n\nFor external tables, use the same DBMS_STATS procedures that you use for internal tables. Note that the scanrate parameter of DBMS_STATS.SET_TABLE_STATS and DBMS_STATS.GET_TABLE_STATS specifies the rate (in MB/s) at which Oracle Database scans data in tables, and is relevant only for external tables. The SCAN_RATE column appears in the DBA_TAB_STATISTICS and DBA_TAB_PENDING_STATS data dictionary views.\n\nSee Also:\n\n\"Creating Artificial Optimizer Statistics for Testing\"\n\nOracle Database PL/SQL Packages and Types Reference to learn about SET_TABLE_STATS and GET_TABLE_STATS\n\nOracle Database Reference to learn about the DBA_TAB_STATISTICS view\n\n13.3.3 Determining When Optimizer Statistics Are Stale\n\nStale statistics on a table do not accurately reflect its data. To help you determine when a database object needs new statistics, the database provides a table monitoring facility.\n\nMonitoring tracks the approximate number of DML operations on a table and whether the table has been truncated since the most recent statistics collection. To check whether statistics are stale, query the STALE_STATS column in DBA_TAB_STATISTICS and DBA_IND_STATISTICS. This column is based on data in the DBA_TAB_MODIFICATIONS view and the STALE_PERCENT preference for DBMS_STATS.\n\nNote:\n\nStarting in Oracle Database 12c Release 2 (12.2), you no longer need to use DBMS_STATS.FLUSH_DATABASE_MONITORING_INFO to ensure that view metadata is current. The statistics shown in the DBA_TAB_STATISTICS, DBA_IND_STATISTICS, and DBA_TAB_MODIFICATIONS views are obtained from both disk and memory.\n\nThe STALE_STATS column has the following possible values:\n\nYES\n\nThe statistics are stale.\n\nNO\n\nThe statistics are not stale.\n\nnull\n\nThe statistics are not collected.\n\nExecuting GATHER_SCHEMA_STATS or GATHER_DATABASE_STATS with the GATHER AUTO option collects statistics only for objects with no statistics or stale statistics.\n\nTo determine stale statistics:\n\nStart SQL*Plus, and then log in to the database as a user with the necessary privileges.\n\nQuery the data dictionary for stale statistics.\n\nThe following example queries stale statistics for the sh.sales table (partial output included):\n\nCOL PARTITION_NAME FORMAT a15 SELECT PARTITION_NAME, STALE_STATS FROM DBA_TAB_STATISTICS WHERE TABLE_NAME = 'SALES' AND OWNER = 'SH' ORDER BY PARTITION_NAME; PARTITION_NAME STA --------------- --- SALES_1995 NO SALES_1996 NO SALES_H1_1997 NO SALES_H2_1997 NO SALES_Q1_1998 NO SALES_Q1_1999 NO . . .\n\nSee Also:\n\nOracle Database Reference to learn about the DBA_TAB_MODIFICATIONS view\n\n13.3.4 Gathering Schema and Table Statistics\n\nUse GATHER_TABLE_STATS to collect table statistics, and GATHER_SCHEMA_STATS to collect statistics for all objects in a schema.\n\nTo gather schema statistics using DBMS_STATS:\n\nStart SQL*Plus, and connect to the database with the appropriate privileges for the procedure that you intend to run.\n\nRun the GATHER_TABLE_STATS or GATHER_SCHEMA_STATS procedure, specifying the desired parameters.\n\nTypical parameters include:\n\nOwner - ownname\n\nObject name - tabname, indname, partname\n\nDegree of parallelism - degree\n\nExample 13-1 Gathering Statistics for a Table\n\nThis example uses the DBMS_STATS package to gather statistics on the sh.customers table with a parallelism setting of 2.\n\nBEGIN DBMS_STATS.GATHER_TABLE_STATS ( ownname => 'sh' , tabname => 'customers' , degree => 2 ); END; /\n\nSee Also:\n\nOracle Database PL/SQL Packages and Types Reference to learn about the GATHER_TABLE_STATS procedure\n\n13.3.5 Gathering Statistics for Fixed Objects\n\nFixed objects are dynamic performance tables and their indexes. These objects record current database activity.\n\nUnlike other database tables, the database does not automatically use dynamic statistics for SQL statement referencing X$ tables when optimizer statistics are missing. Instead, the optimizer uses predefined default values. These defaults may not be representative and could potentially lead to a suboptimal execution plan. Thus, it is important to keep fixed object statistics current.\n\nOracle Database automatically gathers fixed object statistics as part of automated statistics gathering if they have not been previously collected. You can also manually collect statistics on fixed objects by calling DBMS_STATS.GATHER_FIXED_OBJECTS_STATS. Oracle recommends that you gather statistics when the database has representative activity.\n\nPrerequisites\n\nYou must have the SYSDBA or ANALYZE ANY DICTIONARY system privilege to execute this procedure.\n\nTo gather schema statistics using GATHER_FIXED_OBJECTS_STATS:\n\nIn SQL*Plus or SQL Developer, log in to the database as a user with the necessary privileges.\n\nRun the DBMS_STATS.GATHER_FIXED_OBJECTS_STATS procedure, specifying the desired parameters.\n\nTypical parameters include:\n\nTable identifier describing where to save the current statistics - stattab\n\nIdentifier to associate with these statistics within stattab (optional) - statid\n\nSchema containing stattab (if different from current schema) - statown\n\nExample 13-2 Gathering Statistics for a Table\n\nThis example uses the DBMS_STATS package to gather fixed object statistics.\n\nBEGIN DBMS_STATS.GATHER_FIXED_OBJECTS_STATS; END; /\n\nSee Also:\n\n\"Configuring Automatic Optimizer Statistics Collection\"\n\nOracle Database PL/SQL Packages and Types Reference to learn about the GATHER_TABLE_STATS procedure\n\n13.3.6 Gathering Statistics for Volatile Tables Using Dynamic Statistics\n\nStatistics for volatile tables, which are tables modified significantly during the day, go stale quickly. For example, a table may be deleted or truncated, and then rebuilt.\n\nWhen you set the statistics of a volatile object to null, Oracle Database dynamically gathers the necessary statistics during optimization using dynamic statistics. The OPTIMIZER_DYNAMIC_SAMPLING initialization parameter controls this feature.\n\nAssumptions\n\nThis tutorial assumes the following:\n\nThe oe.orders table is extremely volatile.\n\nYou want to delete and then lock the statistics on the orders table to prevent the database from gathering statistics on the table. In this way, the database can dynamically gather necessary statistics as part of query optimization.\n\nThe oe user has the necessary privileges to query DBMS_XPLAN.DISPLAY_CURSOR.\n\nTo delete and the lock optimizer statistics:\n\nConnect to the database as user oe, and then delete the statistics for the oe table.\n\nFor example, execute the following procedure:\n\nBEGIN DBMS_STATS.DELETE_TABLE_STATS('OE','ORDERS'); END; /\n\nLock the statistics for the oe table.\n\nFor example, execute the following procedure:\n\nBEGIN DBMS_STATS.LOCK_TABLE_STATS('OE','ORDERS'); END; /\n\nYou query the orders table.\n\nFor example, use the following statement:\n\nSELECT COUNT(order_id) FROM orders;\n\nYou query the plan in the cursor.\n\nYou run the following commands (partial output included):\n\nSET LINESIZE 150 SET PAGESIZE 0 SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR); SQL_ID aut9632fr3358, child number 0 ------------------------------------- SELECT COUNT(order_id) FROM orders Plan hash value: 425895392 --------------------------------------------------------------------- | Id | Operation | Name | Rows | Cost (%CPU)| Time | --------------------------------------------------------------------- | 0 | SELECT STATEMENT | | | 2 (100)| | | 1 | SORT AGGREGATE | | 1 | | | | 2 | TABLE ACCESS FULL| ORDERS | 105 | 2 (0)| 00:00:01 | --------------------------------------------------------------------- Note ----- - dynamic statistics used for this statement (level=2)\n\nThe Note in the preceding execution plan shows that the database used dynamic statistics for the SELECT statement.\n\nSee Also:\n\n\"Configuring Options for Dynamic Statistics\"\n\n\"Locking and Unlocking Optimizer Statistics\" to learn how to gather representative statistics and then lock them, which is an alternative technique for preventing statistics for volatile tables from going stale\n\n13.3.7 Gathering Optimizer Statistics Concurrently\n\nOracle Database can gather statistics on multiple tables or partitions concurrently.\n\n13.3.7.1 About Concurrent Statistics Gathering\n\nBy default, each partition of a partition table is gathered sequentially.\n\nWhen concurrent statistics gathering mode is enabled, the database can simultaneously gather optimizer statistics for multiple tables in a schema, or multiple partitions or subpartitions in a table. Concurrency can reduce the overall time required to gather statistics by enabling the database to fully use multiple processors.\n\nNote:\n\nConcurrent statistics gathering mode does not rely on parallel query processing, but is usable with it.\n\n13.3.7.1.1 How DBMS_STATS Gathers Statistics Concurrently\n\nOracle Database employs multiple tools and technologies to create and manage multiple statistics gathering jobs concurrently.\n\nThe database uses the following:\n\nOracle Scheduler\n\nOracle Database Advanced Queuing (AQ)\n\nOracle Database Resource Manager (the Resource Manager)\n\nEnable concurrent statistics gathering by setting the CONCURRENT preference with DBMS_STATS.SET_GLOBAL_PREF.\n\nThe database runs as many concurrent jobs as possible. The Job Scheduler decides how many jobs to execute concurrently and how many to queue. As running jobs complete, the scheduler dequeues and runs more jobs until the database has gathered statistics on all tables, partitions, and subpartitions. The maximum number of jobs is bounded by the JOB_QUEUE_PROCESSES initialization parameter and available system resources.\n\nIn most cases, the DBMS_STATS procedures create a separate job for each table partition or subpartition. However, if the partition or subpartition is empty or very small, then the database may automatically batch the object with other small objects into a single job to reduce the overhead of job maintenance.\n\nThe following figure illustrates the creation of jobs at different levels, where Table 3 is a partitioned table, and the other tables are nonpartitioned. Job 3 acts as a coordinator job for Table 3, and creates a job for each partition in that table, and a separate job for the global statistics of Table 3. This example assumes that incremental statistics gathering is disabled; if enabled, then the database derives global statistics from partition-level statistics after jobs for partitions complete.\n\nFigure 13-1 Concurrent Statistics Gathering Jobs\n\nDescription of \"Figure 13-1 Concurrent Statistics Gathering Jobs\"\n\nSee Also:\n\n\"Enabling Concurrent Statistics Gathering\"\n\nOracle Database PL/SQL Packages and Types Reference to learn about the DBMS_STATS package\n\nOracle Database Reference to learn about the JOB_QUEUE_PROCESSES initialization parameter\n\n13.3.7.1.2 Concurrent Statistics Gathering and Resource Management\n\nThe DBMS_STATS package does not explicitly manage resources used by concurrent statistics gathering jobs that are part of a user-initiated statistics gathering call.\n\nThus, the database may use system resources fully during concurrent statistics gathering. To address this situation, use the Resource Manager to cap resources consumed by concurrent statistics gathering jobs. The Resource Manager must be enabled to gather statistics concurrently.\n\nThe system-supplied consumer group ORA$AUTOTASK registers all statistics gathering jobs. You can create a resource plan with proper resource allocations for ORA$AUTOTASK to prevent concurrent statistics gathering from consuming all available resources. If you lack your own resource plan, and if choose not to create one, then consider activating the Resource Manager with the system-supplied DEFAULT_PLAN.\n\nNote:\n\nThe ORA$AUTOTASK consumer group is shared with the maintenance tasks that automatically run during the maintenance windows. Thus, when concurrency is activated for automatic statistics gathering, the database automatically manages resources, with no extra steps required.\n\nSee Also:\n\nOracle Database Administratorâs Guide to learn about the Resource Manager\n\n13.3.7.2 Enabling Concurrent Statistics Gathering\n\nTo enable concurrent statistics gathering, use the DBMS_STATS.SET_GLOBAL_PREFS procedure to set the CONCURRENT preference.\n\nPossible values are as follows:\n\nMANUAL\n\nConcurrency is enabled only for manual statistics gathering.\n\nAUTOMATIC\n\nConcurrency is enabled only for automatic statistics gathering.\n\nALL\n\nConcurrency is enabled for both manual and automatic statistics gathering.\n\nOFF\n\nConcurrency is disabled for both manual and automatic statistics gathering. This is the default value.\n\nThis tutorial in this section explains how to enable concurrent statistics gathering.\n\nPrerequisites\n\nThis tutorial has the following prerequisites:\n\nIn addition to the standard privileges for gathering statistics, you must have the following privileges:\n\nCREATE JOB\n\nMANAGE SCHEDULER\n\nMANAGE ANY QUEUE\n\nThe SYSAUX tablespace must be online because the scheduler stores its internal tables and views in this tablespace.\n\nThe JOB_QUEUE_PROCESSES initialization parameter must be set to at least 4.\n\nThe Resource Manager must be enabled.\n\nBy default, the Resource Manager is disabled. If you do not have a resource plan, then consider enabling the Resource Manager with the system-supplied DEFAULT_PLAN.\n\nAssumptions\n\nThis tutorial assumes that you want to do the following:\n\nEnable concurrent statistics gathering\n\nGather statistics for the sh schema\n\nMonitor the gathering of the sh statistics\n\nTo enable concurrent statistics gathering:\n\nConnect SQL*Plus to the database with the appropriate privileges, and then enable the Resource Manager.\n\nThe following example uses the default plan for the Resource Manager:\n\nALTER SYSTEM SET RESOURCE_MANAGER_PLAN = 'DEFAULT_PLAN';\n\nSet the JOB_QUEUE_PROCESSES initialization parameter to at least twice the number of CPU cores.\n\nIn Oracle Real Application Clusters, the JOB_QUEUE_PROCESSES setting applies to each node.\n\nAssume that the system has 4 CPU cores. The following example sets the parameter to 8 (twice the number of cores):\n\nALTER SYSTEM SET JOB_QUEUE_PROCESSES=8;\n\nConfirm that the parameter change took effect.\n\nFor example, enter the following command in SQL*Plus (sample output included):\n\nSHOW PARAMETER PROCESSES; NAME TYPE VALUE -------------------------------- ----------- ----- _high_priority_processes string VKTM aq_tm_processes integer 1 db_writer_processes integer 1 gcs_server_processes integer 0 global_txn_processes integer 1 job_queue_processes integer 8 log_archive_max_processes integer 4 processes integer 100\n\nEnable concurrent statistics.\n\nFor example, execute the following PL/SQL anonymous block:\n\nBEGIN DBMS_STATS.SET_GLOBAL_PREFS('CONCURRENT','ALL'); END; /\n\nConfirm that the statistics were enabled.\n\nFor example, execute the following query (sample output included):\n\nSELECT DBMS_STATS.GET_PREFS('CONCURRENT') FROM DUAL; DBMS_STATS.GET_PREFS('CONCURRENT') ---------------------------------- ALL\n\nGather the statistics for the SH schema.\n\nFor example, execute the following procedure:\n\nEXEC DBMS_STATS.GATHER_SCHEMA_STATS('SH');\n\nIn a separate session, monitor the job progress by querying DBA_OPTSTAT_OPERATION_TASKS.\n\nFor example, execute the following query (sample output included):\n\nSET LINESIZE 1000 COLUMN TARGET FORMAT a8 COLUMN TARGET_TYPE FORMAT a25 COLUMN JOB_NAME FORMAT a14 COLUMN START_TIME FORMAT a40 SELECT TARGET, TARGET_TYPE, JOB_NAME, TO_CHAR(START_TIME, 'dd-mon-yyyy hh24:mi:ss') FROM DBA_OPTSTAT_OPERATION_TASKS WHERE STATUS = 'IN PROGRESS' AND OPID = (SELECT MAX(ID) FROM DBA_OPTSTAT_OPERATIONS WHERE OPERATION = 'gather_schema_stats'); TARGET TARGET_TYPE JOB_NAME TO_CHAR(START_TIME,' --------- ------------------------- -------------- -------------------- SH.SALES TABLE (GLOBAL STATS ONLY) ST$T292_1_B29 30-nov-2012 14:22:47 SH.SALES TABLE (COORDINATOR JOB) ST$SD290_1_B10 30-nov-2012 14:22:08\n\nIn the original session, disable concurrent statistics gathering.\n\nFor example, execute the following query:\n\nEXEC DBMS_STATS.SET_GLOBAL_PREFS('CONCURRENT','OFF');\n\nSee Also:\n\n\"Monitoring Statistics Gathering Operations\"\n\nOracle Database Administratorâs Guide\n\nOracle Database PL/SQL Packages and Types Reference to learn how to use the DBMS_STATS.SET_GLOBAL_PREFS procedure\n\n13.3.7.3 Monitoring Statistics Gathering Operations\n\nYou can monitor statistics gathering jobs using data dictionary views.\n\nThe following views are relevant:\n\nDBA_OPTSTAT_OPERATION_TASKS\n\nThis view contains the history of tasks that are performed or currently in progress as part of statistics gathering operations (recorded in DBA_OPTSTAT_OPERATIONS). Each task represents a target object to be processed in the corresponding parent operation.\n\nDBA_OPTSTAT_OPERATIONS\n\nThis view contains a history of statistics operations performed or currently in progress at the table, schema, and database level using the DBMS_STATS package.\n\nThe TARGET column in the preceding views shows the target object for that statistics gathering job in the following form:\n\nOWNER.TABLE_NAME.PARTITION_OR_SUBPARTITION_NAME\n\nAll statistics gathering job names start with the string ST$.\n\nTo display currently running statistics tasks and jobs:\n\nTo list statistics gathering currently running tasks from all user sessions, use the following SQL statement (sample output included):\n\nSELECT OPID, TARGET, JOB_NAME, (SYSTIMESTAMP - START_TIME) AS elapsed_time FROM DBA_OPTSTAT_OPERATION_TASKS WHERE STATUS = 'IN PROGRESS'; OPID TARGET JOB_NAME ELAPSED_TIME ---- ------------------------- ------------- -------------------------- 981 SH.SALES.SALES_Q4_1998 ST$T82_1_B29 +000000000 00:00:00.596321 981 SH.SALES ST$SD80_1_B10 +000000000 00:00:27.972033\n\nTo display completed statistics tasks and jobs:\n\nTo list only completed tasks and jobs from a particular operation, first identify the operation ID from the DBA_OPTSTAT_OPERATIONS view based on the statistics gathering operation name, target, and start time. After you identify the operation ID, you can query the DBA_OPTSTAT_OPERATION_TASKS view to find the corresponding tasks in that operation\n\nFor example, to list operations with the ID 981, use the following commands in SQL*Plus (sample output included):\n\nVARIABLE id NUMBER EXEC :id := 981 SELECT TARGET, JOB_NAME, (END_TIME - START_TIME) AS ELAPSED_TIME FROM DBA_OPTSTAT_OPERATION_TASKS WHERE STATUS <> 'IN PROGRESS' AND OPID = :id; TARGET JOB_NAME ELAPSED_TIME ------------------------- ------------- -------------------------- SH.SALES_TRANSACTIONS_EXT +000000000 00:00:45.479233 SH.CAL_MONTH_SALES_MV ST$SD88_1_B10 +000000000 00:00:45.382764 SH.CHANNELS ST$SD88_1_B10 +000000000 00:00:45.307397\n\nTo display statistics gathering tasks and jobs that have failed:\n\nUse the following SQL statement (partial sample output included):\n\nSET LONG 10000 SELECT TARGET, JOB_NAME AS NM, (END_TIME - START_TIME) AS ELAPSED_TIME, NOTES FROM DBA_OPTSTAT_OPERATION_TASKS WHERE STATUS = 'FAILED'; TARGET NM ELAPSED_TIME NOTES ------------------ -- -------------------------- ----------------- SYS.OPATCH_XML_INV +000000007 02:36:31.130314 <error>ORA-20011: Approximate NDV failed: ORA-29913: error in\n\nSee Also:\n\nOracle Database Reference to learn about the DBA_SCHEDULER_JOBS view\n\n13.3.8 Gathering Incremental Statistics on Partitioned Objects\n\nIncremental statistics scan only changed partitions. When gathering statistics on large partitioned table by deriving global statistics from partition-level statistics, incremental statistics maintenance improves performance.\n\n13.3.8.1 Purpose of Incremental Statistics\n\nIn a typical case, an application loads data into a new partition of a range-partitioned table. As applications add new partitions and load data, the database must gather statistics on the new partition and keep global statistics up to date.\n\nTypically, data warehouse applications access large partitioned tables. Often these tables are partitioned on date columns, with only the recent partitions subject to frequent DML changes. Without incremental statistics, statistics collection typically uses a two-pass approach:\n\nThe database scans the table to gather the global statistics.\n\nThe full scan of the table for global statistics collection can be very expensive, depending on the size of the table. As the table adds partitions, the longer the execution time for GATHER_TABLE_STATS because of the full table scan required for the global statistics. The database must perform the scan of the entire table even if only a small subset of partitions change.\n\nThe database scans the changed partitions to gather their partition-level statistics.\n\nIncremental maintenance provides a huge performance benefit for data warehouse applications because of the following:\n\nThe database must scan the table only once to gather partition statistics and to derive the global statistics by aggregating partition-level statistics. Thus, the database avoids the two full scans that are required when not using incremental statistics: one scan for the partition-level statistics, and one scan for the global-level statistics.\n\nIn subsequent statistics gathering, the database only needs to scan the stale partitions and update their statistics (including synopses). The database can derive global statistics from the fresh partition statistics, which saves a full table scan.\n\nWhen using incremental statistics, the database must still gather statistics on any partition that will change the global or table-level statistics. Incremental statistics maintenance yields the same statistics as gathering table statistics from scratch, but performs better.\n\n13.3.8.2 How DBMS_STATS Derives Global Statistics for Partitioned tables\n\nWhen incremental statistics maintenance is enabled, DBMS_STATS gathers statistics and creates synopses for changed partitions only. The database also automatically merges partition-level synopses into a global synopsis, and derives global statistics from the partition-level statistics and global synopses.\n\nThe database avoids a full table scan when computing global statistics by deriving some global statistics from the partition-level statistics. For example, the number of rows at the global level is the sum of number of rows of partitions. Even global histograms can be derived from partition histograms.\n\nHowever, the database cannot derive all statistics from partition-level statistics, including the NDV of a column. The following example shows the NDV for two partitions in a table:\n\nTable 13-3 NDV for Two Partitions\n\nObject Column Values NDV Partition 1 1,3,3,4,5 4 Partition 2 2,3,4,5,6 5\n\nCalculating the NDV in the table by adding the NDV of the individual partitions produces an NDV of 9, which is incorrect. Thus, a more accurate technique is required: synopses.\n\n13.3.8.2.1 Partition-Level Synopses\n\nA synopsis is special type of statistic that tracks the number of distinct values (NDV) for each column in a partition. You can consider a synopsis as an internal management structure that samples distinct values.\n\nThe database can accurately derive the global-level NDV for each column by merging partition-level synopses. In the example shown in Table 13-3, the database can use synopses to calculate the NDV for the column as 6.\n\nEach partition maintains a synopsis in incremental mode. When a new partition is added to the table you only need to gather statistics for the new partition. The database automatically updates the global statistics by aggregating the new partition synopsis with the synopses for existing partitions. Subsequent statistics gathering operations are faster than when synopses are not used.\n\nThe database stores synopses in data dictionary tables WRI$_OPTSTAT_SYNOPSIS_HEAD$ and WRI$_OPTSTAT_SYNOPSIS$ in the SYSAUX tablespace. The DBA_PART_COL_STATISTICS dictionary view contains information of the column statistics in partitions. If the NOTES column contains the keyword INCREMENTAL, then this column has synopses.\n\nSee Also:\n\nOracle Database Reference to learn more about DBA_PART_COL_STATISTICS\n\n13.3.8.2.2 NDV Algorithms: Adaptive Sampling and HyperLogLog\n\nStarting in Oracle Database 12c Release 2 (12.2), the HyperLogLog algorithm can improve NDV (number of distinct values) calculation performance, and also reduce the storage space required for synopses.\n\nThe legacy algorithm for calculating NDV uses adaptive sampling. A synopsis is a sample of the distinct values. When calculating the NDV, the database initially stores every distinct value in a hash table. Each distinct value occupies a distinct hash bucket, so a column with 5000 distinct values has 5000 hash buckets. The database then halves the number of hash buckets, and then continues to halve the result until a small number of buckets remain. The algorithm is âadaptiveâ because the sampling rate changes based on the number of hash table splits.\n\nTo calculate the NDV for the column, the database uses the following formula, where B is the number of hash buckets remaining after all the splits have been performed, and S is the number of splits:\n\nNDV = B * 2^S\n\nAdaptive sampling produces accurate NDV statistics, but has the following consequences:\n\nSynopses occupy significant disk space, especially when tables have many columns and partitions, and the NDV in each column is high.\n\nFor example, a 60-column table might have 300,000 partitions, with an average per-column NDV of 5,000. In this example, each partition has 300,000 entries (60 x 5000). In total, the synopses tables have 90 billion entries (300,000 squared), which occupies at least 720 GB of storage space.\n\nBulk processing of synopses can negatively affect performance.\n\nBefore the database regathers statistics on the stale partitions, it must delete the associated synopses. Bulk deletion can be slow because it generates significant amounts of undo and redo data.\n\nIn contrast to dynamic sampling, the HyperLogLog algorithm uses a randomization technique. Although the algorithm is complex, the foundational insight is that in a stream of random values, n distinct values will be spaced on average 1/n apart. Therefore, if you know the smallest value in the stream, then you can roughly estimate the number of distinct values. For example, if the values range from 0 to 1, and if the smallest value observed is .2, then the numbers will on average be evenly spaced .2 apart, so the NDV estimate is 5.\n\nThe HyperLogLog algorithm expands on and corrects the original estimate. The database applies a hash function to every column value, resulting in a set of hash values with the same cardinality as the column. For the base estimate, the NDV equals 2n, where n is the maximum number of trailing zeroes observed in the binary representation of the hash values. The database refines its NDV estimate by using part of the output to split values into different hash buckets.\n\nThe advantages of the HyperLogLog algorithm over adaptive sampling are:\n\nThe accuracy of the new algorithm is similar to the original algorithm.\n\nThe memory required is significantly lower, which typically leads to huge reductions in synopsis size.\n\nSynopses can become large when many partitions exist, and they have many columns with high NDV. Synopses that use the HyperLogLog algorithm are more compact. Creating and deleting synopses affects batch run times. Any operational procedures that manage partitions reduce run time.\n\nThe DBMS_STATS preference APPROXIMATE_NDV_ALGORITHM determines which algorithm the database uses for NDV calculation.\n\nSee Also:\n\nOracle Database PL/SQL Packages and Types Reference to learn about the APPROXIMATE_NDV_ALGORITHM preference\n\n13.3.8.2.3 Aggregation of Global Statistics Using Synopses: Example\n\nIn this example, the database gathers statistics for the initial six partitions of the sales table, and then creates synopses for each partition (S1, S2, and so on). The database creates global statistics by aggregating the partition-level statistics and synopses.\n\nFigure 13-2 Aggregating Statistics\n\nDescription of \"Figure 13-2 Aggregating Statistics\"\n\nThe following graphic shows a new partition, containing data for May 24, being added to the sales table. The database gathers statistics for the newly added partition, retrieves synopses for the other partitions, and then aggregates the synopses to create global statistics.\n\nFigure 13-3 Aggregating Statistics after Adding a Partition\n\nDescription of \"Figure 13-3 Aggregating Statistics after Adding a Partition\"\n\n13.3.8.3 Gathering Statistics for a Partitioned Table: Basic Steps\n\nThis section explains how to gather optimizer statistics for a partitioned table.\n\n13.3.8.3.1 Considerations for Incremental Statistics Maintenance\n\nEnabling incremental statistics maintenance has several consequences.\n\nSpecifically, note the following:\n\nIf a table uses composite partitioning, then the database only gathers statistics for modified subpartitions. The database does not gather statistics at the subpartition level for unmodified subpartitions. In this way, the database reduces work by skipping unmodified partitions.\n\nIf a table uses incremental statistics, and if this table has a locally partitioned index, then the database gathers index statistics at the global level and for modified (not unmodified) index partitions. The database does not generate global index statistics from the partition-level index statistics. Rather, the database gathers global index statistics by performing a full index scan.\n\nA hybrid partitioned table contains both internal and external partitions. For internal partitions only, DDL changes invoke incremental statistic maintenance on individual partitions and on the table itself. For example, if june18 is an internal partition, then ALTER TABLE ... MODIFY PARTITION jun18 ... triggers incremental statistics maintenance during statistics collection; if june18 is an external partition, however, then incremental maintenance does not occur.\n\nThe SYSAUX tablespace consumes additional space to maintain global statistics for partitioned tables.\n\nSee Also:\n\nOracle Database VLDB and Partitioning Guide to learn how to create hybrid partitioned tables\n\nOracle Database PL/SQL Packages and Types Reference to learn more about DBMS_STATS\n\n13.3.8.3.2 Enabling Incremental Statistics Using SET_TABLE_PREFS\n\nTo enable incremental statistics maintenance for a partitioned table, use DBMS_STATS.SET_TABLE_PREFS to set the INCREMENTAL value to true. When INCREMENTAL is set to false, which is the default, the database uses a full table scan to maintain global statistics.\n\nFor the database to update global statistics incrementally by scanning only the partitions that have changed, the following conditions must be met:\n\nThe PUBLISH value for the partitioned table is true.\n\nThe INCREMENTAL value for the partitioned table is true.\n\nThe statistics gathering procedure must specify AUTO_SAMPLE_SIZE for ESTIMATE_PERCENT and AUTO for GRANULARITY.\n\nExample 13-3 Enabling Incremental Statistics\n\nAssume that the PUBLISH value for the partitioned table sh.sales is true. The following program enables incremental statistics for this table:\n\nEXEC DBMS_STATS.SET_TABLE_PREFS('sh', 'sales', 'INCREMENTAL', 'TRUE');\n\n13.3.8.3.3 About the APPROXIMATE_NDV_ALGORITHM Settings\n\nThe DBMS_STATS.APPROXIMATE_NDV_ALGORITHM preference specifies the synopsis generation algorithm, either HyperLogLog or adaptive sampling. The INCREMENTAL_STALENESS preference controls when the database reformats synopses that use the adaptive sampling format.\n\nThe APPROXIMATE_NDV_ALGORITHM preference has the following possible values:\n\nREPEAT OR HYPERLOGLOG\n\nThis is the default. If INCREMENTAL is enabled on the table, then the database preserves the format of any existing synopses that use the adaptive sampling algorithm. However, the database creates any new synopses in HyperLogLog format. This approach is attractive when existing performance is acceptable, and you do not want to incur the performance cost of reformatting legacy content.\n\nADAPTIVE SAMPLING\n\nThe database uses the adaptive sampling algorithm for all synopses. This is the most conservative option.\n\nHYPERLOGLOG\n\nThe database uses the HyperLogLog algorithm for all new and stale synopses.\n\nThe INCREMENTAL_STALENESS preference controls when a synopsis is considered stale. When the APPROXIMATE_NDV_ALGORITHM preference is set to HYPERLOGLOG, then the following INCREMENTAL_STALENESS settings apply:\n\nALLOW_MIXED_FORMAT\n\nThis is the default. If this value is specified, and if the following conditions are met, then the database does not consider existing adaptive sampling synopses as stale:\n\nThe synopses are fresh.\n\nYou gather statistics manually.\n\nThus, synopses in both the legacy and HyperLogLog formats can co-exist. However, over time the automatic statistics gathering job regathers statistics on synopses that use the old format, and replaces them with synopses in HyperLogLog format. In this way, the automatic statistics gather job gradually phases out the old format. Manual statistics gathering jobs do not reformat synopses that use the adaptive sampling format.\n\nNull\n\nAny partitions with the synopses in the legacy format are considered stale, which immediately triggers the database to regather statistics for stale synopses. The advantage is that the performance cost occurs only once. The disadvantage is that regathering all statistics on large tables can be resource-intensive.\n\n13.3.8.3.4 Configuring Synopsis Generation: Examples\n\nThese examples show different approaches, both conservative and aggressive, to switching synopses to the new HyperLogLog format.\n\nExample 13-4 Taking a Conservative Approach to Reformatting Synopses\n\nIn this example, you allow synopses in mixed formats to coexist for the sh.sales table. Mixed formats yield less accurate statistics. However, you do not need to regather statistics for all partitions of the table.\n\nTo ensure that all new and stale synopses use the HyperLogLog algorithm, set the APPROXIMATE_NDV_ALGORITHM preference to HYPERLOGLOG. To ensure that the automatic statistics gathering job reformats stale synopses gradually over time, set the INCREMENTAL_STALENESS preference to ALLOW_MIXED_FORMAT.\n\nBEGIN DBMS_STATS.SET_TABLE_PREFS ( ownname => 'sh' , tabname => 'sales' , pname => 'approximate_ndv_algorithm' , pvalue => 'hyperloglog' ); DBMS_STATS.SET_TABLE_PREFS ( ownname => 'sh' , tabname => 'sales' , pname => 'incremental_staleness' , pvalue => 'allow_mixed_format' ); END;\n\nExample 13-5 Taking an Aggressive Approach to Reformatting Synopses\n\nIn this example, you force all synopses to use the HyperLogLog algorithm for the sh.sales table. In this case, the database must regather statistics for all partitions of the table.\n\nTo ensure that all new and stale synopses use the HyperLogLog algorithm, set the APPROXIMATE_NDV_ALGORITHM preference to HYPERLOGLOG. To force the database to immediately regather statistics for all partitions in the table and store them in the new format, set the INCREMENTAL_STALENESS preference to null.\n\nBEGIN DBMS_STATS.SET_TABLE_PREFS ( ownname => 'sh' , tabname => 'sales' , pname => 'approximate_ndv_algorithm' , pvalue => 'hyperloglog' ); DBMS_STATS.SET_TABLE_PREFS ( ownname => 'sh' , tabname => 'sales' , pname => 'incremental_staleness' , pvalue => 'null' ); END;\n\n13.3.8.4 Maintaining Incremental Statistics for Partition Maintenance Operations\n\nA partition maintenance operation is a partition-related operation such as adding, exchanging, merging, or splitting table partitions.\n\nOracle Database provides the following support for incremental statistics maintenance:\n\nIf a partition maintenance operation triggers statistics gathering, then the database can reuse synopses that would previously have been dropped with the old segments.\n\nDBMS_STATS can create a synopsis on a nonpartitioned table. The synopsis enables the database to maintain incremental statistics as part of a partition exchange operation without having to explicitly gather statistics on the partition after the exchange.\n\nWhen the DBMS_STATS preference INCREMENTAL is set to true on a table, the INCREMENTAL_LEVEL preference controls which synopses are collected and when. This preference takes the following values:\n\nTABLE\n\nDBMS_STATS gathers table-level synopses on this table. You can only set INCREMENTAL_LEVEL to TABLE at the table level, not at the schema, database, or global level.\n\nPARTITION (default)\n\nDBMS_STATS only gathers synopsis at the partition level of partitioned tables.\n\nWhen performing a partition exchange, to have synopses after the exchange for the partition being exchanged, set INCREMENTAL to true and INCREMENTAL_LEVEL to TABLE on the table to be exchanged with the partition.\n\nAssumptions\n\nThis tutorial assumes the following:\n\nYou want to load empty partition p_sales_01_2010 in a sales table.\n\nYou create a staging table t_sales_01_2010, and then populate the table.\n\nYou want the database to maintain incremental statistics as part of the partition exchange operation without having to explicitly gather statistics on the partition after the exchange.\n\nTo maintain incremental statistics as part of a partition exchange operation:\n\nSet incremental statistics preferences for staging table t_sales_01_2010.\n\nFor example, run the following statement:\n\nBEGIN DBMS_STATS.SET_TABLE_PREFS ( ownname => 'sh' , tabname => 't_sales_01_2010' , pname => 'INCREMENTAL' , pvalue => 'true' ); DBMS_STATS.SET_TABLE_PREFS ( ownname => 'sh' , tabname => 't_sales_01_2010' , pname => 'INCREMENTAL_LEVEL' , pvalue => 'table' ); END;\n\nGather statistics on staging table t_sales_01_2010.\n\nFor example, run the following PL/SQL code:\n\nBEGIN DBMS_STATS.GATHER_TABLE_STATS ( ownname => 'SH' , tabname => 'T_SALES_01_2010' ); END; /\n\nDBMS_STATS gathers table-level synopses on t_sales_01_2010.\n\nEnsure that the INCREMENTAL preference is true on the sh.sales table.\n\nFor example, run the following PL/SQL code:\n\nBEGIN DBMS_STATS.SET_TABLE_PREFS ( ownname => 'sh' , tabname => 'sales' , pname => 'INCREMENTAL' , pvalue => 'true' ); END; /\n\nIf you have never gathered statistics on sh.sales before with INCREMENTAL set to true, then gather statistics on the partition to be exchanged.\n\nFor example, run the following PL/SQL code:\n\nBEGIN DBMS_STATS.GATHER_TABLE_STATS ( ownname => 'sh' , tabname => 'sales' , pname => 'p_sales_01_2010' , pvalue => granularity=>'partition' ); END; /\n\nPerform the partition exchange.\n\nFor example, use the following SQL statement:\n\nALTER TABLE sales EXCHANGE PARTITION p_sales_01_2010 WITH TABLE t_sales_01_2010;\n\nAfter the exchange, the partitioned table has both statistics and a synopsis for partition p_sales_01_2010.\n\nIn releases before Oracle Database 12c, the preceding statement swapped the segment data and statistics of p_sales_01_2010 with t_sales_01_2010. The database did not maintain synopses for nonpartitioned tables such as t_sales_01_2010. To gather global statistics on the partitioned table, you needed to rescan the p_sales_01_2010 partition to obtain its synopses.\n\nSee Also:\n\nOracle Database PL/SQL Packages and Types Reference to learn more about DBMS_STATS.SET_TABLE_PREFS\n\n13.3.8.5 Maintaining Incremental Statistics for Tables with Stale or Locked Partition Statistics\n\nStarting in Oracle Database 12c, incremental statistics can automatically calculate global statistics for a partitioned table even if the partition or subpartition statistics are stale and locked.\n\nWhen incremental statistics are enabled in releases before Oracle Database 12c, if any DML occurs on a partition, then the optimizer considers statistics on this partition to be stale. Thus, DBMS_STATS must gather the statistics again to accurately aggregate the global statistics. Furthermore, if DML occurs on a partition whose statistics are locked, then DBMS_STATS cannot regather the statistics on the partition, so a full table scan is the only means of gathering global statistics. Regathering statistics creates performance overhead.\n\nIn Oracle Database 12c, the statistics preference INCREMENTAL_STALENESS controls how the database determines whether the statistics on a partition or subpartition are stale. This preference takes the following values:\n\nUSE_STALE_PERCENT\n\nA partition or subpartition is not considered stale if DML changes are less than the STALE_PERCENT preference specified for the table. The default value of STALE_PERCENT is 10, which means that if DML causes more than 10% of row changes, then the table is considered stale.\n\nUSE_LOCKED_STATS\n\nLocked partition or subpartition statistics are not considered stale, regardless of DML changes.\n\nNULL (default)\n\nA partition or subpartition is considered stale if it has any DML changes. This behavior is identical to the Oracle Database 11g behavior. When the default value is used, statistics gathered in incremental mode are guaranteed to be the same as statistics gathered in nonincremental mode. When a nondefault value is used, statistics gathered in incremental mode might be less accurate than those gathered in nonincremental mode.\n\nYou can specify USE_STALE_PERCENT and USE_LOCKED_STATS together. For example, you can write the following anonymous block:\n\nBEGIN DBMS_STATS.SET_TABLE_PREFS ( ownname => null , table_name => 't' , pname => 'incremental_staleness' , pvalue => 'use_stale_percent,use_locked_stats' ); END;\n\nAssumptions\n\nThis tutorial assumes the following:\n\nThe STALE_PERCENT for a partitioned table is set to 10.\n\nThe INCREMENTAL value is set to true.\n\nThe table has had statistics gathered in INCREMENTAL mode before.\n\nYou want to discover how statistics gathering changes depending on the setting for INCREMENTAL_STALENESS, whether the statistics are locked, and the percentage of DML changes.\n\nTo test for tables with stale or locked partition statistics:\n\nSet INCREMENTAL_STALENESS to NULL.\n\nAfterward, 5% of the rows in one partition change because of DML activity.\n\nUse DBMS_STATS to gather statistics on the table.\n\nDBMS_STATS regathers statistics for the partition that had the 5% DML activity, and incrementally maintains the global statistics.\n\nSet INCREMENTAL_STALENESS to USE_STALE_PERCENT.\n\nAfterward, 5% of the rows in one partition change because of DML activity.\n\nUse DBMS_STATS to gather statistics on the table.\n\nDBMS_STATS does not regather statistics for the partition that had DML activity (because the changes are under the staleness threshold of 10%), and incrementally maintains the global statistics.\n\nLock the partition statistics.\n\nAfterward, 20% of the rows in one partition change because of DML activity.\n\nUse DBMS_STATS to gather statistics on the table.\n\nDBMS_STATS does not regather statistics for the partition because the statistics are locked. The database gathers the global statistics with a full table scan.\n\nAfterward, 5% of the rows in one partition change because of DML activity.\n\nUse DBMS_STATS to gather statistics on the table.\n\nWhen you gather statistics on this table, DBMS_STATS does not regather statistics for the partition because they are not considered stale. The database maintains global statistics incrementally using the existing statistics for this partition.\n\nSet INCREMENTAL_STALENESS to USE_LOCKED_STATS and USE_STALE_PERCENT.\n\nAfterward, 20% of the rows in one partition change because of DML activity.\n\nUse DBMS_STATS to gather statistics on the table.\n\nBecause USE_LOCKED_STATS is set, DBMS_STATS ignores the fact that the statistics are stale and uses the locked statistics. The database maintains global statistics incrementally using the existing statistics for this partition.\n\nSee Also:\n\nOracle Database PL/SQL Packages and Types Reference to learn more about DBMS_STATS.SET_TABLE_PREFS\n\n13.4 Gathering System Statistics Manually\n\nSystem statistics describe hardware characteristics, such as I/O and CPU performance and utilization, to the optimizer.\n\n13.4.1 About System Statistics\n\nSystem statistics measure the performance of CPU and storage so that the optimizer can use these inputs when evaluating plans.\n\nWhen a query executes, it consumes CPU. In many cases, a query also consumes storage subsystem resources. Each plan in a typical query may consume a different proportion of CPU and I/O. Using the cost metric, the optimizer chooses the plan that it estimates will execute most quickly. If the optimizer knows the speed of CPU and storage, then it can make finer judgments about the cost of each alternative plan.\n\nThe following figure shows a query that has three possible plans. Each plan uses different amounts of CPU and I/O. For the sake of this example, the optimizer has assigned Plan 1 the lowest cost.\n\nThe database automatically gathers essential system statistics, called noworkload statistics, at the first instance startup. Typically, these characteristics only change when some aspect of the hardware configuration is upgraded.\n\nThe following figure shows the same database after adding high-performance storage. Gathering system statistics enables the optimizer to take the storage performance into account. In this example, the high-performance storage lowers the relative cost of Plan 2 and Plan 3 significantly. Plan 1 shows only marginal improvement because it uses less I/O. Plan 3 has now been assigned the lowest cost.\n\nOn systems with fast I/O infrastructure, system statistics increase the probability that queries choose table scans over index access methods.\n\n13.4.2 Guidelines for Gathering System Statistics\n\nUnless there is a good reason to gather manually, Oracle recommends using the defaults for system statistics.\n\nSystem statistics are important for performance because they affect every SQL statement executed in the database. Changing system statistics may change SQL execution plans, perhaps in unexpected or unwanted ways. For this reason, Oracle recommends considering the options carefully before changing system statistics.\n\nWhen to Consider Gathering System Statistics Manually\n\nIf you are using Oracle Exadata, and if the database is running a pure data warehouse load, then gathering system statistics using the EXADATA option can help performance in some cases because table scans are more strongly favored. However, even on Exadata, the defaults are best for most workloads.\n\nIf you are not using Oracle Exadata, and if you choose to gather system statistics manually, then Oracle recommends the following:\n\nGather system statistics when a physical change occurs in your environment, for example, the server gets faster CPUs, more memory, or different disk storage. Oracle recommends that you gather noworkload statistics after you create new tablespaces on storage that is not used by any other tablespace.\n\nCapture statistics when the system has the most common workload. Gathering workload statistics does not generate additional overhead.\n\nWhen to Consider Using Default Statistics\n\nOracle recommends using the defaults for system statistics in most cases. To reset system statistics to their default values, execute DBMS_STATS.DELETE_SYSTEM_STATS, and then shut down and reopen the database. To ensure that appropriate defaults are used, this step is also recommended on a newly created database.\n\n13.4.3 Gathering System Statistics with DBMS_STATS\n\nTo gather system statistics manually, use the DBMS_STATS.GATHER_SYSTEM_STATS procedure.\n\n13.4.3.1 About the GATHER_SYSTEM_STATS Procedure\n\nThe DBMS_STATS.GATHER_SYSTEM_STATS procedure analyzes activity in a specified time period (workload statistics) or simulates a workload (noworkload statistics).\n\nThe input arguments to DBMS_STATS.GATHER_SYSTEM_STATS are:\n\nNOWORKLOAD\n\nThe optimizer gathers statistics based on system characteristics only, without regard to the workload.\n\nINTERVAL\n\nAfter the specified number of minutes has passed, the optimizer updates system statistics either in the data dictionary, or in an alternative table (specified by stattab). Statistics are based on system activity during the specified interval.\n\nSTART and STOP\n\nSTART initiates gathering statistics. STOP calculates statistics for the elapsed period (since START) and refreshes the data dictionary or an alternative table (specified by stattab). The optimizer ignores INTERVAL.\n\nEXADATA\n\nThe system statistics consider the unique capabilities provided by using Exadata, such as large I/O size and high I/O throughput. The optimizer sets the multiblock read count and I/O throughput statistics along with CPU speed.\n\nThe following table lists the optimizer system statistics gathered by DBMS_STATS and the options for gathering or manually setting specific system statistics.\n\nTable 13-4 Optimizer System Statistics in the DBMS_STATS Package\n\nParameter Name Description Initialization Options for Gathering or Setting Statistics Unit\n\nSee Also:\n\nOracle Database PL/SQL Packages and Types Reference for detailed information on the procedures in the DBMS_STATS package for gathering and deleting system statistics\n\n13.4.3.2 Gathering Workload Statistics\n\nOracle recommends that you use DBMS_STATS.GATHER_SYSTEM_STATS to capture statistics when the database has the most typical workload.\n\n13.4.3.2.1 About Workload Statistics\n\nWorkload statistics analyze activity in a specified time period.\n\nWorkload statistics include the following statistics listed in Table 13-4:\n\nSingle block (sreadtim) and multiblock (mreadtim) read times\n\nMultiblock count (mbrc)\n\nCPU speed (cpuspeed)\n\nMaximum system throughput (maxthr)\n\nAverage parallel execution throughput (slavethr)\n\nThe database computes sreadtim, mreadtim, and mbrc by comparing the number of physical sequential and random reads between two points in time from the beginning to the end of a workload. The database implements these values through counters that change when the buffer cache completes synchronous read requests.\n\nBecause the counters are in the buffer cache, they include not only I/O delays, but also waits related to latch contention and task switching. Thus, workload statistics depend on system activity during the workload window. If system is I/O bound (both latch contention and I/O throughput), then the statistics promote a less I/O-intensive plan after the database uses the statistics.\n\nAs shown in Figure 13-4, if you gather workload statistics, then the optimizer uses the mbrc value gathered for workload statistics to estimate the cost of a full table scan.\n\nFigure 13-4 Workload Statistics Counters\n\nDescription of \"Figure 13-4 Workload Statistics Counters\"\n\nWhen gathering workload statistics, the database may not gather the mbrc and mreadtim values if no table scans occur during serial workloads, as is typical of OLTP systems. However, full table scans occur frequently on DSS systems. These scans may run parallel and bypass the buffer cache. In such cases, the database still gathers the sreadtim because index lookups use the buffer cache.\n\nIf the database cannot gather or validate gathered mbrc or mreadtim values, but has gathered sreadtim and cpuspeed, then the database uses only sreadtim and cpuspeed for costing. In this case, the optimizer uses the value of the initialization parameter DB_FILE_MULTIBLOCK_READ_COUNT to cost a full table scan. However, if DB_FILE_MULTIBLOCK_READ_COUNT is 0 or is not set, then the optimizer uses a value of 8 for calculating cost.\n\nUse the DBMS_STATS.GATHER_SYSTEM_STATS procedure to gather workload statistics. The GATHER_SYSTEM_STATS procedure refreshes the data dictionary or a staging table with statistics for the elapsed period. To set the duration of the collection, use either of the following techniques:\n\nSpecify START the beginning of the workload window, and then STOP at the end of the workload window.\n\nSpecify INTERVAL and the number of minutes before statistics gathering automatically stops. If needed, you can use GATHER_SYSTEM_STATS (gathering_mode=>'STOP') to end gathering earlier than scheduled.\n\nSee Also:\n\nOracle Database Reference to learn about the DB_FILE_MULTIBLOCK_READ_COUNT initialization parameter\n\n13.4.3.2.2 Starting and Stopping System Statistics Gathering\n\nThis tutorial explains how to set the workload interval with the START and STOP parameters of GATHER_SYSTEM_STATS.\n\nAssumptions\n\nThis tutorial assumes the following:\n\nThe hour between 10 a.m. and 11 a.m. is representative of the daily workload.\n\nYou intend to collect system statistics directly in the data dictionary.\n\nTo gather workload statistics using START and STOP:\n\nStart SQL*Plus and connect to the database with administrator privileges.\n\nStart statistics collection.\n\nFor example, at 10 a.m., execute the following procedure to start collection:\n\nEXECUTE DBMS_STATS.GATHER_SYSTEM_STATS( gathering_mode => 'START' );\n\nGenerate the workload.\n\nEnd statistics collection.\n\nFor example, at 11 a.m., execute the following procedure to end collection:\n\nEXECUTE DBMS_STATS.GATHER_SYSTEM_STATS( gathering_mode => 'STOP' );\n\nThe optimizer can now use the workload statistics to generate execution plans that are effective during the normal daily workload.\n\nOptionally, query the system statistics.\n\nFor example, run the following query:\n\nCOL PNAME FORMAT a15 SELECT PNAME, PVAL1 FROM SYS.AUX_STATS$ WHERE SNAME = 'SYSSTATS_MAIN';\n\nSee Also:\n\nOracle Database PL/SQL Packages and Types Reference to learn about the DBMS_STATS.GATHER_SYSTEM_STATS procedure\n\n13.4.3.3 Gathering Noworkload Statistics\n\nNoworkload statistics capture characteristics of the I/O system.\n\nBy default, Oracle Database uses noworkload statistics and the CPU cost model. The values of noworkload statistics are initialized to defaults at the first instance startup. You can also use the DBMS_STATS.GATHER_SYSTEM_STATS procedure to gather noworkload statistics manually.\n\nNoworkload statistics include the following system statistics listed in Table 13-4:\n\nI/O transfer speed (iotfrspeed)\n\nI/O seek time (ioseektim)\n\nCPU speed (cpuspeednw)\n\nThe major difference between workload statistics and noworkload statistics is in the gathering method. Noworkload statistics gather data by submitting random reads against all data files, whereas workload statistics uses counters updated when database activity occurs. If you gather workload statistics, then Oracle Database uses them instead of noworkload statistics.\n\nTo gather noworkload statistics, run DBMS_STATS.GATHER_SYSTEM_STATS with no arguments or with the gathering mode set to noworkload. There is an overhead on the I/O system during the gathering process of noworkload statistics. The gathering process may take from a few seconds to several minutes, depending on I/O performance and database size.\n\nWhen you gather noworkload statistics, the database analyzes the information and verifies it for consistency. In some cases, the values of noworkload statistics may retain their default values. You can either gather the statistics again, or use SET_SYSTEM_STATS to set the values manually to the I/O system specifications.\n\nAssumptions\n\nThis tutorial assumes that you want to gather noworkload statistics manually.\n\nTo gather noworkload statistics manually:\n\nStart SQL*Plus and connect to the database with administrator privileges.\n\nGather the noworkload statistics.\n\nFor example, run the following statement:\n\nBEGIN DBMS_STATS.GATHER_SYSTEM_STATS ( gathering_mode => 'NOWORKLOAD' ); END;\n\nOptionally, query the system statistics.\n\nFor example, run the following query:\n\nCOL PNAME FORMAT a15 SELECT PNAME, PVAL1 FROM SYS.AUX_STATS$ WHERE SNAME = 'SYSSTATS_MAIN';\n\nSee Also:\n\nOracle Database PL/SQL Packages and Types Reference to learn about the DBMS_STATS.GATHER_SYSTEM_STATS procedure\n\n13.4.4 Deleting System Statistics\n\nThe DBMS_STATS.DELETE_SYSTEM_STATS procedure deletes system statistics.\n\nThis procedure deletes workload statistics collected using the INTERVAL or START and STOP options, and then resets the default to noworkload statistics. However, if the stattab parameter specifies a table for storing statistics, then the subprogram deletes all system statistics with the associated statid from the statistics table.\n\nIf the database is newly created, then Oracle recommends deleting system statistics, shutting down the database, and then reopening the database. This sequence of steps ensures that the database establishes appropriate defaults for system statistics.\n\nAssumptions\n\nThis tutorial assumes the following:\n\nYou gathered statistics for a specific intensive workload, but no longer want the optimizer to use these statistics.\n\nYou stored workload statistics in the default location, not in a user-specified table.\n\nTo delete system statistics:\n\nIn SQL*Plus, log in to the database as a user with administrative privileges.\n\nDelete the system statistics.\n\nFor example, run the following statement:\n\nEXEC DBMS_STATS.DELETE_SYSTEM_STATS;\n\nSee Also:\n\nOracle Database PL/SQL Packages and Types Reference to learn about the DBMS_STATS.DELETE_SYSTEM_STATS procedure\n\n13.5 Running Statistics Gathering Functions in Reporting Mode\n\nYou can run the DBMS_STATS statistics gathering procedures in reporting mode.\n\nWhen you use the REPORT_* procedures, the optimizer does not actually gather statistics. Rather, the package reports objects that would be processed if you were to use a specified statistics gathering function.\n\nThe following table lists the DBMS_STATS.REPORT_GATHER_*_STATS functions. For all functions, the input parameters are the same as for the corresponding GATHER_*_STATS procedure, with the following additional parameters: detail_level and format. Supported formats are XML, HTML, and TEXT.\n\nTable 13-5 DBMS_STATS Reporting Mode Functions\n\nFunction Description\n\nAssumptions\n\nThis tutorial assumes that you want to generate an HTML report of the objects that would be affected by running GATHER_SCHEMA_STATS on the oe schema.\n\nTo report on objects affected by running GATHER_SCHEMA_STATS:\n\nStart SQL*Plus and connect to the database with administrator privileges.\n\nRun the DBMS_STATS.REPORT_GATHER_SCHEMA_STATS function.\n\nFor example, run the following commands in SQL*Plus:\n\nSET LINES 200 PAGES 0 SET LONG 100000 COLUMN REPORT FORMAT A200 VARIABLE my_report CLOB; BEGIN :my_report :=DBMS_STATS.REPORT_GATHER_SCHEMA_STATS( ownname => 'OE' , detail_level => 'TYPICAL' , format => 'HTML' ); END; /\n\nThe following graphic shows a partial example report:\n\nSee Also:\n\nOracle Database PL/SQL Packages and Types Reference to learn more about DBMS_STATS"
    }
}