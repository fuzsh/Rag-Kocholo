{
    "id": "dbpedia_5039_3",
    "rank": 34,
    "data": {
        "url": "https://github.com/scala/scala-collection-laws",
        "read_more_link": "",
        "language": "en",
        "title": "automatic generation of tests for the entire collections library",
        "top_image": "https://opengraph.githubassets.com/ea68d7c61c751953568d6b5bb66e8ea306f8ac17733a9e69b97d2b23c7a71bcf/scala/scala-collection-laws",
        "meta_img": "https://opengraph.githubassets.com/ea68d7c61c751953568d6b5bb66e8ea306f8ac17733a9e69b97d2b23c7a71bcf/scala/scala-collection-laws",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "partially-automatic generation of tests for the entire collections library - scala/scala-collection-laws",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/scala/scala-collection-laws",
        "text": "======================\n\nPartially automatic generation of tests for the Scala collections library. The goal is to have a quasi-comprehensive set of collections tests that will catch regressions in basic functionality in any collection.\n\nThese tests are expressed as a series of \"laws\": one-liners (mostly) that express relationships that should be true of some or all collections.\n\nThese laws are written into a series of collection-specific tests by a code generator (so that implicit resolution and the like is also tested) which can be run with a method call so the results can be inspected, or can be run from the command-line with results printed out, or can be invoked by JUnit as a standard test.\n\nEarlier versions of scala-collection-laws had several weird text-based DSLs. This has been abandoned in favor of plain Scala code with the sourcecode plugin helping to produce meaningful automatic reports.\n\nClone the repository, update build.sbt with the scalaVersion you want to test and a compatible sourcecode, and run\n\nbash run.sh\n\non a Unix-based machine. It should produce output that includes stuff like\n\nThis is the code generator and law framework in the laws folder generating source files in tests. The tests are then compiled, and the output continues with\n\nand finally ends with\n\nCongratuations! Your collections were quasi-comprehensively tested.\n\nIf you want to test changes to the compiler or standard library, you will presumably want to do something like the following.\n\nFork the Scala compiler somewhere on your machine. (You've probably done that already.)\n\nPublish the build locally by running sbt publishLocal and note what it's called (e.g. 2.13.0-pre-SNAPSHOT)\n\nFork sourcecode\n\nAlter sourcecode's build.sbt in the following ways: a. In baseSettings, change scalaVersion to the locally built compiler b. In baseSettings, you may also wish to change version to a custom name for your local build (e.g. I would change \"0.1.5-SNAPSHOT\" to \"0.1.5-local-SNAPSHOT\") c. Remove NativePlatform and maybe JSPlatform from lazy val sourcecode = crossProject(...) d. Remove the .nativeSettings and maybe .jsSettings from the end of the definition of lazy val sourcecode e. Remove lazy val native and maybe lazy val js from the end of the file f. Run sbt, enter project sourcecodeJVM and then publishLocal, noting what it's called\n\nAlter scala-collection-laws's build.sbt to request the local versions of the compiler and sourcecode\n\nNow you can run bash run.sh to commence testing. (Note--this only tests the JVM build.)\n\nEach time you change the library or compiler, you'll need to publish both the compiler and sourcecode locally before running collections-laws again.\n\nCatching a regression typically does not require deep knowledge of the workings of scala-collection-laws. Simply change the target version of Scala in the build.sbt file and use run.sh again.\n\nThe test files contain methods that try different combinations of inputs to laws that require the same inputs. If a single assertion fails in one of these methods, the testing in that method terminates.\n\nFor example, suppose we expected Iterator to obey\n\n(the backquotes indicate that the collection must have that method for the test to run).\n\nIn addition to the normal report, at the end we would see something like\n\nEvery time the law fails--for every collection that runs it, for every element type that is used for it--it will appear in the output list. Consequently, the list can be very long if something major has gone wrong.\n\nIn this case, there is only a single failure and the information provided allows us to replicate it in the REPL easily. In this case, we can see by inspection that the law is silly and go to Laws.scala line 1054 to fix it.\n\nIn the case of errors that are more mysterious, the test prints out enough information to manually reconstruct the test case, albeit with a little effort. In this case, one can manually create the Numbers, Ops, and Instance values like so:\n\nand used in a custom source file in the tests directory; or the variables used can be manually filled in and the test pasted in inline (not very interesting in this case; it's just def x = Iterator(0)--make sure to use def for collections with state!).\n\nIn principle one ought to be able to create a new test instance with e.g. val test = new Test_Root_Iterator_Int(num, ops, inst, 1054) inside SBT, but I've hit classloader issues before, so don't count on this working.\n\nThe test framework tries to catch runtime exceptions. Generally, as long as the collection can be built without error, the information will be similar to the relationship failure class. For instance, if we decide arrays should obey\n\n(which it would if we had negative indices running from the end of the array), we get the following:\n\nThe test, array and element type, and exception thrown are all visible from inspection, and replicating the error can be done as in the previous case.\n\nIf, however, there is an exception during creation of the collection, the error reporting is less complete. For instance, if we change iterator creation from\n\nto\n\nwe get the following error:\n\nplus similar errors for every other test that Iterator has. This situation could be improved (by better capturing context), but presently, this is all you have to go on.\n\nThe presumption is that compilation errors will be rare. If a change has caused a compilation error, you will have to work through SBT's error reporting facilities and look at the generated code to figure out what went wrong. Since each method is named after the line that the law came from, you can generally quickly get back to the offending law.\n\nIn some cases, the code generation itself may be inappropriate. In this case, the code generation routines in Generator#code and/or GenerateAll (both in Generator.scala) should be examined.\n\nThe collections tests will not pass successfully if even a single error is found. This requires the entire test-suite to avoid any existing bugs in the source code.\n\nThe convention for bugs is to create a new flag (in Flag.scala) with the issue number, e.g.\n\nThen, you decorate each affected collection with the bug, e.g. by changing the collection instantiator in InstantiatorsOf[A]#Imm from\n\nto\n\nFinally, you can create positive and negative versions of each test, as necessary.\n\nFor instance, if the functionality is simply broken, you would write a law like\n\nOn the other hand, if you want to verify the undesired behavior, you can write an alternate test for the buggy case:\n\nWhen the bug is fixed, it should be removed from the test sources. Presently there is no ability to have a single set of laws that handles multiple versions of Scala with different sets of bugs, but git branches can be used to maintain slightly different versions of the source for each Scala version.\n\nLaws are all specified in Laws.scala inside strings which are marked for code generation by appending .law, possibly with arguments.\n\nLaws should only be run on collections that actually have the appropriate methods. In order to mark which methods in the code need to be tested, write them inside backticks, i.e.\n\n(Note that the above is not a valid law, as tail and drop(1) have different behavior on empty collections.)\n\nWithin the code of the law you have access to sixteen variables whose values will be varied if use is detected, and three or five types:\n\nType Name Meaning A The type of element stored in the collection under test B The type that A is mapped to via the function g CC The type of the collection (not parametric!) K Maps only: the type of the keys V Maps only: the type of the values\n\nNote that CC is the fully applied type, e.g. Iterator[Int]; this is necessary in case CC has no type parameters or has multiple parameters, e.g. BitSet or Map[String, Long].\n\nNote that A is identically (K, V) for maps.\n\nVariable Name Expected Values Meaning a an element Some single instance of the collection's element type b an element Some single instance of the type that A is mapped to via g x a collection May be empty or have one or more elements xsize x.size Contains the pre-computed size of x y another collection In general is not the same as x (but can be) ysize y.size Precomputed size of y n 0 until x.length An index into the x collection f A => A Transformation that does not alter element type g A => B Transformation that does alter element type op (A, A) => A An operator that collapses elements p A => Boolean A predicate that tests the elements pf partial function A transformation defined on only some elements; does not alter element type n in 0 until xsize An integer value that could be used as a valid index into x nn non-negative An integer value that is a valid index, but maybe not for x m in 0 until ysize An integer value that could be used as a valid index into y mm non-negative An integer value that is a valid index, but maybe not for y; in general is different than nn r integer An integer value that could be anything\n\nYou can find the range of variation for these variables in Numbers.scala for n, nn, m, mm, and r; in Ops.scala for f, g, op, p, and pf; and in Instantiator.scala for a, x, and y (xsize and ysize are determined by x and y). In the last case, look for possible_a, possible_x, and possible_y.\n\nIf you write a law that doesn't compile, e.g.\n\nYou will get compile errors after the code generation phase:\n\nUsually this is enough to see the problem, but as the source line is also given, one can inspect the full generated code if the error message is inadequate on its own.\n\nThe primary way to restrict the applicability of laws is to use the flags in Flag.scala. SEQ, SET, and MAP are particularly useful flags, as these collections have rather different behavior from each other.\n\nCollections are marked with a subset of flags; in order to run only collections that are marked, name the flag in the parameters of the law method:\n\nIn contrast, if you want to only consider collections that do not have the flag, append .! to the flag name:\n\nOnly those collections that have all the positive flags and are missing all the negative flags will have a test generated for that law. Note that if the conditions are so restrictive that no collections are tested, the law will be listed as untested in the output.\n\nAdditional testing is available at runtime. The best way to achieve this is to use the Filt helper object which allows you to query the values of the parameters before the test is actually run. For instance,\n\ndemands that all permutations are distinct, but would take impractically long for large collections, so it only runs when xsize is no more than 8.\n\nCollections are specified in Instantiators.scala. There are objects for each concrete element type, and within that objects for each namespace that contain builders for the collections. These specify how to build the relevant collection from an array of the appropriate elements.\n\nThere is a fair bit of code duplication, as the type signatures get very hairy if generalized; this is not clearly the right strategy, however.\n\nIn any case, if you're using an existing namespace, you can simply add the collection to the appropriate place. For instance, if there were a new Rope collection in collection.immutable, one would add to InstantiatorsOf[A], inside the Imm object, the following line:\n\nIf it is a map, add to InstantiatorsOfKV[K, V] instead. If the element type must be restricted, add to the element-specific objects, e.g. InstantiatorsOfInt.\n\nIf the namespace is different, e.g. collection.concurrent, a new inner object should be created much like Imm. Cutting and pasting should be sufficient; use Mut as a template if the collection has state that can alter (in which case, code that references x and y will get freshly generated copies each time they are named), or Imm if not (in which case the collection is created once and cached).\n\nFor instance, for collection.concurrent we would have\n\nNote that the val name must be the collection name with the first letter lower-cased. The generator uses this val name to generate the type signature of the class.\n\nFinally, you must find the val force lines for each fully specified instantiator object and add :: Conc to them (to actually add imaginarySkipList to the list of collections for which to generate tests).\n\nOnce the collection has been created, a parallel structure needs to be created in Generators.scala to actually generate code for the class. In the future, perhaps it would be better to combine these two so one cannot specify an instantiator without a corresponding generator.\n\nIn any case, simply add the collection to the element-type-specific generator objects, in the appropriate place that mirrors the path to the instantiator (this is mostly just convention, but it makes it easier to avoid mistakes). For instance, ropes would be added to both AllIntGenerators and AllStrGenerators inside Imm as\n\nwhile for Conc one would create a new object Conc inside AllIntGenerators and AllStrGenerators that looked like\n\nand then :: Conc would be added to val force in both All___Generators objects.\n\nFollow the examples of BitSet and/or LongMap; between them they illustrate most or all of the issues one must address to get a specific collection type working.\n\nYou will also need to add the new element-type-generator to the write method in GenerateAll.\n\nThanks for reading! Good luck!"
    }
}