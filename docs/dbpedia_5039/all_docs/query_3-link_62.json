{
    "id": "dbpedia_5039_3",
    "rank": 62,
    "data": {
        "url": "https://docs.python.org/3/library/gc.html",
        "read_more_link": "",
        "language": "en",
        "title": "gc â Garbage Collector interface",
        "top_image": "https://docs.python.org/3/_static/og-image.png",
        "meta_img": "https://docs.python.org/3/_static/og-image.png",
        "images": [
            "https://docs.python.org/3/_static/py.svg",
            "https://docs.python.org/3/_static/py.svg",
            "https://docs.python.org/3/_static/py.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "This module provides an interface to the optional garbage collector. It provides the ability to disable the collector, tune the collection frequency, and set debugging options. It also provides acc...",
        "meta_lang": "en",
        "meta_favicon": "../_static/py.svg",
        "meta_site_name": "Python documentation",
        "canonical_link": "https://docs.python.org/3/library/gc.html",
        "text": "gc â Garbage Collector interfaceÂ¶\n\nThis module provides an interface to the optional garbage collector. It provides the ability to disable the collector, tune the collection frequency, and set debugging options. It also provides access to unreachable objects that the collector found but cannot free. Since the collector supplements the reference counting already used in Python, you can disable the collector if you are sure your program does not create reference cycles. Automatic collection can be disabled by calling gc.disable(). To debug a leaking program call gc.set_debug(gc.DEBUG_LEAK). Notice that this includes gc.DEBUG_SAVEALL, causing garbage-collected objects to be saved in gc.garbage for inspection.\n\nThe gc module provides the following functions:\n\ngc.enable()Â¶\n\nEnable automatic garbage collection.\n\ngc.disable()Â¶\n\nDisable automatic garbage collection.\n\ngc.isenabled()Â¶\n\nReturn True if automatic collection is enabled.\n\ngc.collect(generation=2)Â¶\n\nWith no arguments, run a full collection. The optional argument generation may be an integer specifying which generation to collect (from 0 to 2). A ValueError is raised if the generation number is invalid. The number of unreachable objects found is returned.\n\nThe free lists maintained for a number of built-in types are cleared whenever a full collection or collection of the highest generation (2) is run. Not all items in some free lists may be freed due to the particular implementation, in particular float.\n\nThe effect of calling gc.collect() while the interpreter is already performing a collection is undefined.\n\ngc.set_debug(flags)Â¶\n\nSet the garbage collection debugging flags. Debugging information will be written to sys.stderr. See below for a list of debugging flags which can be combined using bit operations to control debugging.\n\ngc.get_debug()Â¶\n\nReturn the debugging flags currently set.\n\ngc.get_objects(generation=None)Â¶\n\nReturns a list of all objects tracked by the collector, excluding the list returned. If generation is not None, return only the objects tracked by the collector that are in that generation.\n\nChanged in version 3.8: New generation parameter.\n\nRaises an auditing event gc.get_objects with argument generation.\n\ngc.get_stats()Â¶\n\nReturn a list of three per-generation dictionaries containing collection statistics since interpreter start. The number of keys may change in the future, but currently each dictionary will contain the following items:\n\ncollections is the number of times this generation was collected;\n\ncollected is the total number of objects collected inside this generation;\n\nuncollectable is the total number of objects which were found to be uncollectable (and were therefore moved to the garbage list) inside this generation.\n\nAdded in version 3.4.\n\ngc.set_threshold(threshold0[, threshold1[, threshold2]])Â¶\n\nSet the garbage collection thresholds (the collection frequency). Setting threshold0 to zero disables collection.\n\nThe GC classifies objects into three generations depending on how many collection sweeps they have survived. New objects are placed in the youngest generation (generation 0). If an object survives a collection it is moved into the next older generation. Since generation 2 is the oldest generation, objects in that generation remain there after a collection. In order to decide when to run, the collector keeps track of the number object allocations and deallocations since the last collection. When the number of allocations minus the number of deallocations exceeds threshold0, collection starts. Initially only generation 0 is examined. If generation 0 has been examined more than threshold1 times since generation 1 has been examined, then generation 1 is examined as well. With the third generation, things are a bit more complicated, see Collecting the oldest generation for more information.\n\ngc.get_count()Â¶\n\nReturn the current collection counts as a tuple of (count0, count1, count2).\n\ngc.get_threshold()Â¶\n\nReturn the current collection thresholds as a tuple of (threshold0, threshold1, threshold2).\n\ngc.get_referrers(*objs)Â¶\n\nReturn the list of objects that directly refer to any of objs. This function will only locate those containers which support garbage collection; extension types which do refer to other objects but do not support garbage collection will not be found.\n\nNote that objects which have already been dereferenced, but which live in cycles and have not yet been collected by the garbage collector can be listed among the resulting referrers. To get only currently live objects, call collect() before calling get_referrers().\n\nWarning\n\nCare must be taken when using objects returned by get_referrers() because some of them could still be under construction and hence in a temporarily invalid state. Avoid using get_referrers() for any purpose other than debugging.\n\nRaises an auditing event gc.get_referrers with argument objs.\n\ngc.get_referents(*objs)Â¶\n\nReturn a list of objects directly referred to by any of the arguments. The referents returned are those objects visited by the argumentsâ C-level tp_traverse methods (if any), and may not be all objects actually directly reachable. tp_traverse methods are supported only by objects that support garbage collection, and are only required to visit objects that may be involved in a cycle. So, for example, if an integer is directly reachable from an argument, that integer object may or may not appear in the result list.\n\nRaises an auditing event gc.get_referents with argument objs.\n\ngc.is_tracked(obj)Â¶\n\nReturns True if the object is currently tracked by the garbage collector, False otherwise. As a general rule, instances of atomic types arenât tracked and instances of non-atomic types (containers, user-defined objectsâ¦) are. However, some type-specific optimizations can be present in order to suppress the garbage collector footprint of simple instances (e.g. dicts containing only atomic keys and values):\n\n>>> gc.is_tracked(0) False >>> gc.is_tracked(\"a\") False >>> gc.is_tracked([]) True >>> gc.is_tracked({}) False >>> gc.is_tracked({\"a\": 1}) False >>> gc.is_tracked({\"a\": []}) True\n\nAdded in version 3.1.\n\ngc.is_finalized(obj)Â¶\n\nReturns True if the given object has been finalized by the garbage collector, False otherwise.\n\n>>> x = None >>> class Lazarus: ... def __del__(self): ... global x ... x = self ... >>> lazarus = Lazarus() >>> gc.is_finalized(lazarus) False >>> del lazarus >>> gc.is_finalized(x) True\n\nAdded in version 3.9.\n\ngc.freeze()Â¶\n\nFreeze all the objects tracked by the garbage collector; move them to a permanent generation and ignore them in all the future collections.\n\nIf a process will fork() without exec(), avoiding unnecessary copy-on-write in child processes will maximize memory sharing and reduce overall memory usage. This requires both avoiding creation of freed âholesâ in memory pages in the parent process and ensuring that GC collections in child processes wonât touch the gc_refs counter of long-lived objects originating in the parent process. To accomplish both, call gc.disable() early in the parent process, gc.freeze() right before fork(), and gc.enable() early in child processes.\n\nAdded in version 3.7.\n\ngc.unfreeze()Â¶\n\nUnfreeze the objects in the permanent generation, put them back into the oldest generation.\n\nAdded in version 3.7.\n\ngc.get_freeze_count()Â¶\n\nReturn the number of objects in the permanent generation.\n\nAdded in version 3.7.\n\nThe following variables are provided for read-only access (you can mutate the values but should not rebind them):\n\ngc.garbageÂ¶\n\nA list of objects which the collector found to be unreachable but could not be freed (uncollectable objects). Starting with Python 3.4, this list should be empty most of the time, except when using instances of C extension types with a non-NULL tp_del slot.\n\nIf DEBUG_SAVEALL is set, then all unreachable objects will be added to this list rather than freed.\n\nChanged in version 3.2: If this list is non-empty at interpreter shutdown, a ResourceWarning is emitted, which is silent by default. If DEBUG_UNCOLLECTABLE is set, in addition all uncollectable objects are printed.\n\nChanged in version 3.4: Following PEP 442, objects with a __del__() method donât end up in gc.garbage anymore.\n\nThe following constants are provided for use with set_debug():\n\ngc.DEBUG_STATSÂ¶\n\nPrint statistics during collection. This information can be useful when tuning the collection frequency.\n\ngc.DEBUG_COLLECTABLEÂ¶\n\nPrint information on collectable objects found.\n\ngc.DEBUG_UNCOLLECTABLEÂ¶\n\nPrint information of uncollectable objects found (objects which are not reachable but cannot be freed by the collector). These objects will be added to the garbage list.\n\nChanged in version 3.2: Also print the contents of the garbage list at interpreter shutdown, if it isnât empty.\n\ngc.DEBUG_SAVEALLÂ¶\n\nWhen set, all unreachable objects found will be appended to garbage rather than being freed. This can be useful for debugging a leaking program."
    }
}