{
    "id": "dbpedia_5039_3",
    "rank": 17,
    "data": {
        "url": "https://newrelic.com/blog/best-practices/java-garbage-collection",
        "read_more_link": "",
        "language": "en",
        "title": "Java garbage collection: What is it and how does it work?",
        "top_image": "https://newrelic.com/sites/default/files/styles/og_image/public/2022-08/nr1_java.png?h=61224e8f&itok=sw4xKu3y",
        "meta_img": "https://newrelic.com/sites/default/files/styles/og_image/public/2022-08/nr1_java.png?h=61224e8f&itok=sw4xKu3y",
        "images": [
            "https://newrelic.com/sites/default/files/2023-09/APM.svg",
            "https://newrelic.com/sites/default/files/2024-08/customer-stories-desktop-jpg.jpg",
            "https://newrelic.com/sites/default/files/2024-07/web-value-calculator-icon.svg",
            "https://newrelic.com/sites/default/files/2024-04/kubernates.svg",
            "https://newrelic.com/sites/default/files/2024-04/retail.svg",
            "https://newrelic.com/sites/default/files/2023-08/developers-kubernates.svg",
            "https://newrelic.com/sites/default/files/2023-08/developers-mobile-monitoring.svg",
            "https://newrelic.com/sites/default/files/2023-08/developers-browser-tracking.svg",
            "https://newrelic.com/sites/default/files/2024-04/kubernates.svg",
            "https://newrelic.com/sites/default/files/2024-04/security.svg",
            "https://newrelic.com/sites/default/files/2024-04/mag-glass.svg",
            "https://newrelic.com/sites/default/files/2024-04/1-APM.svg",
            "https://newrelic.com/sites/default/files/2024-04/2-infrastructure.svg",
            "https://newrelic.com/sites/default/files/2024-04/3-architecture.svg",
            "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-06/franz_knupfer.jpg?h=16e01b40&itok=51F4FXpP 1x, /sites/default/files/styles/1x1_200w/public/2021-06/franz_knupfer.jpg?h=16e01b40&itok=EGHdkcvO 2x",
            "https://newrelic.com/sites/default/files/styles/16x9_300w/public/2022-06/java-mascot.png?h=d2c2ee4d&itok=4_YY0pgI",
            "https://newrelic.com/sites/default/files/styles/16x9_300w/public/2024-04/java-report-2024-promo-600x338.png?h=c66d06c9&itok=nOKSyTFf",
            "https://newrelic.com/sites/default/files/styles/900w/public/2022-08/nr1_java.png?itok=XhJKWviL",
            "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-06/franz_knupfer.jpg?h=16e01b40&itok=51F4FXpP 1x, /sites/default/files/styles/1x1_200w/public/2021-06/franz_knupfer.jpg?h=16e01b40&itok=EGHdkcvO 2x",
            "https://newrelic.com/sites/default/files/styles/16x9_300w/public/2022-08/nr1_java.png?h=61224e8f&itok=eym8UR8d",
            "https://newrelic.com/sites/default/files/styles/16x9_300w/public/2024-08/nr-2024-gartner-mq-social-graphics-dark-02c-1200x630%20%283%29.png?h=ec041e41&itok=C4IRls9Q",
            "https://newrelic.com/sites/default/files/styles/16x9_300w/public/2023-05/Web-Mobile-engineer-collab-1920x1080%20blog%20main%20image_0.jpg?h=d1cb525d&itok=5xqGA5oE",
            "https://newrelic.com/themes/custom/erno/assets/images/icons/misc/ccpa.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Franz Knupfer"
        ],
        "publish_date": "2024-01-24T00:00:00",
        "summary": "",
        "meta_description": "Learn about how Java garbage collection works and how you can monitor your application to ensure garbage collection isn't impacting performance.",
        "meta_lang": "en",
        "meta_favicon": "/themes/custom/erno/assets/images/metadata/favicon.ico",
        "meta_site_name": "New Relic",
        "canonical_link": "https://newrelic.com/blog/best-practices/java-garbage-collection",
        "text": "How does garbage collection work in Java?\n\nDuring the garbage collection process, the collector scans different parts of the heap, looking for objects that are no longer in use. If an object no longer has any references to it from elsewhere in the application, the collector removes the object, freeing up memory in the heap. This process continues until all unused objects are successfully reclaimed.\n\nSometimes, a developer will inadvertently write code that continues to be referenced even though it’s no longer being used. The garbage collector will not remove objects that are being referenced in this way, leading to memory leaks. After memory leaks are created, it can be hard to detect the cause, so it’s important to prevent memory leaks by ensuring that there are no references to unused objects.\n\nTo ensure that garbage collectors work efficiently, the JVM separates the heap into separate spaces, and then garbage collectors use a mark-and-sweep algorithm to traverse these spaces and clear out unused objects. Let’s take a closer look at the different generations in the memory heap, then go over the basics of the mark-and-sweep algorithm.\n\nGenerational garbage collection\n\nTo fully understand how Java garbage collection works, it’s important to know about the different generations in the memory heap, which help make garbage collection more efficient. These generations are split into these types of spaces:\n\nJava eden space\n\nThe eden space in Java is a memory pool where objects are created. When the eden space is full, the garbage collector either removes objects if they are no longer in use or stores them in the survivor space if they are still being used. This space is considered part of the young generation in the memory heap.\n\nJava survivor spaces\n\nThere are two survivor spaces in the JVM: survivor zero and survivor one. This space is also part of the young generation.\n\nJava tenured space\n\nThe tenured space is where long-lived objects are stored. Objects are eventually moved to this space if they survive a certain number of garbage collection cycles. This space is much larger than the eden space and the garbage collector checks it less often. This space is considered the old generation in the heap.\n\nSo how do these different spaces make garbage collection more efficient? Well, garbage collection occurs most frequently in the eden space because many new objects don’t need to stay in memory for very long. However, it wouldn’t make sense for the garbage collector to keep checking uncollected objects over and over, particularly if an object needs to remain in the heap for a long time. That’s an inefficient use of the collector. By moving objects into survivor and tenured spaces, the garbage collector knows that there is a higher likelihood that the objects there will need to remain in memory, so it checks those areas less frequently. Because the tenured space is much larger than the eden space, it fills up less regularly and the garbage collector doesn’t check it as much. The potential downside is that the tenured space is more prone to memory leaks since it isn’t checked as regularly.\n\nThe garbage collection cycles in the young generation (eden and survivor spaces) are considered minor garbage collection. The garbage collection cycles in the old generation (tenured space) is known as old garbage collection or major garbage collection because it takes longer than minor garbage collection. As you might guess, the minor garbage collection cycle is a simpler and faster process than major garbage collection, which makes sense because it occurs much more frequently and needs to be efficient.\n\nIn past versions of Java (before Java 8), there was a third area of memory known as permanent generation (perm gen or PermGen) that included required application metadata for the JVM. However, the permanent generation was removed in Java 8.\n\nMark-and-sweep\n\nThe Java garbage collection process uses a mark-and-sweep algorithm. Here’s how that works:\n\nThere are two phases in this algorithm: mark followed by sweep.\n\nWhen a Java object is created in the heap, it has a mark bit that is set to 0 (false).\n\nDuring the mark phase, the garbage collector traverses object trees starting at their roots. When an object is reachable from the root, the mark bit is set to 1 (true). Meanwhile, the mark bits for unreachable objects is unchanged.\n\nDuring the sweep phase, the garbage collector traverses the heap, reclaiming memory from all items with a mark bit of 0 (false).\n\nJava garbage collection benefits\n\nJava garbage collection offers several benefits for memory management in Java applications. Here are the most important:\n\nAutomatic memory management:\n\nGarbage collection automates the memory management process, reducing the burden on developers to manually allocate and deallocate memory.\n\nPrevention of memory leaks:\n\nGarbage collection helps prevent memory leaks by automatically reclaiming memory occupied by objects that are no longer reachable or referenced by the program.\n\nIncreased productivity:\n\nDevelopers can focus more on application logic and features without worrying extensively about memory management, leading to increased productivity and faster development cycles.\n\nEnhanced application stability:\n\nAutomatic memory management reduces the likelihood of memory-related errors, such as segmentation faults or access violations, contributing to enhanced application stability.\n\nAdaptability to varied workloads:\n\nJava provides different garbage collection algorithms to suit diverse application workloads and requirements. This adaptability allows developers to choose the most appropriate algorithm for their specific scenarios.\n\nOptimized performance:\n\nEfficient garbage collection algorithms, when tuned properly, contribute to optimized performance by minimizing pause times and ensuring that the application spends more time executing useful code.\n\nWhat triggers Java garbage collection?\n\nThere are three major types of events that trigger garbage collection in the heap.\n\nMinor events: These occur when the eden space is full and objects are moved to a survivor. A minor event happens within the young area.\n\nMixed events: These are minor events that reclaim old generation objects.\n\nMajor events: These clear space in both the young and old generations, which takes longer than other types of garbage collection events.\n\nJava garbage collection types & strategies\n\nJava includes four different options for garbage collectors, each with its own pros and cons.\n\nSerial garbage collector\n\nThe serial garbage collector is typically used for smaller, single-threaded environments. Don’t use it in a production environment because the process of garbage collection takes over the thread, freezing other processes. This is known as a “stop the world” event.\n\nParallel garbage collector\n\nThe parallel garbage collector is JVM’s default garbage collector. As the name implies this garbage collector uses multiple (parallel) threads. Because it can also use multiple CPUs to speed up throughput, it’s also known as the throughput collector. However, when running garbage collection, it will also freeze application threads.\n\nConcurrent mark-and-sweep (CMS) collector\n\nLike the parallel garbage collector, the concurrent mark-and-sweep collector uses multiple threads. However, this collector is known as a “low-pause” collector because it freezes application threads less frequently, making it more appropriate for user-facing applications where “stop the world” events will cause issues for your users. It can only garbage collect the old generation concurrently, though—it still needs to freeze execution when collecting the young generation. Also, because the collector’s threads execute at the same time as the application’s threads, it does use more processing power than other garbage collectors.\n\nGarbage first (G1) garbage collector\n\nThe G1 garbage collector takes a different approach altogether. Instead of collecting the young and old generations separately, it can collect both at once by splitting the heap into many spaces—not just the eden, survivor, and tenured spaces that other garbage collectors use. This allows it to clear smaller regions instead of clearing large regions all at once, optimizing the collection process. It runs concurrently like the CMS collector, but it very rarely freezes execution and can collect both the young and old generations concurrently.\n\nIs it possible to force garbage collection?\n\nUnfortunately, you can’t force garbage collection, even if your JVM is utilizing close to 100% of the heap. However, there are a few tricks you can use to help ensure that Java objects are garbage collected.\n\nEnsuring a Java object is removed during garbage collection\n\nYou can’t force garbage collection on a specific object, but you can update objects so they are no longer accessible to the rest of the application. This lets the garbage collector know that those objects should be removed.\n\nYou can make objects inaccessible in the following ways:\n\nCreate an object inside a method. After methods are executed, all objects called within those methods become unreachable, which makes them eligible for garbage collection.\n\nNullify the reference variable. You can change a reference variable to NULL. As long as all references to an object are removed, that object will become unreachable, which lets the garbage collector know the object can be removed.\n\nReassign the reference variable. Instead of nullifying the reference variable, you can also reassign the reference to another object. Once again, as long as all references to an object are removed, either through making reference variables NULL or reassigning them, the object will become inaccessible, leading to it being removed during the garbage collection process.\n\nCreate an anonymous object. An anonymous object doesn’t have a reference, so the garbage collector will mark and remove it during the next garbage collection cycle.\n\nJava garbage collection best practices\n\nJava garbage collection best practices may vary based on the specific characteristics of your application. We recommend regularly assessing and adjusting your garbage collection strategies to meet evolving performance demands. Here are some strategies to get you started:\n\nChoose the right garbage collector:\n\nSelect a garbage collector based on your application's requirements and characteristics. Different collectors are optimized for various scenarios, such as low latency, throughput, or minimal pause times.\n\nMonitor and analyze garbage collection logs:\n\nRegularly analyze garbage collection logs to identify patterns, diagnose issues, and fine-tune garbage collection settings.\n\nOptimize heap size:\n\nAdjust the heap size to match the application's memory requirements. An appropriately sized heap helps avoid issues like frequent garbage collection or out-of-memory errors.\n\nTune garbage collection parameters:\n\nUnderstand and adjust garbage collection parameters such as the size of the Young and Old Generations, thread counts, and collection intervals. This tuning can significantly impact performance.\n\nMinimize object creation:\n\nMinimize unnecessary object creation to reduce the frequency of garbage collection cycles. Reuse objects when possible, and be mindful of object lifecycle management.\n\nUse parallelism and concurrency:\n\nLeverage parallel and concurrent garbage collection options for improved performance. Parallel collectors can utilize multiple threads, reducing pause times.\n\nMonitoring Java application performance with New Relic\n\nJava garbage collection can impact the performance of your Java application, especially if you are using a garbage collector that freezes threads. Also, it’s important to understand how the garbage collection process works, and to ensure that the garbage collector knows when to remove objects from the heap. Otherwise, you can run into performance issues due to memory leaks and other problems. So how do you monitor your Java application to optimize performance and detect and triage issues?"
    }
}