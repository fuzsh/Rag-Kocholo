{
    "id": "dbpedia_5039_3",
    "rank": 30,
    "data": {
        "url": "https://typesense.org/docs/0.25.1/api/collections.html",
        "read_more_link": "",
        "language": "en",
        "title": "Collections",
        "top_image": "https://typesense.org/docs/images/opengraph_banner.png",
        "meta_img": "https://typesense.org/docs/images/opengraph_banner.png",
        "images": [
            "https://typesense.org/docs/images/typesense_logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Documentation for Typesense Search",
        "meta_lang": "en",
        "meta_favicon": "/docs/favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://typesense.org/26.0/api/collections.html",
        "text": "# Collections\n\nIn Typesense, every record you index is called a Document and a group of documents with similar fields is called a Collection. A Collection is roughly equivalent to a table in a relational database.\n\n# Create a collection\n\nBefore we can add documents to Typesense, we need to first create a Collection - we give it a name and describe the fields that will be indexed from our Documents. We call this definition the collection's schema, which is just a fancy term to describe the fields (and their data types) in your documents.\n\nTIP\n\nIt might help to think of defining a collection \"schema\" as being similar to defining \"types\" in a strongly-typed programming language like Typescript, C, Java, Dart, Rust, etc. This ensures that the documents you add to your collection have consistent data types and are validated, and this helps prevent a whole class of errors you might typically see with mis-matched or inconsistent data types across documents.\n\nThere are two ways to specify a schema:\n\nPre-define all the fields to be indexed from your documents OR\n\nHave Typesense automatically detect your fields and data types based on the documents you index.\n\nThe simplest option is #2 where you don't have to worry about defining an explicit schema. But if you need more fine-grained control and/or validation, you want to use #1 or even mix both together.\n\n# With pre-defined schema\n\nLet's first create a collection with an explicit, pre-defined schema.\n\nThis option gives you fine-grained control over your document fields' data types and configures your collection to reject documents that don't match the data types defined in your schema (by default).\n\nIf you want Typesense to automatically detect your schema for you, skip over to auto-schema detection.\n\nSee Schema Parameters for all available options, and Field Types for all available data types.\n\nSample Response\n\nDefinition\n\nPOST ${TYPESENSE_HOST}/collections\n\n# With auto schema detection\n\nIf your field names are dynamic and not known upfront, or if you just want to keep things simple and index all fields you send in your documents by default, auto-schema detection should help you.\n\nYou can define a wildcard field with the name .* and type auto to let Typesense automatically detect the type of the fields when you add documents to the collection. In fact, you can use any RegEx expression to define a field name.\n\nWhen a .* field is defined this way, all the fields in a document are automatically indexed for searching and filtering.\n\n# Data Coercion\n\nSay you've set type: auto for a particular field (or fields) (eg: popularity_score) in a collection and send the first document as:\n\nSince popularity_score has type: auto, the data-type will automatically be set to int64 internally.\n\nWhat happens when the next document's popularity_score field is not an integer field, but a string? For eg:\n\nBy default, Typesense will try to coerce (convert) the value to the previously inferred type. So in this example, since the first document had a numeric data-type for popularity_score, the second document's popularity_score field will be coerced to an integer from string.\n\nHowever, this may not always work - (for eg: say the value has alphabets, it can't be coerced to an integer). In such cases, when Typesense is unable to coerce the field value to the previously inferred type, the indexing will fail with the appropriate error.\n\n# Faceting fields with auto-schema detection\n\nFaceting is not enabled for a wildcard field {\"name\": \".*\" , ...}, since that can consume a lot of memory, especially for large text fields. However, you can still explicitly define specific fields (with or without RegEx names) to facet by setting facet: true for them.\n\nFor e.g, when you define a schema like this:\n\nThis will only set field names that end with _facet in the document, as a facet.\n\n# Geopoint and auto-schema detection\n\nA geopoint field requires an explicit type definition, as the geo field value is represented as a 2-element float field and we cannot differentiate between a lat/long definition and an actual float array.\n\n# Indexing all but some fields\n\nIf you have a case where you do want to index all fields in the document, except for a few fields, you can use the {\"index\": false, \"optional\": true} settings to exclude fields.\n\nNote: it is not currently possible to have a mandatory field excluded from the indexing, hence the setting to optional.\n\nFor eg, if you want to index all fields, except for fields that start with description_, you can use a schema like this:\n\n# Schema parameters\n\nParameter Required Description name yes Name of the collection you wish to create. fields yes A list of fields that you wish to index for querying, filtering and faceting. For each field, you have to specify at least it's name and type.\n\nEg: {\"name\": \"title\", \"type\": \"string\", \"facet\": false, \"index\": true}\n\nname can be a simple string like \"name\": \"score\". Or you can also use a RegEx to specify field names matching a pattern. For eg: if you want to specify that all fields starting with score_ should be an integer, you can set name as \"name\": \"score_.*\".\n\nDeclaring a field as optional\n\nA field can be declared as optional by setting \"optional\": true.\n\nDeclaring a field as a facet\n\nA field can be declared as a facetable field by setting \"facet\": true. Faceted fields are indexed verbatim without any tokenization or preprocessing. For example, if you are building a product search, color and brand could be defined as facet fields. Once a field is enabled for faceting in the schema, it can be used in the facet_by search parameter.\n\nDeclaring a field as un-indexed\n\nYou can set a field as un-indexed by setting \"index\": false. This is useful when used along with auto schema detection and you need to exclude certain fields from indexing.\n\nConfiguring language-specific tokenization:\n\nThe default tokenizer that Typesense uses works for most languages, especially ones that separate words by spaces. However, based on feedback from users, we've added locale specific customizations for the following languages. You can enable these customizations for a field, by setting a field called locale inside the field definition. Eg: {name: 'title', type: 'string', locale: 'ja'} will enable the Japanese locale customizations for the field named title.\n\nHere's the list of all language-specific customizations:\n\nja - Japanese\n\nzh - Chinese\n\nko - Korean\n\nth - Thai\n\nel - Greek\n\nru - Russian\n\nsr - Serbian / Cyrillic\n\nuk - Ukrainian\n\nbe - Belarusian\n\nFor all other languages, you don't have to set the locale field.\n\ntoken_separators no List of symbols or special characters to be used for splitting the text into individual words in addition to space and new-line characters.\n\nFor e.g. you can add - (hyphen) to this list to make a word like non-stick to be split on hyphen and indexed as two separate words.\n\nRead this guide article for more examples on how to use this setting. symbols_to_index no List of symbols or special characters to be indexed.\n\nFor e.g. you can add + to this list to make the word c++ indexable verbatim.\n\nRead this guide article for more examples on how to use this setting. default_sorting_field no The name of an int32 / float field that determines the order in which the search results are ranked when a sort_by clause is not provided during searching. This field must indicate some kind of popularity. For example, in a product search application, you could define num_reviews field as the default_sorting_field.\n\nAdditionally, when a word in a search query matches multiple possible words (either because of a typo or during a prefix search), this parameter is used to rank such equally matching tokens. For e.g. both \"john\" and \"joan\" are 1-typo away from \"jofn\". Similarly, in a prefix search, both \"apple\" and \"apply\" would match the prefix \"app\". In these cases, the default_sorting_field is used as the tie-breaker to rank.\n\n# Field types\n\nTypesense allows you to index the following types of fields:\n\ntype Description string String values string[] Array of strings int32 Integer values up to 2,147,483,647 int32[] Array of int32 int64 Integer values larger than 2,147,483,647 int64[] Array of int64 float Floating point / decimal numbers float[] Array of floating point / decimal numbers bool true or false bool[] Array of booleans geopoint Latitude and longitude specified as [lat, lng]. Read more here. geopoint[]geosearch.md Arrays of Latitude and longitude specified as [[lat1, lng1], [lat2, lng2]]. Read more here. object Nested objects. Read more here. object[] Arrays of nested objects. Read more here. string* Special type that automatically converts values to a string or string[]. auto Special type that automatically attempts to infer the data type based on the documents added to the collection. See automatic schema detection.\n\n# Cloning a collection schema\n\nHere's how you can clone an existing collection's schema (documents are not copied), overrides and synonyms.\n\nThe above API call will create a new collection called new_coll that contains the schema, overrides and synonyms of the collection existing_coll. The actual documents in the existing_coll collection are not copied, so this is primarily useful for creating new collections from an existing reference template.\n\n# Notes on indexing common types of data\n\nHere's how to index other common types of data, using the basic primitives in the table above:\n\nNested fields / objects\n\nDates\n\nOther Types\n\n# Indexing nested fields\n\nTypesense supports indexing nested objects (and array of objects) from v0.24.\n\nYou must first enable nested fields at a collection level via the enable_nested_fields schema property, and the object or object[] data type:\n\nWhen you now search on an object field name, all sub-fields will be automatically searched. Use a dot notation to refer to specific sub-fields, e.g. person.last_name or person.school.name.\n\nYou can also index specific sub-fields within a nested object. For eg, if your document looks like this:\n\nAnd say you only want to index the zip field inside the address nested object, without indexing other fields like line_1, you can specify this in the schema like this:\n\nTo index specific fields inside an array of objects, you want to specify an array data type. For eg, if your document looks like this:\n\nAnd say you only want to index the zip field inside each address object in the addresses array of objects, without indexing other fields, you can specify this in the schema like this:\n\nNote\n\nIf there are overlapping definitions for nested fields at different levels of the nested hierarchy, the broader definition will take precedence over the definition for a sub-field.\n\nIndexing nested objects via flattening\n\nYou can also flatten objects and arrays of objects into top-level keys before sending the data into Typesense.\n\nFor example, a document like this containing nested objects:\n\nwould need to be flattened as:\n\nbefore indexing it into Typesense.\n\nTo simplify traversing the data in the results, you might want to send both the flattened and unflattened version of the nested fields into Typesense, and only set the flattened keys as indexed in the collection's schema and use them for search/filtering/faceting. At display time when parsing the results, you can then use the nested version.\n\nDates need to be converted into Unix timestamps (opens new window) and stored as int64 fields in Typesense. Most languages have libraries that help do this conversion for you.\n\nYou'll then be able to use numerical operators like <, >, etc to filter records that are before or after or between dates.\n\n# Indexing other types of data\n\nRead our dedicated guide article on how to index other common types of data like emails, phone numbers, SKUs, model numbers, etc here.\n\n# Retrieve a collection\n\nRetrieve the details of a collection, given its name.\n\nSample Response\n\nDefinition GET ${TYPESENSE_HOST}/collections/:collection\n\n# List all collections\n\nReturns a summary of all your collections. The collections are returned sorted by creation date, with the most recent collections appearing first.\n\nSample Response\n\nDefinition GET ${TYPESENSE_HOST}/collections\n\n# Drop a collection\n\nPermanently drops a collection. This action cannot be undone. For large collections, this might have an impact on read latencies.\n\nSample Response\n\nDefinition DELETE ${TYPESENSE_HOST}/collections/:collection\n\nTypesense supports adding or removing fields to a collection's schema in-place.\n\nLet's see how we can add a new company_category field to the companies collection and also drop the existing num_employees field.\n\nSample Response\n\nDefinition PATCH ${TYPESENSE_HOST}/collections/:collection\n\nThe update operation consists of an initial validation step where the records on-disk are assessed to ensure that they are compatible with the proposed schema change. For example, let's say there is a string field A which is already present in the documents on-disk but is not part of the schema. If you try to update the collection schema by adding a field A with type integer, the validation step will reject this change as it's incompatible with the type of data already present.\n\nIf the validation is successful, the actual schema change is done and the records are indexed / re-indexed / dropped as per the requested change. The process is complete as soon as the API call returns (make sure you use a large client timeout value). Because of the blocking nature of the update, we recommend doing the change during off-peak hours. Alternatively, you can also use the alias feature to do zero downtime schema changes.\n\n# Modifying an existing field\n\nSince Typesense currently only supports adding/deleting a field, any modifications to an existing field should be expressed as a drop + add operation. All fields except the id field can be modified.\n\nFor example, to add a facet property to the company_category field, we will drop + add it in the same change set:\n\n# Using an alias\n\nIf you need to do zero-downtime schema changes, you could also re-create the collection fully and use the Collection Alias feature to do a zero-downtime switch over to the new collection:\n\nCreate your collection as usual with a timestamped name. For eg: movies_jan_1\n\nCreate an alias pointing to your collection. For eg: create an alias called movies pointing to movies_jan_1\n\nUse the collection alias in your application to search / index documents in your collection.\n\nWhen you need to make schema changes, create a new timestamped collection with the updated collection schema, for eg: movies_feb_1 and reindex your data in it.\n\nUpdate the collection alias to now point to the new collection. Eg: Update movies to now point to movies_feb_1.\n\nDrop the old collection, movies_jan_1 in our example.\n\nOnce you update the alias, any search / indexing operations will go to the new collection (eg: movies_feb_1) without you having to do any application-side changes.\n\n# Dynamic field additions"
    }
}