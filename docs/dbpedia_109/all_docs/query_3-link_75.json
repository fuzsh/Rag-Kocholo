{
    "id": "dbpedia_109_3",
    "rank": 75,
    "data": {
        "url": "https://neo4j.com/docs/cypher-manual/current/functions/string/",
        "read_more_link": "",
        "language": "en",
        "title": "String functions",
        "top_image": "https://dist.neo4j.com/wp-content/uploads/20210423062553/neo4j-social-share-21.png",
        "meta_img": "https://dist.neo4j.com/wp-content/uploads/20210423062553/neo4j-social-share-21.png",
        "images": [
            "https://dist.neo4j.com/wp-content/uploads/20230926084108/Logo_FullColor_RGB_TransBG.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "String functions all operate on string expressions only, and will return an error if used on any other values.",
        "meta_lang": "en",
        "meta_favicon": "https://neo4j.com/wp-content/themes/neo4jweb/favicon.ico",
        "meta_site_name": "Neo4j Graph Data Platform",
        "canonical_link": "https://neo4j.com/docs/cypher-manual/5/functions/string/",
        "text": "String functions operate on string expressions only, and will return an error if used on any other values. The exception to this rule is toString(), which also accepts numbers, booleans and temporal values (i.e. DATE, ZONED TIME` LOCAL TIME, ZONED DATETIME, LOCAL DATETIME or DURATION values).\n\nFunctions taking a STRING as input all operate on Unicode characters rather than on a standard char[]. For example, the size() function applied to any Unicode character will return 1, even if the character does not fit in the 16 bits of one char.\n\nSee also String operators.\n\nbtrim()\n\nbtrim() returns the original STRING with leading and trailing trimCharacterString characters removed. If trimCharacterString is not specified then all leading and trailing whitespace will be removed.\n\nSyntax:\n\nbtrim(original [, trimCharacterString])\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nbtrim(null) returns null.\n\nbtrim(null, null) returns null.\n\nbtrim(\"hello\", null) returns null.\n\nbtrim(null, ' ') returns null.\n\nExample 1. btrim()\n\nQuery\n\nRETURN btrim(' hello '), btrim('xxyyhelloxyxy', 'xy')\n\nTable 1. Result btrim(' hello') btrim('xxyyhelloxyxy', 'xy')\n\n\"hello\"\n\n\"hello\"\n\nRows: 1\n\nleft()\n\nleft() returns a STRING containing the specified number of leftmost characters of the given STRING.\n\nSyntax:\n\nleft(original, length)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nExample 2. left()\n\nQuery\n\nRETURN left('hello', 3)\n\nTable 2. Result left('hello', 3)\n\n\"hel\"\n\nRows: 1\n\nlower()\n\nlower() returns the given STRING in lowercase. This function is an alias to the toLower() function, and it was introduced as part of Cypher®'s GQL conformance.\n\nSyntax:\n\nlower(original)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nlower(null) returns null.\n\nExample 3. lower()\n\nQuery\n\nRETURN lower('HELLO')\n\nTable 3. Result lower('HELLO')\n\n\"hello\"\n\nRows: 1\n\nltrim()\n\nltrim() returns the original STRING with leading trimCharacterString characters removed. As of Neo4j 5.20, a trimCharacterString can be specified. If this is not specified all leading whitespace will be removed.\n\nSyntax:\n\nltrim(original [, trimCharacterString])\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nltrim(null) returns null.\n\nltrim(null, null) returns null.\n\nltrim(\"hello\", null) returns null.\n\nltrim(null, ' ') returns null.\n\nExample 4. ltrim()\n\nQuery\n\nRETURN ltrim(' hello'), ltrim('xxyyhelloxyxy', 'xy')\n\nTable 4. Result ltrim(' hello') ltrim('xxyyhelloxyxy', 'xy')\n\n\"hello\"\n\n\"helloxyxy\"\n\nRows: 1\n\nnormalize()\n\nnormalize() returns the given STRING normalized using the NFC Unicode normalization form.\n\nThe normalize() function is useful for converting STRING values into comparable forms. When comparing two STRING values, it is their Unicode codepoints that are compared. In Unicode, a codepoint for a character that looks the same may be represented by two, or more, different codepoints. For example, the character < can be represented as \\uFE64 (ï¹¤) or \\u003C (<). To the human eye, the characters may appear identical. However, if compared, Cypher will return false as \\uFE64 does not equal \\u003C. Using the normalize() function, it is possible to normalize the codepoint \\uFE64 to \\u003C, creating a single codepoint representation, allowing them to be successfully compared.\n\nSyntax:\n\nnormalize(input)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nnormalize(null) returns null.\n\nExample 5. normalize()\n\nQuery\n\nRETURN normalize('\\u212B') = '\\u00C5' AS result\n\nTable 5. Result result\n\ntrue\n\nRows: 1\n\nTo check if a STRING is normalized, use the IS NORMALIZED operator.\n\nnormalize(), with specified normal form\n\nnormalize() returns the given STRING normalized using the specified normalization form. The normalization form can be of type NFC, NFD, NFKC or NFKD.\n\nThere are two main types of normalization forms:\n\nCanonical equivalence: The NFC (default) and NFD are forms of canonical equivalence. This means that codepoints that represent the same abstract character will be normalized to the same codepoint (and have the same appearance and behavior). The NFC form will always give the composed canonical form (in which the combined codes are replaced with a single representation, if possible). The`NFD` form gives the decomposed form (the opposite of the composed form, which converts the combined codepoints into a split form if possible).\n\nCompatability normalization: NFKC and NFKD are forms of compatibility normalization. All canonically equivalent sequences are compatible, but not all compatible sequences are canonical. This means that a character normalized in NFC or NFD should also be normalized in NFKC and NFKD. Other characters with only slight differences in appearance should be compatibly equivalent.\n\nFor example, the Greek Upsilon with Acute and Hook Symbol Ï can be represented by the Unicode codepoint: \\u03D3.\n\nNormalized in NFC: \\u03D3 Greek Upsilon with Acute and Hook Symbol (Ï)\n\nNormalized in NFD: \\u03D2\\u0301 Greek Upsilon with Hook Symbol + Combining Acute Accent (ÏÌ)\n\nNormalized in NFKC: \\u038E Greek Capital Letter Upsilon with Tonos (Î)\n\nNormalized in NFKD: \\u03A5\\u0301 Greek Capital Letter Upsilon + Combining Acute Accent (Î¥Ì)\n\nIn the compatibility normalization forms (NFKC and NFKD) the character is visibly different as it no longer contains the hook symbol.\n\nSyntax:\n\nnormalize(input, normalForm)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nnormalize(null, NFC) returns null.\n\nExample 6. normalize()\n\nQuery\n\nRETURN normalize('\\uFE64', NFKC) = '\\u003C' AS result\n\nTable 6. Result result\n\ntrue\n\nRows: 1\n\nTo check if a STRING is normalized in a specific Unicode normal form, use the IS NORMALIZED operator with a specified normalization form.\n\nreplace()\n\nreplace() returns a STRING in which all occurrences of a specified STRING in the given STRING have been replaced by another (specified) replacement STRING.\n\nSyntax:\n\nreplace(original, search, replace)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nExample 7. replace()\n\nQuery\n\nRETURN replace(\"hello\", \"l\", \"w\")\n\nTable 7. Result replace(\"hello\", \"l\", \"w\")\n\n\"hewwo\"\n\nRows: 1\n\nreverse()\n\nreverse() returns a STRING in which the order of all characters in the given STRING have been reversed.\n\nSyntax:\n\nreverse(original)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nreverse(null) returns null.\n\nExample 8. reverse\n\nQuery\n\nRETURN reverse('anagram')\n\nTable 8. Result reverse('anagram')\n\n\"margana\"\n\nRows: 1\n\nright()\n\nright() returns a STRING containing the specified number of rightmost characters in the given STRING.\n\nSyntax:\n\nright(original, length)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nExample 9. right()\n\nQuery\n\nRETURN right('hello', 3)\n\nTable 9. Result right('hello', 3)\n\n\"llo\"\n\nRows: 1\n\nrtrim()\n\nrtrim() returns the original STRING with trailing trimCharacterString characters removed. As of Neo4j 5.20, a trimCharacterString can be specified. If this is not specified all trailing whitespace will be removed.\n\nSyntax:\n\nrtrim(original [, trimCharacterString])\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nrtrim(null) returns null.\n\nrtrim(null, null) returns null.\n\nrtrim(\"hello\", null) returns null.\n\nrtrim(null, ' ') returns null.\n\nExample 10. rtrim()\n\nQuery\n\nRETURN rtrim('hello '), rtrim('xxyyhelloxyxy', 'xy')\n\nTable 10. Result rtrim('hello ') rtrim('xxyyhelloxyxy', 'xy')\n\n\"hello\"\n\n\"xxyyhello\"\n\nRows: 1\n\nsplit()\n\nsplit() returns a LIST<STRING> resulting from the splitting of the given STRING around matches of the given delimiter.\n\nSyntax:\n\nsplit(original, splitDelimiter)\n\nReturns:\n\nLIST<STRING>\n\nArguments:\n\nName Description\n\nConsiderations:\n\nsplit(null, splitDelimiter) return null.\n\nsplit(original, null) return null\n\nExample 11. split()\n\nQuery\n\nRETURN split('one,two', ',')\n\nTable 11. Result split('one,two', ',')\n\n[\"one\",\"two\"]\n\nRows: 1\n\ntoString()\n\ntoString() converts an INTEGER, FLOAT, BOOLEAN, STRING, POINT, DURATION, DATE, ZONED TIME, LOCAL TIME, LOCAL DATETIME or ZONED DATETIME value to a STRING.\n\nSyntax:\n\ntoString(expression)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nExample 14. toString()\n\nQuery\n\nRETURN toString(11.5), toString('already a string'), toString(true), toString(date({year: 1984, month: 10, day: 11})) AS dateString, toString(datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, millisecond: 341, timezone: 'Europe/Stockholm'})) AS datetimeString, toString(duration({minutes: 12, seconds: -60})) AS durationString\n\nTable 14. Result toString(11.5) toString('already a string') toString(true) dateString datetimeString durationString\n\n\"11.5\"\n\n\"already a string\"\n\n\"true\"\n\n\"1984-10-11\"\n\n\"1984-10-11T12:31:14.341+01:00[Europe/Stockholm]\"\n\n\"PT11M\"\n\nRows: 1\n\ntoStringOrNull()\n\nThe function toStringOrNull() converts an INTEGER, FLOAT, BOOLEAN, STRING, POINT, DURATION, DATE, ZONED TIME, LOCAL TIME, LOCAL DATETIME or ZONED DATETIME value to a STRING.\n\nSyntax:\n\ntoStringOrNull(expression)\n\nReturns:\n\nSTRING or null.\n\nArguments:\n\nName Description\n\nConsiderations:\n\nExample 15. toStringOrNull()\n\nQuery\n\nRETURN toStringOrNull(11.5), toStringOrNull('already a string'), toStringOrNull(true), toStringOrNull(date({year: 1984, month: 10, day: 11})) AS dateString, toStringOrNull(datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, millisecond: 341, timezone: 'Europe/Stockholm'})) AS datetimeString, toStringOrNull(duration({minutes: 12, seconds: -60})) AS durationString, toStringOrNull(['A', 'B', 'C']) AS list\n\nTable 15. Result toStringOrNull(11.5) toStringOrNull('already a string') toStringOrNull(true) dateString datetimeString durationString list\n\n\"11.5\"\n\n\"already a string\"\n\n\"true\"\n\n\"1984-10-11\"\n\n\"1984-10-11T12:31:14.341+01:00[Europe/Stockholm]\"\n\n\"PT11M\"\n\n<null>\n\nRows: 1\n\ntoUpper()\n\ntoUpper() returns the given STRING in uppercase.\n\nSyntax:\n\ntoUpper(original)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\ntoUpper(null) returns null.\n\nExample 16. toUpper()\n\nQuery\n\nRETURN toUpper('hello')\n\nTable 16. Result toUpper('hello')\n\n\"HELLO\"\n\nRows: 1\n\ntrim()\n\ntrim() returns the given STRING with the leading and/or trailing trimCharacterString character removed. As of Neo4j 5.20, a trimCharacterString can be specified. If this is not specified all leading and/or trailing whitespace will be removed.\n\nSyntax:\n\ntrim([[LEADING | TRAILING | BOTH] [trimCharacterString] FROM] original)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\ntrim(null) returns null.\n\ntrim(null FROM \"hello\") returns null.\n\ntrim(\" \" FROM null) returns null.\n\ntrim(BOTH null FROM null) returns null.\n\nExample 17. trim()\n\nQuery\n\nRETURN trim(' hello '), trim(BOTH 'x' FROM 'xxxhelloxxx')\n\nTable 17. Result trim(' hello ') trim(BOTH 'x' FROM 'xxxhelloxxx')\n\n\"hello\"\n\n\"hello\"\n\nRows: 1\n\nupper()\n\nupper() returns the given STRING in uppercase. This function is an alias to the toUpper() function, and it was introduced as part of Cypher’s GQL conformance.\n\nSyntax:\n\nupper(original)\n\nReturns:\n\nSTRING\n\nArguments:\n\nName Description\n\nConsiderations:\n\nupper(null) returns null.\n\nExample 18. upper()\n\nQuery\n\nRETURN upper('hello')\n\nTable 18. Result upper('hello')\n\n\"HELLO\"\n\nRows: 1"
    }
}