{
    "id": "dbpedia_109_3",
    "rank": 47,
    "data": {
        "url": "https://docs.python.org/3/library/string.html",
        "read_more_link": "",
        "language": "en",
        "title": "string â Common string operations",
        "top_image": "https://docs.python.org/3/_static/og-image.png",
        "meta_img": "https://docs.python.org/3/_static/og-image.png",
        "images": [
            "https://docs.python.org/3/_static/py.svg",
            "https://docs.python.org/3/_static/py.svg",
            "https://docs.python.org/3/_static/py.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Source code: Lib/string.py String constants: The constants defined in this module are: Custom String Formatting: The built-in string class provides the ability to do complex variable substitutions ...",
        "meta_lang": "en",
        "meta_favicon": "../_static/py.svg",
        "meta_site_name": "Python documentation",
        "canonical_link": "https://docs.python.org/3/library/string.html",
        "text": "Format String SyntaxÂ¶\n\nThe str.format() method and the Formatter class share the same syntax for format strings (although in the case of Formatter, subclasses can define their own format string syntax). The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions.\n\nFormat strings contain âreplacement fieldsâ surrounded by curly braces {}. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}.\n\nThe grammar for a replacement field is as follows:\n\nreplacement_field ::= \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\" field_name ::= arg_name (\".\" attribute_name | \"[\" element_index \"]\")* arg_name ::= [identifier | digit+] attribute_name ::= identifier element_index ::= digit+ | index_string index_string ::= <any source character except \"]\"> + conversion ::= \"r\" | \"s\" | \"a\" format_spec ::= format-spec:format_spec\n\nIn less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a conversion field, which is preceded by an exclamation point '!', and a format_spec, which is preceded by a colon ':'. These specify a non-default format for the replacement value.\n\nSee also the Format Specification Mini-Language section.\n\nThe field_name itself begins with an arg_name that is either a number or a keyword. If itâs a number, it refers to a positional argument, and if itâs a keyword, it refers to a named keyword argument. An arg_name is treated as a number if a call to str.isdecimal() on the string would return true. If the numerical arg_names in a format string are 0, 1, 2, â¦ in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, â¦ will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings '10' or ':-]') within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form '.name' selects the named attribute using getattr(), while an expression of the form '[index]' does an index lookup using __getitem__().\n\nSome simple format string examples:\n\n\"First, thou shalt count to {0}\" # References first positional argument \"Bring me a {}\" # Implicitly references the first positional argument \"From {} to {}\" # Same as \"From {0} to {1}\" \"My quest is {name}\" # References keyword argument 'name' \"Weight in tons {0.weight}\" # 'weight' attribute of first positional arg \"Units destroyed: {players[0]}\" # First element of keyword argument 'players'.\n\nThe conversion field causes a type coercion before formatting. Normally, the job of formatting a value is done by the __format__() method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling __format__(), the normal formatting logic is bypassed.\n\nThree conversion flags are currently supported: '!s' which calls str() on the value, '!r' which calls repr() and '!a' which calls ascii().\n\nSome examples:\n\n\"Harold's a clever {0!s}\" # Calls str() on the argument first \"Bring out the holy {name!r}\" # Calls repr() on the argument first \"More {!a}\" # Calls ascii() on the argument first\n\nThe format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own âformatting mini-languageâ or interpretation of the format_spec.\n\nMost built-in types support a common formatting mini-language, which is described in the next section.\n\nA format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified.\n\nSee the Format examples section for some examples.\n\nFormat Specification Mini-LanguageÂ¶\n\nâFormat specificationsâ are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in format() function. Each formattable type may define how the format specification is to be interpreted.\n\nMost built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types.\n\nA general convention is that an empty format specification produces the same result as if you had called str() on the value. A non-empty format specification typically modifies the result.\n\nThe general form of a standard format specifier is:\n\nformat_spec ::= [[fill]align][sign][\"z\"][\"#\"][\"0\"][width][grouping_option][\".\" precision][type] fill ::= <any character> align ::= \"<\" | \">\" | \"=\" | \"^\" sign ::= \"+\" | \"-\" | \" \" width ::= digit+ grouping_option ::= \"_\" | \",\" precision ::= digit+ type ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\"\n\nIf a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (â{â or â}â) as the fill character in a formatted string literal or when using the str.format() method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesnât affect the format() function.\n\nThe meaning of the various alignment options is as follows:\n\nOption\n\nMeaning\n\nNote that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.\n\nThe sign option is only valid for number types, and can be one of the following:\n\nOption\n\nMeaning\n\nThe 'z' option coerces negative zero floating-point values to positive zero after rounding to the format precision. This option is only valid for floating-point presentation types.\n\nChanged in version 3.11: Added the 'z' option (see also PEP 682).\n\nThe '#' option causes the âalternate formâ to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix '0b', '0o', '0x', or '0X' to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for 'g' and 'G' conversions, trailing zeros are not removed from the result.\n\nThe ',' option signals the use of a comma for a thousands separator. For a locale aware separator, use the 'n' integer presentation type instead.\n\nChanged in version 3.1: Added the ',' option (see also PEP 378).\n\nThe '_' option signals the use of an underscore for a thousands separator for floating-point presentation types and for integer presentation type 'd'. For integer presentation types 'b', 'o', 'x', and 'X', underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error.\n\nChanged in version 3.6: Added the '_' option (see also PEP 515).\n\nwidth is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content.\n\nWhen no explicit alignment is given, preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types. This is equivalent to a fill character of '0' with an alignment type of '='.\n\nChanged in version 3.10: Preceding the width field by '0' no longer affects the default alignment for strings.\n\nThe precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types 'f' and 'F', or before and after the decimal point for presentation types 'g' or 'G'. For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types.\n\nFinally, the type determines how the data should be presented.\n\nThe available string presentation types are:\n\nType\n\nMeaning\n\nThe available integer presentation types are:\n\nType\n\nMeaning\n\nIn addition to the above presentation types, integers can be formatted with the floating-point presentation types listed below (except 'n' and None). When doing so, float() is used to convert the integer to a floating-point number before formatting.\n\nThe available presentation types for float and Decimal values are:\n\nType\n\nMeaning\n\nFormat examplesÂ¶\n\nThis section contains examples of the str.format() syntax and comparison with the old %-formatting.\n\nIn most of the cases the syntax is similar to the old %-formatting, with the addition of the {} and with : used instead of %. For example, '%03.2f' can be translated to '{:03.2f}'.\n\nThe new format syntax also supports new and different options, shown in the following examples.\n\nAccessing arguments by position:\n\n>>> '{0}, {1}, {2}'.format('a', 'b', 'c') 'a, b, c' >>> '{}, {}, {}'.format('a', 'b', 'c') # 3.1+ only 'a, b, c' >>> '{2}, {1}, {0}'.format('a', 'b', 'c') 'c, b, a' >>> '{2}, {1}, {0}'.format(*'abc') # unpacking argument sequence 'c, b, a' >>> '{0}{1}{0}'.format('abra', 'cad') # arguments' indices can be repeated 'abracadabra'\n\nAccessing arguments by name:\n\n>>> 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W') 'Coordinates: 37.24N, -115.81W' >>> coord = {'latitude': '37.24N', 'longitude': '-115.81W'} >>> 'Coordinates: {latitude}, {longitude}'.format(**coord) 'Coordinates: 37.24N, -115.81W'\n\nAccessing argumentsâ attributes:\n\n>>> c = 3-5j >>> ('The complex number {0} is formed from the real part {0.real} ' ... 'and the imaginary part {0.imag}.').format(c) 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.' >>> class Point: ... def __init__(self, x, y): ... self.x, self.y = x, y ... def __str__(self): ... return 'Point({self.x}, {self.y})'.format(self=self) ... >>> str(Point(4, 2)) 'Point(4, 2)'\n\nAccessing argumentsâ items:\n\n>>> coord = (3, 5) >>> 'X: {0[0]}; Y: {0[1]}'.format(coord) 'X: 3; Y: 5'\n\nReplacing %s and %r:\n\n>>> \"repr() shows quotes: {!r}; str() doesn't: {!s}\".format('test1', 'test2') \"repr() shows quotes: 'test1'; str() doesn't: test2\"\n\nAligning the text and specifying a width:\n\n>>> '{:<30}'.format('left aligned') 'left aligned ' >>> '{:>30}'.format('right aligned') ' right aligned' >>> '{:^30}'.format('centered') ' centered ' >>> '{:*^30}'.format('centered') # use '*' as a fill char '***********centered***********'\n\nReplacing %+f, %-f, and % f and specifying a sign:\n\n>>> '{:+f}; {:+f}'.format(3.14, -3.14) # show it always '+3.140000; -3.140000' >>> '{: f}; {: f}'.format(3.14, -3.14) # show a space for positive numbers ' 3.140000; -3.140000' >>> '{:-f}; {:-f}'.format(3.14, -3.14) # show only the minus -- same as '{:f}; {:f}' '3.140000; -3.140000'\n\nReplacing %x and %o and converting the value to different bases:\n\n>>> # format also supports binary numbers >>> \"int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}\".format(42) 'int: 42; hex: 2a; oct: 52; bin: 101010' >>> # with 0x, 0o, or 0b as prefix: >>> \"int: {0:d}; hex: {0:#x}; oct: {0:#o}; bin: {0:#b}\".format(42) 'int: 42; hex: 0x2a; oct: 0o52; bin: 0b101010'\n\nUsing the comma as a thousands separator:\n\n>>> '{:,}'.format(1234567890) '1,234,567,890'\n\nExpressing a percentage:\n\n>>> points = 19 >>> total = 22 >>> 'Correct answers: {:.2%}'.format(points/total) 'Correct answers: 86.36%'\n\nUsing type-specific formatting:\n\n>>> import datetime >>> d = datetime.datetime(2010, 7, 4, 12, 15, 58) >>> '{:%Y-%m-%d %H:%M:%S}'.format(d) '2010-07-04 12:15:58'\n\nNesting arguments and more complex examples:\n\n>>> for align, text in zip('<^>', ['left', 'center', 'right']): ... '{0:{fill}{align}16}'.format(text, fill=align, align=align) ... 'left<<<<<<<<<<<<' '^^^^^center^^^^^' '>>>>>>>>>>>right' >>> >>> octets = [192, 168, 0, 1] >>> '{:02X}{:02X}{:02X}{:02X}'.format(*octets) 'C0A80001' >>> int(_, 16) 3232235521 >>> >>> width = 5 >>> for num in range(5,12): ... for base in 'dXob': ... print('{0:{width}{base}}'.format(num, base=base, width=width), end=' ') ... print() ... 5 5 5 101 6 6 6 110 7 7 7 111 8 8 10 1000 9 9 11 1001 10 A 12 1010 11 B 13 1011"
    }
}