{
    "id": "dbpedia_109_1",
    "rank": 58,
    "data": {
        "url": "https://docs.checkmk.com/latest/en/regexes.html",
        "read_more_link": "",
        "language": "en",
        "title": "Regular expressions in Checkmk",
        "top_image": "https://docs.checkmk.com/assets/images/share_image.png",
        "meta_img": "https://docs.checkmk.com/assets/images/share_image.png",
        "images": [
            "https://docs.checkmk.com/assets/images/docs_logo.png",
            "https://docs.checkmk.com/assets/images/logo_icon.svg",
            "https://docs.checkmk.com/assets/images/search.svg",
            "https://docs.checkmk.com/latest/images/regexes_servicematch.png",
            "https://docs.checkmk.com/latest/images/bulk_renaming_regex.png",
            "https://docs.checkmk.com/latest/images/regexes_testing.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "In Checkmk, you can use regular expressions in many places to capture a group of objects and thus achieve a highly-dynamic operational environment.",
        "meta_lang": "en",
        "meta_favicon": "/favicon.png",
        "meta_site_name": "Checkmk Docs",
        "canonical_link": null,
        "text": "Regular expressionsâââregex (or rarely regexp)âââare used in Checkmk to specify service names and in many other situations. They are patterns that match a certain text or do not match (non-match). You can do many practical things with them, such as formulating flexible rules that apply to all services with foo or bar in their name.\n\nRegular expressions are often confused with filename search patterns, since the special characters * and ?, as well as square and curly brackets, can exist in both.\n\nIn this article we will show you the most important functions of regular expressions, of course in the context of Checkmk. Since Checkmk uses two different components for regular expressions, sometimes the devil is in the detail. Essentially, the monitoring core uses the C library and all other components use Python 3. Where differences exist, we will explain them.\n\nTip: In Checkmk regexp are allowed in input fields on various pages. If you are unsure, use the context-sensitive help via the Help menu (Help > Show inline help). There you can see whether regular expressions are permitted and how they can be used.\n\nWhen working with older plug-ins or plug-ins from external sources, it may happen that these may use Python 2 or Perl and deviate from the conventions described here.\n\nIn this article we will show you the most important capabilities of regular expressionsâââbut by no means all of them. If the possibilities shown here do not go far enough, below you will find references where you can read all of the relevant details. And then there is always the internet.\n\nIf you want to program your own plug-ins that, for example, use regular expressions to find anomalies in log files, you can use this article as a basis. However, when searching in large volumes of data optimization of performance is an important aspect. If in doubt always consult the documentation for the regex library being used.\n\nThe logic of regular expressions is not always easy to understand, especially in the case of nested match groups, and the question of the order and which end of the string is to be matched. Better than trial and error in Checkmk, there are two ways of testing regular expressions: Online services such as regex101.com prepare matches graphically and explain the order of evaluation in real time:\n\nThe second testing procedure is the Python prompt, which comes with every Python installation. With Linux and Mac OS Python 3 is usually pre-installed. Precisely because regular expressions at the Python prompt are evaluated exactly as in Checkmk, there are no discrepancies in an interpretation, even with complex nesting. With the test in the Python interpreter you are always on the safe side.\n\nAfter opening, you have to import the module re. In the example we switch the distinction between upper and lower case with re.IGNORECASE off:\n\nOMD[mysite]:~$ python3 Python 3.8.10 (default, Jun 2 2021, 10:49:15) [GCC 9.4.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import re >>> re.IGNORECASE re.IGNORECASE\n\nTo emulate the behavior of Câs regular expressions, which are also used in many Python components, you can restrict to ASCII:\n\n>>> re.ASCII re.ASCII\n\nNow you can use the function re.match() to directly match a regular expression against a string and output the match group: group(0) stands for the whole match, and group(1) the match that is the first that matches the sub-expression enclosed within round brackets:\n\n>>> x = re.match('M[ae]{1}[iy]{1}e?r', 'Meier') >>> x.group(0) 'Meier' >>> x = re.match('M[ae]{1}[iy]{1}e?r', 'Mayr') >>> x.group(0) 'Mayr' >>> x = re.match('M[ae]{1}[iy]{1}e?r', 'Myers') >>> x.group(0) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> IndexError: no such group >>> x = re.match('server-(.*)\\.local', 'server-lnx23.local') >>> x.group(0) 'server-lnx23.local' >>> x.group(1) 'lnx23'\n\nKen Thompson, one of the creators of UNIX back in the 1960s, was the first to develop regular expressions in todayâs formâââamong other things in the Unix command grep, which is still in use. Since then, numerous extensions and dialects of regular expressions have been createdâââincluding extended regexes, Perl-compatible regexes as well as a very similar variant in Python.\n\nIn filters in views Checkmk uses POSIX extended regular expressions (extended REs). These are evaluated in the monitoring core in C using the C-libraryâs regex function. You can find a complete reference for this in the Linux man page for regex(7):\n\nOMD[mysite]:~$ man7 regex REGEX(7) Linux Programmer's Manual REGEX(7) NAME regex - POSIX.2 regular expressions DESCRIPTION Regular expressions (\"RE\"s), as defined in POSIX.2, come in two forMFS: modern REs (roughly those of egrep; POSIX.2 calls these \"extended\" REs) and obsolete REs (roughly those of *ed*(1); POSIX.2 \"basic\" REs). Obso- lete REs mostly exist for backward compatibility in some old programs;\n\nIn all other places, all of the functions of Pythonâs regular expressions are available. This includes, among other things the configuration rules, Event Console (EC) and Business Intelligence (BI).\n\nThe regular expressions in Python are an extension of the extended REs and are very similar to those in Perl. They support, for example, the so-called negative lookahead, a non-greedy * asterisk, or an enforcement of upper/lower case distinction. The details of the capabilities of these regular expressions can be found in the Python online help for the re module, or in more detail in the Python online documentation:\n\nOMD[mysite]:~$ pydoc3 re Help on module re: NAME re - Support for regular expressions (RE). MODULE REFERENCE https://docs.python.org/3.8/library/re The following documentation is automatically generated from the Python source files. It may be incomplete, incorrect or include features that are considered implementation detail and may vary between Python implementations. When in doubt, consult the module reference at the location listed above. DESCRIPTION This module provides regular expression matching operations similar to those found in Perl. It supports both 8-bit and Unicode strings; both the pattern and the strings being processed can contain null bytes and characters outside the US ASCII range. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like \"A\", \"a\", or \"0\", are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so last matches the string 'last'.\n\nA very detailed explanation of regular expressions can be found in a Wikipedia article."
    }
}