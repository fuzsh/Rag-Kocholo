{
    "id": "dbpedia_109_1",
    "rank": 52,
    "data": {
        "url": "https://backstage.io/docs/features/software-catalog/descriptor-format/",
        "read_more_link": "",
        "language": "en",
        "title": "Descriptor Format of Catalog Entities",
        "top_image": "https://backstage.io/img/sharing-opengraph.png",
        "meta_img": "https://backstage.io/img/sharing-opengraph.png",
        "images": [
            "https://backstage.io/img/logo.svg",
            "https://backstage.io/img/logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Documentation on Descriptor Format of Catalog Entities which describes the default data shape and semantics of catalog entities",
        "meta_lang": "en",
        "meta_favicon": "/img/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://backstage.io/docs/features/software-catalog/descriptor-format",
        "text": "This section describes the default data shape and semantics of catalog entities.\n\nThis both applies to objects given to and returned from the software catalog API, as well as to the descriptor files that the software catalog can ingest natively. In the API request/response cycle, a JSON representation is used, while the descriptor files are on YAML format to be more easily maintainable by humans. However, the structure and semantics are the same in both cases.\n\nAlthough it's possible to name catalog entity descriptor files however you wish, we recommend that you name them catalog-info.yaml.\n\nOverall Shape Of An Entity\n\nCommon to All Kinds: The Envelope\n\nCommon to All Kinds: The Metadata\n\nCommon to All Kinds: Relations\n\nCommon to All Kinds: Status\n\nKind: Component\n\nKind: Template\n\nKind: API\n\nKind: Group\n\nKind: User\n\nKind: Resource\n\nKind: System\n\nKind: Domain\n\nKind: Location\n\nThe following is an example of a descriptor file for a Component entity:\n\nThis is the same entity as returned in JSON from the software catalog API:\n\nThe root fields apiVersion, kind, metadata, and spec are part of the envelope, defining the overall structure of all kinds of entity. Likewise, some metadata fields like name, labels, and annotations are of special significance and have reserved purposes and distinct shapes.\n\nSee below for details about these fields.\n\nThe descriptor format supports substitutions using $text, $json, and $yaml.\n\nPlaceholders like $json: https://example.com/entity.json are substituted by the content of the referenced file. Files can be referenced from any configured integration similar to locations by passing an absolute URL. It's also possible to reference relative files like ./referenced.yaml from the same location. Relative references are handled relative to the folder of the catalog-info.yaml that contains the placeholder. There are three different types of placeholders:\n\n$text: Interprets the contents of the referenced file as plain text and embeds it as a string.\n\n$json: Interprets the contents of the referenced file as JSON and embeds the parsed structure.\n\n$yaml: Interprets the contents of the referenced file as YAML and embeds the parsed structure.\n\nFor example, this can be used to load the definition of an API entity from a web server and embed it as a string in the field spec.definition:\n\nNote that to be able to read from targets that are outside of the normal integration points such as github.com, you'll need to explicitly allow it by adding an entry in the backend.reading.allow list. Paths can be specified to further restrict targets For example:\n\nThe root envelope object has the following structure.\n\nThe kind is the high level entity type being described. ADR005 describes a number of core kinds that plugins can know of and understand, but an organization using Backstage is free to also add entities of other kinds to the catalog.\n\nThe perhaps most central kind of entity, that the catalog focuses on in the initial phase, is Component (see below).\n\nThe apiVersion is the version of specification format for that particular entity that the specification is made against. The version is used for being able to evolve the format, and the tuple of apiVersion and kind should be enough for a parser to know how to interpret the contents of the rest of the data.\n\nBackstage specific entities have an apiVersion that is prefixed with backstage.io/, to distinguish them from other types of object that share the same type of structure. This may be relevant when co-hosting these specifications with e.g. Kubernetes object manifests, or when an organization adds their own specific kinds of entity to the catalog.\n\nEarly versions of the catalog will be using alpha/beta versions, e.g. backstage.io/v1alpha1, to signal that the format may still change. After that, we will be using backstage.io/v1 and up.\n\nA structure that contains metadata about the entity, i.e. things that aren't directly part of the entity specification itself. See below for more details about this structure.\n\nThe actual specification data that describes the entity.\n\nThe precise structure of the spec depends on the apiVersion and kind combination, and some kinds may not even have a spec at all. See further down in this document for the specification structure of specific kinds.\n\nThe metadata root field has a number of reserved fields with specific meaning, described below.\n\nIn addition to these, you may add any number of other fields directly under metadata, but be aware that general plugins and tools may not be able to understand their semantics. See Extending the model for more information.\n\nThe name of the entity. This name is both meant for human eyes to recognize the entity, and for machines and other components to reference the entity (e.g. in URLs or from other entity specification files).\n\nNames must be unique per kind, within a given namespace (if specified), at any point in time. This uniqueness constraint is case insensitive. Names may be reused at a later time, after an entity is deleted from the registry.\n\nNames are required to follow a certain format. Entities that do not follow those rules will not be accepted for registration in the catalog. The ruleset is configurable to fit your organization's needs, but the default behavior is as follows.\n\nStrings of length at least 1, and at most 63\n\nMust consist of sequences of [a-z0-9A-Z] possibly separated by one of [-_.]\n\nExample: visits-tracking-service, CircleciBuildsDumpV2_avro_gcs\n\nThe ID of a namespace that the entity belongs to. This field is optional, and currently has no special semantics apart from bounding the name uniqueness constraint if specified. It is reserved for future use and may get broader semantic implication later.\n\nFor now, it is recommended to not specify a namespace unless you have specific need to do so. This means the entity belongs to the \"default\" namespace.\n\nNamespaces must be sequences of [a-zA-Z0-9], possibly separated by -, at most 63 characters in total. Namespace names are case insensitive and will be rendered as lower case in most places.\n\nExample: tracking-services, payment\n\nEach entity gets an automatically generated globally unique ID when it first enters the database. This field is not meant to be specified as input data, but is rather created by the database engine itself when producing the output entity.\n\nNote that uid values are not to be seen as stable, and should not be used as external references to an entity. The uid can change over time even when a human observer might think that it wouldn't. As one of many examples, unregistering and re-registering the exact same file will result in a different uid value even though everything else is the same. Therefore there is very little, if any, reason to read or use this field externally.\n\nIf you want to refer to an entity by some form of an identifier, you should always use string-form entity reference instead.\n\nA display name of the entity, to be presented in user interfaces instead of the name property above, when available.\n\nThis field is sometimes useful when the name is cumbersome or ends up being perceived as overly technical. The title generally does not have as stringent format requirements on it, so it may contain special characters and be more explanatory. Do keep it very short though, and avoid situations where a title can be confused with the name of another entity, or where two entities share a title.\n\nNote that this is only for display purposes, and may be ignored by some parts of the code. Entity references still always make use of the name property for example, not the title.\n\nA human readable description of the entity, to be shown in Backstage. Should be kept short and informative, suitable to give an overview of the entity's purpose at a glance. More detailed explanations and documentation should be placed elsewhere.\n\nLabels are optional key/value pairs of that are attached to the entity, and their use is identical to Kubernetes object labels.\n\nTheir main purpose is for references to other entities, and for information that is in one way or another classifying for the current entity. They are often used as values in queries or filters.\n\nBoth the key and the value are strings, subject to the following restrictions.\n\nKeys have an optional prefix followed by a slash, and then the name part which is required. The prefix, if present, must be a valid lowercase domain name, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.], at most 63 characters in total.\n\nThe backstage.io/ prefix is reserved for use by Backstage core components.\n\nValues are strings that follow the same restrictions as name above.\n\nAn object with arbitrary non-identifying metadata attached to the entity, identical in use to Kubernetes object annotations.\n\nTheir purpose is mainly, but not limited, to reference into external systems. This could for example be a reference to the git ref the entity was ingested from, to monitoring and logging systems, to PagerDuty schedules, etc. Users may add these to descriptor YAML files, but in addition to this automated systems may also add annotations, either during ingestion into the catalog, or at a later time.\n\nBoth the key and the value are strings, subject to the following restrictions.\n\nKeys have an optional prefix followed by a slash, and then the name part which is required. The prefix must be a valid lowercase domain name if specified, at most 253 characters in total. The name part must be sequences of [a-zA-Z0-9] separated by any of [-_.], at most 63 characters in total.\n\nThe backstage.io/ prefix is reserved for use by Backstage core components.\n\nValues can be of any length, but are limited to being strings.\n\nThere is a list of well-known annotations, but anybody is free to add more annotations as they see fit.\n\nA list of single-valued strings, for example to classify catalog entities in various ways. This is different to the labels in metadata, as labels are key-value pairs.\n\nThe values are user defined, for example the programming language used for the component, like java or go.\n\nThis field is optional, and currently has no special semantics.\n\nEach tag must be sequences of [a-z0-9:+#] separated by -, at most 63 characters in total.\n\nA list of external hyperlinks related to the entity. Links can provide additional contextual information that may be located outside of Backstage itself. For example, an admin dashboard or external CMS page.\n\nUsers may add links to descriptor YAML files to provide additional reference information to external content & resources. Links are not intended to drive any additional functionality within Backstage, which is best left to annotations and labels. It is recommended to use links only when an equivalent well-known annotation does not cover a similar use case.\n\nFields of a link are:\n\nFieldTypeDescriptionurlString[Required] A url in a standard uri format (e.g. https://example.com/some/page)titleString[Optional] A user friendly display name for the link.iconString[Optional] A key representing a visual icon to be displayed in the UI.typeString[Optional] An optional value to categorize links into specific groups.\n\nNOTE: The icon field value is meant to be a semantic key that will map to a specific icon that may be provided by an icon library (e.g. material-ui icons). These keys should be a sequence of [a-z0-9A-Z], possibly separated by one of [-_.]. Backstage may support some basic icons out of the box such as those defined in app-defaults, but the Backstage integrator will ultimately be left to provide the appropriate icon component mappings. A generic fallback icon would be provided if a mapping cannot be resolved.\n\nThe semantics of the type field are undefined. The adopter is free to define their own set of types and utilize them as they wish. Some potential use cases can be to utilize the type field to validate certain links exist on entities or to create customized UI components for specific link types.\n\nThe relations root field is a read-only list of relations, between the current entity and other entities, described in the well-known relations section. Relations are commonly two-way, so that there's a pair of relation types each describing one direction of the relation.\n\nA relation as part of a single entity that's read out of the API may look as follows.\n\nThe fields of a relation are:\n\nFieldTypeDescriptiontargetRefStringA full entity reference to the other end of the relation.typeStringThe type of relation FROM a source entity TO the target entity.metadataObjectReserved for future use.\n\nEntity descriptor YAML files are not supposed to contain this field. Instead, catalog processors analyze the entity descriptor data and its surroundings, and deduce relations that are then attached onto the entity as read from the catalog.\n\nWhere relations are produced, they are to be considered the authoritative source for that piece of data. In the example above, a plugin would do better to consume the relation rather than spec.owner for deducing the owner of the entity, because it may even be the case that the owner isn't taken from the YAML at all - it could be taken from a CODEOWNERS file nearby instead for example. Also, the spec.owner is on a shortened form and may have semantics associated with it (such as the default kind being Group if not specified).\n\nSee the well-known relations section for a list of well-known / common relations and their semantics.\n\nThe status root object is a read-only set of statuses, pertaining to the current state or health of the entity, described in the well-known statuses section.\n\nCurrently, the only defined field is the items array. Each of its items contains a specific data structure that describes some aspect of the state of the entity, as seen from the point of view of some specific system. Different systems may contribute to this array, under their own respective type keys.\n\nThe current main use case for this field is for the ingestion processes of the catalog itself to convey information about errors and warnings back to the user.\n\nA status field as part of a single entity that's read out of the API may look as follows.\n\nThe fields of a status item are:\n\nFieldTypeDescriptiontypeStringThe type of status as a unique key per source. Each type may appear more than once in the array.levelStringThe level / severity of the status item: 'info', 'warning, or 'error'.messageStringA brief message describing the status, intended for human consumption.errorObjectAn optional serialized error object related to the status.\n\nThe type is an arbitrary string, but we recommend that types that are not strictly private within the organization be namespaced to avoid collisions. Types emitted by Backstage core processes will for example be prefixed with backstage.io/ as in the example above.\n\nEntity descriptor YAML files are not supposed to contain a status root key. Instead, catalog processors analyze the entity descriptor data and its surroundings, and deduce status entries that are then attached onto the entity as read from the catalog.\n\nSee the well-known statuses section for a list of well-known / common status types.\n\nDescribes the following entity kind:\n\nFieldValueapiVersionbackstage.io/v1alpha1kindComponent\n\nA Component describes a software component. It is typically intimately linked to the source code that constitutes the component, and should be what a developer may regard a \"unit of software\", usually with a distinct deployable or linkable artifact.\n\nDescriptor files for this kind may look as follows.\n\nIn addition to the common envelope metadata shape, this kind has the following structure.\n\nExactly equal to backstage.io/v1alpha1 and Component, respectively.\n\nThe type of component as a string, e.g. website. This field is required.\n\nThe software catalog accepts any type value, but an organization should take great care to establish a proper taxonomy for these. Tools including Backstage itself may read this field and behave differently depending on its value. For example, a website type component may present tooling in the Backstage interface that is specific to just websites.\n\nThe current set of well-known and common values for this field is:\n\nservice - a backend service, typically exposing an API\n\nwebsite - a website\n\nlibrary - a software library, such as an npm module or a Java library\n\nThe lifecycle state of the component, e.g. production. This field is required.\n\nThe software catalog accepts any lifecycle value, but an organization should take great care to establish a proper taxonomy for these.\n\nThe current set of well-known and common values for this field is:\n\nexperimental - an experiment or early, non-production component, signaling that users may not prefer to consume it over other more established components, or that there are low or no reliability guarantees\n\nproduction - an established, owned, maintained component\n\ndeprecated - a component that is at the end of its lifecycle, and may disappear at a later point in time\n\nAn entity reference to the owner of the component, e.g. artist-relations-team. This field is required.\n\nIn Backstage, the owner of a component is the singular entity (commonly a team) that bears ultimate responsibility for the component, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this component belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the component, but there will always be one ultimate owner.\n\nkindDefault namespaceGenerated relation typeGroup (default), UserSame as this entity, typically defaultownerOf, and reverse ownedBy\n\nAn entity reference to the system that the component belongs to, e.g. artist-engagement-portal. This field is optional.\n\nkindDefault namespaceGenerated relation typeSystem (default)Same as this entity, typically defaultpartOf, and reverse hasPart\n\nAn entity reference to another component of which the component is a part, e.g. spotify-ios-app. This field is optional.\n\nkindDefault namespaceGenerated relation typeComponent (default)Same as this entity, typically defaultpartOf, and reverse hasPart\n\nAn array of entity references to the APIs that are provided by the component, e.g. artist-api. This field is optional.\n\nkindDefault namespaceGenerated relation typeAPI (default)Same as this entity, typically defaultprovidesApi, and reverse apiProvidedBy\n\nAn array of entity references to the APIs that are consumed by the component, e.g. artist-api. This field is optional.\n\nkindDefault namespaceGenerated relation typeAPI (default)Same as this entity, typically defaultconsumesApi, and reverse apiConsumedBy\n\nAn array of entity references to the components and resources that the component depends on, e.g. artists-db. This field is optional.\n\nkindDefault namespaceGenerated relation typeComponentSame as this entity, typically defaultdependsOn, and reverse dependencyOfResourceSame as this entity, typically defaultdependsOn, and reverse dependencyOf\n\nThe following describes the following entity kind:\n\nFieldValueapiVersionbackstage.io/v1beta2kindTemplate\n\nA template definition describes both the parameters that are rendered in the frontend part of the scaffolding wizard, and the steps that are executed when scaffolding that component.\n\nDescriptor files for this kind may look as follows.\n\nIn addition to the common envelope metadata shape, this kind has the following structure.\n\nExactly equal to backstage.io/v1beta2 and Template, respectively.\n\nA list of strings that can be associated with the template, e.g. ['recommended', 'react'].\n\nThis list will also be used in the frontend to display to the user so you can potentially search and group templates by these tags.\n\nAn ISO 8601 duration representing the approximate amount of time saved when someone uses this template (e.g. PT8H to mean \"8 hours saved\" or PT15M to mean \"15 minutes saved\").\n\nCan be used in combination with the backstage.io/source-template annotation, or analytics data, to calculate how much time has been saved through the use of the Scaffolder plugin.\n\nThe type of component created by the template, e.g. website. This is used for filtering templates, and should ideally match the Component spec.type created by the template.\n\nYou can find out more about the parameters key here\n\nYou can find out more about the steps key here\n\nAn entity reference to the owner of the template, e.g. artist-relations-team. This field is required.\n\nIn Backstage, the owner of a Template is the singular entity (commonly a team) that bears ultimate responsibility for the Template, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this Template belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the Template, but there will always be one ultimate owner.\n\nkindDefault namespaceGenerated relation typeGroup (default), UserSame as this entity, typically defaultownerOf, and reverse ownedBy\n\nDescribes the following entity kind:\n\nFieldValueapiVersionbackstage.io/v1alpha1kindAPI\n\nAn API describes an interface that can be exposed by a component. The API can be defined in different formats, like OpenAPI, AsyncAPI, GraphQL, gRPC, or other formats.\n\nDescriptor files for this kind may look as follows.\n\nIn addition to the common envelope metadata shape, this kind has the following structure.\n\nExactly equal to backstage.io/v1alpha1 and API, respectively.\n\nThe type of the API definition as a string, e.g. openapi. This field is required.\n\nThe software catalog accepts any type value, but an organization should take great care to establish a proper taxonomy for these. Tools including Backstage itself may read this field and behave differently depending on its value. For example, an OpenAPI type API may be displayed using an OpenAPI viewer tooling in the Backstage interface.\n\nThe current set of well-known and common values for this field is:\n\nopenapi - An API definition in YAML or JSON format based on the OpenAPI version 2 or version 3 spec.\n\nasyncapi - An API definition based on the AsyncAPI version 2 or version 3 spec.\n\ngraphql - An API definition based on GraphQL schemas for consuming GraphQL based APIs.\n\ngrpc - An API definition based on Protocol Buffers to use with gRPC.\n\nThe lifecycle state of the API, e.g. production. This field is required.\n\nThe software catalog accepts any lifecycle value, but an organization should take great care to establish a proper taxonomy for these.\n\nThe current set of well-known and common values for this field is:\n\nexperimental - an experiment or early, non-production API, signaling that users may not prefer to consume it over other more established APIs, or that there are low or no reliability guarantees\n\nproduction - an established, owned, maintained API\n\ndeprecated - an API that is at the end of its lifecycle, and may disappear at a later point in time\n\nAn entity reference to the owner of the component, e.g. artist-relations-team. This field is required.\n\nIn Backstage, the owner of an API is the singular entity (commonly a team) that bears ultimate responsibility for the API, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this API belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the API, but there will always be one ultimate owner.\n\nkindDefault namespaceGenerated relation typeGroup (default), UserSame as this entity, typically defaultownerOf, and reverse ownedBy\n\nAn entity reference to the system that the API belongs to, e.g. artist-engagement-portal. This field is optional.\n\nkindDefault namespaceGenerated relation typeSystem (default)Same as this entity, typically defaultpartOf, and reverse hasPart\n\nThe definition of the API, based on the format defined by spec.type. This field is required.\n\nDescribes the following entity kind:\n\nFieldValueapiVersionbackstage.io/v1alpha1kindGroup\n\nA group describes an organizational entity, such as for example a team, a business unit, or a loose collection of people in an interest group. Members of these groups are modeled in the catalog as kind User.\n\nDescriptor files for this kind may look as follows.\n\nIn addition to the common envelope metadata shape, this kind has the following structure.\n\nExactly equal to backstage.io/v1alpha1 and Group, respectively.\n\nThe type of group as a string, e.g. team. There is currently no enforced set of values for this field, so it is left up to the adopting organization to choose a nomenclature that matches their org hierarchy.\n\nSome common values for this field could be:\n\nteam\n\nbusiness-unit\n\nproduct-area\n\nroot - as a common virtual root of the hierarchy, if desired\n\nOptional profile information about the group, mainly for display purposes. All fields of this structure are also optional. The email would be a group email of some form, that the group may wish to be used for contacting them. The picture is expected to be a URL pointing to an image that's representative of the group, and that a browser could fetch and render on a group page or similar.\n\nThe fields of a profile are:\n\nFieldTypeDescriptiondisplayName (optional)StringA human-readable name for the group.email (optional)StringAn email the group may wish to be used for contacting them.picture (optional)StringA URL pointing to an image that's representative of the group.\n\nThe immediate parent group in the hierarchy, if any. Not all groups must have a parent; the catalog supports multi-root hierarchies. Groups may however not have more than one parent.\n\nThis field is an entity reference.\n\nkindDefault namespaceGenerated relation typeGroup (default)Same as this entity, typically defaultchildOf, and reverse parentOf\n\nThe immediate child groups of this group in the hierarchy (whose parent field points to this group). The list must be present, but may be empty if there are no child groups. The items are not guaranteed to be ordered in any particular way.\n\nThe entries of this array are entity references.\n\nkindDefault namespaceGenerated relation typeGroup (default)Same as this entity, typically defaultparentOf, and reverse childOf\n\nThe users that are direct members of this group. The items are not guaranteed to be ordered in any particular way.\n\nThe entries of this array are entity references.\n\nkindDefault namespaceGenerated relation typeUser (default)Same as this entity, typically defaulthasMember, and reverse memberOf\n\nDescribes the following entity kind:\n\nFieldValueapiVersionbackstage.io/v1alpha1kindUser\n\nA user describes a person, such as an employee, a contractor, or similar. Users belong to Group entities in the catalog.\n\nThese catalog user entries are connected to the way that authentication within the Backstage ecosystem works. See the auth section of the docs for a discussion of these concepts.\n\nDescriptor files for this kind may look as follows.\n\nIn addition to the common envelope metadata shape, this kind has the following structure.\n\nExactly equal to backstage.io/v1alpha1 and User, respectively.\n\nOptional profile information about the user, mainly for display purposes. All fields of this structure are also optional. The email would be a primary email of some form, that the user may wish to be used for contacting them. The picture is expected to be a URL pointing to an image that's representative of the user, and that a browser could fetch and render on a profile page or similar.\n\nThe fields of a profile are:\n\nFieldTypeDescriptiondisplayName (optional)StringA human-readable name for the user.email (optional)StringAn email the user may wish to be used for contacting them.picture (optional)StringA URL pointing to an image that's representative of the user.\n\nThe list of groups that the user is a direct member of (i.e., no transitive memberships are listed here). The list must be present, but may be empty if the user is not member of any groups. The items are not guaranteed to be ordered in any particular way.\n\nThe entries of this array are entity references.\n\nkindDefault namespaceGenerated relation typeGroup (default)Same as this entity, typically defaultmemberOf, and reverse hasMember\n\nDescribes the following entity kind:\n\nFieldValueapiVersionbackstage.io/v1alpha1kindResource\n\nA resource describes the infrastructure a system needs to operate, like BigTable databases, Pub/Sub topics, S3 buckets or CDNs. Modelling them together with components and systems allows to visualize resource footprint, and create tooling around them.\n\nDescriptor files for this kind may look as follows.\n\nIn addition to the common envelope metadata shape, this kind has the following structure.\n\nExactly equal to backstage.io/v1alpha1 and Resource, respectively.\n\nAn entity reference to the owner of the resource, e.g. artist-relations-team. This field is required.\n\nIn Backstage, the owner of a resource is the singular entity (commonly a team) that bears ultimate responsibility for the resource, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this resource belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also manage or otherwise touch the resource, but there will always be one ultimate owner.\n\nkindDefault namespaceGenerated relation typeGroup (default), UserSame as this entity, typically defaultownerOf, and reverse ownedBy\n\nThe type of resource as a string, e.g. database. This field is required. There is currently no enforced set of values for this field, so it is left up to the adopting organization to choose a nomenclature that matches the resources used in their tech stack.\n\nSome common values for this field could be:\n\ndatabase\n\ns3-bucket\n\nkubernetes-cluster\n\nAn entity reference to the system that the resource belongs to, e.g. artist-engagement-portal. This field is optional.\n\nkindDefault namespaceGenerated relation typeSystem (default)Same as this entity, typically defaultpartOf, and reverse hasPart\n\nAn array of entity references to the components and resources that the resource depends on, e.g. artist-lookup. This field is optional.\n\nkindDefault namespaceGenerated relation typeComponentSame as this entity, typically defaultdependsOn, and reverse dependencyOfResourceSame as this entity, typically defaultdependsOn, and reverse dependencyOf\n\nAn array of entity references to the components and resources that the resource is a dependency of, e.g. artist-lookup. This field is optional.\n\nkindDefault namespaceGenerated relation typeComponentSame as this entity, typically defaultdependencyOf, and reverse dependsOnResourceSame as this entity, typically defaultdependencyOf, and reverse dependsOn\n\nDescribes the following entity kind:\n\nFieldValueapiVersionbackstage.io/v1alpha1kindSystem\n\nA system is a collection of resources and components. The system may expose or consume one or several APIs. It is viewed as abstraction level that provides potential consumers insights into exposed features without needing a too detailed view into the details of all components. This also gives the owning team the possibility to decide about published artifacts and APIs.\n\nDescriptor files for this kind may look as follows.\n\nIn addition to the common envelope metadata shape, this kind has the following structure.\n\nExactly equal to backstage.io/v1alpha1 and System, respectively.\n\nAn entity reference to the owner of the system, e.g. artist-relations-team. This field is required.\n\nIn Backstage, the owner of a system is the singular entity (commonly a team) that bears ultimate responsibility for the system, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this system belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the system, but there will always be one ultimate owner.\n\nkindDefault namespaceGenerated relation typeGroup (default), UserSame as this entity, typically defaultownerOf, and reverse ownedBy\n\nAn entity reference to the domain that the system belongs to, e.g. artists. This field is optional.\n\nkindDefault namespaceGenerated relation typeDomain (default)Same as this entity, typically defaultpartOf, and reverse hasPart\n\nDescribes the following entity kind:\n\nFieldValueapiVersionbackstage.io/v1alpha1kindDomain\n\nA Domain groups a collection of systems that share terminology, domain models, business purpose, or documentation, i.e. form a bounded context.\n\nDescriptor files for this kind may look as follows.\n\nIn addition to the common envelope metadata shape, this kind has the following structure.\n\nExactly equal to backstage.io/v1alpha1 and Domain, respectively.\n\nAn entity reference to the owner of the domain, e.g. artist-relations-team. This field is required.\n\nIn Backstage, the owner of a domain is the singular entity (commonly a team) that bears ultimate responsibility for the domain, and has the authority and capability to develop and maintain it. They will be the point of contact if something goes wrong, or if features are to be requested. The main purpose of this field is for display purposes in Backstage, so that people looking at catalog items can get an understanding of to whom this domain belongs. It is not to be used by automated processes to for example assign authorization in runtime systems. There may be others that also develop or otherwise touch the domain, but there will always be one ultimate owner.\n\nkindDefault namespaceGenerated relation typeGroup (default), UserSame as this entity, typically defaultownerOf, and reverse ownedBy\n\nAn entity reference to another domain of which the domain is a part, e.g. audio. This field is optional.\n\nkindDefault namespaceGenerated relation typeDomain (default)Same as this entity, typically defaultpartOf, and reverse hasPart\n\nDescribes the following entity kind:\n\nFieldValueapiVersionbackstage.io/v1alpha1kindLocation\n\nA location is a marker that references other places to look for catalog data.\n\nDescriptor files for this kind may look as follows.\n\nIn addition to the common envelope metadata shape, this kind has the following structure.\n\nExactly equal to backstage.io/v1alpha1 and Location, respectively.\n\nThe spec field is required. The minimal spec should be an empty object.\n\nThe single location type, that's common to the targets specified in the spec. If it is left out, it is inherited from the location type that originally read the entity data. For example, if you have a url type location, that when read results in a Location kind entity with no spec.type, then the referenced targets in the entity will implicitly also be of url type. This is useful because you can define a hierarchy of things in a directory structure using relative target paths (see below), and it will work out no matter if it's consumed locally on disk from a file location, or as uploaded on a VCS.\n\nA single target as a string. Can be either an absolute path/URL (depending on the type), or a relative path such as ./details/catalog-info.yaml which is resolved relative to the location of this Location entity itself.\n\nA list of targets as strings. They can all be either absolute paths/URLs (depending on the type), or relative paths such as ./details/catalog-info.yaml which are resolved relative to the location of this Location entity itself."
    }
}