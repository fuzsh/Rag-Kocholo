{
    "id": "dbpedia_109_1",
    "rank": 54,
    "data": {
        "url": "https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions",
        "read_more_link": "",
        "language": "en",
        "title": "String functions",
        "top_image": "https://cloud.google.com/_static/cloud/images/social-icon-google-cloud-1200-630.png",
        "meta_img": "https://cloud.google.com/_static/cloud/images/social-icon-google-cloud-1200-630.png",
        "images": [
            "https://www.gstatic.com/devrel-devsite/prod/v80280542cfb431993d6ccf12e26a1c5862cffb314c3cfae3ff08e8374a93b7f7/cloud/images/cloud-logo.svg",
            "https://www.gstatic.com/devrel-devsite/prod/v80280542cfb431993d6ccf12e26a1c5862cffb314c3cfae3ff08e8374a93b7f7/cloud/images/cloud-logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://www.gstatic.com/devrel-devsite/prod/v80280542cfb431993d6ccf12e26a1c5862cffb314c3cfae3ff08e8374a93b7f7/cloud/images/favicons/onecloud/favicon.ico",
        "meta_site_name": "Google Cloud",
        "canonical_link": "https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions",
        "text": "GoogleSQL for BigQuery supports string functions. These string functions work on two different values: STRING and BYTES data types. STRING values must be well-formed UTF-8.\n\nFunctions that return position values, such as STRPOS, encode those positions as INT64. The value 1 refers to the first character (or byte), 2 refers to the second, and so on. The value 0 indicates an invalid position. When working on STRING types, the returned positions refer to character positions.\n\nAll string comparisons are done byte-by-byte, without regard to Unicode canonical equivalence.\n\nFunction list\n\nName Summary ASCII Gets the ASCII code for the first character or byte in a STRING or BYTES value. BYTE_LENGTH Gets the number of BYTES in a STRING or BYTES value. CHAR_LENGTH Gets the number of characters in a STRING value. CHARACTER_LENGTH Synonym for CHAR_LENGTH. CHR Converts a Unicode code point to a character. CODE_POINTS_TO_BYTES Converts an array of extended ASCII code points to a BYTES value. CODE_POINTS_TO_STRING Converts an array of extended ASCII code points to a STRING value. COLLATE Combines a STRING value and a collation specification into a collation specification-supported STRING value. CONCAT Concatenates one or more STRING or BYTES values into a single result. CONTAINS_SUBSTR Performs a normalized, case-insensitive search to see if a value exists as a substring in an expression. EDIT_DISTANCE Computes the Levenshtein distance between two STRING or BYTES values. ENDS_WITH Checks if a STRING or BYTES value is the suffix of another value. FORMAT Formats data and produces the results as a STRING value. FROM_BASE32 Converts a base32-encoded STRING value into a BYTES value. FROM_BASE64 Converts a base64-encoded STRING value into a BYTES value. FROM_HEX Converts a hexadecimal-encoded STRING value into a BYTES value. INITCAP Formats a STRING as proper case, which means that the first character in each word is uppercase and all other characters are lowercase. INSTR Finds the position of a subvalue inside another value, optionally starting the search at a given offset or occurrence. LEFT Gets the specified leftmost portion from a STRING or BYTES value. LENGTH Gets the length of a STRING or BYTES value. LOWER Formats alphabetic characters in a STRING value as lowercase.\n\nFormats ASCII characters in a BYTES value as lowercase. LPAD Prepends a STRING or BYTES value with a pattern. LTRIM Identical to the TRIM function, but only removes leading characters. NORMALIZE Case-sensitively normalizes the characters in a STRING value. NORMALIZE_AND_CASEFOLD Case-insensitively normalizes the characters in a STRING value. OCTET_LENGTH Alias for BYTE_LENGTH. REGEXP_CONTAINS Checks if a value is a partial match for a regular expression. REGEXP_EXTRACT Produces a substring that matches a regular expression. REGEXP_EXTRACT_ALL Produces an array of all substrings that match a regular expression. REGEXP_INSTR Finds the position of a regular expression match in a value, optionally starting the search at a given offset or occurrence. REGEXP_REPLACE Produces a STRING value where all substrings that match a regular expression are replaced with a specified value. REGEXP_SUBSTR Synonym for REGEXP_EXTRACT. REPEAT Produces a STRING or BYTES value that consists of an original value, repeated. REPLACE Replaces all occurrences of a pattern with another pattern in a STRING or BYTES value. REVERSE Reverses a STRING or BYTES value. RIGHT Gets the specified rightmost portion from a STRING or BYTES value. RPAD Appends a STRING or BYTES value with a pattern. RTRIM Identical to the TRIM function, but only removes trailing characters. SAFE_CONVERT_BYTES_TO_STRING Converts a BYTES value to a STRING value and replace any invalid UTF-8 characters with the Unicode replacement character, U+FFFD. SOUNDEX Gets the Soundex codes for words in a STRING value. SPLIT Splits a STRING or BYTES value, using a delimiter. STARTS_WITH Checks if a STRING or BYTES value is a prefix of another value. STRPOS Finds the position of the first occurrence of a subvalue inside another value. SUBSTR Gets a portion of a STRING or BYTES value. SUBSTRING Alias for SUBSTR TO_BASE32 Converts a BYTES value to a base32-encoded STRING value. TO_BASE64 Converts a BYTES value to a base64-encoded STRING value. TO_CODE_POINTS Converts a STRING or BYTES value into an array of extended ASCII code points. TO_HEX Converts a BYTES value to a hexadecimal STRING value. TRANSLATE Within a value, replaces each source character with the corresponding target character. TRIM Removes the specified leading and trailing Unicode code points or bytes from a STRING or BYTES value. UNICODE Gets the Unicode code point for the first character in a value. UPPER Formats alphabetic characters in a STRING value as uppercase.\n\nFormats ASCII characters in a BYTES value as uppercase.\n\nASCII\n\nASCII(value)\n\nDescription\n\nReturns the ASCII code for the first character or byte in value. Returns 0 if value is empty or the ASCII code is 0 for the first character or byte.\n\nReturn type\n\nINT64\n\nExamples\n\nSELECT ASCII('abcd') as A, ASCII('a') as B, ASCII('') as C, ASCII(NULL) as D; /*-------+-------+-------+-------* | A | B | C | D | +-------+-------+-------+-------+ | 97 | 97 | 0 | NULL | *-------+-------+-------+-------*/\n\nBYTE_LENGTH\n\nBYTE_LENGTH(value)\n\nDescription\n\nGets the number of BYTES in a STRING or BYTES value, regardless of whether the value is a STRING or BYTES type.\n\nReturn type\n\nINT64\n\nExamples\n\nSELECT BYTE_LENGTH('абвгд') AS string_example; /*----------------* | string_example | +----------------+ | 10 | *----------------*/\n\nSELECT BYTE_LENGTH(b'абвгд') AS bytes_example; /*----------------* | bytes_example | +----------------+ | 10 | *----------------*/\n\nCHAR_LENGTH\n\nCHAR_LENGTH(value)\n\nDescription\n\nGets the number of characters in a STRING value.\n\nReturn type\n\nINT64\n\nExamples\n\nSELECT CHAR_LENGTH('абвгд') AS char_length; /*-------------* | char_length | +-------------+ | 5 | *------------ */\n\nCHARACTER_LENGTH\n\nCHARACTER_LENGTH(value)\n\nDescription\n\nSynonym for CHAR_LENGTH.\n\nReturn type\n\nINT64\n\nExamples\n\nSELECT 'абвгд' AS characters, CHARACTER_LENGTH('абвгд') AS char_length_example /*------------+---------------------* | characters | char_length_example | +------------+---------------------+ | абвгд | 5 | *------------+---------------------*/\n\nCHR\n\nCHR(value)\n\nDescription\n\nTakes a Unicode code point and returns the character that matches the code point. Each valid code point should fall within the range of [0, 0xD7FF] and [0xE000, 0x10FFFF]. Returns an empty string if the code point is 0. If an invalid Unicode code point is specified, an error is returned.\n\nTo work with an array of Unicode code points, see CODE_POINTS_TO_STRING\n\nReturn type\n\nSTRING\n\nExamples\n\nSELECT CHR(65) AS A, CHR(255) AS B, CHR(513) AS C, CHR(1024) AS D; /*-------+-------+-------+-------* | A | B | C | D | +-------+-------+-------+-------+ | A | ÿ | ȁ | Ѐ | *-------+-------+-------+-------*/\n\nSELECT CHR(97) AS A, CHR(0xF9B5) AS B, CHR(0) AS C, CHR(NULL) AS D; /*-------+-------+-------+-------* | A | B | C | D | +-------+-------+-------+-------+ | a | 例 | | NULL | *-------+-------+-------+-------*/\n\nCODE_POINTS_TO_BYTES\n\nCODE_POINTS_TO_BYTES(ascii_code_points)\n\nDescription\n\nTakes an array of extended ASCII code points as ARRAY<INT64> and returns BYTES.\n\nTo convert from BYTES to an array of code points, see TO_CODE_POINTS.\n\nReturn type\n\nBYTES\n\nExamples\n\nThe following is a basic example using CODE_POINTS_TO_BYTES.\n\nSELECT CODE_POINTS_TO_BYTES([65, 98, 67, 100]) AS bytes; -- Note that the result of CODE_POINTS_TO_BYTES is of type BYTES, displayed as a base64-encoded string. -- In BYTES format, b'AbCd' is the result. /*----------* | bytes | +----------+ | QWJDZA== | *----------*/\n\nThe following example uses a rotate-by-13 places (ROT13) algorithm to encode a string.\n\nSELECT CODE_POINTS_TO_BYTES(ARRAY_AGG( (SELECT CASE WHEN chr BETWEEN b'a' and b'z' THEN TO_CODE_POINTS(b'a')[offset(0)] + MOD(code+13-TO_CODE_POINTS(b'a')[offset(0)],26) WHEN chr BETWEEN b'A' and b'Z' THEN TO_CODE_POINTS(b'A')[offset(0)] + MOD(code+13-TO_CODE_POINTS(b'A')[offset(0)],26) ELSE code END FROM (SELECT code, CODE_POINTS_TO_BYTES([code]) chr) ) ORDER BY OFFSET)) AS encoded_string FROM UNNEST(TO_CODE_POINTS(b'Test String!')) code WITH OFFSET; -- Note that the result of CODE_POINTS_TO_BYTES is of type BYTES, displayed as a base64-encoded string. -- In BYTES format, b'Grfg Fgevat!' is the result. /*------------------* | encoded_string | +------------------+ | R3JmZyBGZ2V2YXQh | *------------------*/\n\nCODE_POINTS_TO_STRING\n\nCODE_POINTS_TO_STRING(unicode_code_points)\n\nDescription\n\nTakes an array of Unicode code points as ARRAY<INT64> and returns a STRING.\n\nTo convert from a string to an array of code points, see TO_CODE_POINTS.\n\nReturn type\n\nSTRING\n\nExamples\n\nThe following are basic examples using CODE_POINTS_TO_STRING.\n\nSELECT CODE_POINTS_TO_STRING([65, 255, 513, 1024]) AS string; /*--------* | string | +--------+ | AÿȁЀ | *--------*/\n\nSELECT CODE_POINTS_TO_STRING([97, 0, 0xF9B5]) AS string; /*--------* | string | +--------+ | a例 | *--------*/\n\nSELECT CODE_POINTS_TO_STRING([65, 255, NULL, 1024]) AS string; /*--------* | string | +--------+ | NULL | *--------*/\n\nThe following example computes the frequency of letters in a set of words.\n\nWITH Words AS ( SELECT word FROM UNNEST(['foo', 'bar', 'baz', 'giraffe', 'llama']) AS word ) SELECT CODE_POINTS_TO_STRING([code_point]) AS letter, COUNT(*) AS letter_count FROM Words, UNNEST(TO_CODE_POINTS(word)) AS code_point GROUP BY 1 ORDER BY 2 DESC; /*--------+--------------* | letter | letter_count | +--------+--------------+ | a | 5 | | f | 3 | | r | 2 | | b | 2 | | l | 2 | | o | 2 | | g | 1 | | z | 1 | | e | 1 | | m | 1 | | i | 1 | *--------+--------------*/\n\nCOLLATE\n\nCOLLATE(value, collate_specification)\n\nTakes a STRING and a collation specification. Returns a STRING with a collation specification. If collate_specification is empty, returns a value with collation removed from the STRING.\n\nThe collation specification defines how the resulting STRING can be compared and sorted. To learn more, see Working with collation.\n\ncollation_specification must be a string literal, otherwise an error is thrown.\n\nReturns NULL if value is NULL.\n\nReturn type\n\nSTRING\n\nExamples\n\nIn this example, the weight of a is less than the weight of Z. This is because the collate specification, und:ci assigns more weight to Z.\n\nWITH Words AS ( SELECT COLLATE('a', 'und:ci') AS char1, COLLATE('Z', 'und:ci') AS char2 ) SELECT ( Words.char1 < Words.char2 ) AS a_less_than_Z FROM Words; /*----------------* | a_less_than_Z | +----------------+ | TRUE | *----------------*/\n\nIn this example, the weight of a is greater than the weight of Z. This is because the default collate specification assigns more weight to a.\n\nWITH Words AS ( SELECT 'a' AS char1, 'Z' AS char2 ) SELECT ( Words.char1 < Words.char2 ) AS a_less_than_Z FROM Words; /*----------------* | a_less_than_Z | +----------------+ | FALSE | *----------------*/\n\nCONCAT\n\nCONCAT(value1[, ...])\n\nDescription\n\nConcatenates one or more values into a single result. All values must be BYTES or data types that can be cast to STRING.\n\nThe function returns NULL if any input argument is NULL.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT CONCAT('T.P.', ' ', 'Bar') as author; /*---------------------* | author | +---------------------+ | T.P. Bar | *---------------------*/\n\nSELECT CONCAT('Summer', ' ', 1923) as release_date; /*---------------------* | release_date | +---------------------+ | Summer 1923 | *---------------------*/\n\nWith Employees AS (SELECT 'John' AS first_name, 'Doe' AS last_name UNION ALL SELECT 'Jane' AS first_name, 'Smith' AS last_name UNION ALL SELECT 'Joe' AS first_name, 'Jackson' AS last_name) SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM Employees; /*---------------------* | full_name | +---------------------+ | John Doe | | Jane Smith | | Joe Jackson | *---------------------*/\n\nCONTAINS_SUBSTR\n\nCONTAINS_SUBSTR(expression, search_value_literal[, json_scope=>json_scope_value]) json_scope_value: { 'JSON_VALUES' | 'JSON_KEYS' | 'JSON_KEYS_AND_VALUES' }\n\nDescription\n\nPerforms a normalized, case-insensitive search to see if a value exists as a substring in an expression. Returns TRUE if the value exists, otherwise returns FALSE.\n\nBefore values are compared, they are normalized and case folded with NFKC normalization. Wildcard searches are not supported.\n\nArguments\n\nsearch_value_literal: The value to search for. It must be a STRING literal or a STRING constant expression.\n\nexpression: The data to search over. The expression can be a column or table reference. A table reference is evaluated as a STRUCT whose fields are the columns of the table. A column reference is evaluated as one the following data types:\n\nSTRING\n\nINT64\n\nBOOL\n\nNUMERIC\n\nBIGNUMERIC\n\nTIMESTAMP\n\nTIME\n\nDATE\n\nDATETIME\n\nARRAY\n\nSTRUCT\n\nWhen the expression is evaluated, the result is cast to a STRING, and then the function looks for the search value in the result.\n\nYou can perform a cross-field search on an expression that evaluates to a STRUCT or ARRAY. If the expression evaluates to a STRUCT, the cross-field search is recursive and includes all subfields inside the STRUCT.\n\nIn a cross-field search, each field and subfield is individually converted to a string and searched for the value. The function returns TRUE if at least one field includes the search value; otherwise, if at least one field is NULL, it returns NULL; otherwise, if the search value is not found and all fields are non-NULL, it returns FALSE.\n\nIf the expression is NULL, the return value is NULL.\n\njson_scope: This optional mandatory-named argument takes one of the following values to indicate the scope of JSON data to be searched. It has no effect if expression is not JSON or does not contain a JSON field.\n\n'JSON_VALUES': Only the JSON values are searched. If json_scope is not provided, this is used by default.\n\n'JSON_KEYS': Only the JSON keys are searched.\n\n'JSON_KEYS_AND_VALUES': The JSON keys and values are searched.\n\nReturn type\n\nBOOL\n\nExamples\n\nThe following query returns TRUE because this case-insensitive match was found: blue house and Blue house.\n\nSELECT CONTAINS_SUBSTR('the blue house', 'Blue house') AS result; /*--------* | result | +--------+ | true | *--------*/\n\nThe following query returns TRUE similar to the above example, but in this case the search value is a constant expression with CONCAT function.\n\nSELECT CONTAINS_SUBSTR('the blue house', CONCAT('Blue ', 'house')) AS result; /*--------* | result | +--------+ | true | *--------*/\n\nThe following query returns FALSE because blue was not found in the red house.\n\nSELECT CONTAINS_SUBSTR('the red house', 'blue') AS result; /*--------* | result | +--------+ | false | *--------*/\n\nThe following query returns TRUE because Ⅸ and IX represent the same normalized value.\n\nSELECT '\\u2168 day' AS a, 'IX' AS b, CONTAINS_SUBSTR('\\u2168', 'IX') AS result; /*----------------------* | a | b | result | +----------------------+ | Ⅸ day | IX | true | *----------------------*/\n\nThe following query returns TRUE because 35 was found inside a STRUCT field.\n\nSELECT CONTAINS_SUBSTR((23, 35, 41), '35') AS result; /*--------* | result | +--------+ | true | *--------*/\n\nThe following query returns TRUE because jk was found during a recursive search inside a STRUCT.\n\nSELECT CONTAINS_SUBSTR(('abc', ['def', 'ghi', 'jkl'], 'mno'), 'jk'); /*--------* | result | +--------+ | true | *--------*/\n\nThe following query returns TRUE because NULLs are ignored when a match is found found inside a STRUCT or ARRAY.\n\nSELECT CONTAINS_SUBSTR((23, NULL, 41), '41') AS result; /*--------* | result | +--------+ | true | *--------*/\n\nThe following query returns NULL because a NULL existed in a STRUCT that did not result in a match.\n\nSELECT CONTAINS_SUBSTR((23, NULL, 41), '35') AS result; /*--------* | result | +--------+ | null | *--------*/\n\nIn the following query, an error is thrown because the search value cannot be a literal NULL.\n\nSELECT CONTAINS_SUBSTR('hello', NULL) AS result; -- Throws an error\n\nThe following examples reference a table called Recipes that you can emulate with a WITH clause like this:\n\nWITH Recipes AS (SELECT 'Blueberry pancakes' as Breakfast, 'Egg salad sandwich' as Lunch, 'Potato dumplings' as Dinner UNION ALL SELECT 'Potato pancakes', 'Toasted cheese sandwich', 'Beef stroganoff' UNION ALL SELECT 'Ham scramble', 'Steak avocado salad', 'Tomato pasta' UNION ALL SELECT 'Avocado toast', 'Tomato soup', 'Blueberry salmon' UNION ALL SELECT 'Corned beef hash', 'Lentil potato soup', 'Glazed ham') SELECT * FROM Recipes; /*-------------------+-------------------------+------------------* | Breakfast | Lunch | Dinner | +-------------------+-------------------------+------------------+ | Bluberry pancakes | Egg salad sandwich | Potato dumplings | | Potato pancakes | Toasted cheese sandwich | Beef stroganoff | | Ham scramble | Steak avocado salad | Tomato pasta | | Avocado toast | Tomato soup | Blueberry samon | | Corned beef hash | Lentil potato soup | Glazed ham | *-------------------+-------------------------+------------------*/\n\nThe following query searches across all columns of the Recipes table for the value toast and returns the rows that contain this value.\n\nSELECT * FROM Recipes WHERE CONTAINS_SUBSTR(Recipes, 'toast'); /*-------------------+-------------------------+------------------* | Breakfast | Lunch | Dinner | +-------------------+-------------------------+------------------+ | Potato pancakes | Toasted cheese sandwich | Beef stroganoff | | Avocado toast | Tomato soup | Blueberry samon | *-------------------+-------------------------+------------------*/\n\nThe following query searches the Lunch and Dinner columns of the Recipe table for the value potato and returns the row if either column contains this value.\n\nSELECT * FROM Recipes WHERE CONTAINS_SUBSTR((Lunch, Dinner), 'potato'); /*-------------------+-------------------------+------------------* | Breakfast | Lunch | Dinner | +-------------------+-------------------------+------------------+ | Bluberry pancakes | Egg salad sandwich | Potato dumplings | | Corned beef hash | Lentil potato soup | Glazed ham | *-------------------+-------------------------+------------------*/\n\nThe following query searches across all columns of the Recipes table except for the Lunch and Dinner columns. It returns the rows of any columns other than Lunch or Dinner that contain the value potato.\n\nSELECT * FROM Recipes WHERE CONTAINS_SUBSTR( (SELECT AS STRUCT Recipes.* EXCEPT (Lunch, Dinner)), 'potato' ); /*-------------------+-------------------------+------------------* | Breakfast | Lunch | Dinner | +-------------------+-------------------------+------------------+ | Potato pancakes | Toasted cheese sandwich | Beef stroganoff | *-------------------+-------------------------+------------------*/\n\nThe following query searches for the value lunch in the JSON {\"lunch\":\"soup\"} and returns FALSE because the default json_scope is \"JSON_VALUES\", and lunch is a JSON key, not a JSON value.\n\nSELECT CONTAINS_SUBSTR(JSON '{\"lunch\":\"soup\"}',\"lunch\") AS result; /*--------* | result | +--------+ | FALSE | *--------*/\n\nThe following query searches for the value lunch in the values of the JSON {\"lunch\":\"soup\"} and returns FALSE because lunch is a JSON key, not a JSON value.\n\nSELECT CONTAINS_SUBSTR(JSON '{\"lunch\":\"soup\"}', \"lunch\", json_scope=>\"JSON_VALUES\") AS result; /*--------* | result | +--------+ | FALSE | *--------*/\n\nThe following query searches for the value lunch in the keys and values of the JSON {\"lunch\":\"soup\"} and returns TRUE because lunch is a JSON key.\n\nSELECT CONTAINS_SUBSTR(JSON '{\"lunch\":\"soup\"}', \"lunch\", json_scope=>\"JSON_KEYS_AND_VALUES\") AS result; /*--------* | result | +--------+ | TRUE | *--------*/\n\nThe following query searches for the value lunch in the keys of the JSON {\"lunch\":\"soup\"} and returns TRUE because lunch is a JSON key.\n\nSELECT CONTAINS_SUBSTR(JSON '{\"lunch\":\"soup\"}', \"lunch\", json_scope=>\"JSON_KEYS\") AS result; /*--------* | result | +--------+ | TRUE | *--------*/\n\nEDIT_DISTANCE\n\nEDIT_DISTANCE(value1, value2, [max_distance => max_distance_value])\n\nDescription\n\nComputes the Levenshtein distance between two STRING or BYTES values.\n\nDefinitions\n\nvalue1: The first STRING or BYTES value to compare.\n\nvalue2: The second STRING or BYTES value to compare.\n\nmax_distance: Optional mandatory-named argument. Takes a non-negative INT64 value that represents the maximum distance between the two values to compute.\n\nIf this distance is exceeded, the function returns this value. The default value for this argument is the maximum size of value1 and value2.\n\nDetails\n\nIf value1 or value2 is NULL, NULL is returned.\n\nYou can only compare values of the same type. Otherwise, an error is produced.\n\nReturn type\n\nINT64\n\nExamples\n\nIn the following example, the first character in both strings is different:\n\nSELECT EDIT_DISTANCE('a', 'b') AS results; /*---------* | results | +---------+ | 1 | *---------*/\n\nIn the following example, the first and second characters in both strings are different:\n\nSELECT EDIT_DISTANCE('aa', 'b') AS results; /*---------* | results | +---------+ | 2 | *---------*/\n\nIn the following example, only the first character in both strings is different:\n\nSELECT EDIT_DISTANCE('aa', 'ba') AS results; /*---------* | results | +---------+ | 1 | *---------*/\n\nIn the following example, the last six characters are different, but because the maximum distance is 2, this function exits early and returns 2, the maximum distance:\n\nSELECT EDIT_DISTANCE('abcdefg', 'a', max_distance => 2) AS results; /*---------* | results | +---------+ | 2 | *---------*/\n\nENDS_WITH\n\nENDS_WITH(value, suffix)\n\nDescription\n\nTakes two STRING or BYTES values. Returns TRUE if suffix is a suffix of value.\n\nThis function supports specifying collation.\n\nReturn type\n\nBOOL\n\nExamples\n\nSELECT ENDS_WITH('apple', 'e') as example /*---------* | example | +---------+ | True | *---------*/\n\nFORMAT\n\nFORMAT(format_string_expression, data_type_expression[, ...])\n\nDescription\n\nFORMAT formats a data type expression as a string.\n\nformat_string_expression: Can contain zero or more format specifiers. Each format specifier is introduced by the % symbol, and must map to one or more of the remaining arguments. In general, this is a one-to-one mapping, except when the * specifier is present. For example, %.*i maps to two arguments—a length argument and a signed integer argument. If the number of arguments related to the format specifiers is not the same as the number of arguments, an error occurs.\n\ndata_type_expression: The value to format as a string. This can be any GoogleSQL data type.\n\nReturn type\n\nSTRING\n\nExamples\n\nDescription Statement Result Simple integer FORMAT('%d', 10) 10 Integer with left blank padding FORMAT('|%10d|', 11) | 11| Integer with left zero padding FORMAT('+%010d+', 12) +0000000012+ Integer with commas FORMAT(\"%'d\", 123456789) 123,456,789 STRING FORMAT('-%s-', 'abcd efg') -abcd efg- FLOAT64 FORMAT('%f %E', 1.1, 2.2) 1.100000 2.200000E+00 DATE FORMAT('%t', date '2015-09-01') 2015-09-01 TIMESTAMP FORMAT('%t', timestamp '2015-09-01 12:34:56 America/Los_Angeles') 2015‑09‑01 19:34:56+00\n\nThe FORMAT() function does not provide fully customizable formatting for all types and values, nor formatting that is sensitive to locale.\n\nIf custom formatting is necessary for a type, you must first format it using type-specific format functions, such as FORMAT_DATE() or FORMAT_TIMESTAMP(). For example:\n\nSELECT FORMAT('date: %s!', FORMAT_DATE('%B %d, %Y', date '2015-01-02'));\n\nReturns\n\ndate: January 02, 2015!\n\nSupported format specifiers\n\n%[flags][width][.precision]specifier\n\nA format specifier adds formatting when casting a value to a string. It can optionally contain these sub-specifiers:\n\nFlags\n\nWidth\n\nPrecision\n\nAdditional information about format specifiers:\n\n%g and %G behavior\n\n%p and %P behavior\n\n%t and %T behavior\n\nError conditions\n\nNULL argument handling\n\nAdditional semantic rules\n\nFormat specifiers\n\nSpecifier Description Examples Types d or i Decimal integer 392 INT64\n\no Octal\n\nNote: If an INT64 value is negative, an error is produced. 610 INT64\n\nx Hexadecimal integer\n\nNote: If an INT64 value is negative, an error is produced. 7fa INT64\n\nX Hexadecimal integer (uppercase)\n\nNote: If an INT64 value is negative, an error is produced. 7FA INT64\n\nf Decimal notation, in [-](integer part).(fractional part) for finite values, and in lowercase for non-finite values 392.650000\n\ninf\n\nnan NUMERIC\n\nBIGNUMERIC\n\nFLOAT64\n\nF Decimal notation, in [-](integer part).(fractional part) for finite values, and in uppercase for non-finite values 392.650000\n\nINF\n\nNAN NUMERIC\n\nBIGNUMERIC\n\nFLOAT64\n\ne Scientific notation (mantissa/exponent), lowercase 3.926500e+02\n\ninf\n\nnan NUMERIC\n\nBIGNUMERIC\n\nFLOAT64\n\nE Scientific notation (mantissa/exponent), uppercase 3.926500E+02\n\nINF\n\nNAN NUMERIC\n\nBIGNUMERIC\n\nFLOAT64\n\ng Either decimal notation or scientific notation, depending on the input value's exponent and the specified precision. Lowercase. See %g and %G behavior for details. 392.65\n\n3.9265e+07\n\ninf\n\nnan NUMERIC\n\nBIGNUMERIC\n\nFLOAT64\n\nG Either decimal notation or scientific notation, depending on the input value's exponent and the specified precision. Uppercase. See %g and %G behavior for details. 392.65\n\n3.9265E+07\n\nINF\n\nNAN NUMERIC\n\nBIGNUMERIC\n\nFLOAT64\n\np Produces a one-line printable string representing JSON. See %p and %P behavior.\n\n{\"month\":10,\"year\":2019}\n\nJSON\n\nP Produces a multi-line printable string representing JSON. See %p and %P behavior.\n\n{ \"month\": 10, \"year\": 2019 }\n\nJSON\n\ns String of characters sample STRING\n\nt Returns a printable string representing the value. Often looks similar to casting the argument to STRING. See %t and %T behavior. sample\n\n2014‑01‑01 Any type T Produces a string that is a valid GoogleSQL constant with a similar type to the value's type (maybe wider, or maybe string). See %t and %T behavior. 'sample'\n\nb'bytes sample'\n\n1234\n\n2.3\n\ndate '2014‑01‑01' Any type % '%%' produces a single '%' % n/a\n\nThe format specifier can optionally contain the sub-specifiers identified above in the specifier prototype.\n\nThese sub-specifiers must comply with the following specifications.\n\nFlags\n\nFlags Description - Left-justify within the given field width; Right justification is the default (see width sub-specifier) + Forces to precede the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a - sign <space> If no sign is going to be written, a blank space is inserted before the value #\n\nFor `%o`, `%x`, and `%X`, this flag means to precede the value with 0, 0x or 0X respectively for values different than zero.\n\nFor `%f`, `%F`, `%e`, and `%E`, this flag means to add the decimal point even when there is no fractional part, unless the value is non-finite.\n\nFor `%g` and `%G`, this flag means to add the decimal point even when there is no fractional part unless the value is non-finite, and never remove the trailing zeros after the decimal point.\n\n0 Left-pads the number with zeroes (0) instead of spaces when padding is specified (see width sub-specifier) '\n\nFormats integers using the appropriating grouping character. For example:\n\nFORMAT(\"%'d\", 12345678) returns 12,345,678\n\nFORMAT(\"%'x\", 12345678) returns bc:614e\n\nFORMAT(\"%'o\", 55555) returns 15,4403\n\nThis flag is only relevant for decimal, hex, and octal values.\n\nFlags may be specified in any order. Duplicate flags are not an error. When flags are not relevant for some element type, they are ignored.\n\nWidth\n\nWidth Description <number> Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger * The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted\n\nPrecision\n\nPrecision Description .<number>\n\nFor integer specifiers `%d`, `%i`, `%o`, `%u`, `%x`, and `%X`: precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with trailing zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.\n\nFor specifiers `%a`, `%A`, `%e`, `%E`, `%f`, and `%F`: this is the number of digits to be printed after the decimal point. The default value is 6.\n\nFor specifiers `%g` and `%G`: this is the number of significant digits to be printed, before the removal of the trailing zeros after the decimal point. The default value is 6.\n\n.* The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted\n\n%g and %G behavior\n\nThe %g and %G format specifiers choose either the decimal notation (like the %f and %F specifiers) or the scientific notation (like the %e and %E specifiers), depending on the input value's exponent and the specified precision.\n\nLet p stand for the specified precision (defaults to 6; 1 if the specified precision is less than 1). The input value is first converted to scientific notation with precision = (p - 1). If the resulting exponent part x is less than -4 or no less than p, the scientific notation with precision = (p - 1) is used; otherwise the decimal notation with precision = (p - 1 - x) is used.\n\nUnless # flag is present, the trailing zeros after the decimal point are removed, and the decimal point is also removed if there is no digit after it.\n\n%p and %P behavior\n\nThe %p format specifier produces a one-line printable string. The %P format specifier produces a multi-line printable string. You can use these format specifiers with the following data types:\n\n%t and %T behavior\n\nThe %t and %T format specifiers are defined for all types. The width, precision, and flags act as they do for %s: the width is the minimum width and the STRING will be padded to that size, and precision is the maximum width of content to show and the STRING will be truncated to that size, prior to padding to width.\n\nThe %t specifier is always meant to be a readable form of the value.\n\nThe %T specifier is always a valid SQL literal of a similar type, such as a wider numeric type. The literal will not include casts or a type name, except for the special case of non-finite floating point values.\n\nThe STRING is formatted as follows:\n\nType %t %T NULL of any type NULL NULL INT64\n\n123 123 NUMERIC 123.0 (always with .0) NUMERIC \"123.0\" FLOAT64 123.0 (always with .0)\n\n123e+10\n\ninf\n\n-inf\n\nNaN 123.0 (always with .0)\n\n123e+10\n\nCAST(\"inf\" AS <type>)\n\nCAST(\"-inf\" AS <type>)\n\nCAST(\"nan\" AS <type>) STRING unquoted string value quoted string literal BYTES unquoted escaped bytes\n\ne.g., abc\\x01\\x02 quoted bytes literal\n\ne.g., b\"abc\\x01\\x02\" BOOL boolean value boolean value DATE 2011-02-03 DATE \"2011-02-03\" TIMESTAMP 2011-02-03 04:05:06+00 TIMESTAMP \"2011-02-03 04:05:06+00\" INTERVAL 1-2 3 4:5:6.789 INTERVAL \"1-2 3 4:5:6.789\" YEAR TO SECOND ARRAY [value, value, ...]\n\nwhere values are formatted with %t [value, value, ...]\n\nwhere values are formatted with %T STRUCT (value, value, ...)\n\nwhere fields are formatted with %t (value, value, ...)\n\nwhere fields are formatted with %T\n\nSpecial cases:\n\nZero fields: STRUCT()\n\nOne field: STRUCT(value) JSON one-line printable string representing JSON.\n\n{\"name\":\"apple\",\"stock\":3}\n\none-line printable string representing a JSON literal.\n\nJSON '{\"name\":\"apple\",\"stock\":3}'\n\nError conditions\n\nIf a format specifier is invalid, or is not compatible with the related argument type, or the wrong number or arguments are provided, then an error is produced. For example, the following <format_string> expressions are invalid:\n\nFORMAT('%s', 1)\n\nFORMAT('%')\n\nNULL argument handling\n\nA NULL format string results in a NULL output STRING. Any other arguments are ignored in this case.\n\nThe function generally produces a NULL value if a NULL argument is present. For example, FORMAT('%i', NULL_expression) produces a NULL STRING as output.\n\nHowever, there are some exceptions: if the format specifier is %t or %T (both of which produce STRINGs that effectively match CAST and literal value semantics), a NULL value produces 'NULL' (without the quotes) in the result STRING. For example, the function:\n\nFORMAT('00-%t-00', NULL_expression);\n\nReturns\n\n00-NULL-00\n\nAdditional semantic rules\n\nFLOAT64 values can be +/-inf or NaN. When an argument has one of those values, the result of the format specifiers %f, %F, %e, %E, %g, %G, and %t are inf, -inf, or nan (or the same in uppercase) as appropriate. This is consistent with how GoogleSQL casts these values to STRING. For %T, GoogleSQL returns quoted strings for FLOAT64 values that don't have non-string literal representations.\n\nFROM_BASE32\n\nFROM_BASE32(string_expr)\n\nDescription\n\nConverts the base32-encoded input string_expr into BYTES format. To convert BYTES to a base32-encoded STRING, use TO_BASE32.\n\nReturn type\n\nBYTES\n\nExample\n\nSELECT FROM_BASE32('MFRGGZDF74======') AS byte_data; -- Note that the result of FROM_BASE32 is of type BYTES, displayed as a base64-encoded string. /*-----------* | byte_data | +-----------+ | YWJjZGX/ | *-----------*/\n\nFROM_BASE64\n\nFROM_BASE64(string_expr)\n\nDescription\n\nConverts the base64-encoded input string_expr into BYTES format. To convert BYTES to a base64-encoded STRING, use [TO_BASE64][string-link-to-base64].\n\nThere are several base64 encodings in common use that vary in exactly which alphabet of 65 ASCII characters are used to encode the 64 digits and padding. See RFC 4648 for details. This function expects the alphabet [A-Za-z0-9+/=].\n\nReturn type\n\nBYTES\n\nExample\n\nSELECT FROM_BASE64('/+A=') AS byte_data; -- Note that the result of FROM_BASE64 is of type BYTES, displayed as a base64-encoded string. /*-----------* | byte_data | +-----------+ | /+A= | *-----------*/\n\nTo work with an encoding using a different base64 alphabet, you might need to compose FROM_BASE64 with the REPLACE function. For instance, the base64url url-safe and filename-safe encoding commonly used in web programming uses -_= as the last characters rather than +/=. To decode a base64url-encoded string, replace - and _ with + and / respectively.\n\nSELECT FROM_BASE64(REPLACE(REPLACE('_-A=', '-', '+'), '_', '/')) AS binary; -- Note that the result of FROM_BASE64 is of type BYTES, displayed as a base64-encoded string. /*--------* | binary | +--------+ | /+A= | *--------*/\n\nFROM_HEX\n\nFROM_HEX(string)\n\nDescription\n\nConverts a hexadecimal-encoded STRING into BYTES format. Returns an error if the input STRING contains characters outside the range (0..9, A..F, a..f). The lettercase of the characters does not matter. If the input STRING has an odd number of characters, the function acts as if the input has an additional leading 0. To convert BYTES to a hexadecimal-encoded STRING, use TO_HEX.\n\nReturn type\n\nBYTES\n\nExample\n\nWITH Input AS ( SELECT '00010203aaeeefff' AS hex_str UNION ALL SELECT '0AF' UNION ALL SELECT '666f6f626172' ) SELECT hex_str, FROM_HEX(hex_str) AS bytes_str FROM Input; -- Note that the result of FROM_HEX is of type BYTES, displayed as a base64-encoded string. /*------------------+--------------* | hex_str | bytes_str | +------------------+--------------+ | 0AF | AAECA6ru7/8= | | 00010203aaeeefff | AK8= | | 666f6f626172 | Zm9vYmFy | *------------------+--------------*/\n\nINITCAP\n\nINITCAP(value[, delimiters])\n\nDescription\n\nTakes a STRING and returns it with the first character in each word in uppercase and all other characters in lowercase. Non-alphabetic characters remain the same.\n\ndelimiters is an optional string argument that is used to override the default set of characters used to separate words. If delimiters is not specified, it defaults to the following characters:\n\n<whitespace> [ ] ( ) { } / | \\ < > ! ? @ \" ^ # $ & ~ _ , . : ; * % + -\n\nIf value or delimiters is NULL, the function returns NULL.\n\nReturn type\n\nSTRING\n\nExamples\n\nSELECT 'Hello World-everyone!' AS value, INITCAP('Hello World-everyone!') AS initcap_value /*-------------------------------+-------------------------------* | value | initcap_value | +-------------------------------+-------------------------------+ | Hello World-everyone! | Hello World-Everyone! | *-------------------------------+-------------------------------*/\n\nSELECT 'Apples1oranges2pears' as value, '12' AS delimiters, INITCAP('Apples1oranges2pears' , '12') AS initcap_value /*----------------------+------------+----------------------* | value | delimiters | initcap_value | +----------------------+------------+----------------------+ | Apples1oranges2pears | 12 | Apples1Oranges2Pears | *----------------------+------------+----------------------*/\n\nINSTR\n\nINSTR(value, subvalue[, position[, occurrence]])\n\nDescription\n\nReturns the lowest 1-based position of subvalue in value. value and subvalue must be the same type, either STRING or BYTES.\n\nIf position is specified, the search starts at this position in value, otherwise it starts at 1, which is the beginning of value. If position is negative, the function searches backwards from the end of value, with -1 indicating the last character. position is of type INT64 and cannot be 0.\n\nIf occurrence is specified, the search returns the position of a specific instance of subvalue in value. If not specified, occurrence defaults to 1 and returns the position of the first occurrence. For occurrence > 1, the function includes overlapping occurrences. occurrence is of type INT64 and must be positive.\n\nThis function supports specifying collation.\n\nReturns 0 if:\n\nNo match is found.\n\nIf occurrence is greater than the number of matches found.\n\nIf position is greater than the length of value.\n\nReturns NULL if:\n\nAny input argument is NULL.\n\nReturns an error if:\n\nposition is 0.\n\noccurrence is 0 or negative.\n\nReturn type\n\nINT64\n\nExamples\n\nSELECT 'banana' AS value, 'an' AS subvalue, 1 AS position, 1 AS occurrence, INSTR('banana', 'an', 1, 1) AS instr; /*--------------+--------------+----------+------------+-------* | value | subvalue | position | occurrence | instr | +--------------+--------------+----------+------------+-------+ | banana | an | 1 | 1 | 2 | *--------------+--------------+----------+------------+-------*/\n\nSELECT 'banana' AS value, 'an' AS subvalue, 1 AS position, 2 AS occurrence, INSTR('banana', 'an', 1, 2) AS instr; /*--------------+--------------+----------+------------+-------* | value | subvalue | position | occurrence | instr | +--------------+--------------+----------+------------+-------+ | banana | an | 1 | 2 | 4 | *--------------+--------------+----------+------------+-------*/\n\nSELECT 'banana' AS value, 'an' AS subvalue, 1 AS position, 3 AS occurrence, INSTR('banana', 'an', 1, 3) AS instr; /*--------------+--------------+----------+------------+-------* | value | subvalue | position | occurrence | instr | +--------------+--------------+----------+------------+-------+ | banana | an | 1 | 3 | 0 | *--------------+--------------+----------+------------+-------*/\n\nSELECT 'banana' AS value, 'an' AS subvalue, 3 AS position, 1 AS occurrence, INSTR('banana', 'an', 3, 1) AS instr; /*--------------+--------------+----------+------------+-------* | value | subvalue | position | occurrence | instr | +--------------+--------------+----------+------------+-------+ | banana | an | 3 | 1 | 4 | *--------------+--------------+----------+------------+-------*/\n\nSELECT 'banana' AS value, 'an' AS subvalue, -1 AS position, 1 AS occurrence, INSTR('banana', 'an', -1, 1) AS instr; /*--------------+--------------+----------+------------+-------* | value | subvalue | position | occurrence | instr | +--------------+--------------+----------+------------+-------+ | banana | an | -1 | 1 | 4 | *--------------+--------------+----------+------------+-------*/\n\nSELECT 'banana' AS value, 'an' AS subvalue, -3 AS position, 1 AS occurrence, INSTR('banana', 'an', -3, 1) AS instr; /*--------------+--------------+----------+------------+-------* | value | subvalue | position | occurrence | instr | +--------------+--------------+----------+------------+-------+ | banana | an | -3 | 1 | 4 | *--------------+--------------+----------+------------+-------*/\n\nSELECT 'banana' AS value, 'ann' AS subvalue, 1 AS position, 1 AS occurrence, INSTR('banana', 'ann', 1, 1) AS instr; /*--------------+--------------+----------+------------+-------* | value | subvalue | position | occurrence | instr | +--------------+--------------+----------+------------+-------+ | banana | ann | 1 | 1 | 0 | *--------------+--------------+----------+------------+-------*/\n\nSELECT 'helloooo' AS value, 'oo' AS subvalue, 1 AS position, 1 AS occurrence, INSTR('helloooo', 'oo', 1, 1) AS instr; /*--------------+--------------+----------+------------+-------* | value | subvalue | position | occurrence | instr | +--------------+--------------+----------+------------+-------+ | helloooo | oo | 1 | 1 | 5 | *--------------+--------------+----------+------------+-------*/\n\nSELECT 'helloooo' AS value, 'oo' AS subvalue, 1 AS position, 2 AS occurrence, INSTR('helloooo', 'oo', 1, 2) AS instr; /*--------------+--------------+----------+------------+-------* | value | subvalue | position | occurrence | instr | +--------------+--------------+----------+------------+-------+ | helloooo | oo | 1 | 2 | 6 | *--------------+--------------+----------+------------+-------*/\n\nLEFT\n\nLEFT(value, length)\n\nDescription\n\nReturns a STRING or BYTES value that consists of the specified number of leftmost characters or bytes from value. The length is an INT64 that specifies the length of the returned value. If value is of type BYTES, length is the number of leftmost bytes to return. If value is STRING, length is the number of leftmost characters to return.\n\nIf length is 0, an empty STRING or BYTES value will be returned. If length is negative, an error will be returned. If length exceeds the number of characters or bytes from value, the original value will be returned.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT LEFT('banana', 3) AS results /*---------* | results | +--------+ | ban | *---------*/\n\nSELECT LEFT(b'\\xab\\xcd\\xef\\xaa\\xbb', 3) AS results -- Note that the result of LEFT is of type BYTES, displayed as a base64-encoded string. /*---------* | results | +---------+ | q83v | *---------*/\n\nLENGTH\n\nLENGTH(value)\n\nDescription\n\nReturns the length of the STRING or BYTES value. The returned value is in characters for STRING arguments and in bytes for the BYTES argument.\n\nReturn type\n\nINT64\n\nExamples\n\nSELECT LENGTH('абвгд') AS string_example, LENGTH(CAST('абвгд' AS BYTES)) AS bytes_example; /*----------------+---------------* | string_example | bytes_example | +----------------+---------------+ | 5 | 10 | *----------------+---------------*/\n\nLOWER\n\nLOWER(value)\n\nDescription\n\nFor STRING arguments, returns the original string with all alphabetic characters in lowercase. Mapping between lowercase and uppercase is done according to the Unicode Character Database without taking into account language-specific mappings.\n\nFor BYTES arguments, the argument is treated as ASCII text, with all bytes greater than 127 left intact.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT LOWER('FOO BAR BAZ') AS example FROM items; /*-------------* | example | +-------------+ | foo bar baz | *-------------*/\n\nLPAD\n\nLPAD(original_value, return_length[, pattern])\n\nDescription\n\nReturns a STRING or BYTES value that consists of original_value prepended with pattern. The return_length is an INT64 that specifies the length of the returned value. If original_value is of type BYTES, return_length is the number of bytes. If original_value is of type STRING, return_length is the number of characters.\n\nThe default value of pattern is a blank space.\n\nBoth original_value and pattern must be the same data type.\n\nIf return_length is less than or equal to the original_value length, this function returns the original_value value, truncated to the value of return_length. For example, LPAD('hello world', 7); returns 'hello w'.\n\nIf original_value, return_length, or pattern is NULL, this function returns NULL.\n\nThis function returns an error if:\n\nreturn_length is negative\n\npattern is empty\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT FORMAT('%T', LPAD('c', 5)) AS results /*---------* | results | +---------+ | \" c\" | *---------*/\n\nSELECT LPAD('b', 5, 'a') AS results /*---------* | results | +---------+ | aaaab | *---------*/\n\nSELECT LPAD('abc', 10, 'ghd') AS results /*------------* | results | +------------+ | ghdghdgabc | *------------*/\n\nSELECT LPAD('abc', 2, 'd') AS results /*---------* | results | +---------+ | ab | *---------*/\n\nSELECT FORMAT('%T', LPAD(b'abc', 10, b'ghd')) AS results /*---------------* | results | +---------------+ | b\"ghdghdgabc\" | *---------------*/\n\nLTRIM\n\nLTRIM(value1[, value2])\n\nDescription\n\nIdentical to TRIM, but only removes leading characters.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT CONCAT('#', LTRIM(' apple '), '#') AS example /*-------------* | example | +-------------+ | #apple # | *-------------*/\n\nSELECT LTRIM('***apple***', '*') AS example /*-----------* | example | +-----------+ | apple*** | *-----------*/\n\nSELECT LTRIM('xxxapplexxx', 'xyz') AS example /*-----------* | example | +-----------+ | applexxx | *-----------*/\n\nNORMALIZE\n\nNORMALIZE(value[, normalization_mode])\n\nDescription\n\nTakes a string value and returns it as a normalized string. If you do not provide a normalization mode, NFC is used.\n\nNormalization is used to ensure that two strings are equivalent. Normalization is often used in situations in which two strings render the same on the screen but have different Unicode code points.\n\nNORMALIZE supports four optional normalization modes:\n\nValue Name Description NFC Normalization Form Canonical Composition Decomposes and recomposes characters by canonical equivalence. NFKC Normalization Form Compatibility Composition Decomposes characters by compatibility, then recomposes them by canonical equivalence. NFD Normalization Form Canonical Decomposition Decomposes characters by canonical equivalence, and multiple combining characters are arranged in a specific order. NFKD Normalization Form Compatibility Decomposition Decomposes characters by compatibility, and multiple combining characters are arranged in a specific order.\n\nReturn type\n\nSTRING\n\nExamples\n\nThe following example normalizes different language characters:\n\nSELECT NORMALIZE('\\u00ea') as a, NORMALIZE('\\u0065\\u0302') as b, NORMALIZE('\\u00ea') = NORMALIZE('\\u0065\\u0302') as normalized; /*---+---+------------* | a | b | normalized | +---+---+------------+ | ê | ê | TRUE | *---+---+------------*/\n\nThe following examples normalize different space characters:\n\nSELECT NORMALIZE('Raha\\u2004Mahan', NFKC) AS normalized_name /*-----------------* | normalized_name | +-----------------+ | Raha Mahan | *-----------------*/\n\nSELECT NORMALIZE('Raha\\u2005Mahan', NFKC) AS normalized_name /*-----------------* | normalized_name | +-----------------+ | Raha Mahan | *-----------------*/\n\nSELECT NORMALIZE('Raha\\u2006Mahan', NFKC) AS normalized_name /*-----------------* | normalized_name | +-----------------+ | Raha Mahan | *-----------------*/\n\nSELECT NORMALIZE('Raha Mahan', NFKC) AS normalized_name /*-----------------* | normalized_name | +-----------------+ | Raha Mahan | *-----------------*/\n\nNORMALIZE_AND_CASEFOLD\n\nNORMALIZE_AND_CASEFOLD(value[, normalization_mode])\n\nDescription\n\nTakes a string value and returns it as a normalized string. If you do not provide a normalization mode, NFC is used.\n\nNormalization is used to ensure that two strings are equivalent. Normalization is often used in situations in which two strings render the same on the screen but have different Unicode code points.\n\nCase folding is used for the caseless comparison of strings. If you need to compare strings and case should not be considered, use NORMALIZE_AND_CASEFOLD, otherwise use NORMALIZE.\n\nNORMALIZE_AND_CASEFOLD supports four optional normalization modes:\n\nValue Name Description NFC Normalization Form Canonical Composition Decomposes and recomposes characters by canonical equivalence. NFKC Normalization Form Compatibility Composition Decomposes characters by compatibility, then recomposes them by canonical equivalence. NFD Normalization Form Canonical Decomposition Decomposes characters by canonical equivalence, and multiple combining characters are arranged in a specific order. NFKD Normalization Form Compatibility Decomposition Decomposes characters by compatibility, and multiple combining characters are arranged in a specific order.\n\nReturn type\n\nSTRING\n\nExamples\n\nSELECT NORMALIZE('The red barn') = NORMALIZE('The Red Barn') AS normalized, NORMALIZE_AND_CASEFOLD('The red barn') = NORMALIZE_AND_CASEFOLD('The Red Barn') AS normalized_with_case_folding; /*------------+------------------------------* | normalized | normalized_with_case_folding | +------------+------------------------------+ | FALSE | TRUE | *------------+------------------------------*/\n\nSELECT '\\u2168' AS a, 'IX' AS b, NORMALIZE_AND_CASEFOLD('\\u2168', NFD)=NORMALIZE_AND_CASEFOLD('IX', NFD) AS nfd, NORMALIZE_AND_CASEFOLD('\\u2168', NFC)=NORMALIZE_AND_CASEFOLD('IX', NFC) AS nfc, NORMALIZE_AND_CASEFOLD('\\u2168', NFKD)=NORMALIZE_AND_CASEFOLD('IX', NFKD) AS nkfd, NORMALIZE_AND_CASEFOLD('\\u2168', NFKC)=NORMALIZE_AND_CASEFOLD('IX', NFKC) AS nkfc; /*---+----+-------+-------+------+------* | a | b | nfd | nfc | nkfd | nkfc | +---+----+-------+-------+------+------+ | Ⅸ | IX | false | false | true | true | *---+----+-------+-------+------+------*/\n\nSELECT '\\u0041\\u030A' AS a, '\\u00C5' AS b, NORMALIZE_AND_CASEFOLD('\\u0041\\u030A', NFD)=NORMALIZE_AND_CASEFOLD('\\u00C5', NFD) AS nfd, NORMALIZE_AND_CASEFOLD('\\u0041\\u030A', NFC)=NORMALIZE_AND_CASEFOLD('\\u00C5', NFC) AS nfc, NORMALIZE_AND_CASEFOLD('\\u0041\\u030A', NFKD)=NORMALIZE_AND_CASEFOLD('\\u00C5', NFKD) AS nkfd, NORMALIZE_AND_CASEFOLD('\\u0041\\u030A', NFKC)=NORMALIZE_AND_CASEFOLD('\\u00C5', NFKC) AS nkfc; /*---+----+-------+-------+------+------* | a | b | nfd | nfc | nkfd | nkfc | +---+----+-------+-------+------+------+ | Å | Å | true | true | true | true | *---+----+-------+-------+------+------*/\n\nOCTET_LENGTH\n\nOCTET_LENGTH(value)\n\nAlias for BYTE_LENGTH.\n\nREGEXP_CONTAINS\n\nREGEXP_CONTAINS(value, regexp)\n\nDescription\n\nReturns TRUE if value is a partial match for the regular expression, regexp.\n\nIf the regexp argument is invalid, the function returns an error.\n\nYou can search for a full match by using ^ (beginning of text) and $ (end of text). Due to regular expression operator precedence, it is good practice to use parentheses around everything between ^ and $.\n\nReturn type\n\nBOOL\n\nExamples\n\nThe following queries check to see if an email is valid:\n\nSELECT 'foo@example.com' AS email, REGEXP_CONTAINS('foo@example.com', r'@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+') AS is_valid /*-----------------+----------* | email | is_valid | +-----------------+----------+ | foo@example.com | TRUE | *-----------------+----------*/ ``` ```sql SELECT 'www.example.net' AS email, REGEXP_CONTAINS('www.example.net', r'@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+') AS is_valid /*-----------------+----------* | email | is_valid | +-----------------+----------+ | www.example.net | FALSE | *-----------------+----------*/ ``` The following queries check to see if an email is valid. They perform a full match, using `^` and `$`. Due to regular expression operator precedence, it is good practice to use parentheses around everything between `^` and `$`. ```sql SELECT 'a@foo.com' AS email, REGEXP_CONTAINS('a@foo.com', r'^([\\w.+-]+@foo\\.com|[\\w.+-]+@bar\\.org)$') AS valid_email_address, REGEXP_CONTAINS('a@foo.com', r'^[\\w.+-]+@foo\\.com|[\\w.+-]+@bar\\.org$') AS without_parentheses; /*----------------+---------------------+---------------------* | email | valid_email_address | without_parentheses | +----------------+---------------------+---------------------+ | a@foo.com | true | true | *----------------+---------------------+---------------------*/\n\nSELECT 'a@foo.computer' AS email, REGEXP_CONTAINS('a@foo.computer', r'^([\\w.+-]+@foo\\.com|[\\w.+-]+@bar\\.org)$') AS valid_email_address, REGEXP_CONTAINS('a@foo.computer', r'^[\\w.+-]+@foo\\.com|[\\w.+-]+@bar\\.org$') AS without_parentheses; /*----------------+---------------------+---------------------* | email | valid_email_address | without_parentheses | +----------------+---------------------+---------------------+ | a@foo.computer | false | true | *----------------+---------------------+---------------------*/\n\nSELECT 'b@bar.org' AS email, REGEXP_CONTAINS('b@bar.org', r'^([\\w.+-]+@foo\\.com|[\\w.+-]+@bar\\.org)$') AS valid_email_address, REGEXP_CONTAINS('b@bar.org', r'^[\\w.+-]+@foo\\.com|[\\w.+-]+@bar\\.org$') AS without_parentheses; /*----------------+---------------------+---------------------* | email | valid_email_address | without_parentheses | +----------------+---------------------+---------------------+ | b@bar.org | true | true | *----------------+---------------------+---------------------*/\n\nSELECT '!b@bar.org' AS email, REGEXP_CONTAINS('!b@bar.org', r'^([\\w.+-]+@foo\\.com|[\\w.+-]+@bar\\.org)$') AS valid_email_address, REGEXP_CONTAINS('!b@bar.org', r'^[\\w.+-]+@foo\\.com|[\\w.+-]+@bar\\.org$') AS without_parentheses; /*----------------+---------------------+---------------------* | email | valid_email_address | without_parentheses | +----------------+---------------------+---------------------+ | !b@bar.org | false | true | *----------------+---------------------+---------------------*/\n\nSELECT 'c@buz.net' AS email, REGEXP_CONTAINS('c@buz.net', r'^([\\w.+-]+@foo\\.com|[\\w.+-]+@bar\\.org)$') AS valid_email_address, REGEXP_CONTAINS('c@buz.net', r'^[\\w.+-]+@foo\\.com|[\\w.+-]+@bar\\.org$') AS without_parentheses; /*----------------+---------------------+---------------------* | email | valid_email_address | without_parentheses | +----------------+---------------------+---------------------+ | c@buz.net | false | false | *----------------+---------------------+---------------------*/\n\nREGEXP_EXTRACT\n\nREGEXP_EXTRACT(value, regexp[, position[, occurrence]])\n\nDescription\n\nReturns the substring in value that matches the re2 regular expression, regexp. Returns NULL if there is no match.\n\nIf the regular expression contains a capturing group ((...)), and there is a match for that capturing group, that match is returned. If there are multiple matches for a capturing group, the first match is returned.\n\nIf position is specified, the search starts at this position in value, otherwise it starts at the beginning of value. The position must be a positive integer and cannot be 0. If position is greater than the length of value, NULL is returned.\n\nIf occurrence is specified, the search returns a specific occurrence of the regexp in value, otherwise returns the first match. If occurrence is greater than the number of matches found, NULL is returned. For occurrence > 1, the function searches for additional occurrences beginning with the character following the previous occurrence.\n\nReturns an error if:\n\nThe regular expression is invalid\n\nThe regular expression has more than one capturing group\n\nThe position is not a positive integer\n\nThe occurrence is not a positive integer\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT REGEXP_EXTRACT('foo@example.com', r'^[a-zA-Z0-9_.+-]+') AS user_name /*-----------* | user_name | +-----------+ | foo | *-----------*/\n\nSELECT REGEXP_EXTRACT('foo@example.com', r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.([a-zA-Z0-9-.]+$)') /*------------------* | top_level_domain | +------------------+ | com | *------------------*/\n\nSELECT REGEXP_EXTRACT('ab', '.b') AS result_a, REGEXP_EXTRACT('ab', '(.)b') AS result_b, REGEXP_EXTRACT('xyztb', '(.)+b') AS result_c, REGEXP_EXTRACT('ab', '(z)?b') AS result_d /*-------------------------------------------* | result_a | result_b | result_c | result_d | +-------------------------------------------+ | ab | a | t | NULL | *-------------------------------------------*/\n\nWITH example AS (SELECT 'Hello Helloo and Hellooo' AS value, 'H?ello+' AS regex, 1 as position, 1 AS occurrence UNION ALL SELECT 'Hello Helloo and Hellooo', 'H?ello+', 1, 2 UNION ALL SELECT 'Hello Helloo and Hellooo', 'H?ello+', 1, 3 UNION ALL SELECT 'Hello Helloo and Hellooo', 'H?ello+', 1, 4 UNION ALL SELECT 'Hello Helloo and Hellooo', 'H?ello+', 2, 1 UNION ALL SELECT 'Hello Helloo and Hellooo', 'H?ello+', 3, 1 UNION ALL SELECT 'Hello Helloo and Hellooo', 'H?ello+', 3, 2 UNION ALL SELECT 'Hello Helloo and Hellooo', 'H?ello+', 3, 3 UNION ALL SELECT 'Hello Helloo and Hellooo', 'H?ello+', 20, 1 UNION ALL SELECT 'cats&dogs&rabbits' ,'\\\\w+&', 1, 2 UNION ALL SELECT 'cats&dogs&rabbits', '\\\\w+&', 2, 3 ) SELECT value, regex, position, occurrence, REGEXP_EXTRACT(value, regex, position, occurrence) AS regexp_value FROM example; /*--------------------------+---------+----------+------------+--------------* | value | regex | position | occurrence | regexp_value | +--------------------------+---------+----------+------------+--------------+ | Hello Helloo and Hellooo | H?ello+ | 1 | 1 | Hello | | Hello Helloo and Hellooo | H?ello+ | 1 | 2 | Helloo | | Hello Helloo and Hellooo | H?ello+ | 1 | 3 | Hellooo | | Hello Helloo and Hellooo | H?ello+ | 1 | 4 | NULL | | Hello Helloo and Hellooo | H?ello+ | 2 | 1 | ello | | Hello Helloo and Hellooo | H?ello+ | 3 | 1 | Helloo | | Hello Helloo and Hellooo | H?ello+ | 3 | 2 | Hellooo | | Hello Helloo and Hellooo | H?ello+ | 3 | 3 | NULL | | Hello Helloo and Hellooo | H?ello+ | 20 | 1 | NULL | | cats&dogs&rabbits | \\w+& | 1 | 2 | dogs& | | cats&dogs&rabbits | \\w+& | 2 | 3 | NULL | *--------------------------+---------+----------+------------+--------------*/\n\nREGEXP_EXTRACT_ALL\n\nREGEXP_EXTRACT_ALL(value, regexp)\n\nDescription\n\nReturns an array of all substrings of value that match the re2 regular expression, regexp. Returns an empty array if there is no match.\n\nIf the regular expression contains a capturing group ((...)), and there is a match for that capturing group, that match is added to the results.\n\nThe REGEXP_EXTRACT_ALL function only returns non-overlapping matches. For example, using this function to extract ana from banana returns only one substring, not two.\n\nReturns an error if:\n\nThe regular expression is invalid\n\nThe regular expression has more than one capturing group\n\nReturn type\n\nARRAY<STRING> or ARRAY<BYTES>\n\nExamples\n\nSELECT REGEXP_EXTRACT_ALL('Try `func(x)` or `func(y)`', '`(.+?)`') AS example /*--------------------* | example | +--------------------+ | [func(x), func(y)] | *--------------------*/\n\nREGEXP_INSTR\n\nREGEXP_INSTR(source_value, regexp [, position[, occurrence, [occurrence_position]]])\n\nDescription\n\nReturns the lowest 1-based position of a regular expression, regexp, in source_value. source_value and regexp must be the same type, either STRING or BYTES.\n\nIf position is specified, the search starts at this position in source_value, otherwise it starts at 1, which is the beginning of source_value. position is of type INT64 and must be positive.\n\nIf occurrence is specified, the search returns the position of a specific instance of regexp in source_value. If not specified, occurrence defaults to 1 and returns the position of the first occurrence. For occurrence > 1, the function searches for the next, non-overlapping occurrence. occurrence is of type INT64 and must be positive.\n\nYou can optionally use occurrence_position to specify where a position in relation to an occurrence starts. Your choices are:\n\n0: Returns the start position of occurrence.\n\n1: Returns the end position of occurrence + 1. If the end of the occurrence is at the end of source_value, LENGTH(source_value) + 1 is returned.\n\nReturns 0 if:\n\nNo match is found.\n\nIf occurrence is greater than the number of matches found.\n\nIf position is greater than the length of source_value.\n\nThe regular expression is empty.\n\nReturns NULL if:\n\nposition is NULL.\n\noccurrence is NULL.\n\nReturns an error if:\n\nposition is 0 or negative.\n\noccurrence is 0 or negative.\n\noccurrence_position is neither 0 nor 1.\n\nThe regular expression is invalid.\n\nThe regular expression has more than one capturing group.\n\nReturn type\n\nINT64\n\nExamples\n\nSELECT REGEXP_INSTR('ab@cd-ef', '@[^-]*') AS instr_a, REGEXP_INSTR('ab@d-ef', '@[^-]*') AS instr_b, REGEXP_INSTR('abc@cd-ef', '@[^-]*') AS instr_c, REGEXP_INSTR('abc-ef', '@[^-]*') AS instr_d, /*---------------------------------------* | instr_a | instr_b | instr_c | instr_d | +---------------------------------------+ | 3 | 3 | 4 | 0 | *---------------------------------------*/\n\nSELECT REGEXP_INSTR('a@cd-ef b@cd-ef', '@[^-]*', 1) AS instr_a, REGEXP_INSTR('a@cd-ef b@cd-ef', '@[^-]*', 2) AS instr_b, REGEXP_INSTR('a@cd-ef b@cd-ef', '@[^-]*', 3) AS instr_c, REGEXP_INSTR('a@cd-ef b@cd-ef', '@[^-]*', 4) AS instr_d, /*---------------------------------------* | instr_a | instr_b | instr_c | instr_d | +---------------------------------------+ | 2 | 2 | 10 | 10 | *---------------------------------------*/\n\nSELECT REGEXP_INSTR('a@cd-ef b@cd-ef c@cd-ef', '@[^-]*', 1, 1) AS instr_a, REGEXP_INSTR('a@cd-ef b@cd-ef c@cd-ef', '@[^-]*', 1, 2) AS instr_b, REGEXP_INSTR('a@cd-ef b@cd-ef c@cd-ef', '@[^-]*', 1, 3) AS instr_c /*-----------------------------* | instr_a | instr_b | instr_c | +-----------------------------+ | 2 | 10 | 18 | *-----------------------------*/\n\nSELECT REGEXP_INSTR('a@cd-ef', '@[^-]*', 1, 1, 0) AS instr_a, REGEXP_INSTR('a@cd-ef', '@[^-]*', 1, 1, 1) AS instr_b /*-------------------* | instr_a | instr_b | +-------------------+ | 2 | 5 | *-------------------*/\n\nREGEXP_REPLACE\n\nREGEXP_REPLACE(value, regexp, replacement)\n\nDescription\n\nReturns a STRING where all substrings of value that match regular expression regexp are replaced with replacement.\n\nYou can use backslashed-escaped digits (\\1 to \\9) within the replacement argument to insert text matching the corresponding parenthesized group in the regexp pattern. Use \\0 to refer to the entire matching text.\n\nTo add a backslash in your regular expression, you must first escape it. For example, SELECT REGEXP_REPLACE('abc', 'b(.)', 'X\\\\1'); returns aXc. You can also use raw strings to remove one layer of escaping, for example SELECT REGEXP_REPLACE('abc', 'b(.)', r'X\\1');.\n\nThe REGEXP_REPLACE function only replaces non-overlapping matches. For example, replacing ana within banana results in only one replacement, not two.\n\nIf the regexp argument is not a valid regular expression, this function returns an error.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT REGEXP_REPLACE('# Heading', r'^# ([a-zA-Z0-9\\s]+$)', '<h1>\\\\1</h1>') AS html /*--------------------------* | html | +--------------------------+ | <h1>Heading</h1> | *--------------------------*/\n\nREGEXP_SUBSTR\n\nREGEXP_SUBSTR(value, regexp[, position[, occurrence]])\n\nDescription\n\nSynonym for REGEXP_EXTRACT.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nWITH example AS (SELECT 'Hello World Helloo' AS value, 'H?ello+' AS regex, 1 AS position, 1 AS occurrence ) SELECT value, regex, position, occurrence, REGEXP_SUBSTR(value, regex, position, occurrence) AS regexp_value FROM example; /*--------------------+---------+----------+------------+--------------* | value | regex | position | occurrence | regexp_value | +--------------------+---------+----------+------------+--------------+ | Hello World Helloo | H?ello+ | 1 | 1 | Hello | *--------------------+---------+----------+------------+--------------*/\n\nREPEAT\n\nREPEAT(original_value, repetitions)\n\nDescription\n\nReturns a STRING or BYTES value that consists of original_value, repeated. The repetitions parameter specifies the number of times to repeat original_value. Returns NULL if either original_value or repetitions are NULL.\n\nThis function returns an error if the repetitions value is negative.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT REPEAT('abc', 3) AS results /*-----------* | results | |-----------| | abcabcabc | *-----------*/\n\nSELECT REPEAT('abc', NULL) AS results /*---------* | results | |---------| | NULL | *---------*/\n\nSELECT REPEAT(NULL, 3) AS results /*---------* | results | |---------| | NULL | *---------*/\n\nREPLACE\n\nREPLACE(original_value, from_pattern, to_pattern)\n\nDescription\n\nReplaces all occurrences of from_pattern with to_pattern in original_value. If from_pattern is empty, no replacement is made.\n\nThis function supports specifying collation.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nWITH desserts AS (SELECT 'apple pie' as dessert UNION ALL SELECT 'blackberry pie' as dessert UNION ALL SELECT 'cherry pie' as dessert) SELECT REPLACE (dessert, 'pie', 'cobbler') as example FROM desserts; /*--------------------* | example | +--------------------+ | apple cobbler | | blackberry cobbler | | cherry cobbler | *--------------------*/\n\nREVERSE\n\nREVERSE(value)\n\nDescription\n\nReturns the reverse of the input STRING or BYTES.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT REVERSE('abc') AS results /*---------* | results | +---------+ | cba | *---------*/\n\nSELECT FORMAT('%T', REVERSE(b'1a3')) AS results /*---------* | results | +---------+ | b\"3a1\" | *---------*/\n\nRIGHT\n\nRIGHT(value, length)\n\nDescription\n\nReturns a STRING or BYTES value that consists of the specified number of rightmost characters or bytes from value. The length is an INT64 that specifies the length of the returned value. If value is BYTES, length is the number of rightmost bytes to return. If value is STRING, length is the number of rightmost characters to return.\n\nIf length is 0, an empty STRING or BYTES value will be returned. If length is negative, an error will be returned. If length exceeds the number of characters or bytes from value, the original value will be returned.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT 'apple' AS example, RIGHT('apple', 3) AS right_example /*---------+---------------* | example | right_example | +---------+---------------+ | apple | ple | *---------+---------------*/\n\nSELECT b'apple' AS example, RIGHT(b'apple', 3) AS right_example -- Note that the result of RIGHT is of type BYTES, displayed as a base64-encoded string. /*----------+---------------* | example | right_example | +----------+---------------+ | YXBwbGU= | cGxl | *----------+---------------*/\n\nRPAD\n\nRPAD(original_value, return_length[, pattern])\n\nDescription\n\nReturns a STRING or BYTES value that consists of original_value appended with pattern. The return_length parameter is an INT64 that specifies the length of the returned value. If original_value is BYTES, return_length is the number of bytes. If original_value is STRING, return_length is the number of characters.\n\nThe default value of pattern is a blank space.\n\nBoth original_value and pattern must be the same data type.\n\nIf return_length is less than or equal to the original_value length, this function returns the original_value value, truncated to the value of return_length. For example, RPAD('hello world', 7); returns 'hello w'.\n\nIf original_value, return_length, or pattern is NULL, this function returns NULL.\n\nThis function returns an error if:\n\nreturn_length is negative\n\npattern is empty\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT FORMAT('%T', RPAD('c', 5)) AS results /*---------* | results | +---------+ | \"c \" | *---------*/\n\nSELECT RPAD('b', 5, 'a') AS results /*---------* | results | +---------+ | baaaa | *---------*/\n\nSELECT RPAD('abc', 10, 'ghd') AS results /*------------* | results | +------------+ | abcghdghdg | *------------*/\n\nSELECT RPAD('abc', 2, 'd') AS results /*---------* | results | +---------+ | ab | *---------*/\n\nSELECT FORMAT('%T', RPAD(b'abc', 10, b'ghd')) AS results /*---------------* | results | +---------------+ | b\"abcghdghdg\" | *---------------*/\n\nRTRIM\n\nRTRIM(value1[, value2])\n\nDescription\n\nIdentical to TRIM, but only removes trailing characters.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT RTRIM('***apple***', '*') AS example /*-----------* | example | +-----------+ | ***apple | *-----------*/\n\nSELECT RTRIM('applexxz', 'xyz') AS example /*---------* | example | +---------+ | apple | *---------*/\n\nSAFE_CONVERT_BYTES_TO_STRING\n\nSAFE_CONVERT_BYTES_TO_STRING(value)\n\nDescription\n\nConverts a sequence of BYTES to a STRING. Any invalid UTF-8 characters are replaced with the Unicode replacement character, U+FFFD.\n\nReturn type\n\nSTRING\n\nExamples\n\nThe following statement returns the Unicode replacement character, �.\n\nSELECT SAFE_CONVERT_BYTES_TO_STRING(b'\\xc2') as safe_convert;\n\nSOUNDEX\n\nSOUNDEX(value)\n\nDescription\n\nReturns a STRING that represents the Soundex code for value.\n\nSOUNDEX produces a phonetic representation of a string. It indexes words by sound, as pronounced in English. It is typically used to help determine whether two strings, such as the family names Levine and Lavine, or the words to and too, have similar English-language pronunciation.\n\nThe result of the SOUNDEX consists of a letter followed by 3 digits. Non-latin characters are ignored. If the remaining string is empty after removing non-Latin characters, an empty STRING is returned.\n\nReturn type\n\nSTRING\n\nExamples\n\nSELECT 'Ashcraft' AS value, SOUNDEX('Ashcraft') AS soundex /*----------------------+---------* | value | soundex | +----------------------+---------+ | Ashcraft | A261 | *----------------------+---------*/\n\nSPLIT\n\nSPLIT(value[, delimiter])\n\nDescription\n\nSplits value using the delimiter argument.\n\nFor STRING, the default delimiter is the comma ,.\n\nFor BYTES, you must specify a delimiter.\n\nSplitting on an empty delimiter produces an array of UTF-8 characters for STRING values, and an array of BYTES for BYTES values.\n\nSplitting an empty STRING returns an ARRAY with a single empty STRING.\n\nThis function supports specifying collation.\n\nReturn type\n\nARRAY<STRING> or ARRAY<BYTES>\n\nExamples\n\nWITH letters AS (SELECT '' as letter_group UNION ALL SELECT 'a' as letter_group UNION ALL SELECT 'b c d' as letter_group) SELECT SPLIT(letter_group, ' ') as example FROM letters; /*----------------------* | example | +----------------------+ | [] | | [a] | | [b, c, d] | *----------------------*/\n\nSTARTS_WITH\n\nSTARTS_WITH(value, prefix)\n\nDescription\n\nTakes two STRING or BYTES values. Returns TRUE if prefix is a prefix of value.\n\nThis function supports specifying collation.\n\nReturn type\n\nBOOL\n\nExamples\n\nSELECT STARTS_WITH('bar', 'b') AS example /*---------* | example | +---------+ | True | *---------*/\n\nSTRPOS\n\nSTRPOS(value, subvalue)\n\nDescription\n\nTakes two STRING or BYTES values. Returns the 1-based position of the first occurrence of subvalue inside value. Returns 0 if subvalue is not found.\n\nThis function supports specifying collation.\n\nReturn type\n\nINT64\n\nExamples\n\nSELECT STRPOS('foo@example.com', '@') AS example /*---------* | example | +---------+ | 4 | *---------*/\n\nSUBSTR\n\nSUBSTR(value, position[, length])\n\nDescription\n\nGets a portion (substring) of the supplied STRING or BYTES value.\n\nThe position argument is an integer specifying the starting position of the substring.\n\nIf position is 1, the substring starts from the first character or byte.\n\nIf position is 0 or less than -LENGTH(value), position is set to 1, and the substring starts from the first character or byte.\n\nIf position is greater than the length of value, the function produces an empty substring.\n\nIf position is negative, the function counts from the end of value, with -1 indicating the last character or byte.\n\nThe length argument specifies the maximum number of characters or bytes to return.\n\nIf length is not specified, the function produces a substring that starts at the specified position and ends at the last character or byte of value.\n\nIf length is 0, the function produces an empty substring.\n\nIf length is negative, the function produces an error.\n\nThe returned substring may be shorter than length, for example, when length exceeds the length of value, or when the starting position of the substring plus length is greater than the length of value.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT SUBSTR('apple', 2) AS example /*---------* | example | +---------+ | pple | *---------*/\n\nSELECT SUBSTR('apple', 2, 2) AS example /*---------* | example | +---------+ | pp | *---------*/\n\nSELECT SUBSTR('apple', -2) AS example /*---------* | example | +---------+ | le | *---------*/\n\nSELECT SUBSTR('apple', 1, 123) AS example /*---------* | example | +---------+ | apple | *---------*/\n\nSELECT SUBSTR('apple', 123) AS example /*---------* | example | +---------+ | | *---------*/\n\nSELECT SUBSTR('apple', 123, 5) AS example /*---------* | example | +---------+ | | *---------*/\n\nSUBSTRING\n\nSUBSTRING(value, position[, length])\n\nAlias for SUBSTR.\n\nTO_BASE32\n\nTO_BASE32(bytes_expr)\n\nDescription\n\nConverts a sequence of BYTES into a base32-encoded STRING. To convert a base32-encoded STRING into BYTES, use FROM_BASE32.\n\nReturn type\n\nSTRING\n\nExample\n\nSELECT TO_BASE32(b'abcde\\xFF') AS base32_string; /*------------------* | base32_string | +------------------+ | MFRGGZDF74====== | *------------------*/\n\nTO_BASE64\n\nTO_BASE64(bytes_expr)\n\nDescription\n\nConverts a sequence of BYTES into a base64-encoded STRING. To convert a base64-encoded STRING into BYTES, use FROM_BASE64.\n\nThere are several base64 encodings in common use that vary in exactly which alphabet of 65 ASCII characters are used to encode the 64 digits and padding. See RFC 4648 for details. This function adds padding and uses the alphabet [A-Za-z0-9+/=].\n\nReturn type\n\nSTRING\n\nExample\n\nSELECT TO_BASE64(b'\\377\\340') AS base64_string; /*---------------* | base64_string | +---------------+ | /+A= | *---------------*/\n\nTo work with an encoding using a different base64 alphabet, you might need to compose TO_BASE64 with the REPLACE function. For instance, the base64url url-safe and filename-safe encoding commonly used in web programming uses -_= as the last characters rather than +/=. To encode a base64url-encoded string, replace + and / with - and _ respectively.\n\nSELECT REPLACE(REPLACE(TO_BASE64(b'\\377\\340'), '+', '-'), '/', '_') as websafe_base64; /*----------------* | websafe_base64 | +----------------+ | _-A= | *----------------*/\n\nTO_CODE_POINTS\n\nTO_CODE_POINTS(value)\n\nDescription\n\nTakes a STRING or BYTES value and returns an array of INT64 values that represent code points or extended ASCII character values.\n\nIf value is a STRING, each element in the returned array represents a code point. Each code point falls within the range of [0, 0xD7FF] and [0xE000, 0x10FFFF].\n\nIf value is BYTES, each element in the array is an extended ASCII character value in the range of [0, 255].\n\nTo convert from an array of code points to a STRING or BYTES, see CODE_POINTS_TO_STRING or CODE_POINTS_TO_BYTES.\n\nReturn type\n\nARRAY<INT64>\n\nExamples\n\nThe following examples get the code points for each element in an array of words.\n\nSELECT 'foo' AS word, TO_CODE_POINTS('foo') AS code_points /*---------+------------------------------------* | word | code_points | +---------+------------------------------------+ | foo | [102, 111, 111] | *---------+------------------------------------*/\n\nSELECT 'bar' AS word, TO_CODE_POINTS('bar') AS code_points /*---------+------------------------------------* | word | code_points | +---------+------------------------------------+ | bar | [98, 97, 114] | *---------+------------------------------------*/\n\nSELECT 'baz' AS word, TO_CODE_POINTS('baz') AS code_points /*---------+------------------------------------* | word | code_points | +---------+------------------------------------+ | baz | [98, 97, 122] | *---------+------------------------------------*/\n\nSELECT 'giraffe' AS word, TO_CODE_POINTS('giraffe') AS code_points /*---------+------------------------------------* | word | code_points | +---------+------------------------------------+ | giraffe | [103, 105, 114, 97, 102, 102, 101] | *---------+------------------------------------*/\n\nSELECT 'llama' AS word, TO_CODE_POINTS('llama') AS code_points /*---------+------------------------------------* | word | code_points | +---------+------------------------------------+ | llama | [108, 108, 97, 109, 97] | *---------+------------------------------------*/\n\nThe following examples convert integer representations of BYTES to their corresponding ASCII character values.\n\nSELECT b'\\x66\\x6f\\x6f' AS bytes_value, TO_CODE_POINTS(b'\\x66\\x6f\\x6f') AS bytes_value_as_integer /*------------------+------------------------* | bytes_value | bytes_value_as_integer | +------------------+------------------------+ | foo | [102, 111, 111] | *------------------+------------------------*/\n\nSELECT b'\\x00\\x01\\x10\\xff' AS bytes_value, TO_CODE_POINTS(b'\\x00\\x01\\x10\\xff') AS bytes_value_as_integer /*------------------+------------------------* | bytes_value | bytes_value_as_integer | +------------------+------------------------+ | \\x00\\x01\\x10\\xff | [0, 1, 16, 255] | *------------------+------------------------*/\n\nThe following example demonstrates the difference between a BYTES result and a STRING result. Notice that the character Ā is represented as a two-byte Unicode sequence. As a result, the BYTES version of TO_CODE_POINTS returns an array with two elements, while the STRING version returns an array with a single element.\n\nSELECT TO_CODE_POINTS(b'Ā') AS b_result, TO_CODE_POINTS('Ā') AS s_result; /*------------+----------* | b_result | s_result | +------------+----------+ | [196, 128] | [256] | *------------+----------*/\n\nTO_HEX\n\nTO_HEX(bytes)\n\nDescription\n\nConverts a sequence of BYTES into a hexadecimal STRING. Converts each byte in the STRING as two hexadecimal characters in the range (0..9, a..f). To convert a hexadecimal-encoded STRING to BYTES, use FROM_HEX.\n\nReturn type\n\nSTRING\n\nExample\n\nSELECT b'\\x00\\x01\\x02\\x03\\xAA\\xEE\\xEF\\xFF' AS byte_string, TO_HEX(b'\\x00\\x01\\x02\\x03\\xAA\\xEE\\xEF\\xFF') AS hex_string /*----------------------------------+------------------* | byte_string | hex_string | +----------------------------------+------------------+ | \\x00\\x01\\x02\\x03\\xaa\\xee\\xef\\xff | 00010203aaeeefff | *----------------------------------+------------------*/\n\nTRANSLATE\n\nTRANSLATE(expression, source_characters, target_characters)\n\nDescription\n\nIn expression, replaces each character in source_characters with the corresponding character in target_characters. All inputs must be the same type, either STRING or BYTES.\n\nEach character in expression is translated at most once.\n\nA character in expression that is not present in source_characters is left unchanged in expression.\n\nA character in source_characters without a corresponding character in target_characters is omitted from the result.\n\nA duplicate character in source_characters results in an error.\n\nReturn type\n\nSTRING or BYTES\n\nExamples\n\nSELECT TRANSLATE('This is a cookie', 'sco', 'zku') AS translate /*------------------* | translate | +------------------+ | Thiz iz a kuukie | *------------------*/\n\nTRIM\n\nTRIM(value_to_trim[, set_of_characters_to_remove])\n\nDescription\n\nTakes a STRING or BYTES value to trim.\n\nIf the value to trim is a STRING, removes from this value all leading and trailing Unicode code points in set_of_characters_to_remove. The set of code points is optional. If it is not specified, all whitespace characters are removed from the beginning and end of the value to trim.\n\nIf the value to trim is BYTES, removes from this value all leading and trailing bytes in set_of_characters_to_remove. The set of bytes is required.\n\nReturn type\n\nSTRING if value_to_trim is a STRING value.\n\nBYTES if value_to_trim is a BYTES value.\n\nExamples\n\nIn the following example, all leading and trailing whitespace characters are removed from item because set_of_characters_to_remove is not specified.\n\nSELECT CONCAT('#', TRIM( ' apple '), '#') AS example /*----------* | example | +----------+ | #apple# | *----------*/\n\nIn the following example, all leading and trailing * characters are removed from 'apple'.\n\nSELECT TRIM('***apple***', '*') AS example /*---------* | example | +---------+ | apple | *---------*/\n\nIn the following example, all leading and trailing x, y, and z characters are removed from 'xzxapplexxy'.\n\nSELECT TRIM('xzxapplexxy', 'xyz') as example /*---------* | example | +---------+ | apple | *---------*/\n\nIn the following example, examine how TRIM interprets characters as Unicode code-points. If your trailing character set contains a combining diacritic mark over a particular letter, TRIM might strip the same diacritic mark from a different letter.\n\nSELECT TRIM('abaW̊', 'Y̊') AS a, TRIM('W̊aba', 'Y̊') AS b, TRIM('abaŪ̊', 'Y̊') AS c, TRIM('Ū̊aba', 'Y̊') AS d /*------+------+------+------* | a | b | c | d | +------+------+------+------+ | abaW | W̊aba | abaŪ | Ūaba | *------+------+------+------*/\n\nIn the following example, all leading and trailing b'n', b'a', b'\\xab' bytes are removed from item.\n\nSELECT b'apple', TRIM(b'apple', b'na\\xab') AS example -- Note that the result of TRIM is of type BYTES, displayed as a base64-encoded string. /*----------------------+------------------* | item | example | +----------------------+------------------+ | YXBwbGU= | cHBsZQ== | *----------------------+------------------*/\n\nUNICODE\n\nUNICODE(value)\n\nDescription\n\nReturns the Unicode code point for the first character in value. Returns 0 if value is empty, or if the resulting Unicode code point is 0.\n\nReturn type\n\nINT64\n\nExamples\n\nSELECT UNICODE('âbcd') as A, UNICODE('â') as B, UNICODE('') as C, UNICODE(NULL) as D; /*-------+-------+-------+-------* | A | B | C | D | +-------+-------+-------+-------+ | 226 | 226 | 0 | NULL | *-------+-------+-------+-------*/\n\nUPPER\n\nUPPER(value)\n\nDescription\n\nFor STRING arguments, returns the original string with all alphabetic characters in uppercase. Mapping between uppercase and lowercase is done according to the Unicode Character Database without taking into account language-specific mappings.\n\nFor BYTES arguments, the argument is treated as ASCII text, with all bytes greater than 127 left intact.\n\nReturn type\n\nSTRING or BYTES\n\nExamples"
    }
}