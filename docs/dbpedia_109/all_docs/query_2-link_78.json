{
    "id": "dbpedia_109_2",
    "rank": 78,
    "data": {
        "url": "https://tldp.org/LDP/abs/html/special-chars.html",
        "read_more_link": "",
        "language": "en",
        "title": "Special Characters",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://tldp.org/LDP/abs/images/caution.gif",
            "https://tldp.org/LDP/abs/images/note.gif",
            "https://tldp.org/LDP/abs/images/note.gif",
            "https://tldp.org/LDP/abs/images/important.gif",
            "https://tldp.org/LDP/abs/images/caution.gif",
            "https://tldp.org/LDP/abs/images/note.gif",
            "https://tldp.org/LDP/abs/images/note.gif",
            "https://tldp.org/LDP/abs/images/note.gif",
            "https://tldp.org/LDP/abs/images/note.gif",
            "https://tldp.org/LDP/abs/images/caution.gif",
            "https://tldp.org/LDP/abs/images/tip.gif",
            "https://tldp.org/LDP/abs/images/caution.gif",
            "https://tldp.org/LDP/abs/images/caution.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "#\n\nComments. Lines beginning with a # (with the exception of #!) are comments and will not be executed.\n\nComments may also occur following the end of a command.\n\nComments may also follow whitespace at the beginning of a line.\n\n# A tab precedes this comment.\n\nComments may even be embedded within a pipe.\n\nOf course, a quoted or an escaped # in an echo statement does not begin a comment. Likewise, a # appears in certain parameter-substitution constructs and in numerical constant expressions.\n\nquoting and escape characters (\" ' \\) escape the #.\n\nCertain pattern matching operations also use the #.\n\n;\n\nCommand separator [semicolon]. Permits putting two or more commands on the same line.\n\nNote that the \";\" sometimes needs to be escaped.\n\n;;\n\nTerminator in a case option [double semicolon].\n\ncase \"$variable\" in abc) echo \"\\$variable = abc\" ;; xyz) echo \"\\$variable = xyz\" ;; esac\n\n;;&, ;&\n\nTerminators in a case option (version 4+ of Bash).\n\n.\n\n\"dot\" command [period]. Equivalent to source (see Example 15-22). This is a bash builtin.\n\n.\n\n\"dot\", as a component of a filename. When working with filenames, a leading dot is the prefix of a \"hidden\" file, a file that an ls will not normally show.\n\nWhen considering directory names, a single dot represents the current working directory, and two dots denote the parent directory.\n\nThe dot often appears as the destination (directory) of a file movement command, in this context meaning current directory.\n\nbash$ cp /home/bozo/current_work/junk/* .\n\nCopy all the \"junk\" files to $PWD.\n\n.\n\n\"dot\" character match. When matching characters, as part of a regular expression, a \"dot\" matches a single character.\n\n\"\n\npartial quoting [double quote]. \"STRING\" preserves (from interpretation) most of the special characters within STRING. See Chapter 5.\n\n'\n\nfull quoting [single quote]. 'STRING' preserves all special characters within STRING. This is a stronger form of quoting than \"STRING\". See Chapter 5.\n\n,\n\ncomma operator. The comma operator links together a series of arithmetic operations. All are evaluated, but only the last one is returned.\n\nThe comma operator can also concatenate strings.\n\n,, ,\n\nLowercase conversion in parameter substitution (added in version 4 of Bash).\n\n\\\n\nescape [backslash]. A quoting mechanism for single characters.\n\n\\X escapes the character X. This has the effect of \"quoting\" X, equivalent to 'X'. The \\ may be used to quote \" and ', so they are expressed literally.\n\nSee Chapter 5 for an in-depth explanation of escaped characters.\n\n/\n\nFilename path separator [forward slash]. Separates the components of a filename (as in /home/bozo/projects/Makefile).\n\nThis is also the division arithmetic operator.\n\n`\n\ncommand substitution. The `command` construct makes available the output of command for assignment to a variable. This is also known as backquotes or backticks.\n\n:\n\nnull command [colon]. This is the shell equivalent of a \"NOP\" (no op, a do-nothing operation). It may be considered a synonym for the shell builtin true. The \":\" command is itself a Bash builtin, and its exit status is true (0).\n\n: echo $? # 0\n\nEndless loop:\n\nPlaceholder in if/then test:\n\nProvide a placeholder where a binary operation is expected, see Example 8-2 and default parameters.\n\nProvide a placeholder where a command is expected in a here document. See Example 19-10.\n\nEvaluate string of variables using parameter substitution (as in Example 10-7).\n\nVariable expansion / substring replacement.\n\nIn combination with the > redirection operator, truncates a file to zero length, without changing its permissions. If the file did not previously exist, creates it.\n\nExample 16-15.\n\nIn combination with the >> redirection operator, has no effect on a pre-existing target file (: >> target_file). If the file did not previously exist, creates it.\n\nMay be used to begin a comment line, although this is not recommended. Using # for a comment turns off error checking for the remainder of that line, so almost anything may appear in a comment. However, this is not the case with :.\n\nThe \":\" serves as a field separator, in /etc/passwd, and in the $PATH variable.\n\nbash$ echo $PATH /usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games\n\nA colon is acceptable as a function name.\n\nportable behavior, and therefore not a recommended practice. In fact, more recent releases of Bash do not permit this usage. An underscore _ works, though.\n\nA colon can serve as a placeholder in an otherwise empty function.\n\n!\n\nreverse (or negate) the sense of a test or exit status [bang]. The ! operator inverts the exit status of the command to which it is applied (see Example 6-2). It also inverts the meaning of a test operator. This can, for example, change the sense of equal ( = ) to not-equal ( != ). The ! operator is a Bash keyword.\n\nIn a different context, the ! also appears in indirect variable references.\n\nIn yet another context, from the command line, the ! invokes the Bash history mechanism (see Appendix L). Note that within a script, the history mechanism is disabled.\n\n*\n\nwild card [asterisk]. The * character serves as a \"wild card\" for filename expansion in globbing. By itself, it matches every filename in a given directory.\n\nbash$ echo * abs-book.sgml add-drive.sh agram.sh alias.sh\n\nThe * also represents any number (or zero) characters in a regular expression.\n\n*\n\narithmetic operator. In the context of arithmetic operations, the * denotes multiplication.\n\n** A double asterisk can represent the exponentiation operator or extended file-match globbing.\n\n?\n\ntest operator. Within certain expressions, the ? indicates a test for a condition.\n\nIn a double-parentheses construct, the ? can serve as an element of a C-style trinary operator.\n\ncondition?result-if-true:result-if-false\n\nIn a parameter substitution expression, the ? tests whether a variable has been set.\n\n?\n\nwild card. The ? character serves as a single-character \"wild card\" for filename expansion in globbing, as well as representing one character in an extended regular expression.\n\n$\n\nVariable substitution (contents of a variable).\n\nvar1=5 var2=23skidoo echo $var1 # 5 echo $var2 # 23skidoo\n\nA $ prefixing a variable name indicates the value the variable holds.\n\n$\n\nend-of-line. In a regular expression, a \"$\" addresses the end of a line of text.\n\n${}\n\nParameter substitution.\n\n$' ... '\n\nQuoted string expansion. This construct expands single or multiple escaped octal or hex values into ASCII or Unicode characters.\n\n$*, $@\n\npositional parameters.\n\n$?\n\nexit status variable. The $? variable holds the exit status of a command, a function, or of the script itself.\n\n$$\n\nprocess ID variable. The $$ variable holds the process ID of the script in which it appears.\n\n()\n\ncommand group.\n\narray initialization.\n\nArray=(element1 element2 element3)\n\n{xxx,yyy,zzz,...}\n\nBrace expansion.\n\nA command may act upon a comma-separated list of file specs within braces. Filename expansion (globbing) applies to the file specs between the braces.\n\n{a..z}\n\nExtended Brace expansion.\n\nThe {a..z} extended brace expansion construction is a feature introduced in version 3 of Bash.\n\n{}\n\nBlock of code [curly brackets]. Also referred to as an inline group, this construct, in effect, creates an anonymous function (a function without a name). However, unlike in a \"standard\" function, the variables inside a code block remain visible to the remainder of the script.\n\nThe code block enclosed in braces may have I/O redirected to and from it.\n\nExample 3-1. Code blocks and I/O redirection\n\nExample 3-2. Saving the output of a code block to a file\n\n{}\n\nplaceholder for text. Used after xargs -i (replace strings option). The {} double curly brackets are a placeholder for output text.\n\n{} \\;\n\npathname. Mostly used in find constructs. This is not a shell builtin.\n\n[ ]\n\ntest.\n\nTest expression between [ ]. Note that [ is part of the shell builtin test (and a synonym for it), not a link to the external command /usr/bin/test.\n\n[[ ]]\n\ntest.\n\nTest expression between [[ ]]. More flexible than the single-bracket [ ] test, this is a shell keyword.\n\nSee the discussion on the [[ ... ]] construct.\n\n[ ]\n\narray element.\n\nIn the context of an array, brackets set off the numbering of each element of that array.\n\n[ ]\n\nrange of characters.\n\nAs part of a regular expression, brackets delineate a range of characters to match.\n\n$[ ... ]\n\ninteger expansion.\n\nEvaluate integer expression between $[ ].\n\nNote that this usage is deprecated, and has been replaced by the (( ... )) construct.\n\n(( ))\n\ninteger expansion.\n\nExpand and evaluate integer expression between (( )).\n\nSee the discussion on the (( ... )) construct.\n\n> &> >& >> < <>\n\nredirection.\n\nscriptname >filename redirects the output of scriptname to file filename. Overwrite filename if it already exists.\n\ncommand &>filename redirects both the stdout and the stderr of command to filename.\n\ncommand >&2 redirects stdout of command to stderr.\n\nscriptname >>filename appends the output of scriptname to file filename. If filename does not already exist, it is created.\n\n[i]<>filename opens file filename for reading and writing, and assigns file descriptor i to it. If filename does not exist, it is created.\n\nprocess substitution.\n\n(command)>\n\n<(command)\n\nIn a different context, the \"<\" and \">\" characters act as string comparison operators.\n\nIn yet another context, the \"<\" and \">\" characters act as integer comparison operators. See also Example 16-9.\n\n<<\n\nredirection used in a here document.\n\n<<<\n\nredirection used in a here string.\n\n<, >\n\nASCII comparison.\n\n\\<, \\>\n\nword boundary in a regular expression.\n\nbash$ grep '\\<the\\>' textfile\n\n|\n\npipe. Passes the output (stdout) of a previous command to the input (stdin) of the next one, or to the shell. This is a method of chaining commands together.\n\nThe output of a command or commands may be piped to a script.\n\nls -l to this script.\n\n>|\n\nforce redirection (even if the noclobber option is set). This will forcibly overwrite an existing file.\n\n||\n\nOR logical operator. In a test construct, the || operator causes a return of 0 (success) if either of the linked test conditions is true.\n\n&\n\nRun job in background. A command followed by an & will run in the background.\n\nWithin a script, commands and even loops may run in the background.\n\nExample 3-3. Running a loop in the background\n\n&&\n\nAND logical operator. In a test construct, the && operator causes a return of 0 (success) only if both the linked test conditions are true.\n\n-\n\noption, prefix. Option flag for a command or filter. Prefix for an operator. Prefix for a default parameter in parameter substitution.\n\nCOMMAND -[Option1][Option2][...]\n\nls -al\n\nsort -dfu $filename\n\n--\n\nThe double-dash -- prefixes long (verbatim) options to commands.\n\nsort --ignore-leading-blanks\n\nUsed with a Bash builtin, it means the end of options to that particular command.\n\nThe double-dash is also used in conjunction with set.\n\nset -- $variable (as in Example 15-18)\n\n-\n\nredirection from/to stdin or stdout [dash].\n\nbash$ cat - abc abc ... Ctl-D\n\nAs expected, cat - echoes stdin, in this case keyboarded user input, to stdout. But, does I/O redirection using - have real-world applications?\n\nNote that in this context the \"-\" is not itself a Bash operator, but rather an option recognized by certain UNIX utilities that write to stdout, such as tar, cat, etc.\n\nbash$ echo \"whatever\" | cat - whatever\n\nWhere a filename is expected, - redirects output to stdout (sometimes seen with tar cf), or accepts input from stdin, rather than from a file. This is a method of using a file-oriented utility as a filter in a pipe.\n\nbash$ file Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...\n\nBy itself on the command-line, file fails with an error message.\n\nAdd a \"-\" for a more useful result. This causes the shell to await user input.\n\nbash$ file - abc standard input: ASCII text bash$ file - #!/bin/bash standard input: Bourne-Again shell script text executable\n\nNow the command accepts input from stdin and analyzes it.\n\nThe \"-\" can be used to pipe stdout to other commands. This permits such stunts as prepending lines to a file.\n\nUsing diff to compare a file with a section of another:\n\ngrep Linux file1 | diff file2 -\n\nFinally, a real-world example using - with tar.\n\nExample 3-4. Backup of all files changed in last day\n\n-\n\nprevious working directory. A cd - command changes to the previous working directory. This uses the $OLDPWD environmental variable.\n\n-\n\nMinus. Minus sign in an arithmetic operation.\n\n=\n\nEquals. Assignment operator\n\na=28 echo $a # 28\n\nIn a different context, the \"=\" is a string comparison operator.\n\n+\n\nPlus. Addition arithmetic operator.\n\nIn a different context, the + is a Regular Expression operator.\n\n+\n\nOption. Option flag for a command or filter.\n\nCertain commands and builtins use the + to enable certain options and the - to disable them. In parameter substitution, the + prefixes an alternate value that a variable expands to.\n\n%\n\nmodulo. Modulo (remainder of a division) arithmetic operation.\n\nIn a different context, the % is a pattern matching operator.\n\n~\n\nhome directory [tilde]. This corresponds to the $HOME internal variable. ~bozo is bozo's home directory, and ls ~bozo lists the contents of it. ~/ is the current user's home directory, and ls ~/ lists the contents of it.\n\n~+\n\ncurrent working directory. This corresponds to the $PWD internal variable.\n\n~-\n\nprevious working directory. This corresponds to the $OLDPWD internal variable.\n\n=~\n\nregular expression match. This operator was introduced with version 3 of Bash.\n\n^\n\nbeginning-of-line. In a regular expression, a \"^\" addresses the beginning of a line of text.\n\n^, ^^\n\nUppercase conversion in parameter substitution (added in version 4 of Bash).\n\nControl Characters\n\nchange the behavior of the terminal or text display. A control character is a CONTROL + key combination (pressed simultaneously). A control character may also be written in octal or hexadecimal notation, following an escape.\n\nControl characters are not normally useful inside a script.\n\nCtl-A\n\nMoves cursor to beginning of line of text (on the command-line).\n\nCtl-B\n\nBackspace (nondestructive).\n\nCtl-C\n\nBreak. Terminate a foreground job.\n\nCtl-D\n\nLog out from a shell (similar to exit).\n\nEOF (end-of-file). This also terminates input from stdin.\n\nWhen typing text on the console or in an xterm window, Ctl-D erases the character under the cursor. When there are no characters present, Ctl-D logs out of the session, as expected. In an xterm window, this has the effect of closing the window.\n\nCtl-E\n\nMoves cursor to end of line of text (on the command-line).\n\nCtl-F\n\nMoves cursor forward one character position (on the command-line).\n\nCtl-G\n\nBEL. On some old-time teletype terminals, this would actually ring a bell. In an xterm it might beep.\n\nCtl-H\n\nRubout (destructive backspace). Erases characters the cursor backs over while backspacing.\n\nCtl-I\n\nHorizontal tab.\n\nCtl-J\n\nNewline (line feed). In a script, may also be expressed in octal notation -- '\\012' or in hexadecimal -- '\\x0a'.\n\nCtl-K\n\nVertical tab.\n\nWhen typing text on the console or in an xterm window, Ctl-K erases from the character under the cursor to end of line. Within a script, Ctl-K may behave differently, as in Lee Lee Maschmeyer's example, below.\n\nCtl-L\n\nFormfeed (clear the terminal screen). In a terminal, this has the same effect as the clear command. When sent to a printer, a Ctl-L causes an advance to end of the paper sheet.\n\nCtl-M\n\nCarriage return.\n\nCtl-N\n\nErases a line of text recalled from history buffer (on the command-line).\n\nCtl-O\n\nIssues a newline (on the command-line).\n\nCtl-P\n\nRecalls last command from history buffer (on the command-line).\n\nCtl-Q\n\nResume (XON).\n\nThis resumes stdin in a terminal.\n\nCtl-R\n\nBackwards search for text in history buffer (on the command-line).\n\nCtl-S\n\nSuspend (XOFF).\n\nThis freezes stdin in a terminal. (Use Ctl-Q to restore input.)\n\nCtl-T\n\nReverses the position of the character the cursor is on with the previous character (on the command-line).\n\nCtl-U\n\nErase a line of input, from the cursor backward to beginning of line. In some settings, Ctl-U erases the entire line of input, regardless of cursor position.\n\nCtl-V\n\nWhen inputting text, Ctl-V permits inserting control characters. For example, the following two are equivalent:\n\necho -e '\\x0a' echo <Ctl-V><Ctl-J>\n\nCtl-V is primarily useful from within a text editor.\n\nCtl-W\n\nWhen typing text on the console or in an xterm window, Ctl-W erases from the character under the cursor backwards to the first instance of whitespace. In some settings, Ctl-W erases backwards to first non-alphanumeric character.\n\nCtl-X\n\nIn certain word processing programs, Cuts highlighted text and copies to clipboard.\n\nCtl-Y\n\nPastes back text previously erased (with Ctl-U or Ctl-W).\n\nCtl-Z\n\nPauses a foreground job.\n\nSubstitute operation in certain word processing applications.\n\nEOF (end-of-file) character in the MSDOS filesystem.\n\nWhitespace\n\nfunctions as a separator between commands and/or variables. Whitespace consists of either spaces, tabs, blank lines, or any combination thereof. In some contexts, such as variable assignment, whitespace is not permitted, and results in a syntax error.\n\nBlank lines have no effect on the action of a script, and are therefore useful for visually separating functional sections.\n\n$IFS, the special variable separating fields of input to certain commands. It defaults to whitespace.\n\nTo preserve whitespace within a string or in a variable, use quoting.\n\nUNIX filters can target and operate on whitespace using the POSIX character class [:space:]."
    }
}