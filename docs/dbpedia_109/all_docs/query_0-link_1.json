{
    "id": "dbpedia_109_0",
    "rank": 1,
    "data": {
        "url": "https://en.wikipedia.org/wiki/Base64",
        "read_more_link": "",
        "language": "en",
        "title": "Wikipedia",
        "top_image": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "meta_img": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/35_mm_angle_of_view_vs_focal_length.svg/220px-35_mm_angle_of_view_vs_focal_length.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2003-04-24T03:02:20+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/Base64",
        "text": "Group of binary-to-text encoding schemes using 64 symbols (plus padding)\n\nIn computer programming, Base64 is a group of binary-to-text encoding schemes that transforms binary data into a sequence of printable characters, limited to a set of 64 unique characters. More specifically, the source binary data is taken 6 bits at a time, then this group of 6 bits is mapped to one of 64 unique characters.\n\nAs with all binary-to-text encoding schemes, Base64 is designed to carry data stored in binary formats across channels that only reliably support text content. Base64 is particularly prevalent on the World Wide Web[1] where one of its uses is the ability to embed image files or other binary assets inside textual assets such as HTML and CSS files.[2]\n\nBase64 is also widely used for sending e-mail attachments, because SMTP – in its original form – was designed to transport 7-bit ASCII characters only. Encoding an attachment as Base64 before sending, and then decoding when received, assures older SMTP servers will not interfere with the attachment.\n\nBase64 encoding causes an overhead of 33–37% relative to the size of the original binary data (33% by the encoding itself; up to 4% more by the inserted line breaks).\n\nThe particular set of 64 characters chosen to represent the 64-digit values for the base varies between implementations. The general strategy is to choose 64 characters that are common to most encodings and that are also printable. This combination leaves the data unlikely to be modified in transit through information systems, such as email, that were traditionally not 8-bit clean.[3] For example, MIME's Base64 implementation uses A–Z, a–z, and 0–9 for the first 62 values. Other variations share this property but differ in the symbols chosen for the last two values; an example is UTF-7.\n\nThe earliest instances of this type of encoding were created for dial-up communication between systems running the same OS – for example, uuencode for UNIX and BinHex for the TRS-80 (later adapted for the Macintosh) – and could therefore make more assumptions about what characters were safe to use. For instance, uuencode uses uppercase letters, digits, and many punctuation characters, but no lowercase.[4][5][6][3]\n\nThis is the Base64 alphabet defined in RFC 4648 §4 . See also § Variants summary table.\n\nBase64 alphabet defined in RFC 4648. Index Binary Char. Index Binary Char. Index Binary Char. Index Binary Char. 0 000000 A 16 010000 Q 32 100000 g 48 110000 w 1 000001 B 17 010001 R 33 100001 h 49 110001 x 2 000010 C 18 010010 S 34 100010 i 50 110010 y 3 000011 D 19 010011 T 35 100011 j 51 110011 z 4 000100 E 20 010100 U 36 100100 k 52 110100 0 5 000101 F 21 010101 V 37 100101 l 53 110101 1 6 000110 G 22 010110 W 38 100110 m 54 110110 2 7 000111 H 23 010111 X 39 100111 n 55 110111 3 8 001000 I 24 011000 Y 40 101000 o 56 111000 4 9 001001 J 25 011001 Z 41 101001 p 57 111001 5 10 001010 K 26 011010 a 42 101010 q 58 111010 6 11 001011 L 27 011011 b 43 101011 r 59 111011 7 12 001100 M 28 011100 c 44 101100 s 60 111100 8 13 001101 N 29 011101 d 45 101101 t 61 111101 9 14 001110 O 30 011110 e 46 101110 u 62 111110 + 15 001111 P 31 011111 f 47 101111 v 63 111111 / Padding =\n\nThe example below uses ASCII text for simplicity, but this is not a typical use case, as it can already be safely transferred across all systems that can handle Base64. The more typical use is to encode binary data (such as an image); the resulting Base64 data will only contain 64 different ASCII characters, all of which can reliably be transferred across systems that may corrupt the raw source bytes.\n\nHere is a well-known idiom from distributed computing:\n\nMany hands make light work.\n\nWhen the quote (without trailing whitespace) is encoded into Base64, it is represented as a byte sequence of 8-bit-padded ASCII characters encoded in MIME's Base64 scheme as follows (newlines and white spaces may be present anywhere but are to be ignored on decoding):\n\nTWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcmsu\n\nIn the above quote, the encoded value of Man is TWFu. Encoded in ASCII, the characters M, a, and n are stored as the byte values 77, 97, and 110, which are the 8-bit binary values 01001101, 01100001, and 01101110. These three values are joined together into a 24-bit string, producing 010011010110000101101110. Groups of 6 bits (6 bits have a maximum of 26 = 64 different binary values) are converted into individual numbers from start to end (in this case, there are four numbers in a 24-bit string), which are then converted into their corresponding Base64 character values.\n\nAs this example illustrates, Base64 encoding converts three octets into four encoded characters.\n\nEncoding of the source string ⟨Man⟩ in Base64 Source\n\nASCII text Character M a n Octets 77 (0x4d) 97 (0x61) 110 (0x6e) Bits 0 1 0 0 1 1 0 1 0 1 1 0 0 0 0 1 0 1 1 0 1 1 1 0 Base64\n\nencoded Sextets 19 22 5 46 Character T W F u Octets 84 (0x54) 87 (0x57) 70 (0x46) 117 (0x75)\n\n= padding characters might be added to make the last encoded block contain four Base64 characters.\n\nHexadecimal to octal transformation is useful to convert between binary and Base64. Such conversion is available for both advanced calculators and programming languages. For example, the hexadecimal representation of the 24 bits above is 4D616E. The octal representation is 23260556. Those 8 octal digits can be split into pairs (23 26 05 56), and each pair is converted to decimal to yield 19 22 05 46. Using those four decimal numbers as indices for the Base64 alphabet, the corresponding ASCII characters are TWFu.\n\nIf there are only two significant input octets (e.g., 'Ma'), or when the last input group contains only two octets, all 16 bits will be captured in the first three Base64 digits (18 bits); the two least significant bits of the last content-bearing 6-bit block will turn out to be zero, and discarded on decoding (along with the succeeding = padding character):\n\nSource\n\nASCII text Character M a Octets 77 (0x4d) 97 (0x61) Bits 0 1 0 0 1 1 0 1 0 1 1 0 0 0 0 1 0 0 Base64\n\nencoded Sextets 19 22 4 Padding Character T W E = Octets 84 (0x54) 87 (0x57) 69 (0x45) 61 (0x3D)\n\nIf there is only one significant input octet (e.g., 'M'), or when the last input group contains only one octet, all 8 bits will be captured in the first two Base64 digits (12 bits); the four least significant bits of the last content-bearing 6-bit block will turn out to be zero, and discarded on decoding (along with the succeeding two = padding characters):\n\nSource\n\nASCII text Character M Octets 77 (0x4d) Bits 0 1 0 0 1 1 0 1 0 0 0 0 Base64\n\nencoded Sextets 19 16 Padding Padding Character T Q = = Octets 84 (0x54) 81 (0x51) 61 (0x3D) 61 (0x3D)\n\nThere are also interactive tools for visualizing the encoding step by step from plain text to base64.[7]\n\nBecause Base64 is a six-bit encoding, and because the decoded values are divided into 8-bit octets, every four characters of Base64-encoded text (4 sextets = 4 × 6 = 24 bits) represents three octets of unencoded text or data (3 octets = 3 × 8 = 24 bits). This means that when the length of the unencoded input is not a multiple of three, the encoded output must have padding added so that its length is a multiple of four. The padding character is =, which indicates that no further bits are needed to fully encode the input. (This is different from A, which means that the remaining bits are all zeros.) The example below illustrates how truncating the input of the above quote changes the output padding:\n\nInput Output Padding Text Length Text Length light work. 11 bGlnaHQgd29yay4= 16 1 light work 10 bGlnaHQgd29yaw== 16 2 light wor 9 bGlnaHQgd29y 12 0 light wo 8 bGlnaHQgd28= 12 1 light w 7 bGlnaHQgdw== 12 2\n\nThe padding character is not essential for decoding, since the number of missing bytes can be inferred from the length of the encoded text. In some implementations, the padding character is mandatory, while for others it is not used. An exception in which padding characters are required is when multiple Base64 encoded files have been concatenated.\n\nWhen decoding Base64 text, four characters are typically converted back to three bytes. The only exceptions are when padding characters exist. A single = indicates that the four characters will decode to only two bytes, while == indicates that the four characters will decode to only a single byte. For example:\n\nEncoded Padding Length Decoded bGlnaHQgdw== == 1 light w bGlnaHQgd28= = 2 light wo bGlnaHQgd29y None 3 light wor\n\nAnother way to interpret the padding character is to consider it as an instruction to discard 2 trailing bits from the bit string each time a = is encountered. For example, when ` bGlnaHQgdw==` is decoded, we convert each character (except the trailing occurrences of =) into their corresponding 6-bit representation, and then discard 2 trailing bits for the first = and another 2 trailing bits for the other =. In this instance, we would get 6 bits from the d, and another 6 bits from the w for a bit string of length 12, but since we remove 2 bits for each = (for a total of 4 bits), the dw== ends up producing 8 bits (1 byte) when decoded.\n\nWithout padding, after normal decoding of four characters to three bytes over and over again, fewer than four encoded characters may remain. In this situation, only two or three characters can remain. A single remaining encoded character is not possible, because a single Base64 character only contains 6 bits, and 8 bits are required to create a byte, so a minimum of two Base64 characters are required: The first character contributes 6 bits, and the second character contributes its first 2 bits. For example:\n\nLength Encoded Length Decoded 2 bGlnaHQgdw 1 light w 3 bGlnaHQgd28 2 light wo 4 bGlnaHQgd29y 3 light wor\n\nDecoding without padding is not performed consistently among decoders. In addition, allowing padless decoding by definition allows multiple strings to decode into the same set of bytes, which can be a security risk.[8]\n\nImplementations may have some constraints on the alphabet used for representing some bit patterns. This notably concerns the last two characters used in the alphabet at positions 62 and 63, and the character used for padding (which may be mandatory in some protocols or removed in others). The table below summarizes these known variants and provides links to the subsections below.\n\nEncoding Encoding characters Separate encoding of lines Decoding non-encoding characters 62nd 63rd pad Separators Length Checksum RFC 1421: Base64 for Privacy-Enhanced Mail (deprecated) + / = mandatory CR+LF 64, or lower for the last line No No RFC 2045: Base64 transfer encoding for MIME + / = mandatory CR+LF At most 76 No Discarded RFC 2152: Base64 for UTF-7 + / No No No RFC 3501: Base64 encoding for IMAP mailbox names + , No No No RFC 4648 §4: base64 (standard)[a] + / = optional No No RFC 4648 §5: base64url (URL- and filename-safe standard)[a] - _ = optional No No RFC 4880: Radix-64 for OpenPGP + / = mandatory CR+LF At most 76 Radix-64 encoded 24-bit CRC No Other variations See § Applications not compatible with RFC 4648 Base64\n\nThe first known standardized use of the encoding now called MIME Base64 was in the Privacy-enhanced Electronic Mail (PEM) protocol, proposed by RFC 989 in 1987. PEM defines a \"printable encoding\" scheme that uses Base64 encoding to transform an arbitrary sequence of octets to a format that can be expressed in short lines of 6-bit characters, as required by transfer protocols such as SMTP.[9]\n\nThe current version of PEM (specified in RFC 1421) uses a 64-character alphabet consisting of upper- and lower-case Roman letters (A–Z, a–z), the numerals (0–9), and the + and / symbols. The = symbol is also used as a padding suffix.[4] The original specification, RFC 989, additionally used the * symbol to delimit encoded but unencrypted data within the output stream.\n\nTo convert data to PEM printable encoding, the first byte is placed in the most significant eight bits of a 24-bit buffer, the next in the middle eight, and the third in the least significant eight bits. If there are fewer than three bytes left to encode (or in total), the remaining buffer bits will be zero. The buffer is then used, six bits at a time, most significant first, as indices into the string: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", and the indicated character is output.\n\nThe process is repeated on the remaining data until fewer than four octets remain. If three octets remain, they are processed normally. If fewer than three octets (24 bits) are remaining to encode, the input data is right-padded with zero bits to form an integral multiple of six bits.\n\nAfter encoding the non-padded data, if two octets of the 24-bit buffer are padded-zeros, two = characters are appended to the output; if one octet of the 24-bit buffer is filled with padded-zeros, one = character is appended. This signals the decoder that the zero bits added due to padding should be excluded from the reconstructed data. This also guarantees that the encoded output length is a multiple of 4 bytes.\n\nPEM requires that all encoded lines consist of exactly 64 printable characters, with the exception of the last line, which may contain fewer printable characters. Lines are delimited by whitespace characters according to local (platform-specific) conventions.\n\nMain article: MIME\n\nThe MIME (Multipurpose Internet Mail Extensions) specification lists Base64 as one of two binary-to-text encoding schemes (the other being quoted-printable).[5] MIME's Base64 encoding is based on that of the RFC 1421 version of PEM: it uses the same 64-character alphabet and encoding mechanism as PEM and uses the = symbol for output padding in the same way, as described at RFC 2045.\n\nMIME does not specify a fixed length for Base64-encoded lines, but it does specify a maximum line length of 76 characters. Additionally, it specifies that any character outside the standard set of 64 encoding characters (For example CRLF sequences), must be ignored by a compliant decoder, although most implementations use a CR/LF newline pair to delimit encoded lines.\n\nThus, the actual length of MIME-compliant Base64-encoded binary data is usually about 137% of the original data length (4⁄3×78⁄76), though for very short messages the overhead can be much higher due to the overhead of the headers. Very roughly, the final size of Base64-encoded binary data is equal to 1.37 times the original data size + 814 bytes (for headers). The size of the decoded data can be approximated with this formula:\n\nbytes = (string_length(encoded_string) − 814) / 1.37\n\nMain article: UTF-7\n\nUTF-7, described first in RFC 1642, which was later superseded by RFC 2152, introduced a system called modified Base64. This data encoding scheme is used to encode UTF-16 as ASCII characters for use in 7-bit transports such as SMTP. It is a variant of the Base64 encoding used in MIME.[10][11]\n\nThe \"Modified Base64\" alphabet consists of the MIME Base64 alphabet, but does not use the \"=\" padding character. UTF-7 is intended for use in mail headers (defined in RFC 2047), and the \"=\" character is reserved in that context as the escape character for \"quoted-printable\" encoding. Modified Base64 simply omits the padding and ends immediately after the last Base64 digit containing useful bits leaving up to three unused bits in the last Base64 digit.\n\nFurther information: Pretty Good Privacy § OpenPGP\n\nOpenPGP, described in RFC 4880, describes Radix-64 encoding, also known as \"ASCII armor\". Radix-64 is identical to the \"Base64\" encoding described by MIME, with the addition of an optional 24-bit CRC. The checksum is calculated on the input data before encoding; the checksum is then encoded with the same Base64 algorithm and, prefixed by the \"=\" symbol as the separator, appended to the encoded output data.[12]\n\nRFC 3548, entitled The Base16, Base32, and Base64 Data Encodings, is an informational (non-normative) memo that attempts to unify the RFC 1421 and RFC 2045 specifications of Base64 encodings, alternative-alphabet encodings, and the Base32 (which is seldom used) and Base16 encodings.\n\nUnless implementations are written to a specification that refers to RFC 3548 and specifically requires otherwise, RFC 3548 forbids implementations from generating messages containing characters outside the encoding alphabet or without padding, and it also declares that decoder implementations must reject data that contain characters outside the encoding alphabet.[6]\n\nRFC 4648 obsoletes RFC 3548 and focuses on Base64/32/16:\n\nThis document describes the commonly used Base64, Base32, and Base16 encoding schemes. It also discusses the use of line feeds in encoded data, the use of padding in encoded data, the use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings.\n\nBase64 encoding can be helpful when fairly lengthy identifying information is used in an HTTP environment. For example, a database persistence framework for Java objects might use Base64 encoding to encode a relatively large unique id (generally 128-bit UUIDs) into a string for use as an HTTP parameter in HTTP forms or HTTP GET URLs. Also, many applications need to encode binary data in a way that is convenient for inclusion in URLs, including in hidden web form fields, and Base64 is a convenient encoding to render them in a compact way.\n\nUsing standard Base64 in URL requires encoding of '+', '/' and '=' characters into special percent-encoded hexadecimal sequences ('+' becomes '%2B', '/' becomes '%2F' and '=' becomes '%3D'), which makes the string unnecessarily longer.\n\nFor this reason, modified Base64 for URL variants exist (such as base64url in RFC 4648), where the '+' and '/' characters of standard Base64 are respectively replaced by '-' and '_', so that using URL encoders/decoders is no longer necessary and has no effect on the length of the encoded value, leaving the same encoded form intact for use in relational databases, web forms, and object identifiers in general. A popular site to make use of such is YouTube.[13] Some variants allow or require omitting the padding '=' signs to avoid them being confused with field separators, or require that any such padding be percent-encoded. Some libraries [which?] will encode '=' to '.', potentially exposing applications to relative path attacks when a folder name is encoded from user data.[citation needed]\n\nThe atob() and btoa() JavaScript methods, defined in the HTML5 draft specification,[14] provide Base64 encoding and decoding functionality to web pages. The btoa() method outputs padding characters, but these are optional in the input of the atob() method.\n\nBase64 can be used in a variety of contexts:\n\nBase64 can be used to transmit and store text that might otherwise cause delimiter collision\n\nBase64 is used to encode character strings in LDAP Data Interchange Format files\n\nBase64 is often used to embed binary data in an XML file, using a syntax similar to <data encoding=\"base64\">…</data> e.g. favicons in Firefox's exported bookmarks.html.\n\nBase64 is used to encode binary files such as images within scripts, to avoid depending on external files.\n\nBase64 can be used to embed PDF files in HTML pages.[16]\n\nThe data URI scheme can use Base64 to represent file contents. For instance, background images and fonts can be specified in a CSS stylesheet file as data: URIs, instead of being supplied in separate files.\n\nAlthough not part of the official specification for the SVG format, some viewers can interpret Base64 when used for embedded elements, such as raster images inside SVG files.[17]\n\nBase64 can be used to store/transmit relatively small amounts of binary data via a computer's text clipboard functionality, especially in cases where the information doesn't warrant being permanently saved or when information must be quickly sent between a wide variety of different, potentially incompatible programs. An example is the representation of the public keys of cryptocurrency recipients as Base64 encoded text strings, which can be easily copied and pasted into users' wallet software.\n\nBinary data that must be quickly verified by humans as a safety mechanism, such as file checksums or key fingerprints, is often represented in Base64 for easy checking, sometimes with additional formattings, such as separating each group of four characters in the representation of a PGP key fingerprint with a space.\n\nQR codes which contain binary data will sometimes store it encoded in Base64 rather than simply storing the raw binary data, as there is a stronger guarantee that all QR code readers will accurately decode text, as well as the fact that some devices will more readily save text from a QR code than potentially malicious binary data.\n\nSome applications use a Base64 alphabet that is significantly different from the alphabets used in the most common Base64 variants (see Variants summary table above).\n\nThe Uuencoding alphabet includes no lowercase characters, instead using ASCII codes 32 (\" \" (space)) through 95 (\"_\"), consecutively. Uuencoding uses the alphabet \" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\". Avoiding all lower-case letters was helpful, because many older printers only printed uppercase. Using consecutive ASCII characters saved computing power, because it was only necessary to add 32, without requiring a lookup table. Its use of most punctuation characters and the space character may limit its usefulness in some applications, such as those that use these characters as syntax.[citation needed]\n\nBinHex 4 (HQX), which was used within the classic Mac OS, excludes some visually confusable characters like '7', 'O', 'g' and 'o'. Its alphabet includes additional punctuation characters. It uses the alphabet \"!\"#$%&'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr\".\n\nA UTF-8 environment can use non-synchronized continuation bytes as base64: 0b10xxxxxx. See UTF-8#Self-synchronization.\n\nSeveral other applications use alphabets similar to the common variations, but in a different order:\n\nUnix stores password hashes computed with crypt in the /etc/passwd file using an encoding called B64. crypt's alphabet puts the punctuation . and / before the alphanumeric characters. crypt uses the alphabet \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\". Padding is not used.\n\nThe GEDCOM 5.5 standard for genealogical data interchange encodes multimedia files in its text-line hierarchical file format. GEDCOM uses the same alphabet as crypt, which is \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".[18]\n\nbcrypt hashes are designed to be used in the same way as traditional crypt(3) hashes, but bcrypt's alphabet is in a different order than crypt's. bcrypt uses the alphabet \"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\".[19]\n\nXxencoding uses a mostly-alphanumeric character set similar to crypt, but using + and - rather than . and /. Xxencoding uses the alphabet \"+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".\n\n6PACK, used with some terminal node controllers, uses an alphabet from 0x00 to 0x3f.[20]\n\nBash supports numeric literals in Base64. Bash uses the alphabet \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@_\".[21]\n\nOne issue with the RFC 4648 alphabet is that, when a sorted list of ASCII-encoded strings is Base64-transformed and sorted again, the order of elements changes. This is because the padding character and the characters in the substitution alphabet are not ordered by ASCII character value (which can be seen by using the following sample table's sort buttons). Alphabets like (unpadded) B64 address this.\n\nASCII Base64 Base64, no padding B64 light w bGlnaHQgdw== bGlnaHQgdw P4ZbO5EURk light wo bGlnaHQgd28= bGlnaHQgd28 P4ZbO5EURqw light wor bGlnaHQgd29y bGlnaHQgd29y P4ZbO5EURqxm"
    }
}