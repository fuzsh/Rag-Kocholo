{
    "id": "dbpedia_2923_3",
    "rank": 71,
    "data": {
        "url": "https://www.apicur.io/registry/docs/apicurio-registry/2.5.x/getting-started/assembly-intro-to-the-registry.html",
        "read_more_link": "",
        "language": "en",
        "title": "Introduction to Apicurio Registry :: Apicurio Registry",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.apicur.io/images/apicurio_headerlogo.png",
            "https://www.apicur.io/registry/docs/apicurio-registry/2.5.x/assets-images/images/getting-started/registry-web-console.png",
            "https://www.apicur.io/registry/docs/apicurio-registry/2.5.x/assets-images/images/getting-started/registry-serdes-architecture.png",
            "https://www.apicur.io/registry/docs/apicurio-registry/2.5.x/assets-images/images/getting-started/registry-connect-architecture.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://www.apicur.io/images/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://www.apicur.io/registry/docs/apicurio-registry/2.6.x/getting-started/assembly-intro-to-the-registry.html",
        "text": "Apicurio Registry is a datastore for sharing standard event schemas and API designs across event-driven and API architectures. You can use Apicurio Registry to decouple the structure of your data from your client applications, and to share and manage your data types and API descriptions at runtime using a REST interface.\n\nClient applications can dynamically push or pull the latest schema updates to or from Apicurio Registry at runtime without needing to redeploy. Developer teams can query Apicurio Registry for existing schemas required for services already deployed in production, and can register new schemas required for new services in development.\n\nYou can enable client applications to use schemas and API designs stored in Apicurio Registry by specifying the Apicurio Registry URL in your client application code. Apicurio Registry can store schemas used to serialize and deserialize messages, which are referenced from your client applications to ensure that the messages that they send and receive are compatible with those schemas.\n\nUsing Apicurio Registry to decouple your data structure from your applications reduces costs by decreasing overall message size, and creates efficiencies by increasing consistent reuse of schemas and API designs across your organization. Apicurio Registry provides a web console to make it easy for developers and administrators to manage registry content.\n\nYou can configure optional rules to govern the evolution of your Apicurio Registry content. These include rules to ensure that uploaded content is valid, or is compatible with other versions. Any configured rules must pass before new versions can be uploaded to Apicurio Registry, which ensures that time is not wasted on invalid or incompatible schemas or API designs.\n\nApicurio Registry capabilities\n\nMultiple payload formats for standard event schema and API specifications such as Apache Avro, JSON Schema, Google Protobuf, AsyncAPI, OpenAPI, and more.\n\nPluggable Apicurio Registry storage options in Apache Kafka or PostgreSQL database.\n\nRules for content validation, compatibility, and integrity to govern how Apicurio Registry content evolves over time.\n\nApicurio Registry content management using web console, REST API, command line, Maven plug-in, or Java client.\n\nFull Apache Kafka schema registry support, including integration with Kafka Connect for external systems.\n\nKafka client serializers/deserializers (SerDes) to validate message types at runtime.\n\nCompatibility with existing Confluent schema registry client applications.\n\nCloud-native Quarkus Java runtime for low memory footprint and fast deployment times.\n\nOperator-based installation of Apicurio Registry on OpenShift.\n\nOpenID Connect (OIDC) authentication using Keycloak.\n\nThe items stored in Apicurio Registry, such as event schemas and API designs, are known as registry artifacts. The following shows an example of an Apache Avro schema artifact in JSON format for a simple share price application:\n\nExample Avro schema\n\n{ \"type\": \"record\", \"name\": \"price\", \"namespace\": \"com.example\", \"fields\": [ { \"name\": \"symbol\", \"type\": \"string\" }, { \"name\": \"price\", \"type\": \"string\" } ] }\n\nWhen a schema or API design is added as an artifact in Apicurio Registry, client applications can then use that schema or API design to validate that the client messages conform to the correct data structure at runtime.\n\nGroups of schemas and APIs\n\nAn artifact group is an optional named collection of schema or API artifacts. Each group contains a logically related set of schemas or API designs, typically managed by a single entity, belonging to a particular application or organization.\n\nYou can create optional artifact groups when adding your schemas and API designs to organize them in Apicurio Registry. For example, you could create groups to match your development and production application environments, or your sales and engineering organizations.\n\nSchema and API groups can contain multiple artifact types. For example, you could have Protobuf, Avro, JSON Schema, OpenAPI, or AsyncAPI artifacts all in the same group.\n\nYou can create schema and API artifacts and groups using the Apicurio Registry web console, REST API, command line, Maven plug-in, or Java client application. The following simple example shows using the Core Registry REST API:\n\n$ curl -X POST -H \"Content-type: application/json; artifactType=AVRO\" \\ -H \"X-Registry-ArtifactId: share-price\" \\ --data '{\"type\":\"record\",\"name\":\"price\",\"namespace\":\"com.example\", \\ \"fields\":[{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"string\"}]}' \\ https://my-registry.example.com/apis/registry/v2/groups/my-group/artifacts\n\nThis example creates an artifact group named my-group and adds an Avro schema with an artifact ID of share-price.\n\nSpecifying a group is optional when using the Apicurio Registry web console, and a default group is created automatically. When using the REST API or Maven plug-in, specify the default group in the API path if you do not want to create a unique group.\n\nAdditional resources\n\nFor information on supported artifact types, see Apicurio Registry artifact reference.\n\nFor information on the Core Registry API, see the Apicurio Registry REST API documentation.\n\nReferences to other schemas and APIs\n\nSome Apicurio Registry artifact types can include artifact references from one artifact file to another. You can create efficiencies by defining reusable schema or API components, and then referencing them from multiple locations. For example, you can specify a reference in JSON Schema or OpenAPI using a $ref statement, or in Google Protobuf using an import statement, or in Apache Avro using a nested namespace.\n\nThe following example shows a simple Avro schema named TradeKey that includes a reference to another schema named Exchange using a nested namespace:\n\nTradekey schema with nested Exchange schema\n\n{ \"namespace\": \"com.kubetrade.schema.trade\", \"type\": \"record\", \"name\": \"TradeKey\", \"fields\": [ { \"name\": \"exchange\", \"type\": \"com.kubetrade.schema.common.Exchange\" }, { \"name\": \"key\", \"type\": \"string\" } ] }\n\nExchange schema\n\n{ \"namespace\": \"com.kubetrade.schema.common\", \"type\": \"enum\", \"name\": \"Exchange\", \"symbols\" : [\"GEMINI\"] }\n\nAn artifact reference is stored in Apicurio Registry as a collection of artifact metadata that maps from an artifact type-specific reference to an internal Apicurio Registry reference. Each artifact reference in Apicurio Registry is composed of the following:\n\nGroup ID\n\nArtifact ID\n\nArtifact version\n\nArtifact reference name\n\nYou can manage artifact references using the Apicurio Registry core REST API, Maven plug-in, and Java serializers/deserializers (SerDes). Apicurio Registry stores the artifact references along with the artifact content. Apicurio Registry also maintains a collection of all artifact references so you can search them or list all references for a specific artifact.\n\nSupported artifact types\n\nApicurio Registry currently supports artifact references for the following artifact types only:\n\nAvro\n\nProtobuf\n\nJSON Schema\n\nOpenAPI\n\nAsyncAPI\n\nYou can use Apicurio Registry with Apache Kafka Connect to stream data between Kafka and external systems. Using Kafka Connect, you can define connectors for different systems to move large volumes of data into and out of Kafka-based systems.\n\nFigure 3. Apicurio Registry and Kafka Connect architecture\n\nApicurio Registry provides the following features for Kafka Connect:\n\nStorage for Kafka Connect schemas\n\nKafka Connect converters for Apache Avro and JSON Schema\n\nCore Registry API to manage schemas\n\nYou can use the Avro and JSON Schema converters to map Kafka Connect schemas into Avro or JSON schemas. These schemas can then serialize message keys and values into the compact Avro binary format or human-readable JSON format. The converted JSON is less verbose because the messages do not contain the schema information, only the schema ID.\n\nApicurio Registry can manage and track the Avro and JSON schemas used in the Kafka topics. Because the schemas are stored in Apicurio Registry and decoupled from the message content, each message must only include a tiny schema identifier. For an I/O bound system like Kafka, this means more total throughput for producers and consumers.\n\nThe Avro and JSON Schema serializers and deserializers (SerDes) provided by Apicurio Registry are used by Kafka producers and consumers in this use case. Kafka consumer applications that you write to consume change events can use the Avro or JSON SerDes to deserialize these events. You can install the Apicurio Registry SerDes in any Kafka-based system and use them along with Kafka Connect, or with a Kafka Connect-based system such as Debezium."
    }
}