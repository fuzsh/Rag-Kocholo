{
    "id": "dbpedia_2923_3",
    "rank": 76,
    "data": {
        "url": "https://kea.readthedocs.io/en/kea-2.2.0/arm/dhcp4-srv.html",
        "read_more_link": "",
        "language": "en",
        "title": "8. The DHCPv4 Server — Kea 2.2.0 documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://kea.readthedocs.io/en/kea-2.2.0/_static/kea-imageonly-100bw.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "8.2. DHCPv4 Server Configuration\n\n8.2.1. Introduction\n\nThis section explains how to configure the Kea DHCPv4 server using a configuration file.\n\nBefore DHCPv4 is started, its configuration file must be created. The basic configuration is as follows:\n\n{ # DHCPv4 configuration starts on the next line \"Dhcp4\": { # First we set up global values \"valid-lifetime\": 4000, \"renew-timer\": 1000, \"rebind-timer\": 2000, # Next we set up the interfaces to be used by the server. \"interfaces-config\": { \"interfaces\": [ \"eth0\" ] }, # And we specify the type of lease database \"lease-database\": { \"type\": \"memfile\", \"persist\": true, \"name\": \"/var/lib/kea/dhcp4.leases\" }, # Finally, we list the subnets from which we will be leasing addresses. \"subnet4\": [ { \"subnet\": \"192.0.2.0/24\", \"pools\": [ { \"pool\": \"192.0.2.1 - 192.0.2.200\" } ] } ] # DHCPv4 configuration ends with the next line } }\n\nThe following paragraphs provide a brief overview of the parameters in the above example, along with their format. Subsequent sections of this chapter go into much greater detail for these and other parameters.\n\nThe lines starting with a hash (#) are comments and are ignored by the server; they do not impact its operation in any way.\n\nThe configuration starts in the first line with the initial opening curly bracket (or brace). Each configuration must contain an object specifying the configuration of the Kea module using it. In the example above, this object is called Dhcp4.\n\nThe Dhcp4 configuration starts with the \"Dhcp4\": { line and ends with the corresponding closing brace (in the above example, the brace after the last comment). Everything defined between those lines is considered to be the Dhcp4 configuration.\n\nIn general, the order in which those parameters appear does not matter, but there are two caveats. The first one is that the configuration file must be well-formed JSON, meaning that the parameters for any given scope must be separated by a comma, and there must not be a comma after the last parameter. When reordering a configuration file, moving a parameter to or from the last position in a given scope may also require moving the comma. The second caveat is that it is uncommon — although legal JSON — to repeat the same parameter multiple times. If that happens, the last occurrence of a given parameter in a given scope is used, while all previous instances are ignored. This is unlikely to cause any confusion as there are no real-life reasons to keep multiple copies of the same parameter in the configuration file.\n\nThe first few DHCPv4 configuration elements define some global parameters. valid-lifetime defines how long the addresses (leases) given out by the server are valid; the default is for a client to be allowed to use a given address for 4000 seconds. (Note that integer numbers are specified as is, without any quotes around them.) renew-timer and rebind-timer are values (also in seconds) that define the T1 and T2 timers that govern when the client begins the renewal and rebind processes.\n\nNote\n\nThe lease valid lifetime is expressed as a triplet with minimum, default, and maximum values using configuration entries min-valid-lifetime, valid-lifetime, and max-valid-lifetime. Since Kea 1.9.5, these values may be specified in client classes. The procedure the server uses to select which lifetime value to use is as follows:\n\nIf the client query is a BOOTP query, the server always uses the infinite lease time (e.g. 0xffffffff). Otherwise, the server must determine which configured triplet to use by first searching all classes assigned to the query, and then the subnet selected for the query.\n\nClasses are searched in the order they were assigned to the query; the server uses the triplet from the first class that specifies it. If no classes specify the triplet, the server uses the triplet specified by the subnet selected for the client. If the subnet does not explicitly specify it, the server next looks at the subnet’s shared-network (if one exists), then for a global specification, and finally the global default.\n\nIf the client requested a lifetime value via DHCP option 51, then the lifetime value used is the requested value bounded by the configured triplet. In other words, if the requested lifetime is less than the configured minimum, the configured minimum is used; if it is more than the configured maximum, the configured maximum is used. If the client did not provide a requested value, the lifetime value used is the triplet default value.\n\nNote\n\nBoth renew-timer and rebind-timer are optional. The server only sends rebind-timer to the client, via DHCPv4 option code 59, if it is less than valid-lifetime; and it only sends renew-timer, via DHCPv4 option code 58, if it is less than rebind-timer (or valid-lifetime if rebind-timer was not specified). In their absence, the client should select values for T1 and T2 timers according to RFC 2131. See section Sending T1 (Option 58) and T2 (Option 59) for more details on generating T1 and T2.\n\nThe interfaces-config map specifies the network interfaces on which the server should listen to DHCP messages. The interfaces parameter specifies a list of network interfaces on which the server should listen. Lists are opened and closed with square brackets, with elements separated by commas. To listen on two interfaces, the interfaces-config element should look like this:\n\n\"interfaces-config\": { \"interfaces\": [ \"eth0\", \"eth1\" ] },\n\nThe next lines define the lease database, the place where the server stores its lease information. This particular example tells the server to use memfile, which is the simplest and fastest database backend. It uses an in-memory database and stores leases on disk in a CSV (comma-separated values) file. This is a very simple configuration example; usually the lease database configuration is more extensive and contains additional parameters. Note that lease-database is an object and opens up a new scope, using an opening brace. Its parameters (just one in this example: type) follow. If there were more than one, they would be separated by commas. This scope is closed with a closing brace. As more parameters for the Dhcp4 definition follow, a trailing comma is present.\n\nFinally, we need to define a list of IPv4 subnets. This is the most important DHCPv4 configuration structure, as the server uses that information to process clients’ requests. It defines all subnets from which the server is expected to receive DHCP requests. The subnets are specified with the subnet4 parameter. It is a list, so it starts and ends with square brackets. Each subnet definition in the list has several attributes associated with it, so it is a structure and is opened and closed with braces. At a minimum, a subnet definition must have at least two parameters: subnet, which defines the whole subnet; and pools, which is a list of dynamically allocated pools that are governed by the DHCP server.\n\nThe example contains a single subnet. If more than one were defined, additional elements in the subnet4 parameter would be specified and separated by commas. For example, to define three subnets, the following syntax would be used:\n\n\"subnet4\": [ { \"pools\": [ { \"pool\": \"192.0.2.1 - 192.0.2.200\" } ], \"subnet\": \"192.0.2.0/24\" }, { \"pools\": [ { \"pool\": \"192.0.3.100 - 192.0.3.200\" } ], \"subnet\": \"192.0.3.0/24\" }, { \"pools\": [ { \"pool\": \"192.0.4.1 - 192.0.4.254\" } ], \"subnet\": \"192.0.4.0/24\" } ]\n\nNote that indentation is optional and is used for aesthetic purposes only. In some cases it may be preferable to use more compact notation.\n\nAfter all the parameters have been specified, there are two contexts open: global and Dhcp4; thus, two closing curly brackets must be used to close them.\n\n8.2.2. Lease Storage\n\nAll leases issued by the server are stored in the lease database. There are three database backends available: memfile (the default), MySQL, PostgreSQL.\n\n8.2.2.1. Memfile - Basic Storage for Leases\n\nThe server is able to store lease data in different repositories. Larger deployments may elect to store leases in a database; Lease Database Configuration describes this option. In typical smaller deployments, though, the server stores lease information in a CSV file rather than a database. As well as requiring less administration, an advantage of using a file for storage is that it eliminates a dependency on third-party database software.\n\nThe configuration of the memfile backend is controlled through the Dhcp4/lease-database parameters. The type parameter is mandatory and specifies which storage for leases the server should use, through the \"memfile\" value. The following list gives additional optional parameters that can be used to configure the memfile backend.\n\npersist: controls whether the new leases and updates to existing leases are written to the file. It is strongly recommended that the value of this parameter be set to true at all times during the server’s normal operation. Not writing leases to disk means that if a server is restarted (e.g. after a power failure), it will not know which addresses have been assigned. As a result, it may assign new clients addresses that are already in use. The value of false is mostly useful for performance-testing purposes. The default value of the persist parameter is true, which enables writing lease updates to the lease file.\n\nname: specifies an absolute location of the lease file in which new leases and lease updates are recorded. The default value for this parameter is \"[kea-install-dir]/var/lib/kea/kea-leases4.csv\".\n\nlfc-interval: specifies the interval, in seconds, at which the server will perform a lease file cleanup (LFC). This removes redundant (historical) information from the lease file and effectively reduces the lease file size. The cleanup process is described in more detail later in this section. The default value of the lfc-interval is 3600. A value of 0 disables the LFC.\n\nmax-row-errors: specifies the number of row errors before the server stops attempting to load a lease file. When the server loads a lease file, it is processed row by row, each row containing a single lease. If a row is flawed and cannot be processed correctly the server logs it, discards the row, and goes on to the next row. This parameter can be used to set a limit on the number of such discards that can occur, after which the server abandons the effort and exits. The default value of 0 disables the limit and allows the server to process the entire file, regardless of how many rows are discarded.\n\nAn example configuration of the memfile backend is presented below:\n\n\"Dhcp4\": { \"lease-database\": { \"type\": \"memfile\", \"persist\": true, \"name\": \"/tmp/kea-leases4.csv\", \"lfc-interval\": 1800, \"max-row-errors\": 100 } }\n\nThis configuration selects /tmp/kea-leases4.csv as the storage for lease information and enables persistence (writing lease updates to this file). It also configures the backend to perform a periodic cleanup of the lease file every 1800 seconds (30 minutes) and sets the maximum number of row errors to 100.\n\n8.2.2.2. Why Is Lease File Cleanup Necessary?\n\nIt is important to know how the lease file contents are organized to understand why the periodic lease file cleanup is needed. Every time the server updates a lease or creates a new lease for a client, the new lease information must be recorded in the lease file. For performance reasons, the server does not update the existing client’s lease in the file, as this would potentially require rewriting the entire file. Instead, it simply appends the new lease information to the end of the file; the previous lease entries for the client are not removed. When the server loads leases from the lease file, e.g. at server startup, it assumes that the latest lease entry for the client is the valid one. Previous entries are discarded, meaning that the server can reconstruct accurate information about the leases even though there may be many lease entries for each client. However, storing many entries for each client results in a bloated lease file and impairs the performance of the server’s startup and reconfiguration, as it needs to process a larger number of lease entries.\n\nLease file cleanup (LFC) removes all previous entries for each client and leaves only the latest ones. The interval at which the cleanup is performed is configurable, and it should be selected according to the frequency of lease renewals initiated by the clients. The more frequent the renewals, the smaller the value of lfc-interval should be. Note, however, that the LFC takes time and thus it is possible (although unlikely) that, if the lfc-interval is too short, a new cleanup may be started while the previous one is still running. The server would recover from this by skipping the new cleanup when it detected that the previous cleanup was still in progress, but it implies that the actual cleanups will be triggered more rarely than the configured interval. Moreover, triggering a new cleanup adds overhead to the server, which is not able to respond to new requests for a short period of time when the new cleanup process is spawned. Therefore, it is recommended that the lfc-interval value be selected in a way that allows the LFC to complete the cleanup before a new cleanup is triggered.\n\nLease file cleanup is performed by a separate process (in the background) to avoid a performance impact on the server process. To avoid conflicts between two processes using the same lease files, the LFC process starts with Kea opening a new lease file; the actual LFC process operates on the lease file that is no longer used by the server. There are also other files created as a side effect of the lease file cleanup. The detailed description of the LFC process is located later in this Kea Administrator’s Reference Manual: The LFC Process.\n\n8.2.2.3. Lease Database Configuration\n\nNote\n\nLease database access information must be configured for the DHCPv4 server, even if it has already been configured for the DHCPv6 server. The servers store their information independently, so each server can use a separate database or both servers can use the same database.\n\nNote\n\nKea requires the database timezone to match the system timezone. For more details, see First-Time Creation of the MySQL Database and First-Time Creation of the PostgreSQL Database.\n\nLease database configuration is controlled through the Dhcp4/lease-database parameters. The database type must be set to memfile, mysql or postgresql, e.g.:\n\n\"Dhcp4\": { \"lease-database\": { \"type\": \"mysql\", ... }, ... }\n\nNext, the name of the database to hold the leases must be set; this is the name used when the database was created (see First-Time Creation of the MySQL Database or First-Time Creation of the PostgreSQL Database).\n\nFor MySQL or PostgreSQL:\n\n\"Dhcp4\": { \"lease-database\": { \"name\": \"database-name\" , ... }, ... }\n\nIf the database is located on a different system from the DHCPv4 server, the database host name must also be specified:\n\n\"Dhcp4\": { \"lease-database\": { \"host\": \"remote-host-name\", ... }, ... }\n\nNormally, the database is on the same machine as the DHCPv4 server. In this case, set the value to the empty string:\n\n\"Dhcp4\": { \"lease-database\": { \"host\" : \"\", ... }, ... }\n\nShould the database use a port other than the default, it may be specified as well:\n\n\"Dhcp4\": { \"lease-database\": { \"port\" : 12345, ... }, ... }\n\nShould the database be located on a different system, the administrator may need to specify a longer interval for the connection timeout:\n\n\"Dhcp4\": { \"lease-database\": { \"connect-timeout\" : timeout-in-seconds, ... }, ... }\n\nThe default value of five seconds should be more than adequate for local connections. If a timeout is given, though, it should be an integer greater than zero.\n\nThe maximum number of times the server automatically attempts to reconnect to the lease database after connectivity has been lost may be specified:\n\n\"Dhcp4\": { \"lease-database\": { \"max-reconnect-tries\" : number-of-tries, ... }, ... }\n\nIf the server is unable to reconnect to the database after making the maximum number of attempts, the server will exit. A value of 0 (the default) disables automatic recovery and the server will exit immediately upon detecting a loss of connectivity (MySQL and PostgreSQL only).\n\nThe number of milliseconds the server waits between attempts to reconnect to the lease database after connectivity has been lost may also be specified:\n\n\"Dhcp4\": { \"lease-database\": { \"reconnect-wait-time\" : number-of-milliseconds, ... }, ... }\n\nThe default value for MySQL and PostgreSQL is 0, which disables automatic recovery and causes the server to exit immediately upon detecting the loss of connectivity.\n\n\"Dhcp4\": { \"lease-database\": { \"on-fail\" : \"stop-retry-exit\", ... }, ... }\n\nThe possible values are:\n\nstop-retry-exit - disables the DHCP service while trying to automatically recover lost connections. Shuts down the server on failure after exhausting max-reconnect-tries. This is the default value for MySQL and PostgreSQL.\n\nserve-retry-exit - continues the DHCP service while trying to automatically recover lost connections. Shuts down the server on failure after exhausting max-reconnect-tries.\n\nserve-retry-continue - continues the DHCP service and does not shut down the server even if the recovery fails.\n\nNote\n\nAutomatic reconnection to database backends is configured individually per backend; this allows users to tailor the recovery parameters to each backend they use. We suggest that users enable it either for all backends or none, so behavior is consistent.\n\nLosing connectivity to a backend for which reconnection is disabled results (if configured) in the server shutting itself down. This includes cases when the lease database backend and the hosts database backend are connected to the same database instance.\n\nIt is highly recommended not to change the stop-retry-exit default setting for the lease manager, as it is critical for the connection to be active while processing DHCP traffic. Change this only if the server is used exclusively as a configuration tool.\n\nThe host parameter is used by the MySQL and PostgreSQL backends.\n\nFinally, the credentials of the account under which the server will access the database should be set:\n\n\"Dhcp4\": { \"lease-database\": { \"user\": \"user-name\", \"password\": \"password\", ... }, ... }\n\nIf there is no password to the account, set the password to the empty string \"\". (This is the default.)\n\n8.2.3. Hosts Storage\n\nKea is also able to store information about host reservations in the database. The hosts database configuration uses the same syntax as the lease database. In fact, the Kea server opens independent connections for each purpose, be it lease or hosts information, which gives the most flexibility. Kea can keep leases and host reservations separately, but can also point to the same database. Currently the supported hosts database types are MySQL and PostgreSQL.\n\nThe following configuration can be used to configure a connection to MySQL:\n\n\"Dhcp4\": { \"hosts-database\": { \"type\": \"mysql\", \"name\": \"kea\", \"user\": \"kea\", \"password\": \"secret123\", \"host\": \"localhost\", \"port\": 3306 } }\n\nDepending on the database configuration, many of the parameters may be optional.\n\nPlease note that usage of hosts storage is optional. A user can define all host reservations in the configuration file, and that is the recommended way if the number of reservations is small. However, when the number of reservations grows, it is more convenient to use host storage. Please note that both storage methods (the configuration file and one of the supported databases) can be used together. If hosts are defined in both places, the definitions from the configuration file are checked first and external storage is checked later, if necessary.\n\nHost information can be placed in multiple stores. Operations are performed on the stores in the order they are defined in the configuration file, although this leads to a restriction in ordering in the case of a host reservation addition; read-only stores must be configured after a (required) read-write store, or the addition will fail.\n\nNote\n\nKea requires the database timezone to match the system timezone. For more details, see First-Time Creation of the MySQL Database and First-Time Creation of the PostgreSQL Database.\n\n8.2.3.1. DHCPv4 Hosts Database Configuration\n\nHosts database configuration is controlled through the Dhcp4/hosts-database parameters. If enabled, the type of database must be set to mysql or postgresql.\n\n\"Dhcp4\": { \"hosts-database\": { \"type\": \"mysql\", ... }, ... }\n\nNext, the name of the database to hold the reservations must be set; this is the name used when the lease database was created (see Supported Backends for instructions on how to set up the desired database type):\n\n\"Dhcp4\": { \"hosts-database\": { \"name\": \"database-name\" , ... }, ... }\n\nIf the database is located on a different system than the DHCPv4 server, the database host name must also be specified:\n\n\"Dhcp4\": { \"hosts-database\": { \"host\": remote-host-name, ... }, ... }\n\nNormally, the database is on the same machine as the DHCPv4 server. In this case, set the value to the empty string:\n\n\"Dhcp4\": { \"hosts-database\": { \"host\" : \"\", ... }, ... }\n\nShould the database use a port different than the default, it may be specified as well:\n\n\"Dhcp4\": { \"hosts-database\": { \"port\" : 12345, ... }, ... }\n\nThe maximum number of times the server automatically attempts to reconnect to the host database after connectivity has been lost may be specified:\n\n\"Dhcp4\": { \"hosts-database\": { \"max-reconnect-tries\" : number-of-tries, ... }, ... }\n\nIf the server is unable to reconnect to the database after making the maximum number of attempts, the server will exit. A value of 0 (the default) disables automatic recovery and the server will exit immediately upon detecting a loss of connectivity (MySQL and PostgreSQL only).\n\nThe number of milliseconds the server waits between attempts to reconnect to the host database after connectivity has been lost may also be specified:\n\n\"Dhcp4\": { \"hosts-database\": { \"reconnect-wait-time\" : number-of-milliseconds, ... }, ... }\n\nThe default value for MySQL and PostgreSQL is 0, which disables automatic recovery and causes the server to exit immediately upon detecting the loss of connectivity.\n\n\"Dhcp4\": { \"hosts-database\": { \"on-fail\" : \"stop-retry-exit\", ... }, ... }\n\nThe possible values are:\n\nstop-retry-exit - disables the DHCP service while trying to automatically recover lost connections. Shuts down the server on failure after exhausting max-reconnect-tries. This is the default value for MySQL and PostgreSQL.\n\nserve-retry-exit - continues the DHCP service while trying to automatically recover lost connections. Shuts down the server on failure after exhausting max-reconnect-tries.\n\nserve-retry-continue - continues the DHCP service and does not shut down the server even if the recovery fails.\n\nNote\n\nAutomatic reconnection to database backends is configured individually per backend. This allows users to tailor the recovery parameters to each backend they use. We suggest that users enable it either for all backends or none, so behavior is consistent.\n\nLosing connectivity to a backend for which reconnection is disabled results (if configured) in the server shutting itself down. This includes cases when the lease database backend and the hosts database backend are connected to the same database instance.\n\nFinally, the credentials of the account under which the server will access the database should be set:\n\n\"Dhcp4\": { \"hosts-database\": { \"user\": \"user-name\", \"password\": \"password\", ... }, ... }\n\nIf there is no password to the account, set the password to the empty string \"\". (This is the default.)\n\nThe multiple-storage extension uses a similar syntax; a configuration is placed into a hosts-databases list instead of into a hosts-database entry, as in:\n\n\"Dhcp4\": { \"hosts-databases\": [ { \"type\": \"mysql\", ... }, ... ], ... }\n\nIf the same host is configured both in-file and in-database, Kea does not issue a warning, as it would if both were specified in the same data source. Instead, the host configured in-file has priority over the one configured in-database.\n\n8.2.3.2. Using Read-Only Databases for Host Reservations With DHCPv4\n\nIn some deployments, the user whose name is specified in the database backend configuration may not have write privileges to the database. This is often required by the policy within a given network to secure the data from being unintentionally modified. In many cases administrators have deployed inventory databases, which contain substantially more information about the hosts than just the static reservations assigned to them. The inventory database can be used to create a view of a Kea hosts database and such a view is often read-only.\n\nKea host-database backends operate with an implicit configuration to both read from and write to the database. If the user does not have write access to the host database, the backend will fail to start and the server will refuse to start (or reconfigure). However, if access to a read-only host database is required for retrieving reservations for clients and/or assigning specific addresses and options, it is possible to explicitly configure Kea to start in “read-only” mode. This is controlled by the readonly boolean parameter as follows:\n\n\"Dhcp4\": { \"hosts-database\": { \"readonly\": true, ... }, ... }\n\nSetting this parameter to false configures the database backend to operate in “read-write” mode, which is also the default configuration if the parameter is not specified.\n\nNote\n\nThe readonly parameter is only supported for MySQL and PostgreSQL databases.\n\n8.2.4. Interface Configuration\n\nThe DHCPv4 server must be configured to listen on specific network interfaces. The simplest network interface configuration tells the server to listen on all available interfaces:\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"*\" ] } ... },\n\nThe asterisk plays the role of a wildcard and means “listen on all interfaces.” However, it is usually a good idea to explicitly specify interface names:\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"eth1\", \"eth3\" ] }, ... }\n\nIt is possible to use an interface wildcard (*) concurrently with explicit interface names:\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"eth1\", \"eth3\", \"*\" ] }, ... }\n\nThis format should only be used when it is desired to temporarily override a list of interface names and listen on all interfaces.\n\nSome deployments of DHCP servers require that the servers listen on interfaces with multiple IPv4 addresses configured. In these situations, the address to use can be selected by appending an IPv4 address to the interface name in the following manner:\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"eth1/10.0.0.1\", \"eth3/192.0.2.3\" ] }, ... }\n\nShould the server be required to listen on multiple IPv4 addresses assigned to the same interface, multiple addresses can be specified for an interface as in the example below:\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"eth1/10.0.0.1\", \"eth1/10.0.0.2\" ] }, ... }\n\nAlternatively, if the server should listen on all addresses for the particular interface, an interface name without any address should be specified.\n\nKea supports responding to directly connected clients which do not have an address configured. This requires the server to inject the hardware address of the destination into the data-link layer of the packet being sent to the client. The DHCPv4 server uses raw sockets to achieve this, and builds the entire IP/UDP stack for the outgoing packets. The downside of raw socket use, however, is that incoming and outgoing packets bypass the firewalls (e.g. iptables).\n\nHandling traffic on multiple IPv4 addresses assigned to the same interface can be a challenge, as raw sockets are bound to the interface. When the DHCP server is configured to use the raw socket on an interface to receive DHCP traffic, advanced packet filtering techniques (e.g. the BPF) must be used to receive unicast traffic on the desired addresses assigned to the interface. Whether clients use the raw socket or the UDP socket depends on whether they are directly connected (raw socket) or relayed (either raw or UDP socket).\n\nTherefore, in deployments where the server does not need to provision the directly connected clients and only receives the unicast packets from the relay agents, the Kea server should be configured to use UDP sockets instead of raw sockets. The following configuration demonstrates how this can be achieved:\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"eth1\", \"eth3\" ], \"dhcp-socket-type\": \"udp\" }, ... }\n\nThe dhcp-socket-type parameter specifies that the IP/UDP sockets will be opened on all interfaces on which the server listens, i.e. “eth1” and “eth3” in this example. If dhcp-socket-type is set to raw, it configures the server to use raw sockets instead. If the dhcp-socket-type value is not specified, the default value raw is used.\n\nUsing UDP sockets automatically disables the reception of broadcast packets from directly connected clients. This effectively means that UDP sockets can be used for relayed traffic only. When using raw sockets, both the traffic from the directly connected clients and the relayed traffic are handled.\n\nCaution should be taken when configuring the server to open multiple raw sockets on the interface with several IPv4 addresses assigned. If the directly connected client sends the message to the broadcast address, all sockets on this link will receive this message and multiple responses will be sent to the client. Therefore, the configuration with multiple IPv4 addresses assigned to the interface should not be used when the directly connected clients are operating on that link. To use a single address on such an interface, the “interface-name/address” notation should be used.\n\nNote\n\nSpecifying the value raw as the socket type does not guarantee that raw sockets will be used! The use of raw sockets to handle traffic from the directly connected clients is currently supported on Linux and BSD systems only. If raw sockets are not supported on the particular OS in use, the server issues a warning and fall back to using IP/UDP sockets.\n\nIn a typical environment, the DHCP server is expected to send back a response on the same network interface on which the query was received. This is the default behavior. However, in some deployments it is desired that the outbound (response) packets be sent as regular traffic and the outbound interface be determined by the routing tables. This kind of asymmetric traffic is uncommon, but valid. Kea supports a parameter called outbound-interface that controls this behavior. It supports two values: the first one, same-as-inbound, tells Kea to send back the response on the same interface where the query packet was received. This is the default behavior. The second parameter, use-routing, tells Kea to send regular UDP packets and let the kernel’s routing table determine the most appropriate interface. This only works when dhcp-socket-type is set to udp. An example configuration looks as follows:\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"eth1\", \"eth3\" ], \"dhcp-socket-type\": \"udp\", \"outbound-interface\": \"use-routing\" }, ... }\n\nInterfaces are re-detected at each reconfiguration. This behavior can be disabled by setting the re-detect value to false, for instance:\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"eth1\", \"eth3\" ], \"re-detect\": false }, ... }\n\nNote that interfaces are not re-detected during config-test.\n\nUsually loopback interfaces (e.g. the lo or lo0 interface) are not configured, but if a loopback interface is explicitly configured and IP/UDP sockets are specified, the loopback interface is accepted.\n\nFor example, this setup can be used to run Kea in a FreeBSD jail having only a loopback interface, to service a relayed DHCP request:\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"lo0\" ], \"dhcp-socket-type\": \"udp\" }, ... }\n\nKea binds the service sockets for each interface on startup. If another process is already using a port, then Kea logs the message and suppresses an error. DHCP service runs, but it is unavailable on some interfaces.\n\nThe “service-sockets-require-all” option makes Kea require all sockets to be successfully bound. If any opening fails, Kea interrupts the initialization and exits with a non-zero status. (Default is false).\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"eth1\", \"eth3\" ], \"service-sockets-require-all\": true }, ... }\n\nSometimes, immediate interruption isn’t a good choice. The port can be unavailable only temporary. In this case, retrying the opening may resolve the problem. Kea provides two options to specify the retrying: service-sockets-max-retries and service-sockets-retry-wait-time.\n\nThe first defines a maximal number of retries that Kea makes to open a socket. The zero value (default) means that the Kea doesn’t retry the process.\n\nThe second defines a wait time (in milliseconds) between attempts. The default value is 5000 (5 seconds).\n\n\"Dhcp4\": { \"interfaces-config\": { \"interfaces\": [ \"eth1\", \"eth3\" ], \"service-sockets-max-retries\": 5, \"service-sockets-retry-wait-time\": 5000 }, ... }\n\nIf “service-sockets-max-retries” is non-zero and “service-sockets-require-all” is false, then Kea retries the opening (if needed) but does not fail if any socket is still not opened.\n\n8.2.5. Issues With Unicast Responses to DHCPINFORM\n\nThe use of UDP sockets has certain benefits in deployments where the server receives only relayed traffic; these benefits are mentioned in Interface Configuration. From the administrator’s perspective it is often desirable to configure the system’s firewall to filter out unwanted traffic, and the use of UDP sockets facilitates this. However, the administrator must also be aware of the implications related to filtering certain types of traffic, as it may impair the DHCP server’s operation.\n\nIn this section we focus on the case when the server receives the DHCPINFORM message from the client via a relay. According to RFC 2131, the server should unicast the DHCPACK response to the address carried in the ciaddr field. When the UDP socket is in use, the DHCP server relies on the low-level functions of an operating system to build the data link, IP, and UDP layers of the outgoing message. Typically, the OS first uses ARP to obtain the client’s link-layer address to be inserted into the frame’s header, if the address is not cached from a previous transaction that the client had with the server. When the ARP exchange is successful, the DHCP message can be unicast to the client, using the obtained address.\n\nSome system administrators block ARP messages in their network, which causes issues for the server when it responds to the DHCPINFORM messages because the server is unable to send the DHCPACK if the preceding ARP communication fails. Since the OS is entirely responsible for the ARP communication and then sending the DHCP packet over the wire, the DHCP server has no means to determine that the ARP exchange failed and the DHCP response message was dropped. Thus, the server does not log any error messages when the outgoing DHCP response is dropped. At the same time, all hooks pertaining to the packet-sending operation will be called, even though the message never reaches its destination.\n\nNote that the issue described in this section is not observed when raw sockets are in use, because, in this case, the DHCP server builds all the layers of the outgoing message on its own and does not use ARP. Instead, it inserts the value carried in the chaddr field of the DHCPINFORM message into the link layer.\n\nServer administrators willing to support DHCPINFORM messages via relays should not block ARP traffic in their networks, or should use raw sockets instead of UDP sockets.\n\n8.2.6. IPv4 Subnet Identifier\n\nThe subnet identifier (subnet ID) is a unique number associated with a particular subnet. In principle, it is used to associate clients’ leases with their respective subnets. When a subnet identifier is not specified for a subnet being configured, it is automatically assigned by the configuration mechanism. The identifiers are assigned starting at 1 and are monotonically increased for each subsequent subnet: 1, 2, 3, ….\n\nIf there are multiple subnets configured with auto-generated identifiers and one of them is removed, the subnet identifiers may be renumbered. For example: if there are four subnets and the third is removed, the last subnet will be assigned the identifier that the third subnet had before removal. As a result, the leases stored in the lease database for subnet 3 are now associated with subnet 4, something that may have unexpected consequences. The only remedy for this issue at present is to manually specify a unique identifier for each subnet.\n\nNote\n\nSubnet IDs must be greater than zero and less than 4294967295.\n\nThe following configuration assigns the specified subnet identifier to a newly configured subnet:\n\n\"Dhcp4\": { \"subnet4\": [ { \"subnet\": \"192.0.2.0/24\", \"id\": 1024, ... } ] }\n\nThis identifier will not change for this subnet unless the id parameter is removed or set to 0. The value of 0 forces auto-generation of the subnet identifier.\n\n8.2.7. IPv4 Subnet Prefix\n\nThe subnet prefix is the second way to identify a subnet. Kea can accept non-canonical subnet addresses; for instance, this configuration is accepted:\n\n\"Dhcp4\": { \"subnet4\": [ { \"subnet\": \"192.0.2.1/24\", ... } ] }\n\nThis works even if there is another subnet with the “192.0.2.0/24” prefix; only the textual form of subnets are compared to avoid duplicates.\n\nNote\n\nAbuse of this feature can lead to incorrect subnet selection (see How the DHCPv4 Server Selects a Subnet for the Client).\n\n8.2.8. Configuration of IPv4 Address Pools\n\nThe main role of a DHCPv4 server is address assignment. For this, the server must be configured with at least one subnet and one pool of dynamic addresses to be managed. For example, assume that the server is connected to a network segment that uses the 192.0.2.0/24 prefix. The administrator of that network decides that addresses from the range 192.0.2.10 to 192.0.2.20 are going to be managed by the DHCPv4 server. Such a configuration can be achieved in the following way:\n\n\"Dhcp4\": { \"subnet4\": [ { \"subnet\": \"192.0.2.0/24\", \"pools\": [ { \"pool\": \"192.0.2.10 - 192.0.2.20\" } ], ... } ] }\n\nNote that subnet is defined as a simple string, but the pools parameter is actually a list of pools; for this reason, the pool definition is enclosed in square brackets, even though only one range of addresses is specified.\n\nEach pool is a structure that contains the parameters that describe a single pool. Currently there is only one parameter, pool, which gives the range of addresses in the pool.\n\nIt is possible to define more than one pool in a subnet; continuing the previous example, further assume that 192.0.2.64/26 should also be managed by the server. It could be written as 192.0.2.64 to 192.0.2.127, or it can be expressed more simply as 192.0.2.64/26. Both formats are supported by Dhcp4 and can be mixed in the pool list. For example, the following pools could be defined:\n\n\"Dhcp4\": { \"subnet4\": [ { \"subnet\": \"192.0.2.0/24\", \"pools\": [ { \"pool\": \"192.0.2.10-192.0.2.20\" }, { \"pool\": \"192.0.2.64/26\" } ], ... } ], ... }\n\nWhite space in pool definitions is ignored, so spaces before and after the hyphen are optional. They can be used to improve readability.\n\nThe number of pools is not limited, but for performance reasons it is recommended to use as few as possible.\n\nThe server may be configured to serve more than one subnet. To add a second subnet, use a command similar to the following:\n\n\"Dhcp4\": { \"subnet4\": [ { \"subnet\": \"192.0.2.0/24\", \"pools\": [ { \"pool\": \"192.0.2.1 - 192.0.2.200\" } ], ... }, { \"subnet\": \"192.0.3.0/24\", \"pools\": [ { \"pool\": \"192.0.3.100 - 192.0.3.200\" } ], ... }, { \"subnet\": \"192.0.4.0/24\", \"pools\": [ { \"pool\": \"192.0.4.1 - 192.0.4.254\" } ], ... } ] }\n\nWhen configuring a DHCPv4 server using prefix/length notation, please pay attention to the boundary values. When specifying that the server can use a given pool, it is also able to allocate the first (typically a network address) and the last (typically a broadcast address) address from that pool. In the aforementioned example of pool 192.0.3.0/24, both the 192.0.3.0 and 192.0.3.255 addresses may be assigned as well. This may be invalid in some network configurations. To avoid this, use the min-max notation.\n\nNote\n\nHere are some liberties and limits to the values that subnets and pools can take in Kea configurations that are out of the ordinary:\n\nKea configuration case\n\nAllowed\n\nComment\n\n8.2.9. Sending T1 (Option 58) and T2 (Option 59)\n\nAccording to RFC 2131, servers should send values for T1 and T2 that are 50% and 87.5% of the lease lifetime, respectively. By default, kea-dhcp4 does not send either value; it can be configured to send values that are either specified explicitly or that are calculated as percentages of the lease time. The server’s behavior is governed by a combination of configuration parameters, two of which have already been mentioned. To send specific, fixed values use the following two parameters:\n\nrenew-timer - specifies the value of T1 in seconds.\n\nrebind-timer - specifies the value of T2 in seconds.\n\nThe server only sends T2 if it is less than the valid lease time. T1 is only sent if T2 is being sent and T1 is less than T2; or T2 is not being sent and T1 is less than the valid lease time.\n\nCalculating the values is controlled by the following three parameters.\n\ncalculate-tee-times - when true, T1 and T2 are calculated as percentages of the valid lease time. It defaults to false.\n\nt1-percent - the percentage of the valid lease time to use for T1. It is expressed as a real number between 0.0 and 1.0 and must be less than t2-percent. The default value is 0.50, per RFC 2131.\n\nt2-percent - the percentage of the valid lease time to use for T2. It is expressed as a real number between 0.0 and 1.0 and must be greater than t1-percent. The default value is .875, per RFC 2131.\n\nNote\n\nIn the event that both explicit values are specified and calculate-tee-times is true, the server will use the explicit values. Administrators with a setup where some subnets or shared-networks use explicit values and some use calculated values must not define the explicit values at any level higher than where they will be used. Inheriting them from too high a scope, such as global, will cause them to have explicit values at every level underneath (shared-networks and subnets), effectively disabling calculated values.\n\n8.2.10. Standard DHCPv4 Options\n\nOne of the major features of the DHCPv4 server is the ability to provide configuration options to clients. Most of the options are sent by the server only if the client explicitly requests them using the Parameter Request List option. Those that do not require inclusion in the Parameter Request List option are commonly used options, e.g. “Domain Server”, and options which require special behavior, e.g. “Client FQDN”, which is returned to the client if the client has included this option in its message to the server.\n\nList of standard DHCPv4 options configurable by an administrator comprises the list of the standard DHCPv4 options whose values can be configured using the configuration structures described in this section. This table excludes the options which require special processing and thus cannot be configured with fixed values. The last column of the table indicates which options can be sent by the server even when they are not requested in the Parameter Request List option, and those which are sent only when explicitly requested.\n\nThe following example shows how to configure the addresses of DNS servers, which is one of the most frequently used options. Options specified in this way are considered global and apply to all configured subnets.\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"domain-name-servers\", \"code\": 6, \"space\": \"dhcp4\", \"csv-format\": true, \"data\": \"192.0.2.1, 192.0.2.2\" }, ... ] }\n\nNote that either name or code is required; there is no need to specify both. space has a default value of dhcp4, so this can be skipped as well if a regular (not encapsulated) DHCPv4 option is defined. Finally, csv-format defaults to true, so it too can be skipped, unless the option value is specified as a hexadecimal string. Therefore, the above example can be simplified to:\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"domain-name-servers\", \"data\": \"192.0.2.1, 192.0.2.2\" }, ... ] }\n\nDefined options are added to the response when the client requests them, with a few exceptions which are always added. To enforce the addition of a particular option, set the always-send flag to true as in:\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"domain-name-servers\", \"data\": \"192.0.2.1, 192.0.2.2\", \"always-send\": true }, ... ] }\n\nThe effect is the same as if the client added the option code in the Parameter Request List option (or its equivalent for vendor options):\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"domain-name-servers\", \"data\": \"192.0.2.1, 192.0.2.2\", \"always-send\": true }, ... ], \"subnet4\": [ { \"subnet\": \"192.0.3.0/24\", \"option-data\": [ { \"name\": \"domain-name-servers\", \"data\": \"192.0.3.1, 192.0.3.2\" }, ... ], ... }, ... ], ... }\n\nThe domain-name-servers option is always added to responses (the always-send is “sticky”), but the value is the subnet one when the client is localized in the subnet.\n\nThe name parameter specifies the option name. For a list of currently supported names, see List of standard DHCPv4 options configurable by an administrator below. The code parameter specifies the option code, which must match one of the values from that list. The next line specifies the option space, which must always be set to dhcp4 as these are standard DHCPv4 options. For other option spaces, including custom option spaces, see Nested DHCPv4 Options (Custom Option Spaces). The next line specifies the format in which the data will be entered; use of CSV (comma-separated values) is recommended. The sixth line gives the actual value to be sent to clients. The data parameter is specified as normal text, with values separated by commas if more than one value is allowed.\n\nOptions can also be configured as hexadecimal values. If csv-format is set to false, option data must be specified as a hexadecimal string. The following commands configure the domain-name-servers option for all subnets with the following addresses: 192.0.3.1 and 192.0.3.2. Note that csv-format is set to false.\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"domain-name-servers\", \"code\": 6, \"space\": \"dhcp4\", \"csv-format\": false, \"data\": \"C0 00 03 01 C0 00 03 02\" }, ... ], ... }\n\nKea supports the following formats when specifying hexadecimal data:\n\nDelimited octets - one or more octets separated by either colons or spaces (“:” or ” “). While each octet may contain one or two digits, we strongly recommend always using two digits. Valid examples are “ab:cd:ef” and “ab cd ef”.\n\nString of digits - a continuous string of hexadecimal digits with or without a “0x” prefix. Valid examples are “0xabcdef” and “abcdef”.\n\nCare should be taken to use proper encoding when using hexadecimal format; Kea’s ability to validate data correctness in hexadecimal is limited.\n\nIt is also possible to specify data for binary options as a single-quoted text string within double quotes as shown (note that csv-format must be set to false):\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"user-class\", \"code\": 77, \"space\": \"dhcp4\", \"csv-format\": false, \"data\": \"'convert this text to binary'\" }, ... ], ... }\n\nMost of the parameters in the option-data structure are optional and can be omitted in some circumstances, as discussed in Unspecified Parameters for DHCPv4 Option Configuration.\n\nIt is possible to specify or override options on a per-subnet basis. If clients connected to most subnets are expected to get the same values of a given option, administrators should use global options. On the other hand, if different values are used in each subnet, it does not make sense to specify global option values; rather, only subnet-specific ones should be set.\n\nThe following commands override the global DNS servers option for a particular subnet, setting a single DNS server with address 192.0.2.3:\n\n\"Dhcp4\": { \"subnet4\": [ { \"option-data\": [ { \"name\": \"domain-name-servers\", \"code\": 6, \"space\": \"dhcp4\", \"csv-format\": true, \"data\": \"192.0.2.3\" }, ... ], ... }, ... ], ... }\n\nIn some cases it is useful to associate some options with an address pool from which a client is assigned a lease. Pool-specific option values override subnet-specific and global option values; it is not possible to prioritize assignment of pool-specific options via the order of pool declarations in the server configuration.\n\nThe following configuration snippet demonstrates how to specify the DNS servers option, which is assigned to a client only if the client obtains an address from the given pool:\n\n\"Dhcp4\": { \"subnet4\": [ { \"pools\": [ { \"pool\": \"192.0.2.1 - 192.0.2.200\", \"option-data\": [ { \"name\": \"domain-name-servers\", \"data\": \"192.0.2.3\" }, ... ], ... }, ... ], ... }, ... ], ... }\n\nOptions can also be specified in class or host-reservation scope. The current Kea options precedence order is (from most important to least): host reservation, pool, subnet, shared network, class, global.\n\nWhen a data field is a string and that string contains the comma (,; U+002C) character, the comma must be escaped with two backslashes (\\\\,; U+005C). This double escape is required because both the routine splitting of CSV data into fields and JSON use the same escape character; a single escape (\\,) would make the JSON invalid. For example, the string “foo,bar” must be represented as:\n\n\"Dhcp4\": { \"subnet4\": [ { \"pools\": [ { \"option-data\": [ { \"name\": \"boot-file-name\", \"data\": \"foo\\\\,bar\" } ] }, ... ], ... }, ... ], ... }\n\nSome options are designated as arrays, which means that more than one value is allowed. For example, the option time-servers allows the specification of more than one IPv4 address, enabling clients to obtain the addresses of multiple NTP servers.\n\nCustom DHCPv4 Options describes the configuration syntax to create custom option definitions (formats). Creation of custom definitions for standard options is generally not permitted, even if the definition being created matches the actual option format defined in the RFCs. There is an exception to this rule for standard options for which Kea currently does not provide a definition. To use such options, a server administrator must create a definition as described in Custom DHCPv4 Options in the dhcp4 option space. This definition should match the option format described in the relevant RFC, but the configuration mechanism will allow any option format as it currently has no means to validate it.\n\nThe currently supported standard DHCPv4 options are listed in the table below. “Name” and “Code” are the values that should be used as a name/code in the option-data structures. “Type” designates the format of the data; the meanings of the various types are given in List of standard DHCP option types.\n\n\n\nName\n\nCode\n\nType\n\nArray?\n\nReturned if not requested?\n\ntime-offset\n\n2\n\nint32\n\nfalse\n\nfalse\n\nrouters\n\n3\n\nipv4-address\n\ntrue\n\ntrue\n\ntime-servers\n\n4\n\nipv4-address\n\ntrue\n\nfalse\n\nname-servers\n\n5\n\nipv4-address\n\ntrue\n\nfalse\n\ndomain-name-servers\n\n6\n\nipv4-address\n\ntrue\n\ntrue\n\nlog-servers\n\n7\n\nipv4-address\n\ntrue\n\nfalse\n\ncookie-servers\n\n8\n\nipv4-address\n\ntrue\n\nfalse\n\nlpr-servers\n\n9\n\nipv4-address\n\ntrue\n\nfalse\n\nimpress-servers\n\n10\n\nipv4-address\n\ntrue\n\nfalse\n\nresource-location-servers\n\n11\n\nipv4-address\n\ntrue\n\nfalse\n\nboot-size\n\n13\n\nuint16\n\nfalse\n\nfalse\n\nmerit-dump\n\n14\n\nstring\n\nfalse\n\nfalse\n\ndomain-name\n\n15\n\nfqdn\n\nfalse\n\ntrue\n\nswap-server\n\n16\n\nipv4-address\n\nfalse\n\nfalse\n\nroot-path\n\n17\n\nstring\n\nfalse\n\nfalse\n\nextensions-path\n\n18\n\nstring\n\nfalse\n\nfalse\n\nip-forwarding\n\n19\n\nboolean\n\nfalse\n\nfalse\n\nnon-local-source-routing\n\n20\n\nboolean\n\nfalse\n\nfalse\n\npolicy-filter\n\n21\n\nipv4-address\n\ntrue\n\nfalse\n\nmax-dgram-reassembly\n\n22\n\nuint16\n\nfalse\n\nfalse\n\ndefault-ip-ttl\n\n23\n\nuint8\n\nfalse\n\nfalse\n\npath-mtu-aging-timeout\n\n24\n\nuint32\n\nfalse\n\nfalse\n\npath-mtu-plateau-table\n\n25\n\nuint16\n\ntrue\n\nfalse\n\ninterface-mtu\n\n26\n\nuint16\n\nfalse\n\nfalse\n\nall-subnets-local\n\n27\n\nboolean\n\nfalse\n\nfalse\n\nbroadcast-address\n\n28\n\nipv4-address\n\nfalse\n\nfalse\n\nperform-mask-discovery\n\n29\n\nboolean\n\nfalse\n\nfalse\n\nmask-supplier\n\n30\n\nboolean\n\nfalse\n\nfalse\n\nrouter-discovery\n\n31\n\nboolean\n\nfalse\n\nfalse\n\nrouter-solicitation-address\n\n32\n\nipv4-address\n\nfalse\n\nfalse\n\nstatic-routes\n\n33\n\nipv4-address\n\ntrue\n\nfalse\n\ntrailer-encapsulation\n\n34\n\nboolean\n\nfalse\n\nfalse\n\narp-cache-timeout\n\n35\n\nuint32\n\nfalse\n\nfalse\n\nieee802-3-encapsulation\n\n36\n\nboolean\n\nfalse\n\nfalse\n\ndefault-tcp-ttl\n\n37\n\nuint8\n\nfalse\n\nfalse\n\ntcp-keepalive-interval\n\n38\n\nuint32\n\nfalse\n\nfalse\n\ntcp-keepalive-garbage\n\n39\n\nboolean\n\nfalse\n\nfalse\n\nnis-domain\n\n40\n\nstring\n\nfalse\n\nfalse\n\nnis-servers\n\n41\n\nipv4-address\n\ntrue\n\nfalse\n\nntp-servers\n\n42\n\nipv4-address\n\ntrue\n\nfalse\n\nvendor-encapsulated-options\n\n43\n\nempty\n\nfalse\n\nfalse\n\nnetbios-name-servers\n\n44\n\nipv4-address\n\ntrue\n\nfalse\n\nnetbios-dd-server\n\n45\n\nipv4-address\n\ntrue\n\nfalse\n\nnetbios-node-type\n\n46\n\nuint8\n\nfalse\n\nfalse\n\nnetbios-scope\n\n47\n\nstring\n\nfalse\n\nfalse\n\nfont-servers\n\n48\n\nipv4-address\n\ntrue\n\nfalse\n\nx-display-manager\n\n49\n\nipv4-address\n\ntrue\n\nfalse\n\ndhcp-option-overload\n\n52\n\nuint8\n\nfalse\n\nfalse\n\ndhcp-server-identifier\n\n54\n\nipv4-address\n\nfalse\n\ntrue\n\ndhcp-message\n\n56\n\nstring\n\nfalse\n\nfalse\n\ndhcp-max-message-size\n\n57\n\nuint16\n\nfalse\n\nfalse\n\nvendor-class-identifier\n\n60\n\nstring\n\nfalse\n\nfalse\n\nnwip-domain-name\n\n62\n\nstring\n\nfalse\n\nfalse\n\nnwip-suboptions\n\n63\n\nbinary\n\nfalse\n\nfalse\n\nnisplus-domain-name\n\n64\n\nstring\n\nfalse\n\nfalse\n\nnisplus-servers\n\n65\n\nipv4-address\n\ntrue\n\nfalse\n\ntftp-server-name\n\n66\n\nstring\n\nfalse\n\nfalse\n\nboot-file-name\n\n67\n\nstring\n\nfalse\n\nfalse\n\nmobile-ip-home-agent\n\n68\n\nipv4-address\n\ntrue\n\nfalse\n\nsmtp-server\n\n69\n\nipv4-address\n\ntrue\n\nfalse\n\npop-server\n\n70\n\nipv4-address\n\ntrue\n\nfalse\n\nnntp-server\n\n71\n\nipv4-address\n\ntrue\n\nfalse\n\nwww-server\n\n72\n\nipv4-address\n\ntrue\n\nfalse\n\nfinger-server\n\n73\n\nipv4-address\n\ntrue\n\nfalse\n\nirc-server\n\n74\n\nipv4-address\n\ntrue\n\nfalse\n\nstreettalk-server\n\n75\n\nipv4-address\n\ntrue\n\nfalse\n\nstreettalk-directory-assistance-server\n\n76\n\nipv4-address\n\ntrue\n\nfalse\n\nuser-class\n\n77\n\nbinary\n\nfalse\n\nfalse\n\nslp-directory-agent\n\n78\n\nrecord (boolean, ipv4-address)\n\ntrue\n\nfalse\n\nslp-service-scope\n\n79\n\nrecord (boolean, string)\n\nfalse\n\nfalse\n\nnds-server\n\n85\n\nipv4-address\n\ntrue\n\nfalse\n\nnds-tree-name\n\n86\n\nstring\n\nfalse\n\nfalse\n\nnds-context\n\n87\n\nstring\n\nfalse\n\nfalse\n\nbcms-controller-names\n\n88\n\nfqdn\n\ntrue\n\nfalse\n\nbcms-controller-address\n\n89\n\nipv4-address\n\ntrue\n\nfalse\n\nclient-system\n\n93\n\nuint16\n\ntrue\n\nfalse\n\nclient-ndi\n\n94\n\nrecord (uint8, uint8, uint8)\n\nfalse\n\nfalse\n\nuuid-guid\n\n97\n\nrecord (uint8, binary)\n\nfalse\n\nfalse\n\nuap-servers\n\n98\n\nstring\n\nfalse\n\nfalse\n\ngeoconf-civic\n\n99\n\nbinary\n\nfalse\n\nfalse\n\npcode\n\n100\n\nstring\n\nfalse\n\nfalse\n\ntcode\n\n101\n\nstring\n\nfalse\n\nfalse\n\nv6-only-preferred\n\n108\n\nuint32\n\nfalse\n\nfalse\n\nnetinfo-server-address\n\n112\n\nipv4-address\n\ntrue\n\nfalse\n\nnetinfo-server-tag\n\n113\n\nstring\n\nfalse\n\nfalse\n\nv4-captive-portal\n\n114\n\nstring\n\nfalse\n\nfalse\n\nauto-config\n\n116\n\nuint8\n\nfalse\n\nfalse\n\nname-service-search\n\n117\n\nuint16\n\ntrue\n\nfalse\n\ndomain-search\n\n119\n\nfqdn\n\ntrue\n\nfalse\n\nvivco-suboptions\n\n124\n\nrecord (uint32, binary)\n\nfalse\n\nfalse\n\nvivso-suboptions\n\n125\n\nuint32\n\nfalse\n\nfalse\n\npana-agent\n\n136\n\nipv4-address\n\ntrue\n\nfalse\n\nv4-lost\n\n137\n\nfqdn\n\nfalse\n\nfalse\n\ncapwap-ac-v4\n\n138\n\nipv4-address\n\ntrue\n\nfalse\n\nsip-ua-cs-domains\n\n141\n\nfqdn\n\ntrue\n\nfalse\n\nrdnss-selection\n\n146\n\nrecord (uint8, ipv4-address, ipv4-address, fqdn)\n\ntrue\n\nfalse\n\nv4-portparams\n\n159\n\nrecord (uint8, psid)\n\nfalse\n\nfalse\n\noption-6rd\n\n212\n\nrecord (uint8, uint8, ipv6-address, ipv4-address)\n\ntrue\n\nfalse\n\nv4-access-domain\n\n213\n\nfqdn\n\nfalse\n\nfalse\n\nNote\n\nThe default-url option was replaced with v4-captive-portal in Kea 2.1.2, as introduced by RFC 8910. The new option has exactly the same format as the old one. The general perception is that default-url was seldom used. If you used it and migrating, please replace default-url with v4-captive-portal and your configuration will continue to work as before.\n\nKea also supports other options than those listed above; the following options are returned by the Kea engine itself and in general should not be configured manually.\n\n\n\nName\n\nCode\n\nType\n\nDescription\n\nThe following table lists all option types used in the previous two tables with a description of what values are accepted for them.\n\n\n\nName\n\nMeaning\n\nKea also supports the Relay Agent Information (RAI) option, sometimes referred to as the relay option, agent option, or simply option 82. The option itself is just a container and does not convey any information on its own. The following table contains a list of RAI sub-options that Kea can understand. The RAI and its sub-options are inserted by the relay agent and received by Kea; there is no need for Kea to be configured with those options.\n\n\n\nName\n\nCode\n\nComment\n\nAll other RAI sub-options can be used in client classification to classify incoming packets to specific classes and/or by flex-id to construct a unique device identifier.\n\n8.2.11. Custom DHCPv4 Options\n\nKea supports custom (non-standard) DHCPv4 options. Let’s say that we want to define a new DHCPv4 option called foo, which will have code 222 and will convey a single, unsigned, 32-bit integer value. Such an option can be defined by putting the following entry in the configuration file:\n\n\"Dhcp4\": { \"option-def\": [ { \"name\": \"foo\", \"code\": 222, \"type\": \"uint32\", \"array\": false, \"record-types\": \"\", \"space\": \"dhcp4\", \"encapsulate\": \"\" }, ... ], ... }\n\nThe false value of the array parameter determines that the option does NOT comprise an array of uint32 values but is, instead, a single value. Two other parameters have been left blank: record-types and encapsulate. The former specifies the comma-separated list of option data fields, if the option comprises a record of data fields. The record-types value should be non-empty if type is set to “record”; otherwise it must be left blank. The latter parameter specifies the name of the option space being encapsulated by the particular option. If the particular option does not encapsulate any option space, the parameter should be left blank. Note that the option-def configuration statement only defines the format of an option and does not set its value(s).\n\nThe name, code, and type parameters are required; all others are optional. The array default value is false. The record-types and encapsulate default values are blank (\"\"). The default space is dhcp4.\n\nOnce the new option format is defined, its value is set in the same way as for a standard option. For example, the following commands set a global value that applies to all subnets.\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"foo\", \"code\": 222, \"space\": \"dhcp4\", \"csv-format\": true, \"data\": \"12345\" }, ... ], ... }\n\nNew options can take more complex forms than the simple use of primitives (uint8, string, ipv4-address, etc.); it is possible to define an option comprising a number of existing primitives.\n\nFor example, say we want to define a new option that will consist of an IPv4 address, followed by an unsigned 16-bit integer, followed by a boolean value, followed by a text string. Such an option could be defined in the following way:\n\n\"Dhcp4\": { \"option-def\": [ { \"name\": \"bar\", \"code\": 223, \"space\": \"dhcp4\", \"type\": \"record\", \"array\": false, \"record-types\": \"ipv4-address, uint16, boolean, string\", \"encapsulate\": \"\" }, ... ], ... }\n\nThe type is set to \"record\" to indicate that the option contains multiple values of different types. These types are given as a comma-separated list in the record-types field and should be ones from those listed in List of standard DHCP option types.\n\nThe option’s values are set in an option-data statement as follows:\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"bar\", \"space\": \"dhcp4\", \"code\": 223, \"csv-format\": true, \"data\": \"192.0.2.100, 123, true, Hello World\" } ], ... }\n\ncsv-format is set to \"true\" to indicate that the data field comprises a comma-separated list of values. The values in data must correspond to the types set in the record-types field of the option definition.\n\nWhen array is set to \"true\" and type is set to \"record\", the last field is an array, i.e. it can contain more than one value, as in:\n\n\"Dhcp4\": { \"option-def\": [ { \"name\": \"bar\", \"code\": 223, \"space\": \"dhcp4\", \"type\": \"record\", \"array\": true, \"record-types\": \"ipv4-address, uint16\", \"encapsulate\": \"\" }, ... ], ... }\n\nThe new option content is one IPv4 address followed by one or more 16-bit unsigned integers.\n\nNote\n\nIn general, boolean values are specified as true or false, without quotes. Some specific boolean parameters may also accept \"true\", \"false\", 0, 1, \"0\", and \"1\".\n\nNote\n\nNumbers can be specified in decimal or hexadecimal format. The hexadecimal format can be either plain (e.g. abcd) or prefixed with 0x (e.g. 0xabcd).\n\n8.2.12. DHCPv4 Private Options\n\nOptions with a code between 224 and 254 are reserved for private use. They can be defined at the global scope or at the client-class local scope; this allows option definitions to be used depending on context, and option data to be set accordingly. For instance, to configure an old PXEClient vendor:\n\n\"Dhcp4\": { \"client-classes\": [ { \"name\": \"pxeclient\", \"test\": \"option[vendor-class-identifier].text == 'PXEClient'\", \"option-def\": [ { \"name\": \"configfile\", \"code\": 209, \"type\": \"string\" } ], ... }, ... ], ... }\n\nAs the Vendor-Specific Information (VSI) option (code 43) has a vendor-specific format, i.e. can carry either raw binary value or sub-options, this mechanism is also available for this option.\n\nIn the following example taken from a real configuration, two vendor classes use option 43 for different and incompatible purposes:\n\n\"Dhcp4\": { \"option-def\": [ { \"name\": \"cookie\", \"code\": 1, \"type\": \"string\", \"space\": \"APC\" }, { \"name\": \"mtftp-ip\", \"code\": 1, \"type\": \"ipv4-address\", \"space\": \"PXE\" }, ... ], \"client-classes\": [ { \"name\": \"APC\", \"test\": \"option[vendor-class-identifier].text == 'APC'\", \"option-def\": [ { \"name\": \"vendor-encapsulated-options\", \"type\": \"empty\", \"encapsulate\": \"APC\" } ], \"option-data\": [ { \"name\": \"cookie\", \"space\": \"APC\", \"data\": \"1APC\" }, { \"name\": \"vendor-encapsulated-options\" }, ... ], ... }, { \"name\": \"PXE\", \"test\": \"option[vendor-class-identifier].text == 'PXE'\", \"option-def\": [ { \"name\": \"vendor-encapsulated-options\", \"type\": \"empty\", \"encapsulate\": \"PXE\" } ], \"option-data\": [ { \"name\": \"mtftp-ip\", \"space\": \"PXE\", \"data\": \"0.0.0.0\" }, { \"name\": \"vendor-encapsulated-options\" }, ... ], ... }, ... ], ... }\n\nThe definition used to decode a VSI option is:\n\nThe local definition of a client class the incoming packet belongs to;\n\nIf none, the global definition;\n\nIf none, the last-resort definition described in the next section, DHCPv4 Vendor-Specific Options (backward-compatible with previous Kea versions).\n\nNote\n\nThis last-resort definition for the Vendor-Specific Information option (code 43) is not compatible with a raw binary value. When there are known cases where a raw binary value will be used, a client class must be defined with both a classification expression matching these cases and an option definition for the VSI option with a binary type and no encapsulation.\n\nNote\n\nBy default, in the Vendor-Specific Information option (code 43), sub-option code 0 and 255 mean PAD and END respectively, according to RFC 2132. In other words, the sub-option code values of 0 and 255 are reserved. Kea does, however, allow users to define sub-option codes from 0 to 255. If sub-options with codes 0 and/or 255 are defined, bytes with that value are no longer treated as a PAD or an END, but as the sub-option code when parsing a VSI option in an incoming query.\n\nOption 43 input processing (also called unpacking) is deferred so that it happens after classification. This means clients cannot be classified using option 43 sub-options. The definition used to unpack option 43 is determined as follows:\n\nIf defined at the global scope, this definition is used.\n\nIf defined at client class scope and the packet belongs to this class, the client class definition is used.\n\nIf not defined at global scope nor in a client class to which the packet belongs, the built-in last resort definition is used. This definition only says the sub-option space is \"vendor-encapsulated-options-space\".\n\nThe output definition selection is a bit simpler:\n\nIf the packet belongs to a client class which defines the option 43, use this definition.\n\nIf defined at the global scope, use this definition.\n\nOtherwise, use the built-in last-resort definition.\n\nSince they use a specific/per vendor option space, sub-options are defined at the global scope.\n\nNote\n\nOption definitions in client classes are allowed only for this limited option set (codes 43 and from 224 to 254), and only for DHCPv4.\n\n8.2.13. DHCPv4 Vendor-Specific Options\n\nCurrently there are two option spaces defined for the DHCPv4 daemon: dhcp4 (for the top-level DHCPv4 options) and \"vendor-encapsulated-options-space\", which is empty by default but in which options can be defined. Those options are carried in the Vendor-Specific Information option (code 43). The following examples show how to define an option foo with code 1 that comprises an IPv4 address, an unsigned 16-bit integer, and a string. The foo option is conveyed in a Vendor-Specific Information option.\n\nThe first step is to define the format of the option:\n\n\"Dhcp4\": { \"option-def\": [ { \"name\": \"foo\", \"code\": 1, \"space\": \"vendor-encapsulated-options-space\", \"type\": \"record\", \"array\": false, \"record-types\": \"ipv4-address, uint16, string\", \"encapsulate\": \"\" } ], ... }\n\n(Note that the option space is set to \"vendor-encapsulated-options-space\".) Once the option format is defined, the next step is to define actual values for that option:\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"foo\", \"space\": \"vendor-encapsulated-options-space\", \"code\": 1, \"csv-format\": true, \"data\": \"192.0.2.3, 123, Hello World\" } ], ... }\n\nIn this example, we also include the Vendor-Specific Information option, which conveys our sub-option foo. This is required; otherwise, the option will not be included in messages sent to the client.\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"vendor-encapsulated-options\" } ], ... }\n\nAlternatively, the option can be specified using its code.\n\n\"Dhcp4\": { \"option-data\": [ { \"code\": 43 } ], ... }\n\nAnother popular option that is often somewhat imprecisely called the “vendor option” is option 125. Its proper name is the “vendor-independent vendor-specific information option” or “vivso”. The idea behind vivso options is that each vendor has its own unique set of options with their own custom formats. The vendor is identified by a 32-bit unsigned integer called enterprise-number or vendor-id.\n\nThe standard spaces defined in Kea and their options are:\n\nvendor-4491: Cable Television Laboratories, Inc. for DOCSIS3 options:\n\noption code\n\noption name\n\noption description\n\nIn Kea each vendor is represented by its own vendor space. Since there are hundreds of vendors and sometimes they use different option definitions for different hardware, it is impossible for Kea to support them all natively. Fortunately, it’s easy to define support for new vendor options. Let’s take an example of the Genexis home gateway. This device requires sending the vivso 125 option with a sub-option 2 that contains a string with the TFTP server URL. To support such a device, three steps are needed: first, we need to define option definitions that will explain how the option is supposed to be formed. Second, we need to define option values. Third, we need to tell Kea when to send those specific options, which we can do via client classification.\n\nAn example snippet of a configuration could look similar to the following:\n\n{ // First, we need to define that the suboption 2 in vivso option for // vendor-id 25167 has a specific format (it's a plain string in this example). // After this definition, we can specify values for option tftp. \"option-def\": [ { // We define a short name, so the option can be referenced by name. // The option has code 2 and resides within vendor space 25167. // Its data is a plain string. \"name\": \"tftp\", \"code\": 2, \"space\": \"vendor-25167\", \"type\": \"string\" } ], \"client-classes\": [ { // We now need to tell Kea how to recognize when to use vendor space 25167. // Usually we can use a simple expression, such as checking if the device // sent a vivso option with specific vendor-id, e.g. \"vendor[4491].exists\". // Unfortunately, Genexis is a bit unusual in this aspect, because it // doesn't send vivso. In this case we need to look into the vendor class // (option code 60) and see if there's a specific string that identifies // the device. \"name\": \"cpe_genexis\", \"test\": \"substring(option[60].hex,0,7) == 'HMC1000'\", // Once the device is recognized, we want to send two options: // the vivso option with vendor-id set to 25167, and a suboption 2. \"option-data\": [ { \"name\": \"vivso-suboptions\", \"data\": \"25167\" }, // The suboption 2 value is defined as any other option. However, // we want to send this suboption 2, even when the client didn't // explicitly request it (often there is no way to do that for // vendor options). Therefore we use always-send to force Kea // to always send this option when 25167 vendor space is involved. { \"name\": \"tftp\", \"space\": \"vendor-25167\", \"data\": \"tftp://192.0.2.1/genexis/HMC1000.v1.3.0-R.img\", \"always-send\": true } ] } ] }\n\nBy default, Kea sends back only those options that are requested by a client, unless there are protocol rules that tell the DHCP server to always send an option. This approach works nicely in most cases and avoids problems with clients refusing responses with options they do not understand. However, the situation with vendor options is more complex, as they are not requested the same way as other options, are not well-documented in official RFCs, or vary by vendor.\n\nSome vendors (such as DOCSIS, identified by vendor option 4491) have a mechanism to request specific vendor options and Kea is able to honor those. Unfortunately, for many other vendors, such as Genexis (25167, discussed above), Kea does not have such a mechanism, so it cannot send any sub-options on its own. To solve this issue, we devised the concept of persistent options. Kea can be told to always send options, even if the client did not request them. This can be achieved by adding \"always-send\": true to the option definition. Note that in this particular case an option is defined in vendor space 25167. With always-send enabled, the option is sent every time there is a need to deal with vendor space 25167.\n\nAnother possibility is to redefine the option; see DHCPv4 Private Options.\n\nKea comes with several example configuration files. Some of them showcase how to configure options 60 and 43. See doc/examples/kea4/vendor-specific.json and doc/examples/kea6/vivso.json in the Kea sources.\n\nNote\n\nCurrently only one vendor is supported for the vivco-suboptions (code 124) and vivso-suboptions (code 125) options. Specifying multiple enterprise numbers within a single option instance or multiple options with different enterprise numbers is not supported.\n\n8.2.14. Nested DHCPv4 Options (Custom Option Spaces)\n\nIt is sometimes useful to define a completely new option space, such as when a user creates a new option in the standard option space (dhcp4) and wants this option to convey sub-options. Since they are in a separate space, sub-option codes have a separate numbering scheme and may overlap with the codes of standard options.\n\nNote that the creation of a new option space is not required when defining sub-options for a standard option, because one is created by default if the standard option is meant to convey any sub-options (see DHCPv4 Vendor-Specific Options).\n\nIf we want a DHCPv4 option called container with code 222, that conveys two sub-options with codes 1 and 2, we first need to define the new sub-options:\n\n\"Dhcp4\": { \"option-def\": [ { \"name\": \"subopt1\", \"code\": 1, \"space\": \"isc\", \"type\": \"ipv4-address\", \"record-types\": \"\", \"array\": false, \"encapsulate\": \"\" }, { \"name\": \"subopt2\", \"code\": 2, \"space\": \"isc\", \"type\": \"string\", \"record-types\": \"\", \"array\": false, \"encapsulate\": \"\" } ], ... }\n\nNote that we have defined the options to belong to a new option space (in this case, \"isc\").\n\nThe next step is to define a regular DHCPv4 option with the desired code and specify that it should include options from the new option space:\n\n\"Dhcp4\": { \"option-def\": [ ..., { \"name\": \"container\", \"code\": 222, \"space\": \"dhcp4\", \"type\": \"empty\", \"array\": false, \"record-types\": \"\", \"encapsulate\": \"isc\" } ], ... }\n\nThe name of the option space in which the sub-options are defined is set in the encapsulate field. The type field is set to \"empty\", to indicate that this option does not carry any data other than sub-options.\n\nFinally, we can set values for the new options:\n\n\"Dhcp4\": { \"option-data\": [ { \"name\": \"subopt1\", \"code\": 1, \"space\": \"isc\", \"data\": \"192.0.2.3\" }, } \"name\": \"subopt2\", \"code\": 2, \"space\": \"isc\", \"data\": \"Hello world\" }, { \"name\": \"container\", \"code\": 222, \"space\": \"dhcp4\" } ], ... }\n\nIt is possible to create an option which carries some data in addition to the sub-options defined in the encapsulated option space. For example, if the container option from the previous example were required to carry a uint16 value as well as the sub-options, the type value would have to be set to \"uint16\" in the option definition. (Such an option would then have the following data structure: DHCP header, uint16 value, sub-options.) The value specified with the data parameter — which should be a valid integer enclosed in quotes, e.g. \"123\" — would then be assigned to the uint16 field in the container option.\n\n8.2.15. Unspecified Parameters for DHCPv4 Option Configuration\n\nIn many cases it is not required to specify all parameters for an option configuration, and the default values can be used. However, it is important to understand the implications of not specifying some of them, as it may result in configuration errors. The list below explains the behavior of the server when a particular parameter is not explicitly specified:\n\nname - the server requires either an option name or an option code to identify an option. If this parameter is unspecified, the option code must be specified.\n\ncode - the server requires either an option name or an option code to identify an option; this parameter may be left unspecified if the name parameter is specified. However, this also requires that the particular option have a definition (either as a standard option or an administrator-created definition for the option using an option-def structure), as the option definition associates an option with a particular name. It is possible to configure an option for which there is no definition (unspecified option format). Configuration of such options requires the use of the option code.\n\nspace - if the option space is unspecified it defaults to dhcp4, which is an option space holding standard DHCPv4 options.\n\ndata - if the option data is unspecified it defaults to an empty value. The empty value is mostly used for the options which have no payload (boolean options), but it is legal to specify empty values for some options which carry variable-length data and for which the specification allows a length of 0. For such options, the data parameter may be omitted in the configuration.\n\ncsv-format - if this value is not specified, the server assumes that the option data is specified as a list of comma-separated values to be assigned to individual fields of the DHCP option.\n\n8.2.16. Support for Long Options\n\nThe kea-dhcp4 server partially supports long options (RFC3396). Since Kea 2.1.6, the server accepts configuring long options and suboptions (longer than 255 bytes). The options and suboptions are stored internally in their unwrapped form and they can be processed as usual using the parser language. On send, the server splits long options and suboptions into multiple options and suboptions, using the respective option code.\n\n\"option-def\": [ { \"array\": false, \"code\\\": 240, \"encapsulate\": \"\", \"name\": \"my-option\", \"space\": \"dhcp4\", \"type\": \"string\" } ], \"subnet4\": [ { \"subnet\": \"192.0.2.0/24\", \"reservations\": [ { \"hw-address\": \"aa:bb:cc:dd:ee:ff\", \"option-data\": [ { \"always-send\": false, \"code\": 240, \"name\": \"my-option\", \"csv-format\": true, \"data\": \"data -00010203040506070809-00010203040506070809-00010203040506070809-00010203040506070809 -00010203040506070809-00010203040506070809-00010203040506070809-00010203040506070809 -00010203040506070809-00010203040506070809-00010203040506070809-00010203040506070809 -data\", \"space\": \"dhcp4\" } ] } ] } ]\n\nNote\n\nFor this example, the data has been split on several lines, but Kea does not support this in the configuration file.\n\nThis example illustrates configuring a custom long option in a reservation. The server, when sending a response, will split this option into several options with the same code (11 options with option code 240).\n\nNote\n\nCurrently the server does not support storing long options in the databases, either host reservations or configuration backend.\n\nThe server is also able to receive packets with split options (options using the same option code) and to fuse the data chunks into one option. This is also supported for suboptions if each suboption data chunk also contains the suboption code and suboption length.\n\n8.2.17. Stateless Configuration of DHCPv4 Clients\n\nThe DHCPv4 server supports stateless client configuration, whereby the client has an IP address configured (e.g. using manual configuration) and only contacts the server to obtain other configuration parameters, such as addresses of DNS servers. To obtain the stateless configuration parameters, the client sends the DHCPINFORM message to the server with the ciaddr set to the address that the client is currently using. The server unicasts the DHCPACK message to the client that includes the stateless configuration (“yiaddr” not set).\n\nThe server responds to the DHCPINFORM when the client is associated with a subnet defined in the server’s configuration. An example subnet configuration looks like this:\n\n\"Dhcp4\": { \"subnet4\": [ { \"subnet\": \"192.0.2.0/24\" \"option-data\": [ { \"name\": \"domain-name-servers\", \"code\": 6, \"data\": \"192.0.2.200,192.0.2.201\", \"csv-format\": true, \"space\": \"dhcp4\" } ] } ] }\n\nThis subnet specifies the single option which will be included in the DHCPACK message to the client in response to DHCPINFORM. The subnet definition does not require the address pool configuration if it will be used solely for stateless configuration.\n\nThis server will associate the subnet with the client if one of the following conditions is met:\n\nThe DHCPINFORM is relayed and the giaddr matches the configured subnet.\n\nThe DHCPINFORM is unicast from the client and the ciaddr matches the configured subnet.\n\nThe DHCPINFORM is unicast from the client and the ciaddr is not set, but the source address of the IP packet matches the configured subnet.\n\nThe DHCPINFORM is not relayed and the IP address on the interface on which the message is received matches the configured subnet.\n\n8.2.18. Client Classification in DHCPv4\n\nThe DHCPv4 server includes support for client classification. For a deeper discussion of the classification process, see Client Classification.\n\nIn certain cases it is useful to configure the server to differentiate between DHCP client types and treat them accordingly. Client classification can be used to modify the behavior of almost any part of DHCP message processing. Kea currently offers client classification via private options and option 43 deferred unpacking; subnet selection; pool selection; assignment of different options; and, for cable modems, specific options for use with the TFTP server address and the boot file field.\n\nKea can be instructed to limit access to given subnets based on class information. This is particularly useful for cases where two types of devices share the same link and are expected to be served from two different subnets. The primary use case for such a scenario is cable networks, where there are two classes of devices: the cable modem itself, which should be handed a lease from subnet A; and all other devices behind the modem, which should get leases from subnet B. That segregation is essential to prevent overly curious end-users from playing with their cable modems. For details on how to set up class restrictions on subnets, see Configuring Subnets With Class Information.\n\nWhen subnets belong to a shared network, the classification applies to subnet selection but not to pools; that is, a pool in a subnet limited to a particular class can still be used by clients which do not belong to the class, if the pool they are expected to use is exhausted. The limit on access based on class information is also available at the pool level within a subnet: see Configuring Pools With Class Information. This is useful when segregating clients belonging to the same subnet into different address ranges.\n\nIn a similar way, a pool can be constrained to serve only known clients, i.e. clients which have a reservation, using the built-in KNOWN or UNKNOWN classes. Addresses can be assigned to registered clients without giving a different address per reservation: for instance, when there are not enough available addresses. The determination whether there is a reservation for a given client is made after a subnet is selected, so it is not possible to use KNOWN/UNKNOWN classes to select a shared network or a subnet.\n\nThe process of classification is conducted in five steps. The first step is to assess an incoming packet and assign it to zero or more classes. The second step is to choose a subnet, possibly based on the class information. When the incoming packet is in the special class DROP, it is dropped and a debug message logged. The next step is to evaluate class expressions depending on the built-in KNOWN/UNKNOWN classes after host reservation lookup, using them for pool selection and assigning classes from host reservations. The list of required classes is then built and each class of the list has its expression evaluated; when it returns true, the packet is added as a member of the class. The last step is to assign options, again possibly based on the class information. More complete and detailed information is available in Client Classification.\n\nThere are two main methods of classification. The first is automatic and relies on examining the values in the vendor class options or the existence of a host reservation. Information from these options is extracted, and a class name is constructed from it and added to the class list for the packet. The second method specifies an expression that is evaluated for each packet. If the result is true, the packet is a member of the class.\n\nNote\n\nThe new early-global-reservations-lookup global parameter flag enables a lookup for global reservations before the subnet selection phase. This lookup is similar to the general lookup described above with two differences:\n\nthe lookup is limited to global host reservations\n\nthe UNKNOWN class is never set\n\nNote\n\nCare should be taken with client classification, as it is easy for clients that do not meet class criteria to be denied all service.\n\n8.2.18.1. Setting Fixed Fields in Classification\n\nIt is possible to specify that clients belonging to a particular class should receive packets with specific values in certain fixed fields. In particular, three fixed fields are supported: next-server (conveys an IPv4 address, which is set in the siaddr field), server-hostname (conveys a server hostname, can be up to 64 bytes long, and is sent in the sname field) and boot-file-name (conveys the configuration file, can be up to 128 bytes long, and is sent using the file field).\n\nObviously, there are many ways to assign clients to specific classes, but for PXE clients the client architecture type option (code 93) seems to be particularly suited to make the distinction. The following example checks whether the client identifies itself as a PXE device with architecture EFI x86-64, and sets several fields if it does. See Section 2.1 of RFC 4578) or the client documentation for specific values.\n\n\"Dhcp4\": { \"client-classes\": [ { \"name\": \"ipxe_efi_x64\", \"test\": \"option[93].hex == 0x0009\", \"next-server\": \"192.0.2.254\", \"server-hostname\": \"hal9000\", \"boot-file-name\": \"/dev/null\" }, ... ], ... }\n\nIf an incoming packet is matched to multiple classes, then the value used for each field will come from the first class that specifies the field, in the order the classes are assigned to the packet.\n\nNote\n\nThe classes are ordered as specified in the configuration.\n\n8.2.18.2. Using Vendor Class Information in Classification\n\nThe server checks whether an incoming packet includes the vendor class identifier option (60). If it does, the content of that option is prepended with VENDOR_CLASS_, and it is interpreted as a class. For example, modern cable modems send this option with value docsis3.0, so the packet belongs to the class VENDOR_CLASS_docsis3.0.\n\nNote\n\nCertain special actions for clients in VENDOR_CLASS_docsis3.0 can be achieved by defining VENDOR_CLASS_docsis3.0 and setting its next-server and boot-file-name values appropriately.\n\nThis example shows a configuration using an automatically generated VENDOR_CLASS_ class. The administrator of the network has decided that addresses from the range 192.0.2.10 to 192.0.2.20 are going to be managed by the Dhcp4 server and only clients belonging to the DOCSIS 3.0 client class are allowed to use that pool.\n\n\"Dhcp4\": { \"subnet4\": [ { \"subnet\": \"192.0.2.0/24\", \"pools\": [ { \"pool\": \"192.0.2.10 - 192.0.2.20\" } ], \"client-class\": \"VENDOR_CLASS_docsis3.0\" } ], ... }\n\n8.2.18.3. Defining and Using Custom Classes\n\nThe following example shows how to configure a class using an expression and a subnet using that class. This configuration defines the class named Client_foo. It is comprised of all clients whose client IDs (option 61) start with the string foo. Members of this class will be given addresses from 192.0.2.10 to 192.0.2.20 and the addresses of their DNS servers set to 192.0.2.1 and 192.0.2.2.\n\n\"Dhcp4\": { \"client-classes\": [ { \"name\": \"Client_foo\", \"test\": \"substring(option[61].hex,0,3) == 'foo'\", \"option-data\": [ { \"name\": \"domain-name-servers\", \"code\": 6, \"space\": \"dhcp4\", \"csv-format\": true, \"data\": \"192.0.2.1, 192.0.2.2\" } ] }, ... ], \"subnet4\": [ { \"subnet\": \"192.0.2.0/24\", \"pools\": [ { \"pool\": \"192.0.2.10 - 192.0.2.20\" } ], \"client-class\": \"Client_foo\" }, ... ], ... }\n\n8.2.18.4. Required Classification\n\nIn some cases it is useful to limit the scope of a class to a shared network, subnet, or pool. There are two parameters which are used to limit the scope of the class by instructing the server to evaluate test expressions when required.\n\nThe first one is the per-class only-if-required flag, which is false by default. When it is set to true, the test expression of the class is not evaluated at the reception of the incoming packet but later, and only if the class evaluation is required.\n\nThe second is require-client-classes, which takes a list of class names and is valid in shared-network, subnet, and pool scope. Classes in these lists are marked as required and evaluated after selection of this specific shared network/subnet/pool and before output-option processing.\n\nIn this example, a class is assigned to the incoming packet when the specified subnet is used:\n\n\"Dhcp4\": { \"client-classes\": [ { \"name\": \"Client_foo\", \"test\": \"member('ALL')\", \"only-if-required\": true }, ... ], \"subnet4\": [ { \"subnet\": \"192.0.2.0/24\", \"pools\": [ { \"pool\": \"192.0.2.10 - 192.0.2.20\" } ], \"require-client-classes\": [ \"Client_foo\" ], ... }, ... ], ... }\n\nRequired evaluation can be used to express complex dependencies like subnet membership. It can also be used to reverse the precedence; if option-data is set in a subnet, it takes precedence over option-data in a class. If option-data is moved to a required class and required in the subnet, a class evaluated earlier may take precedence.\n\nRequired evaluation is also available at the shared-network and pool levels. The order in which required classes are considered is: shared-network, subnet, and pool, i.e. in the reverse order from the way in which option-data is processed.\n\n8.2.19. DDNS for DHCPv4\n\nAs mentioned earlier, kea-dhcp4 can be configured to generate requests to the DHCP-DDNS server, kea-dhcp-ddns, (referred to herein as “D2”) to update DNS entries. These requests are known as NameChangeRequests or NCRs. Each NCR contains the following information:\n\nWhether it is a request to add (update) or remove DNS entries.\n\nWhether the change requests forward DNS updates (A records), reverse DNS updates (PTR records), or both.\n\nThe Fully Qualified Domain Name (FQDN), lease address, and DHCID (information identifying the client associated with the FQDN).\n\nDDNS-related parameters are split into two groups:\n\nConnectivity Parameters\n\nThese are parameters which specify where and how kea-dhcp4 connects to and communicates with D2. These parameters can only be specified within the top-level dhcp-ddns section in the kea-dhcp4 configuration. The connectivity parameters are listed below:\n\nenable-updates\n\nserver-ip\n\nserver-port\n\nsender-ip\n\nsender-port\n\nmax-queue-size\n\nncr-protocol\n\nncr-format\"\n\nBehavioral Parameters\n\nThese parameters influence behavior such as how client host names and FQDN options are handled. They have been moved out of the dhcp-ddns section so that they may be specified at the global, shared-network, and/or subnet levels. Furthermore, they are inherited downward from global to shared-network to subnet. In other words, if a parameter is not specified at a given level, the value for that level comes from the level above it. The behavioral parameters are as follows:\n\nddns-send-updates\n\nddns-override-no-update\n\nddns-override-client-update\n\nddns-replace-client-name\"\n\nddns-generated-prefix\n\nddns-qualifying-suffix\n\nddns-update-on-renew\n\nddns-use-conflict-resolution\n\nhostname-char-set\n\nhostname-char-replacement\n\nNote\n\nFor backward compatibility, configuration parsing still recognizes the original behavioral parameters specified in dhcp-ddns, by translating the parameter into its global equivalent. If a parameter is specified both globally and in dhcp-ddns, the latter value is ignored. In either case, a log is emitted explaining what has occurred. Specifying these values within dhcp-ddns is deprecated and support for it will be removed.\n\nThe default configuration and values would appear as follows:\n\n\"Dhcp4\": { \"dhcp-ddns\": { // Connectivity parameters \"enable-updates\": false, \"server-ip\": \"127.0.0.1\", \"server-port\":53001, \"sender-ip\":\"\", \"sender-port\":0, \"max-queue-size\":1024, \"ncr-protocol\":\"UDP\", \"ncr-format\":\"JSON\" }, // Behavioral parameters (global) \"ddns-send-updates\": true, \"ddns-override-no-update\": false, \"ddns-override-client-update\": false, \"ddns-replace-client-name\": \"never\", \"ddns-generated-prefix\": \"myhost\", \"ddns-qualifying-suffix\": \"\", \"ddns-update-on-renew\": false, \"ddns-use-conflict-resolution\": true, \"hostname-char-set\": \"\", \"hostname-char-replacement\": \"\" ... }\n\nThere are two parameters which determine if kea-dhcp4 can generate DDNS requests to D2: the existing dhcp-ddns:enable-updates parameter, which now only controls whether kea-dhcp4 connects to D2; and the new behavioral parameter, ddns-send-updates, which determines whether DDNS updates are enabled at a given level (i.e. global, shared-network, or subnet). The following table shows how the two parameters function together:\n\n\n\ndhcp-ddns: enable-updates\n\nGlobal ddns-send-updates\n\nOutcome\n\nKea 1.9.1 added two new parameters; the first is ddns-update-on-renew. Normally, when leases are renewed, the server only updates DNS if the DNS information for the lease (e.g. FQDN, DNS update direction flags) has changed. Setting ddns-update-on-renew to true instructs the server to always update the DNS information when a lease is renewed, even if its DNS information has not changed. This allows Kea to “self-heal” if it was previously unable to add DNS entries or they were somehow lost by the DNS server.\n\nNote\n\nSetting ddns-update-on-renew to true may impact performance, especially for servers with numerous clients that renew often.\n\nThe second parameter added in Kea 1.9.1 is ddns-use-conflict-resolution. The value of this parameter is passed by kea-dhcp4 to D2 with each DNS update request. When true (the default value), D2 employs conflict resolution, as described in RFC 4703, when attempting to fulfill the update request. When false, D2 simply attempts to update the DNS entries per the request, regardless of whether they conflict with existing entries owned by other DHCPv4 clients.\n\nNote\n\nSetting ddns-use-conflict-resolution to false disables the overwrite safeguards that the rules of conflict resolution (from RFC 4703) are intended to prevent. This means that existing entries for an FQDN or an IP address made for Client-A can be deleted or replaced by entries for Client-B. Furthermore, there are two scenarios by which entries for multiple clients for the same key (e.g. FQDN or IP) can be created.\n\n1. Client-B uses the same FQDN as Client-A but a different IP address. In this case, the forward DNS entries (A and DHCID RRs) for Client-A will be deleted as they match the FQDN and new entries for Client-B will be added. The reverse DNS entries (PTR and DHCID RRs) for Client-A, however, will not be deleted as they belong to a different IP address, while new entries for Client-B will still be added.\n\n2. Client-B uses the same IP address as Client-A but a different FQDN. In this case the reverse DNS entries (PTR and DHCID RRs) for Client-A will be deleted as they match the IP address, and new entries for Client-B will be added. The forward DNS entries (A and DHCID RRs) for Client-A, however, will not be deleted, as they belong to a different FQDN, while new entries for Client-B will still be added.\n\nDisabling conflict resolution should be done only after careful review of specific use cases. The best way to avoid unwanted DNS entries is to always ensure lease changes are processed through Kea, whether they are released, expire, or are deleted via the lease-del4 command, prior to reassigning either FQDNs or IP addresses. Doing so causes kea-dhcp4 to generate DNS removal requests to D2.\n\nNote\n\nThe DNS entries Kea creates contain a value for TTL (time to live). Since Kea 1.9.3, kea-dhcp4 calculates that value based on RFC 4702, Section 5, which suggests that the TTL value be 1/3 of the lease’s lifetime, with a minimum value of 10 minutes. In earlier versions, the server set the TTL value equal to the lease’s valid lifetime.\n\n8.2.19.1. DHCP-DDNS Server Connectivity\n\nFor NCRs to reach the D2 server, kea-dhcp4 must be able to communicate with it. kea-dhcp4 uses the following configuration parameters to control this communication:\n\nenable-updates - Enables connectivity to kea-dhcp-ddns such that DDNS updates can be constructed and sent. It must be true for NCRs to be generated and sent to D2. It defaults to false.\n\nserver-ip - This is the IP address on which D2 listens for requests. The default is the local loopback interface at address 127.0.0.1. Either an IPv4 or IPv6 address may be specified.\n\nserver-port - This is the port on which D2 listens for requests. The default value is 53001.\n\nsender-ip - This is the IP address which kea-dhcp4 uses to send requests to D2. The default value is blank, which instructs kea-dhcp4 to select a suitable address.\n\nsender-port - This is the port which kea-dhcp4 uses to send requests to D2. The default value of 0 instructs kea-dhcp4 to select a suitable port.\n\nmax-queue-size - This is the maximum number of requests allowed to queue while waiting to be sent to D2. This value guards against requests accumulating uncontrollably if they are being generated faster than they can be delivered. If the number of requests queued for transmission reaches this value, DDNS updating is turned off until the queue backlog has been sufficiently reduced. The intent is to allow the kea-dhcp4 server to continue lease operations without running the risk that its memory usage grows without limit. The default value is 1024.\n\nncr-protocol - This specifies the socket protocol to use when sending requests to D2. Currently only UDP is supported.\n\nncr-format - This specifies the packet format to use when sending requests to D2. Currently only JSON format is supported.\n\nBy default, kea-dhcp-ddns is assumed to be running on the same machine as kea-dhcp4, and all of the default values mentioned above should be sufficient. If, however, D2 has been configured to listen on a different address or port, these values must be altered accordingly. For example, if D2 has been configured to listen on 192.168.1.10 port 900, the following configuration is required:\n\n\"Dhcp4\": { \"dhcp-ddns\": { \"server-ip\": \"192.168.1.10\", \"server-port\": 900, ... }, ... }\n\n8.2.19.2. When Does the kea-dhcp4 Server Generate a DDNS Request?\n\nkea-dhcp4 follows the behavior prescribed for DHCP servers in RFC 4702. It is important to keep in mind that kea-dhcp4 makes the initial decision of when and what to update and forwards that information to D2 in the form of NCRs. Carrying out the actual DNS updates and dealing with such things as conflict resolution are within the purview of D2 itself (see The DHCP-DDNS Server). This section describes when kea-dhcp4 generates NCRs and the configuration parameters that can be used to influence this decision. It assumes that both the connectivity parameter enable-updates and the behavioral parameter ddns-send-updates, are true.\n\nIn general, kea-dhcp4 generates DDNS update requests when:\n\nA new lease is granted in response to a DHCPREQUEST;\n\nAn existing lease is renewed but the FQDN associated with it has changed; or\n\nAn existing lease is released in response to a DHCPRELEASE.\n\nIn the second case, lease renewal, two DDNS requests are issued: one request to remove entries for the previous FQDN, and a second request to add entries for the new FQDN. In the third case, a lease release - a single DDNS request - to remove its entries will be made.\n\nAs for the first case, the decisions involved when granting a new lease are more complex. When a new lease is granted, kea-dhcp4 generates a DDNS update request if the DHCPREQUEST contains either the FQDN option (code 81) or the Host Name option (code 12). If both are present, the server uses the FQDN option. By default, kea-dhcp4 respects the FQDN N and S flags specified by the client as shown in the following table:\n\n\n\nClient Flags:N-S\n\nClient Intent\n\nServer Response\n\nServer Flags:N-S-O\n\nThe first row in the table above represents “client delegation.” Here the DHCP client states that it intends to do the forward DNS updates and the server should do the reverse updates. By default, kea-dhcp4 honors the client’s wishes and generates a DDNS request to the D2 server to update only reverse DNS data. The parameter ddns-override-client-update can be used to instruct the server to override client delegation requests. When this parameter is true, kea-dhcp4 disregards requests for client delegation and generates a DDNS request to update both forward and reverse DNS data. In this case, the N-S-O flags in the server’s response to the client will be 0-1-1 respectively.\n\n(Note that the flag combination N=1, S=1 is prohibited according to RFC 4702. If such a combination is received fr"
    }
}