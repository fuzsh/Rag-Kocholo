{
    "id": "dbpedia_2923_3",
    "rank": 90,
    "data": {
        "url": "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/ProtocolTheory.html",
        "read_more_link": "",
        "language": "en",
        "title": "Chapter 3: Theory of Operation: Protocols",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ixialogo.gif",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/pdf.gif",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/pdf.gif",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/prev.gif",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/next.gif",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/index.gif",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/sample_ospf_netw.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ext_vs_int_bgp.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/bgp4fig.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/gen_bgp_update.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/bgpl3vpn1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/bgp_exten_comm.jpg",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/vpn_ipv4_format.jpg",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/vpnvrfs1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ISIStopo1.jpg",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/rsvpte.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/rsvpfstrr3.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/rsvpfstrr4.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ldppwe3.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ldppwe3pwdiag2.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/pimsmtree1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/pimsmsgmap1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/pimssmdiag1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/mvpns2.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ptp_diagram.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ptp_rate_local.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/atmvpivci1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ldpatmaal5form1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ldpatmbreth3.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ldpatmbreth4.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ldpatmbreth1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ldpatmbreth2.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ldpatmllcenc2.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ldpatmllcenc1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ldpatmllcenc1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/grepacket2.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/grepacket1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/grepacketip1.png",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/prev.gif",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/next.gif",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/index.gif",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/email.gif",
            "http://downloads.ixiacom.com/library/user_guides/IxOS/6.30/EA_6.30_Rev_A/IxiaReferenceGuide/images/ixialogo.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Protocol Server\n\nMost ports in an Ixia chassis operate a Protocol Server. The Protocol Server includes a complete TCP/IP stack, allowing different forms of high-level DUT testing. The Protocol Server can be configured to test a set of provided Level 2 and Level 3 protocols, which include MAC and IP addressing and IP routing. The Protocol Server for Packet over SONET cards omits all MAC configuration items, since POS does not use a MAC layer. The information gathered by the Protocol Server is used within generated frame data, as well.\n\nThe Protocol Server can be accessed through the IxRouter Window. Each protocol must be individually enabled for a selected port in the IxRouter Window.\n\nThe protocols supported by the Ixia Protocol Server are described in the following sections in this chapter:\n\nTable 3-1. Protocols Supported by Ixia Protocol Server\n\nAddress Resolution Protocol (non-POS only)\n\n(includes IP to MAC addressing)\n\nInternet Gateway Management Protocol\n\nOpen Shortest Path First Protocol\n\nOpen Shortest Path First Protocol Version 3 (for IPv6)\n\nBorder Gateway Protocol\n\nRouting Information Protocol\n\nRouting Information Protocol: Next Generation (for IPV6)\n\nIntermediate System to Intermediate System (Dual Mode)\n\nResource ReSerVation Protocol: with Traffic Engineering Extensions\n\nLabel Distribution Protocol\n\nMulticast Listener Discovery\n\nProtocol Independent Multicast: Sparse Mode\n\nMulti-Protocol Label Switching\n\nBi-Directional Forwarding\n\nConnectivity Fault Management\n\nFibre Channel over Ethernet (FCoE), FCoE Initialization Protocol (FIP) and NPIV\n\nPrecision Time Protocol (PTP)\n\nThere are additional sections on the following topics:\n\nARP\n\nThe Address Resolution Protocol (ARP) facility controls the manner in which ARP requests are sent. This option is only available on Ethernet load modules. The resulting responses from ARP requests are held in the ARP Table, which is used to set MAC addresses for transmitted data. ARP'ing the Device Under Test (DUT) allows tests and generated frames to be configured with a specific IP address, which at run time is associated with the MAC address of that particular DUT.\n\nIP\n\nThe IP table within the ARP window specifies a per-port correspondence between IP addresses, MAC addresses (for Ethernet ports only), and the Default Gateway. IP addresses may be expressed as individual addresses or as a range of addresses.\n\nAll ARP requests (for Ethernet) are sent to the Default Gateway address. In most cases, the Default Gateway Address is the address of the DUT. When a gateway separates the Ixia port from the DUT, use the IP address of that gateway as the Default.\n\nIGMP\n\nThe Internet Group Management Protocol (IGMP) is used with IPv4 to control the handling of group membership in the Internet. Version 3, specified in RFC 3376, is supported and is interoperable with Versions 1 and 2. Version 1 of the protocol is specified in RFC 1112, and Version 2 is specified in RFC 2236.\n\nIGMP normally works in an environment in which there are a number of IGMP-capable hosts connected to one or more IGMP routers. The routers forward membership information and packets to other IGMP routers and receive group membership information and packets from other IGMP routers.\n\nThe Ixia hardware simulates one or more hosts, while the DUTs are assumed to be IGMP routers. The simulation calls for groups of simulated hosts to respond to IGMP router-generated queries and to automatically generate reports at regular intervals. A number of IGMP groups are randomly shared across a group of hosts.\n\nVersion 3 adds the concept of filtering, based on the IP source address, to cut down on the reception of unwanted multicast traffic. This filtering consists of limiting the receipt of packets to only those from specific sources (INCLUDE) or to those from all but specific sources (EXCLUDE). Refer to MLD on page 3-28 for information about similar functions for multicast traffic in IPv6 environments.\n\nCompatibility with earlier versions of IGMP is an important part of IGMPv3. The Group Compatibility Modes for an IGMPv3 router are summarized as follows:\n\nOSPF\n\nOpen Shortest Path First (OSPF) is a set of messaging protocols that are used by routers located within a single Autonomous System (AS). The Ixia hardware simulates one or more OSPF routers for the purpose of testing one or more DUT routers configured for OSPF. The OSPF version 2 specification (RFC 2328) details the message exchanges by OSPF routers, as well as the meanings and usage.\n\nOSPF has the following three principal stages:\n\nWhen an OSPF router initializes, it sends out HELLO packets and learns of its neighboring routers by receiving their HELLO packets. If the router is on a Point-to-Point link, or on an Ethernet (transit network) link, these packets are addressed to the AllSPFRouters multicast address (224.0.0.5). In these types of networks, there is no need to manually configure any neighbor information for the routers.\n\nEach router that is traversed on the path between neighbors is added to a list contained in the HELLO packet. In this way, each router discovers the shared set of neighbors and creates individual state machines corresponding to each of its neighbors.\n\nIf the network type is broadcast, then the process for selecting a Designated Router (DR) and Backup Designated Router (BDR) begins. A Designated Router is used to reduce the number of adjacencies required in a broadcast network. That is, if no Designated Router is used, then each router must pair (form an adjacency) with each of the other routers. In this case, the number of required adjacencies is equal to the square of the number of routers (N^2). If a DR and BDR are used, the number of required adjacencies drops to 2 times the number of routers (2N). Currently, the Ixia ports are unable to simulate a DR or BDR.\n\nOnce the routers have initialized their adjacency databases, they synchronize their databases. This process involves one router becoming the master and the other becoming the subordinate. On Ethernet networks, the DR is always the master; on point-to-point networks, the router with the highest Router ID is the master.\n\nLink State Advertisements (LSAs) are OSPF messages that describe an OSPF router's local environment. The simplest LSA Type is the router-LSA (RouterLinks LSA). Each router is required to generate exactly one of these LSAs to describe its own attached interfaces. If a network that consists of a single OSPF area is being simulated with only point-to-point links and there are no Autonomous System Border Routers (ASBR), then this is the only type of LSA that is sent.\n\nThe subordinate asks the master for its LSA (Link State Advertisement) headers, which enables the subordinate to determine the following information:\n\nThe subordinate router then proceeds to explicitly query the master to send it each LSA from Steps (1) and (2). The subordinate sends an ACK to the master upon receipt of each LSA. The global Link State Database (LSDB) is constructed by each router, based on LSAs from all the other routers in the network.\n\nOnce this exchange process is complete, the routers are considered to have reached Full Adjacency, and each runs the link state algorithm to update its IP forwarding tables. The routers continue to exchange periodic HELLO packets, as keepalive messages, until a change occurs (for example, a link goes down or an LSA expires). OSPF routers continue to periodically exchange their LSAs every 30 minutes to ensure that they all hold identical LSDBs.\n\nThis section describes the programming of the Ixia hardware related to OSPF testing, as well as the theory of operation and protocol message formats. The Ixia hardware simulates multiple OSPF routers on multiple networks. For example, in Figure 3-1 on page 3-5 there are three networks and three routers.\n\nFigure 3-1. Sample OSPF Network\n\nThe Protocol Server calls for the specification of router-network connections to be specified in a network-centric fashion. One specifies the network in terms of an Area ID and network mask. One specifies the routers in terms of the interface IP address on that network and Router ID, usually the lowest IP address for the router. For the sample OSPF network, in which Router 3 is the DUT, the three networks are specified by their significant characteristics as shown in Table 3-2 on page 3-6.\n\nTable 3-2. Sample OSPF Network Assignments\n\nNetwork\n\nArea ID\n\nNetwork Mask\n\nRouter ID\n\nRouter Interface\n\nIP Address\n\n1\n\n192.168.36.0\n\n255.255.255.0\n\n192.168.36.10\n\n10.0.0.40\n\n2\n\n172.16.0.0\n\n255.255.255.0\n\n172.16.0.20\n\n10.0.0.41\n\n3\n\n10.0.0.0\n\n255.255.0.0\n\n10.0.0.40\n\n10.0.0.41\n\n10.0.0.90\n\n10.0.0.40\n\n10.0.0.41\n\n10.0.0.90\n\nWithin this framework, Link State Advertisements (LSAs) may be issued from the perspective of any interface on any router. Any OSPF messages from the DUT Routers may be captured and analyzed in the normal manner.\n\nOSPFv3\n\nOpen Shortest Path First Protocol Version 3 supports Internet Protocol version 6 (IPv6), as defined in RFC 2740. The 128-bit IPv6 addressing scheme has been accommodated in OSPF through the use of new LSA types.\n\nSome of the differences between OSPFv2 (for IPv4) and OSPFv3 (for IPv6) are listed as follows:\n\nBGP4/BGP+\n\nBorder Gateway Protocol Version 4 (BGP-4) is the principal protocol used in the Internet backbone and in networks for large organizations. The BGP4 specification (RFC 1771) details the messages exchanged by BGP routers, as well as their meaning and usage. BGP4 - Inter-Domain Routing in the Internet, by John W. Stewart III is a descriptive reference on this protocol.\n\nInternal Versus External BGP\n\nThe BGP4 protocol is used according to two sets of rules, depending on whether or not the two communicating BGP routers are within the same Autonomous System (AS). An AS is a collection of routers that implement the same routing policy and are typically administered by a single group of administrators. ASs connected to the Internet are assigned Autonomous System Numbers (ASNs) that are key to inter-domain routing. When BGP is used between two ASs, the protocol is referred to as EBGP (External BGP); when BGP is used within an AS it is referred to as IBGP (Internal BGP). Figure 3-2 on page 3-8 depicts the differences in topology between EBGP versus IBGP.\n\nFigure 3-2. External BGP Versus Internal BGP\n\nIn the figure above, AS1, AS2, and AS3 are distinct Autonomous Systems. The Rns are routers in the various ASs. Routers on the links between ASs `speak' EBGP, while the routers within AS3 `speak' IBGP.\n\nIBGP Extensions\n\nIn the original BGP4 specification (RFC 1771), all IBGP routers within an AS are required to establish a full mesh with each other. This leads to a lack of scalability which is solved by the introduction of two additional concepts: route Reflection and Confederations.\n\nIn route reflection, some routers in an AS are assigned the task of re-distributing internal routes to other internal AS routers. To prevent looping within an AS that uses route reflection, two concepts are important: the originator-id and cluster-list attributes.The originator-id is the identification of the router that originated a particular route. Routers within an AS propagate this information and refuse to send a route back to its originator. Even the use of route reflectors and originator-ids can lead to scalability problems in an AS. The cluster-list concept helps this problem. A cluster consists of a reflecting router and its clients. A Cluster ID is the IP address of the reflecting router if there is one, or a configured number otherwise. A cluster-list is a constructed list, consisting of the cluster IDs of all of the clusters that a route has passed through. Each router refuses to send a route back to a cluster that has seen the route already.\n\nIn a confederation, an AS is divided into multiple sub-confederation subsets. Each sub-confederation is defined in terms of its own ASN and a list of routers. Routers within a sub-confederation are expected to fully mesh using IGP. Sub-confederations within a confederation speak a variant of EGP, called EIGP. Additional path attributes are used with a confederation to indicate paths that should not be propagated outside the confederation.\n\nCommunities\n\nIn deployment of BGP4 into a growing Internet environment, it became necessary to deal with certain routes in different manners not related to the strict routing of packets. The community attribute was invented to allow a route to be `tagged' with multiple numbers, called communities. This is also referred to sometimes as route coloring.\n\nBGP Router Test Configuration\n\nThe Ixia Protocol server implements an environment in which the Ixia hardware simulates multiple routers which speak IBGP and/or EBGP with one or more DUT routers. For example, in Figure 3-2 on page 3-8, the Ixia hardware emulates R1, R3, and R5 while the DUTs are R2 and R4. The following figure depicts the same setup based on the location of the simulated or actual router:\n\nFigure 3-3. BGP Interconnection Environment\n\nAll of the routers are logically connected through appropriate networking hardware. The Ixia hardware is used to simulate three of the routers in two different ASs communicating with two routers being tested.\n\nA single router emulated by the Ixia hardware is specified by a single IP address, and a number of emulated routers may be specified by a range of IP addresses. Each DUT router is identified by its IP address.\n\nMessages may be sent between the emulated routers and the DUT routers when a connection is made and one of the two endpoints sends an OPEN message. Where the emulated routers and the DUT routers send their OPEN messages simultaneously, standard collision handling is applied. Thereafter, the emulated routers send a number of UPDATE messages to the DUT routers. The UPDATE messages contain a number of network address ranges (route ranges), also known as ranges of prefixes. The ranges of generated network addresses is illustrated in Figure 3-4 on page 3-10.\n\nFigure 3-4. Generation of Network Addresses in BGP UPDATE Messages\n\nA designated number of network addresses are generated with network Mask Width with the From through To values. Table 3-3 on page 3-11 shows some examples of generated addresses. Network Addresses are generated by starting with the First Route and From mask width up to, but not including 224.0.0.0. (127.*.*.* is also skipped). If the requested number of network addresses has not been generated before 224.0.0.0 is reached, then the next mask length is used with the First Route to generate network addresses.\n\nTable 3-3. Examples of Generated BGP Routes (Network Addresses)\n\nFirst Route\n\nMask Width From\n\nMask Width\n\nTo\n\nIterator Step\n\nNumber of Routes\n\nGenerated BGP Routes\n\n(Network Addresses)\n\n192.168.36.0\n\n24\n\n26\n\n1\n\n(14,378,756 Max.)\n\n192.168.36.0/24\n\n192.168.37.0/24\n\n192.168.38.0/24\n\n...\n\n223.255.255.0/24\n\n(224.0.0.0+ skipped)\n\n192.168.36.0/25\n\n192.168.36.128/25\n\n192.168.37.0/25\n\n...\n\n223.255.255.128/25\n\n(224.0.0.0+ skipped)\n\n192.168.36.0/26\n\n192.168.36.64/26\n\n192.168.36.128/26\n\n...\n\n223.255.255.192/26\n\n204.197.56.0\n\n24\n\n24\n\n10\n\n4\n\n204.197.56.0/24\n\n204.197.66.0/24\n\n204.197.76.0/24\n\n204.197.86.0/24\n\nAll of the generated network addresses are associated with a set of attributes that describes routing to these generated network addresses and associated features.\n\nOnly one route can be added per UPDATE message, but a variable number of withdrawn routes may be packed into each UPDATE message. The packing is randomly chosen across a range of a number of routes. The time interval between UPDATE messages is configurable, in units of milliseconds.\n\nA BGP4 network condition called `flapping' can be emulated by the protocol server on an Ixia port. In the Link flapping emulation, a peer BGP router appears to be going offline and online repeatedly, which is accomplished on the Ixia port by alternate disconnects and reconnects of the TCP/IP stack. In the Route flapping emulation, BGP routes are repeatedly withdrawn, and then re-advertised, in UPDATE messages.\n\nBGP L3 VPNs\n\nL3 Virtual Private Networks (VPNs) over an IP backbone (at Layer 3 of the OSI model), may be provided to the customers of a Service Provider (SP), providing connectivity between two or more sites owned by the customer. L3 VPNs are independent of the Layer 2 protocol. While MPLS handles the packet forwarding in the backbone/core, the BGP protocol provides a means of advertising external routes/network addresses across that backbone between sites. IETF Internet Draft `draft-ietf-ppvpn-rfc2547bis-01.txt,' the proposed successor to RFC 2547, covers the VPN architecture designed for use by private service providers. A simplified example of a BGP L3 VPN topology is shown in Figure 3-5 on page 3-12.\n\nFigure 3-5. Simplified BGP L3 VPN Diagram\n\nThe term site refers to a customer/client site, which consists of a group of inter-connected IP devices, usually in one geographic location. A Customer Edge (CE) device, typically a router, connects the site, through a data link connection, to a Provider Edge (PE) routerÂ—an entry point to the service provider's backbone. The PE-to-CE routing protocols may be static routing, or a dynamic protocol such as eBGP or RIPv2.\n\nProvider (P) network core routers, `transparently' carry the IP traffic across the internal core between CE routers. CEs and Ps are not `VPN-aware' devices. CE devices are considered as belonging to a only one site, but that site may belong to multiple VPNs. A VPN Routing and Forwarding table (VRF) on a PE consists of an IP routing table, a forwarding table, and other information on the set of interfaces in the VPN. The VRF generally describes a VPN site's routing information, and a PE may maintain multiple VRFs, one for each connected customer site. See L3 VPN VRFs on page 3-14 for additional information on VRFs.\n\nLayer 3 VPN sites are identified by a Route Target (RT). A route target is based on the mechanism proposed in the IETF draft for the `BGP Extended Communities Attribute.' An 8-byte route target is common to all route ranges that belong to a single L3 site. Route targets are defined for individual VPN route ranges. The formats for Route Targets (RTs) are shown in Figure 3-6 on page 3-13.\n\nFigure 3-6. Route Target Formats (BGP Extended Community Types)\n\nBGP VPN-IPv4 Address Formats\n\nGlobally unique 12-byte VPN-IPv4 prefixes are created by a PE router. This includes configuration of the 8-byte VPN Route Distinguishers (RDs). It should be noted that BGP IPv4 routes and VPN -IPv4 routes are considered noncomparable; VPN-IPV4 addresses can be used only within the VPN service provider network.The route distinguishers are used by PE routers to associate routes with the path to a particular CE site router in a VPN. Each route can only have one RD. The formats of the RDs are shown in Figure 3-7 on page 3-13.\n\nFigure 3-7. VPN-IPv4 Address Formats (with Route Distinguishers)\n\nL3 VPN VRFs\n\nFor Layer 3 Virtual Private Network (L3 VPN) configurations, the Provider Edge (PE) routers maintain routing tables for each VPN that they participate in, termed VPN Routing and Forwarding tables (VRFs). The VRFs are populated with routes received from both the directly attached and remote Customer Edge (CE) routers. Each entry in the VRF is called a VPN Forwarding Instance (VPI). VRFs and CEs are not required to be configured on a one-to-one basis, although this is the typical situation. An example of the possible relationships between VRFs and CEs is shown in Figure 3-8 on page 3-14.\n\nFigure 3-8. L3 VPN VRF Example\n\nRIP\n\nThe Routing Information Protocol (RIP) is an interior routing protocol. It is the oldest and most frequently used of the LAN routing protocol. RIP routers broadcast or multicast to each other on a regular basis and in response to REQUEST packets. RIP routers incorporate routing information received from their neighbors into their own routing table and forward them on to other neighbors. Two distinct versions of RIP exist: version 1 and version 2. Both IPv4 and IPv6 are supported.\n\nAs implemented by the Protocol Server, each Ixia port is capable of simulating one or more routers at distinct addresses. Routing tables for the simulated routers are configured by you and sent out at regular intervals, with a configurable randomizing factor. Either version 1 or version 2 packet formats may be sent through multicast or broadcast (for compatibility with version 1 routers). Received packets may be filtered for version 1 and/or 2 compatibility.\n\nThe current implementation of the Protocol Server uses Split Horizon with Space Saver as its update mode, which receives, but not process RIP broadcasts heard from DUT routers. That is, it does not incorporate received information into its own table, but rather always broadcast the same routing table. Future versions will offer Split Horizon, Split Horizon with Poison Reverse, and Silent modes of update.\n\nThe Protocol Server, however, responds to REQUEST packets that it receives. Two types of requests are processed:\n\nRIP Overview\n\nThe Routing Information Protocol (RIP) is an interior gateway routing protocol (IGP) and uses a Distance Vector Algorithm. It is the oldest and most frequently used of the LAN routing protocols. RIP routers broadcast or multicast to each other on a regular basis and in response to REQUEST packets. RIP routers optionally incorporate routing information received from their neighbors into their own routing table and forward it on to other neighbors.\n\nAs implemented by the Protocol Server, each Ixia port is capable of simulating one or more routers with separate addresses. Routing tables for the simulated routers are configured by you and sent out at regular intervals, with a configurable randomizing factor. Either Version 1 or Version 2 packet formats may be sent through multicast or broadcast (for compatibility with Version 1 routers). Received packets may be filtered for Version 1 or Version 2 compatibility.\n\nThe current implementation of the Protocol Server uses Split Horizon with Space Saver as its update mode, which receives, but not process, RIP broadcasts heard from DUT routers. That is, it does not incorporate received information into its own table, but rather always broadcast the same routing table. Future versions will offer Split Horizon, Split Horizon with Poison Reverse, and Silent modes of update.\n\nThe Protocol Server, however, responds to REQUEST packets that it receives. Two types of requests are processed:\n\nRIPng\n\nRouting Information Protocol - Next Generation (RIPng) is specified for use with IPv6 in RFC 2080. Like the IPv4 version of RIP, this routing protocol is based on a Distance Vector algorithm. RIPng routers compare information for various routes through an IPv6 network, especially the information related to the RIPng metric. Due to the limited number of allowed hops, this protocol is used in small- to moderate-sized networks. The valid metric range is from 1 to 15 (hops). The metric values of 16 and above are defined as `infinity' and are considered unreachable.\n\nAn RIPng router is assumed to have interfaces to one or more directly-connected networks. Each router maintains a routing table, with one entry for every reachable destination in the RIPng network. Each routing table entry contains a minimum of:\n\nAs a UDP-based protocol, the RIPng routing process functions on UDP well-known port number 521 (the `RIPng port'), on which datagrams are sent and received. The RIPng port supports the following:\n\nISISv4/v6\n\nThe Intermediate System to Intermediate System (ISIS) routing protocol was originally designed for use with the OSI Connectionless Network Protocol (CLNP) and was defined in ISO DP 10589. It was later extended to include IP routing in IETF RFC 1195. When routing for OSI and IP packets (defined in ISO/IEC 10589:1992(E)) is combined in this way, the protocol is referred to as Integrated ISIS or Dual ISIS. In addition, RFC 2966 extends the distribution of routing prefixes among ISIS routers, and IETF DRAFT draft-ietf-isis-ipv6-05 adds IPv6 routing capability to the protocol.\n\nISIS Topology\n\nISIS areas are administrative domains which contain ISIS routers, have one or more private networks, and may share networks with other areas. The example shown in Figure 3-9 on page 3-17 consists of a theoretical ISIS topology. Note that, as shown in this diagram, all ISIS routers are considered to reside entirely within an area, unlike some other protocols such as OSPF, where routers can reside at the edges of areas and domains.\n\nFigure 3-9. ISIS Topology\n\nOne or more Area IDs are associated with an area. Most areas only require one ID during steady state operation, but up to three IDs may be needed during the process of migrating a router from one area to another. In most cases, the maximum number of area IDs is set to three.\n\nISIS routers can be divided into three categories, as follows:\n\nEntirely separate routing tables are maintained for Level 1 and Level 2 ISIS information, even within L1/L2 routers. All L1s within an area maintain identical databases. All L2s within a domain maintain identical databases.\n\nISIS Processing\n\nMany OSI concepts are necessary for describing ISIS. The following terms are important to the following discussion:\n\nISIS routers maintain knowledge of each other by exchanging Hello PDUs at regular, configured Hello intervals. A router is considered down if it does not respond within a separately configured Dead interval.\n\nISIS routers update each other using Link State PDUs (LSPs) at a regular interval of 30 minutes. The LSP header contains the Remaining Lifetime for the LSP, a Sequence Number, and a checksum. Each LSP contains information about a router's connection to local networks, plus a metric related to each network. ISO DP 10589 defines four types of metrics: default, delay, expense, and error.\n\nIn a Broadcast/LAN network, the Designated Router sends a Complete Sequence Number PDU (CSNP). In a Point-to-Point network, the receiving router sends a Partial Sequence Number PDU (PSNP).\n\nIn the ISIS protocol, for each of the levels (L1 or L2), one of the routers is elected as the Designated IS, based on priority values assigned to each interface as part of Hello PDU processing. The Ixia Protocol Server does not support the role of DR, so to ensure that it is not elected by its ISIS peers each Ixia-simulated ISIS router has a default priority of `0,' indicating its unwillingness to be the Designated IS.\n\nISIS Addresses\n\nDue to the OSI derivation of the ISIS protocol, each ISIS router has an OSI NET address of 8 to 20 octets in length. The NET address consists of two parts: an Area ID and a System ID. The Area ID has a number of different formats defined in OSI specifications. The System ID may be from 1 to 8 octets in length. The default System ID length defaults to 6 octets and must be the same length for every router in the domain. The System ID is unique within its ISIS area for Level 1, or unique within the ISIS routing domain for Level 2 or Level 1/2. Two types of network connections are supported: broadcast and point-to-point. In a broadcast network, each interface on an ISIS dual-mode router must have an IP address and mask.\n\nRSVP-TE\n\nThe Ixia protocol server implements a part of the Resource Reservation Protocol (RSVP) used for Traffic Engineering (TE). This subset of the RSVP protocol, referred to as RSVP-TE, is used in the process of constructing a path through a sequence of MPLS-enabled label switched routers (LSRs), while reserving necessary bandwidth resources. The use of an internal gateway routing protocol (IGP), such as OSPF, is also required to automatically determine the `next hop' router.\n\nMulti-Protocol Label Switching (MPLS) allows rapid forwarding of packets across a sequence of routers, without time-consuming examination of the packet contents at each hop. Label switching has been used extensively for ATM traffic, where overhead bytes for each `cell,' or packet, of data constitute a large percentage of the overall data transmitted. The addition of a `label' value to the header information in each cell or packet supplies the only forwarding information required to transit the MPLS domain. Based on information in its forwarding table, each LSR replaces (swaps) the incoming label with a new one which directs the packet to the next hop.\n\nThe most important output from an RSVP-TE setup session is the set of MPLS labels, which are used by the MPLS-enabled routers along the path to efficiently forward network traffic. The operation of RSVP-TE is shown in Figure 3-10 on page 3-20.\n\nFigure 3-10. RSVP-TE Overview\n\nThrough the use of RSVP-TE message exchanges, the router at the entry to the MPLS domain, also known as an Ingress LSR, initiates the creation of a dynamic `tunneled' pathway to the Egress LSR, the router at the exit side of the MPLS domain. Packets which pass through this `tunnel' are essentially `protected' from the extensive packet processing normally imposed by each router it traverses. Once this special pathway or Label Switched Path (LSP) is established, the router can forward, rather than route, packets across the domain, saving considerable processing time at each intermediate LSR (Transit LSR). The resulting tunneled pathway is known as an LSP Tunnel. The traffic flows through an LSP Tunnel are unidirectional. To establish bidirectional traffic through the MPLS domain, a second LSP Tunnel must be created in the opposite direction.\n\nAn LSP Tunnel is defined by a Destination Address (the IP address of the Egress LSR), and a Tunnel ID. At a finer level of granularity are LSP IDs. Essentially, these LSP IDs can serve to provide a set of aliases for alternate hop-by-hop paths between a single pair of Ingress and Egress LSRs, and therefore exist within the same LSP Tunnel.\n\nNote: Ingress LSRs and Egress LSRs are also known as Label Edge Routers (LERs).\n\nTwo principal RSVP-TE message types are used to establish LSP Tunnels:\n\nAn additional HELLO message is used between neighbor LSRs to ensure that LSRs are alive. This allows for quick tunnel replacement in the case of link or router failure.\n\nA set of labels is passed in the RESV messages sent upstream from the egress to the ingress router. A label is sent from one LSR to its upstream neighbor telling the upstream router which label to use when later sending downstream traffic.\n\nThree scenarios are currently supported to test MPLS/RSVP-TE on a DUT using Ixia equipment:\n\nPATH Messages\n\nPATH messages contain a number of objects which define the tunnel to be established. These are shown in Table 3-4 on page 3-22.\n\nTable 3-4. RSVP-TE PATH Message Objects\n\nObject\n\nContents\n\nUsage\n\nSESSION\n\nDescribes the destination router and associates a tunnel ID with the session.\n\ntunnel endpoint\n\nThe destination router's IP address.\n\ntunnel ID\n\nA unique LSP tunnel ID.\n\nSENDER_TEMPLATE\n\nThe description of the sender.\n\ntunnel sender address\n\nThe sender router's IP address.\n\nLSP ID\n\nA unique LSP ID.\n\nLABEL_REQUEST\n\nAsks all the LSRs to send back label values through RESV messages.\n\nSENDER_TSPEC and\n\nADSPEC\n\nBoth of these objects deal with bandwidth and other QoS requirements for the path.\n\nTIME_VALUES\n\nTiming values related to the refresh of tunnel information.\n\nrefresh interval\n\nThe interval between messages.\n\nEXPLICIT_ROUTE\n\nAllows the sender to request that the LSP tunnel follow a specific path from ingress to egress router. See Explicit_Route on page 3-22 for more details.\n\nSESSION_ATTRIBUTE\n\nOther attributes associated with the session: tunnel establishment priorities, session name, and optionally resource affinity.\n\nRSVP_HOP\n\nDescribes the immediate upstream router's address to the downstream router.\n\nExplicit_Route\n\nAn explicit route is a particular path in the network topology. Typically, the explicit route is determined by a node with the intent of directing traffic along that path. An explicit route is described as a list of groups of nodes along the explicit route. In addition to the ability to identify specific nodes along the path, an explicit route can identify a group of nodes that must be traversed along the path. Each group of nodes is called an abstract node. Thus, an explicit route is a specification of a set of abstract nodes to be traversed.\n\nThere are three types of objects in an explicit route:\n\nEach node has a loose bit associated with it. If the bit is not set, the node is considered strict. The path between a strict node and its preceding node may only include network nodes from the strict node and its preceding abstract node. The path between a loose node and its preceding node may include other network nodes that are not part of the strict node or its preceding abstract node.\n\nRESV Message\n\nThe RESV message contains object that indicate the success of the PATH request and the details of the assigned tunnel. These are shown in Table 3-5 on page 3-23.\n\nTable 3-5. RSVP-TE RESV Message Objects\n\nObject\n\nUsage\n\nSESSION\n\nIndicates which session is being responded to.\n\nTIME_VALUES\n\nAs in the PATH message but from the downstream LSR to the upstream LSR.\n\nSTYLE\n\nThe type of reservation assigned by the egress router. This relates to whether individual tunnels are requested for each sender-destination connection or whether some connections may use the same tunnel.\n\nFILTER_SPEC\n\nThe sender router's IP address and the LSP ID.\n\nLABEL\n\nThe label value assigned by the downstream router for use by the upstream router.\n\nRECORD_ROUTE\n\nIf requested, the complete route from the destination back to the source. The contents of this object include the IP addresses in either v4 or v6 format of all the LSRs encountered in the formation of the LSP, and optionally the labels used at each step. Each LSR on the upstream path perpends its own address information.\n\nRESV_CONF\n\nIf present, it indicates that the ingress router should send a RESV_CONF message in response to the destination to indicate that the tunnel has been completely established.\n\nOther Messages\n\nSeveral additional messages are used in RSVP-TE, as explained in Table 3-6 on page 3-24.\n\nTable 3-6. Additional RSVP-TE Messages\n\nMessage\n\nUsage\n\nPATH_ERR\n\nAny LSR may determine that it cannot accommodate the tunnel requested in a PATH message. In this case it sends a PATH_ERR message back to the sender.\n\nPATH_TEAR\n\nWhen a sender router determines that it wants to tear down a tunnel, it sends a PATH_TEAR message to the destination router.\n\nRESV_ERR\n\nIf a router cannot handle a reservation, it sends a RESV_ERR back to the destination router.\n\nRESV_TEAR\n\nWhen a destination router determines that it wants to tear down a tunnel, it sends a RESV_TEAR message upstream to the source router.\n\nRESV_CONF\n\nWhen requested, a sender router responds to the destination router with a RESV_CONF message to indicate that a complete tunnel has been successfully established.\n\nRSVP-TE Fast Reroute\n\nRSVP-TE Fast Reroute allows to configure backup LSP tunnels to provide local repair/protection ONLY for explicitly-routed LSPs/LSP tunnels, termed protected LSPs as described in IETF DRAFT draft-ietf-mpls-rsvp-lsp-fastreroute-03.\n\nAn example diagram of a backup scenario for rerouting around a downed link, using an LSP Detour, is shown in Figure 3-11 on page 3-25. Figure 3-12 on page 3-25 shows an example diagram for a backup scenario to reroute around a downed node, using an LSP Detour.\n\nFigure 3-11. RSVP-TE Fast Reroute Backup Link (Detour) Example\n\nFigure 3-12. RSVP-TE Fast Reroute Backup Node (Detour) Example\n\nThe one-to-one backup method is based on including a DETOUR object in the Path message. The head-end router, the Point of Local Repair (PLR), sets up a separate detour LSP for each LSP it protects. For the Facility backup method, the PLR sets up a tunnel to protect multiple LSPs simultaneously, by using the MPLS label stack.\n\nIxia Test Model\n\nThe Ixia test process is designed so as to fully exercise RSVP functionality in MPLS routers. An Ixia port can simulate any number of LSR routers at the same time. Each router operates in an ingress or egress mode. In the following discussion, LSRs I and II refer to Figure 3-10 on page 3-20:\n\nIf requested, HELLO messages are generated and responded to in either mode.\n\nWhen the Ixia port operates in Ingress mode, it attempts to set up LSP tunnels for each combination of sender router and destination router, using any number of LSP tunnels and any number of LSP IDs for each LSP tunnel. Thus the number of PATH messages that the Ixia port attempts to generate for each refresh interval is:\n\n# of sender routers\n\nx # of destination routers\n\nx # of LSPs\n\nx # of LSP tunnels\n\nThe protocol server records all labels and other information that it receives on behalf of its simulated routers and displays those in a convenient format.\n\nLDP\n\nThe Label Distribution Protocol (LDP) version 1, defined in RFC 3036, works in conjunction with Multi-Protocol Label Switching (MPLS), to efficiently `tunnel' IP traffic across backbone topologies between Label Switching Routers (LSRs).\n\nMPLS forwards packets based on added labels, so IP routing table lookups are not required along the length of the tunnel. RFC 3031 defines Forwarding Equivalence Classes (FECs) for use with MPLS, for purposes such as Quality of Service (QoS). LDP utilizes this option, assigning an FEC to every Label Switched Path (LSP) it sets up.\n\nThe LDP protocol creates peer sessions through a bidirectional exchange of messages, which include label requests and labels. While the initial Hello messages are based on UDP and sent to well-known port `646,' all other messages are based on TCP.\n\nThe following global timers can be configured: Hello Hold timer, Hello Interval timer, KeepAlive Hold timer, and KeepAlive Interval timer. The values for these timers can be entered by you, but the final values are negotiated during the Discovery and Session setup processes. When the LDP remote peer has a timeout value which is lower than the one configured for the local LDP router, the lower value is used by both peers.\n\nVirtual Circuit (VC) Ranges of MAC Addresses can be created to simulate Virtual Private LAN Services (VPLS), where L2 PDUs can be carried over VC LSPs, which, in turn, are carried over MPLS. This creates a `bridged,' Ethernet Layer Two Virtual Private Network (Ethernet L2VPN). Refer to IETF DRAFT draft-lasserre-vkompella-ppvpn-vpls-03, which defines the VC Type - Ethernet VPLS, and also discusses the use of MPLS transport tunnels by pseudowires (PWs).\n\nA pseudowire is a logical link through the tunnel, made up of two parallel VC LSPs using the same VC Identifier (VCID), as shown in Figure 3-13 on page 3-27, and in more detail in Figure 3-14 on page 3-28.\n\nFigure 3-13. LDP VPLS Example\n\nFigure 3-14. LDP VPLS Pseudowire Diagram\n\nMLD\n\nThe Multicast Listener Discovery (MLD) protocol is integral to the operation of Internet Protocol Version 6 (IPv6). MLDv1 is defined by RFC 2710, while MLDv2 is defined by RFC 3810. The MLD operations are based on operations similar to the Internet Group Management Protocol (IGMP) that supports IPv4. MLDv2 corresponds to IGMPv3. Both versions are supported by the protocol server.\n\nAn IPv6 router uses MLD to: (1) discover multicast listeners (nodes) on the directly attached links, and (2) find out which multicast addresses those nodes have interest in. In MLDv2, nodes can indicate interest in listening to packets that are sent to a specific multicast address from a filtered group of source IP addresses. This filtering can be based on `all but' (Excluding) or `only' (Including) certain source addresses. Host nodes can only be multicast `listeners,' while the multicast routers can act as routers or listeners.\n\nPIM-SM/SSM-v4/v6\n\nProtocol Independent Multicast - Sparse Mode (PIM-SM) Version 2 protocol is designed for multicast routing, and is defined in RFC 2362. IETF DRAFT draft-ietf-pim-sm-v2-new-06.txt is being designed to obsolete RFC 2362.\n\nThere is one Rendezvous Point (RP) per multicast group, and this router serves as the root of a unidirectional shared distribution tree whose `leaves' consist of multicast receivers. In addition, PIM-SM can create an optional shortest-path tree for an individual source (where the source is the root). The term upstream is used to indicate the direction toward the root of the tree; downstream indicates the direction away from the root of the tree. The address of the RP can be configured statically by an administrator, or configured through a Bootstrap router (BSR) mechanism.\n\nPIM-SM can use two sources of topology information to populate its routing table, the Multicast Routing Information Base (MRIB): unicast or multicast-capable. In a LAN where there are multiple PIM-SM routers and directly-\n\nconnected hosts, one of the routers is elected as Designated Router (DR) to act on the behalf of the hosts.\n\nThe diagram in Figure 3-15 on page 3-29 shows a simplified PIM-SM test setup using Ixia ports.\n\nFigure 3-15. PIM-SM Diagram\n\nPIM-SM Source-Group Mapping\n\nPIM-SM Source-Group mapping involves the pairing of Sources and Groups. The default method is a fully-meshed mapping of sources to groups, where every source is paired with every group. For a situation where there are `X' number of sources and `Y' number of groups, there will be `X x Y' number of mappings, resulting in a great deal of memory usage for processing. When full-mesh mapping is not desired, the optional `One-To-One' Source-Group Mapping can be used to save memory. In comparison, if a one-to-one type mapping behavior was preferred and only a full-mesh setup was available, you would have to create `N' fully-meshed source-group mapping ranges of size `1' to emulate the one-to-one behavior. An example showing the differences between the two types of mapping is shown in Figure 3-16 on page 3-30.\n\nFigure 3-16. PIM-SM Source-Group Mapping Example\n\nPIM-SSM\n\nProtocol Independent Multicast - Source-Specific Multicast (PIM-SSM) uses a subset of the PIM-SM protocol, described in draft-ietf-ssm-arch-06, Source-Specific Multicast for IP, and in Section 4.8 of draft-ietf-pim-sm-v2-new-11, Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised).\n\nPIM-SSM is useful for broadcast-type applications, where one source sends packets to many host groups. There is no shared distribution tree topology, but there is a shortest-path tree (SPT) established, where the source is the root of the tree. In the case of SSM, the usual PIM-SM multicast terminology is modified, and the term Channel is used instead of Group and Subscription replaces Join. A multicast group (G) router that wants to receive packets from a specific Source (S) for its hosts/listeners, will `Subscribe' to `Channel (S,G).' An example of an PIM-SSM topology is shown in Figure 3-17 on page 3-31.\n\nFigure 3-17. PIM-SSM Topology Example\n\nAn existing PIM-SM network can be modified to run SSM by enabling PIM-SSM on the source and destination/group routers. The typical PIM-SM signaling is not used for PIM-SSM, since the role of Rendezvous Point (RP) router is eliminated. The Subscribe (Join) message travels directly from the Destination router to the Source router, and data packets are transmitted in the opposite direction.\n\nPIM-SSM Addressing\n\nThe PIM-SSM protocol uses a restricted addressing scheme, with reserved values for IPv4 SSM addresses defined by the IANA as 232.0.0.0 through 232.255.255.255 (232/8). IPv6 SSM addresses are defined in IETF DRAFT draft-ietf-ssm-arch- 06 and draft-ietf-pim-sm-v2-new-11 as FF3x: : /32. The range of FF3x: : /96 is proposed by RFC 3307, `Allocation Guidelines for IPv6 Multicast Addresses.'\n\nDifferences Between PIM-SM and PIM-SSM\n\nSome of the principal differences between PIM-SM and PIM-SSM routers, per draft-ietf-ssm-arch-06, are mentioned in the following list:\n\nProtocol Elements for PIM-SSM\n\nProtocol elements required for PIM-SSM-only routers are mentioned in the following list:\n\nSome of the Protocol elements not required for PIM-SSM-only routers are mentioned in the following list:\n\nMulticast VPNs\n\nMulticast VPNs (MVPNs) can be created through the use of MP-BGP combined with PIM-SM. Multicast VPNs can be set up by a Service Provider to support scalable, IPv4 multicast traffic solutions, based on IETF draft-rosen-vpn-mcast-07, `Multicast in MPLS/BGP IP VPNs.'\n\nMulticast VRFs (MVRFs) on each PE router contain multicast routing tables. Within a Service Provider's domain, each MVRF is assigned to a Multicast Domain (MD), which is a set of MVRFs that can send multicast traffic to one another. Multicast packets from CE routers are sent over a (GRE) multicast tunnel to other PE routers in the multicast domain. A simplified example of a Multicast VPN topology, with one MVPN, is shown in Figure 3-18 on page 3-33.\n\nFigure 3-18. Multicast VPN Topology Example\n\nEach CE and its connected PE set up a PIM-SM adjacency. However, CEs do not set up PIM-SM adjacencies with each other. Separate CE-associated instances of PIM are run by each PE router, and these are called `PIM C-instances.' Each C-instance is MVRF-specific. As each PE can be affiliated with many MVPNs/MVRFs, the router can run many PIM C-instances simultaneously, up to a maximum of one C-instance per MVRF.\n\nPIM Provider-wide instances (`PIM P-instances') are run by each PE router, creating a global PIM adjacency with all of its IGP PIM-SM-enabled neighbors (P routers). P routers cannot set up PIM-SM C-instances.\n\nAt startup for the multicast domain's Provider Edge (PE) routers, the default Multicast Distribution Tree (MDT) is set up automatically. Each Multicast Domain is identified by a globally unique Service Provider (P) Group address and a Route Distinguisher. The MD group address is created by using BGP (L3 Site window). It is a valid 4-byte IPv4 multicast address prefix (for example, 239.1.1.1/32). The 12-byte Route Distinguisher is also created through BGP (L3 Site window). This Ixia implementation uses an RD value = 2. One C-Multicast Group Range (MGR) can be configured for each MVRF.\n\nMPLS\n\nMulti-Protocol Label Switching (MPLS) is based on the concept of label switching: and independent and unique `label' is added to each data packet and this label is used to switch and route the packet through the network. The label is simple, essentially a shorthand version of the packet's header information, so network equipment can be optimized around processing the label and forwarding traffic. This concept has been around the data communications industry for years. X.25, Frame Relay, and ATM are examples of label switching technologies.\n\nIt is important to understand the differences in the way MPLS and IP routing forward data across a network. Traditional IP packet forwarding uses the IP destination address in the packet's header to make an independent forwarding decision at each router in the network. These hop-by-hop decisions are based on network layer routing protocols, such as Open Shortest Path First (OPSF) or Border Gateway Protocol (BGP). These routing protocols are designed to find the shortest path through the network, and do not consider other factors, such as latency or traffic congestion.\n\nMPLS creates a connection-based model overlaid onto the traditionally connectionless framework of IP routed networks. This connection-oriented architecture opens the door to a wealth of new possibilities for managing traffic on an IP network. MPLS builds on IP, combining the intelligence of routing, which is fundamental to the operation of the Internet and today's IP networks, with the high performance of switching. Beyond its applicability to IP networking, MPLS is being expanded for more general applications in the form of Generalized MPLS (GMPLS), with applications in optical and Time-Division Multiplexing (TDM) networks.\n\nOne of the primary original goals of MPLS, boosting the performance of\n\nsoftware-based IP routers, has been superseded as advances in silicon technology have enabled line-rate routing performance implemented in router hardware. In the meantime, additional benefits of MPLS have been realized, notably Virtual Private Network (VPN) services and traffic engineering (TE).\n\nAdvantages of MPLS\n\nSome of the advantages of using MPLS are:\n\nHow Does MPLS Work?\n\nMPLS is a technology used for optimizing forwarding through a network. Though MPLS can be applied in many different network environments, this discussion focuses primarily on MPLS in IP packet networks, by far the most common application of MPLS today.\n\nMPLS assigns labels to packets for transport across a network. The labels are contained in an MPLS header inserted into the data packet.\n\nThese short, fixed-length labels carry the information that tells each switching node (router) how to process and forward the packets, from source to destination. They have significance only on a local node-to-node connection. As each node forwards the packet, it swaps the current label for the appropriate label to route the packet to the next node. This mechanism enables very-high-speed switching of the packets through the core MPLS network.\n\nMPLS combines the best of both Layer 3 IP routing and Layer 2 switching. In fact, it is sometimes called a `Layer 2-1/2' protocol. While routers require\n\nnetwork-level intelligence to determine where to send traffic, switches only send data to the next hop, and so are inherently simpler, faster, and less costly. MPLS relies on traditional IP routing protocols to advertise and establish the network topology. MPLS is then overlaid on top of this topology. MPLS predetermines the path data takes across a network and encodes that information into a label that the network's routers can understand. This is the connection-oriented approach previously discussed. Since route planning occurs ahead of time and at the edge of the network (where the customer and service provider network meet), MPLS-labeled data requires less router horsepower to traverse the core of the service provider's network.\n\nMPLS Routing\n\nMPLS networks establish Label-Switched Paths (LSPs) for data crossing the network. An LSP is defined by a sequence of labels assigned to nodes on the packet's path from source to destination. LSPs direct packets in one of two ways: hop-by-hop routing or explicit routing.\n\nHop-by-Hop Routing\n\nIn hop-by-hop routing, each MPLS router independently selects the next hop for a given Forwarding Equivalency Class (FEC). A FEC describes a group of packets of the same type; all packets assigned to a FEC receive the same routing treatment. FECs can be based on an IP address route or the service requirements for a packet, such as low latency.\n\nIn the case of hop-by-hop routing, MPLS uses the network topology information distributed by traditional Interior Gateway Protocols (IGPs) routing protocols such as OPSF or IS-IS. This process is similar to traditional routing in IP networks, and the LSPs follow the routes the IGPs dictate.\n\nExplicit Routing\n\nIn explicit routing, the entire list of nodes traversed by the LSP is specified in advance. The path specified could be optimal or not, but is based on the overall view of the network topology and, potentially, on additional constraints. This is called Constraint-Based Routing. Along the path, resources may be reserved to ensure QoS. This permits traffic engineering to be deployed in the network to optimize use of bandwidth.\n\nLabel Information Base\n\nAs the network is established and signaled, each MPLS router builds a Label Information Base (LIB), a table that specifies how to forward a packet. This table associates each label with its corresponding FEC and the outbound port to forward the packet to. This LIB is typically established in addition to the routing table and Forwarding Information Base (FIC) that traditional routers maintain.\n\nConnections are signaled and labels are distributed among nodes in an MPLS network using one of several signaling protocols, including Label Distribution Protocol (LDP) and Resource reSerVation Protocol with Tunneling Extensions (RSVPTE). Alternatively, label assignment can be piggybacked onto existing IP routing protocols such as BGP.\n\nThe most commonly used MPLS signaling protocol is LDP. LDP defines a set of procedures used by MPLS routers to exchange label and stream mapping information. It is used to establish LSPs, mapping routing information directly to Layer 2 switched paths. It is also commonly used to signal at the edge of the MPLS network, the critical point where non-MPLS traffic enters. Such signaling is required when establishing MPLS VPNs.\n\nRSVP-TE is also used for label distribution, most commonly in the core of networks that require traffic engineering and QoS. A set of extensions to the original RSVP protocol, RSVP-TE provides additional functionality beyond label distribution, such as explicit LSP routing, dynamic rerouting around network failures, preemption of LSPs, and loop detection. RSVP-TE can distribute traffic engineering parameters such as bandwidth reservations and QoS requirements.\n\nMulti-protocol extensions have been defined for BGP, enabling the protocol to also be used to distribute MPLS labels. MPLS labels are piggybacked onto the same BGP messages used to distribute the associated routes. MPLS allows multiple labels (called a label stack) to be carried on a packet. Label stacking enables MPLS nodes to differentiate between types of data flows, and to set up and distribute LSPs accordingly. A common use of label stacking is for establishing tunnels through MPLS networks for VPN applications.\n\nBFD\n\nBidirectional Forwarding Detection (BFD) is a network protocol used to detect faults between two forwarding engines. It provides low-overhead detection of faults even on physical media that don't support failure detection of any kind, such as ethernet, virtual circuits, tunnels and MPLS LSPs.\n\nBFD establishes a session between two endpoints over a particular link. If more than one link exists between two systems, multiple BFD sessions may be established to monitor each one of them. The session is established with a three-way handshake, and is torn down the same way. Authentication may be enabled on the session. A choice of simple password, MD5 or SHA1 authentication is available.\n\nBFD does not have a discovery mechanism; sessions must be explicitly configured between endpoints. BFD may be used on many different underlying transport mechanisms and layers, and operates independently of all of these. Therefore, it needs to be encapsulated by whatever transport it uses. For example, monitoring MPLS LSPs involves piggybacking session establishment on LSP-Ping packets. Protocols that support some form of adjacency setup, such as OSPF or IS-IS, may also be used to bootstrap a BFD session. These protocols may then use BFD to receive faster notification of failing links than would normally be possible using the protocol's own keepalive mechanism.\n\nA session may operate in one of two modes: asynchronous mode and demand mode. In asynchronous mode, both endpoints periodically send Hello packets to each other. If a number of those packets are not received, the session is considered down.\n\nIn demand mode, no Hello packets are exchanged after the session is established; it is assumed that the endpoints have another way to verify connectivity to each other, perhaps on the underlying physical layer. However, either host may still send Hello packets if needed.\n\nRegardless of which mode is in use, either endpoint may also initiate an Echo function. When this function is active, a stream of Echo packets is sent, and the other endpoint then sends these back to the sender through its forwarding plane. This is used to test the forwarding path on the remote system.\n\nCFM\n\nEthernet CFM is an end-to-end per-service-instance Ethernet layer OAM protocol that includes proactive connectivity monitoring, fault verification, and fault isolation. End to end can be PE to PE or customer edge (CE) to CE. Per service instance means per VLAN.\n\nBeing an end-to-end technology is the distinction between CFM and other metro-Ethernet OAM protocols. For example, MPLS, ATM, and SONET OAM help in debugging Ethernet wires but are not always end-to-end. 802.3ah OAM is a single-hop and per-physical-wire protocol. It is not end to end or service aware. Ethernet Local Management Interface (E-LMI) is confined between the uPE and CE and relies on CFM for reporting status of the metro-Ethernet network to the CE.\n\nTroubleshooting carrier networks offering Ethernet Layer 2 services can be difficult. Customers contract with service providers for end-to-end Ethernet service and service providers may subcontract with operators to provide equipment and networks. Compared to enterprise networks, where Ethernet traditionally has been implemented, these constituent networks belong to distinct organizations or departments, are substantially larger and more complex, and have a wider user base. Ethernet CFM provides a competitive advantage to service providers for which the operational management of link uptime and timeliness in isolating and responding to failures is crucial to daily operations.\n\nFCoE and NPIV\n\nIxExplorer provides GUI access to all Ixia platform functionality with full support for stateless FCoE functional and scalability testing. The FCoE and Priority Flow Control (PFC) and FCoE Initialization Protocol (FIP) features allow testing of FCoE switches running both FCoE traffic and traditional Ethernet traffic.\n\nSupported Load Modules\n\nThe following Ixia load modules have the Fibre Channel over Ethernet (FCoE) capability:\n\nData Center Mode\n\nFCoE support requires a new port mode, Data Center Mode. You need to switch port mode between Normal Mode and Data Center Mode to use the desired features in each mode.\n\nPriority Traffic Generation\n\nThe scheduling function is based on the existing Advanced Scheduler. A new parameter called `Priority Group' has been added to each stream. You can map Priority Group to the priority field in the frame. The priority field in the same stream should not change (for example, if the priority is a VLAN priority field, then you cannot configure a UDF to control this field within a stream).\n\nPriority-based Flow Control (PFC)\n\nThe Ixia port responds to either IEEE 802.3x pause frame or to IEEE 802.1Qbb Priority-based Flow Control (PFC) frame. The flow control type is determined by the selection made on the Flow Control tab of the Port Properties dialog, in IxExplorer.\n\nIxExplorer Reference\n\nSee IxExplorer User Guide, Chapter 6 topic Frame Data for FCoE Support, subtopic Priority-based Flow Control.\n\nFibre Channel over Ethernet\n\nWhen the port is in Data Center Mode, both existing Ethernet frames and FCoE frames are generated.\n\nThe Fibre Channel CRC is generated on the fly. This CRC is inserted at offset of Ethernet frame size minus 12 bytes. For example:\n\nEthernet Frame Size (bytes)\n\n2000\n\n2001\n\n2002\n\n2003\n\nFC-CRC Offset in FCoE Frame (bytes)\n\n1988\n\n1989\n\n1990\n\n1991\n\nThe FC-CRC can be set to No Error or to Bad CRC.\n\nPacket View Support\n\nFor Fibre Channel frame, there is no Extended Header and Optional Header support. It decodes only FC-2 Frame Header field.\n\nFCoE Initialization Protocol (FIP)\n\nFIP (FCoE Initialization Protocol) has been implemented (in addition to FCoE). It is used to discover and initialize FCoE capable entities connected to an Ethernet cloud.\n\nIxExplorer Reference\n\nSee the IxExplorer User Guide, Chapter 6 topic Frame Data for FCoE Support.\n\nNPIV Protocol Interface\n\nNPIV stands for N_Port ID Virtualization. These can be used to virtually share a single physical N_Port. This allows multiple Fibre Channel initiators to occupy a single physical port, easing hardware requirements in SAN design. Up to 256 N_Port_IDs can be assigned to a single N_Port. NPIV interfaces can be configured using the Protocol Interface Wizard.\n\nSee the IxExplorer User Guide, Chapter 10, topic NPIV Protocol Interface.\n\nPrecision Time Protocol (PTP) IEEE 1588v2\n\nPrecision Time Protocol (IEEE 1588v2) allows precise synchronization of clocks in measurement and controls systems implemented with technologies such as network communications, local computing and distributed objects. The protocol supports system wide synchronization accuracy in sub-microseconds range with minimal network and local clock computing resources. The protocol operates in master/subordinate configuration. IEEE1588 deploys Multicast over an Ethernet network, and devices such as routers and switches can sync to the provided timing source.\n\nSupported Load Modules\n\nThe following Ixia load modules have the PTP capability:\n\nSupported Messages\n\nThe following messages are supported between clocks participating in the PTP protocol.\n\nSupported Features\n\nThe following PTP features are supported.\n\nLocal Clock synchronization through PTP to another PTP clock\n\nThe local clock of the is synchronized to the 's master clock by minimizing the Offset_from_master value of the current data set. The time and the rate characteristics of the local clock are modified upon receipt of either a sync message or follow-up message. Figure 3-19 illustrates the PTP communication path.\n\nFigure 3-19. PTP Communication Path\n\nTable 3-7. PTP Communication Path\n\nTerm\n\nValue\n\nsync_receipt_time = Ts1\n\nTs1 =Tm1+O+master_to__delay\n\npreciseOriginTimestamp = Tm1\n\nTm1\n\nmaster_to__delay (computed)\n\nTs1Â–Tm1\n\ndelay_req_sending_time = Ts2\n\nTs2\n\ndelayReceiptTimestamp = Tm2\n\nTm2 = Ts2 Â– O + _to_master_delay\n\n_to_master_delay (computed)\n\nTm2 Â– Ts2\n\none_way_delay\n\n{(master_to__delay as computed) + (_to_master_delay as computed)}/2\n\n{(Ts1-Tm1) + (Tm2-Ts2)}/2\n\n{(O + master_to__delay ) +\n\nÂ–O +_to_master_delay)}/2\n\n{(master_to__delay ) + (_to_master_delay)}/2\n\nmaster_to__delay if path is symmetrical\n\nNotes:\n\n1. Offset shall be computed as O= Ts1-Tm1 - one_way_Delay. Offset and One way delay shall be stored.\n\n2. Offset correction shall be applied to the local clock.\n\nLocal clock frequency transfer\n\nIn Slave mode of operation, the Ixia port implements a local clock in software (Linux). The frequency of the oscillator is not adjusted but allowed to free-run. The local clock shall be implemented based on time information synchronized from sync/follow_up messages and hardware timestamps associated with these messages. The local clock is associated with a constant and a slope. The rate of a local clock relative to a master clock is illustrated in Figure 3-20.\n\nIxExplorer References\n\nSee the IxExplorer User Guide, Chapter 10, Protocol Interfaces, especially topics Protocol Interfaces Tab, PTP Discovered Information, and PTP Clock Configuration.\n\nFigure 3-20. Rate of Local Clock Relative to Master\n\nWhere T1 is the time synchronized from the master and TS1 is the hardware timestamp associated with sync message 1. T2 and TS2 are corresponding parameters associated with sync message 2. T is the time at any point of time.\n\nWith a sync message, the parameters K and the slope are updated. The Clock Offset from master is calculated as discussed above and applied to K for correction.\n\nTimestamps are cleared once when PTP is enabled.\n\nIn master mode of operation, server provides timestamp to the ports at the instant timestamps are cleared and slope is 1. OFFSET from master is 0.\n\nIf a GPS source is interfaced to the chassis, ports emulating the master are configured as Grand Master.\n\nLocal clock time format is seconds (32 bits) and nanoseconds (32 bits). The Ixia port supports a 2-step clock.\n\nATM Interfaces\n\nOn Asynchronous Transport Mode (ATM) is a Layer 2, connection-oriented, switching protocol, based on L2 Virtual Circuits (VCs). For operation in a\n\nconnectionless IP routing or bridging environment, the IP PDUs must be encapsulated within the payload field of an ATM AAL5 CPCS-PDU (ATM Adaptation Layer 5Â—Common Part Convergence SublayerÂ—Protocol Data Unit). The ATM CPCS-PDUs are divided into 48-byte segments which receive 5-byte headers to form 53-byte ATM cells.\n\nThe ATM cells are then switched across the ATM network, based on the Virtual Port Identifiers (VPIs) and the Virtual Connection Identifiers (VCIs). The relationship between VPIs (identifying one hop between adjacent nodes) and VCIs (identifying the end-to-end virtual connection) is illustrated in Figure 3-21 on page 3-46.\n\nFigure 3-21. ATM VPI/VCI Pairs (PVCs)\n\n`Bridged ATM' Versus `Routed ATM'\n\nThe ATM AAL5 frames allow for the overlay of the connectionless IP bridging or routing environment over the network of ATM nodes (that have frame handling capability). Each ATM node examines the payload of the AAL5 frame, and forwards the frame to the next node, based on the payload's MAC destination address (for IP bridging) or IP destination address (for IP routing). In effect, the ATM environment functions as a simulated Ethernet or IP network, respectively.\n\nIn the case of Label Distribution Protocol (LDP) routing over ATM, the process becomes more complex since MPLS tunnels are created over ATM core networks. For more information on the signaling, session setup, and label distribution for LDP routing over ATM, see the IxNetwork Users Guide: Network Protocols - LDP chapter.\n\nATM Encapsulation Types\n\nThere are two main types of ATM Multiplexing encapsulations defined by RFC 2684, `Multiprotocol Encapsulation over ATM Adaptation Layer 5.' The ATM AAL5 Frame is described in ATM Frame Formats on page 3-50. The various encapsulation types and references to diagrams of the encapsulated frame payloads are listed as follows:\n\nEncapsulation Types by Protocol\n\nThe types of RFC 2684 ATM encapsulations available for each Ixia routing protocol emulation are listed in Table 3-8 on page 3-47.\n\nTable 3-8. ATM Encapsulations for Protocols\n\nRouting Protocol\n\nATM Encapsulation Type\n\nBGP\n\n`Bridged ATM':\n\nVC Mux Bridged Ethernet/802.3 (FCS) - (the default)\n\nVC Mux Bridged Ethernet/802.3 (no FCS)\n\nLLC Bridged Ethernet (FCS)\n\nLLC Bridged Ethernet (no FCS)\n\n`Routed ATM':\n\nVC Mux IPv4 Routed\n\nVC Mux IPv6 Routed\n\nLLC Routed AAL5 Snap\n\nOSPF (v2 only)\n\nNote: Supported for both Point-to-Point and Point-to-MultiPoint links.\n\n`Bridged ATM':\n\nVC Mux Bridged Ethernet/802.3 (FCS) - (the default)\n\nVC Mux Bridged Ethernet/802.3 (no FCS)\n\nLLC Bridged Ethernet (FCS)\n\nLLC Bridged Ethernet (no FCS)\n\n`Routed ATM':\n\nVC Mux IPv4 Routed\n\nLLC Routed AAL5 Snap\n\nLDP\n\nNote: Discovery Mode must be set to Basic, and Advertising Mode must be set to Downstream on Demand (DoD).\n\n`Bridged ATM':\n\nVC Mux Bridged Ethernet/802.3 (FCS) - (the default)\n\nVC Mux Bridged Ethernet/802.3 (no FCS)\n\nLLC Bridged Ethernet (FCS)\n\nLLC Bridged Ethernet (no FCS)\n\n`Routed ATM':\n\nVC Mux IPv4 Routed\n\nLLC Routed AAL5 Snap\n\nRSVP-TE\n\n`Bridged ATM':\n\nVC Mux Bridged Ethernet/802.3 (FCS) - (the default)\n\nVC Mux Bridged Ethernet/802.3 (no FCS)\n\nLLC Bridged Ethernet (FCS)\n\nLLC Bridged Ethernet (no FCS)\n\nISIS\n\n`Bridged ATM':\n\nVC Mux Bridged Ethernet/802.3 (FCS) - (the default)\n\nVC Mux Bridged Ethernet/802.3 (no FCS)\n\nLLC Bridged Ethernet (FCS)\n\nLLC Bridged Ethernet (no FCS)\n\nRIP\n\n`Bridged ATM':\n\nVC Mux Bridged Ethernet/802.3 (FCS) - (the default)\n\nVC Mux Bridged Ethernet/802.3 (no FCS)\n\nLLC Bridged Ethernet (FCS)\n\nLLC Bridged Ethernet (no FCS)\n\nRIPng\n\n`Bridged ATM':\n\nVC Mux Bridged Ethernet/802.3 (FCS) - (the default)\n\nVC Mux Bridged Ethernet/802.3 (no FCS)\n\nLLC Bridged Ethernet (FCS)\n\nLLC Bridged Ethernet (no FCS)\n\nIGMP\n\n`Bridged ATM':\n\nVC Mux Bridged Ethernet/802.3 (FCS) - (the default)\n\nVC Mux Bridged Ethernet/802.3 (no FCS)\n\nLLC Bridged Ethernet (FCS)\n\nLLC Bridged Ethernet (no FCS)\n\nMLD\n\n`Bridged ATM':\n\nVC Mux Bridged Ethernet/802.3 (FCS)-(the default)\n\nVC Mux Bridged Ethernet/802.3 (no FCS)\n\nLLC Bridged Ethernet (FCS)\n\nLLC Bridged Ethernet (no FCS)\n\nPIM-SM\n\n`Bridged ATM':\n\nVC Mux Bridged Ethernet/802.3 (FCS)-(the default)\n\nVC Mux Bridged Ethernet/802.3 (no FCS)\n\nLLC Bridged Ethernet (FCS)\n\nLLC Bridged Ethernet (no FCS)\n\nATM Frame Formats\n\nThe format of the ATM AAL5 CPCS-PDU (ATM AAL5 Frame) is shown in Figure 3-22 on page 3-50. The formats of the various types of AAL5 CPCS-PDU payloads for these frames are shown in the following diagrams:\n\nGeneric Routing Encapsulation (GRE)\n\nRFC 2784, `Generic Routing Encapsulation' (GRE), provides a mechanism for encapsulating a payload packet to send that packet over a network of a different type. First, a GRE header is prepended to the payload packet, and the Ethertype for the protocol used in that packet is included in the GRE header. Then, a Delivery header is prepended to the GRE header, which adds a Layer 2 Data Link Layer address plus a Layer 3 Network address (for a network protocol in this implementation, either IPv4 or IPv6). After a GRE-encapsulated payload packet has reached the last router of the GRE `tunnel,' this router removes the GRE header and forwards the payload as a `normal' packet for the native protocol in the network.\n\nThis is a relatively simple type of encapsulation and can be used to transparently carry packets for many different protocols, since it is based on Ethertypes. The original specifications for this encapsulation were RFC 1701, `Generic Routing Encapsulation (GRE),' published in 1994, and RFC 1702, `Generic Routing Encapsulation over IPv4 Networks,' also published in 1994.\n\nRFC 2890, `Key and Sequence Number Extensions to GRE,' provides optional fields for identifying individual traffic flows within a GRE tunnel through an authentication key value, and for monitoring the sequence of packets within each GRE tunnel.\n\nGRE Packet Format\n\nBoth control and data packets can be GRE-encapsulated. The overall format of a GRE-encapsulated packet is shown in Figure 3-30 on page 3-54.\n\nFigure 3-30. GRE-Encapsulated Packet\n\nGRE Packet Headers\n\nThere are two formats for the GRE Packet Headers:\n\nGRE Header per RFC 2784\n\nThe format of a GRE packet header per RFC 2784 is shown in Figure 3-31 on page 3-54.\n\nFigure 3-31. GRE Packet Header (per RFC 2784)\n\nThe fields in the GRE header, per RFC 2784, are described in Table 3-9 on page 3-54.\n\nTable 3-9. GRE Header Fields (per RFC 2784)\n\nField\n\nDescription\n\nC\n\nThe Checksum Present flag bit.\n\nIf set (= 1), the Checksum and Reserved1 fields are present, and the information in the Checksum field is valid.\n\nReserved0\n\n(Bits 1 - 12)\n\nBits 1 - 5 unless the receiver is implementing RFC 1701, the receiver must discard the packet if any of these bits are non-zero.\n\nBits 6 - 12 reserved for future use.\n\nVer\n\nThe Version Number field.\n\nThe value must be zero.\n\nProtocol Type\n\nProtocol Type field.\n\nThe protocol type of the payload packet. These values are defined in RFC 1700, `Assigned Numbers' and by the IANA `ETHER TYPES' document.\n\nWhen the payload is an IPv4 packet, the protocol type must be set to 0x800 (Ethertype for IPv4).\n\nChecksum\n\n(Optional)\n\nThe IP (one's complement) checksum of all of the 16-bit words in the GRE header and the payload packet. The value of the checksum field = zero for the purpose of computing the checksum.\n\nThe checksum field is present only if Checksum Present bit is set (= 1).\n\nReserved1\n\n(Optional)\n\nThese bits are reserved for future use.\n\nThis field is present only if the Checksum field is present (that is, the Checksum Present bit = 0).\n\nIf present, this field must be transmitted as zero.\n\nGRE Header per RFC 2890\n\nThe format of a GRE header, with added information per RFC 2890, is shown in Figure 3-32 on page 3-55.\n\nFigure 3-32. GRE Header (per RFC 2890)\n\nThe fields in the GRE header, per RFC 2890, are described in Table 3-10 on page 3-56.\n\nTable 3-10. GRE Header Fields (per RFC 2890)\n\nField\n\nDescription\n\nC\n\nThe Checksum Present flag bit.\n\nIf set (= 1), the Checksum field and the Reserved1 is present, and the information in the Checksum field is valid.\n\nReserved0\n\nBits 1 - 12.\n\nFor bits 1 - 5, unless the receiver is implementing RFC 1701 the receiver must discard the packet if any of these bits are non-zero.\n\nFor bits 6 - 12, these bits are reserved for future use.\n\nK\n\nThe Key Present flag bit.\n\nIf set (= 1), the Key field is present. If not set (= 0), this field is not present.\n\n(Compatible with RFC 1701)\n\nS\n\nThe Sequence Number Present flag bit.\n\nIf set (= 1), the Sequence Number Present field is present. If not set (= 0), this field is not present.\n\n(Compatible with RFC 1701)\n\nVer\n\nThe Version Number field.\n\nThe value must be zero.\n\nProtocol Type\n\nProtocol Type field.\n\nThe protocol type of the payload packet. These values are defined in RFC 1700, `Assigned Numbers' and by the IANA `ETHER TYPES' document (located at www.iana.org/assignments/ethernet-numbers).\n\nWhen the payload is an IPv4 packet, the protocol type must be set to 0x800 (Ethertype for IPv4).\n\nChecksum\n\n(Optional)\n\nThe IP (one's complement) checksum of all of the 16-bit words in the GRE header and the payload packet. The value of the checksum field = zero for the purpose of computing the checksum.\n\nThe checksum field is present only if Checksum Present bit is set (= 1).\n\nReserved1\n\n(Optional)\n\nThese bits are reserved for future use.\n\nThis field is only present if the Checksum field is present (that is, the Checksum Present bit = 0).\n\nIf present, this field must be transmitted as zero.\n\nKey Present\n\n(Optional)\n\nThis field is present only if the Key Present bit is set (= 1).\n\nA 4-octet number that can be used to identify an individual, logical traffic flow within the GRE tunnel. The encapsulator/sender uses the same key value for all packets within a single flow, for identification by the decapsulator/receiver.\n\nSequence Number Present\n\n(Optional)\n\nThis field is present only if the Sequence Number Present bit is set (= 1).\n\nA 4-octet number that can be used to identify the order of transmission of the packets, with the goal of providing unreliable, but in-order delivery of packets.\n\nThe decapsulator/receiver uses the sequence number to monitor the order of the packets as they are received. Out-of-sequence packets should be silently discarded.\n\nThe sequence number of the first packet = 0. The value range is from 0 to (2 ** 32) -1.\n\nDHCP Protocol\n\nDynamic Host Configuration Protocol (DHCP) is defined in RFC 2131, and it is based on earlier work with the protocol for BOOTP relay agents, which was specified in RFC 951. A DHCP Server provides permanent storage and dynamic allocation of IPv4 network addresses and other network configuration information. A DHCP Server is a host, and a DHCP Client is also a host. This protocol is designed for allocating IPv4 addresses to hosts, but not to routers.\n\nA Client Identifier (Client ID) is required so that the DHCP Server can match a DHCP client with its `lease.' If the Client does not supply a Client Identifier option, the Client Hardware MAC Address (chaddr) is used by the Server to identify the Client. A lease is the period of time that a DHCP Client may use an IPv4 address that has been allocated by the DHCP Server. This lease period may be extended, and may even be set to `infinity' (0xffffffff hex), to indicate a `permanent' IPv4 address allocation.\n\nDHCP messages are exchanged between client and server using UDP as the transport protocol. The DHCP Server port is UDP Port 67, and the DHCP Client port is UDP Port 68.\n\nDHCPDISCOVER messages are broadcast by the Client on the local subnet, to reach the DHCP Server. Suggested values for a network address and lease period may be included in the Discover message. The Server(s) may respond with a DHCPOFFER message. The Offer message includes available IPv4 network address, plus configuration parameters contained in the DHCP options (TLVs/objects).\n\nDHCPv6 Protocol\n\nThe Dynamic Host Control Protocol for Version 6 (DHCPv6) is defined in RFC 3315. DHCPv6 uses UDP packets to exchange messages between servers and clients. The servers provide IPv6 addresses and additional configuration information to clients. A DHCPv6 server listens on a reserved, link-scope multicast address. A client identifies itself to the server by a link-local source address.\n\nThe groups of IPv6 addresses managed by the servers and clients are called Identity Associations (IAs), where each IA has a unique identifier. IA_NAs are identity associations of non-temporary (permanent) IPv6 addresses. IA_TAs are identity associations of temporary addresses.\n\nRFC 3633, `IPv6 Prefix Options for Dynamic Host Configuration Protocol (DHCP) Version 6,' adds capability for automated allocation of IPv6 prefixes from a delegating router to a requesting router. IA_PDs are identity associations used for delegated IPv6 address prefixes.\n\nThe setup for DHCPv6 involves a four-message exchange `handshake.' Maintaining the DHCPv6 client-server relationship, and managing the return or deletion of IPv6 addresses involves three additional messages. These messages are described in the following list:\n\nMessage exchange (handshake):\n\nAdditional messages for Maintenance/Return/Deletion of Addresses:\n\nEthernet OAM\n\nThe IEEE Std 802.3ah Operations, Administration, and Maintenance (OAM) sublayer provides mechanisms useful for monitoring link operation such as remote fault indication and remote loopback control. In general, OAM provides network operators the ability to monitor the health of the network and quickly determine the location of failing links or fault conditions.\n\nOAM information is conveyed in Slow Protocol frames called OAM Protocol Data Units (OAM PDUs). OAM PDUs contain the appropriate control and status information used to monitor, test and troubleshoot OAM-enabled links.\n\nThe addition of Ethernet OAM support in IxOS involves the following :"
    }
}