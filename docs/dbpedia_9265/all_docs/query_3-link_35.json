{
    "id": "dbpedia_9265_3",
    "rank": 35,
    "data": {
        "url": "https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/",
        "read_more_link": "",
        "language": "en",
        "title": "Labels and Selectors",
        "top_image": "https://kubernetes.io/images/kubernetes-horizontal-color.png",
        "meta_img": "https://kubernetes.io/images/kubernetes-horizontal-color.png",
        "images": [
            "https://kubernetes.io/images/announcements/kubecon-china-2024-white.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-07-30T23:13:48+05:30",
        "summary": "",
        "meta_description": "Labels are key/value pairs that are attached to objects such as Pods. Labels are intended to be used to specify identifying attributes of objects that are meaningful and relevant to users, but do not directly imply semantics to the core system. Labels can be used to organize and to select subsets of objects. Labels can be attached to objects at creation time and subsequently added and modified at any time.",
        "meta_lang": "en",
        "meta_favicon": "/images/kubernetes.png",
        "meta_site_name": "",
        "canonical_link": "https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/",
        "text": "Labels are key/value pairs that are attached to objects such as Pods. Labels are intended to be used to specify identifying attributes of objects that are meaningful and relevant to users, but do not directly imply semantics to the core system. Labels can be used to organize and to select subsets of objects. Labels can be attached to objects at creation time and subsequently added and modified at any time. Each object can have a set of key/value labels defined. Each Key must be unique for a given object.\n\nLabels allow for efficient queries and watches and are ideal for use in UIs and CLIs. Non-identifying information should be recorded using annotations.\n\nMotivation\n\nLabels enable users to map their own organizational structures onto system objects in a loosely coupled fashion, without requiring clients to store these mappings.\n\nService deployments and batch processing pipelines are often multi-dimensional entities (e.g., multiple partitions or deployments, multiple release tracks, multiple tiers, multiple micro-services per tier). Management often requires cross-cutting operations, which breaks encapsulation of strictly hierarchical representations, especially rigid hierarchies determined by the infrastructure rather than by users.\n\nExample labels:\n\n\"release\" : \"stable\", \"release\" : \"canary\"\n\n\"environment\" : \"dev\", \"environment\" : \"qa\", \"environment\" : \"production\"\n\n\"tier\" : \"frontend\", \"tier\" : \"backend\", \"tier\" : \"cache\"\n\n\"partition\" : \"customerA\", \"partition\" : \"customerB\"\n\n\"track\" : \"daily\", \"track\" : \"weekly\"\n\nThese are examples of commonly used labels; you are free to develop your own conventions. Keep in mind that label Key must be unique for a given object.\n\nSyntax and character set\n\nLabels are key/value pairs. Valid label keys have two segments: an optional prefix and name, separated by a slash (/). The name segment is required and must be 63 characters or less, beginning and ending with an alphanumeric character ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and alphanumerics between. The prefix is optional. If specified, the prefix must be a DNS subdomain: a series of DNS labels separated by dots (.), not longer than 253 characters in total, followed by a slash (/).\n\nIf the prefix is omitted, the label Key is presumed to be private to the user. Automated system components (e.g. kube-scheduler, kube-controller-manager, kube-apiserver, kubectl, or other third-party automation) which add labels to end-user objects must specify a prefix.\n\nThe kubernetes.io/ and k8s.io/ prefixes are reserved for Kubernetes core components.\n\nValid label value:\n\nmust be 63 characters or less (can be empty),\n\nunless empty, must begin and end with an alphanumeric character ([a-z0-9A-Z]),\n\ncould contain dashes (-), underscores (_), dots (.), and alphanumerics between.\n\nFor example, here's a manifest for a Pod that has two labels environment: production and app: nginx:\n\nLabel selectors\n\nUnlike names and UIDs, labels do not provide uniqueness. In general, we expect many objects to carry the same label(s).\n\nVia a label selector, the client/user can identify a set of objects. The label selector is the core grouping primitive in Kubernetes.\n\nThe API currently supports two types of selectors: equality-based and set-based. A label selector can be made of multiple requirements which are comma-separated. In the case of multiple requirements, all must be satisfied so the comma separator acts as a logical AND (&&) operator.\n\nThe semantics of empty or non-specified selectors are dependent on the context, and API types that use selectors should document the validity and meaning of them.\n\nNote:\n\nFor some API types, such as ReplicaSets, the label selectors of two instances must not overlap within a namespace, or the controller can see that as conflicting instructions and fail to determine how many replicas should be present.\n\nCaution:\n\nFor both equality-based and set-based conditions there is no logical OR (||) operator. Ensure your filter statements are structured accordingly.\n\nEquality-based requirement\n\nEquality- or inequality-based requirements allow filtering by label keys and values. Matching objects must satisfy all of the specified label constraints, though they may have additional labels as well. Three kinds of operators are admitted =,==,!=. The first two represent equality (and are synonyms), while the latter represents inequality. For example:\n\nenvironment = production tier != frontend\n\nThe former selects all resources with key equal to environment and value equal to production. The latter selects all resources with key equal to tier and value distinct from frontend, and all resources with no labels with the tier key. One could filter for resources in production excluding frontend using the comma operator: environment=production,tier!=frontend\n\nOne usage scenario for equality-based label requirement is for Pods to specify node selection criteria. For example, the sample Pod below selects nodes where the accelerator label exists and is set to nvidia-tesla-p100.\n\nSet-based requirement\n\nSet-based label requirements allow filtering keys according to a set of values. Three kinds of operators are supported: in,notin and exists (only the key identifier). For example:\n\nenvironment in (production, qa) tier notin (frontend, backend) partition !partition\n\nThe first example selects all resources with key equal to environment and value equal to production or qa.\n\nThe second example selects all resources with key equal to tier and values other than frontend and backend, and all resources with no labels with the tier key.\n\nThe third example selects all resources including a label with key partition; no values are checked.\n\nThe fourth example selects all resources without a label with key partition; no values are checked.\n\nSimilarly the comma separator acts as an AND operator. So filtering resources with a partition key (no matter the value) and with environment different than qa can be achieved using partition,environment notin (qa). The set-based label selector is a general form of equality since environment=production is equivalent to environment in (production); similarly for != and notin.\n\nSet-based requirements can be mixed with equality-based requirements. For example: partition in (customerA, customerB),environment!=qa.\n\nAPI\n\nLIST and WATCH filtering\n\nLIST and WATCH operations may specify label selectors to filter the sets of objects returned using a query parameter. Both requirements are permitted (presented here as they would appear in a URL query string):\n\nequality-based requirements: ?labelSelector=environment%3Dproduction,tier%3Dfrontend\n\nset-based requirements: ?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29\n\nBoth label selector styles can be used to list or watch resources via a REST client. For example, targeting apiserver with kubectl and using equality-based one may write:\n\nor using set-based requirements:\n\nAs already mentioned set-based requirements are more expressive. For instance, they can implement the OR operator on values:\n\nor restricting negative matching via notin operator:\n\nSet references in API objects\n\nSome Kubernetes objects, such as services and replicationcontrollers, also use label selectors to specify sets of other resources, such as pods.\n\nService and ReplicationController\n\nThe set of pods that a service targets is defined with a label selector. Similarly, the population of pods that a replicationcontroller should manage is also defined with a label selector.\n\nLabel selectors for both objects are defined in json or yaml files using maps, and only equality-based requirement selectors are supported:\n\nor\n\nThis selector (respectively in json or yaml format) is equivalent to component=redis or component in (redis).\n\nResources that support set-based requirements\n\nNewer resources, such as Job, Deployment, ReplicaSet, and DaemonSet, support set-based requirements as well.\n\nmatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". matchExpressions is a list of pod selector requirements. Valid operators include In, NotIn, Exists, and DoesNotExist. The values set must be non-empty in the case of In and NotIn. All of the requirements, from both matchLabels and matchExpressions are ANDed together -- they must all be satisfied in order to match.\n\nSelecting sets of nodes\n\nOne use case for selecting over labels is to constrain the set of nodes onto which a pod can schedule. See the documentation on node selection for more information.\n\nUsing labels effectively\n\nYou can apply a single label to any resources, but this is not always the best practice. There are many scenarios where multiple labels should be used to distinguish resource sets from one another.\n\nFor instance, different applications would use different values for the app label, but a multi-tier application, such as the guestbook example, would additionally need to distinguish each tier. The frontend could carry the following labels:\n\nwhile the Redis master and replica would have different tier labels, and perhaps even an additional role label:\n\nand\n\nThe labels allow for slicing and dicing the resources along any dimension specified by a label:\n\nNAME READY STATUS RESTARTS AGE APP TIER ROLE guestbook-fe-4nlpb 1/1 Running 0 1m guestbook frontend <none> guestbook-fe-ght6d 1/1 Running 0 1m guestbook frontend <none> guestbook-fe-jpy62 1/1 Running 0 1m guestbook frontend <none> guestbook-redis-master-5pg3b 1/1 Running 0 1m guestbook backend master guestbook-redis-replica-2q2yf 1/1 Running 0 1m guestbook backend replica guestbook-redis-replica-qgazl 1/1 Running 0 1m guestbook backend replica my-nginx-divi2 1/1 Running 0 29m nginx <none> <none> my-nginx-o0ef1 1/1 Running 0 29m nginx <none> <none>\n\nNAME READY STATUS RESTARTS AGE guestbook-redis-replica-2q2yf 1/1 Running 0 3m guestbook-redis-replica-qgazl 1/1 Running 0 3m\n\nUpdating labels\n\nSometimes you may want to relabel existing pods and other resources before creating new resources. This can be done with kubectl label. For example, if you want to label all your NGINX Pods as frontend tier, run:\n\npod/my-nginx-2035384211-j5fhi labeled pod/my-nginx-2035384211-u2c7e labeled pod/my-nginx-2035384211-u3t6x labeled\n\nThis first filters all pods with the label \"app=nginx\", and then labels them with the \"tier=fe\". To see the pods you labeled, run:\n\nNAME READY STATUS RESTARTS AGE TIER my-nginx-2035384211-j5fhi 1/1 Running 0 23m fe my-nginx-2035384211-u2c7e 1/1 Running 0 23m fe my-nginx-2035384211-u3t6x 1/1 Running 0 23m fe\n\nThis outputs all \"app=nginx\" pods, with an additional label column of pods' tier (specified with -L or --label-columns).\n\nFor more information, please see kubectl label.\n\nWhat's next"
    }
}