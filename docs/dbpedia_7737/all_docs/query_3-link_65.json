{
    "id": "dbpedia_7737_3",
    "rank": 65,
    "data": {
        "url": "https://linux-usb.vger.kernel.narkive.com/eqHAN5Vz/rfc-patch-2-2-usb-gadget-introduce-g-mtp-driver",
        "read_more_link": "",
        "language": "en",
        "title": "[RFC/PATCH 2/2] usb: gadget: introduce g",
        "top_image": "https://narkive.net/favicon.ico",
        "meta_img": "https://narkive.net/favicon.ico",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "https://narkive.net/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Felipe Balbi\n\nFrom: Roger Quadros <roger.quadros-***@public.gmane.org>\n\nThis provides a generic character driver implementation for use\n\nby USB function drivers. It provides a glue between USB function\n\nendpoints on one side and character device on the other.\n\nThe user space can read and write to the USB function's bulk OUT\n\nand bulk IN endpoints by reading/writing the character device.\n\nThe USB function character devices will be available at\n\n/dev/gc0...N\n\nSigned-off-by: Roger Quadros <roger.quadros-***@public.gmane.org>\n\nSigned-off-by: Felipe Balbi <felipe.balbi-***@public.gmane.org>\n\n---\n\ndrivers/usb/gadget/u_char.c | 979 +++++++++++++++++++++++++++++++++++++++++++\n\ndrivers/usb/gadget/u_char.h | 45 ++\n\n2 files changed, 1024 insertions(+), 0 deletions(-)\n\ncreate mode 100644 drivers/usb/gadget/u_char.c\n\ncreate mode 100644 drivers/usb/gadget/u_char.h\n\ndiff --git a/drivers/usb/gadget/u_char.c b/drivers/usb/gadget/u_char.c\n\nnew file mode 100644\n\nindex 0000000..7f3f437\n\n--- /dev/null\n\n+++ b/drivers/usb/gadget/u_char.c\n\n@@ -0,0 +1,979 @@\n\n+/*\n\n+ * u_char.c - USB character device glue\n\n+ *\n\n+ * Copyright (C) 2009-2010 Nokia Corporation\n\n+ * Author: Roger Quadros <roger.quadros-***@public.gmane.org>\n\n+ *\n\n+ * This program is free software; you can redistribute it and/or modify\n\n+ * it under the terms of the GNU General Public License as published by\n\n+ * the Free Software Foundation; either version 2 of the License, or\n\n+ * (at your option) any later version.\n\n+ *\n\n+ * This program is distributed in the hope that it will be useful,\n\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n\n+ * GNU General Public License for more details.\n\n+ *\n\n+ * You should have received a copy of the GNU General Public License\n\n+ * along with this program; if not, write to the Free Software\n\n+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n\n+ */\n\n+\n\n+#include <linux/poll.h>\n\n+#include <linux/list.h>\n\n+#include <linux/vmalloc.h>\n\n+#include <linux/interrupt.h>\n\n+#include <linux/kfifo.h>\n\n+#include \"u_char.h\"\n\n+\n\n+/* Max simultaneous gchar devices. Increase if you need more */\n\n+#define GC_MAX_DEVICES 4\n\n+\n\n+/* Number of USB requests that can be queued at a time */\n\n+#define GC_QUEUE_SIZE 16\n\n+\n\n+/* size in bytes of RX and TX FIFOs */\n\n+#define GC_BUF_SIZE 65536\n\n+\n\n+/*----------------USB glue----------------------------------*/\n\n+/*\n\n+ * gc_alloc_req\n\n+ *\n\n+ * Allocate a usb_request and its buffer. Returns a pointer to the\n\n+ * usb_request or NULL if there is an error.\n\n+ */\n\n+struct usb_request *\n\n+gc_alloc_req(struct usb_ep *ep, unsigned len, gfp_t kmalloc_flags)\n\n+{\n\n+ struct usb_request *req;\n\n+\n\n+ req = usb_ep_alloc_request(ep, kmalloc_flags);\n\n+\n\n+ if (req != NULL) {\n\n+ req->length = len;\n\n+ req->buf = kmalloc(len, kmalloc_flags);\n\n+ if (req->buf == NULL) {\n\n+ usb_ep_free_request(ep, req);\n\n+ return NULL;\n\n+ }\n\n+ }\n\n+\n\n+ return req;\n\n+}\n\n+\n\n+/*\n\n+ * gc_free_req\n\n+ *\n\n+ * Free a usb_request and its buffer.\n\n+ */\n\n+void gc_free_req(struct usb_ep *ep, struct usb_request *req)\n\n+{\n\n+ kfree(req->buf);\n\n+ usb_ep_free_request(ep, req);\n\n+}\n\n+\n\n+static int gc_alloc_requests(struct usb_ep *ep, struct list_head *head,\n\n+ void (*fn)(struct usb_ep *, struct usb_request *))\n\n+{\n\n+ int i;\n\n+ struct usb_request *req;\n\n+\n\n+ /* Pre-allocate up to GC_QUEUE_SIZE transfers, but if we can't\n\n+ * do quite that many this time, don't fail ... we just won't\n\n+ * be as speedy as we might otherwise be.\n\n+ */\n\n+ for (i = 0; i < GC_QUEUE_SIZE; i++) {\n\n+ req = gc_alloc_req(ep, ep->maxpacket, GFP_ATOMIC);\n\n+ if (!req)\n\n+ return list_empty(head) ? -ENOMEM : 0;\n\n+ req->complete = fn;\n\n+ list_add_tail(&req->list, head);\n\n+ }\n\n+ return 0;\n\n+}\n\n+\n\n+static void gc_free_requests(struct usb_ep *ep, struct list_head *head)\n\n+{\n\n+ struct usb_request *req;\n\n+\n\n+ while (!list_empty(head)) {\n\n+ req = list_entry(head->next, struct usb_request, list);\n\n+ list_del(&req->list);\n\n+ gc_free_req(ep, req);\n\n+ }\n\n+}\n\n+\n\n+/*----------------------------------------------------------------*/\n\n+\n\n+struct gc_req {\n\n+ struct usb_request *r;\n\n+ ssize_t l;\n\n+ wait_queue_head_t req_wait;\n\n+};\n\n+\n\n+struct gc_dev {\n\n+ struct gchar *gchar;\n\n+ struct device *dev; /* Driver model state */\n\n+ spinlock_t lock; /* serialize access */\n\n+ int opened; /* indicates if device open */\n\n+ wait_queue_head_t close_wait; /* wait for device close */\n\n+ int index; /* device index */\n\n+\n\n+ spinlock_t rx_lock; /* guard rx stuff */\n\n+ struct kfifo rx_fifo;\n\n+ void *rx_fifo_buf;\n\n+ struct list_head rx_pool;\n\n+ struct tasklet_struct rx_task;\n\n+ wait_queue_head_t rx_wait; /* wait for data in RX buf */\n\n+ unsigned int rx_queued; /* no. of queued requests */\n\n+\n\n+ spinlock_t tx_lock; /* guard tx stuff */\n\n+ struct kfifo tx_fifo;\n\n+ void *tx_fifo_buf;\n\n+ struct list_head tx_pool;\n\n+ wait_queue_head_t tx_wait; /* wait for space in TX buf */\n\n+ unsigned int tx_flush:1; /* flush TX buf */\n\n+ wait_queue_head_t tx_flush_wait;\n\n+ int tx_last_size; /*last tx packet's size*/\n\n+ struct tasklet_struct tx_task;\n\n+};\n\n+\n\n+struct gc_data {\n\n+ struct gc_dev *gcdevs;\n\n+ u8 nr_devs;\n\n+ struct class *class;\n\n+ dev_t dev;\n\n+ struct cdev chdev;\n\n+ struct usb_gadget *gadget;\n\n+};\n\n+\n\n+static struct gc_data gcdata;\n\n+\n\n+static void gc_rx_complete(struct usb_ep *ep, struct usb_request *req);\n\n+static void gc_tx_complete(struct usb_ep *ep, struct usb_request *req);\n\n+static int gc_do_rx(struct gc_dev *gc);\n\n+\n\n+\n\n+/*----------some more USB glue---------------------------*/\n\n+\n\n+/* OUT complete, we have new data to read */\n\n+static void gc_rx_complete(struct usb_ep *ep, struct usb_request *req)\n\n+{\n\n+ struct gc_dev *gc = ep->driver_data;\n\n+ unsigned long flags;\n\n+ int i;\n\n+\n\n+ spin_lock_irqsave(&gc->rx_lock, flags);\n\n+\n\n+ /* put received data into RX ring buffer */\n\n+ /* we assume enough space is there in RX buffer for this request\n\n+ * the checking should be done in gc_do_rx() before this request\n\n+ * was queued */\n\n+ switch (req->status) {\n\n+ case 0:\n\n+ /* normal completion */\n\n+ i = kfifo_in(&gc->rx_fifo, req->buf, req->actual);\n\n+ if (i != req->actual) {\n\n+ WARN(1, KERN_ERR \"%s: PUT(%d) != actual(%d) data \"\n\n+ \"loss possible. rx_queued = %d\\n\", __func__, i,\n\n+ req->actual, gc->rx_queued);\n\n+ }\n\n+ gc->rx_queued--;\n\n+ dev_vdbg(gc->dev,\n\n+ \"%s: rx len=%d, 0x%02x 0x%02x 0x%02x ...\\n\", __func__,\n\n+ req->actual, *((u8 *)req->buf),\n\n+ *((u8 *)req->buf+1), *((u8 *)req->buf+2));\n\n+\n\n+ /* wake up rx_wait */\n\n+ wake_up_interruptible(&gc->rx_wait);\n\n+ break;\n\n+ case -ESHUTDOWN:\n\n+ /* disconnect */\n\n+ dev_warn(gc->dev, \"%s: %s shutdown\\n\", __func__, ep->name);\n\n+ break;\n\n+ default:\n\n+ /* presumably a transient fault */\n\n+ dev_warn(gc->dev, \"%s: unexpected %s status %d\\n\",\n\n+ __func__, ep->name, req->status);\n\n+ break;\n\n+ }\n\n+\n\n+ /* recycle req back to rx pool */\n\n+ list_add_tail(&req->list, &gc->rx_pool);\n\n+ spin_unlock_irqrestore(&gc->rx_lock, flags);\n\n+ tasklet_schedule(&gc->rx_task);\n\n+}\n\n+\n\n+static int gc_do_tx(struct gc_dev *gc);\n\n+/* IN complete, i.e. USB write complete. we can free buffer */\n\n+static void gc_tx_complete(struct usb_ep *ep, struct usb_request *req)\n\n+{\n\n+ struct gc_dev *gc = ep->driver_data;\n\n+ unsigned long flags;\n\n+\n\n+ spin_lock_irqsave(&gc->tx_lock, flags);\n\n+ /* recycle back to pool */\n\n+ list_add_tail(&req->list, &gc->tx_pool);\n\n+ spin_unlock_irqrestore(&gc->tx_lock, flags);\n\n+\n\n+ switch (req->status) {\n\n+ case 0:\n\n+ /* normal completion, queue next request */\n\n+ tasklet_schedule(&gc->tx_task);\n\n+ break;\n\n+ case -ESHUTDOWN:\n\n+ /* disconnect */\n\n+ dev_warn(gc->dev, \"%s: %s shutdown\\n\", __func__, ep->name);\n\n+ break;\n\n+ default:\n\n+ /* presumably a transient fault */\n\n+ dev_warn(gc->dev, \"%s: unexpected %s status %d\\n\",\n\n+ __func__, ep->name, req->status);\n\n+ break;\n\n+ }\n\n+}\n\n+\n\n+\n\n+/* Read the TX buffer and send to USB */\n\n+/* gc->tx_lock must be held */\n\n+static int gc_do_tx(struct gc_dev *gc)\n\n+{\n\n+ struct list_head *pool = &gc->tx_pool;\n\n+ struct usb_ep *in = gc->gchar->ep_in;\n\n+ int status;\n\n+\n\n+ if (!in)\n\n+ return -ENODEV;\n\n+\n\n+ while (!list_empty(pool)) {\n\n+ struct usb_request *req;\n\n+ int len;\n\n+\n\n+ req = list_entry(pool->next, struct usb_request, list);\n\n+\n\n+ len = kfifo_len(&gc->tx_fifo);\n\n+ if (!len && !gc->tx_flush)\n\n+ /* TX buf empty */\n\n+ break;\n\n+\n\n+ list_del(&req->list);\n\n+\n\n+ req->zero = 0;\n\n+ if (len > in->maxpacket) {\n\n+ len = in->maxpacket;\n\n+ gc->tx_last_size = 0; /* not the last packet */\n\n+ } else {\n\n+ /* this is last packet in TX buf. send ZLP/SLP\n\n+ * if user has requested so\n\n+ */\n\n+ req->zero = gc->tx_flush;\n\n+ gc->tx_last_size = len;\n\n+ }\n\n+\n\n+ len = kfifo_out(&gc->tx_fifo, req->buf, len);\n\n+ req->length = len;\n\n+\n\n+ if (req->zero) {\n\n+ gc->tx_flush = 0;\n\n+ wake_up_interruptible(&gc->tx_flush_wait);\n\n+ }\n\n+\n\n+ dev_vdbg(gc->dev,\n\n+ \"%s: tx len=%d, 0x%02x 0x%02x 0x%02x ...\\n\", __func__,\n\n+ len, *((u8 *)req->buf),\n\n+ *((u8 *)req->buf+1), *((u8 *)req->buf+2));\n\n+ /* Drop lock while we call out of driver; completions\n\n+ * could be issued while we do so. Disconnection may\n\n+ * happen too; maybe immediately before we queue this!\n\n+ *\n\n+ * NOTE that we may keep sending data for a while after\n\n+ * the file is closed.\n\n+ */\n\n+ spin_unlock(&gc->tx_lock);\n\n+ status = usb_ep_queue(in, req, GFP_ATOMIC);\n\n+ spin_lock(&gc->tx_lock);\n\n+\n\n+ if (status) {\n\n+ dev_err(gc->dev, \"%s: %s %s err %d\\n\",\n\n+ __func__, \"queue\", in->name, status);\n\n+ list_add(&req->list, pool);\n\n+ break;\n\n+ }\n\n+\n\n+ /* abort immediately after disconnect */\n\n+ if (!gc->gchar) {\n\n+ dev_dbg(gc->dev,\n\n+ \"%s: disconnected so aborting\\n\", __func__);\n\n+ break;\n\n+ }\n\n+\n\n+ /* wake up tx_wait */\n\n+ wake_up_interruptible(&gc->tx_wait);\n\n+ }\n\n+ return 0;\n\n+}\n\n+\n\n+static void gc_tx_task(unsigned long _gc)\n\n+{\n\n+ struct gc_dev *gc = (void *)_gc;\n\n+\n\n+ spin_lock_irq(&gc->tx_lock);\n\n+ if (gc->gchar && gc->gchar->ep_in)\n\n+ gc_do_tx(gc);\n\n+ spin_unlock_irq(&gc->tx_lock);\n\n+}\n\n+\n\n+/* Tasklet: Queue USB read requests whenever RX buffer available\n\n+ * Must be called with gc->rx_lock held\n\n+ */\n\n+static int gc_do_rx(struct gc_dev *gc)\n\n+{\n\n+ /* Queue the request only if required space is there in RX buffer */\n\n+ struct list_head *pool = &gc->rx_pool;\n\n+ struct usb_ep *out = gc->gchar->ep_out;\n\n+ int started = 0;\n\n+\n\n+ if (!out)\n\n+ return -EINVAL;\n\n+\n\n+ while (!list_empty(pool)) {\n\n+ struct usb_request *req;\n\n+ int status;\n\n+\n\n+ req = list_entry(pool->next, struct usb_request, list);\n\n+ list_del(&req->list);\n\n+ req->length = out->maxpacket;\n\n+\n\n+ /* check if space is available in RX buf for this request */\n\n+ if (kfifo_avail(&gc->rx_fifo) <\n\n+ (gc->rx_queued + 2)*req->length) {\n\n+ /* insufficient space, recycle req */\n\n+ list_add(&req->list, pool);\n\n+ break;\n\n+ }\n\n+ gc->rx_queued++;\n\n+\n\n+ /* drop lock while we call out; the controller driver\n\n+ * may need to call us back (e.g. for disconnect)\n\n+ */\n\n+ spin_unlock(&gc->rx_lock);\n\n+ status = usb_ep_queue(out, req, GFP_ATOMIC);\n\n+ spin_lock(&gc->rx_lock);\n\n+\n\n+ if (status) {\n\n+ dev_warn(gc->dev, \"%s: %s %s err %d\\n\",\n\n+ __func__, \"queue\", out->name, status);\n\n+ list_add(&req->list, pool);\n\n+ break;\n\n+ }\n\n+\n\n+ started++;\n\n+\n\n+ /* abort immediately after disconnect */\n\n+ if (!gc->gchar) {\n\n+ dev_dbg(gc->dev, \"%s: disconnected so aborting\\n\",\n\n+ __func__);\n\n+ break;\n\n+ }\n\n+ }\n\n+ return started;\n\n+}\n\n+\n\n+\n\n+static void gc_rx_task(unsigned long _gc)\n\n+{\n\n+ struct gc_dev *gc = (void *)_gc;\n\n+\n\n+ spin_lock_irq(&gc->rx_lock);\n\n+ if (gc->gchar && gc->gchar->ep_out)\n\n+ gc_do_rx(gc);\n\n+ spin_unlock_irq(&gc->rx_lock);\n\n+}\n\n+\n\n+/*----------FILE Operations-------------------------------*/\n\n+\n\n+static int gc_open(struct inode *inode, struct file *filp)\n\n+{\n\n+ unsigned minor = iminor(inode);\n\n+ struct gc_dev *gc;\n\n+ int index;\n\n+\n\n+ index = minor - MINOR(gcdata.dev);\n\n+ if (index >= gcdata.nr_devs)\n\n+ return -ENODEV;\n\n+\n\n+ if (!gcdata.gcdevs)\n\n+ return -ENODEV;\n\n+\n\n+ if (!gcdata.gcdevs[index].gchar)\n\n+ return -ENODEV;\n\n+\n\n+ filp->private_data = &gcdata.gcdevs[index];\n\n+ gc = filp->private_data;\n\n+\n\n+ /* prevent multiple opens for now */\n\n+ if (gc->opened)\n\n+ return -EBUSY;\n\n+ spin_lock_irq(&gc->lock);\n\n+ if (gc->opened) {\n\n+ spin_unlock_irq(&gc->lock);\n\n+ return -EBUSY;\n\n+ }\n\n+ gc->opened = 1;\n\n+ spin_unlock_irq(&gc->lock);\n\n+ gc->index = index;\n\n+\n\n+ if (!gc->tx_fifo_buf && gc->gchar->ep_in) {\n\n+ gc->tx_fifo_buf = vmalloc(GC_BUF_SIZE);\n\n+ if (gc->tx_fifo_buf == NULL)\n\n+ return -ENOMEM;\n\n+ kfifo_init(&gcdata.gcdevs[minor].tx_fifo,\n\n+ gc->tx_fifo_buf, GC_BUF_SIZE);\n\n+ }\n\n+\n\n+ if (!gc->rx_fifo_buf && gc->gchar->ep_out) {\n\n+ gc->rx_fifo_buf = vmalloc(GC_BUF_SIZE);\n\n+ if (gc->rx_fifo_buf == NULL) {\n\n+ vfree(gc->tx_fifo_buf);\n\n+ return -ENOMEM;\n\n+ }\n\n+ kfifo_init(&gcdata.gcdevs[minor].rx_fifo,\n\n+ gc->rx_fifo_buf, GC_BUF_SIZE);\n\n+ }\n\n+\n\n+ if (gc->gchar && gc->gchar->open)\n\n+ gc->gchar->open(gc->gchar);\n\n+\n\n+ /* if connected, start receiving */\n\n+ if (gc->gchar)\n\n+ tasklet_schedule(&gc->rx_task);\n\n+\n\n+ dev_dbg(gc->dev, \"%s: gc%d opened\\n\", __func__, gc->index);\n\n+ return 0;\n\n+}\n\n+\n\n+static int gc_release(struct inode *inode, struct file *filp)\n\n+{\n\n+ struct gc_dev *gc = filp->private_data;\n\n+\n\n+ filp->private_data = NULL;\n\n+\n\n+ dev_dbg(gc->dev, \"%s: releasing gc%d\\n\", __func__, gc->index);\n\n+\n\n+ if (!gc->opened)\n\n+ goto gc_release_exit;\n\n+\n\n+ vfree(gc->tx_fifo_buf);\n\n+ gc->tx_fifo_buf = NULL;\n\n+ vfree(gc->rx_fifo_buf);\n\n+ gc->rx_fifo_buf = NULL;\n\n+\n\n+ if (gc->gchar && gc->gchar->close)\n\n+ gc->gchar->close(gc->gchar);\n\n+\n\n+ spin_lock_irq(&gc->lock);\n\n+ gc->opened = 0;\n\n+ spin_unlock_irq(&gc->lock);\n\n+\n\n+ wake_up_interruptible(&gc->close_wait);\n\n+\n\n+gc_release_exit:\n\n+ dev_dbg(gc->dev, \"%s: gc%d released!!\\n\", __func__, gc->index);\n\n+ return 0;\n\n+}\n\n+\n\n+static int gc_can_read(struct gc_dev *gc)\n\n+{\n\n+ int ret;\n\n+\n\n+ spin_lock_irq(&gc->rx_lock);\n\n+ ret = kfifo_len(&gc->rx_fifo) ? 1 : 0;\n\n+ spin_unlock_irq(&gc->rx_lock);\n\n+\n\n+ return ret;\n\n+}\n\n+\n\n+static ssize_t gc_read(struct file *filp, char __user *buff,\n\n+ size_t len, loff_t *o)\n\n+{\n\n+ struct gc_dev *gc = filp->private_data;\n\n+ int read = 0;\n\n+\n\n+ if (!gc->gchar || !gc->gchar->ep_out) {\n\n+ /* not yet connected or reading not possible*/\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ if (len) {\n\n+ read = kfifo_len(&gc->rx_fifo);\n\n+ if (!read) {\n\n+ /* if NONBLOCK then return immediately */\n\n+ if (filp->f_flags & O_NONBLOCK)\n\n+ return -EAGAIN;\n\n+\n\n+ /* sleep till we have some data */\n\n+ if (wait_event_interruptible(gc->rx_wait,\n\n+ gc_can_read(gc)))\n\n+ return -ERESTARTSYS;\n\n+\n\n+ }\n\n+ read = kfifo_to_user(&gc->rx_fifo, buff, len);\n\n+ }\n\n+\n\n+ if (read > 0) {\n\n+ spin_lock_irq(&gc->rx_lock);\n\n+ gc_do_rx(gc);\n\n+ spin_unlock_irq(&gc->rx_lock);\n\n+ }\n\n+\n\n+ dev_vdbg(gc->dev, \"%s done %d/%d\\n\", __func__, read, len);\n\n+ return read;\n\n+}\n\n+\n\n+static int gc_can_write(struct gc_dev *gc)\n\n+{\n\n+ int ret;\n\n+\n\n+ spin_lock_irq(&gc->tx_lock);\n\n+ ret = !kfifo_is_full(&gc->tx_fifo);\n\n+ spin_unlock_irq(&gc->tx_lock);\n\n+\n\n+ return ret;\n\n+}\n\n+\n\n+static ssize_t gc_write(struct file *filp, const char __user *buff,\n\n+ size_t len, loff_t *o)\n\n+{\n\n+ struct gc_dev *gc = filp->private_data;\n\n+ int wrote = 0;\n\n+\n\n+ if (!gc->gchar || !gc->gchar->ep_in) {\n\n+ /* not yet connected or writing not possible */\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ if (len) {\n\n+ if (kfifo_is_full(&gc->tx_fifo)) {\n\n+ if (filp->f_flags & O_NONBLOCK)\n\n+ return -EAGAIN;\n\n+\n\n+ /* sleep till we have some space to write into */\n\n+ if (wait_event_interruptible(gc->tx_wait,\n\n+ gc_can_write(gc)))\n\n+ return -ERESTARTSYS;\n\n+\n\n+ }\n\n+ wrote = kfifo_from_user(&gc->tx_fifo, buff, len);\n\n+ if (wrote < 0)\n\n+ dev_warn(gc->dev, \"%s fault %d\\n\", __func__, wrote);\n\n+ }\n\n+\n\n+ if (wrote > 0) {\n\n+ spin_lock_irq(&gc->tx_lock);\n\n+ gc_do_tx(gc);\n\n+ spin_unlock_irq(&gc->tx_lock);\n\n+ }\n\n+\n\n+ dev_vdbg(gc->dev, \"%s done %d/%d\\n\", __func__, wrote, len);\n\n+ return wrote;\n\n+}\n\n+\n\n+static long gc_ioctl(struct file *filp, unsigned code, unsigned long value)\n\n+{\n\n+ struct gc_dev *gc = filp->private_data;\n\n+ int status = -EINVAL;\n\n+\n\n+ if (gc->gchar && gc->gchar->ioctl)\n\n+ status = gc->gchar->ioctl(gc->gchar, code, value);\n\n+\n\n+ dev_dbg(gc->dev, \"%s done\\n\", __func__);\n\n+ return status;\n\n+}\n\n+\n\n+static unsigned int gc_poll(struct file *filp, struct poll_table_struct *pt)\n\n+{\n\n+ struct gc_dev *gc = filp->private_data;\n\n+ int ret = 0;\n\n+ int rx = 0, tx = 0;\n\n+\n\n+ /* generic poll implementation */\n\n+ poll_wait(filp, &gc->rx_wait, pt);\n\n+ poll_wait(filp, &gc->tx_wait, pt);\n\n+\n\n+ if (!gc->gchar) {\n\n+ /* not yet connected */\n\n+ goto poll_exit;\n\n+ }\n\n+\n\n+ /* check if data is available to read */\n\n+ spin_lock_irq(&gc->rx_lock);\n\n+ if (gc->gchar->ep_out) {\n\n+ rx = kfifo_len(&gc->rx_fifo);\n\n+ if (rx)\n\n+ ret |= POLLIN | POLLRDNORM;\n\n+ }\n\n+ spin_unlock_irq(&gc->rx_lock);\n\n+\n\n+ /* check if space is available to write */\n\n+ spin_lock_irq(&gc->tx_lock);\n\n+ if (gc->gchar->ep_in) {\n\n+ tx = kfifo_avail(&gc->tx_fifo);\n\n+ if (tx)\n\n+ ret |= POLLOUT | POLLWRNORM;\n\n+ }\n\n+ spin_unlock_irq(&gc->tx_lock);\n\n+\n\n+ dev_dbg(gc->dev, \"%s: rx avl %d, tx space %d\\n\", __func__, rx, tx);\n\n+poll_exit:\n\n+\n\n+ return ret;\n\n+}\n\n+\n\n+int gc_fsync(struct file *filp, struct dentry *dentry, int datasync)\n\n+{\n\n+ struct gc_dev *gc = filp->private_data;\n\n+\n\n+ if (!gc->gchar || !gc->gchar->ep_in) {\n\n+ /* not yet connected or writing not possible */\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ /* flush the TX buffer and send ZLP/SLP\n\n+ * we will wait till TX buffer is empty\n\n+ */\n\n+ spin_lock_irq(&gc->tx_lock);\n\n+\n\n+ if (gc->tx_flush) {\n\n+ dev_err(gc->dev, \"%s tx_flush already requested\\n\", __func__);\n\n+ spin_unlock_irq(&gc->tx_lock);\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ if (!kfifo_len(&gc->tx_fifo)) {\n\n+ if (gc->tx_last_size == gc->gchar->ep_in->maxpacket)\n\n+ gc->tx_flush = 1;\n\n+ } else\n\n+ gc->tx_flush = 1;\n\n+\n\n+ if (gc->tx_flush) {\n\n+ gc_do_tx(gc);\n\n+\n\n+ spin_unlock_irq(&gc->tx_lock);\n\n+\n\n+ if (wait_event_interruptible(gc->tx_flush_wait,\n\n+ !gc->tx_flush))\n\n+ return -ERESTARTSYS;\n\n+ } else\n\n+ spin_unlock_irq(&gc->tx_lock);\n\n+\n\n+ dev_dbg(gc->dev, \"%s complete\\n\", __func__);\n\n+ return 0;\n\n+}\n\n+\n\n+static const struct file_operations gc_fops = {\n\n+ .owner = THIS_MODULE,\n\n+ .open = gc_open,\n\n+ .poll = gc_poll,\n\n+ .unlocked_ioctl = gc_ioctl,\n\n+ .release = gc_release,\n\n+ .read = gc_read,\n\n+ .write = gc_write,\n\n+ .fsync = gc_fsync,\n\n+};\n\n+\n\n+/*------------USB Gadget Driver Interface----------------------------*/\n\n+\n\n+/**\n\n+ * gchar_setup - initialize the character driver for one or more devices\n\n+ * @g: gadget to associate with these devices\n\n+ * @devs_num: number of character devices to support\n\n+ * Context: may sleep\n\n+ *\n\n+ * This driver needs to know how many char. devices it should manage.\n\n+ * Use this call to set up the devices that will be exported through USB.\n\n+ * Later, connect them to functions based on what configuration is activated\n\n+ * by the USB host, and disconnect them as appropriate.\n\n+ *\n\n+ * Returns negative errno or zero.\n\n+ */\n\n+int __init gchar_setup(struct usb_gadget *g, u8 devs_num)\n\n+{\n\n+ int status;\n\n+ int i = 0;\n\n+\n\n+ if (gcdata.nr_devs)\n\n+ return -EBUSY;\n\n+\n\n+ if (devs_num == 0 || devs_num > GC_MAX_DEVICES)\n\n+ return -EINVAL;\n\n+\n\n+ gcdata.gcdevs = kzalloc(sizeof(struct gc_dev) * devs_num, GFP_KERNEL);\n\n+ if (!gcdata.gcdevs)\n\n+ return -ENOMEM;\n\n+\n\n+ /* created char dev */\n\n+ status = alloc_chrdev_region(&gcdata.dev, 0, devs_num, \"gchar\");\n\n+ if (status)\n\n+ goto fail1;\n\n+\n\n+ cdev_init(&gcdata.chdev, &gc_fops);\n\n+\n\n+ gcdata.chdev.owner = THIS_MODULE;\n\n+ gcdata.nr_devs = devs_num;\n\n+\n\n+ status = cdev_add(&gcdata.chdev, gcdata.dev, devs_num);\n\n+ if (status)\n\n+ goto fail2;\n\n+\n\n+ /* register with sysfs */\n\n+ gcdata.class = class_create(THIS_MODULE, \"gchar\");\n\n+ if (IS_ERR(gcdata.class)) {\n\n+ pr_err(\"%s: could not create class gchar\\n\", __func__);\n\n+ status = PTR_ERR(gcdata.class);\n\n+ goto fail3;\n\n+ }\n\n+\n\n+ for (i = 0; i < devs_num; i++) {\n\n+ struct gc_dev *gc;\n\n+\n\n+ gc = &gcdata.gcdevs[i];\n\n+ spin_lock_init(&gc->lock);\n\n+ spin_lock_init(&gc->rx_lock);\n\n+ spin_lock_init(&gc->tx_lock);\n\n+ INIT_LIST_HEAD(&gc->rx_pool);\n\n+ INIT_LIST_HEAD(&gc->tx_pool);\n\n+ init_waitqueue_head(&gc->rx_wait);\n\n+ init_waitqueue_head(&gc->tx_wait);\n\n+ init_waitqueue_head(&gc->tx_flush_wait);\n\n+ init_waitqueue_head(&gc->close_wait);\n\n+\n\n+ tasklet_init(&gc->rx_task, gc_rx_task, (unsigned long) gc);\n\n+ tasklet_init(&gc->tx_task, gc_tx_task, (unsigned long) gc);\n\n+ gc->dev = device_create(gcdata.class, NULL,\n\n+ MKDEV(MAJOR(gcdata.dev), MINOR(gcdata.dev) + i),\n\n+ NULL, \"gc%d\", i);\n\n+ if (IS_ERR(gc->dev)) {\n\n+ pr_err(\"%s: device_create() failed for device %d\\n\",\n\n+ __func__, i);\n\n+ for ( ; i > 0; i--) {\n\n+ device_destroy(gcdata.class,\n\n+ MKDEV(MAJOR(gcdata.dev),\n\n+ MINOR(gcdata.dev) + i));\n\n+ }\n\n+ goto fail4;\n\n+ }\n\n+ }\n\n+\n\n+ gcdata.gadget = g;\n\n+\n\n+ return 0;\n\n+\n\n+fail4:\n\n+ class_destroy(gcdata.class);\n\n+fail3:\n\n+ cdev_del(&gcdata.chdev);\n\n+fail2:\n\n+ unregister_chrdev_region(gcdata.dev, gcdata.nr_devs);\n\n+fail1:\n\n+ kfree(gcdata.gcdevs);\n\n+ gcdata.gcdevs = NULL;\n\n+ gcdata.nr_devs = 0;\n\n+\n\n+ return status;\n\n+}\n\n+\n\n+static int gc_closed(struct gc_dev *gc)\n\n+{\n\n+ int ret;\n\n+\n\n+ spin_lock_irq(&gc->lock);\n\n+ ret = !gc->opened;\n\n+ spin_unlock_irq(&gc->lock);\n\n+ return ret;\n\n+}\n\n+\n\n+/**\n\n+ * gchar_cleanup - remove the USB to character devicer and devices\n\n+ * Context: may sleep\n\n+ *\n\n+ * This is called to free all resources allocated by @gchar_setup().\n\n+ * It may need to wait until some open /dev/ files have been closed.\n\n+ */\n\n+void gchar_cleanup(void)\n\n+{\n\n+ int i;\n\n+\n\n+ if (!gcdata.gcdevs)\n\n+ return;\n\n+\n\n+ for (i = 0; i < gcdata.nr_devs; i++) {\n\n+ struct gc_dev *gc = &gcdata.gcdevs[i];\n\n+\n\n+ tasklet_kill(&gc->rx_task);\n\n+ tasklet_kill(&gc->tx_task);\n\n+ device_destroy(gcdata.class, MKDEV(MAJOR(gcdata.dev),\n\n+ MINOR(gcdata.dev) + i));\n\n+ /* wait till open files are closed */\n\n+ wait_event(gc->close_wait, gc_closed(gc));\n\n+ }\n\n+\n\n+ cdev_del(&gcdata.chdev);\n\n+ class_destroy(gcdata.class);\n\n+\n\n+ /* cdev_put(&gchar>chdev); */\n\n+ unregister_chrdev_region(gcdata.dev, gcdata.nr_devs);\n\n+\n\n+ kfree(gcdata.gcdevs);\n\n+ gcdata.gcdevs = NULL;\n\n+ gcdata.nr_devs = 0;\n\n+}\n\n+\n\n+/**\n\n+ * gchar_connect - notify the driver that USB link is active\n\n+ * @gchar: the function, setup with endpoints and descriptors\n\n+ * @num: the device number that is active\n\n+ * @name: name of the function\n\n+ * Context: any (usually from irq)\n\n+ *\n\n+ * This is called to activate the endpoints and let the driver know\n\n+ * that USB link is active.\n\n+ *\n\n+ * Caller needs to have set up the endpoints and USB function in @gchar\n\n+ * before calling this, as well as the appropriate (speed-specific)\n\n+ * endpoint descriptors, and also have set up the char driver by calling\n\n+ * @gchar_setup().\n\n+ *\n\n+ * Returns negative error or zeroa\n\n+ * On success, ep->driver_data will be overwritten\n\n+ */\n\n+int gchar_connect(struct gchar *gchar, u8 num, const char *name)\n\n+{\n\n+ int status = 0;\n\n+ struct gc_dev *gc;\n\n+\n\n+ if (num >= gcdata.nr_devs) {\n\n+ pr_err(\"%s: invalid device number\\n\", __func__);\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ gc = &gcdata.gcdevs[num];\n\n+\n\n+ dev_dbg(gc->dev, \"%s %s %d\\n\", __func__, name, num);\n\n+\n\n+ if (!gchar->ep_out && !gchar->ep_in) {\n\n+ dev_err(gc->dev, \"%s: Neither IN nor OUT endpoint available\\n\",\n\n+ __func__);\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ if (gchar->ep_out) {\n\n+ status = usb_ep_enable(gchar->ep_out, gchar->ep_out_desc);\n\n+ if (status < 0)\n\n+ return status;\n\n+\n\n+ gchar->ep_out->driver_data = gc;\n\n+ }\n\n+\n\n+ if (gchar->ep_in) {\n\n+ status = usb_ep_enable(gchar->ep_in, gchar->ep_in_desc);\n\n+ if (status < 0)\n\n+ goto fail1;\n\n+\n\n+ gchar->ep_in->driver_data = gc;\n\n+ }\n\n+\n\n+ kfifo_reset(&gc->tx_fifo);\n\n+ kfifo_reset(&gc->rx_fifo);\n\n+ gc->rx_queued = 0;\n\n+ gc->tx_flush = 0;\n\n+ gc->tx_last_size = 0;\n\n+\n\n+ if (gchar->ep_out) {\n\n+ status = gc_alloc_requests(gchar->ep_out, &gc->rx_pool,\n\n+ &gc_rx_complete);\n\n+ if (status)\n\n+ goto fail2;\n\n+ }\n\n+\n\n+ if (gchar->ep_in) {\n\n+ status = gc_alloc_requests(gchar->ep_in, &gc->tx_pool,\n\n+ &gc_tx_complete);\n\n+ if (status)\n\n+ goto fail3;\n\n+ }\n\n+\n\n+ /* connect gchar */\n\n+ gc->gchar = gchar;\n\n+\n\n+ /* if userspace has opened the device, enable function */\n\n+ if (gc->opened)\n\n+ gc->gchar->open(gc->gchar);\n\n+\n\n+ /* if device is opened by user space then start RX */\n\n+ if (gc->opened)\n\n+ tasklet_schedule(&gc->rx_task);\n\n+\n\n+ dev_dbg(gc->dev, \"%s complete\\n\", __func__);\n\n+ return 0;\n\n+\n\n+fail3:\n\n+ if (gchar->ep_out)\n\n+ gc_free_requests(gchar->ep_out, &gc->rx_pool);\n\n+\n\n+fail2:\n\n+ if (gchar->ep_in) {\n\n+ gchar->ep_in->driver_data = NULL;\n\n+ usb_ep_disable(gchar->ep_in);\n\n+ }\n\n+fail1:\n\n+ if (gchar->ep_out) {\n\n+ gchar->ep_out->driver_data = NULL;\n\n+ usb_ep_disable(gchar->ep_out);\n\n+ }\n\n+\n\n+ return status;\n\n+}\n\n+\n\n+/**\n\n+ * gchar_disconnect - notify the driver that USB link is inactive\n\n+ * @gchar: the function, on which, gchar_connect() was called\n\n+ * Context: any (usually from irq)\n\n+ *\n\n+ * this is called to deactivate the endpoints (related to @gchar)\n\n+ * and let the driver know that the USB link is inactive\n\n+ */\n\n+void gchar_disconnect(struct gchar *gchar)\n\n+{\n\n+ struct gc_dev *gc;\n\n+\n\n+ if (!gchar->ep_out && !gchar->ep_in)\n\n+ return;\n\n+\n\n+ if (gchar->ep_out)\n\n+ gc = gchar->ep_out->driver_data;\n\n+ else\n\n+ gc = gchar->ep_in->driver_data;\n\n+\n\n+ if (!gc) {\n\n+ pr_err(\"%s Invalid gc_dev\\n\", __func__);\n\n+ return;\n\n+ }\n\n+\n\n+ spin_lock(&gc->lock);\n\n+\n\n+ if (gchar->ep_out) {\n\n+ usb_ep_disable(gchar->ep_out);\n\n+ gc_free_requests(gc->gchar->ep_out, &gc->rx_pool);\n\n+ }\n\n+\n\n+ if (gchar->ep_in) {\n\n+ usb_ep_disable(gchar->ep_in);\n\n+ gc_free_requests(gc->gchar->ep_in, &gc->tx_pool);\n\n+ }\n\n+\n\n+ gc->gchar = NULL;\n\n+ gchar->ep_out->driver_data = NULL;\n\n+ gchar->ep_in->driver_data = NULL;\n\n+\n\n+ spin_unlock(&gc->lock);\n\n+}\n\ndiff --git a/drivers/usb/gadget/u_char.h b/drivers/usb/gadget/u_char.h\n\nnew file mode 100644\n\nindex 0000000..abbf550\n\n--- /dev/null\n\n+++ b/drivers/usb/gadget/u_char.h\n\n@@ -0,0 +1,45 @@\n\n+/*\n\n+ * Copyright (C) 2009-2010 Nokia Corporation\n\n+ * Contact: Roger Quadros <roger.quadros-***@public.gmane.org>\n\n+ *\n\n+ * This program is free software; you can redistribute it and/or modify\n\n+ * it under the terms of the GNU General Public License as published by\n\n+ * the Free Software Foundation; either version 2 of the License, or\n\n+ * (at your option) any later version.\n\n+ *\n\n+ * This program is distributed in the hope that it will be useful,\n\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n\n+ * GNU General Public License for more details.\n\n+ *\n\n+ * You should have received a copy of the GNU General Public License\n\n+ * along with this program; if not, write to the Free Software\n\n+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n\n+ */\n\n+\n\n+#ifndef __U_CHAR_H\n\n+#define __U_CHAR_H\n\n+\n\n+#include <linux/kernel.h>\n\n+#include <linux/device.h>\n\n+#include <linux/cdev.h>\n\n+\n\n+struct gchar {\n\n+ struct usb_gadget *gadget;\n\n+ struct usb_function func;\n\n+\n\n+ struct usb_ep *ep_out;\n\n+ struct usb_ep *ep_in;\n\n+ struct usb_endpoint_descriptor *ep_out_desc;\n\n+ struct usb_endpoint_descriptor *ep_in_desc;\n\n+\n\n+ void (*open)(struct gchar *);\n\n+ void (*close)(struct gchar *);\n\n+ long (*ioctl)(struct gchar *, unsigned int, unsigned long);\n\n+};\n\n+\n\n+int __init gchar_setup(struct usb_gadget *g, u8 devs_num);\n\n+void gchar_cleanup(void);\n\n+int gchar_connect(struct gchar *gchar, u8 num, const char *name);\n\n+void gchar_disconnect(struct gchar *gchar);\n\n+#endif\n\n--\n\n1.7.0.rc0.33.g7c3932\n\n--\n\nTo unsubscribe from this list: send the line \"unsubscribe linux-usb\" in\n\nthe body of a message to majordomo-***@public.gmane.org\n\nMore majordomo info at http://vger.kernel.org/majordomo-info.html\n\nFelipe Balbi\n\nFrom: Yauheni Kaliuta <yauheni.kaliuta-***@public.gmane.org>\n\ng_mtp is the gadget driver implementing\n\nmedia transfer protocol.\n\nSigned-off-by: Yauheni Kaliuta <yauheni.kaliuta-***@public.gmane.org>\n\nSigned-off-by: Felipe Balbi <felipe.balbi-***@public.gmane.org>\n\n---\n\ndrivers/usb/gadget/Kconfig | 11 +\n\ndrivers/usb/gadget/Makefile | 2 +\n\ndrivers/usb/gadget/f_mtp.c | 869 +++++++++++++++++++++++++++++++++++++++++++\n\ndrivers/usb/gadget/mtp.c | 249 +++++++++++++\n\n4 files changed, 1131 insertions(+), 0 deletions(-)\n\ncreate mode 100644 drivers/usb/gadget/f_mtp.c\n\ncreate mode 100644 drivers/usb/gadget/mtp.c\n\ndiff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig\n\nindex 7460cd7..876f534 100644\n\n--- a/drivers/usb/gadget/Kconfig\n\n+++ b/drivers/usb/gadget/Kconfig\n\n@@ -822,6 +822,17 @@ config USB_G_NOKIA\n\nIt's only really useful for N900 hardware. If you're building\n\na kernel for N900, say Y or M here. If unsure, say N.\n\n+config USB_G_MTP\n\n+ tristate \"Media Transfer Protocol (MTP) Gadget\"\n\n+ help\n\n+ The Media Transfer Protocol gadget provides support for MTP,\n\n+ which is used to transfer different types of media files\n\n+ (music, pictures, movies) to/from multimedia devices like\n\n+ digital cameras or multimedia players.\n\n+\n\n+ Say \"y\" to link the driver statically, or \"m\" to build a\n\n+ dynamically linked module called \"g_mtp\".\n\n+\n\nconfig USB_G_MULTI\n\ntristate \"Multifunction Composite Gadget (EXPERIMENTAL)\"\n\ndepends on BLOCK && NET\n\ndiff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile\n\nindex 43b51da..eae8f2d 100644\n\n--- a/drivers/usb/gadget/Makefile\n\n+++ b/drivers/usb/gadget/Makefile\n\n@@ -44,6 +44,7 @@ g_printer-objs := printer.o\n\ng_cdc-objs := cdc2.o\n\ng_multi-objs := multi.o\n\ng_nokia-objs := nokia.o\n\n+g_mtp-objs := mtp.o\n\nobj-$(CONFIG_USB_ZERO) += g_zero.o\n\nobj-$(CONFIG_USB_AUDIO) += g_audio.o\n\n@@ -57,4 +58,5 @@ obj-$(CONFIG_USB_MIDI_GADGET) += g_midi.o\n\nobj-$(CONFIG_USB_CDC_COMPOSITE) += g_cdc.o\n\nobj-$(CONFIG_USB_G_MULTI) += g_multi.o\n\nobj-$(CONFIG_USB_G_NOKIA) += g_nokia.o\n\n+obj-$(CONFIG_USB_G_MTP) += g_mtp.o\n\ndiff --git a/drivers/usb/gadget/f_mtp.c b/drivers/usb/gadget/f_mtp.c\n\nnew file mode 100644\n\nindex 0000000..80df951\n\n--- /dev/null\n\n+++ b/drivers/usb/gadget/f_mtp.c\n\n@@ -0,0 +1,869 @@\n\n+/*\n\n+ * f_mtp.c -- USB MTP Function Driver\n\n+ *\n\n+ * Copyright (C) 2009 Nokia Corporation\n\n+ * Contact: Roger Quadros <roger.quadros at nokia.com>\n\n+ *\n\n+ * Based on f_obex.c by Felipe Balbi\n\n+ *\n\n+ * This program is free software; you can redistribute it and/or modify\n\n+ * it under the terms of the GNU General Public License as published by\n\n+ * the Free Software Foundation; either version 2 of the License, or\n\n+ * (at your option) any later version.\n\n+ *\n\n+ * This program is distributed in the hope that it will be useful,\n\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n\n+ * GNU General Public License for more details.\n\n+ *\n\n+ * You should have received a copy of the GNU General Public License\n\n+ * along with this program; if not, write to the Free Software\n\n+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n\n+ */\n\n+\n\n+#include <linux/kernel.h>\n\n+#include <linux/device.h>\n\n+#include <linux/utsname.h>\n\n+#include <linux/uaccess.h>\n\n+#include <linux/ioctl.h>\n\n+#include <linux/usb/ptp.h>\n\n+#include \"u_char.h\"\n\n+#include \"gadget_chips.h\"\n\n+\n\n+struct mtp_ep_desc {\n\n+ struct usb_endpoint_descriptor *mtp_in;\n\n+ struct usb_endpoint_descriptor *mtp_out;\n\n+ struct usb_endpoint_descriptor *mtp_int;\n\n+};\n\n+\n\n+#define MAX_STATUS_DATA_SIZE (PTP_MAX_STATUS_SIZE - 4)\n\n+/* device status cache */\n\n+struct device_status {\n\n+ u16 length;\n\n+ u16 code;\n\n+ u8 data[MAX_STATUS_DATA_SIZE];\n\n+};\n\n+\n\n+struct f_mtp {\n\n+ struct gchar gc;\n\n+ struct usb_composite_dev *cdev;\n\n+ u8 ctrl_id;\n\n+ u8 mtp_id;\n\n+ u8 minor;\n\n+ u8 connected;\n\n+ struct device_status dev_status;\n\n+ spinlock_t lock;\n\n+\n\n+ struct mtp_ep_desc fs;\n\n+ struct mtp_ep_desc hs;\n\n+\n\n+ struct usb_ep *notify;\n\n+ struct usb_endpoint_descriptor *notify_desc;\n\n+\n\n+ int usb_speed;\n\n+};\n\n+\n\n+/*-------------------------------------------------------------------------*/\n\n+\n\n+static inline struct f_mtp *func_to_mtp(struct usb_function *f)\n\n+{\n\n+ return container_of(f, struct f_mtp, gc.func);\n\n+}\n\n+\n\n+static inline struct f_mtp *gchar_to_mtp(struct gchar *p)\n\n+{\n\n+ return container_of(p, struct f_mtp, gc);\n\n+}\n\n+\n\n+/*\n\n+ * USB String Descriptors\n\n+ */\n\n+\n\n+static struct usb_string mtp_string_defs[] = {\n\n+ { 0, \"MTP\" ,},\n\n+ { /* ZEROES END LIST */ },\n\n+};\n\n+\n\n+static struct usb_gadget_strings mtp_string_table = {\n\n+ .language = 0x0409, /* en-US */\n\n+ .strings = mtp_string_defs,\n\n+};\n\n+\n\n+static struct usb_gadget_strings *mtp_strings[] = {\n\n+ &mtp_string_table,\n\n+ NULL,\n\n+};\n\n+\n\n+/*\n\n+ * USB Interface Descriptors\n\n+ */\n\n+\n\n+static struct usb_interface_descriptor mtp_intf __initdata = {\n\n+ .bLength = sizeof(mtp_intf),\n\n+ .bDescriptorType = USB_DT_INTERFACE,\n\n+ .bAlternateSetting = 0,\n\n+ .bNumEndpoints = 3,\n\n+ .bInterfaceClass = USB_CLASS_STILL_IMAGE,\n\n+ .bInterfaceSubClass = USB_SUBCLASS_PTP,\n\n+ .bInterfaceProtocol = USB_PROTOCOL_PTP,\n\n+};\n\n+\n\n+/*\n\n+ * USB Endpoint Descriptors\n\n+ */\n\n+\n\n+/* High speed support */\n\n+static struct usb_endpoint_descriptor mtp_ep_hs_in_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_IN,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_BULK,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_HS_DATA_PKT_SIZE),\n\n+ .bInterval = 0,\n\n+};\n\n+\n\n+\n\n+static struct usb_endpoint_descriptor mtp_ep_hs_out_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_OUT,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_BULK,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_HS_DATA_PKT_SIZE),\n\n+ .bInterval = 0,\n\n+};\n\n+\n\n+\n\n+static struct usb_endpoint_descriptor mtp_ep_hs_int_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_IN,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_INT,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_HS_EVENT_PKT_SIZE),\n\n+ .bInterval = 12,\n\n+};\n\n+\n\n+static struct usb_descriptor_header *mtp_hs_function[] __initdata = {\n\n+ (struct usb_descriptor_header *) &mtp_intf,\n\n+ (struct usb_descriptor_header *) &mtp_ep_hs_in_desc,\n\n+ (struct usb_descriptor_header *) &mtp_ep_hs_out_desc,\n\n+ (struct usb_descriptor_header *) &mtp_ep_hs_int_desc,\n\n+ NULL,\n\n+};\n\n+\n\n+/* Full speed support */\n\n+static struct usb_endpoint_descriptor mtp_ep_fs_in_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_IN,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_BULK,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_FS_DATA_PKT_SIZE),\n\n+ .bInterval = 0,\n\n+};\n\n+\n\n+static struct usb_endpoint_descriptor mtp_ep_fs_out_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_OUT,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_BULK,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_FS_DATA_PKT_SIZE),\n\n+ .bInterval = 0,\n\n+};\n\n+\n\n+static struct usb_endpoint_descriptor mtp_ep_fs_int_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_IN,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_INT,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_FS_EVENT_PKT_SIZE),\n\n+ .bInterval = 255,\n\n+};\n\n+\n\n+static struct usb_descriptor_header *mtp_fs_function[] __initdata = {\n\n+ (struct usb_descriptor_header *) &mtp_intf,\n\n+ (struct usb_descriptor_header *) &mtp_ep_fs_in_desc,\n\n+ (struct usb_descriptor_header *) &mtp_ep_fs_out_desc,\n\n+ (struct usb_descriptor_header *) &mtp_ep_fs_int_desc,\n\n+ NULL,\n\n+};\n\n+\n\n+/**\n\n+ * This function will be called when the request on the interrupt\n\n+ * end point being used for class specific events is completed.\n\n+ * Notes -\n\n+ * The protocol does not give any specifications about what needs\n\n+ * should be done in such case.\n\n+ * Revisit if there is more information.\n\n+ */\n\n+static void\n\n+mtp_notify_complete(struct usb_ep *ep, struct usb_request *req)\n\n+{\n\n+ struct f_mtp *mtp = req->context;\n\n+ struct usb_composite_dev *cdev = mtp->cdev;\n\n+\n\n+ VDBG(cdev, \"%s:\\n\", __func__);\n\n+\n\n+ switch (req->status) {\n\n+ case 0:\n\n+ /* normal completionn */\n\n+ break;\n\n+\n\n+ case -ESHUTDOWN:\n\n+ /* disconnect */\n\n+ WARNING(cdev, \"%s: %s shutdown\\n\", __func__, ep->name);\n\n+ break;\n\n+\n\n+ default:\n\n+ WARNING(cdev, \"%s: unexpected %s status %d\\n\",\n\n+ __func__, ep->name, req->status);\n\n+ break;\n\n+ }\n\n+\n\n+ kfree(req->buf);\n\n+ usb_ep_free_request(ep, req);\n\n+ return;\n\n+}\n\n+\n\n+/**\n\n+ * build_device_status() - prepares the device status response\n\n+ *\n\n+ * @mtp: the f_mtp struct\n\n+ * @buf: buffer to build the response data into\n\n+ * @buf_len: length of buffer in bytes\n\n+ *\n\n+ * uses spinlock mtp->lock\n\n+ *\n\n+ * returns number of bytes copied.\n\n+ */\n\n+static int build_device_status(struct f_mtp *mtp, void *buf, size_t buf_len)\n\n+{\n\n+ int copied, len;\n\n+ __le16 *ptr = buf;\n\n+ struct device_status *status = &mtp->dev_status;\n\n+\n\n+ spin_lock_irq(&mtp->lock);\n\n+ len = status->length;\n\n+ if (len > buf_len) {\n\n+ WARNING(mtp->cdev, \"%s Insufficient buffer for dev_status\\n\",\n\n+ __func__);\n\n+ /* limit status data to available buffer */\n\n+ len = buf_len;\n\n+ }\n\n+\n\n+ *ptr++ = cpu_to_le16(len);\n\n+ *ptr++ = cpu_to_le16(status->code);\n\n+ copied = 4;\n\n+\n\n+ if (len > 4) {\n\n+ len -= 4;\n\n+ if (len > MAX_STATUS_DATA_SIZE) {\n\n+ len = MAX_STATUS_DATA_SIZE;\n\n+ WARNING(mtp->cdev, \"%s limited status to %d bytes\\n\",\n\n+ __func__, len);\n\n+ }\n\n+ memcpy(ptr, status->data, len);\n\n+ copied += len;\n\n+ }\n\n+ spin_unlock_irq(&mtp->lock);\n\n+ return copied;\n\n+}\n\n+\n\n+/**\n\n+ * cache_device_status() - saves the device status to struct f_mtp\n\n+ *\n\n+ * @mtp: the f_mtp struct\n\n+ * @length: length of PTP device status\n\n+ * @code: code of PTP device status\n\n+ * @buf: user space buffer pointing to PTP device status container\n\n+ *\n\n+ * uses spinlock mtp->lock\n\n+ *\n\n+ * returns 0 on success. negative on error\n\n+ */\n\n+static int cache_device_status(struct f_mtp *mtp,\n\n+ u16 length, u16 code, const void __user *buf)\n\n+{\n\n+ u8 *uninitialized_var(tmp_data);\n\n+\n\n+ if (length > 4) {\n\n+ if (!buf) {\n\n+ WARNING(mtp->cdev, \"%s No data buffer provided\\n\",\n\n+ __func__);\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ length -= 4; /* get length of data section */\n\n+ if (length > MAX_STATUS_DATA_SIZE) {\n\n+ length = MAX_STATUS_DATA_SIZE;\n\n+ WARNING(mtp->cdev, \"%s limited status data to %d \"\n\n+ \"bytes\\n\", __func__, length);\n\n+ }\n\n+\n\n+ tmp_data = kmalloc(length, GFP_KERNEL);\n\n+ if (!tmp_data)\n\n+ return -ENOMEM;\n\n+\n\n+ /* 4 bytes are for header, leave them out */\n\n+ if (copy_from_user(tmp_data, buf + 4, length)) {\n\n+ ERROR(mtp->cdev, \"%s copy_from_user fault\\n\", __func__);\n\n+ kfree(tmp_data);\n\n+ return -EFAULT;\n\n+ }\n\n+ length += 4; /* undo the previous minus */\n\n+ }\n\n+\n\n+ spin_lock_irq(&mtp->lock);\n\n+ if (length > 4) {\n\n+ memcpy(mtp->dev_status.data, tmp_data, length - 4);\n\n+ kfree(tmp_data);\n\n+ }\n\n+ mtp->dev_status.length = length;\n\n+ mtp->dev_status.code = code;\n\n+ spin_unlock_irq(&mtp->lock);\n\n+ return 0;\n\n+}\n\n+\n\n+/**\n\n+ * Handle the MTP specific setup requests\n\n+ */\n\n+static int\n\n+mtp_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\n\n+{\n\n+ struct f_mtp *mtp = func_to_mtp(f);\n\n+ struct usb_composite_dev *cdev = f->config->cdev;\n\n+ struct usb_request *req = cdev->req;\n\n+\n\n+ int value = -EOPNOTSUPP;\n\n+ u16 wIndex = le16_to_cpu(ctrl->wIndex);\n\n+ u16 wValue = le16_to_cpu(ctrl->wValue);\n\n+ u16 wLength = le16_to_cpu(ctrl->wLength);\n\n+\n\n+ switch (ctrl->bRequest) {\n\n+ case PTP_REQ_GET_EXTENDED_EVENT_DATA:\n\n+ /* FIXME need to implement\n\n+ * Maybe we could have an IOCTL to save the extended event\n\n+ * data with the driver and then send it to host whenever\n\n+ * we get this request\n\n+ */\n\n+ WARNING(cdev, \"%s: FIXME: PTP request GET_EXTENDED_EVENT_DATA, \"\n\n+ \"not implemented\\n\", __func__);\n\n+ break;\n\n+\n\n+ case PTP_REQ_CANCEL:\n\n+ DBG(cdev, \"%s: PTP: CANCEL\\n\", __func__);\n\n+ if (ctrl->bRequestType != (USB_DIR_OUT |\n\n+ USB_TYPE_CLASS | USB_RECIP_INTERFACE))\n\n+ goto stall;\n\n+\n\n+ if (wValue != 0 || wIndex != 0 || wLength != 6)\n\n+ goto stall;\n\n+\n\n+ /* FIXME need to notify user space stack */\n\n+\n\n+ /* we don't support CANCEL so stall */\n\n+ break;\n\n+\n\n+ case PTP_REQ_DEVICE_RESET:\n\n+ DBG(cdev, \"%s: PTP: DEVICE_RESET\\n\", __func__);\n\n+ if (ctrl->bRequestType != (USB_DIR_OUT |\n\n+ USB_TYPE_CLASS | USB_RECIP_INTERFACE))\n\n+ goto stall;\n\n+\n\n+ if (wValue != 0 || wIndex != 0 || wLength != 0)\n\n+ goto stall;\n\n+\n\n+ /* FIXME need to notify user space stack */\n\n+\n\n+ /* we don't support RESET so stall */\n\n+ break;\n\n+\n\n+ case PTP_REQ_GET_DEVICE_STATUS:\n\n+ /* return the cached device status */\n\n+ DBG(cdev, \"%s: PTP: GET_DEVICE_STATUS\\n\", __func__);\n\n+\n\n+ if (ctrl->bRequestType != (USB_DIR_IN |\n\n+ USB_TYPE_CLASS | USB_RECIP_INTERFACE)) {\n\n+ goto stall;\n\n+ }\n\n+\n\n+ if (wValue != 0 || wIndex != 0)\n\n+ goto stall;\n\n+\n\n+ value = build_device_status(mtp, req->buf,\n\n+ USB_BUFSIZ); /* composite.c */\n\n+\n\n+ if (value < 0) {\n\n+ ERROR(cdev, \"%s: error building device status\\n\",\n\n+ __func__);\n\n+ goto stall;\n\n+ }\n\n+ value = min(wLength, (u16)value);\n\n+ break;\n\n+\n\n+ /* TBD: other response codes */\n\n+ default:\n\n+ WARNING(cdev,\n\n+ \"%s: FIXME, got PTP request 0x%x, not implemented\\n\",\n\n+ __func__, ctrl->bRequest);\n\n+ break;\n\n+ }\n\n+\n\n+ /* data phase of control transfer */\n\n+ if (value >= 0) {\n\n+ req->length = value;\n\n+ req->zero = value < wLength;\n\n+ value = usb_ep_queue(cdev->gadget->ep0,\n\n+ req, GFP_ATOMIC);\n\n+ if (value < 0) {\n\n+ DBG(cdev, \"%s: ep_queue --> %d\\n\", __func__, value);\n\n+ req->status = 0;\n\n+ }\n\n+ }\n\n+\n\n+stall:\n\n+ /* device either stalls (value < 0) or reports success */\n\n+ return value;\n\n+}\n\n+\n\n+static long\n\n+mtp_ioctl(struct gchar *gc, unsigned int cmd, unsigned long arg)\n\n+{\n\n+ int status;\n\n+ struct f_mtp *mtp = gchar_to_mtp(gc);\n\n+ struct usb_composite_dev *cdev = mtp->cdev;\n\n+ int packet_size;\n\n+ struct usb_request *notify_req;\n\n+ void *event_packet;\n\n+ u32 event_packet_len;\n\n+ struct ptp_device_status_data ptp_status;\n\n+\n\n+ switch (cmd) {\n\n+ case MTP_IOCTL_WRITE_ON_INTERRUPT_EP:\n\n+\n\n+ /* get size of packet */\n\n+ if (copy_from_user(&event_packet_len,\n\n+ (void __user *)arg, 4))\n\n+ return -EFAULT;\n\n+\n\n+ event_packet_len = le32_to_cpu(event_packet_len);\n\n+ if (event_packet_len > mtp->notify->maxpacket) {\n\n+ ERROR(cdev, \"%s Max event packet limit exceeded\\n\",\n\n+ __func__);\n\n+ return -EFAULT;\n\n+ }\n\n+\n\n+ event_packet = kmalloc(event_packet_len, GFP_KERNEL);\n\n+ if (!event_packet) {\n\n+ ERROR(cdev, \"%s cannot allocate memory for event\\n\",\n\n+ __func__);\n\n+ return -ENOMEM;\n\n+ }\n\n+\n\n+ /* read full packet */\n\n+ if (copy_from_user(event_packet,\n\n+ (void __user *)arg, event_packet_len)) {\n\n+ kfree(event_packet);\n\n+ return -EFAULT;\n\n+ }\n\n+\n\n+ /* Allocate request object to be used with this endpoint. */\n\n+ notify_req = usb_ep_alloc_request(mtp->notify, GFP_KERNEL);\n\n+ if (!notify_req) {\n\n+ ERROR(cdev,\n\n+ \"%s: could not allocate notify EP request\\n\",\n\n+ __func__);\n\n+ kfree(event_packet);\n\n+ return -ENOMEM;\n\n+ }\n\n+\n\n+ notify_req->buf = event_packet;\n\n+ notify_req->context = mtp;\n\n+ notify_req->complete = mtp_notify_complete;\n\n+ notify_req->length = event_packet_len;\n\n+ if (unlikely(event_packet_len == mtp->notify->maxpacket))\n\n+ notify_req->zero = 1;\n\n+ else\n\n+ notify_req->zero = 0;\n\n+\n\n+\n\n+ status = usb_ep_queue(mtp->notify, notify_req, GFP_ATOMIC);\n\n+ if (status) {\n\n+ ERROR(cdev,\n\n+ \"%s: EVENT packet could not be queued %d\\n\",\n\n+ __func__, status);\n\n+ usb_ep_free_request(mtp->notify, notify_req);\n\n+ kfree(event_packet);\n\n+ return status;\n\n+ }\n\n+ return 0;\n\n+\n\n+ case MTP_IOCTL_GET_MAX_DATAPKT_SIZE:\n\n+ switch (mtp->usb_speed) {\n\n+ case USB_SPEED_LOW:\n\n+ case USB_SPEED_FULL:\n\n+ packet_size = PTP_FS_DATA_PKT_SIZE;\n\n+ break;\n\n+\n\n+ case USB_SPEED_HIGH:\n\n+ case USB_SPEED_VARIABLE:\n\n+ packet_size = PTP_HS_DATA_PKT_SIZE;\n\n+ break;\n\n+\n\n+ default:\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ status = put_user(packet_size, (int *)arg);\n\n+ if (status) {\n\n+ ERROR(cdev,\n\n+ \"%s: could not send max data packet size\\n\",\n\n+ __func__);\n\n+ return -EFAULT;\n\n+ }\n\n+ return 0;\n\n+\n\n+ case MTP_IOCTL_GET_MAX_EVENTPKT_SIZE:\n\n+ switch (mtp->usb_speed) {\n\n+ case USB_SPEED_LOW:\n\n+ case USB_SPEED_FULL:\n\n+ packet_size = PTP_FS_EVENT_PKT_SIZE;\n\n+ break;\n\n+\n\n+ case USB_SPEED_HIGH:\n\n+ case USB_SPEED_VARIABLE:\n\n+ packet_size = PTP_HS_EVENT_PKT_SIZE;\n\n+ break;\n\n+\n\n+ default:\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ status = put_user(packet_size, (int *)arg);\n\n+ if (status) {\n\n+ ERROR(cdev,\n\n+ \"%s: couldn't send max event packet size\\n\",\n\n+ __func__);\n\n+ return -EFAULT;\n\n+ }\n\n+ return 0;\n\n+\n\n+ case MTP_IOCTL_SET_DEVICE_STATUS:\n\n+ if (copy_from_user(&ptp_status, (const void __user *)arg,\n\n+ sizeof(ptp_status)))\n\n+ return -EFAULT;\n\n+\n\n+ status = cache_device_status(mtp,\n\n+ __le16_to_cpu(ptp_status.wLength),\n\n+ __le16_to_cpu(ptp_status.Code),\n\n+ (const void __user *)(arg));\n\n+ return status;\n\n+\n\n+ default:\n\n+ WARNING(cdev, \"%s: unhandled IOCTL %d\\n\", __func__, cmd);\n\n+ return -EINVAL;\n\n+ }\n\n+}\n\n+\n\n+static void\n\n+mtp_disconnect(struct gchar *gc)\n\n+{\n\n+ struct f_mtp *mtp = gchar_to_mtp(gc);\n\n+ struct usb_composite_dev *cdev = mtp->cdev;\n\n+ int status = 0;\n\n+\n\n+ if (!mtp->connected)\n\n+ return;\n\n+\n\n+ status = usb_function_deactivate(&gc->func);\n\n+ if (status) {\n\n+ WARNING(cdev, \"%s: could not deactivate mtp function %d, \"\n\n+ \"status: %d\\n\", __func__, mtp->minor, status);\n\n+ } else {\n\n+ mtp->connected = false;\n\n+ INFO(cdev, \"mtp function %d disconnected\\n\", mtp->minor);\n\n+ }\n\n+}\n\n+\n\n+static void mtp_connect(struct gchar *gc)\n\n+{\n\n+ struct f_mtp *mtp = gchar_to_mtp(gc);\n\n+ struct usb_composite_dev *cdev = mtp->cdev;\n\n+ int status = 0;\n\n+\n\n+ if (mtp->connected)\n\n+ return;\n\n+\n\n+ status = usb_function_activate(&gc->func);\n\n+ if (status) {\n\n+ WARNING(cdev, \"%s: could not activate mtp function %d, \"\n\n+ \"status: %d\\n\", __func__, mtp->minor, status);\n\n+ } else {\n\n+ mtp->connected = true;\n\n+ INFO(cdev, \"mtp function %d connected\\n\", mtp->minor);\n\n+ }\n\n+}\n\n+\n\n+/**\n\n+ * Set alt-settings of the interface.\n\n+ * When connected with host, this function will get called for the\n\n+ * number of interfaces defined for this gadget.\n\n+ * This function enables all the required end points.\n\n+ */\n\n+static int\n\n+mtp_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n\n+{\n\n+ struct usb_composite_dev *cdev = f->config->cdev;\n\n+ struct f_mtp *mtp = func_to_mtp(f);\n\n+ int status = -1;\n\n+\n\n+ if (intf != mtp->mtp_id)\n\n+ return -EINVAL;\n\n+\n\n+ if (alt != 0) {\n\n+ WARNING(cdev, \"%s: invalid setting\\n\", __func__);\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ /* Handle interrupt endpoint */\n\n+ if (mtp->notify->driver_data) {\n\n+ DBG(cdev, \"%s: notify reset mtp control %d\\n\", __func__, intf);\n\n+ usb_ep_disable(mtp->notify);\n\n+ } else {\n\n+ DBG(cdev, \"%s: notify init mtp ctrl %d\\n\", __func__, intf);\n\n+ mtp->notify_desc = ep_choose(cdev->gadget,\n\n+ mtp->hs.mtp_int,\n\n+ mtp->fs.mtp_int);\n\n+ }\n\n+\n\n+ status = usb_ep_enable(mtp->notify, mtp->notify_desc);\n\n+ if (status != 0)\n\n+ ERROR(cdev, \"%s: Error enabling endpoint\\n\", __func__);\n\n+ mtp->notify->driver_data = mtp;\n\n+\n\n+ if (mtp->gc.ep_in->driver_data) {\n\n+ /* Altsetting 0 for an interface that already has 0 altset,\n\n+ * ignore this\n\n+ */\n\n+ return 0;\n\n+ }\n\n+\n\n+ if (!mtp->gc.ep_in_desc) {\n\n+ DBG(cdev, \"%s: init mtp %d\\n\", __func__, mtp->minor);\n\n+ mtp->gc.ep_in_desc = ep_choose(cdev->gadget,\n\n+ mtp->hs.mtp_in,\n\n+ mtp->fs.mtp_in);\n\n+ mtp->gc.ep_out_desc = ep_choose(cdev->gadget,\n\n+ mtp->hs.mtp_out,\n\n+ mtp->fs.mtp_out);\n\n+ }\n\n+\n\n+ DBG(cdev, \"%s: mtp %d enable\\n\", __func__, mtp->minor);\n\n+ status = gchar_connect(&mtp->gc, mtp->minor, f->name);\n\n+ if (status) {\n\n+ ERROR(cdev,\n\n+ \"%s: gchar_connect() failed %d\\n\", __func__, status);\n\n+ return status;\n\n+ }\n\n+\n\n+ /* Get the USB speed */\n\n+ mtp->usb_speed = cdev->gadget->speed;\n\n+ return 0;\n\n+}\n\n+\n\n+static void\n\n+mtp_disable(struct usb_function *f)\n\n+{\n\n+ struct f_mtp *mtp = func_to_mtp(f);\n\n+ struct usb_composite_dev *cdev = f->config->cdev;\n\n+\n\n+ DBG(cdev, \"%s: mtp %d disable\\n\", __func__, mtp->minor);\n\n+ /* disable OUT/IN endpoints */\n\n+ gchar_disconnect(&mtp->gc);\n\n+ /* disable INT endpoint */\n\n+ if (mtp->notify->driver_data) {\n\n+ usb_ep_disable(mtp->notify);\n\n+ mtp->notify->driver_data = NULL;\n\n+ mtp->notify_desc = NULL;\n\n+ }\n\n+ mtp->usb_speed = -1;\n\n+}\n\n+\n\n+static int\n\n+__init mtp_bind(struct usb_configuration *c, struct usb_function *f)\n\n+{\n\n+ struct f_mtp *mtp = func_to_mtp(f);\n\n+ struct usb_composite_dev *cdev = c->cdev;\n\n+ int status;\n\n+ struct usb_ep *ep = NULL;\n\n+\n\n+ /* allocate instance-specific interface IDs and patch up descriptors */\n\n+ /* We have only ONE MTP interface. So get the unused interface ID for\n\n+ * this interface.*/\n\n+ status = usb_interface_id(c, f);\n\n+ if (status < 0)\n\n+ return status;\n\n+ mtp->mtp_id = status;\n\n+ mtp_intf.bInterfaceNumber = status;\n\n+\n\n+ status = -ENOMEM;\n\n+ /* Allocate the endpoints */\n\n+ /* mtp_ep_fs_in_desc */\n\n+ ep = usb_ep_autoconfig(cdev->gadget, &mtp_ep_fs_in_desc);\n\n+ if (!ep)\n\n+ goto fail;\n\n+ mtp->gc.ep_in = ep;\n\n+ ep->driver_data = cdev;\n\n+\n\n+ /* mtp_ep_fs_out_desc */\n\n+ ep = usb_ep_autoconfig(cdev->gadget, &mtp_ep_fs_out_desc);\n\n+ if (!ep)\n\n+ goto fail;\n\n+ mtp->gc.ep_out = ep;\n\n+ ep->driver_data = cdev;\n\n+\n\n+ /* mtp_ep_fs_int_desc */\n\n+ ep = usb_ep_autoconfig(cdev->gadget, &mtp_ep_fs_int_desc);\n\n+ if (!ep)\n\n+ goto fail;\n\n+ mtp->notify = ep;\n\n+ ep->driver_data = cdev;\n\n+\n\n+\n\n+ /* copy descriptors, and track endpoint copies */\n\n+ f->descriptors = usb_copy_descriptors(mtp_fs_function);\n\n+ mtp->fs.mtp_in = usb_find_endpoint(mtp_fs_function,\n\n+ f->descriptors, &mtp_ep_fs_in_desc);\n\n+ mtp->fs.mtp_out = usb_find_endpoint(mtp_fs_function,\n\n+ f->descriptors, &mtp_ep_fs_out_desc);\n\n+ mtp->fs.mtp_int = usb_find_endpoint(mtp_fs_function,\n\n+ f->descriptors, &mtp_ep_fs_int_desc);\n\n+\n\n+ /* support all relevant hardware speeds... we expect that when\n\n+ * hardware is dual speed, all bulk-capable endpoints work at\n\n+ * both speeds\n\n+ */\n\n+ if (gadget_is_dualspeed(c->cdev->gadget)) {\n\n+ /* Copy endpoint address */\n\n+ mtp_ep_hs_in_desc.bEndpointAddress =\n\n+ mtp_ep_fs_in_desc.bEndpointAddress;\n\n+ mtp_ep_hs_out_desc.bEndpointAddress =\n\n+ mtp_ep_fs_out_desc.bEndpointAddress;\n\n+ mtp_ep_hs_int_desc.bEndpointAddress =\n\n+ mtp_ep_fs_int_desc.bEndpointAddress;\n\n+\n\n+ /* Copy descriptors, and track endpoint copies */\n\n+ f->hs_descriptors = usb_copy_descriptors(mtp_hs_function);\n\n+ mtp->hs.mtp_in = usb_find_endpoint(mtp_hs_function,\n\n+ f->hs_descriptors, &mtp_ep_hs_in_desc);\n\n+ mtp->hs.mtp_out = usb_find_endpoint(mtp_hs_function,\n\n+ f->hs_descriptors, &mtp_ep_hs_out_desc);\n\n+ mtp->hs.mtp_int = usb_find_endpoint(mtp_hs_function,\n\n+ f->hs_descriptors, &mtp_ep_hs_int_desc);\n\n+ }\n\n+\n\n+ /* Prevent enumeration until someone opens\n\n+ * the port from the user space */\n\n+ status = usb_function_deactivate(f);\n\n+ if (status < 0) {\n\n+ WARNING(cdev, \"%s: mtp %d: can't prevent enumeration, %d\\n\",\n\n+ __func__, mtp->minor, status);\n\n+ mtp->connected = true;\n\n+ }\n\n+\n\n+\n\n+ INFO(cdev, \"mtp %d: %s speed IN/%s OUT/%s INT/%s\\n\",\n\n+ mtp->minor,\n\n+ gadget_is_dualspeed(cdev->gadget) ? \"dual\" : \"full\",\n\n+ mtp->gc.ep_in->name, mtp->gc.ep_out->name,\n\n+ mtp->notify->name);\n\n+\n\n+ return 0;\n\n+fail:\n\n+ if (mtp->gc.ep_out)\n\n+ mtp->gc.ep_out->driver_data = NULL;\n\n+\n\n+ if (mtp->gc.ep_in)\n\n+ mtp->gc.ep_in->driver_data = NULL;\n\n+\n\n+ if (mtp->notify)\n\n+ mtp->notify->driver_data = NULL;\n\n+\n\n+ ERROR(cdev, \"%s/%p: cant bind, err %d\\n\", f->name, f, status);\n\n+\n\n+ return status;\n\n+}\n\n+\n\n+static void\n\n+mtp_unbind(struct usb_configuration *c, struct usb_function *f)\n\n+{\n\n+ struct f_mtp *mtp = func_to_mtp(f);\n\n+\n\n+ if (gadget_is_dualspeed(c->cdev->gadget))\n\n+ usb_free_descriptors(f->hs_descriptors);\n\n+\n\n+ usb_free_descriptors(f->descriptors);\n\n+ kfree(mtp);\n\n+}\n\n+\n\n+/**\n\n+ * mtp_bind_config - add a MTP function to a configuration\n\n+ * @c: the configuration to support MTP\n\n+ * @port_num: /dev/ttyGS* port this interface will use\n\n+ * Context: single threaded during gadget setup\n\n+ *\n\n+ * Returns zero on success, else negative errno.\n\n+ *\n\n+ * Caller must have called @gchar_setup() with enough devices to\n\n+ * handle all the ones it binds. Caller is also responsible\n\n+ * for calling @gchar_cleanup() before module unload.\n\n+ */\n\n+int\n\n+__init mtp_bind_config(struct usb_configuration *c, u8 minor)\n\n+{\n\n+ struct f_mtp *mtp = NULL;\n\n+ int status = 0;\n\n+\n\n+ /* allocate device global string IDs and patch descriptors*/\n\n+ if (mtp_string_defs[0].id == 0) {\n\n+ status = usb_string_id(c->cdev);\n\n+ if (status < 0)\n\n+ return status;\n\n+ mtp_string_defs[0].id = status;\n\n+ mtp_intf.iInterface = status;\n\n+ }\n\n+\n\n+ /* allocate and initialize one new instance */\n\n+ mtp = kzalloc(sizeof(*mtp), GFP_KERNEL);\n\n+ if (!mtp)\n\n+ return -ENOMEM;\n\n+\n\n+ spin_lock_init(&mtp->lock);\n\n+\n\n+ mtp->minor = minor;\n\n+\n\n+ mtp->gc.func.name = \"MTP\";\n\n+ mtp->gc.func.strings = mtp_strings;\n\n+\n\n+ mtp->gc.open = mtp_connect;\n\n+ mtp->gc.close = mtp_disconnect;\n\n+ mtp->gc.ioctl = mtp_ioctl;\n\n+\n\n+ mtp->gc.func.bind = mtp_bind;\n\n+ mtp->gc.func.unbind = mtp_unbind;\n\n+ mtp->gc.func.set_alt = mtp_set_alt;\n\n+ mtp->gc.func.setup = mtp_setup;\n\n+ mtp->gc.func.disable = mtp_disable;\n\n+\n\n+ mtp->usb_speed = -1; /* invalid speed */\n\n+\n\n+ mtp->cdev = c->cdev;\n\n+\n\n+ /* default device status is BUSY */\n\n+ cache_device_status(mtp, 4, PTP_RC_DEVICE_BUSY, 0);\n\n+\n\n+ status = usb_add_function(c, &mtp->gc.func);\n\n+ if (status) {\n\n+ kfree(mtp);\n\n+ }\n\n+\n\n+ return status;\n\n+}\n\ndiff --git a/drivers/usb/gadget/mtp.c b/drivers/usb/gadget/mtp.c\n\nnew file mode 100644\n\nindex 0000000..f1f763f\n\n--- /dev/null\n\n+++ b/drivers/usb/gadget/mtp.c\n\n@@ -0,0 +1,249 @@\n\n+/*\n\n+ * mtp.c -- Media Transfer Protocol USB Gadget Driver\n\n+ *\n\n+ * Copyright (C) 2009-2010 Nokia Corporation\n\n+ * Contact: Yauheni Kaliuta <yauheni.kaliuta-***@public.gmane.org>\n\n+ *\n\n+ * This gadget driver borrows from serial.c which is:\n\n+ *\n\n+ * Copyright (C) 2003 Al Borchers (alborchers-***@public.gmane.org)\n\n+ * Copyright (C) 2008 by David Brownell\n\n+ * Copyright (C) 2008 by Nokia Corporation\n\n+ *\n\n+ * This program is free software; you can redistribute it and/or modify\n\n+ * it under the terms of the GNU General Public License as published by\n\n+ * the Free Software Foundation; either version 2 of the License, or\n\n+ * (at your option) any later version.\n\n+ *\n\n+ * This program is distributed in the hope that it will be useful,\n\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n\n+ * GNU General Public License for more details.\n\n+ *\n\n+ * You should have received a copy of the GNU General Public License\n\n+ * along with this program; if not, write to the Free Software\n\n+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n\n+ */\n\n+\n\n+#include <linux/kernel.h>\n\n+#include <linux/utsname.h>\n\n+#include <linux/device.h>\n\n+\n\n+#include <linux/usb/composite.h>\n\n+#include \"u_char.h\"\n\n+#include \"gadget_chips.h\"\n\n+\n\n+/*-------------------------------------------------------------------------*/\n\n+\n\n+/*\n\n+ * Kbuild is not very cooperative with respect to linking separately\n\n+ * compiled library objects into one module. So for now we won't use\n\n+ * separate compilation ... ensuring init/exit sections work to shrink\n\n+ * the runtime footprint, and giving us at least some parts of what\n\n+ * a \"gcc --combine ... part1.c part2.c part3.c ... \" build would.\n\n+ */\n\n+#include \"composite.c\"\n\n+#include \"usbstring.c\"\n\n+#include \"config.c\"\n\n+#include \"epautoconf.c\"\n\n+\n\n+#include \"f_mtp.c\"\n\n+#include \"u_char.c\"\n\n+\n\n+/*-------------------------------------------------------------------------*/\n\n+\n\n+#define MTP_VERSION_NUM 0x1000\n\n+#define MTP_VERSION_STR \"1.0\"\n\n+\n\n+#define MTP_VENDOR_ID 0x0101\n\n+#define MTP_PRODUCT_ID 0x0202\n\n+\n\n+#define MTP_DRIVER_DESC \"MTP Gadget\"\n\n+\n\n+/* string IDs are assigned dynamically */\n\n+\n\n+#define STRING_MANUFACTURER_IDX 0\n\n+#define STRING_PRODUCT_IDX 1\n\n+#define STRING_DESCRIPTION_IDX 2\n\n+\n\n+static char manufacturer[50];\n\n+\n\n+static struct usb_string strings_dev[] = {\n\n+ [STRING_MANUFACTURER_IDX].s = manufacturer,\n\n+ [STRING_PRODUCT_IDX].s = MTP_DRIVER_DESC,\n\n+ [STRING_DESCRIPTION_IDX].s = MTP_DRIVER_DESC,\n\n+ { } /* end of list */\n\n+};\n\n+\n\n+static struct usb_gadget_strings stringtab_dev = {\n\n+ .language = 0x0409, /* en-us */\n\n+ .strings = strings_dev,\n\n+};\n\n+\n\n+static struct usb_gadget_strings *dev_strings[] = {\n\n+ &stringtab_dev,\n\n+ NULL,\n\n+};\n\n+\n\n+static struct usb_device_descriptor device_desc = {\n\n+ .bLength = USB_DT_DEVICE_SIZE,\n\n+ .bDescriptorType = USB_DT_DEVICE,\n\n+ .bcdUSB = cpu_to_le16(0x0200),\n\n+ .bDeviceClass = USB_CLASS_PER_INTERFACE,\n\n+ .bDeviceSubClass = 0,\n\n+ .bDeviceProtocol = 0,\n\n+ /* .bMaxPacketSize0 = f(hardware) */\n\n+ .idVendor = cpu_to_le16(MTP_VENDOR_ID),\n\n+ .idProduct = cpu_to_le16(MTP_PRODUCT_ID),\n\n+ /* .bcdDevice = f(hardware) */\n\n+ /* .iManufacturer = DYNAMIC */\n\n+ /* .iProduct = DYNAMIC */\n\n+ .bNumConfigurations = 1,\n\n+};\n\n+\n\n+static struct usb_otg_descriptor otg_descriptor = {\n\n+ .bLength = sizeof otg_descriptor,\n\n+ .bDescriptorType = USB_DT_OTG,\n\n+\n\n+ /* REVISIT SRP-only hardware is possible, although\n\n+ * it would not be called \"OTG\" ...\n\n+ */\n\n+ .bmAttributes = USB_OTG_SRP | USB_OTG_HNP,\n\n+};\n\n+\n\n+static const struct usb_descriptor_header *otg_desc[] = {\n\n+ (struct usb_descriptor_header *) &otg_descriptor,\n\n+ NULL,\n\n+};\n\n+\n\n+/*-------------------------------------------------------------------------*/\n\n+\n\n+/* Module */\n\n+MODULE_DESCRIPTION(MTP_DRIVER_DESC);\n\n+MODULE_AUTHOR(\"Yauheni Kaliuta\");\n\n+MODULE_LICENSE(\"GPL\");\n\n+\n\n+/*-------------------------------------------------------------------------*/\n\n+\n\n+static int __init g_mtp_bind_config(struct usb_configuration *c)\n\n+{\n\n+ int status;\n\n+\n\n+ status = mtp_bind_config(c, 0);\n\n+ if (status)\n\n+ printk(KERN_DEBUG \"could not bind mtp config\\n\");\n\n+\n\n+ return status;\n\n+}\n\n+\n\n+static struct usb_configuration mtp_config_driver = {\n\n+ /* .label = f(use_acm) */\n\n+ .bind = g_mtp_bind_config,\n\n+ .bConfigurationValue = 1,\n\n+ /* .iConfiguration = DYNAMIC */\n\n+ .bmAttributes = USB_CONFIG_ATT_SELFPOWER,\n\n+};\n\n+\n\n+static int __init g_mtp_bind(struct usb_composite_dev *cdev)\n\n+{\n\n+ int gcnum;\n\n+ struct usb_gadget *gadget = cdev->gadget;\n\n+ int status;\n\n+\n\n+ status = gchar_setup(cdev->gadget, 1);\n\n+ if (status < 0)\n\n+ return status;\n\n+\n\n+ /* Allocate string descriptor numbers ... note that string\n\n+ * contents can be overridden by the composite_dev glue.\n\n+ */\n\n+\n\n+ /* device description: manufacturer, product */\n\n+ snprintf(manufacturer, sizeof manufacturer, \"%s %s with %s\",\n\n+ init_utsname()->sysname, init_utsname()->release,\n\n+ gadget->name);\n\n+ status = usb_string_id(cdev);\n\n+ if (status < 0)\n\n+ goto fail;\n\n+ strings_dev[STRING_MANUFACTURER_IDX].id = status;\n\n+\n\n+ device_desc.iManufacturer = status;\n\n+\n\n+ status = usb_string_id(cdev);\n\n+ if (status < 0)\n\n+ goto fail;\n\n+ strings_dev[STRING_PRODUCT_IDX].id = status;\n\n+\n\n+ device_desc.iProduct = status;\n\n+\n\n+ /* config description */\n\n+ status = usb_string_id(cdev);\n\n+ if (status < 0)\n\n+ goto fail;\n\n+ strings_dev[STRING_DESCRIPTION_IDX].id = status;\n\n+\n\n+ mtp_config_driver.iConfiguration = status;\n\n+\n\n+ /* set up other descriptors */\n\n+ gcnum = usb_gadget_controller_number(gadget);\n\n+ if (gcnum >= 0)\n\n+ device_desc.bcdDevice = cpu_to_le16(MTP_VERSION_NUM | gcnum);\n\n+ else {\n\n+ /* this is so simple (for now, no altsettings) that it\n\n+ * SHOULD NOT have problems with bulk-capable hardware.\n\n+ * so warn about unrecognized controllers -- don't panic.\n\n+ *\n\n+ * things like configuration and altsetting numbering\n\n+ * can need hardware-specific attention though.\n\n+ */\n\n+ WARNING(cdev, \"g_mtp_bind: controller '%s' not recognized\\n\",\n\n+ gadget->name);\n\n+ device_desc.bcdDevice =\n\n+ cpu_to_le16(MTP_VERSION_NUM | 0x0099);\n\n+ }\n\n+\n\n+ if (gadget_is_otg(cdev->gadget)) {\n\n+ mtp_config_driver.descriptors = otg_desc;\n\n+ mtp_config_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\n+ }\n\n+\n\n+ /* register our configuration */\n\n+ status = usb_add_config(cdev, &mtp_config_driver);\n\n+ if (status < 0)\n\n+ goto fail;\n\n+\n\n+ DBG(cdev, \"%s, version: \" MTP_VERSION_STR \"\\n\",\n\n+ MTP_DRIVER_DESC);\n\n+\n\n+ return 0;\n\n+\n\n+fail:\n\n+ gchar_cleanup();\n\n+ return status;\n\n+}\n\n+\n\n+static int __exit g_mtp_unbind(struct usb_composite_dev *cdev)\n\n+{\n\n+ gchar_cleanup();\n\n+ return 0;\n\n+}\n\n+\n\n+static struct usb_composite_driver gmtp_driver = {\n\n+ .name = \"g_mtp\",\n\n+ .dev = &device_desc,\n\n+ .strings = dev_strings,\n\n+ .bind = g_mtp_bind,\n\n+ .unbind = __exit_p(g_mtp_unbind),\n\n+};\n\n+\n\n+static int __init init(void)\n\n+{\n\n+ return usb_composite_register(&gmtp_driver);\n\n+}\n\n+module_init(init);\n\n+\n\n+static void __exit cleanup(void)\n\n+{\n\n+ usb_composite_unregister(&gmtp_driver);\n\n+}\n\n+module_exit(cleanup);\n\n--\n\n1.7.0.rc0.33.g7c3932\n\n--\n\nTo unsubscribe from this list: send the line \"unsubscribe linux-usb\" in\n\nthe body of a message to majordomo-***@public.gmane.org\n\nMore majordomo info at http://vger.kernel.org/majordomo-info.html\n\nFelipe Balbi\n\nFrom: Yauheni Kaliuta <yauheni.kaliuta-***@public.gmane.org>\n\ng_mtp is the gadget driver implementing\n\nmedia transfer protocol.\n\nSigned-off-by: Yauheni Kaliuta <yauheni.kaliuta-***@public.gmane.org>\n\nSigned-off-by: Felipe Balbi <felipe.balbi-***@public.gmane.org>\n\n---\n\ndrivers/usb/gadget/Kconfig | 11 +\n\ndrivers/usb/gadget/Makefile | 2 +\n\ndrivers/usb/gadget/f_mtp.c | 869 +++++++++++++++++++++++++++++++++++++++++++\n\ndrivers/usb/gadget/mtp.c | 249 +++++++++++++\n\ninclude/linux/usb/ptp.h | 105 ++++++\n\n5 files changed, 1236 insertions(+), 0 deletions(-)\n\ncreate mode 100644 drivers/usb/gadget/f_mtp.c\n\ncreate mode 100644 drivers/usb/gadget/mtp.c\n\ncreate mode 100644 include/linux/usb/ptp.h\n\ndiff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig\n\nindex 7460cd7..876f534 100644\n\n--- a/drivers/usb/gadget/Kconfig\n\n+++ b/drivers/usb/gadget/Kconfig\n\n@@ -822,6 +822,17 @@ config USB_G_NOKIA\n\nIt's only really useful for N900 hardware. If you're building\n\na kernel for N900, say Y or M here. If unsure, say N.\n\n+config USB_G_MTP\n\n+ tristate \"Media Transfer Protocol (MTP) Gadget\"\n\n+ help\n\n+ The Media Transfer Protocol gadget provides support for MTP,\n\n+ which is used to transfer different types of media files\n\n+ (music, pictures, movies) to/from multimedia devices like\n\n+ digital cameras or multimedia players.\n\n+\n\n+ Say \"y\" to link the driver statically, or \"m\" to build a\n\n+ dynamically linked module called \"g_mtp\".\n\n+\n\nconfig USB_G_MULTI\n\ntristate \"Multifunction Composite Gadget (EXPERIMENTAL)\"\n\ndepends on BLOCK && NET\n\ndiff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile\n\nindex 43b51da..eae8f2d 100644\n\n--- a/drivers/usb/gadget/Makefile\n\n+++ b/drivers/usb/gadget/Makefile\n\n@@ -44,6 +44,7 @@ g_printer-objs := printer.o\n\ng_cdc-objs := cdc2.o\n\ng_multi-objs := multi.o\n\ng_nokia-objs := nokia.o\n\n+g_mtp-objs := mtp.o\n\nobj-$(CONFIG_USB_ZERO) += g_zero.o\n\nobj-$(CONFIG_USB_AUDIO) += g_audio.o\n\n@@ -57,4 +58,5 @@ obj-$(CONFIG_USB_MIDI_GADGET) += g_midi.o\n\nobj-$(CONFIG_USB_CDC_COMPOSITE) += g_cdc.o\n\nobj-$(CONFIG_USB_G_MULTI) += g_multi.o\n\nobj-$(CONFIG_USB_G_NOKIA) += g_nokia.o\n\n+obj-$(CONFIG_USB_G_MTP) += g_mtp.o\n\ndiff --git a/drivers/usb/gadget/f_mtp.c b/drivers/usb/gadget/f_mtp.c\n\nnew file mode 100644\n\nindex 0000000..c70872f\n\n--- /dev/null\n\n+++ b/drivers/usb/gadget/f_mtp.c\n\n@@ -0,0 +1,869 @@\n\n+/*\n\n+ * f_mtp.c -- USB MTP Function Driver\n\n+ *\n\n+ * Copyright (C) 2009-2010 Nokia Corporation\n\n+ * Contact: Roger Quadros <roger.quadros at nokia.com>\n\n+ *\n\n+ * Based on f_obex.c by Felipe Balbi\n\n+ *\n\n+ * This program is free software; you can redistribute it and/or modify\n\n+ * it under the terms of the GNU General Public License as published by\n\n+ * the Free Software Foundation; either version 2 of the License, or\n\n+ * (at your option) any later version.\n\n+ *\n\n+ * This program is distributed in the hope that it will be useful,\n\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n\n+ * GNU General Public License for more details.\n\n+ *\n\n+ * You should have received a copy of the GNU General Public License\n\n+ * along with this program; if not, write to the Free Software\n\n+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n\n+ */\n\n+\n\n+#include <linux/kernel.h>\n\n+#include <linux/device.h>\n\n+#include <linux/utsname.h>\n\n+#include <linux/uaccess.h>\n\n+#include <linux/ioctl.h>\n\n+#include <linux/usb/ptp.h>\n\n+#include \"u_char.h\"\n\n+#include \"gadget_chips.h\"\n\n+\n\n+struct mtp_ep_desc {\n\n+ struct usb_endpoint_descriptor *mtp_in;\n\n+ struct usb_endpoint_descriptor *mtp_out;\n\n+ struct usb_endpoint_descriptor *mtp_int;\n\n+};\n\n+\n\n+#define MAX_STATUS_DATA_SIZE (PTP_MAX_STATUS_SIZE - 4)\n\n+/* device status cache */\n\n+struct device_status {\n\n+ u16 length;\n\n+ u16 code;\n\n+ u8 data[MAX_STATUS_DATA_SIZE];\n\n+};\n\n+\n\n+struct f_mtp {\n\n+ struct gchar gc;\n\n+ struct usb_composite_dev *cdev;\n\n+ u8 ctrl_id;\n\n+ u8 mtp_id;\n\n+ u8 minor;\n\n+ u8 connected;\n\n+ struct device_status dev_status;\n\n+ spinlock_t lock;\n\n+\n\n+ struct mtp_ep_desc fs;\n\n+ struct mtp_ep_desc hs;\n\n+\n\n+ struct usb_ep *notify;\n\n+ struct usb_endpoint_descriptor *notify_desc;\n\n+\n\n+ int usb_speed;\n\n+};\n\n+\n\n+/*-------------------------------------------------------------------------*/\n\n+\n\n+static inline struct f_mtp *func_to_mtp(struct usb_function *f)\n\n+{\n\n+ return container_of(f, struct f_mtp, gc.func);\n\n+}\n\n+\n\n+static inline struct f_mtp *gchar_to_mtp(struct gchar *p)\n\n+{\n\n+ return container_of(p, struct f_mtp, gc);\n\n+}\n\n+\n\n+/*\n\n+ * USB String Descriptors\n\n+ */\n\n+\n\n+static struct usb_string mtp_string_defs[] = {\n\n+ { 0, \"MTP\" ,},\n\n+ { /* ZEROES END LIST */ },\n\n+};\n\n+\n\n+static struct usb_gadget_strings mtp_string_table = {\n\n+ .language = 0x0409, /* en-US */\n\n+ .strings = mtp_string_defs,\n\n+};\n\n+\n\n+static struct usb_gadget_strings *mtp_strings[] = {\n\n+ &mtp_string_table,\n\n+ NULL,\n\n+};\n\n+\n\n+/*\n\n+ * USB Interface Descriptors\n\n+ */\n\n+\n\n+static struct usb_interface_descriptor mtp_intf __initdata = {\n\n+ .bLength = sizeof(mtp_intf),\n\n+ .bDescriptorType = USB_DT_INTERFACE,\n\n+ .bAlternateSetting = 0,\n\n+ .bNumEndpoints = 3,\n\n+ .bInterfaceClass = USB_CLASS_STILL_IMAGE,\n\n+ .bInterfaceSubClass = USB_SUBCLASS_PTP,\n\n+ .bInterfaceProtocol = USB_PROTOCOL_PTP,\n\n+};\n\n+\n\n+/*\n\n+ * USB Endpoint Descriptors\n\n+ */\n\n+\n\n+/* High speed support */\n\n+static struct usb_endpoint_descriptor mtp_ep_hs_in_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_IN,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_BULK,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_HS_DATA_PKT_SIZE),\n\n+ .bInterval = 0,\n\n+};\n\n+\n\n+\n\n+static struct usb_endpoint_descriptor mtp_ep_hs_out_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_OUT,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_BULK,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_HS_DATA_PKT_SIZE),\n\n+ .bInterval = 0,\n\n+};\n\n+\n\n+\n\n+static struct usb_endpoint_descriptor mtp_ep_hs_int_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_IN,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_INT,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_HS_EVENT_PKT_SIZE),\n\n+ .bInterval = 12,\n\n+};\n\n+\n\n+static struct usb_descriptor_header *mtp_hs_function[] __initdata = {\n\n+ (struct usb_descriptor_header *) &mtp_intf,\n\n+ (struct usb_descriptor_header *) &mtp_ep_hs_in_desc,\n\n+ (struct usb_descriptor_header *) &mtp_ep_hs_out_desc,\n\n+ (struct usb_descriptor_header *) &mtp_ep_hs_int_desc,\n\n+ NULL,\n\n+};\n\n+\n\n+/* Full speed support */\n\n+static struct usb_endpoint_descriptor mtp_ep_fs_in_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_IN,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_BULK,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_FS_DATA_PKT_SIZE),\n\n+ .bInterval = 0,\n\n+};\n\n+\n\n+static struct usb_endpoint_descriptor mtp_ep_fs_out_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_OUT,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_BULK,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_FS_DATA_PKT_SIZE),\n\n+ .bInterval = 0,\n\n+};\n\n+\n\n+static struct usb_endpoint_descriptor mtp_ep_fs_int_desc __initdata = {\n\n+ .bLength = USB_DT_ENDPOINT_SIZE,\n\n+ .bDescriptorType = USB_DT_ENDPOINT,\n\n+ .bEndpointAddress = USB_DIR_IN,\n\n+ .bmAttributes = USB_ENDPOINT_XFER_INT,\n\n+ .wMaxPacketSize = __constant_cpu_to_le16(PTP_FS_EVENT_PKT_SIZE),\n\n+ .bInterval = 255,\n\n+};\n\n+\n\n+static struct usb_descriptor_header *mtp_fs_function[] __initdata = {\n\n+ (struct usb_descriptor_header *) &mtp_intf,\n\n+ (struct usb_descriptor_header *) &mtp_ep_fs_in_desc,\n\n+ (struct usb_descriptor_header *) &mtp_ep_fs_out_desc,\n\n+ (struct usb_descriptor_header *) &mtp_ep_fs_int_desc,\n\n+ NULL,\n\n+};\n\n+\n\n+/**\n\n+ * This function will be called when the request on the interrupt\n\n+ * end point being used for class specific events is completed.\n\n+ * Notes -\n\n+ * The protocol does not give any specifications about what needs\n\n+ * should be done in such case.\n\n+ * Revisit if there is more information.\n\n+ */\n\n+static void\n\n+mtp_notify_complete(struct usb_ep *ep, struct usb_request *req)\n\n+{\n\n+ struct f_mtp *mtp = req->context;\n\n+ struct usb_composite_dev *cdev = mtp->cdev;\n\n+\n\n+ VDBG(cdev, \"%s:\\n\", __func__);\n\n+\n\n+ switch (req->status) {\n\n+ case 0:\n\n+ /* normal completionn */\n\n+ break;\n\n+\n\n+ case -ESHUTDOWN:\n\n+ /* disconnect */\n\n+ WARNING(cdev, \"%s: %s shutdown\\n\", __func__, ep->name);\n\n+ break;\n\n+\n\n+ default:\n\n+ WARNING(cdev, \"%s: unexpected %s status %d\\n\",\n\n+ __func__, ep->name, req->status);\n\n+ break;\n\n+ }\n\n+\n\n+ kfree(req->buf);\n\n+ usb_ep_free_request(ep, req);\n\n+ return;\n\n+}\n\n+\n\n+/**\n\n+ * build_device_status() - prepares the device status response\n\n+ *\n\n+ * @mtp: the f_mtp struct\n\n+ * @buf: buffer to build the response data into\n\n+ * @buf_len: length of buffer in bytes\n\n+ *\n\n+ * uses spinlock mtp->lock\n\n+ *\n\n+ * returns number of bytes copied.\n\n+ */\n\n+static int build_device_status(struct f_mtp *mtp, void *buf, size_t buf_len)\n\n+{\n\n+ int copied, len;\n\n+ __le16 *ptr = buf;\n\n+ struct device_status *status = &mtp->dev_status;\n\n+\n\n+ spin_lock_irq(&mtp->lock);\n\n+ len = status->length;\n\n+ if (len > buf_len) {\n\n+ WARNING(mtp->cdev, \"%s Insufficient buffer for dev_status\\n\",\n\n+ __func__);\n\n+ /* limit status data to available buffer */\n\n+ len = buf_len;\n\n+ }\n\n+\n\n+ *ptr++ = cpu_to_le16(len);\n\n+ *ptr++ = cpu_to_le16(status->code);\n\n+ copied = 4;\n\n+\n\n+ if (len > 4) {\n\n+ len -= 4;\n\n+ if (len > MAX_STATUS_DATA_SIZE) {\n\n+ len = MAX_STATUS_DATA_SIZE;\n\n+ WARNING(mtp->cdev, \"%s limited status to %d bytes\\n\",\n\n+ __func__, len);\n\n+ }\n\n+ memcpy(ptr, status->data, len);\n\n+ copied += len;\n\n+ }\n\n+ spin_unlock_irq(&mtp->lock);\n\n+ return copied;\n\n+}\n\n+\n\n+/**\n\n+ * cache_device_status() - saves the device status to struct f_mtp\n\n+ *\n\n+ * @mtp: the f_mtp struct\n\n+ * @length: length of PTP device status\n\n+ * @code: code of PTP device status\n\n+ * @buf: user space buffer pointing to PTP device status container\n\n+ *\n\n+ * uses spinlock mtp->lock\n\n+ *\n\n+ * returns 0 on success. negative on error\n\n+ */\n\n+static int cache_device_status(struct f_mtp *mtp,\n\n+ u16 length, u16 code, const void __user *buf)\n\n+{\n\n+ u8 *uninitialized_var(tmp_data);\n\n+\n\n+ if (length > 4) {\n\n+ if (!buf) {\n\n+ WARNING(mtp->cdev, \"%s No data buffer provided\\n\",\n\n+ __func__);\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ length -= 4; /* get length of data section */\n\n+ if (length > MAX_STATUS_DATA_SIZE) {\n\n+ length = MAX_STATUS_DATA_SIZE;\n\n+ WARNING(mtp->cdev, \"%s limited status data to %d \"\n\n+ \"bytes\\n\", __func__, length);\n\n+ }\n\n+\n\n+ tmp_data = kmalloc(length, GFP_KERNEL);\n\n+ if (!tmp_data)\n\n+ return -ENOMEM;\n\n+\n\n+ /* 4 bytes are for header, leave them out */\n\n+ if (copy_from_user(tmp_data, buf + 4, length)) {\n\n+ ERROR(mtp->cdev, \"%s copy_from_user fault\\n\", __func__);\n\n+ kfree(tmp_data);\n\n+ return -EFAULT;\n\n+ }\n\n+ length += 4; /* undo the previous minus */\n\n+ }\n\n+\n\n+ spin_lock_irq(&mtp->lock);\n\n+ if (length > 4) {\n\n+ memcpy(mtp->dev_status.data, tmp_data, length - 4);\n\n+ kfree(tmp_data);\n\n+ }\n\n+ mtp->dev_status.length = length;\n\n+ mtp->dev_status.code = code;\n\n+ spin_unlock_irq(&mtp->lock);\n\n+ return 0;\n\n+}\n\n+\n\n+/**\n\n+ * Handle the MTP specific setup requests\n\n+ */\n\n+static int\n\n+mtp_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\n\n+{\n\n+ struct f_mtp *mtp = func_to_mtp(f);\n\n+ struct usb_composite_dev *cdev = f->config->cdev;\n\n+ struct usb_request *req = cdev->req;\n\n+\n\n+ int value = -EOPNOTSUPP;\n\n+ u16 wIndex = le16_to_cpu(ctrl->wIndex);\n\n+ u16 wValue = le16_to_cpu(ctrl->wValue);\n\n+ u16 wLength = le16_to_cpu(ctrl->wLength);\n\n+\n\n+ switch (ctrl->bRequest) {\n\n+ case PTP_REQ_GET_EXTENDED_EVENT_DATA:\n\n+ /* FIXME need to implement\n\n+ * Maybe we could have an IOCTL to save the extended event\n\n+ * data with the driver and then send it to host whenever\n\n+ * we get this request\n\n+ */\n\n+ WARNING(cdev, \"%s: FIXME: PTP request GET_EXTENDED_EVENT_DATA, \"\n\n+ \"not implemented\\n\", __func__);\n\n+ break;\n\n+\n\n+ case PTP_REQ_CANCEL:\n\n+ DBG(cdev, \"%s: PTP: CANCEL\\n\", __func__);\n\n+ if (ctrl->bRequestType != (USB_DIR_OUT |\n\n+ USB_TYPE_CLASS | USB_RECIP_INTERFACE))\n\n+ goto stall;\n\n+\n\n+ if (wValue != 0 || wIndex != 0 || wLength != 6)\n\n+ goto stall;\n\n+\n\n+ /* FIXME need to notify user space stack */\n\n+\n\n+ /* we don't support CANCEL so stall */\n\n+ break;\n\n+\n\n+ case PTP_REQ_DEVICE_RESET:\n\n+ DBG(cdev, \"%s: PTP: DEVICE_RESET\\n\", __func__);\n\n+ if (ctrl->bRequestType != (USB_DIR_OUT |\n\n+ USB_TYPE_CLASS | USB_RECIP_INTERFACE))\n\n+ goto stall;\n\n+\n\n+ if (wValue != 0 || wIndex != 0 || wLength != 0)\n\n+ goto stall;\n\n+\n\n+ /* FIXME need to notify user space stack */\n\n+\n\n+ /* we don't support RESET so stall */\n\n+ break;\n\n+\n\n+ case PTP_REQ_GET_DEVICE_STATUS:\n\n+ /* return the cached device status */\n\n+ DBG(cdev, \"%s: PTP: GET_DEVICE_STATUS\\n\", __func__);\n\n+\n\n+ if (ctrl->bRequestType != (USB_DIR_IN |\n\n+ USB_TYPE_CLASS | USB_RECIP_INTERFACE)) {\n\n+ goto stall;\n\n+ }\n\n+\n\n+ if (wValue != 0 || wIndex != 0)\n\n+ goto stall;\n\n+\n\n+ value = build_device_status(mtp, req->buf,\n\n+ USB_BUFSIZ); /* composite.c */\n\n+\n\n+ if (value < 0) {\n\n+ ERROR(cdev, \"%s: error building device status\\n\",\n\n+ __func__);\n\n+ goto stall;\n\n+ }\n\n+ value = min(wLength, (u16)value);\n\n+ break;\n\n+\n\n+ /* TBD: other response codes */\n\n+ default:\n\n+ WARNING(cdev,\n\n+ \"%s: FIXME, got PTP request 0x%x, not implemented\\n\",\n\n+ __func__, ctrl->bRequest);\n\n+ break;\n\n+ }\n\n+\n\n+ /* data phase of control transfer */\n\n+ if (value >= 0) {\n\n+ req->length = value;\n\n+ req->zero = value < wLength;\n\n+ value = usb_ep_queue(cdev->gadget->ep0,\n\n+ req, GFP_ATOMIC);\n\n+ if (value < 0) {\n\n+ DBG(cdev, \"%s: ep_queue --> %d\\n\", __func__, value);\n\n+ req->status = 0;\n\n+ }\n\n+ }\n\n+\n\n+stall:\n\n+ /* device either stalls (value < 0) or reports success */\n\n+ return value;\n\n+}\n\n+\n\n+static long\n\n+mtp_ioctl(struct gchar *gc, unsigned int cmd, unsigned long arg)\n\n+{\n\n+ int status;\n\n+ struct f_mtp *mtp = gchar_to_mtp(gc);\n\n+ struct usb_composite_dev *cdev = mtp->cdev;\n\n+ int packet_size;\n\n+ struct usb_request *notify_req;\n\n+ void *event_packet;\n\n+ u32 event_packet_len;\n\n+ struct ptp_device_status_data ptp_status;\n\n+\n\n+ switch (cmd) {\n\n+ case MTP_IOCTL_WRITE_ON_INTERRUPT_EP:\n\n+\n\n+ /* get size of packet */\n\n+ if (copy_from_user(&event_packet_len,\n\n+ (void __user *)arg, 4))\n\n+ return -EFAULT;\n\n+\n\n+ event_packet_len = le32_to_cpu(event_packet_len);\n\n+ if (event_packet_len > mtp->notify->maxpacket) {\n\n+ ERROR(cdev, \"%s Max event packet limit exceeded\\n\",\n\n+ __func__);\n\n+ return -EFAULT;\n\n+ }\n\n+\n\n+ event_packet = kmalloc(event_packet_len, GFP_KERNEL);\n\n+ if (!event_packet) {\n\n+ ERROR(cdev, \"%s cannot allocate memory for event\\n\",\n\n+ __func__);\n\n+ return -ENOMEM;\n\n+ }\n\n+\n\n+ /* read full packet */\n\n+ if (copy_from_user(event_packet,\n\n+ (void __user *)arg, event_packet_len)) {\n\n+ kfree(event_packet);\n\n+ return -EFAULT;\n\n+ }\n\n+\n\n+ /* Allocate request object to be used with this endpoint. */\n\n+ notify_req = usb_ep_alloc_request(mtp->notify, GFP_KERNEL);\n\n+ if (!notify_req) {\n\n+ ERROR(cdev,\n\n+ \"%s: could not allocate notify EP request\\n\",\n\n+ __func__);\n\n+ kfree(event_packet);\n\n+ return -ENOMEM;\n\n+ }\n\n+\n\n+ notify_req->buf = event_packet;\n\n+ notify_req->context = mtp;\n\n+ notify_req->complete = mtp_notify_complete;\n\n+ notify_req->length = event_packet_len;\n\n+ if (unlikely(event_packet_len == mtp->notify->maxpacket))\n\n+ notify_req->zero = 1;\n\n+ else\n\n+ notify_req->zero = 0;\n\n+\n\n+\n\n+ status = usb_ep_queue(mtp->notify, notify_req, GFP_ATOMIC);\n\n+ if (status) {\n\n+ ERROR(cdev,\n\n+ \"%s: EVENT packet could not be queued %d\\n\",\n\n+ __func__, status);\n\n+ usb_ep_free_request(mtp->notify, notify_req);\n\n+ kfree(event_packet);\n\n+ return status;\n\n+ }\n\n+ return 0;\n\n+\n\n+ case MTP_IOCTL_GET_MAX_DATAPKT_SIZE:\n\n+ switch (mtp->usb_speed) {\n\n+ case USB_SPEED_LOW:\n\n+ case USB_SPEED_FULL:\n\n+ packet_size = PTP_FS_DATA_PKT_SIZE;\n\n+ break;\n\n+\n\n+ case USB_SPEED_HIGH:\n\n+ case USB_SPEED_VARIABLE:\n\n+ packet_size = PTP_HS_DATA_PKT_SIZE;\n\n+ break;\n\n+\n\n+ default:\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ status = put_user(packet_size, (int *)arg);\n\n+ if (status) {\n\n+ ERROR(cdev,\n\n+ \"%s: could not send max data packet size\\n\",\n\n+ __func__);\n\n+ return -EFAULT;\n\n+ }\n\n+ return 0;\n\n+\n\n+ case MTP_IOCTL_GET_MAX_EVENTPKT_SIZE:\n\n+ switch (mtp->usb_speed) {\n\n+ case USB_SPEED_LOW:\n\n+ case USB_SPEED_FULL:\n\n+ packet_size = PTP_FS_EVENT_PKT_SIZE;\n\n+ break;\n\n+\n\n+ case USB_SPEED_HIGH:\n\n+ case USB_SPEED_VARIABLE:\n\n+ packet_size = PTP_HS_EVENT_PKT_SIZE;\n\n+ break;\n\n+\n\n+ default:\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ status = put_user(packet_size, (int *)arg);\n\n+ if (status) {\n\n+ ERROR(cdev,\n\n+ \"%s: couldn't send max event packet size\\n\",\n\n+ __func__);\n\n+ return -EFAULT;\n\n+ }\n\n+ return 0;\n\n+\n\n+ case MTP_IOCTL_SET_DEVICE_STATUS:\n\n+ if (copy_from_user(&ptp_status, (const void __user *)arg,\n\n+ sizeof(ptp_status)))\n\n+ return -EFAULT;\n\n+\n\n+ status = cache_device_status(mtp,\n\n+ __le16_to_cpu(ptp_status.wLength),\n\n+ __le16_to_cpu(ptp_status.Code),\n\n+ (const void __user *)(arg));\n\n+ return status;\n\n+\n\n+ default:\n\n+ WARNING(cdev, \"%s: unhandled IOCTL %d\\n\", __func__, cmd);\n\n+ return -EINVAL;\n\n+ }\n\n+}\n\n+\n\n+static void\n\n+mtp_disconnect(struct gchar *gc)\n\n+{\n\n+ struct f_mtp *mtp = gchar_to_mtp(gc);\n\n+ struct usb_composite_dev *cdev = mtp->cdev;\n\n+ int status = 0;\n\n+\n\n+ if (!mtp->connected)\n\n+ return;\n\n+\n\n+ status = usb_function_deactivate(&gc->func);\n\n+ if (status) {\n\n+ WARNING(cdev, \"%s: could not deactivate mtp function %d, \"\n\n+ \"status: %d\\n\", __func__, mtp->minor, status);\n\n+ } else {\n\n+ mtp->connected = false;\n\n+ INFO(cdev, \"mtp function %d disconnected\\n\", mtp->minor);\n\n+ }\n\n+}\n\n+\n\n+static void mtp_connect(struct gchar *gc)\n\n+{\n\n+ struct f_mtp *mtp = gchar_to_mtp(gc);\n\n+ struct usb_composite_dev *cdev = mtp->cdev;\n\n+ int status = 0;\n\n+\n\n+ if (mtp->connected)\n\n+ return;\n\n+\n\n+ status = usb_function_activate(&gc->func);\n\n+ if (status) {\n\n+ WARNING(cdev, \"%s: could not activate mtp function %d, \"\n\n+ \"status: %d\\n\", __func__, mtp->minor, status);\n\n+ } else {\n\n+ mtp->connected = true;\n\n+ INFO(cdev, \"mtp function %d connected\\n\", mtp->minor);\n\n+ }\n\n+}\n\n+\n\n+/**\n\n+ * Set alt-settings of the interface.\n\n+ * When connected with host, this function will get called for the\n\n+ * number of interfaces defined for this gadget.\n\n+ * This function enables all the required end points.\n\n+ */\n\n+static int\n\n+mtp_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n\n+{\n\n+ struct usb_composite_dev *cdev = f->config->cdev;\n\n+ struct f_mtp *mtp = func_to_mtp(f);\n\n+ int status = -1;\n\n+\n\n+ if (intf != mtp->mtp_id)\n\n+ return -EINVAL;\n\n+\n\n+ if (alt != 0) {\n\n+ WARNING(cdev, \"%s: invalid setting\\n\", __func__);\n\n+ return -EINVAL;\n\n+ }\n\n+\n\n+ /* Handle interrupt endpoint */\n\n+ if (mtp->notify->driver_data) {\n\n+ DBG(cdev, \"%s: notify reset mtp control %d\\n\", __func__, intf);\n\n+ usb_ep_disable(mtp->notify);\n\n+ } else {\n\n+ DBG(cdev, \"%s: notify init mtp ctrl %d\\n\", __func__, intf);\n\n+ mtp->notify_desc = ep_choose(cdev->gadget,\n\n+ mtp->hs.mtp_int,\n\n+ mtp->fs.mtp_int);\n\n+ }\n\n+\n\n+ status = usb_ep_enable(mtp->notify, mtp->notify_desc);\n\n+ if (status != 0)\n\n+ ERROR(cdev, \"%s: Error enabling endpoint\\n\", __func__);\n\n+ mtp->notify->driver_data = mtp;\n\n+\n\n+ if (mtp->gc.ep_in->driver_data) {\n\n+ /* Altsetting 0 for an interface that already has 0 altset,\n\n+ * ignore this\n\n+ */\n\n+ return 0;\n\n+ }\n\n+\n\n+ if (!mtp->gc.ep_in_desc) {\n\n+ DBG(cdev, \"%s: init mtp %d\\n\", __func__, mtp->minor);\n\n+ mtp->gc.ep_in_desc = ep_choose(cdev->gadget,\n\n+ mtp->hs.mtp_in,\n\n+ mtp->fs.mtp_in);\n\n+ mtp->gc.ep_out_desc = ep_choose(cdev->gadget,\n\n+ mtp->hs.mtp_out,\n\n+ mtp->fs.mtp_out);\n\n+ }\n\n+\n\n+ DBG(cdev, \"%s: mtp %d enable\\n\", __func__, mtp->minor);\n\n+ status = gchar_connect(&mtp->gc, mtp->minor, f->name);\n\n+ if (status) {\n\n+ ERROR(cdev,\n\n+ \"%s: gchar_connect() failed %d\\n\", __func__, status);\n\n+ return status;\n\n+ }\n\n+\n\n+ /* Get the USB speed */\n\n+ mtp->usb_speed = cdev->gadget->speed;\n\n+ return 0;\n\n+}\n\n+\n\n+static void\n\n+mtp_disable(struct usb_function *f)\n\n+{\n\n+ struct f_mtp *mtp = func_to_mtp(f);\n\n+ struct usb_composite_dev *cdev = f->config->cdev;\n\n+\n\n+ DBG(cdev, \"%s: mtp %d disable\\n\", __func__, mtp->minor);\n\n+ /* disable OUT/IN endpoints */\n\n+ gchar_disconnect(&mtp->gc);\n\n+ /* disable INT endpoint */\n\n+ if (mtp->notify->driver_data) {\n\n+ usb_ep_disable(mtp->notify);\n\n+ mtp->notify->driver_data = NULL;\n\n+ mtp->notify_desc = NULL;\n\n+ }\n\n+ mtp->usb_speed = -1;\n\n+}\n\n+\n\n+static int\n\n+__init mtp_bind(struct usb_configuration *c, struct usb_function *f)\n\n+{\n\n+ struct f_mtp *mtp = func_to_mtp(f);\n\n+ struct usb_composite_dev *cdev = c->cdev;\n\n+ int status;\n\n+ struct usb_ep *ep = NULL;\n\n+\n\n+ /* allocate instance-specific interface IDs and patch up descriptors */\n\n+ /* We have only ONE MTP interface. So get the unused interface ID for\n\n+ * this interface.*/\n\n+ status = usb_interface_id(c, f);\n\n+ if (status < 0)\n\n+ return status;\n\n+ mtp->mtp_id = status;\n\n+ mtp_intf.bInterfaceNumber = status;\n\n+\n\n+ status = -ENOMEM;\n\n+ /* Allocate the endpoints */\n\n+ /* mtp_ep_fs_in_desc */\n\n+ ep = usb_ep_autoconfig(cdev->gadget, &mtp_ep_fs_in_desc);\n\n+ if (!ep)\n\n+ goto fail;\n\n+ mtp->gc.ep_in = ep;\n\n+ ep->driver_data = cdev;\n\n+\n\n+ /* mtp_ep_fs_out_desc */\n\n+ ep = usb_ep_autoconfig(cdev->gadget, &mtp_ep_fs_out_desc);\n\n+ if (!ep)\n\n+ goto fail;\n\n+ mtp->gc.ep_out = ep;\n\n+ ep->driver_data = cdev;\n\n+\n\n+ /* mtp_ep_fs_int_desc */\n\n+ ep = usb_ep_autoconfig(cdev->gadget, &mtp_ep_fs_int_desc);\n\n+ if (!ep)\n\n+ goto fail;\n\n+ mtp->notify = ep;\n\n+ ep->driver_data = cdev;\n\n+\n\n+\n\n+ /* copy descriptors, and track endpoint copies */\n\n+ f->descriptors = usb_copy_descriptors(mtp_fs_function);\n\n+ mtp->fs.mtp_in = usb_find_endpoint(mtp_fs_function,\n\n+ f->descriptors, &mtp_ep_fs_in_desc);\n\n+ mtp->fs.mtp_out = usb_find_endpoint(mtp_fs_function,\n\n+ f->descriptors, &mtp_ep_fs_out_desc);\n\n+ mtp->fs.mtp_int = usb_find_endpoint(mtp_fs_function,\n\n+ f->descriptors, &mtp_ep_fs_int_desc);\n\n+\n\n+ /* support all relevant hardware speeds... we expect that when\n\n+ * hardware is dual speed, all bulk-capable endpoints work at\n\n+ * both speeds\n\n+ */\n\n+ if (gadget_is_dualspeed(c->cdev->gadget)) {\n\n+ /* Copy endpoint address */\n\n+ mtp_ep_hs_in_desc.bEndpointAddress =\n\n+ mtp_ep_fs_in_desc.bEndpointAddress;\n\n+ mtp_ep_hs_out_desc.bEndpointAddress =\n\n+ mtp_ep_fs_out_desc.bEndpointAddress;\n\n+ mtp_ep_hs_int_desc.bEndpointAddress =\n\n+ mtp_ep_fs_int_desc.bEndpointAddress;\n\n+\n\n+ /* Copy descriptors, and track endpoint copies */\n\n+ f->hs_descriptors = usb_copy_descriptors(mtp_hs_function);\n\n+ mtp->hs.mtp_in = usb_find_endpoint(mtp_hs_function,\n\n+ f->hs_descriptors, &mtp_ep_hs_in_desc);\n\n+ mtp->hs.mtp_out = usb_find_endpoint(mtp_hs_function,\n\n+ f->hs_descriptors, &mtp_ep_hs_out_desc);\n\n+ mtp->hs.mtp_int = usb_find_endpoint(mtp_hs_function,\n\n+ f->hs_descriptors, &mtp_ep_hs_int_desc);\n\n+ }\n\n+\n\n+ /* Prevent enumeration until someone opens\n\n+ * the port from the user space */\n\n+ status = usb_function_deactivate(f);\n\n+ if (status < 0) {\n\n+ WARNING(cdev, \"%s: mtp %d: can't prevent enumeration, %d\\n\",\n\n+ __func__, mtp->minor, status);\n\n+ mtp->connected = true;\n\n+ }\n\n+\n\n+\n\n+ INFO(cdev, \"mtp %d: %s speed IN/%s OUT/%s INT/%s\\n\",\n\n+ mtp->minor,\n\n+ gadget_is_dualspeed(cdev->gadget) ? \"dual\" : \"full\",\n\n+ mtp->gc.ep_in->name, mtp->gc.ep_out->name,\n\n+ mtp->notify->name);\n\n+\n\n+ return 0;\n\n+fail:\n\n+ if (mtp->gc.ep_out)\n\n+ mtp->gc.ep_out->driver_data = NULL;\n\n+\n\n+ if (mtp->gc.ep_in)\n\n+ mtp->gc.ep_in->driver_data = NULL;\n\n+\n\n+ if (mtp->notify)\n\n+ mtp->notify->driver_data = NULL;\n\n+\n\n+ ERROR(cdev, \"%s/%p: cant bind, err %d\\n\", f->name, f, status);\n\n+\n\n+ return status;\n\n+}\n\n+\n\n+static void\n\n+mtp_unbind(struct usb_configuration *c, struct usb_function *f)\n\n+{\n\n+ struct f_mtp *mtp = func_to_mtp(f);\n\n+\n\n+ if (gadget_is_dualspeed(c->cdev->gadget))\n\n+ usb_free_descriptors(f->hs_descriptors);\n\n+\n\n+ usb_free_descriptors(f->descriptors);\n\n+ kfree(mtp);\n\n+}\n\n+\n\n+/**\n\n+ * mtp_bind_config - add a MTP function to a configuration\n\n+ * @c: the configuration to support MTP\n\n+ * @port_num: /dev/ttyGS* port this interface will use\n\n+ * Context: single threaded during gadget setup\n\n+ *\n\n+ * Returns zero on success, else negative errno.\n\n+ *\n\n+ * Caller must have called @gchar_setup() with enough devices to\n\n+ * handle all the ones it binds. Caller is also responsible\n\n+ * for calling @gchar_cleanup() before module unload.\n\n+ */\n\n+int\n\n+__init mtp_bind_config(struct usb_configuration *c, u8 minor)\n\n+{\n\n+ struct f_mtp *mtp = NULL;\n\n+ int status = 0;\n\n+\n\n+ /* allocate device global string IDs and patch descriptors*/\n\n+ if (mtp_string_defs[0].id == 0) {\n\n+ status = usb_string_id(c->cdev);\n\n+ if (status < 0)\n\n+ return status;\n\n+ mtp_string_defs[0].id = status;\n\n+ mtp_intf.iInterface = status;\n\n+ }\n\n+\n\n+ /* allocate and initialize one new instance */\n\n+ mtp = kzalloc(sizeof(*mtp), GFP_KERNEL);\n\n+ if (!mtp)\n\n+ return -ENOMEM;\n\n+\n\n+ spin_lock_init(&mtp->lock);\n\n+\n\n+ mtp->minor = minor;\n\n+\n\n+ mtp->gc.func.name = \"MTP\";\n\n+ mtp->gc.func.strings = mtp_strings;\n\n+\n\n+ mtp->gc.open = mtp_connect;\n\n+ mtp->gc.close = mtp_disconnect;\n\n+ mtp->gc.ioctl = mtp_ioctl;\n\n+\n\n+ mtp->gc.func.bind = mtp_bind;\n\n+ mtp->gc.func.unbind = mtp_unbind;\n\n+ mtp->gc.func.set_alt = mtp_set_alt;\n\n+ mtp->gc.func.setup = mtp_setup;\n\n+ mtp->gc.func.disable = mtp_disable;\n\n+\n\n+ mtp->usb_speed = -1; /* invalid speed */\n\n+\n\n+ mtp->cdev = c->cdev;\n\n+\n\n+ /* default device status is BUSY */\n\n+ cache_device_status(mtp, 4, PTP_RC_DEVICE_BUSY, 0);\n\n+\n\n+ status = usb_add_function(c, &mtp->gc.func);\n\n+ if (status) {\n\n+ kfree(mtp);\n\n+ }\n\n+\n\n+ return status;\n\n+}\n\ndiff --git a/drivers/usb/gadget/mtp.c b/drivers/usb/gadget/mtp.c\n\nnew file mode 100644\n\nindex 0000000..b0cea2f\n\n--- /dev/null\n\n+++ b/drivers/usb/gadget/mtp.c\n\n@@ -0,0 +1,249 @@\n\n+/*\n\n+ * mtp.c -- Media Transfer Protocol USB Gadget Driver\n\n+ *\n\n+ * Copyright (C) 2009-2010 Nokia Corporation\n\n+ * Contact: Yauheni Kaliuta <yauheni.kaliuta-***@public.gmane.org>\n\n+ *\n\n+ * This gadget driver borrows from serial.c which is:\n\n+ *\n\n+ * Copyright (C) 2003 Al Borchers (alborchers-***@public.gmane.org)\n\n+ * Copyright (C) 2008 by David Brownell\n\n+ * Copyright (C) 2008 by Nokia Corporation\n\n+ *\n\n+ * This program is free software; you can redistribute it and/or modify\n\n+ * it under the terms of the GNU General Public License as published by\n\n+ * the Free Software Foundation; either version 2 of the License, or\n\n+ * (at your option) any later version.\n\n+ *\n\n+ * This program is distributed in the hope that it will be useful,\n\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n\n+ * GNU General Public License for more details.\n\n+ *\n\n+ * You should have received a copy of the GNU General Public License\n\n+ * along with this program; if not, write to the Free Software\n\n+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n\n+ */\n\n+\n\n+#include <linux/kernel.h>\n\n+#include <linux/utsname.h>\n\n+#include <linux/device.h>\n\n+\n\n+#include <linux/usb/composite.h>\n\n+#include \"u_char.h\"\n\n+#include \"gadget_chips.h\"\n\n+\n\n+/*-------------------------------------------------------------------------*/\n\n+\n\n+/*\n\n+ * Kbuild is not very cooperative with respect to linking separately\n\n+ * compiled library objects into one module. So for now we won't use\n\n+ * separate compilation ... ensuring init/exit sections work to shrink\n\n+ * the runtime footprint, and giving us at least some parts of what\n\n+ * a \"gcc --combine ... part1.c part2.c part3.c ... \" build would.\n\n+ */\n\n+#include \"composite.c\"\n\n+#include \"usbstring.c\"\n\n+#include \"config.c\"\n\n+#include \"epautoconf.c\"\n\n+\n\n+#include \"f_mtp.c\"\n\n+#include \"u_char.c\"\n\n+\n\n+/*-------------------------------------------------------------------------*/\n\n+\n\n+#define MTP_VERSION_NUM 0x1000\n\n+#define MTP_VERSION_STR \"1.0\"\n\n+\n\n+#define MTP_VENDOR_ID 0x0101\n\n+#define MTP_PRODUCT_ID 0x0202\n\n+\n\n+#define MTP_DRIVER_DESC \"MTP Gadget\"\n\n+\n\n+/* string IDs are assigned dynamically */\n\n+\n\n+#define STRING_MANUFACTURER_IDX 0\n\n+#define STRING_PRODUCT_IDX 1\n\n+#define STRING_DESCRIPTION_IDX 2\n\n+\n\n+static char manufacturer[50];\n\n+\n\n+static struct usb_string strings_dev[] = {\n\n+ [STRING_MANUFACTURER_IDX].s = manufacturer,\n\n+ [STRING_PRODUCT_IDX].s = MTP_DRIVER_DESC,\n\n+ [STRING_DESCRIPTION_IDX].s = MTP_DRIVER_DESC,\n\n+ { } /* end of list */\n\n+};\n\n+\n\n+static struct usb_gadget_strings stringtab_dev = {\n\n+ .language = 0x0409, /* en-us */\n\n+ .strings = strings_dev,\n\n+};\n\n+\n\n+static struct usb_gadget_strings *dev_strings[] = {\n\n+ &stringtab_dev,\n\n+ NULL,\n\n+};\n\n+\n\n+static struct usb_device_descriptor device_desc = {\n\n+ .bLength = USB_DT_DEVICE_SIZE,\n\n+ .bDescriptorType = USB_DT_DEVICE,\n\n+ .bcdUSB = cpu_to_le16(0x0200),\n\n+ .bDeviceClass = USB_CLASS_PER_INTERFACE,\n\n+ .bDeviceSubClass = 0,\n\n+ .bDeviceProtocol = 0,\n\n+ /* .bMaxPacketSize0 = f(hardware) */\n\n+ .idVendor = cpu_to_le16(MTP_VENDOR_ID),\n\n+ .idProduct = cpu_to_le16(MTP_PRODUCT_ID),\n\n+ /* .bcdDevice = f(hardware) */\n\n+ /* .iManufacturer = DYNAMIC */\n\n+ /* .iProduct = DYNAMIC */\n\n+ .bNumConfigurations = 1,\n\n+};\n\n+\n\n+static struct usb_otg_descriptor otg_descriptor = {\n\n+ .bLength = sizeof otg_descriptor,\n\n+ .bDescriptorType = USB_DT_OTG,\n\n+\n\n+ /* REVISIT SRP-only hardware is possible, although\n\n+ * it would not be called \"OTG\" ...\n\n+ */\n\n+ .bmAttributes = USB_OTG_SRP | USB_OTG_HNP,\n\n+};\n\n+\n\n+static const struct usb_descriptor_header *otg_desc[] = {\n\n+ (struct usb_descriptor_header *) &otg_descriptor,\n\n+ NULL,\n\n+};\n\n+\n\n+/*-------------------------------------------------------------------------*/\n\n+\n\n+/* Module */\n\n+MODULE_DESCRIPTION(MTP_DRIVER_DESC);\n\n+MODULE_AUTHOR(\"Yauheni Kaliuta\");\n\n+MODULE_LICENSE(\"GPL\");\n\n+\n\n+/*-------------------------------------------------------------------------*/\n\n+\n\n+static int __init g_mtp_bind_config(struct usb_configuration *c)\n\n+{\n\n+ int status;\n\n+\n\n+ status = mtp_bind_config(c, 0);\n\n+ if (status)\n\n+ printk(KERN_DEBUG \"could not bind mtp config\\n\");\n\n+\n\n+ return status;\n\n+}\n\n+\n\n+static struct usb_configuration mtp_config_driver = {\n\n+ /* .label = f(use_acm) */\n\n+ .bind = g_mtp_bind_config,\n\n+ .bConfigurationValue = 1,\n\n+ /* .iConfiguration = DYNAMIC */\n\n+ .bmAttributes = USB_CONFIG_ATT_SELFPOWER,\n\n+};\n\n+\n\n+static int __init g_mtp_bind(struct usb_composite_dev *cdev)\n\n+{\n\n+ int gcnum;\n\n+ struct usb_gadget *gadget = cdev->gadget;\n\n+ int status;\n\n+\n\n+ status = gchar_setup(cdev->gadget, 1);\n\n+ if (status < 0)\n\n+ return status;\n\n+\n\n+ /* Allocate string descriptor numbers ... note that string\n\n+ * contents can be overridden by the composite_dev glue.\n\n+ */\n\n+\n\n+ /* device description: manufacturer, product */\n\n+ snprintf(manufacturer, sizeof manufacturer, \"%s %s with %s\",\n\n+ init_utsname()->sysname, init_utsname()->release,\n\n+ gadget->name);\n\n+ status = usb_string_id(cdev);\n\n+ if (status < 0)\n\n+ goto fail;\n\n+ strings_dev[STRING_MANUFACTURER_IDX].id = status;\n\n+\n\n+ device_desc.iManufacturer = status;\n\n+\n\n+ status = usb_string_id(cdev);\n\n+ if (status < 0)\n\n+ goto fail;\n\n+ strings_dev[STRING_PRODUCT_IDX].id = status;\n\n+\n\n+ device_desc.iProduct = status;\n\n+\n\n+ /* config description */\n\n+ status = usb_string_id(cdev);\n\n+ if (status < 0)\n\n+ goto fail;\n\n+ strings_dev[STRING_DESCRIPTION_IDX].id = status;\n\n+\n\n+ mtp_config_driver.iConfiguration = status;\n\n+\n\n+ /* set up other descriptors */\n\n+ gcnum = usb_gadget_controller_number(gadget);\n\n+ if (gcnum >= 0)\n\n+ device_desc.bcdDevice = cpu_to_le16(MTP_VERSION_NUM | gcnum);\n\n+ else {\n\n+ /* this is so simple (for now, no altsettings) that it\n\n+ * SHOULD NOT have problems with bulk-capable hardware.\n\n+ * so warn about unrecognized controllers -- don't panic.\n\n+ *\n\n+ * things like configuration and altsetting numbering\n\n+ * can need hardware-specific attention though.\n\n+ */\n\n+ WARNING(cdev, \"g_mtp_bind: controller '%s' not recognized\\n\",\n\n+ gadget->name);\n\n+ device_desc.bcdDevice =\n\n+ cpu_to_le16(MTP_VERSION_NUM | 0x0099);\n\n+ }\n\n+\n\n+ if (gadget_is_otg(cdev->gadget)) {\n\n+ mtp_config_driver.descriptors = otg_desc;\n\n+ mtp_config_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\n+ }\n\n+\n\n+ /* register our configuration */\n\n+ status = usb_add_config(cdev, &mtp_config_driver);\n\n+ if (status < 0)\n\n+ goto fail;\n\n+\n\n+ DBG(cdev, \"%s, version: \" MTP_VERSION_STR \"\\n\",\n\n+ MTP_DRIVER_DESC);\n\n+\n\n+ return 0;\n\n+\n\n+fail:\n\n+ gchar_cleanup();\n\n+ return status;\n\n+}\n\n+\n\n+static int __exit g_mtp_unbind(struct usb_composite_dev *cdev)\n\n+{\n\n+ gchar_cleanup();\n\n+ return 0;\n\n+}\n\n+\n\n+static struct usb_composite_driver gmtp_driver = {\n\n+ .name = \"g_mtp\",\n\n+ .dev = &device_desc,\n\n+ .strings = dev_strings,\n\n+ .bind = g_mtp_bind,\n\n+ .unbind = __exit_p(g_mtp_unbind),\n\n+};\n\n+\n\n+static int __init init(void)\n\n+{\n\n+ return usb_composite_register(&gmtp_driver);\n\n+}\n\n+module_init(init);\n\n+\n\n+static void __exit cleanup(void)\n\n+{\n\n+ usb_composite_unregister(&gmtp_driver);\n\n+}\n\n+module_exit(cleanup);\n\ndiff --git a/include/linux/usb/ptp.h b/include/linux/usb/ptp.h\n\nnew file mode 100644\n\nindex 0000000..dd14ab1\n\n--- /dev/null\n\n+++ b/include/linux/usb/ptp.h\n\n@@ -0,0 +1,105 @@\n\n+/*\n\n+ * ptp.h -- Picture Transfer Protocol definitions\n\n+ *\n\n+ * Copyright (C) 2009-2010 Nokia Corporation\n\n+ *\n\n+ * This program is free software; you can redistribute it and/or modify\n\n+ * it under the terms of the GNU General Public License as published by\n\n+ * the Free Software Foundation; either version 2 of the License, or\n\n+ * (at your option) any later version.\n\n+ *\n\n+ * This program is distributed in the hope that it will be useful,\n\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n\n+ * GNU General Public License for more details.\n\n+ *\n\n+ * You should have received a copy of the GNU General Public License\n\n+ * along with this program; if not, write to the Free Software\n\n+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n\n+ */\n\n+\n\n+#ifndef __LINUX_USB_PTP_H\n\n+#define __LINUX_USB_PTP_H\n\n+\n\n+/* device or driver specific */\n\n+#define PTP_HS_DATA_PKT_SIZE 512\n\n+#define PTP_HS_EVENT_PKT_SIZE 64\n\n+\n\n+#define PTP_FS_DATA_PKT_SIZE 64\n\n+#define PTP_FS_EVENT_PKT_SIZE 64\n\n+\n\n+#define PTP_PACKET_LENGTH 16\n\n+#define PTP_MAX_STATUS_SIZE 64\n\n+\n\n+/* PTP USB Class codes */\n\n+#define USB_SUBCLASS_PTP 1\n\n+#define USB_PROTOCOL_PTP 1\n\n+\n\n+/* PTP Response Codes */\n\n+\n\n+#define PTP_RC_OK 0x2001\n\n+#define PTP_RC_DEVICE_BUSY 0x2019\n\n+#define PTP_RC_TRANSACTION_CANCELLED 0x201F\n\n+\n\n+/**\n\n+ * PTP class specific requests\n\n+ */\n\n+#define PTP_REQ_CANCEL 0x64\n\n+#define PTP_REQ_GET_EXTENDED_EVENT_DATA 0x65\n\n+#define PTP_REQ_DEVICE_RESET 0x66\n\n+#define PTP_REQ_GET_DEVICE_STATUS 0x67\n\n+\n\n+struct ptp_device_status_data {\n\n+ __le16 wLength;\n\n+ __le16 Code;\n\n+ __le32 Parameter1;\n\n+ __le32 Parameter2;\n\n+} __attribute__ ((packed));\n\n+\n\n+struct ptp_cancel_data {\n\n+ __le16 CancellationCode;\n\n+ __le32 TransactionID;\n\n+} __attribute__ ((packed));\n\n+\n\n+\n\n+/* MTP IOCTLs */\n\n+\n\n+#define MTP_IOCTL_BASE 0xF9\n\n+#define MTP_IO(nr) _IO(MTP_IOCTL_BASE, nr)\n\n+#define MTP_IOR(nr, type) _IOR(MTP_IOCTL_BASE, nr, type)\n\n+#define MTP_IOW(nr, type) _IOW(MTP_IOCTL_BASE, nr, type)\n\n+#define MTP_IOWR(nr, type) _IOWR(MTP_IOCTL_BASE, nr, type)\n\n+\n\n+\n\n+/* MTP_IOCTL_WRITE_ON_INTERRUPT_EP\n\n+ *\n\n+ * Write at max 64 bytes to MTP interrupt i.e. event endpoint\n\n+ */\n\n+#define MTP_IOCTL_WRITE_ON_INTERRUPT_EP MTP_IOW(0, __u8[64])\n\n+\n\n+/* Not yet Implemented\n\n+ *\n\n+ * #define MTP_IOCTL_DEVICE_STATUS MTP_IOW(1, char *)\n\n+ * #define MTP_IOCTL_CANCEL_TXN MTP_IOW(2, char *)\n\n+ *\n\n+ */\n\n+\n\n+/* MTP_IOCTL_GET_MAX_DATAPKT_SIZE\n\n+ *\n\n+ * Return the max packet size of Data endpoint\n\n+ */\n\n+#define MTP_IOCTL_GET_MAX_DATAPKT_SIZE MTP_IOR(3, __u32)\n\n+\n\n+/* MTP_IOCTL_GET_MAX_EVENTPKT_SIZE\n\n+ *\n\n+ * Return the max packet size of Event endpoing\n\n+ */\n\n+#define MTP_IOCTL_GET_MAX_EVENTPKT_SIZE MTP_IOR(4, __u32)\n\n+\n\n+/* MTP_IOCTL_SET_DEVICE_STATUS\n\n+ *\n\n+ * Update drivers device status cache\n\n+ */\n\n+#define MTP_IOCTL_SET_DEVICE_STATUS MTP_IOW(5, __u8[PTP_MAX_STATUS_SIZE])\n\n+\n\n+#endif /* __LINUX_USB_PTP_H */\n\n--\n\n1.7.0.rc0.33.g7c3932\n\n--\n\nTo unsubscribe from this list: send the line \"unsubscribe linux-usb\" in\n\nthe body of a message to majordomo-***@public.gmane.org\n\nMore majordomo info at http://vger.kernel.org/majordomo-info.html"
    }
}