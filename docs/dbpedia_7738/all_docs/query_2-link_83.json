{
    "id": "dbpedia_7738_2",
    "rank": 83,
    "data": {
        "url": "https://manpages.ubuntu.com/manpages/noble/man1/swupdate.1.html",
        "read_more_link": "",
        "language": "en",
        "title": "SWUpdate Documentation [image]",
        "top_image": "https://assets.ubuntu.com/v1/cb22ba5d-favicon-16x16.png",
        "meta_img": "https://assets.ubuntu.com/v1/cb22ba5d-favicon-16x16.png",
        "images": [
            "https://assets.ubuntu.com/v1/b93fecb3-ubuntu-manuals-lockup.svg",
            "https://manpages.ubuntu.com/img/bug.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://assets.ubuntu.com/v1/cb22ba5d-favicon-16x16.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Provided by: swupdate_2023.12.1+dfsg-1ubuntu5_amd64\n\nNAME\n\nswupdate - SWUpdate Documentation [image] SWUpdate provides a reliable way to update the software on an embedded system. Sources are hosted at https://github.com/sbabic/swupdate. Do not forget to star SWUpdate.\n\nSOFTWARE MANAGEMENT ON EMBEDDED SYSTEMS\n\nAs Embedded Systems become more and more complex, their software reflects the augmented complexity. It is vital that the software on an embedded system can be updated in an absolutely reliable way, as new features and fixes are added. On a Linux-based system, we can find in most cases the following elements: â¢ the boot loader. â¢ the kernel and the DT (Device Tree) file. â¢ the root file system â¢ other file systems, mounted at a later point â¢ customer data, in raw format or on a file system â¢ application specific software. For example, firmware to be downloaded on connected micro-controllers, and so on. Generally speaking, in most cases it is required to update kernel and root file system, preserving user data - but cases vary. In only a few cases it is required to update the boot loader, too. In fact, updating the boot loader is quite always risky, because a failure in the update breaks the board. Restoring a broken board is possible in some cases, but this is not left in most cases to the end user and the system must be sent back to the manufacturer. There are a lot of different concepts about updating the software. I like to expose some of them, and then explain why I have implemented this project. Updating through the boot loader Boot loaders do much more as simply start the kernel. They have their own shell and can be managed using a processorâs peripheral, in most cases a serial line. They are often script-able, letting possible to implement some kind of software update mechanism. However, I found some drawbacks in this approach, that let me search for another solution, based on an application running on Linux: Boot loaders have limited access to peripherals Not all peripherals supported by the kernel are available with the boot loader. When it makes sense to add support to the kernel, because the peripheral is then available by the main application, it does not always make sense to duplicate the effort to port the driver to the boot loader. Boot loaderâs drivers are not updated Boot loaderâs drivers are mostly ported from the Linux kernel, but due to adaptations they are not later fixed or synchronized with the kernel, while bug fixes flow regularly in the Linux kernel. Some peripherals can then work in a not reliable ways, and fixing the issues can be not easy. Drivers in boot loaders are more or less a fork of the respective drivers in kernel. As example, the UBI / UBIFS for NAND devices contains a lot of fixes in the kernel, that are not ported back to the boot loaders. The same can be found for the USB stack. The effort to support new peripherals or protocols is better to be used for the kernel as for the boot loaders. Reduced file systems The number of supported file systems is limited and porting a file system to the boot loader requires high effort. Network support is limited Network stack is limited, generally an update is possible via UDP but not via TCP. Interaction with the operator It is difficult to expose an interface to the operator, such as a GUI with a browser or on a display. A complex logic can be easier implemented inside an application else in the boot loader. Extending the boot loader becomes complicated because the whole range of services and libraries are not available. Boot loaderâs update advantages However, this approach has some advantages, too: â¢ software for update is generally simpler. - smaller footprint: a stand-alone application only for software management requires an own kernel and a root file system. Even if their size can be trimmed dropping what is not required for updating the software, their size is not negligible. Updating through a package manager All Linux distributions are updating with a package manager. Why is it not suitable for embedded ? I cannot say it cannot be used, but there is an important drawback using this approach. Embedded systems are well tested with a specific software. Using a package manager can put weirdness because the software itself is not anymore atomic, but split into a long list of packages. How can we be assured that an application with library version x.y works, and also with different versions of the same library? How can it be successfully tested? For a manufacturer, it is generally better to say that a new release of software (well tested by its test engineers) is released, and the new software (or firmware) is available for updating. Splitting in packages can generate nightmare and high effort for the testers. The ease of replacing single files can speed up the development, but it is a software-versions nightmare at the customer site. If a customer report a bug, how can it is possible that software is âversion 2.5â when a patch for some files were sent previously to the customer ? An atomic update is generally a must feature for an embedded system. Strategies for an application doing software upgrade Instead of using the boot loader, an application can take into charge to upgrade the system. The application can use all services provided by the OS. The proposed solution is a stand-alone software, that follow customer rules and performs checks to determine if a software is installable, and then install the software on the desired storage. The application can detect if the provided new software is suitable for the hardware, and it is can also check if the software is released by a verified authority. The range of features can grow from small system to a complex one, including the possibility to have pre- and post- install scripts, and so on. Different strategies can be used, depending on the systemâs resources. I am listing some of them. Double copy with fall-back If there is enough space on the storage to save two copies of the whole software, it is possible to guarantee that there is always a working copy even if the software update is interrupted or a power off occurs. Each copy must contain the kernel, the root file system, and each further component that can be updated. It is required a mechanism to identify which version is running. SWUpdate should be inserted in the application software, and the application software will trigger it when an update is required. The duty of SWUpdate is to update the stand-by copy, leaving the running copy of the software untouched. A synergy with the boot loader is often necessary, because the boot loader must decide which copy should be started. Again, it must be possible to switch between the two copies. After a reboot, the boot loader decides which copy should run. [image] Check the chapter about boot loader to see which mechanisms can be implemented to guarantee that the target is not broken after an update. The most evident drawback is the amount of required space. The available space for each copy is less than half the size of the storage. However, an update is always safe even in case of power off. This project supports this strategy. The application as part of this project should be installed in the root file system and started or triggered as required. There is no need of an own kernel, because the two copies guarantees that it is always possible to upgrade the not running copy. SWUpdate will set bootloaderâs variable to signal the that a new image is successfully installed. Single copy - running as standalone image The software upgrade application consists of kernel (maybe reduced dropping not required drivers) and a small root file system, with the application and its libraries. The whole size is much less than a single copy of the system software. Depending on set up, I get sizes from 2.5 until 8 MB for the stand-alone root file system. If the size is very important on small systems, it becomes negligible on systems with a lot of storage or big NANDs. The system can be put in âupgradeâ mode, simply signaling to the boot loader that the upgrading software must be started. The way can differ, for example setting a boot loader environment or using and external GPIO. The boot loader starts âSWUpdateâ, booting the SWUpdate kernel and the initrd image as root file system. Because it runs in RAM, it is possible to upgrade the whole storage. Differently as in the double-copy strategy, the systems must reboot to put itself in update mode. This concept consumes less space in storage as having two copies, but it does not guarantee a fall-back without updating again the software. However, it can be guaranteed that the system goes automatically in upgrade mode when the productivity software is not found or corrupted, as well as when the upgrade process is interrupted for some reason. [image] In fact, it is possible to consider the upgrade procedure as a transaction, and only after the successful upgrade the new software is set as âboot-ableâ. With these considerations, an upgrade with this strategy is safe: it is always guaranteed that the system boots and it is ready to get a new software, if the old one is corrupted or cannot run. With U-Boot as boot loader, SWUpdate is able to manage U-Bootâs environment setting variables to indicate the start and the end of a transaction and that the storage contains a valid software. A similar feature for GRUB environment block modification as well as for EFI Boot Guard has been introduced. SWUpdate is mainly used in this configuration. The recipes for Yocto generate an initrd image containing the SWUpdate application, that is automatically started after mounting the root file system. [image] Something went wrong ? Many things can go wrong, and it must be guaranteed that the system is able to run again and maybe able to reload a new software to fix a damaged image. SWUpdate works together with the boot loader to identify the possible causes of failures. Currently U-Boot, GRUB, and EFI Boot Guard are supported. We can at least group some of the common causes: â¢ damage / corrupted image during installing. SWUpdate is able to recognize it and the update process is interrupted. The old software is preserved and nothing is really copied into the targetâs storage. â¢ corrupted image in the storage (flash) â¢ remote update interrupted due to communication problem. â¢ power-failure SWUpdate works as transaction process. The boot loader environment variable ârecovery_statusâ is set to signal the updateâs status to the boot loader. Of course, further variables can be added to fine tuning and report error causes. recovery_status can have the values âprogressâ, âfailedâ, or it can be unset. When SWUpdate starts, it sets recovery_status to âprogressâ. After an update is finished with success, the variable is erased. If the update ends with an error, recovery_status has the value âfailedâ. When an update is interrupted, independently from the cause, the boot loader recognizes it because the recovery_status variable is in âprogressâ or âfailedâ. The boot loader can then start again SWUpdate to load again the software (single-copy case) or run the old copy of the application (double-copy case). Power Failure If a power off occurs, it must be guaranteed that the system is able to work again - starting again SWUpdate or restoring an old copy of the software. Generally, the behavior can be split according to the chosen scenario: â¢ single copy: SWUpdate is interrupted and the update transaction did not end with a success. The boot loader is able to start SWUpdate again, having the possibility to update the software again. â¢ double copy: SWUpdate did not switch between stand-by and current copy. The same version of software, that was not touched by the update, is started again. To be completely safe, SWUpdate and the bootloader need to exchange some information. The bootloader must detect if an update was interrupted due to a power-off, and restart SWUpdate until an update is successful. SWUpdate supports the U-Boot, GRUB, and EFI Boot Guard bootloaders. U-Boot and EFI Boot Guard have a power-safe environment which SWUpdate is able to read and change in order to communicate with them. In case of GRUB, a fixed 1024-byte environment block file is used instead. SWUpdate sets a variable as flag when it starts to update the system and resets the same variable after completion. The bootloader can read this flag to check if an update was running before a power-off. [image] What about upgrading SWUpdate itself ? SWUpdate is thought to be used in the whole development process, replacing customized process to update the software during the development. Before going into production, SWUpdate is well tested for a project. If SWUpdate itself should be updated, the update cannot be safe if there is only one copy of SWUpdate in the storage. Safe update can be guaranteed only if SWUpdate is duplicated. There are some ways to circumvent this issue if SWUpdate is part of the upgraded image: â¢ have two copies of SWUpdate â¢ take the risk, but have a rescue procedure using the boot loader. What about upgrading the Boot loader ? Updating the boot loader is in most cases a one-way process. On most SOCs, there is no possibility to have multiple copies of the boot loader, and when boot loader is broken, the board does not simply boot. Some SOCs allow one to have multiple copies of the boot loader. But again, there is no general solution for this because it is very hardware specific. In my experience, most targets do not allow one to update the boot loader. It is very uncommon that the boot loader must be updated when the product is ready for production. It is different if the U-Boot environment must be updated, that is a common practice. U-Boot provides a double copy of the whole environment, and updating the environment from SWUpdate is power-off safe. Other boot loaders can or cannot have this feature.\n\nLICENSE\n\nSWUpdate is Free Software. It is copyrighted by Stefano Babic and many others who contributed code (see the actual source code and the git commit messages for details). You can redistribute SWUpdate and/or modify it under the terms of version 2 of the GNU General Public License as published by the Free Software Foundation. Some files can also be distributed, at your option, under any later version of the GNU General Public License â see individual files for exceptions. To make this easier, license headers in the source files will be replaced with a single line reference to Unique License Identifiers as defined by the Linux Foundationâs SPDX project [1]. For example, in a source file the full âGPL v2.0 onlyâ header text will be replaced by a single line: SPDX-License-Identifier: GPL-2.0-only Ideally, the license terms of all files in the source tree should be defined by such License Identifiers; in no case a file can contain more than one such License Identifier list. If a âSPDX-License-Identifier:â line references more than one Unique License Identifier, then this means that the respective file can be used under the terms of either of these licenses, i. e. with SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause you can choose between GPL-2.0-only and BSD-3-Clause licensing. We use the SPDX Unique License Identifiers (SPDX-Identifiers)\n\nLICENSES\n\nâââââââââââââââââââââââââââ¬ââââââââââââââââââââ¬âââââââââââââââ âFull name â SPDX Identifier â OSI Approved â âââââââââââââââââââââââââââ¼ââââââââââââââââââââ¼âââââââââââââââ¤ âGNU General Public â GPL-2.0-only â Y â âLicense v2.0 only â â â âââââââââââââââââââââââââââ¼ââââââââââââââââââââ¼âââââââââââââââ¤ âGNU Lesser General â LGPL-2.1-or-later â Y â âPublic License v2.1 or â â â âlater â â â âââââââââââââââââââââââââââ¼ââââââââââââââââââââ¼âââââââââââââââ¤ âBSD 1-Clause License â BSD-1-Clause â Y â âââââââââââââââââââââââââââ¼ââââââââââââââââââââ¼âââââââââââââââ¤ âBSD 2-Clause License â BSD-2-Clause â Y â âââââââââââââââââââââââââââ¼ââââââââââââââââââââ¼âââââââââââââââ¤ âBSD 3-Clause âNewâ or â BSD-3-Clause â Y â ââRevisedâ License â â â âââââââââââââââââââââââââââ¼ââââââââââââââââââââ¼âââââââââââââââ¤ âMIT License â MIT â Y â âââââââââââââââââââââââââââ¼ââââââââââââââââââââ¼âââââââââââââââ¤ âCreative Commons Zero â CC0-1.0 â N â â1.0 Universal (CC0) â â â âââââââââââââââââââââââââââ´ââââââââââââââââââââ´âââââââââââââââ âCreative Commons â CC-BY-SA-4.0 â Y â âAttribution Share Alike â â â â4.0 â â â âââââââââââââââââââââââââââ¼ââââââââââââââââââââ¼âââââââââââââââ¤ âISC License (ISC) â ISC â Y â âââââââââââââââââââââââââââ´ââââââââââââââââââââ´âââââââââââââââ\n\nSWUPDATE: SOFTWARE UPDATE FOR EMBEDDED SYSTEM\n\nOverview This project is thought to help to update an embedded system from a storage media or from network. However, it should be mainly considered as a framework, where further protocols or installers (in SWUpdate they are called handlers) can be easily added to the application. One use case is to update from an external local media, as USB-Pen or SD-Card. In this case, the update is done without any intervention by an operator: it is thought as âone-key-updateâ, and the software is started at reset simply pressing a key (or in any way that can be recognized by the target), making all checks automatically. At the end, the updating process reports only the status to the operator (successful or failed). The output can be displayed on a LCD using the frame-buffer device or directed to a serial line (Linux console). It is generally used in the single copy approach, running in an initrd (recipes are provided to generate with Yocto). However, it is possible to use it in a double-copy approach by use of Software collections. If started for a remote update, SWUpdate starts an embedded Web-server and waits for requests. The operator must upload a suitable image, that SWUpdate checks and then install. All output is notified to the operatorâs browser via AJAX notifications. Features General Overview â¢ Install on embedded Media (eMMC, SD, Raw NAND, NOR and SPI-NOR flashes) â¢ check if an image is available. The image is built in a specified format (cpio) and it must contain a file describing the software that must be updated. â¢ SWUpdate is thought to update UBI volumes (mainly for NAND, but not only) and images on devices. Passing a whole image can still be updated as a partition on the SD card, or a MTD partition. â¢ new partition schema. This is bound with UBI volume. SWUpdate can recreate UBI volumes, resizing them and copying the new software. â¢ support for compressed images, using the zlib and zstd library. tarball (tgz file) are supported. â¢ support for partitioned USB-pen or unpartitioned (mainly used by Windows). â¢ support for updating a single file inside a filesystem. The filesystem where to put the file must be described. â¢ checksum for the single components of an image â¢ use a structured language to describe the image. This is done using the libconfig library as default parser, that uses a JSON-like description. â¢ use customâs choice for the description of the image. It is possible to write an own parser using the Lua language. An example using a XML description in Lua is provided in the examples directory. â¢ Support for setting / erasing U-Boot variables â¢ Support for setting / erasing GRUB environment block variables â¢ Support for setting / erasing EFI Boot Guard variables â¢ Support for pre and post update commands run before the update starts processing data and after the update has finished successfully. â¢ Support for lua hooks, executed before any handler runs. â¢ Support for preinstall scripts. They run after streamed handlers have handled their data, and before regular handlers. â¢ Support for postinstall scripts. They run after updating the images. â¢ Network installer using an embedded Web-server (Mongoose Server was chosen, in the version under Lua license). A different Web-server can be used. â¢ Multiple interfaces for getting software â¢ local Storage: USB, SD, UART,.. â¢ OTA / Remote â¢ integrated Web-Server â¢ pulling from remote Server (HTTP, HTTPS, ..) â¢ using a Backend. SWUpdate is open to talk with back end servers for rolling out software updates. Current version supports the hawkBit server, but other backend can be added. â¢ Can be configured to check for compatibility between software and hardware revisions. The software image must contain an entry declaring on which HW revision the software is allowed to run. SWUpdate refuses to install if the compatibility is not verified. â¢ support for image extraction. A manufacturer can require to have a single image that contains the software for more as one device. This simplifies the manufacturerâs management and reduces their administrative costs having a single software product. SWUpdate receives the software as stream without temporary storing, and extracts only the required components for the device to be installed. â¢ allow custom handlers for installing FPGA firmware, micro-controller firmware via custom protocols. â¢ Features are enabled / disabled using âmake menuconfigâ. (Kbuild is inherited from busybox project) â¢ Images are authenticated and verified before installing â¢ Power-Off safe Single image delivery The main concept is that the manufacturer delivers a single big image. All single images are packed together (cpio was chosen for its simplicity and because can be streamed) together with an additional file (sw-description), that contains meta information about each single image. The format of sw-description can be customized: SWUpdate can be configured to use its internal parser (based on libconfig), or calling an external parser in Lua. [image] Changing the rules to accept images with an external parser, let to extend to new image types and how they are installed. In fact, the scope of the parser is to retrieve which single images must be installed and how. SWUpdate implements âhandlersâ to install a single image: there are handlers to install images into UBI volumes, or to a SD card, a CFI Flash, and so on. It is then easy to add an own handler if a very special installer is required. For example we can think at a project with a main processor and one or several micro-controllers. Letâs say for simplicity that the main processor communicates with the micro-controllers via UARTS using a proprietary protocol. The software on the micro-controllers can be updated using the proprietary protocol. It is possible to extend SWUpdate writing a handler, that implements the part of the proprietary protocol to perform the upgrade on the micro-controller. The parser must recognize which image must be installed with the new handler, and SWUpdate will call the handler during the installation process. Streaming feature SWUpdate is thought to be able to stream the received image directly into the target, without any temporary copy. In fact, the single installer (handler) receive as input the file descriptor set at the beginning of the image that must be installed. The feature can be set on image basis, that means that a user can decide which partial images should be streamed. If not streamed (see installed-directly flag), files are temporary extracted into the directory pointed to by the environment variable TMPDIR with /tmp as fall-back if TMPDIR is not set. Of course, by streaming it is not possible to make checks on the whole delivered software before installing. The temporary copy is done only when updated from network. When the image is stored on an external storage, there is no need of that copy. Images fully streamed In case of remote update, SWUpdate extracts relevant images from the stream and copies them into the directory pointed to by the environment variable TMPDIR (if unset, to /tmp) before calling the handlers. This guarantee that an update is initiated only if all parts are present and correct. However, on some systems with less resources, the amount of RAM to copy the images could be not enough, for example if the filesystem on an attached SD Card must be updated. In this case, it will help if the images are installed directly as stream by the corresponding handler, without temporary copies. Not all handlers support to stream directly into the target. Streaming with zero-copy is enabled by setting the flag âinstalled-directlyâ in the description of the single image. Configuration and build Requirements There are only a few libraries that are required to compile SWUpdate. â¢ mtd-utils: internally, mtd-utils generates libmtd and libubi. They are commonly not exported and not installed, but they are linked by SWUpdate to reuse the same functions for upgrading MTD and UBI volumes. â¢ openssl / wolfssl / mbedtls (optional) for cryptographic operations â¢ p11-kit & wolfssl (optional) for PKCS#11 support â¢ Lua: liblua and the development headers. â¢ libz is always linked. â¢ libconfig (optional) for the default parser â¢ libarchive (optional) for archive handler â¢ librsync (optional) for support to apply rdiff patches â¢ libjson (optional) for JSON parser and hawkBit â¢ libubootenv (optional) if support for U-Boot is enabled â¢ libebgenv (optional) if support for EFI Boot Guard is enabled â¢ libcurl used to communicate with network New handlers can add some other libraries to the requirement list - check if you need all handlers in case you get build errors, and drop what you do not need. Building with Yocto See corresponding chapter how to build in Yocto. Configuring SWUpdate SWUpdate is configurable via âmake menuconfigâ. The small footprint is reached using the internal parser and disabling the web server. Any option has a small help describing its usage. In the default configuration, many options are already activated. To configure the options: make menuconfig Building â¢ to cross-compile, set the CC and CXX variables before running make. It is also possible to set the cross-compiler prefix as option with make menuconfig. â¢ generate the code make The result is the binary âswupdateâ. A second binary âprogressâ is built, but it is not strictly required. It is an example how to build your own interface to SWUpdate to show a progress bar or whatever you want on your HMI. The example simply prints on the console the current status of the update. In the Yocto buildsystem,: bitbake swupdate This will build the package bitbake swupdate-image This builds a rescue image. The result is a Ramdisk that can be loaded directly by the bootloader. To use SWUpdate in the double-copy mode, put the package swupdate into your rootfs. Check your image recipe, and simply add it to the list of the installed packages. For example, if we want to add it to the standard âcore-image-full-cmdlineâ image, we can add a recipes-extended/images/core-image-full-cmdline.bbappend IMAGE_INSTALL += \" \\ swupdate \\ swupdate-www \\ \" swupdate-www is the package with the website, that you can customize with your own logo, template ans style. Building a debian package SWUpdate is thought for Embedded Systems and building in an embedded distribution is the first use case. But apart the most used buildsystems for embedded as Yocto or Buildroot, in some cases a standard Linux distro is used. Not only, a distro package allows one to run SWUpdate on Linux PC for test purposes without having to fight with dependencies. Using the debhelper tools, it is possible to generate a debian package. Steps for building a debian package ./debian/rules clean ./debian/rules build fakeroot debian/rules binary The result is a âdebâ package stored in the parent directory. Alternative way signing source package You can use dpkg-buildpackage: dpkg-buildpackage -us -uc debsign -k <keyId> Running SWUpdate What is expected from a SWUpdate run The whole update process can be seen as a set of pipelines. The incoming stream (the SWU file) is processed by each pipe and passed to the next step. First, the SWU is streamed from one of the interfaces : local (USB, filesystem), Webserver, suricatta (one of the backend), etc. The incoming SWU is forwarded to the installer to be examined and installed. A run of SWUpdate consists mainly of the following steps: â¢ extracts sw-description from the stream and verifies it It parses sw-description creating a raw description in RAM about the activities that must be performed. â¢ if Signed Images is activated, extracts sw-description.sig and validate sw-description. â¢ check for hardware-software compatibility, if any, reading hardware revision from hardware and matching with the table in sw-description. â¢ Parse sw-description to determine which artefacts in the incoming SWU are required. Not required artifacts are simply skipped. If an âembedded-scriptâ is defined, it is executed at this point before parsing files. If âhooksâ are defined, they are executed as each file is parsed, even if they will be skipped. At the end of the parsing, SWUpdate builds an internal mapping for each artifact to recognize which handler should be called for each of them. â¢ runs the pre update command, if set â¢ runs partition handlers, if required. â¢ reads through the cpio archive one file at a time and either: â¢ execute handlers for each file marked as âinstalled-directlyâ. checksum is checked while the data is streamed to handler, and copy will be marked as having failed if checksum was not correct failing the rest of the install. â¢ copy other files to a temporary location while checking checksums, stopping if there was a mismatch. â¢ iterates through all scripts and call the corresponding handler for pre-install scripts. Please note: if artifacts are streamed, they will be extracted before this runs. If earlier execution is required, please use the âembedded-scriptâ or hooks features to ensure code is run before installation takes place. â¢ iterates through all images and call the corresponding handler for installing on target. â¢ iterates through all files and call the corresponding handler for installing on target. â¢ iterates through all scripts and call the corresponding handler for post-install scripts â¢ iterates through all bootenv and updates the bootloader environment. â¢ reports the status to the operator through the notification interface (logging, traces) and through the progress interface. â¢ runs the post update command, if set. The first step that fails, stops the entire procedure and an error is reported. To start SWUpdate expecting the image from a file: swupdate -i <filename> To start with the embedded web server: swupdate -w \"<web server options>\" The main important parameters for the web server are âdocument-rootâ and âportâ. swupdate -w \"--document-root ./www --port 8080\" The embedded web server is taken from the Mongoose project. The list of available options (depending on activated features) is shown with: swupdate -h This uses as website the pages delivered with the code. Of course, they can be customized and replaced. The website uses AJAX to communicate with SWUpdate, and to show the progress of the update to the operator. The default port of the Web-server is 8080. You can then connect to the target with: http://<target_ip>:8080 If it works, the start page should be displayed as in next figure. [image] If a correct image is downloaded, SWUpdate starts to process the received image. All notifications are sent back to the browser. SWUpdate provides a mechanism to send to a receiver the progress of the installation. In fact, SWUpdate takes a list of objects that registers itself with the application and they will be informed any time the application calls the notify() function. This allows also for self-written handlers to inform the upper layers about error conditions or simply return the status. It is then simply to add own receivers to implement customized way to display the results: displaying on a LCD (if the target has one), or sending back to another device via network. An example of the notifications sent back to the browser is in the next figure: [image] Software collections can be specified by passing âselect command line option. Assuming sw-description file contains a collection named stable, with alt installation location, SWUpdate can be called like this: swupdate --select stable,alt Command line parameters âââââââââââââââââââââââââââ¬ââââââââââââ¬ââââââââââââââââââââââââââââââââââââââ âParameter â Type â Description â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-f <file> â string â SWUpdate configuration â â â â file to use. See â â â â examples/configuration/swupdate.cfg â â â â in the source code for â â â â details. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-b <string> â string â Available if CONFIG_UBIATTACH is â â â â set. It allows one to blacklist â â â â MTDs when SWUpdate searches for UBI â â â â volumes. Example: U-Boot and â â â â environment in MTD0-1: swupdate -b â â â â \"0 1\". â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-B <loader> â string â Override the default bootloader â â â â interface to use loader instead. â âââââââââââââââââââââââââââ´ââââââââââââ´ââââââââââââââââââââââââââââââââââââââ â-e <sel> â string â sel is in the format â â â â <software>,<mode>. It allows one â â â â to find a subset of rules in the â â â â sw-description file. With it, â â â â multiple rules are allowed. One â â â â common usage is in case of the dual â â â â copy approach. Example: -e âstable, â â â â copy1â ==> install on copy1 -e â â â â âstable, copy2â ==> install on â â â â copy2 â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â â string â sel is in the format â â --excluded â â <software>,<mode>. It sets a â â <sel> â â blacklist of selections that cannot â â â â be used for an update. Selections â â â â can be activated not only with -e, â â â â but also via IPC. Multiple â â â â âexcluded are allowed â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-h â â Run usage with help. â â â â¢ â â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-k <file> â string â Available if CONFIG_SIGNED is set. â â â â Filename with the public key. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-K <file> â string â Available on â â â â CONFIG_ENCRYPTED_IMAGES set. â â â â Filename with the symmetric key to â â â â be used for decryption. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ ââcert-purpose <purpose> â string â Available if CONFIG_SIGNED_IMAGES â â â â is set. Set expected certificate â â â â purpose. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ ââforced-signer-name <cn> â string â Available if CONFIG_SIGNED_IMAGES â â â â is set. Set expected common name â â â â of signer certificate. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ ââca-path <file> â string â Available if CONFIG_SIGNED_IMAGES â â â â is set. Path to the Certificate â â â â Authority (PEM). â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ ââget-root â â Detect and print the root device â â â â and exit â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-l <level> â int â Set loglevel. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-L â â Send LOG output to syslog (local). â â â â¢ â â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-i <file> â string â Run SWUpdate with a local .swu â â â â file. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-n â â Run SWUpdate in dry-run mode. â â â â¢ â â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-N <version> â string â The minimum required version of â â â â software. This will be checked â â â â with the version of new software â â â â and forbids downgrading. Version â â â â consists of either 4 numbers â â â â (major.minor.rev.build with each â â â â field in the range 0..65535) or it â â â â is a semantic version. â âââââââââââââââââââââââââââ´ââââââââââââ´ââââââââââââââââââââââââââââââââââââââ â â string â The maximum required version of â â -max-version â â software. This will be checked â â <version> â â with the version of new software. â â â â Version consists of either 4 â â â â numbers (major.minor.rev.build with â â â â each field in the range 0..65535) â â â â or it is a semantic version. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-R <version> â string â The current installed version of â â â â software. This will be checked â â â â with the version of new software â â â â and forbids reinstalling. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-o <file> â string â Save the stream (SWU) to a file. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-v â â Activate verbose output. â â â â¢ â â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-M â â Disable setting the bootloader â â â â¢ â transaction marker. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-m â â Disable setting the update state in â â â â¢ â the bootloader. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-w <parms> â string â Available if CONFIG_WEBSERVER is â â â â set. Start internal webserver and â â â â pass to it a command line string. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-d <parms> â string â Available if CONFIG_DOWNLOAD is â â â â set. Start internal downloader â â â â client and pass to it a command â â â â line string. See below the â â â â internal command line arguments for â â â â the downloader. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-u <parms> â string â Available if CONFIG_SURICATTA is â â â â set. Start internal suricatta â â â â client daemon and pass to it a â â â â command line string. See below the â â â â internal command line arguments for â â â â suricatta. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-H <board:rev> â string â Available on â â â â CONFIG_HW_COMPATIBILITY set. Set â â â â board name and hardware revision. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-c â â Check *.swu file. It ensures that â â â â¢ â files referenced in sw-description â â â â are present. Usage: swupdate -c -i â â â â <file> â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-P <cmd> â string â Execute pre-update command. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-p <cmd> â string â Execute post-update command. â âââââââââââââââââââââââââââ¼ââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ¤ â-q <sel> â string â â â â â List for software images set â â â â and source â â â â that are accepted via â â â â IPC Ex.: stable,main â â â â it can be set â â â â multiple times â âââââââââââââââââââââââââââ´ââââââââââââ´ââââââââââââââââââââââââââââââââââââââ Downloader command line parameters Example: swupdate -d \"-u example.com\" Mandatory arguments are marked with â*â: âââââââââââââââââ¬ââââââââââ¬âââââââââââââââââââââââââââ âParameter â Type â Description â âââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â-u <url> â string â * This is the URL where â â â â new software is pulled. â â â â URL is a link to a valid â â â â .swu image â âââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â-r <retries> â integer â Number of retries before â â â â a download is considered â â â â broken. With â-r 0â, â â â â SWUpdate will not stop â â â â until a valid software â â â â is loaded. â âââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â-w <retrywait> â integer â Time to wait prior to â â â â retry and resume a â â â â download (default: 5s). â âââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â-t <timeout> â integer â Timeout for connection â â â â lost downloader or â â â â Webserver â âââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â-a <usr:pwd> â string â Send user and password â â â â for Basic Auth â âââââââââââââââââ´ââââââââââ´âââââââââââââââââââââââââââ Suricatta command line parameters Example: swupdate -u \"-t default -u localhost:8080 -i 1B7\" Note that different suricatta modules may have different parameters. The below listed options are for SWUpdateâs hawkBit support. Mandatory arguments are marked with â*â: âââââââââââââââââââââââââ¬ââââââââââââ¬âââââââââââââââââââââââââââ âParameter â Type â Description â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-t <tenant> â string â * Set hawkBit tenant ID â â â â for this device. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-u <url> â string â * Host and port of the â â â â hawkBit instance, e.g., â â â â localhost:8080 â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-i <id> â integer â * The device ID to â â â â communicate to hawkBit. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-c <confirm> â integer â Confirm update status to â â â â server: 1=AGAIN, â â â â 2=SUCCESS, 3=FAILED â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-x â â Do not abort on flawed â â â â¢ â server certificates. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-p <polldelay> â integer â Delay in seconds between â â â â two hawkBit poll â â â â operations (default: â â â â 45s). â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-r <retry> â integer â Resume and retry â â â â interrupted downloads â â â â (default: 5 tries). â âââââââââââââââââââââââââ´ââââââââââââ´âââââââââââââââââââââââââââ â-w <retrywait> â integer â Time to wait prior to â â â â retry and resume a â â â â download (default: 5s). â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-y <proxy> â string â Use proxy. Either give â â â â proxy URL, else â â â â {http,all}_proxy env is â â â â tried. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-k <targettoken> â string â Set target token. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-g <gatewaytoken> â string â Set gateway token. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-f <interface> â string â Set the network â â â â interface to connect to â â â â hawkBit. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-e â â Daemon enabled at â â â â¢ â startup (default). â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-d â â Daemon disabled at â â â â¢ â startup. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ ââdisable-token-for-dwl â â Do not send â â â â¢ â authentication header â â â â when downloading SWU. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ ââcache-file â string â This allows one to â â â â resume an update after a â â â â power cut. If the SWU is â â â â saved in a file, â â â â SWUpdate can reuse the â â â â file and download just â â â â the remaining part of â â â â the SWU. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-m <seconds> â integer â Delay in seconds between â â â â re-trying to send â â â â initial feedback â â â â specified with â-câ â â â â option. Default value is â â â â 10 seconds. If Suricatta â â â â is started with initial â â â â state of STATE_WAIT (â-c â â â â 6â), this value is â â â â ignored. â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-s <seconds> â integer â Connection timeout to â â â â use in seconds. If user â â â â doesnât set this option, â â â â default libcurl â â â â connection timeout value â â â â of 300 seconds is used. â â â â NOTE: it is not possible â â â â for Suricatta to respond â â â â to external program API â â â â requests during this â â â â period - adapt this â â â â value to your use case! â âââââââââââââââââââââââââ¼ââââââââââââ¼âââââââââââââââââââââââââââ¤ â-a <name> <value> â strings â Custom HTTP header with â â â â given name and value to â â â â be sent with every HTTP â â â â request made. â âââââââââââââââââââââââââ´ââââââââââââ´âââââââââââââââââââââââââââ â-n <value> â string â Maximum download speed â â â â to be used. Value be â â â â specified in kB/s, B/s, â â â â MB/s or GB/s. Examples: â â â â -n 100k : Set limit to â â â â 100 kB/s. -n 500 : Set â â â â limit to 500 B/s. -n 2M â â â â : Set limit to 1 M/s. â â â â -n 1G : Set limit to 1 â â â â G/s. â âââââââââââââââââââââââââ´ââââââââââââ´âââââââââââââââââââââââââââ Webserver command line parameters Example: swupdate -w \"-r /www -p 8080\" Mandatory arguments are marked with â*â: ââââââââââââââââââââââââââââ¬ââââââââââ¬âââââââââââââââââââââââââââ âParameter â Type â Description â ââââââââââââââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â-r <document root> â string â * Path where the web app â â â â is stored. â ââââââââââââââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â-p <port> â integer â * TCP port to be â â â â listened if not set, â â â â 8080 is used â ââââââââââââââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â-s <ssl> â â * Enable SSL support. â â â â Note: it must be â â â â configured with â â â â CONFIG_MONGOOSESSL â ââââââââââââââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ ââssl-cert <cert> â string â Path to the certificate â â â â to present to clients â ââââââââââââââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â-K <key> â string â Path to key â â â â corresponding to ssl â â â â certificate â ââââââââââââââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â-t <timeout> â integer â Timeout to consider a â â â â connection lost if â â â â clients stops to send â â â â data. If hit, an update â â â â is aborted. Default=0 â â â â (unlimited) â ââââââââââââââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ ââauth-domain <string> â string â Set authentication â â â â domain Default: none â ââââââââââââââââââââââââââââ¼ââââââââââ¼âââââââââââââââââââââââââââ¤ â â string â Set authentication file â â --global-auth-file â â if any Default: none â â <string> â â â ââââââââââââââââââââââââââââ´ââââââââââ´âââââââââââââââââââââââââââ systemd Integration SWUpdate has optional systemd support via the compile-time configuration switch CONFIG_SYSTEMD. If enabled, SWUpdate signals systemd about start-up completion and can make optional use of systemdâs socket-based activation feature. A sample systemd service unit file /etc/systemd/system/swupdate.service may look like the following starting SWUpdate in suricatta daemon mode: [Unit] Description=SWUpdate daemon Documentation=https://github.com/sbabic/swupdate Documentation=https://sbabic.github.io/swupdate [Service] Type=notify RuntimeDirectory=swupdate RuntimeDirectoryPreserve=yes ExecStart=/usr/bin/swupdate -u '-t default -u http://localhost -i 25' [Install] WantedBy=multi-user.target Started via systemctl start swupdate.service, SWUpdate (re)creates its sockets on startup. For using socket-based activation, an accompanying systemd socket unit file /etc/systemd/system/swupdate.socket is required: [Unit] Description=SWUpdate socket listener Documentation=https://github.com/sbabic/swupdate Documentation=https://sbabic.github.io/swupdate [Socket] ListenStream=/run/swupdate/sockinstctrl ListenStream=/run/swupdate/swupdateprog [Install] WantedBy=sockets.target On swupdate.socket being started, systemd creates the socket files and hands them over to SWUpdate when it starts. So, for example, when talking to /run/swupdate/swupdateprog, systemd starts swupdate.service and hands-over the socket files. The socket files are also handed over on a âregularâ start of SWUpdate via systemctl start swupdate.service. Note, that all dependent services need to access the swupdate sockets via the paths specified in the swupdate.socket systemd unit. Changes in boot-loader code The SWUpdate consists of kernel and a root filesystem (image) that must be started by the boot-loader. In case using U-Boot, the following mechanism can be implemented: â¢ U-Boot checks if a sw update is required (check gpio, serial console, etc.). â¢ the script âaltbootcmdâ sets the rules to start SWUpdate â¢ in case SWUpdate is required, U-boot run the script âaltbootcmdâ Is it safe to change U-Boot environment ? Well, it is, but U-Boot must be configured correctly. U-Boot supports two copies of the environment to be power-off safe during an environment update. The boardâs configuration file must have defined CONFIG_ENV_OFFSET_REDUND or CONFIG_ENV_ADDR_REDUND. Check in U-Boot documentation for these constants and how to use them. There are a further enhancement that can be optionally integrated into U-boot to make the system safer. The most important I will suggest is to add support for boot counter in U-boot (documentation is in U-Boot docs). This allows U-Boot to track for attempts to successfully run the application, and if the boot counter is greater as a limit, can start automatically SWUpdate to replace a corrupt software. GRUB by default does not support double copies of environment as in case of U-Boot. This means that there is possibility that environment block getâs corrupted when power-off occurs during environment update. To minimize the risk, we are not modifying original environment block. Variables are written into temporary file and after successful operation rename instruction is called. Building a single image cpio is used as container for its simplicity. The resulting image is very simple to be built. The file describing the images (âsw-descriptionâ, but the name can be configured) must be the first file in the cpio archive. To produce an image, a script like this can be used: CONTAINER_VER=\"1.0\" PRODUCT_NAME=\"my-software\" FILES=\"sw-description image1.ubifs \\ image2.gz.u-boot uImage.bin myfile sdcard.img\" for i in $FILES;do echo $i;done | cpio -ov -H crc > ${PRODUCT_NAME}_${CONTAINER_VER}.swu The single images can be put in any order inside the cpio container, with the exception of sw-description, that must be the first one. To check your generated image you can run the following command: swupdate -c -i my-software_1.0.swu Support of compound image The single image can be built automatically inside Yocto. meta-swupdate extends the classes with the swupdate class. A recipe should inherit it, and add your own sw-description file to generate the image.\n\nUPDATE STRATEGY EXAMPLES\n\nSWUpdate is a building block and it allows one to design and implementing its own update strategy. Even if many projects have common ways for updating, it is possible to high customize the update for each project. The most common strategies (single-copy and dual-copy) were already described at the beginning of this documentation and of course are well supported in SWUpdate. Single copy - running as standalone image See Single copy - running as standalone image. Double copy with fall-back See Double copy with fall-back. Combine double-copy with rescue system This provides a recovery procedure to cover update failure in severe cases when software is damaged. In case none of the copy can be started, the bootloader will start the rescue system (possibly stored on another storage as the main system) to try to rescue the board. [image] The rescue system can be updated as well during a standard update. Split system update with application update Updating a whole image is quite straightforward, but this means to transfer bigger amount of data if just a few files are updated. It is possible to split theupdate in several smaller parts to reduce the transfer size. This requires a special care to take care of compatibility between system and application, that can be solved with customized Lua scripts in the sw-description file. SWUpdate supports versioning for each artefact, and anyone can add own rules to verify compatibility between components. [image] Configuration update Thought to update the software, SWUpdate can be used to install configuration data as well. Build system can create configuration SWU with files / data for the configuration of the system. There is no requirements what these SWU should contains - it is duty of the integrator to build them and make them suitable for his own project. Again, configuration data can be updated as separate process using one of the above scenarios.\n\nSWUPDATE: SYNTAX AND TAGS WITH THE DEFAULT PARSER\n\nIntroduction SWUpdate uses the library âlibconfigâ as default parser for the image description. However, it is possible to extend SWUpdate and add an own parser, based on a different syntax and language as the one supported by libconfig. In the examples directory there is the code for a parser written in Lua, with the description in XML. Using the default parser, sw-description follows the syntax rules described in the libconfig manual. Please take a look at http://www.hyperrealm.com/libconfig/libconfig_manual.html for an explanation of basic types. The whole description must be contained in the sw-description file itself: using of the #include directive is not allowed by SWUpdate. The following example explains the implemented tags: software = { version = \"0.1.0\"; description = \"Firmware update for XXXXX Project\"; hardware-compatibility: [ \"1.0\", \"1.2\", \"1.3\"]; /* partitions tag is used to resize UBI partitions */ partitions: ( /* UBI Volumes */ { name = \"rootfs\"; device = \"mtd4\"; size = 104896512; /* in bytes */ }, { name = \"data\"; device = \"mtd5\"; size = 50448384; /* in bytes */ } ); images: ( { filename = \"rootfs.ubifs\"; volume = \"rootfs\"; }, { filename = \"swupdate.ext3.gz.u-boot\"; volume = \"fs_recovery\"; }, { filename = \"sdcard.ext3.gz\"; device = \"/dev/mmcblk0p1\"; compressed = \"zlib\"; }, { filename = \"bootlogo.bmp\"; volume = \"splash\"; }, { filename = \"uImage.bin\"; volume = \"kernel\"; }, { filename = \"fpga.txt\"; type = \"fpga\"; }, { filename = \"bootloader-env\"; type = \"bootloader\"; } ); files: ( { filename = \"README\"; path = \"/README\"; device = \"/dev/mmcblk0p1\"; filesystem = \"vfat\" } ); scripts: ( { filename = \"erase_at_end\"; type = \"lua\"; }, { filename = \"display_info\"; type = \"lua\"; } ); bootenv: ( { name = \"vram\"; value = \"4M\"; }, { name = \"addfb\"; value = \"setenv bootargs ${bootargs} omapfb.vram=1:2M,2:2M,3:2M omapdss.def_disp=lcd\" } ); } The first tag is âsoftwareâ. The whole description is contained in this tag. It is possible to group settings per device by using Board specific settings. Handling configuration differences The concept can be extended to deliver a single image containing the release for multiple devices. Each device has its own kernel, dtb, and root filesystem, or they can share some parts. Currently this is managed (and already used in a real project) by writing an own parser, that checks which images must be installed after recognizing which is the device where software is running. Because the external parser can be written in Lua and it is completely customizable, everybody can set his own rules. For this specific example, the sw-description is written in XML format, with tags identifying the images for each device. To run it, the liblxp library is needed. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <software version=\"1.0\"> <name>Update Image</name> <version>1.0.0</version> <description>Firmware for XXXXX Project</description> <images> <image device=\"firstdevice\" version=\"0.9\"> <stream name=\"dev1-uImage\" type=\"ubivol\" volume=\"kernel\" /> <stream name=\"dev1.dtb\" type=\"ubivol\" volume=\"dtb\" /> <stream name=\"dev1-rootfs.ubifs\" type=\"ubivol\" volume=\"rootfs\"/> <stream name=\"dev1-uboot-env\" type=\"uboot\" /> <stream name=\"raw_vfat\" type=\"raw\" dest=\"/dev/mmcblk0p4\" /> <stream name=\"sdcard.lua\" type=\"lua\" /> </image> <image device=\"seconddevice\" version=\"0.9\"> <stream name=\"dev2-uImage\" type=\"ubivol\" volume=\"kernel\" /> <stream name=\"dev2.dtb\" rev=\"0.9\" type=\"ubivol\" volume=\"dtb\" /> <stream name=\"dev2-rootfs.ubifs\" type=\"ubivol\" volume=\"rootfs\"/> </image> </images> </software> The parser for this is in the /examples directory. By identifying which is the running device, the parser return a table containing the images that must be installed and their associated handlers. By reading the delivered image, SWUpdate will ignore all images that are not in the list processed by the parser. In this way, it is possible to have a single delivered image for the update of multiple devices. Multiple devices are supported by the default parser, too. software = { version = \"0.1.0\"; target-1 = { images: ( { ... } ); }; target-2 = { images: ( { ... } ); }; } In this way, it is possible to have a single image providing software for each device you have. By default, the hardware information is extracted from /etc/hwrevision file. The file should contain a single line in the following format: <boardname> <revision> Where: â¢ <revision> will be used for matching with hardware compatibility list â¢ <boardname> can be used for grouping board specific settings Software collections Software collections and operation modes can be used to implement a dual copy strategy. The simplest case is to define two installation locations for the firmware image and call SWUpdate selecting the appropriate image. software = { version = \"0.1.0\"; stable = { copy-1: { images: ( { device = \"/dev/mtd4\" ... } ); } copy-2: { images: ( { device = \"/dev/mtd5\" ... } ); } }; } In this way it is possible to specify that copy-1 gets installed to /dev/mtd4, while copy-2 to /dev/mtd5. By properly selecting the installation locations, SWUpdate will update the firmware in the other slot. The method of image selection is out of the scope of SWUpdate and user is responsible for calling SWUpdate passing proper settings. Priority finding the elements in the file SWUpdate search for entries in the sw-description file according to the following priority: 1. Try <boardname>.<selection>.<mode>.<entry> 2. Try <selection>.<mode>.<entry> 3. Try <boardname>.<entry> 4. Try <entry> Take an example. The following sw-description describes the release for a set of boards. software = { version = \"0.1.0\"; myboard = { stable = { copy-1: { images: ( { device = \"/dev/mtd4\" ... } ); } copy-2: { images: ( { device = \"/dev/mtd5\" ... } ); } } } stable = { copy-1: { images: ( { device = \"/dev/mtd6\" ... } ); } copy-2: { images: ( { device = \"/dev/mtd7\" ... } ); } } } On myboard, SWUpdate searches and finds myboard.stable.copy1(2). When running on different boards, SWUpdate does not find an entry corresponding to the boardname and it falls back to the version without boardname. This allows to realize the same release for different boards having a completely different hardware. myboard could have an eMMC and an ext4 filesystem, while another device can have raw flash and install an UBI filesystem. Nevertheless, they are both just a different format of the same release and they could be described together in sw-description. It is important to understand the priorities how SWUpdate scans for entries during the parsing. Using links sw-description can become very complex. Letâs think to have just one board, but in multiple hw revision and they differ in Hardware. Some of them can be grouped together, some of them require a dedicated section. A way (but not the only one !) could be to add mode and selects the section with -e stable,<rev number>. software = { version = \"0.1.0\"; myboard = { stable = { hardware-compatibility: [\"1.0\", \"1.2\", \"2.0\", \"1.3\", \"3.0\", \"3.1\"]; rev-1.0: { images: ( ... ); scripts: ( ... ); } rev-1.2: { hardware-compatibility: [\"1.2\"]; images: ( ... ); scripts: ( ... ); } rev-2.0: { hardware-compatibility: [\"2.0\"]; images: ( ... ); scripts: ( ... ); } rev-1.3: { hardware-compatibility: [\"1.3\"]; images: ( ... ); scripts: ( ... ); } rev-3.0: { hardware-compatibility: [\"3.0\"]; images: ( ... ); scripts: ( ... ); } rev-3.1: { hardware-compatibility: [\"3.1\"]; images: ( ... ); scripts: ( ... ); } } } } If each of them requires an own section, it is the way to do. Anyway, it is more probable than revisions can be grouped together, for example board with the same major revision number could have the same installation instructions. This leads in the example to 3 groups for rev1.X, rev2.X, and rev3.X. Links allow one to group section together. When a ârefâ is found when SWUpdate searches for a group (images, files, script, bootenv), it replaces the current path in the tree with the value of the string. In this way, the example above can be written in this way: software = { version = \"0.1.0\"; myboard = { stable = { hardware-compatibility: [\"1.0\", \"1.2\", \"2.0\", \"1.3\", \"3.0\", \"3.1\"]; rev-1x: { images: ( ... ); scripts: ( ... ); } rev1.0 = { ref = \"#./rev-1x\"; } rev1.2 = { ref = \"#./rev-1x\"; } rev1.3 = { ref = \"#./rev-1x\"; } rev-2x: { images: ( ... ); scripts: ( ... ); } rev2.0 = { ref = \"#./rev-2x\"; } rev-3x: { images: ( ... ); scripts: ( ... ); } rev3.0 = { ref = \"#./rev-3x\"; } rev3.1 = { ref = \"#./rev-3x\"; } } } } The link can be absolute or relative. The keyword ârefâ is used to indicate a link. If this is found, SWUpdate will traverse the tree and replaces the current path with the values find in the string pointed by ârefâ. There are simple rules for a link: â¢ it must start with the character â#â â¢ â.â points to the current level in the tree, that means the parent of ârefâ â¢ â..â points to the parent level in the tree â¢ â/â is used as filed separator in the link A relative path has a number of leading â../â to move the current cursor to the parent leaf of the tree. In the following example, rev40 sets a link to a âcommonâ section, where images is found. This is sets via a link, too, to a section in the parent node. The path software.myboard.stable.common.images is then replaced by software.myboard.stable.trythis software = { version = { ref = \"#./commonversion\"; } hardware-compatibility = [\"rev10\", \"rev11\", \"rev20\"]; commonversion = \"0.7-linked\"; pc:{ stable:{ common:{ images = { ref = \"#./../trythis\"; } }; trythis:( { filename = \"rootfs1.ext4\"; device = \"/dev/mmcblk0p8\"; type = \"raw\"; } , { filename = \"rootfs5.ext4\"; device = \"/dev/mmcblk0p7\"; type = \"raw\"; } ); pdm3rev10: { images:( { filename = \"rootfs.ext3\"; device = \"/dev/mmcblk0p2\";} ); uboot:( { name = \"bootpart\"; value = \"0:2\";} ); }; pdm3rev11 = { ref = \"#./pdm3rev10\"; } pdm3rev20 = { ref = \"#./pdm3rev10\"; } pdm3rev40 = { ref = \"#./common\"; } }; }; } Each entry in sw-description can be redirect by a link as in the above example for the âversionâ attribute. hardware-compatibility hardware-compatibility: [ \"major.minor\", \"major.minor\", ... ] This entry lists the hardware revisions that are compatible with this software image. Example: hardware-compatibility: [ \"1.0\", \"1.2\", \"1.3\"]; This defines that the software is compatible with HW-Revisions 1.0, 1.2, and 1.3, but not with 1.1 or any other version not explicitly listed here. In the above example, compatibility is checked by means of string comparison. If the software is compatible with a large number of hardware revisions, it may get cumbersome to enumerate all compatible versions. To allow more compact specifications, regular expressions (POSIX extended) can be used by adding a prefix #RE: to the entry. Rewriting the above example would yield: hardware-compatibility: [ \"#RE:^1\\.[023]$\" ]; It is in the responsibility of the respective project to find the revision of the board on which SWUpdate is running. No assumptions are made about how the revision can be obtained (GPIOs, EEPROM,..) and each project is free to select the most appropriate way. In the end the result must be written to the file /etc/hwrevision (or in another file if specified as configuration option) before SWUpdate is started. partitions : UBI layout This tag allows one to change the layout of UBI volumes. Please take care that MTDs are not touched and they are configured by the Device Tree or in another way directly in kernel. partitions: ( { name = <volume name>; size = <size in bytes>; device = <MTD device>; } ); All fields are mandatory. SWUpdate searches for a volume of the given name and if necessary adjusts size or type (see below). If no volume with the given name is found, a new volume is created on the UBI device attached to the MTD device given by device. device can be specified by number (e.g. âmtd4â) or by name (the name of the MTD device, e.g. âubi_partitionâ). The UBI device is attached automatically. The default behavior of swupdate is to create a dynamic UBI volume. To create a static volume, add a line data = \"static\"; to the respective partition entry. If a size of 0 is given, the volume will be deleted if it exists. This can be used to remove orphan volumes possibly created by older software versions which are not required anymore. images The tag âimagesâ collects the image that are installed to the system. The syntax is: images: ( { filename[mandatory] = <Name in CPIO Archive>; volume[optional] = <destination volume>; device[optional] = <destination volume>; mtdname[optional] = <destination mtd name>; type[optional] = <handler>; /* optionally, the image can be copied at a specific offset */ offset[optional] = <offset>; /* optionally, the image can be compressed if it is in raw mode */ compressed; }, /* Next Image */ ..... ); volume is only used to install the image in a UBI volume. volume and device cannot be used at the same time. If device is set, the raw handler is automatically selected. The following example is to update a UBI volume: { filename = \"core-image-base.ubifs\"; volume = \"rootfs\"; } To update an image in raw mode, the syntax is: { filename = \"core-image-base.ext3\"; device = \"/dev/mmcblk0p1\"; } To flash an image at a specific offset, the syntax is: { filename = \"u-boot.bin\"; device = \"/dev/mmcblk0p1\"; offset = \"16K\"; } The offset handles the following multiplicative suffixes: K=1024 and M=1024*1024. However, writing to flash in raw mode must be managed in a special way. Flashes must be erased before copying, and writing into NAND must take care of bad blocks and ECC errors. For these reasons, the handler âflashâ must be selected: For example, to copy the kernel into the MTD7 of a NAND flash: { filename = \"uImage\"; device = \"mtd7\"; type = \"flash\"; } The filename is mandatory. It is the Name of the file extracted by the stream. volume is only mandatory in case of UBI volumes. It should be not used in other cases. Alternatively, for the handler âflashâ, the mtdname can be specified, instead of the device name: { filename = \"uImage\"; mtdname = \"kernel\"; type = \"flash\"; } Files It is possible to copy single files instead of images. This is not the preferred way, but it can be used for debugging or special purposes. files: ( { filename = <Name in CPIO Archive>; path = <path in filesystem>; device[optional] = <device node >; filesystem[optional] = <filesystem for mount>; properties[optional] = {create-destination = \"true\";} } ); Entries in âfilesâ section are managed as single files. The attributes âfilenameâ and âpathâ are mandatory. Attributes âdeviceâ and âfilesystemâ are optional; they tell SWUpdate to mount device (of the given filesystem type, e.g. âext4â) before copying âfilenameâ to âpathâ. Without âdeviceâ and âfilesystemâ, the âfilenameâ will be copied to âpathâ in the current rootfs. As a general rule, swupdate doesnât copy out a file if the destination path doesnât exists. This behavior could be changed using the special property âcreate-destinationâ. As another general rule, the raw file handler installs the file directly to the specified path. If the target file already exists and the raw file handler is interrupted, the existing file may be replaced by an empty or partially written file. A use case can exist where having an empty or corrupted file is worse than the existing file. For this reason, the raw file handler supports an âatomic-installâ property. Setting the property to âtrueâ installs the file to the specified path with â.tmpâ appended to the filename. Once the contents of the file have been written and the buffer is flushed, the â.tmpâ file is renamed to the target file. This minimizes chances that an empty or corrupted file is created by an interrupted raw file handler. Scripts Scripts runs in the order they are put into the sw-description file. The result of a script is valuated by SWUpdate, that stops the update with an error if the result is <> 0. They are copied into a temporary directory before execution and their name must be unique inside the same cpio archive. If no type is given, SWUpdate default to âluaâ. Lua scripts: ( { filename = <Name in CPIO Archive>; type = \"lua\"; } ); Lua scripts are run using the internal interpreter. They must have at least one of the following functions: function preinst() SWUpdate scans for all scripts and check for a preinst function. It is called before installing the images. function postinst() SWUpdate scans for all scripts and check for a postinst function. It is called after installing the images. shellscript scripts: ( { filename = <Name in CPIO Archive>; type = \"shellscript\"; } ); Shell scripts are called via system command. SWUpdate scans for all scripts and calls them before and after installing the images. SWUpdate passes âpreinstâ or âpostinstâ as first argument to the script. If the data attribute is defined, its value is passed as the last argument(s) to the script. preinstall scripts: ( { filename = <Name in CPIO Archive>; type = \"preinstall\"; } ); preinstall are shell scripts and called via system command. SWUpdate scans for all scripts and calls them before installing the images. If the data attribute is defined, its value is passed as the last argument(s) to the script. postinstall scripts: ( { filename = <Name in CPIO Archive>; type = \"postinstall\"; } ); postinstall are shell scripts and called via system command. SWUpdate scans for all scripts and calls them after installing the images. If the data attribute is defined, its value is passed as the last argument(s) to the script. Update Transaction and Status Marker By default, SWUpdate sets the bootloader environment variable ârecovery_statusâ to âin_progressâ prior to an update operation and either unsets it or sets it to âfailedâ after the update operation. This is an interface for SWUpdate-external tooling: If there is no ârecovery_statusâ variable in the bootloaderâs environment, the update operation has been successful. Else, if there is a ârecovery_statusâ variable with the value âfailedâ, the update operation has not been successful. While this is in general essential behavior for firmware updates, it neednât be for less critical update operations. Hence, whether or not the update transaction marker is set by SWUpdate can be controlled by the boolean switch âbootloader_transaction_markerâ which is global per sw-description file. It defaults to true. The following example snippet disables the update transaction marker: software = { version = \"0.1.0\"; bootloader_transaction_marker = false; ... It is also possible to disable setting of the transaction marker entirely (and independently of the setting in sw-description) by starting SWUpdate with the -M option. The same applies to setting the update state in the bootloader via its environment variable âustateâ (default) to STATE_INSTALLED=1 or STATE_FAILED=3 after an installation. This behavior can be turned off globally via the -m option to SWUpdate or per sw-description via the boolean switch âbootloader_state_markerâ. reboot flag It is possible to signal that a reboot for a specific update is not required. This information is evaluated by SWUpdate just to inform a backend about the transaction result. If a postinstall script (icommand line parameter -p) is passed at the startup to perform a reboot, it will be executed anyway because SWUpdate cannot know the nature of this script. SWUpdate sends this information to the progress interface and it is duty of the listeners to interprete the information. The attribute is a boolean: reboot = false; Attribute belongs to the general section, where also version belongs. It is not required to activate the flag with reboot = true because it is the default behavior, so just disabling makes sense. The tool swupdate-progress interprets the flag: if it was started with reboot support (-r parameter), it checks if a âno-rebootâ message is received and disables to reboot the device for this specific update. When the transaction completes, the reboot feature is activated again in case a new update will require to reboot the device. This allows to have on the fly updates, where not the whole software is updated and a reboot is not required. bootloader There are two ways to update the bootloader (currently U-Boot, GRUB, and EFI Boot Guard) environment. First way is to add a file with the list of variables to be changed and setting âbootloaderâ as type of the image. This informs SWUpdate to call the bootloader handler to manage the file (requires enabling bootloader handler in configuration). There is one bootloader handler for all supported bootloaders. The appropriate bootloader must be chosen from the bootloader selection menu in menuconfig. images: ( { filename = \"bootloader-env\"; type = \"bootloader\"; } ) The format of the file is described in U-boot documentation. Each line is in the format <name of variable>=<value> if value is missing, the variable is unset. The format is compatible with U-Boot âenv importâ command. It is possible to produce the file from target as result of âenv exportâ. Comments are allowed in the file to improve readability, see this example: # Default variables bootslot=0 board_name=myboard baudrate=115200 ## Board Revision dependent board_revision=1.0 The second way is to define in a group setting the variables that must be changed: bootenv: ( { name = <Variable name>; value = <Variable value>; } ) SWUpdate will internally generate a script that will be passed to the bootloader handler for adjusting the environment. For backward compatibility with previously built .swu images, the âubootâ group name is still supported as an alias. However, its usage is deprecated. SWUpdate persistent variables Not all updates require to inform the bootloader about the update, and in many cases a reboot is not required. There are also cases where changing bootloaderâs environment is unwanted due to restriction for security. SWUpdate needs then some information after new software is running to understand if everything is fine or some actions like a fallback are needed. SWUpdate can store such as information in variables (like shell variables), that can be stored persistently. The library libubootenv provide a way for saving such kind as database in a power-cut safe mode. It uses the algorythm originally implemented in the U-Boot bootloader. It is then guaranteed that the system will always have a valid instance of the environment. The library supports multiple environment databases at the same time, identifies with namespaces. SWUpdate should be configured to set the namespace used for own variables. This is done by setting the attribute namespace-vars in the runtime configuration file (swupdate.cfg). See also example/configuration/swupdate.cfg for details. The format is the same used with bootloader for single variable: vars: ( { name = <Variable name>; value = <Variable value>; } ) SWUpdate will set these variables all at once like the bootloader variables. These environment is stored just before writing the bootloader environment, that is always the last step in an update. Board specific settings Each setting can be placed under a custom tag matching the board name. This mechanism can be used to override particular setting in board specific fashion. Assuming that the hardware information file /etc/hwrevision contains the following entry: my-board 0.1.0 and the following description: software = { version = \"0.1.0\"; my-board = { bootenv: ( { name = \"bootpart\"; value = \"0:2\"; } ); }; bootenv: ( { name = \"bootpart\"; value = \"0:1\"; } ); } SWUpdate will set bootpart to 0:2 in bootloaderâs environment for this board. For all other boards, bootpart will be set to 0:1. Board specific settings take precedence over default scoped settings. Software collections and operation modes Software collections and operations modes extend the description file syntax to provide an overlay grouping all previous configuration tags. The mechanism is similar to Board specific settings and can be used for implementing a dual copy strategy or delivering both stable and unstable images within a single update file. The mechanism uses a custom user-defined tags placed within software scope. The tag names must not be any of: version, hardware-compatibility, uboot, bootenv, files, scripts, partitions, images An example description file: software = { version = \"0.1\"; hardware-compatibility = [ \"revA\" ]; /* differentiate running image modes/sets */ stable: { main: { images: ( { filename = \"rootfs.ext3\"; device = \"/dev/mmcblk0p2\"; } ); bootenv: ( { name = \"bootpart\"; value = \"0:2\"; } ); }; alt: { images: ( { filename = \"rootfs.ext3\"; device = \"/dev/mmcblk0p1\"; } ); bootenv: ( { name = \"bootpart\"; value = \"0:1\"; } ); }; }; } The configuration describes a single software collection named stable. Two distinct image locations are specified for this collection: /dev/mmcblk0p1 and /dev/mmcblk0p2 for main mode and alt mode respectively. This feature can be used to implement a dual copy strategy by specifying the collection and mode explicitly. Versioning schemas in SWUpdate SWUpdate can perform version comparisons for the whole Software by checking the version attribute in the common part of sw-description and / or for single artifacts. SWUpdate supports two different version schemas, and they must be followed if version comparison is requested. Numbering schema (default) SWUpdate supports a version based on the schema: <major>.<minor>.<revision>.<build> where each field is a plain number (no alphanumeric) in the range 0..65535. User can add further fields using the dot separator, but they are not considered for version comparison. SWUpdate will check if a version number is set according to this rule and fall back to semantic version upon failure. The version is converted to a 64 bit number (each field is 16 bit) and compared against the running version of the same artifact. Please consider that, because additional fields are descriptive only, for the comparison they are not considered. This example contains version numbers that are interpreted as the same version number by SWUpdate: 1.2.3.4 1.2.3.4.5 1.2.3.4.5.6 But the following is different: 1.2.3.4-alpha And it is treated as semantic version. Semantic version SWUpdate supports semantic version. See official documentation for more details. Checking version of installed software SWUpdate can optionally verify if a sub-image is already installed and, if the version to be installed is exactly the same, it can skip to install it. This is very useful in case some high risky image should be installed or to speed up the upgrade process. One case is if the bootloader needs to be updated. In most time, there is no need to upgrade the bootloader, but practice showed that there are some cases where an upgrade is strictly required - the project manager should take the risk. However, it is nicer to have always the bootloader image as part of the .swu file, allowing to get the whole distro for the device in a single file, but the device should install it just when needed. SWUpdate searches for a file (/etc/sw-versions is the default location) containing all versions of the installed images. This must be generated before running SWUpdate. The file must contain pairs with the name of image and version, as: <name of component> <version> In sw-description, the optional attributes ânameâ, âversionâ, and âinstall-if-differentâ provide the connection. Name and version are then compared with the data in the versions file. install-if-different is a boolean that enables the check for this image. It is then possible to check the version just for a subset of the images to be installed. If used with âinstall-if-differentâ, then version can be any string. For example: bootloader 2015.01-rc3-00456-gd4978d kernel 3.17.0-00215-g2e876af There is also an attribute âinstall-if-higherâ that checks if the version of the new software is higher than the version of the installed software. If itâs false, the new software isnât installed. The goal is to avoid installing an older version of software. In this case, version can be any of 2 formats. Either the version consists of up to 4 numbers in the range 0..65535 separated by a dot, e.g. <major>.<minor>.<rev>.<build>, or it is a semantic version. bootloader 2018.03.01 kernel 3.17.0-pre1+g2e876af rfs 0.17-foo3.bar5+2020.07.01 app 1.7 It is advised not to mix version formats! Semantic versions only support 3 numbers (major, minor, patch) and the fourth number will be silently dropped if present. Embedded Script It is possible to embed a script inside sw-description. This is useful in a lot of conditions where some parameters are known just by the target at runtime. The script is global to all sections, but it can contain several functions that can be specific for each entry in the sw-description file. These attributes are used for an embedded-script: embedded-script = \"<Lua code>\" It must be taken into account that the parser has already run and usage of double quotes can interfere with the parser. For this reason, each double quote in the script must be escaped. That means a simple Lua code as: print (\"Test\") must be changed to: print (\\\"Test\\\") If not, the parser thinks to have the closure of the script and this generates an error. See the examples directory for examples how to use it. Any entry in files or images can trigger one function in the script. The âhookâ attribute tells the parser to load the script and to search for the function pointed to by the hook attribute. For example: files: ( { filename = \"examples.tar\"; type = \"archive\"; path = \"/tmp/test\"; hook = \"set_version\"; preserve-attributes = true; } ); After the entry is parsed, the parser runs the Lua function pointed to by hook. If Lua is not activated, the parser raises an error because a sw-description with an embedded script must be parsed, but the interpreter is not available. Each Lua function receives as parameter a table with the setup for the current entry. A hook in Lua is in the format: function lua_hook(image) image is a table where the keys are the list of available attributes. If an attribute contains a â-â, it is replaced with â_â, because â-â cannot be used in Lua. This means, for example, that: install-if-different ==> install_if_different installed-directly ==> installed_directly Attributes can be changed in the Lua script and values are taken over on return. The Lua function must return 2 values: â¢ a boolean, to indicate whether the parsing was correct â¢ the image table or nil to indicate that the image should be skipped Example: function set_version(image) print (\\\"RECOVERY_STATUS.RUN: \\\".. swupdate.RECOVERY_STATUS.RUN) for k,l in pairs(image) do swupdate.trace(\\\"image[\\\" .. tostring(k) .. \\\"] = \\\" .. tostring(l)) end image.version = \\\"1.0\\\" image.install_if_different = true return true, image end The example sets a version for the installed image. Generally, this is detected at runtime reading from the target. Attribute reference There are 4 main sections inside sw-description: â¢ images: entries are images and SWUpdate has no knowledge about them. â¢ files: entries are files, and SWUpdate needs a filesystem for them. This is generally used to expand from a tar-ball or to update single files. â¢ scripts: all entries are treated as executables, and they will be run twice (as pre- and post- install scripts). â¢ bootenv: entries are pair with bootloader environment variable name and its value. Attributes in sw-description âââââââââââââââââââââââ¬âââââââââââââââââââââ¬ââââââââââââââââââââââ¬ââââââââââââââââââââââ âName â Type â Applies to â Description â âââââââââââââââââââââââ¼âââââââââââââââââââââ¼ââââââââââââââââââââââ¼ââââââââââââââââââââââ¤ âfilename â string â images files â filename as found â â â â scripts â in the cpio archive â âââââââââââââââââââââââ¼âââââââââââââââââââââ¼ââââââââââââââââââââââ¼ââââââââââââââââââââââ¤ âvolume â string â images â Just if type = â â â â â âubivolâ. UBI â â â â â volume where image â â â â â must be installed. â âââââââââââââââââââââââ¼âââââââââââââââââââââ¼ââââââââââââââââââââââ¼ââââââââââââââââââââââ¤ âubipartition â string â images â Just if type = â â â â â âubivolâ. Volume to â â â â â be created or â â â â â adjusted with a new â â â â â size â âââââââââââââââââââââââ¼âââââââââââââââââââââ¼ââââââââââââââââââââââ¼ââââââââââââââââââââââ¤ "
    }
}