{
    "id": "dbpedia_7738_1",
    "rank": 24,
    "data": {
        "url": "https://www.wolfssl.com/author/kajal/page/23/",
        "read_more_link": "",
        "language": "en",
        "title": "Kajal Sapkota",
        "top_image": "https://www.wolfssl.com/wordpress/wp-content/uploads/2017/07/cropped-wolf-square-32x32.png",
        "meta_img": "https://www.wolfssl.com/wordpress/wp-content/uploads/2017/07/cropped-wolf-square-32x32.png",
        "images": [
            "https://www.wolfssl.com/wordpress/wp-content/uploads/2017/11/japan-site.png",
            "https://www.wolfssl.com/wordpress/wp-content/uploads/2020/12/cropped-wolfssl_logo_300px.png",
            "https://www.wolfssl.com/wordpress/wp-content/uploads/2020/04/acvp_diagram-745x1024.png",
            "https://www.wolfssl.com/wordpress/wp-content/uploads/2018/08/TLS13-now-avail.png",
            "https://www.wolfssl.com/wordpress/wp-content/uploads/2023/08/x.png",
            "https://www.wolfssl.com/wordpress/wp-content/uploads/2018/06/facebook-icon.png",
            "https://www.wolfssl.com/wordpress/wp-content/uploads/2018/06/github-icon.png",
            "https://www.wolfssl.com/wordpress/wp-content/uploads/2020/12/linkedin_50_50.png",
            "https://www.wolfssl.com/wordpress/wp-content/uploads/2018/06/flickr-icon.png",
            "https://www.wolfssl.com/wordpress/wp-content/uploads/2020/12/madeInUsa_100px.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "iot tls"
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-05-14T15:23:32-06:00",
        "summary": "",
        "meta_description": "Embedded SSL/TLS Library",
        "meta_lang": "en",
        "meta_favicon": "https://www.wolfssl.com/wordpress/wp-content/uploads/2017/07/cropped-wolf-square-32x32.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "What is CT (Certificate Transparency)?\n\nCertificate Transparency is from RFC 6962 and is an extension on certificates to create a Merkle Tree (hash tree like with blockchain). The purpose of the tree is to help spot misuses of certificates and to provide a public way to audit the log of certificates issued. It was first implemented by Google in 2013 and required by google in 2017 which was then pushed back to 2018. Google has now been requiring all new certificates that are issued to have CT. The SCT (signed certificate timestamp) for CT can be sent in a TLS extension too, or with OCSP.\n\nThis is something we are thinking of adding to our library just to make it easier for users to parse out the information and view it with wolfSSL. Currently, users can get the extension by getting the peer certificate after a connection is complete and using one of the available checkers (google/cloudflare have checkers). It obviously gets more involved if adding the TLS extension (signed_certificate_timestamp) or if implementing a Monitor (application that goes out and does the audit on the certificate).\n\nWhat are we doing about it?\n\nTo make this process easier we are planning on leaving it up to the certificate to contain the SCT and parse it from there.\n\nTo get there we are planing on making sure it includes:\n\n– API to get the certificate extension information (people using this will want the hash / signature / timestamp to perform an audit on certificates)\n\n– Checks on the timestamp (must be rejected by client if it is in the future)\n\n– Code in our certificate extension parsing to read the OIDs and store the hash / signature / timestamp\n\n– Testing and documentation (more time on testing since affecting certificate parsing code)\n\nLove it? Star wolfSSL on GitHub.\n\nFor questions and comments regarding Certificate Transparency contact facts@wolfssl.com\n\nWith our new release of wolfSentry people might wonder how it compares to Suricata. Suricata is an open source IDS / IPS / NSM engine. While it seems that Suricata is in rivalry with wolfSentry, our embedded IDPS; they actually have a synergy, it would make sense for sophisticated users to deploy both of them.\n\nSuricata:\n\nThe distribution tarball is 29 MB\n\nThe build tree with minimal featureset is 536 MB\n\nThe binary installation image is 35 MB, of which 34.5 MB is the Suricata binary executable (dynamically linked)\n\nThe main executable depends on 18 special purpose libraries not included in the distribution.\n\nSuricata depends on Python\n\nIt only runs on Unix-like and Windows OSs, and its firewalling (host protection) depends on host OS facilities.\n\nSuricata is a heavyweight, infrastructural IDS platform. It has to duplicate the logic, and a lot of the processing, of the protocols/libraries/applications that it is monitoring and protecting.\n\nSuricata can do a lot of powerful things, including protecting endpoints that can’t protect themselves, and protecting endpoints before they’re attacked, by blocking bad actors at the first opportunity, when they’ve only had time to attack a first protected endpoint.\n\nwolfSentry\n\nBy comparison, wolfSentry has a much smaller footprint.\n\nThe distribution tarball is 36 K.\n\nThe build tree is 2.5 MB, with all features and debugging symbols enabled.\n\nlibwolfsentry.a is 339 K, and the biggest example executable is 443 K, or 84 K stripped, and uses no libraries beyond libc (which it barely uses).\n\nIt is designed to integrate directly with network-facing applications/libraries to block bad traffic, and it can optionally integrate with host firewall facilities, via plugins.\n\nIt can run on bare metal, in which case the firewall functions can be directly integrated into the network stack of the application.\n\nwolfSentry isn’t infrastructural, it’s on the endpoints, and it’s intended to be integrated with the endpoint applications/libraries to leverage them to the fullest.\n\nComparison and Synergy\n\nThe synergy between wolfSentry and Suricata infrastructural IDPSs is to have wolfSentry (via a plugin) notify the external IDPS when it detects bad traffic that the external IDPS might not be able to detect. This can enable clever stuff like blocking the bad traffic inside the network, before it even reaches the endpoint, and of course blocking the bad traffic for all the protected endpoints at once.\n\nThis raises an obvious worry about Suricata being compromised, because by nature it is directly exposed to the network, and is highly privileged. Suricata addresses this by doing lots of fuzz testing etc. to build confidence. However, because they have a 29 MB distribution tarball, there is a higher likelihood for things to fall through the cracks.\n\nAn advantage of wolfSentry is wolfSentry doesn’t require the endpoint to trust anyone else, nor anyone else to trust the endpoint. It’s a freestanding, high-efficiency self-defense system.\n\nUltimately, while there are some comparisons and different uses between the two, the best course of action would be to use wolfSentry and Suricata together for the best secure IDPS.\n\nIf there are any specific questions about how wolfSentry, please contact our team at facts@wolfssl.com. If there is a desire for wolfSSL to include other cybersecurity standards, please let the wolfSSL team know!\n\nwolfSSL is implementing MIKEY-SAKKE!\n\nMIKEY-SAKKE is a standard created by the UK government’s National Cyber Security Center (NCSC). MIKEY-SAKKE is a standard designed to enable secure, cross-platform multimedia communications. It is highly scalable, requiring no prior setup between users or distribution of user certificates. It is designed to be centrally-managed, giving a domain manager full control of the security of the system. But even so, it maintains high-availability, as calling does not require interaction with centralized architecture.\n\nwolfSSL is a lightweight TLS/SSL library that is targeted for embedded devices and systems. It has support for the TLS 1.3 protocol, which is a secure protocol for transporting data between devices and across the Internet. In addition, wolfSSL uses the wolfCrypt encryption library to handle its data encryption.\n\nSecure communications are needed across all governments. As a result governments create policies encouraging the development of security solutions. MIKEY-SAKKE is the answer to the security requirements from the UK government to specify secure, open and patent free cryptographic methods in order to empower private industry to provide UK government interoperable secure communication solutions. As a result many private and commercial organizations perceive a sizable advantage being MIKEY-SAKKE compliant.\n\nIf there are any specific questions about how wolfSSL integrates, please contact our team at facts@wolfssl.com. If there is a desire for wolfSSL to include other cybersecurity standards, please let the wolfSSL team know!\n\nAs many in the FIPS world are aware NIST retired CAVP (Cryptographic Algorithm Validation Protocol) testing on June 30th of 2020, permanently replacing CAVP with ACVP (Automated Cryptographic Validation Protocol), also referred to as ACVTS (Automated Cryptographic Validation Test System).\n\nIn order to prepare for this transition NIST offered a “demo server” that Vendors like wolfSSL and FIPS Labs could utilize in standup of the new protocol. Once the transition was completed NIST also setup “production servers” which only FIPS Labs with a trusted certificate issued by NIST can connect to; Production Vectors passing are now the gateway to Algorithm Certification (IE certs like the ones wolfSSL just received!).\n\nAlgorithm Certification is a prerequisite to CMVP FIPS 140-2 (and 140-3) validations. This design keeps in place the need for a FIPS lab to achieve algorithm certification but it now allows for Vendors such as wolfSSL to pre-test in advance of requesting production vectors for certification! wolfCrypt has been listed on the CMVP IUT List for FIPS 140-3! We are currently working with our testing lab to get validated as quickly as possible with the new FIPS standard from the NIST. wolfSSL is the first software library on the FIPS 140-3 IUT list for embedded development.\n\nConcurrently wolfSSL is also in the process of developing our own ACVP client based off of the current draft (draft-fussell-acvp-spec-01). Having many algorithms already completing the validation process through the NIST operated ACVP Demo server. Where our test vendor information can be seen publicly listed on the demo site here (https://demo.acvts.nist.gov/home).\n\nMore on ACVP’s\n\nACVP stands for (Automated Cryptographic Validation Protocol) and it is the upcoming protocol that will be used for FIPS validation. This is going to be a prerequisite certificate for the CMVP(Cryptographic Module Validation Program) and CAVP(Cryptographic Algorithm Validation Program) certificates.\n\nACVP makes testing cryptographic algorithms and modules more efficient than the current method and more automated. There are three main parts to ACVP – a server, a proxy, and a client.\n\nThe server side handles requests for test vectors and requests for validation among other requests. This side is operated by a FIPS lab or by NIST themselves.\n\nA proxy with ACVP can be used to communicate to offline systems and handle transferring information from the system being tested to the server. Often an ACVP client is used instead.\n\nThe last part being a client, which is most relevant to users who are wanting to get their cryptography FIPS validated. An ACVP client is directly hooked up to the module to be tested and then communicates with the ACVP server to send requests for test vectors, responses of the results from running those tests, and requests for algorithm validation. There are multiple pieces required to build a ACVP client in order to complete a validation process, some of the large portions of the effort go into\n\nJSON parsing / creation for communication with a ACVP server\n\nHTTPS GET / POST / PUT / DELETE messages used for securely transporting information\n\n2 factor authentication with TOTP (Time-Based One-Time Password Algorithm)\n\nPlugging in the test harness that runs crypto operations\n\nUltimately an ACVP client communicates with the server to validate cryptographic operations. This includes creating, or referencing meta data such as; vendor, OE, and module information. A simplified message flow for getting an algorithm validated is as follows:\n\nWe can assist with your FIPS needs. Contact us at facts@wolfssl.com for questions or more information.\n\nMore information from NIST’s website about the ACVP project can be found here:\n\nhttps://csrc.nist.gov/Projects/Automated-Cryptographic-Validation-Testing.\n\nFrom the early days of the wolfSSL library, we have provided example clients and servers with wolfSSL. These examples have shown how easy it is to use wolfSSL in various configurations. We also use them to help test the library. Over the years we’ve added new features available with TLS to our examples, and our examples have grown a little complicated.\n\nEnter the wolfSSL Examples GitHub repository. We tasked some of our interns, with little to no experience with the wolfSSL library, to write some example clients and servers that set up and test various types of connections. They give you a bare-bones simple demonstration on how to set up a client or server using wolfSSL. We also have examples showing off how to use some features of the library like the certificate manager.\n\nThe repository contains example applications, written in C, which demonstrate how to use the wolfSSL lightweight SSL/TLS library for secure communication. Each directory represents a unique topic (SSL/TLS, DTLS, PSK, etc.) and contains a Makefile as well as a simple tutorial on the given topic.\n\nCurrent Examples:\n\nutasker (uTasker wolfSSL Example Tasks)\n\nThis directory contains example uTasker client and server tasks that demonstrate using wolfSSL with the uTasker stack. These have been tested on the uTasker Simulator.\n\nPlease see the utasker/README.md for further usage and details.\n\nandroid (Android NDK Examples)\n\nThis directory contains examples that demonstrate using wolfSSL and wolfSSLJNI on the Android platform, using the Android NDK toolchain.\n\nPlease see the android/README.md for further usage and details.\n\ncertfields (X509 field extraction)\n\nThis directory contains an example that demonstrates using the wolfSSL to read a DER encoded certificate and extract the public key and subject name information.\n\nPlease see the certfields/README.md for further usage and details.\n\ncertmanager (wolfSSL CertManager)\n\nThis directory contains examples that demonstrate using the wolfSSL CertManager (Certificate Manager) functionality.\n\nPlease see the certmanager/README.md for further usage and details.\n\nwolfCLU (wolfSSL Command Line Utility)\n\nThis is a tool to provide command line access to wolfcrypt cryptographic libraries. wolfSSL command line utility will allow users to encrypt or decrypt a user specified file to any file name and extension.\n\nPlease see the clu/README.md for further usage and details.\n\nUnique feature to wolfSSL CLU\n\nThe decision to allow for unique file extensions was prompted by automated tools available for brute forcing files. It will not provide extra security cryptographically however it will force attackers to check the header information on every single brute force attempt. This will provide further frustration and an extra step in any attempt to brute force a file encrypted with our utility.\n\nDTLS (Datagram TLS)\n\nThis directory contains examples of using DTLS, with client and server examples demonstrating UDP, DTLS, non-blocking, session resumption, and multi-threading.\n\nWhen compiling wolfSSL for use with these examples, wolfSSL will need to be compiled with DTLS support:\n\ncd wolfssl-[version] ./configure --enable-dtls\n\nExamples in this directory may be compiled using:\n\ncd ./dtls make\n\nPSK (Pre-Shared Keys)\n\nThis directory contains examples of using PSK, with client and server examples demonstrating TCP/IP, PSK, non-blocking, session resumption, and multi-threading.\n\nWhen compiling wolfSSL for use with these examples, wolfSSL will need to be compiled with PSK support:\n\ncd wolfssl-[version] ./configure --enable-psk\n\nExamples in this directory may be compiled using:\n\ncd ./psk make\n\nSSL/TLS\n\nThis directory contains examples of using SSL/TLS, with client and server examples demonstrating TCP/IP, SSL/TLS, non-blocking, session resumption, and multi-threading.\n\nExamples in this directory may be compiled using:\n\ncd ./tls make\n\nBTLE\n\nThis directory contains examples for securing a Bluetooth Low Energy Link (BTLE). BTLE packets are small and throughput is low, so these examples demonstrate a way to exchange data securely without BTLE pairing.\n\nNotes\n\nWhen necessary, examples will use the example certificates and keys located in the ./certs directory. These certificates and keys have been pulled in from the main wolfSSL repository.\n\nSupport\n\nPlease contact wolfSSL at support@wolfssl.com with any questions, bug fixes, or suggested feature additions."
    }
}