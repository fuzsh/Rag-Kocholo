{
    "id": "dbpedia_6002_0",
    "rank": 15,
    "data": {
        "url": "https://python-course.eu/python-tutorial/dictionaries.php",
        "read_more_link": "",
        "language": "en",
        "title": "12. Dictionaries",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://python-course.eu/images/common/classroom_training_courses.jpg",
            "https://python-course.eu/images/python-tutorial/python_entry.jpg",
            "https://python-course.eu/images/common/classroom_training_courses.jpg",
            "https://python-course.eu/images/common/PDF_150w.webp",
            "https://python-course.eu/images/common/pdf_logo_20w.webp",
            "https://python-course.eu/images/python-tutorial/webster_400w.webp",
            "https://python-course.eu/images/common/classroom_training_courses.jpg",
            "https://python-course.eu/images/common/classroom_training_courses.jpg",
            "https://python-course.eu/images/python-tutorial/zipper_sphere.webp",
            "https://python-course.eu/images/common/classroom_training_courses.jpg",
            "https://python-course.eu/images/common/classroom_training_courses.jpg",
            "https://python-course.eu/images/common/classroom_training_courses.jpg",
            "https://python-course.eu/images/common/classroom_training_courses.jpg",
            "https://python-course.eu/images/common/classroom_training_courses.jpg",
            "https://python-course.eu/images/python-tutorial/map_with_fake_cities_distances_400w.webp",
            "https://python-course.eu/images/common/classroom_training_courses.jpg",
            "https://python-course.eu/images/common/classroom_training_courses.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Tutorial on Dictionaries in Python: Operators and Methods of the  Dictionary class",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "By Bernd Klein. Last modified: 11 Feb 2024.\n\nOn this page ➤\n\nIntroduction\n\nIn the preceding chapters, we delved into the fundamentals of lists, , including subtle intricacies. Now, as we progress through this chapter of our online Python course, we turn our attention to dictionaries, exploring their syntax, operators, and methods. Lists and dictionaries are indispensable components of Python programming, making Python a powerful and extremely useful programming language.\n\nLet's begin with a straightforward example to illustrate the concept of a dictionary:\n\nIn Python, a dictionary is a data structure that stores key-value pairs. Let's take a closer look at our example dictionary to explain the essential details:\n\nA dictionary is wrapped in curly brackets {}.\n\nA dictionary contains keys and values.\n\nThe keys in our dictionary are strings and are positined in front of the colons. The keys of our example dictionary are 'name', 'age', 'city', and 'email'.\n\nEach key is associated with a corresponding value separated by a colon :: 'Anna Schmidt' is the value associated with the key 'name', 28 with 'age', 'Berlin' with 'city', and '[email protected]' with 'email'.\n\nWe call\n\nWe call a key-value pair like 'name': 'Anna Schmidt' an item. So a dictionary contains an arbitrary sequence of key:value pairs separated by commas.\n\nDictionaries are useful for organizing data in a way that allows quick and easy access based on specific keys.\n\nWe can also consider a dictionary like a digital information card about a person named Anna Schmidt from Berlin, Germany and keeps track of important details in a structured way.\n\nIn this digital card:\n\n'name': This is where we keep Anna's full name, which is 'Anna Schmidt'.\n\n'age': Here we store Anna's age, which is 28 years old.\n\n'city': This tells us where Anna lives, which is in Berlin.\n\n'email': Anna's email address, which is '[email protected]', is stored here.\n\nIn the code snippet below, we demonstrate how to retrieve specific pieces of information from our dictionary, such as the 'name' or 'age', from the dictionary:\n\nNow, we'll illustrate how dictionaries can be modified because they are mutable. Let's consider a scenario where Anna relocates from Berlin to Freiburg, renowned as one of Germany's most picturesque cities, known for its favorable weather compared to other regions in the country.\n\nLike lists, they can be easily changed, can be shrunk and grown ad libitum at run time. They shrink and grow without the necessity of making copies. Dictionaries can be contained in lists and vice versa.\n\nLet's add Anna's gender and her favorite hobbies, which include reading, music, and programming (as she's a beginner in Python), to the existing dictionary:\n\nNow, we remove again the gender information from the dictionary:\n\nAssociative Arrays\n\nMore theoretically, we can say that dictionaries are the Python implementation of an abstract data type, known in computer science as an associative array. Associative arrays consist - like dictionaries of (key, value) pairs, such that each possible key appears at most once in the collection. Any key of the dictionary is associated (or mapped) to a value. The values of a dictionary can be any type of Python data. So, dictionaries are unordered key-value-pairs. Dictionaries are implemented as hash tables, and that is the reason why they are known as \"Hashes\" in the programming language Perl.\n\nDictionaries don't support the sequence operation of the sequence data types like strings, tuples and lists. Dictionaries belong to the built-in mapping type, but so far, they are the sole representative of this kind!\n\nAt the end of this chapter, we will demonstrate how a dictionary can be turned into one list, containing (key,value)-tuples or two lists, i.e. one with the keys and one with the values. This transformation can be done reversely as well.\n\nDictionary and Lists\n\nBut what's the difference between lists and dictionaries?\n\nA list is a sequence of objects where the order matters. You can access list elements directly by their position in this order. Similarly, dictionaries are also ordered, but unlike lists, you can't access elements by their position. We can also say that contrary to lists that the order of a dictionary is not important. The order of items in a dictionary is determined by the sequence in which they were added. If we print a dictionary, we can see this ordering.\n\nLet's demonstrate this with the following dictionary:\n\nWe will add now the German cities \"München\" (Munich) and \"Köln' (Cologne) to our dictionary:\n\nWe can see that the cities \"München\" (Munich) and \"Köln' (Cologne) had been added to the end of the dictionary as expected.\n\nConvert Dictionaries to Lists\n\nIf you have worked for a while with Python, nearly inevitably the moment will come, when you want or have to convert lists into dictionaries or vice versa. It wouldn't be too hard to write a function doing this. But Python wouldn't be Python, if it didn't provide such functionalities. We can convert the previously defined dictionary into a list with the following expression:\n\nThis list holds the identical information as the dictionary city_population. However, retrieving this data differs significantly. What if you want to get the population of Amsterdam? It's extremely easy with the dictionary:\n\nIt's a lot more complicated in the list representation. We're limited to accessing indices rather than city names. Consequently, we must iterate over the list and inspect all the tuples to determine if the first entry corresponds to the city of Amsterdam.\n\nIn this aspect, the dictionary method outperforms the list approach by enabling swifter data access. In a dictionary, you can directly retrieve the population of a city using its name as the key, which is much quicker compared to searching through a list to find the population. Think of it like looking up a word in a dictionary versus flipping through the pages of a book to find it. The dictionary provides instant access, while the list requires more time to search through.\n\nThe efficiency of this algorithm depends on the size of the city_population_list. Since it iterates through the entire list linearly to find the population of a given city, the time complexity is O(n), where n is the number of cities in the list.\n\nFor a small number of cities, this approach is acceptable. However, as the number of cities grows larger, the linear search becomes less efficient, especially if the city being searched for is towards the end of the list or if the list contains a large number of cities.\n\nIn scenarios where performance is critical or when dealing with a large dataset, a more efficient approach would be to use a dictionary instead of a list, where the keys are the city names. This would allow constant-time (O(1)) lookups, providing faster access to population data.\n\nitems()\n\nIf we apply the method items() to a dictionary, we don't get a list back, as it used to be the case in Python 2, but a so-called items view. The items view can be turned into a list by applying the list function. We have no information loss by turning a dictionary into an item view or an items list, i.e. it is possible to recreate the original dictionary from the view created by items().\n\nAccessing dictionary items via a method like items() provides a more efficient approach compared to creating lists directly due to several reasons:\n\n1) Lazy Evaluation: The items() method doesn't generate the entire list of key-value pairs upfront. Instead, it returns a view object that generates items on-the-fly as needed. This lazy evaluation saves memory and processing time, especially when dealing with large dictionaries where creating a complete list of items upfront may be resource-intensive.\n\n2) Memory Efficiency: Generating a list of items directly requires storing all key-value pairs in memory simultaneously, which can be inefficient for large dictionaries. In contrast, using items() provides a memory-efficient solution as it generates items dynamically without storing the entire list in memory at once.\n\n3) Time Complexity: While both approaches have similar time complexity for iterating over all items (O(n), where n is the number of items in the dictionary), using items() may provide better performance in certain scenarios. For example, if only a subset of items is needed, items() allows for efficient iteration over only the required items without iterating over the entire dictionary.\n\nOverall, using methods like items() for accessing dictionary items provides a more efficient and memory-friendly approach, especially for large dictionaries or scenarios where lazy evaluation and selective item retrieval are beneficial.\n\nkeys()\n\nThe keys() method returns a view object that displays a list of all keys in the dictionary. This allows you to iterate over or access the keys directly without needing to create a separate list of keys.\n\nWhile the keys() method is available in Python dictionaries, it's less commonly used because iterating over a dictionary directly implicitly iterates over its keys. Here's an example demonstrating this:\n\nvalues()\n\nWe can also iterate directly over the values of a dictionary:\n\nTurn Lists into Dictionaries\n\nNow we will turn our attention to the art of cooking, but don't be afraid, this remains a python course and not a cooking course. We want to show you, how to turn lists into dictionaries, if these lists satisfy certain conditions. We have two lists, one containing the names of the largest German cities and the other one the corresponding areas:\n\nIn this example, we have two lists: cities containing the names of the five largest cities in Germany, and areas containing their respective areas in square kilometers. We use the zip() function to combine these lists into a list of tuples, then we use the dict() function to convert this list of tuples into a dictionary, where each city is paired with its respective area.\n\nTo gain further insight into the functionality of the zip function, explore our tutorial available at 'zip'.\n\nDanger Lurking\n\nWhat is wrong with the following example:\n\nThe issue with this example is that we are converting items to a list using list(items) before iterating over it. Once you convert items to a list, it becomes exhausted, meaning it doesn't contain any more elements for iteration.\n\nIncrementally Creating a Dictionary\n\nSo, it's possible to create a dictionary incrementally by starting with an empty dictionary. We haven't mentioned so far, how to define an empty one. It can be done by using an empty pair of brackets. The following defines an empty dictionary called city:\n\nCloser Look at Keys and Values\n\nLooking at our first examples with the cities and their population, you might have gotten the wrong impression that the values in the dictionaries have to be different. The values can be the same, as you can see in the following example. In honour to the patron saint of Python \"Monty Python\", we'll have now some special food dictionaries. What's Python without \"bacon\", \"egg\" and \"spam\"?\n\nKeys of a dictionary are unique. In casse a keys is defined multiple times, the value of the last \"wins\":\n\nOur next example is a simple English-German dictionary:\n\nWhat about having another language dictionary, let's say German-French?\n\nNow it's even possible to translate from English to French, even though we don't have an English-French-dictionary. de_fr[en_de[\"red\"]] gives us the French word for \"red\", i.e. \"rouge\":\n\nWe can use arbitrary types as values in a dictionary, but there is a restriction for the keys. Only immutable data types can be used as keys, i.e. no lists or dictionaries can be used: If you use a mutable data type as a key, you get an error message:\n\nTuple as keys are okay, as you can see in the following example:\n\nNested Dictionaries\n\nNested dictionaries are dictionaries that contain other dictionaries as values. In Python, dictionaries can hold any data type as their values, including other dictionaries. This allows for the creation of hierarchical or nested data structures where each level of the dictionary can store its own set of key-value pairs.\n\nLet's improve our examples with the natural language dictionaries a bit. We create now a nested dictionary, i.e. a dictionary of dictionaries:\n\nMorsecode Example\n\nThe following dictionary contains a mapping from latin characters to morsecode.\n\nThe numbers of characters contained in this dictionary can be determined by calling the len function:\n\nThe dictionary contains only upper case characters, so that \"a\" returns False, for example:\n\nNow, we will output a space character with three spaces in the morsecode encoding:\n\npop() and popitem()\n\npop\n\nLists can serve as stacks, with the pop() method used to extract an element from the stack. This functionality is straightforward for lists. However, considering dictionaries, does it make sense to have a pop() method? Unlike lists, dictionaries are not sequential data structures; they lack indexing. Consequently, the pop() method behaves differently with dictionaries.\n\nIn dictionaries, the pop() method is used to remove a specific key-value pair from the dictionary and return the corresponding value. Here's how it works:\n\n1) You specify the key of the item you want to remove as an argument to the pop() method. 2) The pop() method then searches for this key in the dictionary. 3) If the key is found, the corresponding key-value pair is removed from the dictionary, and the value associated with the key is returned. 4) If the key is not found, a KeyError is raised.\n\nHere's an example to illustrate:\n\nIf we try to find out the capital of France in the previous example, we raise a KeyError. To prevent these errors, there is an elegant way. The method pop() has an optional second parameter, which can be used as a default value, if key is not in the dictionary:\n\npopitem\n\npopitem() is a method of dict, which doesn't take any parameter and removes and returns a (key,value) pair as a 2-tuple. If popitem() is applied on an empty dictionary, a KeyError will be raised.\n\nPairs are returned in LIFO (last-in, first-out) order.\n\nAccessing Non-existing Keys\n\nIf you try to access a key which doesn't exist, you will get an error message:\n\nTo prevent getting an exception we can check first, if the city is in:\n\nAnother method to access the values via the key consists in using the get() method. get() is not raising an error, if an index doesn't exist. In this case it will return None. It's also possible to set a default value, which will be returned, if an index doesn't exist:\n\nAnother example:\n\nImportant Methods\n\nA dictionary can be copied with the method copy():\n\ncopy()\n\nThis copy is a shallow copy, not a deep copy. If a value is a complex data type like a list, for example, in-place changes in this object have effects on the copy as well:\n\nIf we check the output, we can see that the title of course2 has been changed not only in the dictionary training but in trainings2 as well.\n\nEverything works the way you expect it, if you assign a new value, i.e. a new object, to a key:\n\nIf you want to understand the reason for this behaviour, we recommend our chapter \"Shallow and Deep Copy\".\n\nclear()\n\nThe content of a dictionary can be cleared with the method clear(). The dictionary is not deleted, but set to an empty dictionary:\n\nWhat about concatenating dictionaries, like we did with lists? There is someting similar for dictionaries: the update method update() merges the keys and values of one dictionary into another, overwriting values of the same key:\n\nIterating over a Dictionary\n\nNo method is needed to iterate over the keys of a dictionary:\n\nHowever, it's possible to use the method keys(), we will get the same result:\n\nThe method values() is a convenient way for iterating directly over the values:\n\nThe above loop is logically equivalent to the following one:\n\nWe said logically, because the second way is less efficient!\n\nIf you are familiar with the timeit possibility of ipython, you can measure the time used for the two alternatives:\n\nExercises\n\nExercise 1\n\nWrite a function dict_merge_sum that takes two dictionaries d1 and d2 as parameters. The values of both dictionaries are numerical. The function should return the merged sum dictionary m of those dictionaries. If a key k is both in d1 and d2, the corresponding values will be added and included in the dictionary m If k is only contained in one of the dictionaries, the k and the corresponding value will be included in m\n\nExercise 2\n\nGiven is the following simplified data of a supermarket:\n\nTo be ready for an imminent crisis you decide to buy everything. This isn't particularly social behavior, but for the sake of the task, let's imagine it. The question is how much will you have to pay?\n\nExercise 3\n\nCreate a virtual supermarket. For every article there is a price per article and a quantity, i.e. the stock. (Hint: you can use the one from the previous exercise!)\n\nCreate shopping lists for customers. The shopping lists contain articles plus the quantity.\n\nThe customers fill their carts, one after the other. Check if enough goods are available! Create a receipt for each customer.\n\nExercise 4\n\nGiven is the island of Vannoth\n\nCreate a dictionary, where we get for every city of Vannoth the distance to the capital city of Rogeburgh\n\nExercise 5\n\nCreate a dictionary where you can get the distance between two arbitrary cities\n\nExercise 6\n\nA salesperson takes the following route: Port Carol to Rogerburgh to Smithstad to Scottshire to Clarkhaven to Dixonshire to Port Carol. How many kilometres did the salesperson drive?\n\nTo solve this dictionary exercise it will be optimal, if you are familiar with 'for' or while loops in Python. We recommend to work through the corresponding chapters in our python course.\n\nExercise 7\n\nWrite Pyhton code to create a dictionary with the city names as keys and the corresponding areas and population numbers as values.\n\nExercise 8\n\nStudent Gradebook using Nested Dictionaries\n\nTo solve this exercise you have to be familiar with functions in Python, see our introduction on functions in our python course.\n\nCreate a Python program to manage a student gradebook using nested dictionaries. Follow these steps to implement the functionality:\n\nInitialize an empty dictionary to serve as the gradebook.\n\nImplement a function add_student(gradebook, student_name) that takes the gradebook dictionary and a student name as input and adds an empty dictionary for the student's grades to the gradebook.\n\nImplement a function add_grade(gradebook, student_name, subject, grade) that takes the gradebook dictionary, a student name, a subject name, and a grade as input. This function should add the grade for the specified subject to the grades dictionary of the specified student in the gradebook.\n\nImplement a function calculate_average_grade(gradebook, student_name) that takes the gradebook dictionary and a student name as input and calculates the average grade for the specified student.\n\nImplement a function display_gradebook(gradebook) that takes the gradebook dictionary as input and displays the contents of the gradebook, including student names, subjects, and grades, as well as the average grade for each student.\n\nUse the provided sample usage to demonstrate the functionality of your program.\n\nNote: You may assume that each student will have unique names, and subjects may have duplicate names but within the context of different students.\n\nAn example dictionary may look like this:\n\nSample usage looks like this:\n\ngradebook = {} # Add students to the gradebook add_student(gradebook, \"Alice\") add_student(gradebook, \"Bob\") # Add grades for subjects add_grade(gradebook, \"Alice\", \"Math\", 85) add_grade(gradebook, \"Alice\", \"Science\", 90) add_grade(gradebook, \"Alice\", \"History\", 88) add_grade(gradebook, \"Bob\", \"Math\", 78) add_grade(gradebook, \"Bob\", \"Science\", 92) add_grade(gradebook, \"Bob\", \"History\", 85) # Display the gradebook display_gradebook(gradebook)\n\nSolutions\n\nSolution to Exercise 1\n\nWe offer two solutions to this exercise:\n\nThe first one is only using things you will have learned, if you followed our Python course sequentially. The second solution uses techniques which will be covered later in our tutorial.\n\nFirst solution:\n\nSecond solution:\n\nSolution to Exercise 2:\n\nSolution to Exercise 3:\n\nAlternative solution to exercise 3, in which we create the chopping lists randomly:\n\nSolution to Exercise 4:\n\nSolution to Exercise 5:\n\nSolution to Exercise 6\n\nSolution to exercise 7\n\nSolution to exercise 8\n\n1 The city of Constance, also known as Konstanz in German, holds historical significance as it was the site of the Council of Constance from 1414 to 1418. This council played a crucial role in resolving the Papal Schism, which involved multiple claimants to the papacy. Additionally, Constance is located at the western end of Lake Constance (Bodensee), where Germany, Switzerland, and Austria meet, making it a picturesque and culturally rich destination."
    }
}