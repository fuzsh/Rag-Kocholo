{
    "id": "wrong_mix_property_subsidiary_00023_2",
    "rank": 75,
    "data": {
        "url": "https://patents.google.com/patent/DE69333422T2/en",
        "read_more_link": "",
        "language": "en",
        "title": "DE69333422T2 - Finding strings in a database of strings - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/cc/81/ef/b7bd6cde307be4/00130001.png",
            "https://patentimages.storage.googleapis.com/86/3e/d1/b21afcb2c3d102/00130002.png",
            "https://patentimages.storage.googleapis.com/cc/81/ef/b7bd6cde307be4/00130001.png",
            "https://patentimages.storage.googleapis.com/86/3e/d1/b21afcb2c3d102/00130002.png",
            "https://patentimages.storage.googleapis.com/36/29/9f/1ff7d96b7339df/00140001.png",
            "https://patentimages.storage.googleapis.com/36/29/9f/1ff7d96b7339df/00140001.png",
            "https://patentimages.storage.googleapis.com/79/92/4b/2d7c977a2dafdd/00160001.png",
            "https://patentimages.storage.googleapis.com/79/92/4b/2d7c977a2dafdd/00160001.png",
            "https://patentimages.storage.googleapis.com/54/15/0c/c86deb325e38cd/00170001.png",
            "https://patentimages.storage.googleapis.com/54/15/0c/c86deb325e38cd/00170001.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "1992-07-31T00:00:00",
        "summary": "",
        "meta_description": "This method non sequentially compares a reference sequence of tokens to an original sequence of tokens to determine subsequences of tokens which exactly or similarly match. The method has a novel approach for creating a large number of indexes by partitioning strings of tokens into substrings, appending non contiguous substrings together to form tuples, and creating indexes from the tuples. Indexes are created in this manner for both the original and reference strings. Techniques are also provided to approximately or exactly locate the substrings which where used to create the tuples and indexes from the original sequence of tokens. Original and reference indexes are compared and matches are tracked. Higher numbers of matches result in higher scores (votes) in a table and indicate a stronger similarity between the sequences on the the original and reference strings. Using this method, the degree of similarity can also be determined. The method is useful when comparing a reference sequence of tokens to a large database of original strings of tokens. It has applications in the biological sciences (human genome mapping or analyzing proteins) and in image, speech, and music recognition. <IMAGE>",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/DE69333422T2/en",
        "text": "1. GEBIET DER ERFINDUNG1. AREA THE INVENTION\n\nDie vorliegende Erfindung betrifft das Gebiet der Suche nach Zeichenketten (Zeichenfolgen) in einer Datenbank. Insbesondere werden gemÃ¤Ã der Erfindung Zeichenketten in einer Datenbank gefunden, die einer vorgegebenen Referenz-Zeichenkette Ã¤hnlich oder identisch sind.The The present invention relates to the field of searching for strings (Strings) in a database. In particular, according to the invention Strings found in a database that match a given Reference string similar or are identical.\n\n2. BESCHREIBUNG DES STANDS DER TECHNIK2. DESCRIPTION OF THE STAND OF THE TECHNIQUE\n\nEs gibt zahlreiche herkÃ¶mmliche Verfahren, um eine in einer Datenbank mit vielen Zeichenketten vorkommende bestimmte Zeichenfolge, die auch als Referenz-Zeichenfolge oder Referenz-Zeichenkette bezeichnet wird, zu finden. (Ein Zeichen ist ein Symbol wie beispielsweise ein Buchstabe, ein Wort, ein Klang, ein Bitmuster oder eine andere Beschreibungsform, die im vorliegenden Fall in einer Folge anderer Zeichen auftreten kann.) Einige dieser Verfahren sind zur AusfÃ¼hrung spezieller Tasks entwickelt worden, z. B. zum Auffinden einer genauen oder Ã¤hnlichen Folge spezieller Zeichen wie z. B. von Nukleotiden (oder AminosÃ¤uren) in einer langen Kette von Nukleotiden (oder AminosÃ¤uren), aus denen ein DNA-MolekÃ¼l (oder ProteinmolekÃ¼l) besteht. (Zwei Zeichenfolgen sind einander Ã¤hnlich, wenn sie durch Insertion, Deletion oder Ãnderung einer Anzahl von Zeichen identisch gemacht werden kÃ¶nnen, die kleiner als eine vorgegebene Anzahl von Zeichen in einer der Zeichenfolgen ist.) Einige dieser herkÃ¶mmlichen Vergleichsverfahren sind: der Needlemann-Wunsch-Algorithmus oder die ursprÃ¼nglichen Wilbur-Lipman-Algorithmen FASTA, FASTP und BLAST.It are numerous conventional Procedure to find one in a database with many strings certain string, also known as a reference string or Reference string is referred to find. (A sign is a symbol such as a letter, a word, a sound, a Bit pattern or other form of description described herein Case may occur in a sequence of other characters.) Some of these Procedures are in progress special tasks have been developed, e.g. B. to find an exact or similar Sequence of special characters such as B. of nucleotides (or amino acids) in a long chain of nucleotides (or amino acids) that make up a DNA molecule (or Protein molecule). (Two strings are similar to each other when inserted, Deletion or change a number of characters that can be made identical less than a predetermined number of characters in one of the strings is.) Some of these conventional Comparison methods are: the Needlemann-Wunsch algorithm or the originals Wilbur-Lipman algorithms FASTA, FASTP and BLAST.\n\nDer Needlemann-Wunsch-Algorithmus ist ein dynamisches Programmierverfahren. Alle in den beiden zu vergleichenden Zeichenfolgen enthaltenen Zeichen werden paarweise untersucht, um alle ZuordnungsmÃ¶glichkeiten zwischen den beiden Zeichenketten zu berechnen. Den Deletionen, Insertionen und Ãnderungen wird ein Aufwandswert zugewiesen. Dann wird diejenige Zuordnung gewÃ¤hlt, welche den geringsten Wert des Gesamtaufwands aufweist. Da die erforderliche Rechenleistung dem Produkt der LÃ¤ngen beider zu vergleichender Zeichenfolgen proportional ist, ist dieses Verfahren sehr aufwÃ¤ndig.The Needlemann-Wunsch-Algorithm is a dynamic programming method. All characters contained in the two strings to be compared are examined in pairs to find all possible associations between the two Calculate strings. The deletions, insertions and changes an expense value is assigned. Then the assignment selected which has the lowest value of the total effort. Because the required Computing power the product of lengths is proportional to both strings to be compared, this is Process very complex.\n\nDer Wilbur-Lipman-Algorithmus vergleicht zusammenhÃ¤ngende Tupel geringer LÃ¤nge in der Original-Zeichenkette und in der Referenz-Zeichenkette miteinander. Die Tupel werden mittels einer Referenztabelle, die anhand der Referenz-Zeichenkette erstellt wurde, fÃ¼r die beiden Zeichenketten verglichen. FÃ¼r jeden Vergleich wird eine Bewertungszahl berechnet und dann die beste Bewertungszahl gewÃ¤hlt. Deshalb wird jedes Mal eine neue Referenztabelle erstellt, wenn eine neue Referenz-Zeichenfolge mit der Datenbank verglichen werden soll. Da der gesamte Satz Original-Zeichenketten mit der Referenztabelle verglichen werden muss, verdoppelt sich die zum Vergleich mit einer Datenbank von insgesamt 2N Nukleotiden oder AminosÃ¤uren erforderliche Rechenleistung gegenÃ¼ber dem Vergleich mit einer Datenbank von lediglich N Nukleotiden oder AminosÃ¤uren. Mit anderen Worten, die Anzahl der Vergleiche mit der Referenztabelle ist mindestens gleich der Gesamtanzahl der in allen Original-Zeichenketten vorhandenen Nukleotide (AminosÃ¤uren).The Wilbur-Lipman algorithm compares contiguous tuples of short length in the Original string and in the reference string with each other. The tuples are determined using a reference table based on the reference string was created for compared the two strings. For each comparison there is one Calculated rating number and then selected the best rating number. Therefore a new reference table is created every time a new one Reference string to be compared with the database. Because the entire set of original strings must be compared with the reference table doubles those for comparison with a database of a total of 2N nucleotides or amino acids required computing power compared to a comparison Database of only N nucleotides or amino acids. With in other words, the number of comparisons with the reference table is at least equal to the total number in all original strings existing nucleotides (amino acids).\n\nDie Algorithmen FASTP und FASTA stellen Verbesserungen des ursprÃ¼nglichen WILBUR-LIPMAN-Verfahrens dar. Durch eine Austauschmatrix zur Bewertung der Vergleichsoperationen wird eine hÃ¶here Empfindlichkeit erreicht. WÃ¤hrend der Evolution oft vorkommende Mutationen (Deletionen, Insertionen und Nukleotidaustausch) erhalten eine hÃ¶here Bewertungszahl als seltener vorkommende Mutationen. Hierbei handelt es sich jedoch immer noch um einen sequenziellen Ansatz.The FASTP and FASTA algorithms represent improvements to the original WILBUR-LIPMAN process. Through an exchange matrix for evaluation the comparison operations achieve a higher sensitivity. While mutations that often occur in evolution (deletions, insertions and nucleotide exchange) receive a higher rating than rarer occurring mutations. However, this is still the case a sequential approach.\n\nDas BLAST-Verfahren unternimmt erst dann einen kompletten Vergleich zwischen der Original- und der Referenz-Zeichenkette, wenn diese in einem sehr schnell durchzufÃ¼hrenden Vortest eine MindestÃ¤hnlichkeit aufweisen. Bei diesem Test wird heuristisch ermittelt, ob die LÃ¤nge des MSP (maximal segment pair, grÃ¶Ãtes Segmentpaar) einen bestimmten Schwellenwert Ã¼berschreitet. Das MSP ist dasjenige Paar identischer Teilzeichenketten in der Referenz-Zeichenkette und der Original-Zeichenkette, welches die beste Mutations-Bewertungszahl aufweist. Wenn dieser Test erfolgreich bestanden wurde, erfolgt mittels der Algorithmen vom Typ FASTP-FASTA eine umfassendere und aufwÃ¤ndigere Ãhnlichkeitsanalyse. Hierdurch wird der Rechenaufwand verringert und gleichzeitig in Kauf genommen, dass einige Ãbereinstimmungstreffer unberÃ¼cksichtigt bleiben, welche die Ausgangskriterien nicht erfÃ¼llen. Etwa 20% der durch den Needleman-Wunsch-Algorithmus gefundenen Ãbereinstimmungen werden durch BLAST nicht erfasst. AuÃerdem bleibt dieser Ansatz in seinem Wesen sequenziell, da fÃ¼r jede Zeichenkette aus der Menge der Original-Zeichenketten eine Berechnung durchgefÃ¼hrt werden muss.The Only then does the BLAST process make a complete comparison between the original and reference strings if these are in a very quick to perform Pretest a minimum similarity exhibit. This test heuristically determines whether the length of the MSP (maximum segment pair, largest segment pair) exceeds a certain threshold. The MSP is the pair of identical substrings in the Reference string and the original string, which is the best mutation rating number having. If this test is passed successfully, it is done using the algorithms of type FASTP-FASTA a more comprehensive and more complex similarity analysis. This reduces the computing effort and at the same time Bought some match hits unconsidered remain who do not meet the initial criteria. About 20% of those through the Matches found by Needleman wish algorithm are made by BLAST not recorded. Moreover this approach remains sequential in nature, as for each string a calculation can be made from the set of original strings got to.\n\np3. BESCHREIBUNG DER PROBLEME NACH DEM STAND DER TECHNIKp3. DESCRIPTION OF THE PROBLEMS ACCORDING TO THE STATE OF THE ART\n\nMit den derzeitigen Verfahren war es mÃ¶glich, zwei Zeichenketten (wobei es sich bei den Zeichen speziell um Nukleotide oder AminosÃ¤uren handelt) eins zu eins, d. h. sequenziell, ohne groÃen Aufwand miteinander zu vergleichen. Beim Stand der Technik ist es jedoch oft schwierig, alle oder zumindest die meisten mÃ¶glichen Ãbereinstimmungen einer Referenz-Zeichenfolge in einer Datenbank mit Original- Zeichenketten zu finden, ohne Berechnungen an allen oder fast allen Zeichen der Original-Zeichenfolgen durchzufÃ¼hren. Beim gegenwÃ¤rtigen Stand der Computertechnik lassen sich diese Aufgaben in sehr groÃen Datenbanken nur mit einem unvertretbar hohen Zeitaufwand ausfÃ¼hren.With the current process allowed two strings (where the characters are specifically nucleotides or amino acids) one on one, d. H. sequentially, without much effort to compare. However, in the prior art, it is often difficult all or at least most possible matches of a reference string in a database with original strings to find without calculations on all or almost all of the characters of the Perform original strings. With the current State of the art in computer technology, these tasks can be done in very large databases only perform with an unacceptably long amount of time.\n\nDeshalb besteht seit langem ein Bedarf an einem indexierten Verfahren zur Ermittlung einer annÃ¤hernden oder genauen Ãbereinstimmung zwischen einer Referenz-Zeichenkette und einer Zeichenfolge in einer oder mehreren Original-Zeichenketten in sehr groÃen Datenbanken. AuÃerdem wird gefordert, die Lage dieser Ã¤hnlichen oder identischen Zeichenfolgen in den Original-Zeichenketten und den Grad ihrer Ãbereinstimmung mit einer Referenz-Zeichenkette schnell und mit geringem Aufwand zu ermitteln. Insbesondere besteht auf dem Gebiet der Genomkartierung seit langem der Wunsch nach einem Verfahren, welches mittels der neuesten Rechentechnik Ãbereinstimmungen zwischen den Nukleotidsequenzen in einer Datenbank mit bis zu 4 Milliarden Nukleotiden nachweisen kann.Therefore There has long been a need for an indexed method for Find an approximate or exact match between a reference string and a string in an or several original strings in very large databases. Besides, will requested the location of this similar or identical strings in the original strings and the degree of their agreement with a reference string quickly and with little effort determine. In particular, there is in the field of genome mapping For a long time, the desire for a process that can be carried out using the latest computing technology matches between the nucleotide sequences in a database with up to 4 Can detect billions of nucleotides.\n\nDie Verfahren nach dem Stand der Technik sind nicht in der Lage, die Lage von Zeichenfolgen in Original-Zeichenketten groÃer Datenbanken schnell und ohne groÃen Aufwand zu ermitteln, wenn sie nach einer Ãbereinstimmung mit einer Referenz-Zeichenkette suchen. Das liegt daran, dass die Verfahren nach dem Stand der Technik bei der Vergleichsprozedur die gesamte Datenbank der Original-Zeichenketten durchsuchen mÃ¼ssen. Die Verfahren nach dem Stand der Technik mÃ¼ssen auf der Suche nach passenden Zeichenketten die gesamte Datenbank durchsuchen, da sie nicht in der Lage sind, ein Indexierungsverfahren bereitzustellen, welches nur diejenigen Original-Zeichenketten schnell und genau ausfindig macht, in denen mÃ¶gliche passende Zeichenfolgen enthalten sind.The Prior art methods are unable to Location of strings in original strings of large databases quickly and without much Effort to determine if they match a reference string search. This is because the state of the art methods Search the entire database of original strings during the comparison procedure have to. The methods according to the state of the art have to search for suitable ones Strings search the entire database because they are not in are able to provide an indexing process which find only those original strings quickly and accurately makes where possible matching strings are included.\n\nZIELE DER ERFINDUNGGOALS OF INVENTION\n\nEin Ziel der vorliegenden Erfindung besteht in der Bereitstellung eines verbesserten Verfahrens zum Auffinden von Zeichenfolgen, die einer Referenz-Zeichenfolge in einer oder mehreren Original-Zeichenketten in einer Datenbank mit einer oder mehreren Original-Zeichenketten identisch oder Ã¤hnlich sind.On The aim of the present invention is to provide a improved method for finding strings that a Reference string in one or more original strings in a database with one or more original strings or similar are.\n\nEin weiteres Ziel der vorliegenden Erfindung besteht in der Bereitstellung eines verbesserten Verfahrens zum Auffinden von Zeichenfolgen mittels Indexierungs- und Hashverfahren, die einer Referenz-Zeichenfolge in Original-Zeichenketten in einer Datenbank mit einer oder mehreren Original-Zeichenketten identisch oder Ã¤hnlich sind.On Another object of the present invention is to provide an improved method for finding strings using Indexing and hashing that of a reference string in original strings in a database with one or more Original strings are identical or similar.\n\nEin weiteres Ziel der vorliegenden Erfindung besteht in der Bereitstellung eines verbesserten Verfahrens zum Auffinden von Nukleotidsequenzen (oder AminosÃ¤uresequenzen), die mit einer Referenz-Nukleotidsequenz (oder Referenz-AminosÃ¤uresequenz) in einer Datenbank identisch oder dieser Ã¤hnlich sind, welche eine Vielzahl von Original-Nukleotidketten (oder Original-AminosÃ¤ureketten) enthÃ¤lt, welche ein DNA-MolekÃ¼l (oder ein ProteinmolekÃ¼l) darstellen.On Another object of the present invention is to provide an improved method for finding nucleotide sequences (or amino acid sequences), with a reference nucleotide sequence (or reference amino acid sequence) in a database are identical or similar, which is a multitude of original nucleotide chains (or original amino acid chains) which a DNA molecule (or a protein molecule) represent.\n\nFerner besteht ein Ziel der vorliegenden Erfindung in der Bereitstellung eines verbesserten Verfahrens zur Spracherkennung durch Auffinden von Phonemfolgen, die einer Referenz-Phonemfolge in einer Datenbank mit Original-Sprachphonemfolgen Ã¤hnlich sind.Further It is an object of the present invention to provide an improved method of speech recognition by finding of phoneme sequences that are a reference phoneme sequence in a database with original speech phoneme sequences are similar.\n\nEin weiteres Ziel der vorliegenden Erfindung besteht in der Bereitstellung eines verbesserten Verfahrens zur Musikerkennung durch Auffinden von Notenfolgen, die einer Referenz-Notenfolge in einer Datenbank mit Original-Notenfolgen Ã¤hnlich sind.On Another object of the present invention is to provide an improved method of music recognition by discovery of note sequences using a reference note sequence in a database Original note strings are similar.\n\nÃBERBLICK ÃBER DIE ERFINDUNGOVERVIEW OF THE INVENTION\n\nDie Erfindung gemÃ¤Ã den beiliegenden AnsprÃ¼chen stellt ein Verfahren und ein System bereit, welches in der Lage ist, das vorkommen einer Zeichenfolge in einer oder mehreren Original-Zeichenketten in einer Datenbank mit Original-Zeichenketten zu finden, das einer anderen als Referenz-Zeichenfolge bezeichneten Zeichenfolge identisch oder Ã¤hnlich ist. Die Erfindung weist eine hohe Wahrscheinlichkeit auf, alle FÃ¤lle der Zeichenfolgen in den Original-Zeichenketten schnell und prÃ¤zise aufzufinden, die mit der Referenz-Zeichenfolge ganz (identisch) oder fast genau Ã¼bereinstimmen.The invention according to the appended claims provides a method and a system capable of finding the occurrence of a string in one or more original strings in a database of original strings, that of another string referred to as a reference string is identical or similar. The invention has a high probability of quickly and precisely finding all cases of the strings in the original strings that match the reference string ge completely (identical) or almost exactly match.\n\nFÃ¼r jede Original-Zeichenkette wird eine groÃe Anzahl von Indizes erzeugt und zum Speichern eines die Original-Zeichenkette kennzeichnenden Datensatzes in einer Referenztabelle verwendet. WÃ¤hrend der Erkennungsphase wird aus einer Referenz-Zeichenkette eine groÃe Anzahl von Indizes gebildet. Diese dienen dazu, die Daten aus der Referenztabelle abzurufen und den Nachweis einer oder mehrerer Original-Zeichenketten abzuspeichern. Auf diese Weise kann die Verarbeitung zum groÃen Teil vor der Erkennungsphase stattfinden und somit die Erkennungszeit stark verkÃ¼rzt werden.For every original string will be a big one Number of indexes generated and for storing one that identifies the original character string Record used in a reference table. During the Recognition phase becomes a large number from a reference string formed by indices. These serve the data from the reference table and retrieve evidence of one or more original strings. In this way, processing can largely take place before the recognition phase take place and thus the recognition time is greatly reduced.\n\nZur Bildung von Indizes bildet das Verfahren zuerst âTupel\". Hierzu werden aus einer Original-Zeichenfolge in der Datenbank zuerst eine Anzahl aus zusammenhÃ¤ngenden Zeichen bestehender Original-Teilzeichenfolgen ausgewÃ¤hlt. Die LÃ¤nge jeder Original-Teilzeichenfolge dieses Satzes betrÃ¤gt nur wenige Zeichen, mindestens jedoch ein Zeichen. Die LÃ¤nge aller Teilzeichenfolgen des Satzes kann eine fest vorgegebene Anzahl von Zeichen betragen. Die LÃ¤nge einiger oder aller Teilzeichenfolgen des Satzes kann jedoch eine unterschiedliche Anzahl von Zeichen betragen. Unter Verwendung dieses Satzes von Original-Teilzeichenketten wird ein Satz von Tupeln gebildet. Mindestens ein Tupel dieses Satzes wird durch ZusammenfÃ¼gen mindestens zweier verschiedener, nicht zusammenhÃ¤ngender Teilzeichenfolgen des Satzes gebildet. (Andere Teilzeichenfolgen dieses Tupels oder in dem Satz von Tupeln kÃ¶nnen zusammenhÃ¤ngend oder nicht zusammenhÃ¤ngend sein.) Diese Tupel werden auch als âj-Tupel\" bezeichnet, wobei j die Anzahl der Original-Zeichenfolgen bedeutet, aus denen das Tupel gebildet wird. Die aus einer Original-Zeichenkette gebildeten Tupel heiÃen Originaltupel.to Forming indices, the process first forms \"tuples\". For this, an original string is created in the database first a number of related Characters of existing original substrings selected. The Length each The original substring of this sentence is only a few characters, at least however a sign. The length all substrings of the sentence can have a fixed number of characters. The length however, some or all of the substrings of the sentence can be one different number of characters. Using this A set of tuples is formed from the set of original substrings. At least one tuple of this sentence is at least put together two different, non-contiguous substrings of the Sentence. (Other substrings of this tuple or in the set of tuples coherently or not contiguous These tuples are also called \"j-tuples\", where j is the number of Original strings means from which the tuple is formed. The tuples formed from an original string are called original tuples.\n\nDann wird ein eindeutiger Index erzeugt und auf Basis der Werte der in dem Tupel enthaltenen Zeichen jedem Tupel zugewiesen. Die den Originaltupeln zugewiesenen Indizes heiÃen Originalindizes. Ãblicherweise werden die Originalindizes mittels eines Algorithmus aus den Werten der in den j-Tupeln enthaltenen Zeichen erzeugt und haben die Form eines Wertes wie zum Beispiel einer Zahl (normalerweise einer ganzen Zahl). Jeder Originalindex ist einer eindeutigen Zelle in einer Speicher-Referenzstruktur zugeordnet, Ã¼blicherweise einer Matrix. Der Index dient zur Identifizierung und/oder fÃ¼r den Zugriff auf eine zugehÃ¶rige eindeutige Zelle in der Referenzstruktur. In der zum Index gehÃ¶renden Zelle der Referenzstruktur ist ein Datensatz gespeichert, der eine Original-Zeichenkette beschreibt, aus welcher das Tupel (und der Originalindex) erzeugt wurde. Eine Zelle ist in der Lage, entweder eine fest vorgegebene oder eine beliebige Anzahl dieser DatensÃ¤tze zu speichern. Zum Beispiel kann ein in der Zelle gespeicherter Datensatz einen Verweis auf die Original-Zeichenkette enthalten. Dieser Verweis, der hier auch als Zeiger bezeichnet wird, stellt ein Mittel zur Kennzeichnung einer der Original-Zeichenketten dar. Man beachte, dass ein Verweis als Zeiger (die Speicheradresse) eines bestimmten Zeichens der Original-Zeichenkette oder als Index in einer Zeigertabelle oder nach einem anderen in der Technik bekannten Verfahren realisiert werden kann. Der Zeiger (Verweis) zeigt diejenige Original-Zeichenkette in der Datenbank an, von welcher das durch den Originalindex eindeutig definierte Originaltupel abgeleitet wurde. Die Referenzstruktur kann auch weitere als Verschiebungswert bezeichnete Daten enthalten, welche die Position des (zur Erzeugung des Indexes verwendeten) Tupels in der Original-Zeichenkette angibt. Zu diesen Positionsdaten kÃ¶nnen gehÃ¶ren: 1. eine Verschiebung von einer bestimmten Position (Zeichen) der Original-Zeichenkette zum ersten Zeichen der ersten Original-Teilzeichenkette, die zur Bildung des Tupels dient oder 2. eine Verschiebung, die gleich der mittleren Position des ersten Zeichens aller Original-Teilzeichenketten ist, welche das Tupel bilden oder 3. eine andere Verschiebung, die aus der Position mehrerer Zeichen in einer oder mehreren Original-Teilzeichenketten berechnet werden kann.Then a unique index is generated and based on the values of the characters contained in the tuple assigned to each tuple. The original tuples assigned indices are called Stock indexes. Usually are the original indices using an algorithm from the values of the characters contained in the j-tuples and have the form a value such as a number (usually an integer). Each original index is a unique cell in a memory reference structure assigned, usually a matrix. The index is used for identification and / or access on an associated unique cell in the reference structure. In the cell belonging to the index A record is stored in the reference structure, which is an original string describes from which the tuple (and the original index) was generated. A cell is capable of either a predefined or store any number of these records. For example a record stored in the cell can reference the original string contain. This reference, which is also referred to here as a pointer, provides a means of identifying one of the original strings Note that a reference as a pointer (the memory address) of a certain character of the original string or as an index in a pointer table or another known in the art Procedure can be realized. The pointer (reference) shows that Original character string in the database, from which the by derived the original index clearly defined original tuple has been. The reference structure can also be used as a displacement value contain designated data, which the position of the (for generation of the index used) tuple in the original string. For this position data can belong: 1. a shift from a specific position (character) to the Original character string for the first character of the first original substring, which is used to form the tuple or 2. a shift that equal to the middle position of the first character of all original substrings which is the tuple, or 3. another shift that from the position of several characters in one or more original substrings can be calculated.\n\nNach der Verarbeitung aller gewÃ¼nschten Original-Zeichenketten wird die Referenz-Zeichenfolge mit den Original-Zeichenketten verglichen. Hierzu werden mittels der oben beschriebenen oder einer Ã¤hnlichen Prozedur aus einer Referenz-Zeichenfolge Referenztupel und deren eindeutig kennzeichnende Referenzindizes gebildet.To processing all desired Original strings becomes the reference string with the original strings compared. To do this, use the procedure described above or a similar procedure from a reference string reference tuple and its unique characteristic reference indices are formed.\n\nDie Referenzindizes werden unter Verwendung der oben beschriebenen Referenzstruktur mit den Originalindizes verglichen. Ein Referenzindex dient dazu, auf eine Zelle in der Referenzstruktur zu zeigen. Wenn dieser Referenzindex auf eine Zelle zeigt, welche einen oder mehrere DatensÃ¤tze fÃ¼r Original-Zeichenketten enthÃ¤lt, erhÃ¤lt man eine oder mehrere passende Ãbereinstimmungen. Wenn der Referenzindex auf eine Zelle ohne Daten zeigt, erhÃ¤lt man keine Ãbereinstimmung.The Reference indices are created using the reference structure described above compared to the original indices. A reference index is used to to point to a cell in the reference structure. If this reference index pointing to a cell that contains one or more data records for original character strings, you get one or several matching matches. If the reference index points to a cell with no data, no match is obtained.\n\nFÃ¼r jede in der durch den Referenzindex indexierten Zelle gespeicherten Datensatz wird ein ZÃ¤hlwert in einer zweiten Datenstruktur mit der Bezeichnung Nachweis-Sammeltabelle EIT (Evidence Integration Table) gespeichert, die zur Erfassung der Anzahl der Ãbereinstimmungen fÃ¼r eine bestimmte Original- Zeichenkette dient. Ãblicherweise ist dies eine Hash-Tabelle. In dieser zweiten Struktur adressierte Zellen entsprechen Hypothesen Ã¼ber Original-Zeichenketten, die mit der Referenz-Zeichenkette Ã¼bereinstimmen. Die Zellen enthalten auch einen Wert, der anzeigt, wie oft eine Hypothese gezÃ¤hlt wurde. Zum Beispiel entsprechen die ZÃ¤hlwerteintrÃ¤ge in einer ZÃ¤hlzelle in dieser zweiten Struktur den ZÃ¤hlwerten bestimmter Zeichenketten in der Ausgangs-Datenbank. Je Ã¤hnlicher die Referenz-Zeichenfolge einer Zeichenfolge in einer Original-Zeichenkette in der Datenbank ist, desto hÃ¶her ist die Wahrscheinlichkeit, dass zwischen den Referenzindizes der Referenz-Zeichenfolge und den Originalindizes der Original-Zeichenkette mehr Ãbereinstimmungen vorkommen. Die ZÃ¤hlzellen in der zweiten Speicherstruktur, welche Original-Zeichenketten entsprechen, die den Referenz-Zeichenketten Ã¤hnlich oder identisch sind, weisen eine relativ hohe Anzahl von ZÃ¤hlwerten auf. Umgekehrt ist die Wahrscheinlichkeit der Ãbereinstimmung zwischen den Referenzindizes und den Originalindizes, die jedem aus der Original-Zeichenkette gebildeten Tupel eindeutig zugeordnet sind, umso geringer, je weniger die Referenz-Zeichenfolge mit den Zeichenfolgen in der Original-Zeichenkette Ã¼bereinstimmt. ZÃ¤hlzellen in der EIT, die diesen FÃ¤llen entsprechen, enthalten nur wenige oder Ã¼berhaupt keine ZÃ¤hlwerte. Deshalb weist die Anzahl der ZÃ¤hlwerte in jeder ZÃ¤hlzelle der EIT eine direkte Korrelation zum Ãbereinstimmungsgrad zwischen der durch die Zelle dargestellten Original-Zeichenkette und der Referenz-Zeichenfolge auf.For each data record stored in the cell indexed by the reference index, a count value is stored in a second data structure called Evidence Integration Table (EIT), which is used to record the number of matches for a specific original character string. This is usually a hash table. Cells addressed in this second structure correspond to Hy prostheses over original strings that match the reference string. The cells also contain a value that indicates how many times a hypothesis has been counted. For example, the counter value entries in a counter cell in this second structure correspond to the counter values of certain character strings in the output database. The more similar the reference string to a string in an original string in the database, the higher the likelihood that there will be more matches between the reference strings of the reference string and the original indices of the original string. The count cells in the second memory structure, which correspond to original character strings that are similar or identical to the reference character strings, have a relatively high number of count values. Conversely, the less the reference string matches the strings in the original string, the less likely the match between the reference indices and the original indices, which are uniquely assigned to each tuple formed from the original string. Counting cells in the EIT that correspond to these cases contain little or no counting values. Therefore, the number of counts in each count cell of the EIT has a direct correlation to the degree of agreement between the original string represented by the cell and the reference string.\n\nUnd schlieÃlich dienen die Daten der EIT dazu, die Position derjenigen Zeichenfolgen in einer Original-Zeichenkette in der Datenbank anzugeben, die der Referenz-Zeichenfolge (genau oder annÃ¤hernd) entsprechen. Zuerst werden Zellen der EIT mit einem Wert ausgewÃ¤hlt, der oberhalb eines vorgegebenen Schwellenwertes liegt. Dann werden mit einem oder mehreren zugehÃ¶rigen Zeigern eine oder mehrere Original-Zeichenketten in der Datenbank gesucht. Und schlieÃlich wird die Ã¼bereinstimmende Zeichenfolge der Original-Zeichenkette mittels der zu dem ausgewÃ¤hlten Index bzw. zu den ausgewÃ¤hlten Indizes gehÃ¶renden Verschiebungswerte gefunden.And finally the data of the EIT serve to determine the position of those strings in an original string in the database that the Match reference string (exact or approximate). First cells of the EIT are selected with a value that is above a predetermined threshold lies. Then one or more associated pointers become one or more Original strings searched in the database. And finally it will the matching one String of the original string using the to the selected index or to the selected ones Belonging to indices Displacement values found.\n\nKURZBESCHREIBUNG DER ZEICHNUNGENBRIEF DESCRIPTION OF THE DRAWINGS\n\n1 zeigt ein Ablaufdiagramm des Gesamtverfahrens der Erfindung. 1 shows a flow diagram of the overall method of the invention.\n\n2 zeigt eine Original-Zeichenkette und eine an der Position pi der Original-Zeichenkette beginnende Teilzeichenkette mit der LÃ¤nge von l Zeichen. 2 shows an original character string and a substring beginning at position p i of the original character string with the length of l characters.\n\n3 zeigt die bevorzugte AusfÃ¼hrungsart einer Referenzstruktur. 3 shows the preferred embodiment of a reference structure.\n\n4 zeigt eine alternative AusfÃ¼hrungsart einer Referenzstruktur. 4 shows an alternative embodiment of a reference structure.\n\n5 zeigt die bevorzugte AusfÃ¼hrungsart einer Nachweis-Sammeltabelle (EIT). 5 shows the preferred embodiment of a proof collection table (EIT).\n\n6 ist ein Ablaufdiagramm eines Computerprogramms, das Originaltupel und Originalindizes erzeugt und die zugehÃ¶rigen DatensÃ¤tze in der Referenzstruktur speichert. 6 is a flow diagram of a computer program that generates original tuples and original indices and stores the associated data records in the reference structure.\n\n7 ist ein Ablaufdiagramm des Computerprogramms, das Referenztupel und Referenzindizes erzeugt, die Referenzindizes mit den Originalindizes vergleicht und die EIT aktualisiert. 7 is a flowchart of the computer program that generates reference tuples and reference indices, compares the reference indices with the original indices, and updates the EIT.\n\n8 ist eine Tabelle der verwendeten Symbole. 8th is a table of symbols used.\n\nDETAILLIERTE BESCHREIBUNG DER ERFINDUNGDETAILED DESCRIPTION OF THE INVENTION\n\nDas vorliegende Verfahren ist dazu vorgesehen, in Mehrzweckcomputern angewendet zu werden, die zur AusfÃ¼hrung der durch das Verfahren benÃ¶tigten Hash- und Referenzfunktionen in der Lage sind. Der Computer benÃ¶tigt auch ausreichend SpeicherkapazitÃ¤t, um alle Zeichen der Original-Zeichenketten und die durch das Verfahren verwendeten Datenstrukturen zu speichern.The The present method is intended to be used in general-purpose computers to be applied to the execution of the procedure required Hash and reference functions are capable. The computer also needs sufficient storage capacity, around all characters of the original strings and those through the procedure save used data structures.\n\nDas allgemeine Verfahren der Erfindung ist im Blockschaltbild von 1 gezeigt. Das Verfahren beginnt in Block 10 durch AuswÃ¤hlen einer Original-Zeichenkette 10 aus einer Datenbank. Dann wird die Zeichenkette in Block 15 in Teilzeichenketten mit zusammenhÃ¤ngenden Zeichen aufgeteilt, von denen mindestens zwei nicht zusammenhÃ¤ngend zusammengefÃ¼gt sind, um in Block 20 Originaltupel zu bilden. Die Originaltupel dienen der Erzeugung von Originalindizes in Block 25, die dann in Block 30 zur Speicherung von Daten in einer Zelle der Referenzstruktur dienen, welche zum Index und zur Original-Zeichenkette gehÃ¶ren. Diese Prozedur wird in Block 32 fÃ¼r jede zu untersuchende Original-Zeichenkette der Datenbank wiederholt. Auf Ã¤hnliche Weise werden aus der Referenz-Zeichenfolge die Referenzindizes erzeugt. Insbesondere wird die Referenz-Zeichenfolge in Block 35 in Teilzeichenfolgen von zusammenhÃ¤ngenden Zeichen aufgeteilt, von denen mindestens zwei in Block 40 nicht zusammenhÃ¤ngend zusammengefÃ¼gt werden, um Referenztupel zu bilden. Mittels desselben Verfahrens wie bei der Erzeugung von Originalindizes aus Originaltupeln werden in Block 45 Referenzindizes aus Referenztupeln erzeugt. Dann werden die Referenzindizes in Block 50 mit den Originalindizes verglichen. Die Anzahl der mit den Originalindizes Ã¼bereinstimmenden Referenzindizes wird in Block 55 in einer Nachweis-Sammeltabelle (EIT) erfasst. Das Vergleichen und Erfassen kann so lange wiederholt werden, bis alle (oder ein Teil) der Referenzindizes mit den Originalindizes verglichen worden sind. Die Werte der gespeicherten Zahlen fÃ¼r die Ãbereinstimmung zwischen den Originalindizes und den Referenzindizes werden dann in Block 60 dazu verwendet, um diejenigen Original-Zeichenketten herauszufinden, die der Referenz-Zeichenkette am Ã¤hnlichsten sind. Weitere zum Originalindex gehÃ¶rende Daten dienen in Block 65 zur Suche nach der Position derjenigen Zeichenfolge in der Original-Zeichenkette, welche fast oder ganz genau mit der Referenz-Zeichenfolge Ã¼bereinstimmt. In Block 70 werden auf dieselbe Weise weitere Referenz-Zeichenketten verarbeitet und mit den Original-Zeichenketten verglichen.The general method of the invention is in the block diagram of FIG 1 shown. The process begins in block 10 by selecting an original string 10 from a database. Then the string is in block 15 divided into substrings with contiguous characters, at least two of which are not joined together to block 20 Form original tuple. The original tuples are used to generate original indices in blocks 25 which then in block 30 serve to store data in a cell of the reference structure that belongs to the index and the original character string. This procedure is in block 32 repeated for each original database string to be examined. The reference indices are generated in a similar manner from the reference string. In particular, the reference string is in block 35 divided into substrings of related characters, of which at least two in block 40 not joined together to form a reference tuple. Using the same procedure as for the generation of original indices from original tuples are in block 45 Reference indices generated from reference tuples. Then the reference indices in block 50 compared to the original indices. The number of reference indices matching the original indices is in block 55 recorded in a collection table (EIT). The comparison and detection can be repeated until all (or a part) of the reference indices have been compared with the original indices. The values of the stored numbers for the match between the original indices and the reference indices are then in block 60 used to find out those original strings that are most similar to the reference string. Further data belonging to the original index serve in block 65 to search for the position of the character string in the original character string that almost or exactly matches the reference character string. In block 70 other reference strings are processed in the same way and compared with the original strings.\n\nDas Verfahren beginnt zunÃ¤chst mit einer Datenbank mit Original-Zeichenketten X mit unterschiedlicher (oder gleicher) Zeichenanzahl. Ãblicherweise sind diese Zeichenfolgen in einer zur Speicherung von Zeichenfolgen geeigneten Weise an einem Speicherplatz im Computerspeicher gespeichert. Zum Beispiel wird, wenn in der Datenbank eine groÃe Anzahl von Proteinketten dargestellt werden soll, jedem der mÃ¶glichen AminosÃ¤urezeichen im Protein ein alphanumerisches Zeichen zugewiesen. Bei diesen Zeichen kann es sich um ASCII-Zeichen handeln. Jede Proteinkette wird dann durch eine ASCII-Zeichenkette in aufeinander folgenden SpeicherplÃ¤tzen des Computers dargestellt. Der Beginn einer Proteinkette kann durch einen Zeiger angezeigt werden, der auf das erste ASCII-Zeichen der Zeichenkette zeigt, und das Ende der Proteinkette kann durch einen Begrenzer wie etwa das Zeichen â0\" angezeigt werden. Allgemein wird die Menge X der Original-Zeichenketten in der Datenbank durch X â¡ {Ïi; i = 1, ..., NÏ} dargestellt.The process begins with a database with original character strings X with different (or the same) number of characters. Typically, these strings are stored in a location in computer memory in a manner suitable for storing strings. For example, if a large number of protein chains are to be displayed in the database, an alphanumeric character is assigned to each of the possible amino acid characters in the protein. These characters can be ASCII characters. Each protein chain is then represented by an ASCII string in successive memory locations on the computer. The beginning of a protein chain can be indicated by a pointer pointing to the first ASCII character of the character string and the end of the protein chain can be indicated by a delimiter such as the character \"0\". In general, the set X becomes the original character strings represented in the database by X â¡ {Ï i ; i = 1, ..., N Ï }.\n\nAnschlieÃend wird jede Original-Zeichenkette Ï in der Datenbank X in zwei oder mehrere Original-Teilzeichenketten mit zusammenhÃ¤ngenden Zeichen Î¼ aufgeteilt. Zur Veranschaulichung zeigt 2 eine Original-Zeichenkette Ï 200, in der jedes Zeichen 205 durch Ï bezeichnet wird. Das Zeichen Ïi 207 bezeichnet das Zeichen Ï an der Position i 220 der Original-Zeichenkette Ï 200. 2 zeigt ferner, dass durch eine Original-Teilzeichenkette zusammenhÃ¤ngender und aufeinander folgender Zeichen 210 aus der Original-Zeichenkette bezeichnet wird, die bei dem Zeichen an der Position 220 (pi) beginnt und eine LÃ¤nge von l Zeichen 225 hat. Durch Aufteilen der Original-Zeichenkette wird eine Gruppe von Original-Teilzeichenketten 210 gebildet. Diese wird durch dargestellt. Jede Original-Teilzeichenkette beginnt an einer Position pk der Original-Zeichenkette und hat jeweils eine LÃ¤nge lk. Zum Beispiel ist die Original-Teilzeichenkette Î¼(5,14) eine Teilzeichenkette aus der Original-Zeichenkette, die an der fÃ¼nften Position der Original-Zeichenkette beginnt und die folgenden 13 Zeichen der Original-Zeichenkette enthÃ¤lt, wodurch die Teilzeichenkette eine LÃ¤nge von 14 Zeichen hat. In manchen FÃ¤llen ist die LÃ¤nge lk einiger oder aller Original-Teilzeichenketten gleich der LÃ¤nge anderer Original-Teilzeichenketten in dieser Gruppe. Eine Original-Teilzeichenkette muss eine LÃ¤nge von mindestens einem Zeichen haben.Subsequently, each original character string Ï in the database X is divided into two or more original substrings with connected characters Î¼. Illustrative shows 2 an original string Ï 200 in which each character 205 is denoted by Ï. The character Ï i 207 denotes the character Ï at position i 220 the original string Ï 200 , 2 further shows that by an original substring of contiguous and consecutive characters 210 from the original string is referred to that at the character at the position 220 (p i ) begins and has a length of 1 characters 225 Has. Splitting the original string creates a group of original substrings 210 educated. This is through shown. Each original substring begins at a position p k of the original string and has a length l k . For example, the original substring Î¼ (5,14) is a substring from the original string that starts at the fifth position of the original string and contains the following 13 characters of the original string, making the substring 14 characters long Has. In some cases, the length l k of some or all of the original substrings is equal to the length of other original substrings in this group. An original substring must have a length of at least one character.\n\nEine Gruppe von K jeweils mit Î¾k bezeichneten Originaltupeln wird durch ZusammenfÃ¼gen von j Original-Teilzeichenketten gebildet, wobei j gleich zwei oder grÃ¶Ãer ist. Mindestens eines der Tupel in dieser Gruppe wird durch ZusammenfÃ¼gen von mindestens zwei nicht zusammenhÃ¤ngenden Original-Teilzeichenketten miteinander gebildet. An dieses Tupel kÃ¶nnen weitere zusammenhÃ¤ngende Teilzeichenketten angehÃ¤ngt werden. Andere Tupel in dieser Gruppe kÃ¶nnen auch durch ZusammenfÃ¼gen zusammenhÃ¤ngender Teilzeichenketten miteinander gebildet werden (siehe Block 20 in 1). Dabei ist zu beachten, dass zwei Zeichenfolgen als zusammenhÃ¤ngend anzusehen sind, wenn das erste Zeichen der zweiten Teilzeichenkette auf das letzte Zeichen der ersten Teilzeichenkette in der Original-Zeichenkette folgt.A group of K original tuples, each denoted by Î¾ k , is formed by combining j original substrings, where j is two or more. At least one of the tuples in this group is formed by joining together at least two non-contiguous original substrings. Additional contiguous substrings can be appended to this tuple. Other tuples in this group can also be formed by joining together sub-strings (see block 20 in 1 ). It should be noted that two strings are considered to be contiguous if the first character of the second substring follows the last character of the first substring in the original string.\n\nEin durch eine Anzahl j von Original-Teilzeichenketten gebildetes Originaltupel wird als Original-j-Tupel bezeichnet. Ein j-Tupel der LÃ¤nge L wird durch das Symbol Î¾(j,L) dargestellt. Die Original-Teilzeichenketten im j-Tupel werden hier durch beschrieben. Man beachte, dass die LÃ¤nge der Original-Teilzeichenketten in manchen FÃ¤llen gleich sein kann.An original tuple formed by a number j of original substrings is referred to as an original j tuple. A j-tuple of length L is represented by the symbol Î¾ (j, L) . The original substrings in the j tuple are shown here described. Note that the length of the original substrings can be the same in some cases.\n\nTupel kÃ¶nnen mittels einer Vielzahl von Algorithmen durch Aneinanderreihung von Teilzeichenketten gebildet werden, diese Algorithmen bilden jedoch im Wesentlichen zwei Gruppen, nÃ¤mlich probabilistische und deterministische Algorithmen. Die mittels probabilistischer Algorithmen erzeugten Tupel unterliegen eher dem Zufall, d. h. bei Anwendung desselben Algorithmus auf dieselbe Gruppe von Original-Teilzeichenketten erhÃ¤lt man wahrscheinlich jedes Mal einen anderen Satz von Tupeln. Ein deterministischer Algorithmus hingegen erzeugt jedes Mal aus einer bestimmten Gruppe von Original-Teilzeichenketten denselben Satz von Tupeln.tuple can using a variety of algorithms by stringing together Substrings are formed, but these algorithms form essentially two groups, namely probabilistic and deterministic algorithms. The means of probabilistic Algorithms generated tuples are more of a coincidence, i. H. at Apply the same algorithm to the same set of original substrings you get probably a different set of tuples each time. A deterministic Algorithm, on the other hand, generates each time from a certain group of original substrings the same set of tuples.\n\nZum Beispiel wird ein probabilistischer Algorithmus dazu eingesetzt, um aus einer Gruppe von 17 Teilzeichenketten mit einer LÃ¤nge von je zwei Zeichen einen Satz von Dreiertupeln (ein Tupel wird durch ZusammenfÃ¼gen von 3 Teilzeichenketten gebildet) zu erzeugen. Der Algorithmus wÃ¤hlt zufÃ¤llig eine der 17 Teilzeichenketten aus, dann eine der 16 restlichen Teilzeichenketten, dann eine der 15 restlichen Teilzeichenketten und fÃ¼gt die drei ausgewÃ¤hlten Teilzeichenketten zusammen, um das erste Dreiertupel des Satzes zu bilden. Die Prozedur wird dann beliebig oft wiederholt, z. B. 100 Mal, bis 100 Dreiertupel gebildet sind. Sehr wahrscheinlich unterscheidet sich der erste Satz von 100 Dreiertupeln, die auf diese Weise aus einer Original-Zeichenkette (Teilzeichenketten) gebildet wurden, vom nÃ¤chsten Satz von 100 Dreiertupeln, die wiederum mittels desselben Algorithmus aus derselben Original-Teilzeichenkette gebildet wurden. Ungeachtet dessen bildet diese Art von Algorithmus einen Satz von j-Tupeln, die durch die vorliegende Erfindung verwendet werden kÃ¶nnen.To the Example a probabilistic algorithm is used to order from a group of 17 substrings with a length of two characters a set of three-tuples (a tuple is replaced by Put together formed by 3 substrings). The algorithm chooses one at random of the 17 substrings, then one of the 16 remaining substrings, then one of the 15 remaining substrings and adds the three chosen Substrings together to form the first triplet of the set to build. The procedure is then repeated as often as necessary, e.g. B. 100 times until 100 triplets are formed. Most likely the first set of 100 triplet tuples that differ on this way from an original string (Substrings) were formed from the next set of 100 triplets, which in turn use the same algorithm from the same original substring were formed. Regardless, this type of algorithm forms a set of j-tuples used by the present invention can be.\n\nBeim vorliegenden Verfahren stellt der deterministische Algorithmus den bevorzugten Algorithmus zur Erzeugung von Tupeln dar. Zum Beispiel wird ein deterministischer Algorithmus zur Erzeugung von Dreiertupeln aus 17 Original-Teilzeichenketten der LÃ¤nge 2 verwendet, indem er die am 1., 5. und 9. Zeichen der Original-Zeichenkette beginnenden Teilzeichenketten an die am 3., 7, und 11. Zeichen der Original-Zeichenkette beginnenden Teilzeichenketten anfÃ¼gt. Dieser einfache Algorithmus erzeugt einen Satz von Dreiertupeln, die jedes Mal wieder entstehen, wenn der Algorithmus auf dieselbe Original-Zeichenkette und dieselben Original-Teilzeichenketten angewendet wird. Anhand der vorliegenden Beschreibung kann ein Fachmann eine groÃe Anzahl deterministischer Algorithmen dieser Art entwickeln, die verschieden lange Teilzeichenketten, unterschiedlich viele (zwei oder mehr) zu einem Tupel verknÃ¼pfte Teilzeichenketten und verschiedene Verfahren zur VerknÃ¼pfung der Teilzeichenketten miteinander verwenden. Die Verwendung dieser vielen Varianten wird in der vorliegenden Erfindung dargelegt.At the the deterministic algorithm preferred algorithm for generating tuples. For example becomes a deterministic algorithm for generating triplets from 17 original substrings the length 2 used by adding the 1st, 5th and 9th characters of the original string partial strings beginning on the 3rd, 7th and 11th characters of the Appends original string to beginning substrings. This simple algorithm generates a set of triplets, each Again arise when the algorithm is on the same original string and the same original substrings are used. Based a large number of those skilled in the art can use this description deterministic algorithms of this kind develop that different long substrings, different numbers (two or more) linked into a tuple Substrings and various methods of linking the Use substrings together. The use of these many Variants are set out in the present invention.\n\nEs gibt jedoch einen besonders bevorzugten deterministischen Algorithmus zur Erzeugung von Tupeln fÃ¼r die vorliegende Erfindung, der im Folgenden beschrieben wird. Dieser besonders bevorzugte Algorithmus, der sich durch die begrenzte Anzahl von Tupeln zur Erreichung eines bestimmten Genauigkeitsgrades auszeichnet, wird im Folgenden allgemein beschrieben:It however gives a particularly preferred deterministic algorithm to generate tuples for the present invention, which is described below. This particularly preferred algorithm, which is characterized by the limited number tuples to achieve a certain level of accuracy, is generally described below:\n\nFÃ¼r jede Zeichenfolge der LÃ¤nge LS, jedes gewÃ¼nschte j-Tupel der LÃ¤nge L und jede Ordnung j des Tupels ist eine Reihe von ganzen Zahlen, d. h. TeilzeichenkettenlÃ¤ngen (l1, l2, ..., lj), so zu ermitteln, dass Î£lm = L (mit m = 1 bis j) ist.For each character string of length L S , each desired j-tuple of length L and every order j of the tuple, a series of integers, ie partial character lengths (l 1 , l 2 , ..., l j ), must be determined that Î£l m = L (with m = 1 to j).\n\nDann sind alle j-Tupel eines Satzes k zu bilden, der beschrieben wird durch wobei fÃ¼r jedes Glied k aus dem Satz von j-Tupeln die ersten Zeichenpositionen (p1, p2, ..., pj) der durch Aufteilung aus der Original-Zeichenkette gebildeten und das Tupel bildenden Teilzeichenkette so ausgewÃ¤hlt werden, dass sie den folgenden Regeln genÃ¼gen:\n\n1. â a und b, sodass 1 â¤ a < b â¤ j und pa < pb\n\n2. â a, sodass 1 â¤ a â¤ j und pa + la â¤ j\n\n3. â a und b, sodass 1 â¤ b â¤ j und Î» â / ab < pb â pa < Î» + / ab,\n\nwobei Î» â / ab und Î» + / ab eine Anzahl a priori festgelegter unterer und oberer Schwellenwerte sind.Then all j-tuples of a set k, which is described by wherein for each link k from the set of j-tuples the first character positions (p 1 , p 2 , ..., p j ) of the partial character string formed by division from the original character string and forming the tuple are selected such that they match the the following rules are sufficient:\n\n1. â a and b such that 1 â¤ a <b â¤ j and p a <p b\n\n2. â a, so that 1 â¤ a â¤ j and p a + l a â¤ j\n\n3. â a and b such that 1 â¤ b â¤ j and Î» - / ab <p b - p a <Î» + / ab,\n\nwhere Î» - / ab and Î» + / ab are a number of predetermined lower and upper threshold values.\n\nDie bevorzugten Regeln zur deterministischen Erzeugung von Tupeln kÃ¶nnen alternativ wie folgt beschrieben werden:\n\n1. Gleichung 1 besagt, dass fÃ¼r die Startposition pa einer der das Tupel bildenden Zeichenketten die das j-te Tupel bildenden nachfolgenden Teilzeichenketten nur eine Startposition grÃ¶Ãer als pa haben kÃ¶nnen, d. h. dass die nachfolgenden Teilzeichenketten des Tupels vom Beginn der Original-Zeichenkette an gerechnet spÃ¤ter beginnen mÃ¼ssen. Hierdurch werden die Tupel in ihrer Reihenfolge erzeugt.\n\n2. Gleichung 2 besagt, keine Teilzeichenkette an einer Position beginnen kann, von der aus die Teilzeichenkette Ã¼ber die GesamtlÃ¤nge der Original-Zeichenkette hinausragen wÃ¼rde.\n\n3. Gleichung 3 besagt, dass sich beim Vorliegen zweier a priori festgelegter Schwellenwerte Î» â / ab und Î» + / ab, die als minimaler und maximaler KohÃ¤renzradius bezeichnet werden, die Startpositionen pa und pb zweier aufeinander folgender Teilzeichenketten nicht um mehr als Î» + / ab und um weniger als Î» â / ab unterscheiden kÃ¶nnen. Gleichung 3 hat die grÃ¶Ãte Bedeutung fÃ¼r die Begrenzung der Anzahl der durch diesen Algorithmus erzeugten Tupel.\n\nThe preferred rules for the deterministic generation of tuples can alternatively be described as follows:\n\n1. Equation 1 states that for the starting position p a of one of the character strings forming the tuple, the subsequent partial character strings forming the jth tuple can only have a starting position larger than p a , ie that the subsequent partial character strings of the tuple from the beginning of the original character string have to start later. This creates the tuples in their order.\n\n2. Equation 2 states that no substring can begin at a position from which the substring would protrude beyond the entire length of the original string.\n\n3. Equation 3 states that when there are two a priori defined threshold values Î» - / ab and Î» + / ab, which are called the minimum and maximum coherence radius, the starting positions p a and p b of two successive substrings do not differ by more than Î» + / ab and can distinguish by less than Î» - / ab. Equation 3 is of greatest importance for limiting the number of tuples generated by this algorithm.\n\nDieser besonders bevorzugte deterministische Algorithmus wird durch ein Beispiel veranschaulicht. Eine Original-Zeichenkette hat eine LÃ¤nge von 18 Zeichen, d. h. Ls = 18. Aus einem Satz von 17 Original-Teilzeichenketten mit einer LÃ¤nge von je 2 Zeichen wird ein Satz von Dreiertupeln gebildet. Alle Tupel des erzeugten Satzes von Originaltupeln haben eine LÃ¤nge von 6 Zeichen (L = 6) und werden durch ZusammenfÃ¼gen von 3 Teilzeichenketten gebildet (j = 3). Man beachte, dass es 17 Teilzeichenketten gibt, da die Gruppe der Teilzeichenketten so gebildet wird, dass die erste Teilzeichenkette beginnend an der Zeichenposition p = 1, die zweite Teilzeichenkette beginnend bei p = 2 usw. erzeugt wird, bis die letzte Teilzeichenkette beginnend bei p = 17 erzeugt wird. Mit anderen Worten, die Gruppe M der Original-Teilzeichenketten besteht aus den folgenden 17 Teilzeichenketten: Î¼(1,2) Î¼(2,2), ..., Î¼(17,2). Legt man alle mÃ¶glichen geordneten Kombinationen von 3 zusammenhÃ¤ngenden bzw. nicht zusammenhÃ¤ngenden Teilzeichenketten diesem Satz von 17 Teilzeichenketten zugrunde, kann man 680 Dreiertupel erzeugen. Mit anderen Worten,This particularly preferred deterministic algorithm is illustrated by an example. An original character string has a length of 18 characters, ie L s = 18. A set of triplets is formed from a set of 17 original substrings with a length of 2 characters each. All tuples of the generated set of original tuples have a length of 6 characters (L = 6) and are formed by combining 3 partial character strings (j = 3). Note that there are 17 substrings because the group of substrings is formed so that the first substring is created starting at the character position p = 1, the second substring starting at p = 2, and so on until the last substring starts at p = 17 is generated. In other words, the group M of the original substrings consists of the following 17 substrings: Î¼ (1.2) Î¼ (2.2) , ..., Î¼ (17.2) . If one bases all possible ordered combinations of 3 contiguous or non-contiguous substrings on this set of 17 substrings, 680 triple tuples can be generated. In other words,\n\nWenn man jedoch die drei obigen Regeln anwendet, wird durch Definieren der KohÃ¤renzradien zu Î» â / 12 = Î» â / 23 = 0, Î» â / 12 = Î» â / 23 = 3, Î» â / 13 = 0 und Î» â / 13 = 20 ein deterministischer Satz von 42 Dreiertupeln erzeugt. Wendet man die Kriterien dieser 3 Regeln an, wÃ¤re ein Dreiertupel Î¾ (3,6) / gut = Î¼(5,2) + Î¼(7,2) + Î¼(8,2) zugelassen, wohingegen das Tupel Î¾ (3,6) / schlecht = Î¼(5,2) + Î¼(9,2) + Î¼(10,2) nicht zugelassen wÃ¤re, schlecht da p2 â p1 = 4 â¤ Î»12 = 3 ist. Durch geeignete Auswahl der Werte fÃ¼r die KohÃ¤renzradien kann die Gesamtzahl der erzeugten Tupel und Indizes nach Belieben gewÃ¤hlt werden.However, if one applies the three rules above, by defining the coherence radii, Î» - / 12 = Î» - / 23 = 0, Î» - / 12 = Î» - / 23 = 3, Î» - / 13 = 0 and Î» - / 13 = 20 a deterministic set of 42 triplets is generated. Applying the criteria of these 3 rules, a triple tuple Î¾ (3.6) / good = Î¼ (5.2) + Î¼ (7.2) + Î¼ (8.2) would be permitted, whereas the tuple Î¾ (3, 6) / bad = Î¼ (5.2) + Î¼ (9.2) + Î¼ (10.2) would not be allowed, bad because p 2 - p 1 = 4 â¤ Î» 12 = 3. By appropriately selecting the values for the coherence radii, the total number of tuples and indices generated can be chosen at will.\n\nIm nÃ¤chsten Schritt, der in Kasten 25 von 1 gezeigt ist, werden fÃ¼r jedes der aus einer Original-Zeichenkette gebildete Tupel eindeutige Originalindizes erzeugt. GemÃ¤Ã der Beschreibung der vorliegenden Erfindung kann ein erfahrener Programmierer eine Vielzahl von Verfahren entwickeln, die man zur Erzeugung von Originalindizes fÃ¼r jedes dieser Originaltupel einsetzen kann. Bei diesen Verfahren werden Ã¼blicherweise Zuordnungsverfahren, Hash-Tabellen oder Algorithmen zum Umwandeln jedes Originaltupels in einen Originalindex verwendet, der eindeutig anzeigt, von welchem Tupel er stammt.In the next step, the one in box 25 of 1 is shown, unique original indices are generated for each of the tuples formed from an original character string. In accordance with the description of the present invention, an experienced programmer can develop a variety of methods that can be used to generate original indexes for each of these original tuples. These methods typically use mapping methods, hash tables, or algorithms to convert each original tuple to an original index that clearly indicates which tuple it comes from.\n\nBei der bevorzugten AusfÃ¼hrungsart werden eindeutige Indizes Î³ dadurch erzeugt, indem man zuerst jedem mÃ¶glichen Zeichenwert in der Original-Zeichenkette einen Wert, z. B. einen numerischen Wert, zuweist. Dadurch entsteht aus der Original-Zeichenkette und somit auch aus den Teilzeichenketten und den Tupeln eine Folge numerischer Werte, welche ihre jeweiligen Zeichen darstellen. Im Allgemeinen wird fÃ¼r jedes Zeichen Ï eine eindeutige Zahl Ïj zwischen 0 und nÏ (0 â¤ Ïj â¤ nÏ) gewÃ¤hlt. Zum Beispiel werden in einer aus Nukleotiden bestehenden DNA-Sequenz den vier mÃ¶glichen Nukleotidzeichen (A, C, G, T) die numerischen Werte 0, 1, 2 bzw. 3 zugewiesen. Bei einem anderen Beispiel einer AminosÃ¤uresequenz in einem Protein werden den 20 mÃ¶glichen AminosÃ¤urezeichen die numerischen Werte 0 bis 19 zugewiesen.In the preferred embodiment, unique indices Î³ are generated by first assigning a value to each possible character value in the original character string, e.g. B. assigns a numerical value. This results in a sequence of numerical values from the original character string and thus also from the partial character strings and the tuples, which represent their respective characters. In general, a unique number Ï j between 0 and n Ï (0 â¤ Ï j â¤ n Ï ) is chosen for each character Ï. For example, in a DNA sequence consisting of nucleotides, the four possible nucleotide characters (A, C, G, T) are assigned the numerical values 0, 1, 2 and 3. In another example of an amino acid sequence in a protein, the 20 possible amino acid characters are assigned the numerical values 0 to 19.\n\nDann wird ein Algorithmus zur Indexerzeugung festgelegt, der die Folge numerischer werte (Zeichen) in einen eindeutigen Index umwandelt. Als Beispiel wird ein Algorithmus zur Indexerzeugung vorgestellt, der nicht als EinschrÃ¤nkung anzusehen ist. Anhand der vorliegenden Erfindung kann ein Fachmann viele andere Algorithmen entwickeln. Ein bevorzugter zur Indexerzeugung eingesetzter Algorithmus ist: Î³ = Î£n(iâ1)Ï Ïi, (mit i = 1 bis L). Then an algorithm for index generation is defined, which converts the sequence of numerical values (characters) into a unique index. An algorithm for index generation is presented as an example, which should not be regarded as a restriction. Those skilled in the art can use the present invention to develop many other algorithms. A preferred algorithm used for index generation is: Î³ = Î£n (I-1) Ï Ï i , (with i = 1 to L).\n\nBei dem DNA-Beispiel nimmt der Algorithmus zur Indexerzeugung die Form Î³ = Î£4 (iâ1) / ÏÏi an (mit i = 1 bis L).In the DNA example, the algorithm for index generation takes the form Î³ = Î£4 (i â 1) / ÏÏ i (with i = 1 to L).\n\nBeim Proteinbeispiel nimmt der Algorithmus zur Indexerzeugung die Form Î³ = Î£20 (iâ1) / ÏÏi an (mit i = 1 bis L).In the protein example, the algorithm for index generation takes the form Î³ = Î£20 (i â 1) / ÏÏ i (with i = 1 to L).\n\nBeim DNA-Beispiel wÃ¼rde dann ein j-Tupel wie âAATCGT\" in die Zahlenfolge â003123\" umgesetzt und den eindeutigen Index 40 Ã 0 + 41 Ã 0 + 42 Ã 3 + 43 Ã 1 + 44 Ã 2 + 45 Ã 3 = 3696 haben.In the DNA example, a j-tuple like \"AATCGT\" would then be converted into the number sequence \"003123\" and the unique index 4 0 Ã 0 + 4 1 Ã 0 + 4 2 Ã 3 + 4 3 Ã 1 + 4 4 Ã 2 + 4 5 Ã 3 = 3696.\n\nDurch den Algorithmus zur Indexerzeugung wird fÃ¼r jedes Originaltupel im Satz der Originaltupel, die aus den Original-Teilzeichenketten (siehe Kasten 20 in 1) des ausgewÃ¤hlten zu bearbeitenden Originaltupels Î¾ (j,L) / k gebildet wurden, ein eindeutiger Originalindex erzeugt. Mit demselben Algorithmus und demselben Verfahren werden eindeutige Originalindizes erzeugt, die zu den Originaltupeln jeder anderen ausgewÃ¤hlten Original-Teilzeichenkette in der Datenbank gehÃ¶ren.The algorithm for generating the index for each original tuple in the set means that the original tuple, which consists of the original substrings (see box 20 in 1 ) of the selected original tuple Î¾ (j, L) / k to be processed, a unique original index was generated. With the same algorithm and the same procedure, unique original indexes are generated that belong to the original tuples of every other selected original substring in the database.\n\nKasten 30 in 1 beschreibt, wie die zu jedem Originaltupel gehÃ¶renden Daten im Computerspeicher (Ã¼blicherweise in einem Massenspeicher wie zum Beispiel einer Festplatte) gespeichert werden, damit spÃ¤ter mittels des zu dem Tupel gehÃ¶renden eindeutigen Originalindexes darauf zugegriffen werden kann.box 30 in 1 describes how the data associated with each original tuple is stored in computer memory (usually in a mass storage device such as a hard disk) so that it can later be accessed using the unique original index belonging to the tuple.\n\n3 zeigt eine Matrix einer in der bevorzugten AusfÃ¼hrungsart verwendeten ersten Daten-Referenzstruktur 300, in der die zu jedem Originaltupel gehÃ¶renden Daten gespeichert werden. In der Technik sind auch andere Indexverfahren zur Speicherung von Daten fÃ¼r den spÃ¤teren Zugriff bekannt und werden in die Erfindung einbezogen. Hierzu gehÃ¶ren Vektoren mit Zeigern, die auf Listen von DatensÃ¤tzen zeigen. 3 shows a matrix of a first data reference structure used in the preferred embodiment 300 , in which the data belonging to each original tuple are stored. Other indexing methods for storing data for later access are also known in the art and are included in the invention. This includes vectors with pointers that point to lists of data records.\n\nDie in 3 gezeigte Daten-Referenzstruktur 300 besteht aus einer Matrix mit einer Vielzahl Ã¼blicher Zellen 310. Die Matrix der Daten-Referenzstruktur 300 hat mindestens nL Zellen, wobei L die LÃ¤nge des lÃ¤ngsten verwendeten Tupels und n = nÏ die Anzahl der mÃ¶glichen Zeichenwerte in den Original-Zeichenketten ist. (Im Falle der DNA ist fÃ¼r numerische Darstellungen von vier mÃ¶glichen Nukleotiden n = 4.) Dadurch wird sichergestellt, dass jedem erzeugten Originalindex mindestens eine Zelle eindeutig zugeordnet ist. Man beachte, dass es bei der vorliegenden AusfÃ¼hrungsart auch viele Zellen gibt, die zu keinem erzeugten Originalindex gehÃ¶ren. Wenn einem erzeugten Index eine Zelle zugeordnet wurde, wird ein Datensatz 314, Ã¼blicherweise Ï, in die Zelle eingefÃ¼gt oder an sie angehÃ¤ngt, welcher die Original-Zeichenkette und das Tupel charakterisiert, aus denen der Index 312, Ã¼blicherweise Î³, erzeugt wurde. Eine Zelle 310 kann mehrere DatensÃ¤tze 314 und 326 enthalten. Dieser Datensatz enthÃ¤lt zumindest einen Zeiger 315, der auf die Original-Zeichenkette in der Datenbank zeigt, aus welcher das Tupel erzeugt wurde. Vorzugsweise enthÃ¤lt der Datensatz auÃerdem auch noch Daten 320 zur Position des Originaltupels in der Original-Zeichenkette. Vorzugsweise enthÃ¤lt die Zelle auÃerdem auch noch weitere Daten Ã¼ber das Tupel und die Position der zur Erzeugung des Tupels aneinander gehÃ¤ngten Teilzeichenketten. (NÃ¤here Beschreibung siehe unten.) Bei der bevorzugten AusfÃ¼hrungsart bleiben Zellen, die zu keinem erzeugten Index gehÃ¶ren, leer.In the 3 shown data reference structure 300 consists of a matrix with a large number of common cells 310 , The matrix of the data reference structure 300 has at least n L cells, where L is the length of the longest tuple used and n = n Ï is the number of possible character values in the original character strings. (In the case of DNA, n = 4 for four possible nucleotides). This ensures that at least one cell is uniquely assigned to each original index generated. Note that in the present embodiment there are also many cells that do not belong to an original index generated. If a cell has been assigned to a generated index, a record is created 314 , usually Ï, inserted or appended to the cell that characterizes the original string and tuple that make up the index 312 , usually Î³, was generated. A cell 310 can have multiple records 314 and 326 contain. This data record contains at least one pointer 315 that points to the original string in the database from which the tuple was created. The data record also preferably also contains data 320 the position of the original tuple in the original string. The cell preferably also contains further data about the tuple and the position of the partial character strings which are connected to one another to generate the tuple. (See below for a more detailed description.) In the preferred embodiment, cells that do not belong to any generated index remain empty.\n\nBei einer besonders bevorzugten AusfÃ¼hrungsart enthÃ¤lt die Zelle 310 auÃerdem auch noch Platz fÃ¼r mehr als einen Datensatz Ã¼ber mehr als eine Original-Zeichenkette, die identische erzeugte Indizes haben kann. Mit anderen Worten, die Zelle enthÃ¤lt eine Liste 328 mit mehreren DatensÃ¤tzen, die jeweils einen Zeiger enthalten (315 und 325). Jeder Datensatz 326 in der Zellenliste 328, der einen Zeiger 325 enthÃ¤lt, kann auÃerdem noch Positionsdaten 330 fÃ¼r den Zeiger 325 enthalten. Wenn mehr als eine Original-Zeichenkette denselben Index erzeugt, werden die Daten fÃ¼r jede den identischen Index 312 erzeugende Original-Zeichenkette an die Liste 328 der DatensÃ¤tze in der Einzelzelle 310 angehÃ¤ngt, welche dem gemeinsamen Index 312 zugeordnet ist. Die Liste 328 kann statisch oder dynamisch sein. Eine statische Liste enthÃ¤lt Speicherplatz zur Speicherung von Daten, die sich auf eine fest vorgegebene Anzahl von Original-Zeichenketten beziehen, und lÃ¤sst alle Daten verloren gehen, die den reservierten Speicherplatz Ã¼berschreiten. Eine dynamische Liste wird erweitert, um Daten Ã¼ber jede Original-Zeichenkette zu speichern, die einen gemeinsamen Index erzeugt.In a particularly preferred embodiment, the cell contains 310 there is also space for more than one data record for more than one original character string, which can have identically generated indexes. In other words, the cell contains a list 328 with several data records, each containing a pointer ( 315 and 325 ). Any record 326 in the cell list 328 who has a pointer 325 contains position data 330 for the pointer 325 contain. If more than one original string creates the same index, the data for each becomes the identical index 312 generating original string to the list 328 of the records in the single cell 310 appended which to the common index 312 assigned. The list 328 can be static or dynamic. A static list contains storage space for storing data relating to a predetermined number of original character strings, and all data that exceeds the reserved storage space is lost. A dynamic list is expanded to store data about each original string that creates a common index.\n\nObwohl die Referenzstruktur 300 vom Matrixtyp fÃ¼r eine kleine Anzahl mÃ¶glicher Indizes ausreicht, wird bei Anwendungen mit einer groÃen Anzahl von Indizes eine groÃe Anzahl von Zellen 310 der Referenzstruktur benÃ¶tigt. Ferner beinhalten die meisten dieser Zellen 310 bei vielen Anwendungen keine Daten, da sie keinem erzeugten Index 312 zugeordnet sind. In diesen FÃ¤llen werden in der Technik bekannte Verfahren fÃ¼r den Umgang mit leeren Matrizen eingesetzt. Zu diesen Verfahren gehÃ¶ren Hash-Tabellen.Although the reference structure 300 of the matrix type is sufficient for a small number of possible indexes, in applications with a large number of indexes a large number of cells 310 the reference structure is required. Furthermore, most of these cells contain 310 No data for many applications because they do not have a generated index 312 assigned. In these cases, methods known in the art are used for handling empty matrices. These methods include hash tables.\n\nIn der Technik sind viele AusfÃ¼hrungsarten mit Hash-Tabellen bekannt, die in der vorliegenden Erfindung inbegriffen sind. 4 zeigt jedoch als Beispiel eine erste Referenzstruktur, die als bestimmter Typ einer Hash-Tabelle realisiert wurde. Dieses Beispiel beschreibt eine relativ kleine Matrix von n Zellen 0 bis n. Jeder erzeugte Index wird mit einer Primzahl wie zum Beispiel 7 multipliziert und aus diesem Wert durch Modulo n der Wert 405 erhalten. Dann wird der erzeugte Hash-Index 412 der Zelle 410 zugewiesen, deren Identifizierungszahl mit dem Wert der Modulo-Operation Ã¼bereinstimmt. Der zu diesem Index gehÃ¶rende Datensatz 414 wird dann in der gewÃ¤hlten Zelle gespeichert. Das Verfahren geht davon aus, dass es in der Hashtabelle genÃ¼gend Zellen 410 gibt, die jedem erzeugten Index eindeutig zugewiesen werden kÃ¶nnen. Wenn ein erzeugter Index einer Zelle zugeordnet wird, die bereits einem anderen davon verschiedenen Index zugewiesen wurde, wird dieser Index erneut gehasht und neu zugeordnet. Zum Beispiel wird der Modulo-Wert mit 7 multipliziert und erneut der Modulo-Operation unterzogen. Als Ergebnis soll eine Zahl entstehen, die eine andere Zelle kennzeichnet. Dies wird so lange wiederholt, bis eine leere Zelle gefunden wurde.Many hash table implementations are known in the art that are included in the present invention. 4 however shows as an example a first reference structure, which was realized as a certain type of a hash table. This example describes a relatively small matrix of n cells 0 to n. Each index generated is multiplied by a prime number such as 7 and the value from this value by modulo n 405 receive. Then the hash index generated 412 the cell 410 assigned, the identification number of which corresponds to the value of the modulo operation. The record belonging to this index 414 is then saved in the selected cell. The process assumes that there are enough cells in the hash table 410 there that can be clearly assigned to each generated index. If a generated index is assigned to a cell that has already been assigned to a different index, this index is hashed again and reassigned. For example, the modulo value is multiplied by 7 and subjected to the modulo operation again. The result is a number that is another cell features. This is repeated until an empty cell is found.\n\nIm Folgenden werden die in der Zelle der ersten Referenzstruktur gespeicherten Daten beschrieben. Der Datensatz Ï dient dazu, auf einen bestimmten Speicherplatz in einer zweiten Speicherstruktur zuzugreifen, die als Nachweis-Sammeltabelle (Evidence Integration Table, EIT) bezeichnet wird. Ein Datensatz enthÃ¤lt mindestens einen auf die Original-Zeichenkette zeigenden Zeiger Î± 415 zur Berechnung des Indexes der Zelle 412. Die bevorzugte AusfÃ¼hrungsart speichert einen Zeiger 415 und einen Verschiebungswert 420. Der Verschiebungswert Î´ 420 liefert Daten zur Position der Original-Teilzeichenketten in der Original-Zeichenkette, welche ein der Zelle der Referenzstruktur zugeordnetes j-Tupel gebildet hat.The data stored in the cell of the first reference structure are described below. The data set Ï serves to access a specific storage space in a second storage structure, which is referred to as the Evidence Integration Table (EIT). A data record contains at least one pointer Î± pointing to the original character string 415 to calculate the index of the cell 412 , The preferred embodiment stores a pointer 415 and a shift value 420 , The shift value Î´ 420 provides data on the position of the original substrings in the original string, which has formed a j-tuple assigned to the cell of the reference structure.\n\nBei Bedarf kÃ¶nnen in den Zellen auch noch weitere Daten gespeichert werden. Das kÃ¶nnen andere DatensÃ¤tze 426 sein, die wiederum Daten zu weiteren Zeigern 425 und Verschiebungswerten 430 enthalten. Diese DatensÃ¤tze 426 kÃ¶nnen je nach Bedarf dynamisch in die Zelle eingefÃ¼gt oder an diese angehÃ¤ngt werden. Es kÃ¶nnen aber auch noch weitere Daten hinzugefÃ¼gt werden. Zum Beispiel kann die Zelle 410 Daten zum Abstand zwischen den ein j-Tupel bildenden Teilzeichenketten enthalten.If necessary, further data can also be stored in the cells. Other records can do that 426 be, which in turn data to other pointers 425 and displacement values 430 contain. These records 426 can be dynamically inserted or appended to the cell as needed. However, further data can also be added. For example, the cell 410 Contain data on the distance between the substrings forming a j-tuple.\n\nVerweise/Zeiger sind in der Rechentechnik bekannt, und in der vorliegenden Erfindung sind alle Zeiger inbegriffen, die an einem Speicherplatz, wie zum Beispiel in der Zelle einer Referenzstruktur, gespeichert und zum Auffinden einer in diesem Speicher gespeicherten Zeichenfolge, die eine Original-Zeichenkette darstellt, verwendet werden kÃ¶nnen. Ein Verweis/Zeiger kann die Adresse des Speicherplatzes sein, der dasjenige erste (oder ein anderes) Zeichen der Original-Zeichenkette enthÃ¤lt, auf welches gezeigt wird. Alternativ kann der bevorzugte Verweis/Zeiger lediglich eine (ganze) Zahl sein, die einem Index einer Original-Zeichenkette in einer Datenbank von (ganzzahligen) nummerierten Zeichenketten entspricht.References / pointers are known in computing technology and in the present invention includes all pointers that are stored in a memory location, such as Example in the cell of a reference structure, saved and for Find a string stored in this memory, the an original string represents can be used. A reference / pointer can be the address of the storage location that that contains the first (or another) character of the original character string which is shown. Alternatively, the preferred reference / pointer just be an integer that is an index of an original string in a database of (integer) numbered strings equivalent.\n\nDer Verschiebungswert beschreibt die mittlere oder genaue Position einer Original-Zeichenkette, in welcher sich die Teilzeichenketten befinden, die zur Erstellung eines Tupels dienten. Zur AbschÃ¤tzung der Position dieser Teilzeichenketten gibt es viele Wege. Zum Beispiel kann dies ein Verschiebungswert Î´k fÃ¼r ein von der Original-Zeichenkette Ïi abgeleitetes Tupel Î¾ (j,L) / k sein. Dieser Verschiebungswert Î´i kann der in Zeichen gemessene Abstand (Differenz) zwischen einem bestimmten Zeichen, wie zum Beispiel dem ersten Zeichen Ïi der Original-Zeichenkette Ïi, und einem anderen bestimmten Zeichen, wie zum Beispiel dem ersten (oder zweiten, dritten usw.) Zeichen der ersten Teilzeichenkette, sein, welche zur Erzeugung des Tupels (Index) verwendet wurde, das durch die Zelle in der Speicherstruktur eindeutig gekennzeichnet wird. Bei der besonders bevorzugten AusfÃ¼hrungsart wird der in Zeichen gemessene Mittelwert der AbstÃ¤nde zwischen einem Anfang der Original-Zeichenkette und dem Anfang jeder der Teilzeichenketten zur Erzeugung des Tupels verwendet. Dieser Mittelwert wird als Î´kmitt bezeichnet. Dann hat ein j-Tupel einen Mittelwert Î´kmitt, der durch Mittelung der in Zeichen gemessenen AbstÃ¤nde zwischen dem ersten Zeichen der Original-Zeichenkette und dem ersten Zeichen in jeder der j Teilzeichenketten berechnet wird.The shift value describes the mean or exact position of an original character string in which the partial character strings are located that were used to create a tuple. There are many ways to estimate the position of these substrings. For example, this can be a shift value Î´ k for a tuple Î¾ (j, L) / k derived from the original character string Ï i . This shift value Î´ i can be the distance (difference), measured in characters, between a certain character, such as the first character Ï i of the original character string Ï i , and another specific character, such as the first (or second, third, etc .) Characters of the first substring, which was used to generate the tuple (index), which is uniquely identified by the cell in the memory structure. In the particularly preferred embodiment, the mean value, measured in characters, of the distances between a beginning of the original character string and the beginning of each of the partial character strings is used to generate the tuple. This mean is called Î´ kmitt . Then a j-tuple has an average value Î´ kmitt , which is calculated by averaging the distances, measured in characters, between the first character of the original character string and the first character in each of the j sub-character strings.\n\nNachdem die Originaltupel und die zugehÃ¶rigen Originalindizes fÃ¼r die betreffenden Original-Zeichenketten erzeugt und die DatensÃ¤tze fÃ¼r jeden erzeugten Originalindex in seiner entsprechenden Zelle in der ersten Referenzstruktur gespeichert wurden, werden Referenztupel und deren zugehÃ¶rige eindeutige Referenzindizes erzeugt. Hierzu siehe Kasten 35, 40 und 45 in 1. Dies wird erreicht durch: 1. Aufteilen einer bestimmten Referenz-Zeichenkette in zwei oder mehr Referenz-Teilzeichenketten aus zusammenhÃ¤ngenden Zeichen, 2. Bilden mindestens eines Referenztupels durch ZusammenfÃ¼gen von mindestens zwei nicht zusammenhÃ¤ngenden Referenz-Teilzeichenketten und 3. Erzeugen eines Referenzindexes mittels desselben Indexgenerators, der zur Erzeugung der Indizes in der Referenzstruktur verwendet wurde.After the original tuple and the associated original indices for the relevant original character strings have been generated and the data records for each original index generated have been stored in its corresponding cell in the first reference structure, reference tuples and their associated unique reference indices are generated. See box 35 . 40 and 45 in 1 , This is achieved by: 1. Splitting a specific reference character string into two or more reference substrings from connected characters, 2. Forming at least one reference tuple by combining at least two non-contiguous reference substrings and 3. Generating a reference index using the same index generator, which was used to create the indices in the reference structure.\n\nEine Referenz-Zeichenkette Ïref ist eine Zeichenfolge, die mit den Original-Zeichenketten in der Datenbank verglichen wird, um festzustellen, ob die Referenz-Zeichenkette genau oder ungefÃ¤hr mit einem Teil (einer Teilzeichenfolge) einer oder mehrerer Original-Zeichenketten in der Datenbank Ã¼bereinstimmt.A reference string Ï ref is a string that is compared to the original strings in the database to determine whether the reference string matches exactly or approximately with a part (a sub-string) of one or more original strings in the database ,\n\nUm gemÃ¤Ã Kasten 35 in 1 die Referenztupel Î¾ref, d. h. die aus dieser Referenz-Zeichenkette gebildeten Tupel, zu bilden, wird die Referenz-Zeichenkette zuerst in Teilzeichenketten aus zusammenhÃ¤ngenden Zeichen aufgeteilt, die als Referenz-Teilzeichenketten bezeichnet werden. Diese Aufteilung erfolgt nach einem der oben bei der Aufgliederung in Original- Teilzeichenketten erÃ¶rterten Verfahren. Man beachte, dass die Aufgliederung von Referenz-Zeichenketten in Teilzeichenketten auch mit vielen anderen Verfahren als bei der Aufgliederung der Original-Zeichenketten in Teilzeichenketten erfolgen kann. Bei der bevorzugten AusfÃ¼hrungsart jedoch werden sowohl die Original-Zeichenketten als auch die Referenz-Zeichenketten nach demselben Verfahren aufgegliedert. Hierzu siehe Kasten 40 in 1. Die Referenztupel Î¾ref werden nun durch ZusammenfÃ¼gen von mindestens zwei nicht zusammenhÃ¤ngenden Referenz-Teilzeichenketten gebildet. Dieses ZusammenfÃ¼gen von Referenz-Teilzeichenketten erfolgt nach einem der oben fÃ¼r das ZusammenfÃ¼gen von Original-Teilzeichenketten zur Bildung von Originaltupeln erÃ¶rterten Verfahren. Die Referenz-Teilzeichenketten brauchen jedoch nicht in genau derselben Weise zusammengefÃ¼gt werden wie die Original-Teilzeichenketten zu Originaltupeln.To according to box 35 in 1 To form the reference tuple Î¾ ref , that is to say the tuples formed from this reference character string, the reference character string is first divided into partial character strings from connected characters which are referred to as reference partial character strings. This division takes place in accordance with one of the methods discussed above for the division into original substrings. It should be noted that the breakdown of reference strings into substrings can also be done using many different methods than the breakdown of the original strings into substrings. However, in the preferred embodiment, both the original strings and the reference strings are broken down using the same procedure. See box 40 in 1 , The reference tuples Î¾ ref are now formed by combining at least two non-contiguous reference substrings. This too The assembly of reference substrings is carried out according to one of the methods discussed above for the joining of original substrings to form original tuples. However, the reference substrings need not be put together in exactly the same way as the original substrings to form original tuples.\n\nNun werden gemÃ¤Ã Kasten 45 in 1 aus den Referenztupeln die Referenzindizes Î³ref gebildet. Wie zuvor erhÃ¤lt jedes Referenztupel einen eindeutigen Referenzindex. Der eindeutige Referenzindex fÃ¼r jedes Referenztupel sollte mÃ¶glichst mittels genau desselben Algorithmus zur Indexerzeugung erzeugt werden wie bei der oben beschriebenen Erzeugung der Originalindizes aus den Originaltupeln.Now according to box 45 in 1 the reference indices Î³ ref are formed from the reference tuples . As before, each reference tuple receives a unique reference index. The unique reference index for each reference tuple should, if possible, be generated using exactly the same algorithm for generating the index as for the above-described generation of the original indices from the original tuples.\n\nAuch der Referenz-Verschiebungswert Î wird berechnet, um die Position der Referenz-Teilzeichenketten in der Referenz-Zeichenkette zu ermitteln, die zur Erzeugung des Referenztupels verwendet wurden. Zur Erzeugung des Positionswertes fÃ¼r die Referenz-Teilzeichenketten kann jedes allgemeine Verfahren, wie zum Beispiel die oben zur Erzeugung des Verschiebungswertes fÃ¼r Original-Zeichenketten eingesetzten Verfahren, verwendet werden. Auch hier sollte das zur Ermittlung des Verschiebungswertes fÃ¼r die Referenztupel verwendete Verfahren mÃ¶glichst genau dasselbe Verfahren sein, welches zur Ermittlung des Verschiebungswertes fÃ¼r Originaltupel verwendet wurde.Also becomes the reference displacement value Î calculated to the position of the reference substrings in the Reference string to determine which were used to generate the reference tuple. to Generation of the position value for the reference substrings can be any general method, such as the one above for generating the shift value for original strings used methods are used. Here, too, should Determination of the displacement value used for the reference tuple Procedure if possible be exactly the same method used to determine the displacement value for original tuple was used.\n\nNachdem die Referenzindizes erzeugt worden sind, werden sie mit den Originalindizes verglichen, um Ãbereinstimmungen festzustellen (siehe Kasten 50 in 1). In der vorliegenden Erfindung sind alle in der Technik bekannten Verfahren zum Vergleichen von zwei Indizes (Zahlen) oder von zwei Indexlisten (Zahlenlisten) inbegriffen, mit denen eine Ãbereinstimmung zwischen den Indizes festgestellt werden kann. Als bevorzugtes Verfahren zum Vergleichen der Indizes mit den Originalindizes wird jedoch die Referenzstruktur verwendet. Hierzu wird jeder Referenzindex zum Zugriff auf diejenige Zelle (Ã¼blicherweise die Zelle 310 in 3 oder Zelle 410 in 4) in der Referenzstruktur verwendet, die einem Originalindex (Ã¼blicherweise 312 oder 412) zugeordnet ist, der gleich dem Referenzindex ist. Liegen in der Zelle, auf die zugegriffen wurde, ein oder mehrere DatensÃ¤tze (328 oder 428) vor, kommt es zur Ãbereinstimmung zwischen dem Referenzindex (350 oder 450) und einem oder mehreren Originalindizes (Ã¼blicherweise 312 oder 412) (Tupel), welche der Zelle, auf die zugegriffen wurde (Ã¼blicherweise 310 oder 410), zugeordnet sind. Befindet sich in der Zelle kein Datensatz, kommt es nicht zur Ãbereinstimmung und fÃ¼r dieses Referenztupel erfolgt keine weitere Verarbeitung.After the reference indices have been generated, they are compared to the original indices to determine if they match (see box 50 in 1 ). The present invention includes all methods known in the art for comparing two indices (numbers) or two index lists (number lists) with which a correspondence between the indices can be determined. However, the reference structure is used as the preferred method for comparing the indices with the original indices. For this purpose, each reference index is used to access that cell (usually the cell 310 in 3 or cell 410 in 4 ) used in the reference structure that corresponds to an original index (usually 312 or 412 ) which is equal to the reference index. If there are one or more data records in the cell that was accessed ( 328 or 428 ), there is a match between the reference index ( 350 or 450 ) and one or more original indices (usually 312 or 412 ) (Tuple) which of the cell that was accessed (usually 310 or 410 ), assigned. If there is no data record in the cell, there is no match and no further processing takes place for this reference tuple.\n\nIn Kasten 55 in 1 wird in einem zweiten Speicherbereich mit der Bezeichnung Nachweis-Sammeltabelle EIT (Evidence Integration Table) jede Ãbereinstimmung zwischen einem Referenzindex und einem Originalindex erfasst. In 5 wird auf die als ZÃ¤hlzellen bezeichneten Zellen 510 in der EIT 500 mittels eines ZÃ¤hlindexes 512 zugegriffen, der anhand eines Teils oder des gesamten Datensatzes (314 oder 414) in der Zelle (310 oder 410) der Referenzstruktur erzeugt wird, welche dem mit dem Originalindex Ã¼bereinstimmenden Referenzindex zugeordnet ist. Im Allgemeinen braucht nur der Verweis/Zeiger (315 oder 415) im Datensatz als ZÃ¤hlindex oder zu dessen Berechnung verwendet zu werden. Vorzugsweise werden insbesondere der Verweis/Zeiger und der Verschiebungswert (320 oder 420) des Datensatzes und der Verschiebungswert des Referenztupels Î zur Berechnung eines ZÃ¤hlindexes 512 verwendet. Besonders bevorzugt zur Erzeugung eines ZÃ¤hlindexes 512 fÃ¼r den Zugriff auf eine Zelle 510 in der ZÃ¤hltabelle 500 ist die Verwendung des Verweises/Zeigers (315 oder 415) und eine Optimierung der Differenz zwischen dem im Datensatz (320 oder 420) gefundenen Verschiebungswert sowie dem Verschiebungswert des Referenztupels Î.In box 55 in 1 In a second memory area called the Evidence Integration Table (EIT), every match between a reference index and an original index is recorded. In 5 is applied to the cells called counting cells 510 in the EIT 500 by means of a counting index 512 accessed based on part or all of the record ( 314 or 414 ) in the cell ( 310 or 410 ) the reference structure is generated, which is assigned to the reference index matching the original index. Generally only the reference / pointer ( 315 or 415 ) to be used in the data set as a counting index or for its calculation. In particular, the reference / pointer and the displacement value ( 320 or 420 ) of the data set and the shift value of the reference tuple Î for calculating a counting index 512 used. Particularly preferred for generating a counting index 512 for access to a cell 510 in the counting table 500 is the use of the reference / pointer ( 315 or 415 ) and an optimization of the difference between that in the data set ( 320 or 420 ) found displacement value and the displacement value of the reference tuple Î.\n\nDer ZÃ¤hlindex 512 der bevorzugten AusfÃ¼hrungsart wird aus dem Verweis/Zeiger (315 oder 415) Î± und der Vergleichsdifferenz (berechnet als Differenz zwischen dem Verschiebungswert Î´ des Datensatzes Ï minus dem Referenz-Verschiebungswert Î) berechnet. Die Vergleichsdifferenz D0 entspricht dem in Zeichen gemessenen Abstand zwischen einem bestimmten Zeichen in der Original-Zeichenkette, z. B. dem ersten Zeichen der Original-Zeichenkette, und einem bestimmten Zeichen der Referenz-Zeichenkette, z. B. dem ersten Zeichen der Referenz-Zeichenkette, sodass die Ã¼bereinstimmenden Zeichenfolgen in der Original-Zeichenkette und der Referenz-Zeichenkette zur Deckung gebracht werden, wenn die Zeichenketten um den Abstand der Vergleichsdifferenz verschoben werden. Mit anderen Worten, die Vergleichsdifferenz (durch D0 = Î´mitt â Îkmitt berechnet) stellt den in Zeichen gemessenen Abstand dar, um den die Original-Zeichenkette gegenÃ¼ber der Referenz-Zeichenkette verschoben werden muss, um diejenigen Ã¼bereinstimmenden Zeichenfolgen zur Deckung zu bringen, von denen die entsprechenden Ã¼bereinstimmenden Originaltupel und Referenztupel (Indizes) abgeleitet wurden.The counting index 512 In the preferred embodiment, the reference / pointer ( 315 or 415 ) Î± and the comparison difference (calculated as the difference between the shift value Î´ of the data set Ï minus the reference shift value Î). The comparison difference D 0 corresponds to the distance, measured in characters, between a certain character in the original character string, e.g. B. the first character of the original string, and a certain character of the reference string, e.g. B. the first character of the reference string, so that the matching strings in the original string and the reference string are made to coincide when the strings are shifted by the distance of the comparison difference. In other words, the comparison difference (calculated by D 0 = Î´ mitt - Î kmitt ) represents the distance measured in characters by which the original character string has to be shifted from the reference character string in order to match those matching character strings, from which the corresponding matching original tuples and reference tuples (indices) were derived.\n\nNachdem die Vergleichsdifferenz D0 ermittelt worden ist, wird mittels eines Algorithmus der ZÃ¤hlindex 512 erzeugt. Es gibt in der Technik viele Verfahren zur Erzeugung solcher Indizes, die in der Erfindung inbegriffen sind. Das bevorzugte Verfahren besteht jedoch darin, den Wert des Verweises/Zeigers 315 oder 415 Î± im Datensatz (328 oder 428) mit einer bestimmten Konstanten zu multiplizieren, die gleich der grÃ¶ÃtmÃ¶glichen Vergleichsdifferenz ist, und dazu dann den Wert der Vergleichsdifferenz zu addieren. Die Konstante wird so gewÃ¤hlt, dass der Algorithmus einen eindeutigen ZÃ¤hlindex fÃ¼r jede mÃ¶gliche Kombination von Zeiger und Vergleichsdifferenz erzeugt, die aus den DatensÃ¤tzen in der Referenzstruktur erzeugt werden kann. Dabei ist zu beachten, dass man aus dem ZÃ¤hlindex die Werte fÃ¼r den Verweis/Zeiger und die Vergleichsdifferenz ermitteln kann, indem man den Algorithmus umkehrt. Jede Zelle in der EIT bezeichnet eindeutig eine Original-Zeichenkette mit einer bestimmten Vergleichsdifferenz gegenÃ¼ber der Referenz-Zeichenkette.After the comparison difference D 0 has been determined, the counting index is determined using an algorithm 512 generated. There are many methods in the art for generating such indexes that are included in the invention. However, the preferred method is the value of the reference / pointer 315 or 415 Î± in the data set ( 328 or 428 ) multiply by a certain constant, which is equal to the largest possible comparison difference, and then add the value of the comparison difference. The constant is chosen so that the algorithm generates a unique counting index for every possible combination of pointer and comparison difference that can be generated from the data records in the reference structure. It should be noted that the values for the reference / pointer and the comparison difference can be determined from the counting index by reversing the algorithm. Each cell in the EIT uniquely designates an original character string with a certain comparison difference compared to the reference character string.\n\nDie ZÃ¤hlzellen 510 in der EIT 500, auf die durch die ZÃ¤hlindizes zugegriffen wird, dienen jedes Mal der Speicherung der âZÃ¤hlwerte\" 515 fÃ¼r eine Original-Zeichenkette mit einer bestimmten Vergleichsdifferenz, wenn mittels der Referenzstruktur und des Referenzindexes in der oben beschriebenen Weise eine entsprechende Ãbereinstimmung festgestellt wird. Der Wert âc\" 515 in jeder ZÃ¤hlzelle 510 der EIT 500 wird jedes Mal aktualisiert, wenn fÃ¼r diese Zelle ein ZÃ¤hlindex erzeugt wird. Kommt es zur Ãbereinstimmung, d. h. wenn eine Zelle in der Referenzstruktur mindestens einen Datensatz enthÃ¤lt, wird aus dem Verweis/Zeiger im Datensatz und der berechneten Vergleichsdifferenz ein ZÃ¤hlindex 512 erzeugt. Auf die dem Verweis/Zeiger und der Vergleichsdifferenz zugeordnete eindeutige ZÃ¤hlzelle wird durch den ZÃ¤hlindex zugegriffen und ihr Wert c um einen bestimmten Betrag, normalerweise um den ganzzahligen Wert 1, erhÃ¶ht. Demzufolge stellt der Wert c 515 in jeder ZÃ¤hlzelle 510 einen direkten Hinweis darauf dar, wie oft eine Original-Zeichenkette und eine Referenz-Zeichenkette identische Indizes und denselben Wert der Vergleichsdifferenz erzeugt haben.The counting cells 510 in the EIT 500 which are accessed by the counting indices are used to store the \"counting values\" each time 515 for an original character string with a certain comparison difference, if a corresponding match is found using the reference structure and the reference index in the manner described above. The value \"c\" 515 in every counting cell 510 the EIT 500 is updated every time a count index is generated for this cell. If there is a match, ie if a cell in the reference structure contains at least one data record, the reference / pointer in the data record and the calculated comparison difference become a counting index 512 generated. The unique counting cell assigned to the reference / pointer and the comparison difference is accessed by the counting index and its value c is increased by a certain amount, normally by the integer value 1. As a result, the value c 515 in every counting cell 510 a direct indication of how often an original string and a reference string have generated identical indexes and the same value of the comparison difference.\n\nDaher zeigt bei der bevorzugten AusfÃ¼hrungsart der vorliegenden Erfindung eine Zelle in der EIT mit einem hohen Wert c an, dass die entsprechende Original-Zeichenkette der Referenz-Zeichenkette mit hoher Wahrscheinlichkeit Ã¤hnlich oder identisch ist, wenn sie um die Vergleichsdifferenz verschoben wird.Therefore shows in the preferred embodiment the present invention a cell in the EIT with a high Value c indicates that the corresponding original string of the reference string with a high probability similar or is identical if it is shifted by the comparison difference becomes.\n\nIn der Technik sind viele Strukturen bekannt, die als AusfÃ¼hrungsarten fÃ¼r die EIT dienen kÃ¶nnen, z. B. eine Matrix, ein Vektor oder eine Hash-Tabelle. Matrizen und deren eindimensionale Untereinheit, also Vektoren, mÃ¼ssen bei groÃen Datenbanken, die die bevorzugte AusfÃ¼hrungsart verwenden, ziemlich groÃ sein, da fÃ¼r jede mÃ¶gliche Kombination von Zeiger und Vergleichsdifferenz eine eindeutige ZÃ¤hlzelle benÃ¶tigt wird. Bei einer typischen Anwendung der vorliegenden Erfindung wird auf die meisten dieser Zellen nicht zugegriffen, da es sehr unwahrscheinlich ist, dass alle diese ZÃ¤hlzellen 510 einer Ãbereinstimmung zwischen einem Originaltupel und einem Referenztupel (Index) zugeordnet sind. Infolgedessen wird die Matrix (der Vektor) nur in geringem MaÃe gefÃ¼llt und ein groÃer Teil der SpeicherkapazitÃ¤t vergeudet. Die vorliegende AusfÃ¼hrungsart bedient sich einer Hash-Tabelle, um die Anforderungen an das Speichervolumen zu verringern. Hash-Tabellen-Verfahren sind in der Technik bekannt und wurden oben anhand von Beispielen erÃ¶rtert. Die Hash-Tabelle kann statisch oder dynamisch sein. Eine statische Hash-Tabelle hat eine fest vorgegebene Anzahl von ZÃ¤hlzellen. Eine dynamische Hash-Tabelle hingegen beginnt ohne oder mit nur wenigen ZÃ¤hlzellen und legt beim Auftreten von Ãbereinstimmungen noch mehr ZÃ¤hlzellen fest und fÃ¼gt sie zur Tabelle hinzu. Die bevorzugte AusfÃ¼hrungsart verwendet eine dynamische Hash-Tabelle.Many structures are known in the art that can serve as embodiments for the EIT, e.g. B. a matrix, a vector or a hash table. Matrices and their one-dimensional subunit, i.e. vectors, must be quite large in large databases that use the preferred embodiment, since a unique counting cell is required for every possible combination of pointer and comparison difference. In a typical application of the present invention, most of these cells are not accessed because all of these count cells are very unlikely to be accessed 510 a correspondence between an original tuple and a reference tuple (index) is assigned. As a result, the matrix (the vector) is only filled to a small extent and a large part of the storage capacity is wasted. The present embodiment uses a hash table to reduce memory volume requirements. Hash table methods are known in the art and have been discussed above using examples. The hash table can be static or dynamic. A static hash table has a fixed number of counting cells. A dynamic hash table, on the other hand, starts without or with only a few counting cells and, if there are matches, specifies even more counting cells and adds them to the table. The preferred embodiment uses a dynamic hash table.\n\nIn Kasten 60 in 1 werden alle Zellen in der EIT mit einem Wert c, der einen vorgegebenen Schwellenwert Ã¼bersteigt, als Hinweis auf Ã¼bereinstimmende Original-Zeichenketten ausgewÃ¤hlt. Dann kann eine dem Wert c direkt proportionale Ãhnlichkeitsbewertung berechnet werden.In box 60 in 1 all cells in the EIT with a value c that exceeds a predetermined threshold value are selected as an indication of matching original character strings. Then a similarity assessment that is directly proportional to the value c can"
    }
}