{
    "id": "dbpedia_8583_3",
    "rank": 83,
    "data": {
        "url": "https://sccmf12twice.com/package-software-while-you-sleep-using-the-sccm-application-packager-script-part-2/",
        "read_more_link": "",
        "language": "en",
        "title": "Package Software While You Sleep Using the SCCM Application Packager Script – Part 2",
        "top_image": "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2019/08/SCCMPackagerFeaturedImage.jpg?fit=1656%2C779&ssl=1",
        "meta_img": "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2019/08/SCCMPackagerFeaturedImage.jpg?fit=1656%2C779&ssl=1",
        "images": [
            "http://sccmf12twice.com/wp-content/uploads/2018/03/2949_logo02_SMALLER.png",
            "http://sccmf12twice.com/wp-content/uploads/2018/03/2949_logo02_SMALLER.png",
            "http://sccmf12twice.com/wp-content/uploads/2018/03/2949_logo02_SMALLER.png",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2019/08/SCCMPackagerFeaturedImage.jpg?resize=1500%2C500&ssl=1",
            "https://secure.gravatar.com/avatar/3e0882fa67e24ba17b82fceac550761b?s=24&d=mm&r=g",
            "https://secure.gravatar.com/avatar/3e0882fa67e24ba17b82fceac550761b?s=24&d=mm&r=g",
            "https://secure.gravatar.com/avatar/3e0882fa67e24ba17b82fceac550761b?s=100&d=mm&r=g",
            "https://secure.gravatar.com/avatar/3e0882fa67e24ba17b82fceac550761b?s=100&d=mm&r=g",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2021/10/Intune-Logo.png?resize=380%2C214&ssl=1",
            "https://secure.gravatar.com/avatar/70b2e663a074996916918de2d0366e34?s=24&d=mm&r=g",
            "https://secure.gravatar.com/avatar/70b2e663a074996916918de2d0366e34?s=24&d=mm&r=g",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2018/03/Favicon_F12v2.png?resize=385%2C300&ssl=1",
            "https://secure.gravatar.com/avatar/b46dc02f1373e5fb3d99e52cee6237e3?s=24&d=mm&r=g",
            "https://secure.gravatar.com/avatar/b46dc02f1373e5fb3d99e52cee6237e3?s=24&d=mm&r=g",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2020/04/TSDebugger-OOBE_FeaturedImage.png?resize=385%2C300&ssl=1",
            "https://secure.gravatar.com/avatar/70b2e663a074996916918de2d0366e34?s=24&d=mm&r=g",
            "https://secure.gravatar.com/avatar/70b2e663a074996916918de2d0366e34?s=24&d=mm&r=g",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2022/02/Microsoft_Azure.png?resize=80%2C60&ssl=1",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2022/02/Cylance.png?resize=80%2C60&ssl=1",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2021/10/Intune-Logo.png?resize=80%2C60&ssl=1",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2018/03/Favicon_F12v2.png?resize=80%2C60&ssl=1",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2020/04/TSDebugger-OOBE_FeaturedImage.png?resize=80%2C60&ssl=1",
            "https://mekshq.com/static/gridlove/td_gridlove_300.jpg",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2019/02/F12_256x256.png?resize=80%2C60&ssl=1",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2017/11/1-1.png?resize=80%2C60&ssl=1",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2019/07/Featured.jpeg?resize=80%2C60&ssl=1",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2017/02/Collection-2BScreencap-filtered.png?resize=80%2C60&ssl=1",
            "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2017/11/1-2.png?resize=80%2C60&ssl=1"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Andrew Jimenez"
        ],
        "publish_date": "2019-08-19T15:50:37+00:00",
        "summary": "",
        "meta_description": "Enhance your knowledge of the SCCM Application Packager Script and learn how recipes work in the tool by disecting an example recipe.",
        "meta_lang": "en",
        "meta_favicon": "https://i0.wp.com/sccmf12twice.com/wp-content/uploads/2018/03/cropped-Favicon_F12v2.png?fit=32%2C32&ssl=1",
        "meta_site_name": "SCCMF12TWICE",
        "canonical_link": "https://sccmf12twice.com/package-software-while-you-sleep-using-the-sccm-application-packager-script-part-2/",
        "text": "Welcome to Part 2 of the 2-part series about the SCCM Application Packager Script! If you have not yet read Part 1, I highly recommend doing so before continuing.\n\nThe SCCM Packager Tool works by parsing and processing XML files known as “recipes”. Recipes provide the instructions to the SCCM Application Packager Script that allow it to create applications in SCCM. Recipes are broken down into 5 main nodes. This post will cover each of the nodes, many of the tags and properties found in each node, and their purpose. Once a general understanding of the recipes and their properties are established, we will dissect the 7-Zip recipe for further insights. Please note that there are more properties available than the ones explained here. All available properties and options are documented in the Template.xml file located in the “Recipes” folder of the SCCM Application Packager Script.\n\nApplication Node\n\nThe Application Node contains information for the application that will be visible to the end user when the it is deployed. Essentially, the Application Node defines what will be seen in Software Center for each application. The Application Node does not have many options overall, so they are all broken down below:\n\nName – The name of the application as shown in SCCM and the Software Center\n\nDescription – The description of the application in Software Center. Also sets the “Administrative Comments”\n\nPublisher – The application publisher as shown in Software Center\n\nAutoInstall – Whether to allow the application to install during a task sequence or not\n\nUserDocumentation – Link for the application to provide the end user with more information\n\nIcon – The filename of the application icon in the icon repository folder\n\nDownloads Node\n\nThe Downloads Node is responsible for downloading and copying the application installers and any associated files to the application share. Multiple downloads can be specified (for things like 32 and 64-bit downloads), and each download should be named to correspond with a “DeploymentType” in the Deployment Types Node. Different destinations can also be specified for each download (see the Template.xml file for more information). The Downloads Node also has just a few options, the most common are as follows:\n\nPrefetchScript – The prefetch script can be used to download the software or find the URL of the download for the application if a direct link to the application download isn’t available.\n\nURL – The link to download the latest version of the application.\n\nDownloadFileName – Specify the name of the file when it is downloaded\n\nVersion and FullVersion – These can be blank, but MUST be present in each download definition\n\nDownloadVersionCheck – This can be used to check the version of the application that was downloaded. If the version can’t be checked directly, additional processing can be done here as well\n\nAppRepoFolder – Allows different folders to be specified on the application share per download\n\nExtraCopyFunctions – If additional files like configurations, installation scripts, or “.mst” files are needed, they can be copied to the content share here\n\nDeployment Types Node\n\nThe Deployment Types Node is where all the magic really happens. In the Deployment Types Node, multiple deployment types can be specified for a single application. At this time, Script and MSI deployment types are supported. Each deployment type supports things like: Custom installation and uninstall commands, Custom and multiple detection methods including script detection methods, Installation behavior, and dependencies. The number of options available are too great to list for the deployment types, so it is recommended to check out the Template.xml to see the options available.\n\nDistribution Node\n\nThe Distribution Node is responsible for distributing the content to SCCM distribution points. Generally, only one option will need to be specified here, and that is whether or not to distribute the content. If the “DistributeContent” property is set to “True”, the content for the application will automatically be distributed to the distribution point group specified in SCCMPackager.prefs. The following options are also available in the Distribution Node:\n\nDistributeContent – Set to True to distribute content, Set to false to skip distributing content\n\nDistributeToGroup – Distribution Point group to distribute content to\n\nDistributeToDPs – Distribution Point to distribute content to\n\nDeployment Node\n\nThe Deployment Node is similar to the Distribution Node. It has very few options and, generally, the only option that needs to be set is “DeploySoftware”. If the “DeploySoftware” property is set to “True”, the software will automatically be deployed as available to the default collection specified in SCCMPackager.prefs. Additionally, a collection other than the default can be specified for deployment. Other options available in the Deployment Node are as follows:\n\nDeploySoftware – Set to True to deploy the software, Set to false to skip deploying software\n\nDeploymentCollection – Specify the name of a collection to deploy to other than the default\n\nRecipe Breakdown – 7-Zip.xml\n\nNow that we have a general idea of the purpose of recipes and the features available to them, let’s break down a simple one to demonstrate a real life example. The recipe for 7-Zip is relatively simple, containing two downloads and two MSI deployment types. One of these deployment types also contains a requirements rule. Below, each node of the 7-Zip recipe will be dissected and discussed.\n\n7-Zip Application Node\n\n<Application> <Name>7-Zip</Name> <Description>7-Zip is a file archiver with a high compression ratio. Free and Open Source Software</Description> <Publisher>Igor Pavlov</Publisher> <AutoInstall>True</AutoInstall> <UserDocumentation>http://www.7-zip.org/</UserDocumentation> <Icon>7Zip.ico</Icon> </Application>\n\nAs described earlier, the Application Node is fairly simple overall. The 7-Zip application will be packaged with the name “7-Zip <Version>”, the Description as shown in Software Center will be: “7-Zip is a file archiver with a high compression ratio. Free and Open Source Software”. The Publisher and Link provided in Software Center will be “Igor Pavlov” and “http://www.7-zip.org/” respectively. The SCCM Application Packager Script will also mark the option to allow the packaged application to be installed during a Task Sequence, and will choose the icon file “7Zip.ico” from the icon repository specified in SCCMPackager.prefs.\n\n7-Zip Downloads Node\n\n<Downloads> <Download DeploymentType=\"DeploymentType1\"> <PrefetchScript>$URL = \"https://www.7-zip.org/$((Invoke-WebRequest https://www.7-zip.org/download.html |Select -ExpandProperty Links |where -Property href -like \"*-x64.msi\")[0].href)\"</PrefetchScript> <URL></URL> <DownloadFileName>7Zipx64.msi</DownloadFileName> <Version></Version> <FullVersion></FullVersion> <DownloadVersionCheck>[String]$Version = ([String](Get-MSIInfo -Path $DownloadFile -Property ProductVersion)).TrimStart().TrimEnd() $Version = ($version.Split('.'))[0..1] -join \".\"</DownloadVersionCheck> <ExtraCopyFunctions></ExtraCopyFunctions> </Download> <Download DeploymentType=\"DeploymentType2\"> <PrefetchScript>$URL = \"https://www.7-zip.org/$((Invoke-WebRequest https://www.7-zip.org/download.html |Select -ExpandProperty Links |where -Property href -like \"*.msi\")[0].href)\"</PrefetchScript> <URL></URL> <DownloadFileName>7Zipx86.msi</DownloadFileName> <Version></Version> <FullVersion></FullVersion> <DownloadVersionCheck>[String]$Version = ([String](Get-MSIInfo -Path $DownloadFile -Property ProductVersion)).TrimStart().TrimEnd() $Version = ($version.Split('.'))[0..1] -join \".\"</DownloadVersionCheck> <ExtraCopyFunctions></ExtraCopyFunctions> </Download> </Downloads>\n\nThe Downloads Node for 7-Zip has a bit more going on than the Application Node. Upon initial inspection, we can see that there are 2 “DeploymentType(s)” specified, one is tied to “DeploymentType1”, and the other is tied to “DeploymentType2”. We can also tell pretty quickly based on the “DownloadFileName(s)” properties of these downloads that they download the 64-bit and 32-bit msi installers of 7-Zip respectively.\n\nYou will notice that a URL is not provided in either of the downloads, however, each download has a “PrefetchScript”, that sets a variable called “$URL”. Let’s look at what the “PrefetchScript” in the “DeploymentType1” download does:\n\n$URL = \"https://www.7-zip.org/$((Invoke-WebRequest https://www.7-zip.org/download.html |Select -ExpandProperty Links |where -Property href -like \"*-x64.msi\")[0].href)\"\n\nWe can see that this script is setting a $URL variable, it just so happens that the $URL variable is tied to the URL tag in the recipe, which is what the SCCM Application Packager Script will attempt to download. That means that whatever we set $URL to in the prefetch script will be downloaded by the Packager Script. If we break down the command a bit more, and run the command found in the inner-most parenthesis in PowerShell:\n\nPS C:\\Users\\Andrew> (Invoke-WebRequest https://www.7-zip.org/download.html |Select -ExpandProperty Links |where -Property href -like \"*-x64.msi\") innerHTML : Download innerText : Download outerHTML : <A href=\"a/7z1900-x64.msi\">Download</A> outerText : Download tagName : A href : a/7z1900-x64.msi innerHTML : Download innerText : Download outerHTML : <A href=\"a/7z1604-x64.msi\">Download</A> outerText : Download tagName : A href : a/7z1604-x64.msi innerHTML : Download innerText : Download outerHTML : <A href=\"a/7z920-x64.msi\">Download</A> outerText : Download tagName : A href : a/7z920-x64.msi\n\nwe will see that it returns 3 possible download links to 7-Zip MSIs. If we expand a bit and run everything found in the outer-most parenthesis:\n\nPS C:\\Users\\Andrew> $((Invoke-WebRequest https://www.7-zip.org/download.html |Select -ExpandProperty Links |where -Property href -like \"*-x64.msi\")[0].href) a/7z1900-x64.msi\n\nwe are greeted with a file path for the latest 7-Zip MSI file. Finally, if we run the entire “PrefetchScript” script block:\n\nPS C:\\Users\\Andrew> $URL = \"https://www.7-zip.org/$((Invoke-WebRequest https://www.7-zip.org/download.html |Select -ExpandProperty Links |where -Property href -like \"*-x64.msi\")[0].href)\" PS C:\\Users\\Andrew> Write-Output $URL https://www.7-zip.org/a/7z1900-x64.msi\n\nwe can see that it returns a full URL. If we go ahead and point our browser to that $URL, we can see that it is a direct download of the latest 7-Zip MSI file. This clarifies the purpose of the “PrefetchScript” Property, it allows the Packager to find the latest download link, even when a hotlink to the latest version is not provided. Crafting a good “PrefetchScript” is one of the harder things to do when creating a recipe, it can take much trial and error. A suggestion for creating a “PrefetchScript” is to build it outside of the packager, and only add it in once it is perfected as it’s own little script.\n\nMoving on, the final thing we will look at in the Downloads Node is the “DownloadVersionCheck”. This property is also just a PowerShell script block. The goal of the “DownloadVersionCheck” is to provide the proper version of the application to the Packager so that it can determine if this download is a new version, and package it if it is new. The “DownloadVersionCheck” script for this recipe is fairly simple:\n\n[String]$Version = ([String](Get-MSIInfo -Path $DownloadFile -Property ProductVersion)).TrimStart().TrimEnd() $Version = ($version.Split('.'))[0..1] -join \".\"\n\nFirst, the “ProductVersion” is grabbed by the “Get-MSIInfo” function, any leading or following white space is trimmed, and the string is saved to the “$Version” variable. Now, this version string will be something like “19.0.0.0” which is great and all, but 7-Zip does not even use the last two 0’s on their version string. So, for the sake of consistency with the vendor, we split the “19.0.0.0” version string by the “.” and only keep the first two array values (“19” and “0”), then we join those back together with a “.” and assign the joined string back to “$Version”.\n\nNow you may notice, just like there is a $URL that corresponds to the URL tag in the XML, there is also a “Version” tag in the XML; if you were thinking that the “$Version” variable ties to the “Version” tag in the XML, you would be exactly right! It is also important to note that having a Version assigned to every application packaged is a very important aspect to the packaging process. The “Version” property plays an important role, not only in the naming of the application, but in the folder structure on the application share.\n\n7-Zip Deployment Types Node\n\n<DeploymentTypes> <DeploymentType Name=\"DeploymentType1\"> <DeploymentTypeName>7Zip Silent Install x64</DeploymentTypeName> <InstallationType>MSI</InstallationType> <Comments>Silent Installer for 7Zip</Comments> <Language>English</Language> <CacheContent>False</CacheContent> <BranchCache>True</BranchCache> <ContentFallback>True</ContentFallback> <OnSlowNetwork>Download</OnSlowNetwork> <InstallationMSI>7Zipx64.msi</InstallationMSI> <UninstallCmd></UninstallCmd> <Force32bit>False</Force32bit> <InstallationBehaviorType>InstallForSystem</InstallationBehaviorType> <LogonReqType>WhetherOrNotUserLoggedOn</LogonReqType> <UserInteractionMode>Hidden</UserInteractionMode> <ReqUserInteraction>False</ReqUserInteraction> <EstRuntimeMins>5</EstRuntimeMins> <MaxRuntimeMins>15</MaxRuntimeMins> <RebootBehavior>BasedOnExitCode</RebootBehavior> <DetectionMethodType>MSI</DetectionMethodType> <Requirements> <RuleName>Existential of AutoPackage - OSArchitecture x64 Not Equal to 0</RuleName> </Requirements> </DeploymentType> <DeploymentType Name=\"DeploymentType2\"> <DeploymentTypeName>7Zip Silent Install x86</DeploymentTypeName> <InstallationType>MSI</InstallationType> <Comments>Silent Installer for 7Zip</Comments> <Language>English</Language> <CacheContent>False</CacheContent> <BranchCache>True</BranchCache> <ContentFallback>True</ContentFallback> <OnSlowNetwork>Download</OnSlowNetwork> <InstallationMSI>7Zipx86.msi</InstallationMSI> <UninstallCmd></UninstallCmd> <Force32bit>False</Force32bit> <InstallationBehaviorType>InstallForSystem</InstallationBehaviorType> <LogonReqType>WhetherOrNotUserLoggedOn</LogonReqType> <UserInteractionMode>Hidden</UserInteractionMode> <ReqUserInteraction>False</ReqUserInteraction> <EstRuntimeMins>5</EstRuntimeMins> <MaxRuntimeMins>15</MaxRuntimeMins> <RebootBehavior>BasedOnExitCode</RebootBehavior> <DetectionMethodType>MSI</DetectionMethodType> </DeploymentType> </DeploymentTypes>\n\nAlright here we are, the meat of the Recipe. The Deployment Types Node usually ends up being the largest part of any Recipe (depending of course on how tough it is to scrape the latest download for an application).\n\nLooking over the Deployment Types Node, we can see that there are two “DeploymentType” objects with the names “DeploymentType1” and “DeploymentType2”, which correspond with the downloads we saw earlier with the same names. There is also a “DeploymentTypeName” specified in each deployment type, but don’t let that fool you, the “DeploymentTypeName” tag only specifies the name of the deployment type in SCCM. Looking over the rest of the deployment type properties, most of the options should look familiar if you have ever created an application in SCCM before.\n\nWe can also see that the 64-bit deployment type has a “Requirements” tag with an associated “RuleName”. These properties specify that a requirements rule with the name “Existential of AutoPackage – OSArchitecture x64 Not Equal to 0” should be added to the application. By default, on it’s first run, the SCCM Application Packager Script will create a few Global Conditions for use when packaging; one of which is “Existential of AutoPackage – OSArchitecture x64” which returns a “1” on a 64-bit operating system. Therefore, this rule will ensure that the 64-bit version will only install on 64-bit computers, while the 32-bit install will run on anything else.\n\nSome other options of note for this recipe are:\n\nInstallationType – This sets the type of installation for the deployment type. The MSI “DeploymentType” is nice because if you provide an MSI, SCCM will automatically provide things like Install/Uninstall commands and a detection method. You will notice that specific install and uninstall commands are not specified in this recipe, however they can be added to MSI deployment types in the Packager\n\nInstallationMSI – This is the MSI provided to SCCM for it to generate the Install/Uninstall commands and the detection method\n\nDetectionMethodType – This specifies that the MSI file should be used to generate the detection method automatically, instead of using a script, file, or registry key for the detection method\n\n7-Zip Distribution Node\n\n<Distribution> <DistributeContent>True</DistributeContent> </Distribution>\n\nNow that we have covered all of the complex parts of the recipe, we can end on a much more gentle note. The Distribution Node for the 7-Zip application only contains a single property. The “DistributeContent” property for 7-Zip is set to “True” meaning it will be distributed to the default distribution point group specified in the preferences file.\n\n7-Zip Deployment Node\n\n<Deployment> <DeploySoftware>True</DeploySoftware> </Deployment>\n\nLast but not least, the Deployment Node for the 7-Zip recipe also contains just a single Property. The “DeploySoftware” property here is also set to “True” meaning the software will be deployed as available to the default collection specified in the preferences file. I will note that this is the default for all of the recipes provided, but can be changed per recipe depending on your specific needs.\n\n7-Zip Application End Result\n\nThis post went a bit long, so I am going to let the results speak for themselves here:\n\nThis slideshow requires JavaScript.\n\nThe SCCM Application Packager Script is a very powerful tool. Its recipes were designed for ultimate flexibility with the intention of automating the packaging of just about any application in SCCM. Creating your own recipes can be a time consuming process, however, the end result will end up saving a ton of time. In my own production environment, I have saved an estimated 220 hours a year with this tool, and that number will only grow as more recipes are created, and more application updates are released per month.\n\nThank you for taking the time to read this post and your interest in the SCCM Packager Script! I created this tool with the intention of saving people time and energy, and was able to deepen my knowledge in SCCM and PowerShell as a result. If you are interested in contributing your own recipes to the project, feel free to submit pull requests to the GitHub repository.\n\n—\n\nAndrew Jimenez\n\nTwitter: @AndrewJimenez_"
    }
}