{
    "id": "dbpedia_8583_3",
    "rank": 76,
    "data": {
        "url": "https://macvfx.blog/category/osx-app-deployment-automation/",
        "read_more_link": "",
        "language": "en",
        "title": "OSX app deployment automation",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://macvfx.blog/wp-content/uploads/2020/11/cropped-postlab-start-editing.png",
            "https://macvfx.blog/wp-content/uploads/2019/08/reciperobot-feedme.jpg?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/08/reciperobot-start.jpg?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/08/reciperobot-done.jpg?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/08/reciperobot-options.jpg?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/08/autopkgr-notification.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/08/munkiadmin-recently-changedpkgs.jpg?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/08/munkiadmin-description.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/munkipkg-payload.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/munkipkg-postinstall.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/munkipkg-build.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/hedge.gif?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/automator.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/hedge-automator.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/hedge-applesriptusb.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/applescript-dialogquit.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/hedge-camcard-prefs.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/hedge-camcard-filenaming.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/hedge-usbcard-prefs.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/hedge-usbcard-filenaming.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/04/hedge-api-script-quit.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2019/02/netboot-globespin.jpg?w=584",
            "https://macvfx.blog/wp-content/uploads/2018/09/installmojave.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2018/09/appleblockerproject.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2018/09/appblocker-munkipkg3.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2018/09/appblocker-munkipkg4.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2017/11/nomad-intro.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2016/09/autopkgr-work-tree.png?w=584",
            "https://macvfx.blog/wp-content/uploads/2016/09/screen-shot-2016-09-29-at-10-26-20-am.png?w=584",
            "https://0.gravatar.com/avatar/6b83b849e046b0fa31203719ecd55f3136de11f3fe62ebc8261a7897293e5d6a?s=48&d=identicon&r=G",
            "https://0.gravatar.com/avatar/6cf63c27aae4741a613d923c005f98d0708be9815544e32ffc63ac247646c226?s=48&d=identicon&r=G",
            "https://0.gravatar.com/avatar/3777f6d8de894bcb5af8d8f573fb099fdbf15215f0ccb4051387180885d4c582?s=48&d=identicon&r=G",
            "https://0.gravatar.com/avatar/91b25a7feb78727b5cf4a437845fd23f1168445a562ef507785d83041c9babdd?s=48&d=identicon&r=G",
            "https://0.gravatar.com/avatar/6cf63c27aae4741a613d923c005f98d0708be9815544e32ffc63ac247646c226?s=48&d=identicon&r=G",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [
            "https://video.wordpress.com/embed/HfiKMSct?hd=0&autoPlay=0&permalink=1&loop=0&preloadContent=metadata&muted=0&playsinline=0&controls=1&cover=1"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2019-08-02T05:30:45-08:00",
        "summary": "",
        "meta_description": "Posts about OSX app deployment automation written by macvfx",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "DAM SAN",
        "canonical_link": "https://macvfx.blog/category/osx-app-deployment-automation/",
        "text": "If only one person needs an application then I think about using Munki to deploy that app. If more than one person should have it then Munki is definitely the way to automate app deployment. And really, if you‚Äôre going to take the time to download an app from a website, mount a disk image or un-pack a ZIP archive, run an installer, type an admin password, close that installer ‚Ä¶ then for the love of all that is good just put the app into your Munki repo and be done with it. Automate it.\n\nUsing Munki to solve problems makes sense. Automation helps everyone in this case. But if you‚Äôre putting in one off applications into your Munki repo more often than you need to, you need to get those apps into Autopkg. Using Autopkg recipes to download the latest apps and put them into your Munki repo automatically is an automation love fest, but if your apps don‚Äôt have recipes what are you going to do? Manually add your apps to Munki? No way. We need a robot ü§ñ‚ù§Ô∏è. Recipe robot, that is.\n\nUsing Recipe Robot we can build Autopkg recipes for most apps then add the recipes to the Autopkg community to enjoy. Everyone wins.\n\nI recently created recipes for two important apps in my media workflow: Kyno and Hedge. I‚Äôll show an example of this workflow using Recipe Robot and Munki Admin to demonstrate the workflow.\n\nStep 1. Feed the robot.\n\nDrag and and drop the app you want to create your Autopkg recipes.\n\nStep 2. Watch the robot do it‚Äôs work\n\nStep 3. Robot is done. Recipes made.\n\nVarious type of recipes can be made. I chose download and munki because those are what I am using to automate adding apps to my Munki repo. But there are other options: jss, Filewave, or ‚Äúinstall‚Äù for example.\n\nStep 4. Run those Recipes\n\nYou can use your recipes locally with Autopkg. Run them in Terminal or use Autopkgr , a very nice GUI app for automating the collection and scheduling of recipes. Note: Autopkg and Munki can all be run via cli (command line interface) but for this demo we are showing the GUI apps that are there provided by outstanding members of the community. Many Thanks to them and the contributors to their projects.\n\nAutopkgr app can send notifications in macOS, emails, or post to your Slack group.\n\nStep 5. See the recipes, Use them wisely\n\nHere is an example of newly imported Kyno and Hedge apps in our Munki repo (via Munki Admin GUI).\n\nAdd a display name, choose which catalogs the apps will reside in, and check that the description will help explain what the app is.\n\nReferences:\n\nElliot Jordan ‚Äì Autopkg talk at MacDevOps:YVR\n\nhttps://youtu.be/Q_cvgGtJ71M\n\nElliot Jordan ‚Äì Recipe Robot talk at MacDevOps:YVR\n\nhttps://youtu.be/DgjO1mfMHtI\n\nQuick post to talk about some fun I‚Äôve been having with the new Hedge API.\n\nBackground: Hedge is an awesome app for securely copying Camera Cards to multiple destinations to ensure data integrity and safety of the original footage. Hedge is one part of a workflow I build for my clients. Hedge is the first step in ensuring an easy and convenient transition from the cameras to the SAN to the tape archive powered by Archiware P5.\n\nTL;DR\n\nUsing AppleScript and Automator I have built some apps to quickly set the file naming and data integrity preferences as we want them to be. And also quickly change them to something else depending on the needed workflow.\n\nAPI or Clickety click click\n\nCopying camera cards copies is what we use Hedge for. Certain preferences like logs or receipts are great to have to ensure the copy succeeded. Also file naming conventions are good to have. Set and forget, right? But what if you did forget? Or if you‚Äôre new and don‚Äôt know the convention or you don‚Äôt read documentation. What do we do? One way to solve this is build an app that launches Hedge and sets the correct preferences. And if we want to copy USB sticks or something else then we can launch another app that prepares Hedge with a different set of preferences. For extra points we just ask the user what they want with a nice dialog box and just do that.\n\nAutomator\n\nAutomator is awesome. Create workflows, apps, or services amongst many other things. For more info on Automator check out Apple‚Äôs official docs or this unofficial website of resources.\n\nFor this quick testing I used two AppleScripts with different preferences and settings defined. One for camera card copying and another for USB sticks that need different preferences set. The fancy automator app just calls the needed AppleScript. Make two apps and you have two different workflows without having to explain to users which prefs get set for what, or how the file naming should go to be consistent.\n\nExample 1: Cam Card script (snippet)\n\nExample 2: USB card copy (snippet)\n\nAutomator can do many things. Call AppleScripts, Run shell scripts, pop-up dialog boxes etc and this is just a simple example of building single purpose apps to set Hedge via its new API. Very cool and so many possibilities.\n\nAppleScript\n\nWhat if we could just build one app which asked the user what they wanted to do? We can do that!\n\nChoose ‚ÄúCam‚Äù and the appropriate preferences are set and file naming conventions applied.\n\nChoose ‚ÄúUSB‚Äù and a different set of preferences are set. Magic.\n\nHow do we do this? This piece of AppleScript chains an action to a response or button choice. Run a script or choose an action. The possibilities are endless. And thanks to the Hedge API we can set preferences on or off, and set destinations or many other things. We can do them programmatically and we can ensure they are set correctly. Fun times!\n\nAppleScript vs POSIX:\n\nI updated my AppleScript code with the POSIX path of the scripts it wants to load. It‚Äôs a major improvement! I had packaged up my scripts and my Hedge Setup app with munkipkg then deployed through Munki but when I demoed it ‚Äî nothing worked‚Ä¶. because the start up disk drive was named something else. The fix: set a variable to be the POSIX path (Unix path in AppleScript friendly format).\n\nScripting and App Building\n\nI hope that helped. We can do a lot of the same things with Python and in my testing I was working with a script written in python3 but since that‚Äôs not shipping on Macs in the current version of macOS by default (not yet!) then AppleScript was the quickest way to get this done. This is not restricted to AppleScript. Using Automator and your favourite scripting language you can build apps for your clients, co-workers, friends and family.\n\nA note about the Hedge API:\n\nThere are two major calls I use in my scripts ‚ÄúsetDestination‚Äù and ‚ÄúsetPreferences‚Äù\n\nThe ‚ÄúsetDestination‚Äù call looks like this:\n\nopen ‚Äòhedge://actions?json=[{‚ÄúsetDestination‚Äù:{‚Äúpath‚Äù:‚Äù/Volumes/LaCie/Testing/Test1‚Ä≥}},{‚Äútoken‚Äù:‚Äù1234567890123345555‚Ä≥}]‚Äô\n\nNote: the token is generated for you when you have a Pro license.\n\nThe ‚Äúthe setPreferences‚Äù call uses plist keys.\n\nNote: I‚Äôll have more say about using the actual Hedge API after it is officially announced.\n\nIt‚Äôs 2019, and NetBoot is almost dead. All new Macs have T2 chips. Sent from the future to protect us from ‚Ä¶. ourselves? No more NetBoot, no problem!!\n\nWhen NetBoot first appeared and I was able to boot entire labs of Macs across the network I was amazed and overjoyed. It was awesome. Spinning globe, spinning‚Ä¶\n\nBut in the years since I‚Äôve moved on to no-imaging. Using Munki to manage software means no more imaging, just install Munki and a small config change to point to the Munki server, thereafter the software that should be there goes on, and what‚Äôs not supposed to be there goes away. Simple. Just install one package, well, maybe two, then you‚Äôre good.\n\nWell, what if you want to streamline or automate these things? What if these are new Macs which don‚Äôt have users configured? What if we could do all this from recovery mode? Hmm‚Ä¶ Enter bootstrappr and installr!!\n\nbootstrappr\n\nThis awesome project allows to add packages to install in one step while booted in recovery mode. Plug in a USB stick with the bootstrapr script to run the package install magic or mount a disk image over http. Create a DMG with the included script make_dmg.sh. And now this is the best part: in recovery mode open the Terminal app from Utilities and type:\n\nhdiutil mount http://server/yourDMG.dmg\n\nThen:\n\n/Volumes/bootstrap/run\n\nWhen it‚Äôs done you can Reboot the Mac and you‚Äôll have a set up customized to your liking with Munki installed and configured with custom settings.\n\ninstallr\n\nThe installr script works in the same way but adds the macOS installer to the party. You can also mount the DMG over http and re-image a Mac and then add your custom packages. It‚Äôs awesome. Truly amazing.\n\nOne note: Added packages in Installr must be in a special format. From the installr site: startosinstall requires that all additional packages be Distribution-style packages (typically built with productbuild) and not component-style packages (typically built with pkgbuild)\n\nproductbuild --package component.pkg --version x.y --identifier com.example.component distribution.pkg\n\nIn one of my first tests with installr and pycreateuserpkg I was caught up by this, even though it is properly mentioned in the read me. Packages that work in Bootstrappr or munki directly don‚Äôt necessarily work when called by the macOS installer (startoinstall). Armin Briegel was helpful in the MacAdmins Slack and reminded me of this. Thanks Armin and thanks everyone on the MacAdmins Slack.\n\nMany Thanks to Greg Neagle for creating these tools and Munki. Looking forward to hearing him speak at the next MacDevOps:YVR conference June 12-14, 2019. Greg will be speaking about his efforts to port some parts of Munki from Python to Swift. More info on the conference and speakers here: https://mdoyvr.com/speakers/\n\nAlso a shout out to Graham Gilbert who has worked on Imagr (MDOYVR talk), over the years, an imaging and automation tool which was also an inspiration (along with bootstrappr and installr) to Tim Perfit and his MDS project.\n\nUpdate: corrected the names of installr and bootstrappr in the title because‚Ä¶ autocorrect.\n\nContinuing our theme of welcoming our new macOS overlords, uh, I mean, blocking major macOS upgrades such as macOS 10.14 Mojave with AppBlock we shall examine some other methods of stopping the freight train known as Apple upgrades.\n\n1) A smart person on the MacAdmins Slack posted a useful command to tell macOS not to download major upgrades.\n\nIn their testing, running:\n\n`software update ‚Äìignore macOSInstallerNotification_GM`\n\nblocks the installation of the Mojave notification package (at /Library/Bundles/OSXNotification.bundle).\n\nHowever if it already installed, then it‚Äôs too late. They pushed out this command prior to that package being distributed by Apple, and they could subsequently see in install.log that the update is being found by softwareupdated but not being installed.\n\n2) If you missed the chance to tell the Mac not to download major macOS upgrades then Rick Heil on his blog has detailed a way using munki to delete the bundle that triggers the macOS upgrade installer.\n\n3) App Block\n\nIf your users are intent or their computers are all hell bent on downloading the install app then block it with App block detailed in my previously mentioned blog post\n\n4) Warning\n\nIn an effort to get an early warning when users are about to upgrade I use Watchman Monitoring to send me an alert email when a Mac starts downloading the Install macOS app. Sometimes it‚Äôs enough of a warning to send an email to a user to ask them whether it is a good idea to upgrade at this time. If storage or software needed for production or backups aren‚Äôt qualified or tested thoroughly beforehand then upgrading in the early waves can be less than ideal and frought with peril.\n\nIn other interesting and related news, Victor (MicroMDM) was spelunking into the MDM Protocol for what prompts Macs like iOS devices to download major updates. Great post here\n\nIf you have any better ways to block macOS upgrades or want to contribute some great solutions let me know. Cheers\n\nJust the other day macOS Mojave was released and now the armies of Macs armed only with the AppStore are silently downloading the installer and ready to upgrade. You can‚Äôt hurry too fast to be on the bleeding edge, hurry faster!\n\nJust in case you don‚Äôt want everyone to install macOS 10.14.0 (dot zero!) in the first week of its release here‚Äôs a way to slow down the upgrade hordes using Erik Berglund‚Äôs AppBlocker script. Erik Berglund is also the author of ProfileCreator (for creating profiles) and the author of many other great scripts.\n\nNote: for true binary whitelisting check out Google‚Äôs Santa project and Upvote (and Moroz and Zentral, two other Santa sync servers).\n\nStep 1. Get it\n\nClone or download the AppBlocker project from GitHub\n\nStep 2. Do it\n\nEdit the AppBlocker.py script with the Bundle Identifier of your app to block, in this case for the Mojave installer from the AppStore it is:\n\ncom.apple.InstallAssistant.Mojave\n\nYou can also edit the alert message, and the icon that is shown, as well as decide if the blocked app should be deleted or not. The script is easy to edit in BBEdit, or nano (in Terminal). Use whatever your favorite text editor is to make the necessary changes.\n\n# List of all blocked bundle identifiers. Can use regexes. blockedBundleIdentifiers = ['com.apple.InstallAssistant.Mojave'] # Whether the blocked application should be deleted if launched deleteBlockedApplication = False # Whether the user should be alerted that the launched applicaion was blocked alertUser = True # Message displayed to the user when application is blocked alertMessage = \"The application \\\"{appname}\\\" has been blocked by IT\" alertInformativeText = \"Contact your administrator for more information\" # Use a custom Icon for the alert. If none is defined here, the Python rocketship will be shown. alertIconPath = \"/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/Actions.icns\"\n\nUPDATED NOTE:\n\nTo determine the Bundle identifier of other applications you can use osascript\n\nosascript -e 'id of app \"iTunes\"'\n\ncom.apple.iTunes\n\nIf you want to block more than one app use a comma separated list in the AppBlocker.py script:\n\n['com.apple.InstallAssistant.Mojave','com.apple.iTunes']\n\nStep 3. Run it\n\nPut the script where you want to run it. The default location as defined in the launchd plist included with the app is ‚Äú/usr/local/bin‚Äù. Put the launchd.plist in ‚Äú/Library/LaunchDaemons/‚Äù and start up your launchd to block your apps!\n\nlaunchctl load /Library/LaunchDaemons/com.github.erikberglund.AppBlocker.plist\n\nStep 4. Automate it\n\nFor bonus points we automate! Bundle it all up in a package with munkipkg, then distribute it with Munki to all your clients.\n\nUsing munkipkg is easy. Create the folder using munkipkg\n\n./munkipkg --create AppBlocker munkipkg: Created new package project at AppBlocker\n\nThen you fill the payload folders with those items you downloaded from the AppBlocker project. LauchD plist in the LaunchDaemons folder and AppBlocker.py in the ‚Äúusr local bin‚Äù (create each nested folder).\n\nAnd finally create a post install script (no ‚Äú.sh‚Äù) with the launchctl action to start your plist.\n\nLast but not least add this package to your Munki repo as an unattended managed install that everyone gets. Of course, only do this after testing your package locally somewhere to verify that it works properly. Remember the saying: ‚ÄúYou may not test very often, but when you do it‚Äôs always in production.‚Äù Be very careful with your testing but always automate all the things.\n\nUpdated after the initial blog post to explain how to add more than one app to block, and how to use osascript to determine the bundle identifier.\n\nMacDevOps:YVR 2018 tickets are on sale now. Buy one for everyone in your MacAdmin family.\n\nSeems like just the other day we were hanging out with our friends who came from all over the world to talk Open Source and macOS management, and now we can do it all again!\n\nTickets are on sale now.\n\nMacDevOps:YVR is the place for Mac Admins interested in integrating DevOps into their IT practise. Developers and IT (Ops) working together to build a better world.\n\nJoin us at MacDevOps:YVR 2018, our annual conference, for two days of learning and networking in Vancouver, BC, Canada. With speakers from a diverse group of companies, this year‚Äôs conference will be the best place to talk about Open Source projects that matter to the community. Learn from your peers, and connect with fellow Mac Admins.\n\nWe will be discussing: munki, imagr, autopkg, chef, puppet and all your favourite Open Source projects. This year we will be discussing MDM and all the changes in macOS. We‚Äôre planning another hack night because it was so much fun last year, and if you are interested in a particular workshop topic let us know.\n\nLearn more at https://mdoyvr.com\n\nAnd because we‚Äôre always learning from every conference we‚Äôve organized we‚Äôre trying something different this year: tiered pricing for tickets. We want everyone to join us and we want to make it fair for independents, students and others who want to be there. At the same time we want to pay the bills and support a diverse group of speakers and attendees who might not be able to attend due to lack of funds.\n\nWe‚Äôve created three tickets: corporate (if your work is paying), independent (if you‚Äôre buying you‚Äôre own ticket), and education (students and those who work in schools). Last, but not least, the Donation ticket is for those who want to contribute to our financial aid fund. Help those who want to speak and/or attend but need some help.\n\nTicket sales: https://www.eventbrite.com/e/mdoyvr2018-tickets-38821491125\n\nI love Autopkg and Autopkgr. They feed Munki and they keep me fed.\n\nSometimes Autopkg gives an error that doesn‚Äôt make sense since you don‚Äôt have enough info. Like this one:\n\nThat‚Äôs no way to make friends. Nope.\n\nIf even I understood all that‚Ä¶ which is saying a lot. It doesn‚Äôt tell us what to do, or where to go to fix it.\n\nGit makes sense, but maybe not in the context of Autopkgr errors. It wants us to ‚ÄúGit add or rm‚Äù (remove) offending items, but what does it have to do with what we‚Äôre doing at this moment? Hmm. Ok, we know that autopkgr uses autopkg which uses git but that still leaves us in the dark about what‚Äôs going on.\n\nDrop down in terminal and poke at autopkg. That always helps.\n\nbash-3.2$ autopkg Usage: autopkg <verb> <options>, where <verb> is one of the following: help (Display this help) info (Get info about configuration or a recipe) install (Run one or more install recipes. Example: autopkg install Firefox -- equivalent to: autopkg run Firefox.install) list-processors (List available core Processors) list-recipes (List recipes available locally) make-override (Make a recipe override) processor-info (Get information about a specific processor) repo-add (Add one or more recipe repo from a URL) repo-delete (Delete a recipe repo) repo-list (List installed recipe repos) repo-update (Update one or more recipe repos) run (Run one or more recipes) search (Search for recipes on GitHub.) version (Print the current version of autopkg) autopkg <verb> --help for more help for that verb\n\nLooking at all that we notice that ‚Äúrepo-update‚Äù is most likely the autopkg command that gets activated when Autopkgr gui ‚Äúupdate repos now‚Äù button gets clicked.\n\nRunning autopkg with repo-update option gets us a better error message.\n\nAttempting git pull for /Users/awesome/Library/AutoPkg/RecipeRepos/ com.github.autopkg.wardsparadox-recipes... ERROR: Pull is not possible because you have unmerged files. Please, fix them up in the work tree, and then use 'git add/rm <file>' as appropriate to mark resolution and make a commit.\n\nSo, at least we know now what is causing that error that Autopkgr showed us. Quick fix:\n\nautopkg repo-delete https://github.com/autopkg/wardsparadox-recipes.git\n\nAnd then we go on and pretend like nothing happened and continue on with our day, amirate? Maybe we go to the Mac Admins Slack autopkg channel and ask our colleagues, or post on the autopkg mail-list. Or we write a blog post.\n\nMore information:\n\nThe Autopkgr read me has troubleshooting tips\n\nIn the archives:\n\nI first wrote about troubleshooting Autopkgr 2 years ago"
    }
}