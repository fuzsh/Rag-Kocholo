{
    "id": "dbpedia_8583_3",
    "rank": 21,
    "data": {
        "url": "https://github.com/coapp/coapp.org/blob/master/src/dynamic/tutorials/autopackage-guide.html.md",
        "read_more_link": "",
        "language": "en",
        "title": "coapp.org/src/dynamic/tutorials/autopackage-guide.html.md at master Â· coapp/coapp.org",
        "top_image": "https://opengraph.githubassets.com/89fd9a6899c4f3d99c16761dbbab1ba90968753a9300c62d686285de05d4ff4a/coapp/coapp.org",
        "meta_img": "https://opengraph.githubassets.com/89fd9a6899c4f3d99c16761dbbab1ba90968753a9300c62d686285de05d4ff4a/coapp/coapp.org",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Website. Contribute to coapp/coapp.org development by creating an account on GitHub.",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/coapp/coapp.org/blob/master/src/dynamic/tutorials/autopackage-guide.html.md",
        "text": "layout title version\n\narticle\n\nAutoPackage\n\n0.1\n\nThis is a draft document -- send feedback to hanrahat@microsoft.com, or submit a pull request\n\n## Automated Package Creation\n\nAutoPackage is designed to automate the CoApp package creation process. It allows you to define the build options you want to control and lets you determine the number and types of packages you create for a particular software component. For example, if you're building a library component, you can choose to create a dynamic link, static link or standard call (stdcall) variant of the package, or you can choose to create all three. You can choose to create the packages targeted to Win32, x64 or ARM platforms, or all three. This document gives examples of the AutoPackage scripts you need to write in order to manage the package creation process.\n\nAutoPackage scripts are identified with the extension .autopkg and follow the PropertySheet format.\n\nNOTE! The AutoPackage script format is constantly evolving to include new output formats. At present all supported formats will be presented on this page, but as this tool evolves, these instructions may be divided into seperate pages according to the desired output.\n\nThere is an implicit AutoPackage script built into the tools which sets the default properties for package creation across the complete range of build options. It is automatically loaded loaded by AutoPackage before processing on user files begins.\n\nFor more detailed information about the implicit script, read here.\n\nA top-level node which is common to all output formats is the configurations node, which contains descriptors for file and package variants that may affect the package consumer or have an impact on where files are placed. There are some defaults defined by the implicit AutoPackage script which should cover a majority of the pivots most packages will need. Additional pivots may be added as described in the AutoPackage Reference if needed.\n\nThe initial and primary output type is NuGet packages. The design of NuGet packages is such that all supported variations are expected to be included in the same package file. These packages must also contain a variety of metadata for discoverability and administrative purposes. In an effort to make doing all of this as painless as possible, particularly for native libraries, all of the file and metadata information can be entered into the .autopkg file, from which all defined variations for all necessary output files will be generated in a single action.\n\nA NuGet package's definition is contained in the nuget top-level node. Below we walk through this definition for the common library, zlib. This is just a basic example to show how most of these nodes and definitions work to produce the output packages.\n\nFirst the NuGet metadata, which resides in the nuspec node:\n\nnuspec { id = zlib; version : ${package-version}; title: ZLib compression library; authors: { \"Jean-loup Gailly\", \"Mark Adler\", \"Garrett Serack\", \"Tim Rogers\" }; owners: Garrett Serack; licenseUrl: \"http_://zlib.net/zlib_license.html\"; projectUrl: \"http_://github.com/coapp-packages/zlib\"; iconUrl: \"http_://zlib.net/images/zlib3d-b1.png\"; requireLicenseAcceptance:false; summary:A zlib library; description: @\"A native zlib library. zlib homepage: http://zlib.net\"; releaseNotes: \"Release of zlib 1.2.7 libraries.\"; copyright: Copyright 2013; tags: { zlib, native, coapp, }; };\n\nFor information on appropriate values for these fields, please refer to the NuGet documentation on the subject. Of particular interest to us is the id field, which determines the default output filenames.\n\nThe files node defines the files to be included in this package. There are multiple pre-defined collections which should cover the vast majority of needs for NuGet library packages. These include:\n\nsource - Files in this collection will be added as source files to the ${id}.symbols.nupkg file.\n\nsymbols - These files will be added as debug symbols to the ${id}.symbols.nupkg file.\n\ndocs - Documentation files. These are not copied or included in the consuming project, but are made available in the directory tree to which the package is installed. These are added to the ${id}.nupkg file.\n\ninclude - Files in this collection will be placed into an include directory, which will be added to the include path for consuming projects. These are added to ${id}.nupkg.\n\nlib - Link-time library files (typically ending in .lib). These will automatically be added to the linker command line of consuming projects as additional libraries to link with. These are added to ${id}.nupkg.\n\nbin - Binaries or run-time libraries (typically ending in .dll). These will be copied to the output directory of the consuming project after a successful build. These files are added to the ${id}.redist.nupkg package.\n\nAdditional file collections may be defined in the manner described here. Existing collections may also be adjusted or re-defined in the same way.\n\nAll of these pre-defined collections can accept both global and condition-specific file specifiers. A file specifier is simply a string path to the file(s) to include in the collection which may contain wildcards. File specifiers should relative paths from the location of the .autopkg file being processed.\n\nThe following are all perfectly acceptable file specifiers:\n\n..\\includes\\*.h\n\n.\\docs\\**\\*\n\n..\\output\\v110\\x64\\Release\\MyLib.dll\n\nAdding files to a collection at a global level means that those files will always be present in and connected to consuming projects regardless of the conditions specified in the consuming project. This is typically desirable for header files and documentation, which commonly do not change from one set of conditions to another.\n\nAn example of global usage:\n\nfiles { include += { ..\\include\\*.h, ..\\include\\*.hpp } };\n\nAdding files to a collection at a condition-specific level means that those files will only be connected to consuming projects when those conditions are set in the consuming project. This is frequently necessary for link-time and run-time libraries, which will differ from one set of build conditions to another.\n\nAn example of condition-specific usage:\n\nAs evidenced by the example above, the order in which the conditions are specified does not matter and they will be normalized during processing.\n\nYou may also use replacement variables to simplify the above structure:\n\nfiles { (\"Win32,x64\", \"Release,Debug\") => { [${0},${1}] { bin: ..\\output\\${0}\\${1}\\${pkgname}.dll; lib: ..\\output\\${0}\\${1}\\${pkgname}.lib; symbols: ..\\output\\${0}\\${1}\\${pkgname}.pdb; } } };\n\nIn this case, any files that are not found (such as the .pdb file in the Release configuration) will produce warnings but will otherwise be ignored, and the package will be produced as if the missing files were not specified.\n\nThe props and targets nodes are identical in all ways except with regards to when they take effect. Both of these nodes have a direct impact on projects which consume this package by way of prepending or appending various properties or values into the Visual Studio project file. These are ideal places to insert any defines that are necessary to properly link with your libraries which have no relevance to other projects. As a general rule, it is\n\nOK to add defines that are specific to this (and ONLY this) library,\n\nnot OK to include defines that have any purpose outside this library.\n\nIn a similar fashion to the files node, the props and targets nodes, the pre-defined collections for these nodes will function properly for both global and condition-specific scopes.\n\nAn example from our zlib.autopkg:\n\ntargets { Defines += HAS_ZLIB; [dynamic] Defines += ZLIB_DLL; [stdcall] Defines += ZLIB_WINAPI; };"
    }
}