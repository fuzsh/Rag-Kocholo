{
    "id": "dbpedia_8583_1",
    "rank": 52,
    "data": {
        "url": "https://parceljs.org/features/development/",
        "read_more_link": "",
        "language": "en",
        "title": "Development",
        "top_image": "https://parceljs.org/assets/og.png",
        "meta_img": "https://parceljs.org/assets/og.png",
        "images": [
            "https://parceljs.org/parcel.fb905a63.png",
            "https://parceljs.org/logo.49e8bbc1.svg",
            "https://parceljs.org/image.2d5f6c1f.svg",
            "https://parceljs.org/react.71dfc3a7.svg",
            "https://parceljs.org/webext.df55febd.svg",
            "https://parceljs.org/javascript.8e522547.svg",
            "https://parceljs.org/html5.8e9b85e2.svg",
            "https://parceljs.org/postcss.e1ddbaa1.svg",
            "https://parceljs.org/svg.70ad37f9.svg",
            "https://parceljs.org/typescript.3f240efe.svg",
            "https://parceljs.org/coffeescript.65ea83d0.svg",
            "https://parceljs.org/sass.c79925d8.svg",
            "https://parceljs.org/stylus.6d90e346.svg",
            "https://parceljs.org/less.d647b6fb.svg",
            "https://parceljs.org/sugarss.82d72cf4.svg",
            "https://parceljs.org/vue.f537d6f0.svg",
            "https://parceljs.org/elm.57b1d733.svg",
            "https://parceljs.org/json.9d49c9f7.svg",
            "https://parceljs.org/toml.c57411f8.svg",
            "https://parceljs.org/graphql.abe88238.svg",
            "https://parceljs.org/yaml.7efa81f5.svg",
            "https://parceljs.org/openGL.f24bd5d9.svg",
            "https://parceljs.org/pug.4241fb92.svg",
            "https://parceljs.org/mdx.6d2aad45.svg",
            "https://parceljs.org/xml.c5f44a73.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Parcel includes a development server out of the box supporting hot reloading, HTTPS, an API proxy, and more.",
        "meta_lang": "en",
        "meta_favicon": "https://parceljs.org/favicon.fe6f9d11.ico",
        "meta_site_name": "",
        "canonical_link": "https://parceljs.org/features/development/",
        "text": "Parcel includes a development server out of the box supporting hot reloading, HTTPS, an API proxy, and more.\n\nDev server\n\n#\n\nParcel’s builtin dev server is automatically started when you run the default parcel command, which is a shortcut for parcel serve. By default, it starts a server at http://localhost:1234. If port 1234 is already in use, then a fallback port will be used. After Parcel starts, the location where the dev server is listening will be printed to the terminal.\n\nThe dev server supports several options, which you can specify via CLI options:\n\n-p, --port – Overrides the default port. The PORT environment variable can also be used to set the port.\n\n--host – By default, the dev server accepts connections on all interfaces. You can override this to specify that only connections from certain hosts should be accepted.\n\n--open – Automatically opens the entry in your default browser after Parcel starts. You can also pass a browser name to open a different browser, e.g. --open safari.\n\nHot reloading\n\n#\n\nAs you make changes to your code, Parcel automatically rebuilds the changed files and updates your app in the browser. By default, Parcel fully reloads the page, but in some cases it may perform Hot Module Replacement (HMR). HMR improves the development experience by updating modules in the browser at runtime without needing a whole page refresh. This means that application state can be retained as you change small things in your code.\n\nCSS changes are automatically applied via HMR with no page reload necessary. This is also true when using a framework with HMR support built in, like React (via Fast Refresh), and Vue.\n\nIf you’re not using a framework, you can opt into HMR using the module.hot API. This will prevent the page from being reloaded, and instead apply the update in-place. module.hot is only available in development, so you'll need to check that it exists before using it.\n\nif (module.hot) {\n\nmodule.hot.accept();\n\n}\n\nHMR works by replacing the code for a module, and then re-evaluating it and along with all of its parents. If you need to customize this process, you can hook into it using the module.hot.accept and module.hot.dispose methods. These let you save and restore state inside the new version of the module.\n\nmodule.hot.dispose accepts a callback which is called when that module is about to be replaced. Use it to save any state to restore in the new version of the module in the provided data object, or cleanup things like timers that will be re-created in the new version.\n\nmodule.hot.accept accepts a callback function which is executed when that module or any of its dependencies are updated. You can use this to restore state from the old version of the module using the data stored in module.hot.data.\n\nif (module.hot) {\n\nmodule.hot.dispose(function (data) {\n\ndata.updated = Date.now();\n\n});\n\nmodule.hot.accept(function (getParents) {\n\nlet { updated } = module.hot.data;\n\n});\n\n}\n\nDevelopment target\n\n#\n\nWhen using the dev server, only a single target can be built at once. By default, Parcel uses a development target that supports modern browsers. This means that transpilation of modern JavaScript syntax for older browsers is disabled.\n\nIf you need to test in a older browser, you can provide the --target CLI option to choose which of your targets to build. For example, to build the \"legacy\" target defined in your package.json, use --target legacy. If you don't have any explicit targets defined, and only have a browserslist in your package.json, you can use the implicit default target with --target default. This will result in your source code being transpiled just as it would be in production.\n\nSee the Targets documentation for more information.\n\nLazy mode\n\n#\n\nIn development, it can be frustrating to wait for your entire app to build before the dev server starts up. This is especially true when working on large apps with many pages. If you’re only working on one feature, you shouldn’t need to wait for all of the others to build unless you navigate to them.\n\nYou can use the --lazy CLI flag to tell Parcel to defer building files until they are requested in the browser, which can significantly reduce development build times. The server starts quickly, and when you navigate to a page for the first time, Parcel builds only the files necessary for that page. When you navigate to another page, that page will be built on demand. If you navigate back to a page that was previously built, it loads instantly.\n\nparcel 'pages/*.html' --lazy\n\nThis also works with dynamic import(), not just separate entries. So if you have a page with a dynamically loaded feature, that feature will not be built until it is activated. When it is requested, Parcel eagerly builds all of the dependencies as well, without waiting for them to be requested.\n\nCaching\n\n#\n\nParcel caches everything it builds to disk. If you restart the dev server, Parcel will only rebuild files that have changed since the last time it ran. Parcel automatically tracks all of the files, configuration, plugins, and dev dependencies that are involved in your build, and granularly invalidates the cache when something changes. For example, if you change a configuration file, all of the source files that rely on that configuration will be rebuilt.\n\nBy default, the cache is stored in the .parcel-cache folder inside your project. You should add this folder to your .gitignore (or equivalent) so that it is not committed in your repo. You can also override the location of the cache using the --cache-dir CLI option.\n\nCaching can also be disabled using the --no-cache flag. Note that this only disables reading from the cache – a .parcel-cache folder will still be created.\n\nHTTPS\n\n#\n\nSometimes, you may need to use HTTPS during development. For example, you may need to use a certain hostname for authentication cookies, or debug mixed content issues. Parcel’s dev server supports HTTPS out of the box. You can either use an automatically generated certificate, or provide your own.\n\nTo use an automatically generated self-signed certificate, use the --https CLI flag. The first time you load the page, you may need to manually trust this certificate in your browser.\n\nparcel src/index.html --https\n\nTo use a custom certificate, you’ll need to use the --cert and --key CLI options to specify the certificate file and private key respectively.\n\nparcel src/index.html --cert certificate.cert --key private.key\n\nAPI proxy\n\n#\n\nTo better emulate the actual production environment when developing web apps, you can specify paths that should be proxied to another server (e.g. your real API server or a local testing server) in a .proxyrc, .proxyrc.json or .proxyrc.js file.\n\n.proxyrc / .proxyrc.json\n\n#\n\nIn this JSON file, you specify an object where every key is a pattern against which the URL is matched and the value is a http-proxy-middleware options object:\n\nThis example would cause http://localhost:1234/api/endpoint to be proxied to http://localhost:8000/endpoint.\n\n.proxyrc.js\n\n#\n\nFor more complex configurations, a .proxyrc.js file allows you to attach any connect-compatible middleware. First, make sure you install http-proxy-middleware into your project. This example has the same behaviour as the .proxyrc version above.\n\nIf you would like to write this as an ES module instead, you can do so using a .proxyrc.mjs file, or by using the \"type\": \"module\" option in your package.json.\n\nFile watcher\n\n#\n\nTo support an optimal caching and development experience Parcel utilizes a very fast watcher written in C++ that integrates with low-level file watching functionality of each operating system. Using this watcher Parcel watches every file in your project root (including all node_modules). Based on events and metadata from these files, Parcel determines which files need to be rebuilt.\n\nKnown issues with file watching\n\n#\n\nSafe Write\n\n#\n\nSome text editors and IDE's have a feature called \"safe write\" that prevents data loss by taking a copy of the file and renaming it when saved. However, this feature can prevent automatic detection of file updates.\n\nTo disable safe write, use the options provided below:\n\nSublime Text 3: add atomic_save: \"false\" to your user preferences.\n\nIntelliJ: use search in the preferences to find \"safe write\" and disable it.\n\nVim: add :set backupcopy=yes to your settings.\n\nWebStorm: uncheck Use \"safe write\" in Preferences > Appearance & Behavior > System Settings.\n\nvis: add :set savemethod inplace to your settings.\n\nLinux: No space left on device\n\n#\n\nDepending on the size of your project, and your operating system's watcher limit, this error might pop up when you're running Parcel on Linux. To resolve this issue, change the sysctlconfiguration for fs.inotify to have a higher value for max_user_watches.\n\nYou can do this by adding or changing the following lines in /etc/sysctl.conf:\n\nfs.inotify.max_queued_events = 16384 fs.inotify.max_user_instances = 128 fs.inotify.max_user_watches = 16384\n\nIf this error persists you can try increasing the values even more.\n\nUsing Dropbox, Google Drive or other cloud storage solutions\n\n#\n\nIt is best practice to not place a Parcel project in a folder that is synced to the cloud using something like Dropbox or Google Drive. These solutions create a lot of file system events that can mess with our watcher and cause unnecessary rebuilds.\n\nAuto install\n\n#\n\nWhen you use a language or plugin that isn’t included by default, Parcel will automatically install the necessary dependencies into your project for you. For example, if you include a .sass file, Parcel will install the @parcel/transformer-sass plugin. When this happens, you'll see a message in the terminal, and the new dependency will be added to the devDependencies in your package.json.\n\nParcel automatically detects which package manager you use in your project based on the lock file. For example, if yarn.lock is found, then Yarn will be used to install packages. If no lock file is found, then the package manager is chosen based on what is installed on your system. The following package managers are currently supported, listed in priority order:\n\nYarn\n\nPnpm\n\nNpm\n\nAuto install only occurs during development by default. During production builds, if a dependency is missing, the build will fail. You can also disable auto install during development using the --no-autoinstall CLI flag."
    }
}