{
    "id": "dbpedia_3236_3",
    "rank": 21,
    "data": {
        "url": "https://sessionize.com/gopinath-langote/",
        "read_more_link": "",
        "language": "en",
        "title": "Gopinath Langote's Speaker Profile",
        "top_image": "https://sessionize.com/landing/images/brand/social/image.png",
        "meta_img": "https://sessionize.com/landing/images/brand/social/image.png",
        "images": [
            "https://sessionize.com/landing/images/sessionize-logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "I am a Software Engineer with good experience in designing and implementing complex web and mobile applications with microservices architecture. Open ...",
        "meta_lang": "en",
        "meta_favicon": "/favicon",
        "meta_site_name": "",
        "canonical_link": "https://sessionize.com/gopinath-langote/",
        "text": "Monolith To Microservices - Where everyone has to pay\n\nNowadays, microservices architecture is at the peak of every organization in order to scale system and team hypergrowth. At N26 (Payments Cards Group Specifically) we started this journey of the monolith to microservice around a year back and we are almost to the end of new highly scalable, domain-driven microservices architecture.\n\nWe had to move the card lifecycle related functionality from our monolith service to new microservices solely responsible for card management (ordering, block, unblock, settings and limits etc). When we started this project in our team, there were no product (feature) requirements as such. The entire team goal was to move functionality to the new service(CMS - Card Management System). But later we had to support multiple customer-facing features in this journey. We took the approach of making both services running on life with shared functionality instead of building an entirely new system and switching all traffic to there.\n\nThis talk is all about the technical blockers that we had. It focuses on how we managed to not have downtime, maintenance mode, better customer experience, system quality using best engineering practices - This talk will include those strategies. It is also true that not everything is possible to do with engineering, sometimes other roles also help us to solve such challenges like PO/QA/Leads, even customers. Hence, the last part in the title - *Where everyone has to pay*. How each and every stakeholder helped the team to move the architecture - will be part of my talk. How we managed to give the best N26 feature to customer â€“ YOU card color - https://n26.com/en-de/you-bank-account-with-travel-insurance, even in the middle of the migration.\n\nOutline/structure of the Session\n\n1. Highlight on why monolith to microservice - 5 min\n\n2. Introduction to N26 journey to microservice with the problem statement - 5 min\n\n3. Engineer practices helped us to services - we call it a - migration framework - 15 min\n\n4. Stakeholders role in solving each problem - a perspective - 15 min\n\n5. Q&A - 5 min\n\nLearning Outcomes\n\n1. Why micro-services - to scale system\n\n2. Enterprise case study of moving banks to micro-services\n\n3. Common practices to follow in this journey\n\n4. How to build a migration framework\n\n5. Taking advantages of other roles in the migration phase\n\n6. Case study on moving monolith to microservices\n\nConfidently Releasing Microservices With Consumer-Driven Contract Testing\n\nMany teams working with microservices need confidence they don't break functionality when making changes. System integration tests, functional tests, and sometimes manual tests are older ways to obtain that confidence. These processes may take more than 1 day or even more if different teams or a different company own the services.\n\nTo ensure the same level of confidence and speed up delivery, we can create Contracts for integrations between consumers and providers. Contracts created by consumer services need to pass with every build going in production to guarantee the integrations between systems/services work fine. Checking these contracts in a CI/CD pipeline makes feedback loops even faster.\n\nA Contract is a collection of agreements between a Consumer and a Provider that describes the interactions that can take place between them. Consumer-Driven Contracts (CDCs) is a pattern that drives the development of the Providers from its Consumer's point of view. It is TDD for microservices.\n\nThis talk covers an end to end demo of contract testing between two microservices to show how to release microservices with confidence, get early feedback, speed up delivery, and comparison with other testing strategies.\n\nHappy CDC!\n\nOutline/structure of the Session\n\n1. Introduction to microservices common deployment patterns\n\n2. The pitfall of a couple of deployment strategies\n\n3. Introduction to Consumer-Driven Contract Tests\n\n4. How CDC helps in speeding up the Continuous Delivery\n\n5. Demo of CDC for two microservices integration.\n\n6. Putting CDC in CI/CD workflow.\n\n7. Experience using different CI/CD strategies\n\n8. How the contract testing makes feedback look faster in agile teams\n\n9. Q&A\n\nLearning Outcomes\n\n1. New testing strategy to fasten continues delivery\n\n2. Understanding multiple testing approaches\n\n3. Deploying services autonomously with confidence\n\n4. Understanding contract testing with example\n\n5. Automating service dependencies\n\n6. Putting CDC in CI/CD workflow"
    }
}