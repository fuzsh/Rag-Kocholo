{
    "id": "dbpedia_6118_0",
    "rank": 44,
    "data": {
        "url": "https://subethasoftware.com/category/retro-video-games/atari/",
        "read_more_link": "",
        "language": "en",
        "title": "Sub-Etha Software",
        "top_image": "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/05/cropped-ethafull.gif?fit=32%2C32&ssl=1",
        "meta_img": "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/05/cropped-ethafull.gif?fit=32%2C32&ssl=1",
        "images": [
            "https://subethasoftware.com/wp-content/uploads/2022/03/cropped-ethafull2022.png",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/AtariAdventureCoCoGraphics2.png?fit=624%2C509&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/AtariAdventureCoCoGraphics.png?resize=625%2C510&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/AtariAdventureCoCoGraphics2.png?resize=625%2C510&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/AtariAdventureInvisibleMaze.png?fit=624%2C447&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/AtariAdventureInvisibleMaze.png?resize=625%2C448&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/AtariAdventureThinLeftWall.png?fit=624%2C447&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/CoCoAdvCastleC-scaled.jpg?resize=625%2C469&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/CoCoAdvCastle3D.jpg?resize=625%2C510&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/AtariAdventureThinRightWall.png?resize=625%2C450&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/AtariAdventureThinLeftWall.png?resize=625%2C448&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/CoCoAdvSet.jpg?fit=624%2C302&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/iPadAtariAdventure.jpg?resize=625%2C469&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2012/12/20121218-084451.jpg?resize=625%2C469&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/CoCoAdvCastleC-scaled.jpg?resize=625%2C469&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/CoCoAdvText.jpg?resize=625%2C310&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/CoCoAdvSet.jpg?resize=625%2C303&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/CoCoAdvCastle3D.jpg?resize=625%2C510&ssl=1",
            "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/12/CoCoAdvMaze3D.jpg?resize=625%2C510&ssl=1"
        ],
        "movies": [
            "https://www.youtube.com/embed/yINb5Huh0C4?feature=oembed"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Allen Huffman"
        ],
        "publish_date": "2024-03-15T12:42:00-05:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://i0.wp.com/subethasoftware.com/wp-content/uploads/2020/05/cropped-ethafull.gif?fit=32%2C32&ssl=1",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "I remember the excitement surrounding Pac-Man being released for the Atari VCS (the machine later renamed to the 2600). I was in junior high school and living in Houston, Texas at the time. I recall full page newspaper ads for this cartridge.\n\nI had played Pac-Man in the arcades a few times, but I was not good at it and therefore it was not one of my favorite games to spend a quarter on. A quarter in 1980 would be about $1 today, according to a U.S. government inflation calculator. (And yowza to that. When the Up-Down bar-arcade opened in Des Moines, Iowa about ten years ago, the inflation rate made that quarter worth about .72 then.)\n\nNo wonder my grandmother wasn’t keen on me spending money at arcades ;-)\n\nThe Pac-Man conversion was very different from the arcade original. Some of the changes made to the game were due to limitations of the hardware — such as the “dots” being replaced by “video wafers” (so said the manual) that looked like dashes. The power pills were squares. This is understandable, though future Atari ports of Pac-Man games such as Ms. Pac-Man and Jr. Pac-Man looked much better, thanks to using twice as much cartridge ROM as the original Atari Pac-Man.\n\nHowever, other changes to the game — such as playing a tune that was NOT the Pac-Man tune, and having the tunnels at the top and bottom of the screen rather than the sides, along with a maze that did not at all resemble the arcade original, seemed … just wrong. It was “Pac-Man in name only.”\n\nIt dawns on me that many of this “in name only” ports were more “inspired by”– new games using elements inspired by the original. This is much like how movies based on books are made–changing the plot so much it is barely recognizable except for some character names and general concepts.\n\nThe more movies I see that are quite different than their source material, the more I understand the 1982 Atari Pac-Man.\n\nAfter all, we have seen modern programmers use the same 4K ROM size and create a much more faithful Pac-man (see video below) though I do not know if they could have written this in the same time constraints the Atari programmer had to do his version in…\n\nFor an interesting history on the original Atari Pac-Man, check out this video:\n\nUntil next time…\n\nSee also: part 1, part 2, part 3, part 4 … and more to come…\n\nObjectively speaking\n\nWelcome back to the world of Atari Adventure! After spending some time figuring out how the rooms were drawn, it’s time to look at how the game objects are drawn.\n\nAdventure contains many objects that can be displayed:\n\nBat\n\nBridge\n\nCastle gate (or Portcullis – “a strong, heavy grating sliding up and down in vertical grooves, lowered to block a gateway to a fortress or town.”)\n\nChalice\n\nCreated by Warren Robinett (author’s name)\n\nDot (for getting in to the easter egg room)\n\nDragon (red, green and yellow)\n\nKey\n\nMagnet\n\nNumber “1” (for game select screen)\n\nNumber “2”\n\nNumber “3”\n\nSword\n\nSome objects have multiple frames. For instance, the bat has two: wings up, and wings down. The dragon has three: open mouth, closed mouth, dead. The dragons can also be drawn facing left, or facing right.\n\nI also found an entry for something called “Surround,” which appears to be the the square around the player in the invisible mazes.\n\nIn the ROM disassembly, it looks like these objects are just stored as bytes that represent them:\n\nGfxChallise: .byte $81 ;X X .byte $81 ;X X .byte $C3 ;XX XX .byte $7E ; XXXXXX .byte $7E ; XXXXXX .byte $3C ; XXXX .byte $18 ; XX .byte $18 ; XX .byte $7E ; XXXXXX .byte $00\n\nAbove, the game-winning chalice appears to be 8×9.\n\nThe dragon is much larger:\n\nGfxDrag0: .byte $06 ; XX .byte $0F ; XXXX .byte $F3 ;XXXX XX .byte $FE ;XXXXXXX .byte $0E ; XXX .byte $04 ; X .byte $04 ; X .byte $1E ; XXXX .byte $3F ; XXXXXX .byte $7F ; XXXXXXX .byte $E3 ;XXX XX .byte $C3 ;XX XX .byte $C3 ;XX XX .byte $C7 ;XX XXX .byte $FF ;XXXXXXXX .byte $3C ; XXXX .byte $08 ; X .byte $8F ;X XXXX .byte $E1 ;XXX X .byte $3F ; XXXXXX .byte $00\n\nBut it is still represented as 8 pixels wide. The code to display it must magnify it to make it larger on screen.\n\nEven the bridge, the widest object displayed in the game, is represented as 8-bits wide. This is the first thing we will need to dig in to… What controls how large these small object representations are drawn?\n\nAlso, it appears every object is terminated with a $00 rather than having the length at the start. For example, instead of this:\n\n10 READ N:FOR I=1 TO N:READ A$:PRINT A$:NEXT:END 20 DATA 10,a,b,c,d,e,f,g,h,i,j\n\n…it works like this:\n\n10 READ A$:IF A$=\"0\" THEN END ELSE PRINT A$:GOTO 10:END 20 DATA a,b,c,d,e,f,g,h,i,0\n\nSince both would have taken the same amount of data storage space in the ROM, I am betting the code to parse that data may have been smaller to loop and check for 0 versus loading a size and counting down.\n\nAlso, this presents a restriction for the graphics — none can contain an “empty” row in the graphic ($00). Because of this, each line (byte) must have at least one pixel set. This explains the dots in the easter egg signature!\n\n;Object #4 : State FF : Graphic GfxAuthor: .byte $F0 ;XXXX .byte $80 ;X .byte $80 ;X .byte $80 ;X .byte $F4 ;XXXX X .byte $04 ; X .byte $87 ;X XXX .byte $E5 ;XXX X X .byte $87 ;X XXX .byte $80 ;X .byte $05 ; X X .byte $E5 ;XXX X X .byte $A7 ;X X XXX .byte $E1 ;XXX X .byte $87 ;X XXX .byte $E0 ;XXX .byte $01 ; X .byte $E0 ;XXX .byte $A0 ;X X .byte $F0 ;XXXX .byte $01 ; X .byte $40 ; X .byte $E0 ;XXX .byte $40 ; X .byte $40 ; X .byte $40 ; X .byte $01 ; X .byte $E0 ;XXX .byte $A0 ;X X .byte $E0 ;XXX .byte $80 ;X .byte $E0 ;XXX .byte $01 ; X .byte $20 ; X .byte $20 ; X .byte $E0 ;XXX .byte $A0 ;X X .byte $E0 ;XXX .byte $01 ; X .byte $01 ; X .byte $01 ; X .byte $88 ; X X .byte $A8 ;X X X .byte $A8 ;X X X .byte $A8 ;X X X .byte $F8 ;XXXXX .byte $01 ; X .byte $E0 ;XXX .byte $A0 ;X X .byte $F0 ;XXXX .byte $01 ; X .byte $80 ;X .byte $E0 ;XXX .byte $8F ;X XXXX .byte $89 ;X X X .byte $0F ; XXXX .byte $8A ;X X X .byte $E9 ;XXX X X .byte $80 ;X .byte $8E ;X XXX .byte $0A ; X X .byte $EE ;XXX XXX .byte $A0 ;X X .byte $E8 ;XXX X .byte $88 ;X X .byte $EE ;XXX XXX .byte $0A ; X X .byte $8E ;X XXX .byte $E0 ;XXX .byte $A4 ;X X X .byte $A4 ;X X X .byte $04 ; X .byte $80 ;X .byte $08 ; X .byte $0E ; XXX .byte $0A ; X X .byte $0A ; X X .byte $80 ;X .byte $0E ; XXX .byte $0A ; X X .byte $0E ; XXX .byte $08 ; X .byte $0E ; XXX .byte $80 ;X .byte $04 ; X .byte $0E ; XXX .byte $04 ; X .byte $04 ; X .byte $04 ; X .byte $80 ;X .byte $04 ; X .byte $0E ; XXX .byte $04 ; X .byte $04 ; X .byte $04 ; X .byte $00\n\nThose rows would have been empty, but having a $00 there would have prevented there rest from being drawn. Interesting!\n\nDraw something\n\nFor today’s installment, I’ll be using Color BASIC on a CoCo emulator to write a simple program to plot these objects on the screen. I copied all of the assembly definitions into an editor then did a search and replace to turn those .byte instructions into incredibly inefficient one-number-per-line DATA statements like this:\n\n2830 ' Object #10 : State FF : Graphic 2840 ' GfxChallise: 2850 DATA &H81 ' X X 2860 DATA &H81 ' X X 2870 DATA &HC3 ' XX XX 2880 DATA &H7E ' XXXXXX 2890 DATA &H7E ' XXXXXX 2900 DATA &H3C ' XXXX 2910 DATA &H18 ' XX 2920 DATA &H18 ' XX 2930 DATA &H7E ' XXXXXX 2940 DATA &H00\n\nUnfortunately, READ/DATA in Color BASIC does not allow that. It will READ the first value, then give an ?SN ERROR when it tries to read the next because the parser doesn’t handle the apostrophe “REM” marker!\n\nSo I changed it to this:\n\n2830 ' Object #10 : State FF : Graphic 2840 ' GfxChallise: 2850 DATA &H81:REM X X 2860 DATA &H81:REM X X 2870 DATA &HC3:REM XX XX 2880 DATA &H7E:REM XXXXXX 2890 DATA &H7E:REM XXXXXX 2900 DATA &H3C:REM XXXX 2910 DATA &H18:REM XX 2920 DATA &H18:REM XX 2930 DATA &H7E:REM XXXXXX 2940 DATA &H00\n\nThis also fails — and is a problem I only recently discovered when writing my Base-64 articles.\n\nI guess I can’t have this code be as bulky and inefficient as I wanted. I removed them so it was just the DATA statements:\n\n2830 ' Object #10 : State FF : Graphic 2840 ' GfxChallise: 2850 DATA &H81 2860 DATA &H81 2870 DATA &HC3 2880 DATA &H7E 2890 DATA &H7E 2900 DATA &H3C 2910 DATA &H18 2920 DATA &H18 2930 DATA &H7E 2940 DATA &H00\n\nOh well. Who needs comments anyway — especially in BASIC where they just bloat the code and slow it down.\n\nA quick-and-dirty routine allowed me to see it was working:\n\n…but there was no way I was going to be able to fit the “Created by Warren Robinett” graphic on a low-res 64×32 screen. To solve this, I hacked together a version that used a “high resolution” screen:\n\nIt looks like the data is pretty straight forward. The dragons would have to be drawn reversed to make them face right, and the bridge looks like it needs an X scaling factor added to make it as wide as it is in the game. But, not bad for a first attempt.\n\nJust for fun, here is the brute-force hacky nasty Color BASIC code I quickly put together to do this:\n\n10 REM AdvObjs.bas 20 POKE 65395,0 30 FOR A=0 TO 7:BT(A)=2^A:NEXT 40 CLS0:XS=1:YS=1:Y=1 50 PMODE 1,1:PCLS:SCREEN 1,0 60 READ V:IF V=-1 THEN 120 ELSE IF V=0 THEN 90 70 X=XS:FOR A=7 TO 0 STEP-1:IF V AND BT(A) THEN PSET(X*2,Y*2,C) 80 X=X+1:NEXT:Y=Y+1:GOTO 60 90 XS=XS+9:IF XS>120 THEN XS=1:YS=YS+32 100 C=C+1:IF C=1 THEN C=2 ELSE IF C>3 THEN C=0 110 Y=YS:GOTO 60 120 GOTO 120 130 ' Object #0A : State FF : Graphic 140 ' GfxBridge: 150 DATA &HC3 160 DATA &HC3 170 DATA &HC3 180 DATA &HC3 190 DATA &H42 200 DATA &H42 210 DATA &H42 220 DATA &H42 230 DATA &H42 240 DATA &H42 250 DATA &H42 260 DATA &H42 270 DATA &H42 280 DATA &H42 290 DATA &H42 300 DATA &H42 310 DATA &H42 320 DATA &H42 330 DATA &H42 340 DATA &H42 350 DATA &HC3 360 DATA &HC3 370 DATA &HC3 380 DATA &HC3 390 DATA &H00 400 ' Object #5 State #1 Graphic :'1' 410 ' GfxNum1: 420 DATA &H04 430 DATA &H0C 440 DATA &H04 450 DATA &H04 460 DATA &H04 470 DATA &H04 480 DATA &H0E 490 DATA &H00 500 ' Object #0B : State FF : Graphic 510 ' GfxKey: 520 DATA &H07 530 DATA &HFD 540 DATA &HA7 550 DATA &H00 560 ' Object #5 State #2 Grphic : 570 ' GfxNum2: 580 DATA &H0E 590 DATA &H11 600 DATA &H01 610 DATA &H02 620 DATA &H04 630 DATA &H08 640 DATA &H1F 650 DATA &H00 660 ' Object #5 State #3 Graphic :'3' 670 ' GfxNum3: 680 DATA &H0E 690 DATA &H11 700 DATA &H01 710 DATA &H06 720 DATA &H01 730 DATA &H11 740 DATA &H0E 750 DATA &H00 760 ' Object #0E : State 03 : Graphic 770 ' GfxBat1: 780 DATA &H81 790 DATA &H81 800 DATA &HC3 810 DATA &HC3 820 DATA &HFF 830 DATA &H5A 840 DATA &H66 850 DATA &H00 860 ' Object #0E : State FF : Graphic 870 ' GfxBat2: 880 DATA &H01 890 DATA &H80 900 DATA &H01 910 DATA &H80 920 DATA &H3C 930 DATA &H5A 940 DATA &H66 950 DATA &HC3 960 DATA &H81 970 DATA &H81 980 DATA &H81 990 DATA &H00 1000 ' Object #6 : State #00 : Graphic 1010 ' GfxDrag0: 1020 DATA &H06 1030 DATA &H0F 1040 DATA &HF3 1050 DATA &HFE 1060 DATA &H0E 1070 DATA &H04 1080 DATA &H04 1090 DATA &H1E 1100 DATA &H3F 1110 DATA &H7F 1120 DATA &HE3 1130 DATA &HC3 1140 DATA &HC3 1150 DATA &HC7 1160 DATA &HFF 1170 DATA &H3C 1180 DATA &H08 1190 DATA &H8F 1200 DATA &HE1 1210 DATA &H3F 1220 DATA &H00 1230 ' Object 6 : State FF : Graphic 1240 ' GfxDrag1: 1250 DATA &H80 1260 DATA &H40 1270 DATA &H26 1280 DATA &H1F 1290 DATA &H0B 1300 DATA &H0E 1310 DATA &H1E 1320 DATA &H24 1330 DATA &H44 1340 DATA &H8E 1350 DATA &H1E 1360 DATA &H3F 1370 DATA &H7F 1380 DATA &H7F 1390 DATA &H7F 1400 DATA &H7F 1410 DATA &H3E 1420 DATA &H1C 1430 DATA &H08 1440 DATA &HF8 1450 DATA &H80 1460 DATA &HE0 1470 DATA &H00 1480 ' Object 6 : State 02 : Graphic 1490 ' GfxDrag2: 1500 DATA &H0C 1510 DATA &H0C 1520 DATA &H0C 1530 DATA &H0E 1540 DATA &H1B 1550 DATA &H7F 1560 DATA &HCE 1570 DATA &H80 1580 DATA &HFC 1590 DATA &HFE 1600 DATA &HFE 1610 DATA &H7E 1620 DATA &H78 1630 DATA &H20 1640 DATA &H6E 1650 DATA &H42 1660 DATA &H7E 1670 DATA &H00 1680 ' Object #9 : State FF : Graphics 1690 ' GfxSword: 1700 DATA &H20 1710 DATA &H40 1720 DATA &HFF 1730 DATA &H40 1740 DATA &H20 1750 DATA &H00 1760 ' Object #0F : State FF : Graphic 1770 ' GfxDot: 1780 DATA &H80 1790 DATA &H00 1800 ' Object #4 : State FF : Graphic 1810 ' GfxAuthor: 1820 DATA &HF0 1830 DATA &H80 1840 DATA &H80 1850 DATA &H80 1860 DATA &HF4 1870 DATA &H04 1880 DATA &H87 1890 DATA &HE5 1900 DATA &H87 1910 DATA &H80 1920 DATA &H05 1930 DATA &HE5 1940 DATA &HA7 1950 DATA &HE1 1960 DATA &H87 1970 DATA &HE0 1980 DATA &H01 1990 DATA &HE0 2000 DATA &HA0 2010 DATA &HF0 2020 DATA &H01 2030 DATA &H40 2040 DATA &HE0 2050 DATA &H40 2060 DATA &H40 2070 DATA &H40 2080 DATA &H01 2090 DATA &HE0 2100 DATA &HA0 2110 DATA &HE0 2120 DATA &H80 2130 DATA &HE0 2140 DATA &H01 2150 DATA &H20 2160 DATA &H20 2170 DATA &HE0 2180 DATA &HA0 2190 DATA &HE0 2200 DATA &H01 2210 DATA &H01 2220 DATA &H01 2230 DATA &H88 2240 DATA &HA8 2250 DATA &HA8 2260 DATA &HA8 2270 DATA &HF8 2280 DATA &H01 2290 DATA &HE0 2300 DATA &HA0 2310 DATA &HF0 2320 DATA &H01 2330 DATA &H80 2340 DATA &HE0 2350 DATA &H8F 2360 DATA &H89 2370 DATA &H0F 2380 DATA &H8A 2390 DATA &HE9 2400 DATA &H80 2410 DATA &H8E 2420 DATA &H0A 2430 DATA &HEE 2440 DATA &HA0 2450 DATA &HE8 2460 DATA &H88 2470 DATA &HEE 2480 DATA &H0A 2490 DATA &H8E 2500 DATA &HE0 2510 DATA &HA4 2520 DATA &HA4 2530 DATA &H04 2540 DATA &H80 2550 DATA &H08 2560 DATA &H0E 2570 DATA &H0A 2580 DATA &H0A 2590 DATA &H80 2600 DATA &H0E 2610 DATA &H0A 2620 DATA &H0E 2630 DATA &H08 2640 DATA &H0E 2650 DATA &H80 2660 DATA &H04 2670 DATA &H0E 2680 DATA &H04 2690 DATA &H04 2700 DATA &H04 2710 DATA &H80 2720 DATA &H04 2730 DATA &H0E 2740 DATA &H04 2750 DATA &H04 2760 DATA &H04 2770 DATA &H00 2780 ' Object #10 : State FF : Graphic 2790 ' GfxChallise: 2800 DATA &H81 2810 DATA &H81 2820 DATA &HC3 2830 DATA &H7E 2840 DATA &H7E 2850 DATA &H3C 2860 DATA &H18 2870 DATA &H18 2880 DATA &H7E 2890 DATA &H00 2900 ' Object #11 : State FF : Graphic 2910 ' GfxMagnet: 2920 DATA &H3C 2930 DATA &H7E 2940 DATA &HE7 2950 DATA &HC3 2960 DATA &HC3 2970 DATA &HC3 2980 DATA &HC3 2990 DATA &HC3 3000 DATA &H00 3010 ' Object #1 States 940FF (Graphic) 3020 ' GfxPort01: 3030 DATA &HFE 3040 DATA &HAA 3050 'GfxPort02: 3060 DATA &HFE 3070 DATA &HAA 3080 'GfxPort03: 3090 DATA &HFE 3100 DATA &HAA 3110 'GfxPort04: 3120 DATA &HFE 3130 DATA &HAA 3140 'GfxPort05: 3150 DATA &HFE 3160 DATA &HAA 3170 'GfxPort06: 3180 DATA &HFE 3190 DATA &HAA 3200 'GfxPort07: 3210 DATA &HFE 3220 DATA &HAA 3230 'GfxPort08: 3240 DATA &HFE 3250 DATA &HAA 3260 'GfxPort09: 3270 DATA &H00 3280 DATA -1\n\nIt ain’t pretty, but it’s mine!\n\nI suppose next I should get back to looking at how the rooms are connected. And there’s some interesting stuff in here, including rooms that “change” as the game is played.\n\nStay tuned…\n\nSee also: part 1, part 2, part 3, part 4 … and more to come…\n\nDefining the invisible\n\nWhen we last left off, I was trying to figure out what all the bits did in the room definition attribute byte:\n\n;Offset 4 : Bits 5-0 : Playfield Control ; Bit 6 : True if right thin wall wanted. ; Bit 7 : True if left thin wall wanted.\n\nIn the disassembly I was looking at (created in 2006 or earlier), it did not go in to details about what “Playfield Control” was for. By some trial, I was about to work out which bits represented the right half of a room to be drawn Mirrored or Reversed, as well as the bits that defined drawing a thing left or right wall line:\n\nBit 0 - Right half of screen is Reversed. Bit 1 - ? Bit 2 - ? Bit 3 - Right half of screen Mirrored. Bit 4 - ? Bit 5 - ? Bit 6 - Thin right wall. Bit 7 - Thin left wall.\n\nThere were a few bits left over, and I knew the game had rooms that where “invisible” mazes where you only saw the portion of the maze directly around the player:\n\nThis screenshot is from game variation 2 and 3, and it is below the room to the left of the easter egg room (or, from the yellow castle, down, right, then down). By roaming around the room, and trying to match up its shape with the source code, I believe it is this location:\n\nMazeEntry: .byte $F0,$FF,$0F ;XXXXXXXXXXXXXXXX RRRRRRRRRRRRRRRR .byte $00,$30,$00 ; XX RR .byte $F0,$30,$FF ;XXXX XX XXXXXXXXRRRRRRRRR RR RRRR .byte $00,$30,$C0 ; XX XXRR RR .byte $F0,$F3,$C0 ;XXXXXXXX XX XXRR RR RRRRRRRR .byte $00,$03,$C0 ; XX XXRR RR .byte $F0,$FF,$CC ;XXXXXXXXXXXX XX XXRR RR RRRRRRRRRRRR\n\nBy looking at the room definition data for an entry that uses these graphics, I find room 10:\n\nLFE75: .byte <MazeEntry,>MazeEntry,$08,$08,$25,$03,$09,$09,$09\n\nIts attributes are $25, which is the bit pattern 00101001. Bit 5 is being used, and it wasn’t in my earlier room examples, so I believe that is for “invisible”:\n\nBit 0 - Right half of screen is Reversed. Bit 1 - ? Bit 2 - ? Bit 3 - Right half of screen Mirrored. Bit 4 - ? Bit 5 - Invisible. Bit 6 - Thin right wall. Bit 7 - Thin left wall.\n\nFor all 30 rooms defined in the ROM, I only see bits 0, 3, 5, 6 and 7 ever used. (Distinct attribute values are: $21, $24, $25, $61, and $a1. Bits 0-3 can be $1=0001, $4=1000 or $5=1001, and bits 4-7 can be $2=0010, $6=0110 or $a=1010. It seems to check out, but please double check me. I make many mistakes when writing these things and could be a … bit … off.)\n\nThis gives me five types of rooms to render.\n\nColor me bad\n\nThere is also a color value (when in Color mode) and a black and white color value (when in Black and White mode). The Atari had a switch to alter the colors the games used so they were easier to view on a black and white TV set. Later in the console’s life, not all games continued to support this switch.\n\nFor Adventure, I see various values in the ROM, but no reference to what color they generate. Some are in definitions called “Yellow Castle” or “Red Maze”, but most are not described with a color. Instead, I look at the translated translated Adventure code by Peter David Hirschberg:\n\nhttps://github.com/peterhirschberg/adventure/blob/master/src/adventure.ts\n\nYes, translates translated. Back around 2006, he converted the Adventure assembly code to C++ and wrote wrapper code to allow it to run on a modern PC under the title “Adventure: Revisited.” More recently, he took that converted C code and converted it to TypeScript. (I had to look up just what that was. It’s a Microsoft superset of JavaScript.) Because of this, you can now play his conversion inside a web browser:\n\nhttp://peterhirschberg.com/#/AdventurePlay\n\nIn his TypeScript source, he fills in some of the gaps with new comments including this nice color table:\n\nconst COLOR_BLACK=0 const COLOR_LTGRAY=1 const COLOR_WHITE=2 const COLOR_YELLOW=3 const COLOR_ORANGE=4 const COLOR_RED=5 const COLOR_PURPLE=6 const COLOR_BLUE=7 const COLOR_LTCYAN=8 const COLOR_CYAN=9 const COLOR_DKGREEN=10 const COLOR_LIMEGREEN=11 const COLOR_OLIVEGREEN=12 const COLOR_TAN=13 const COLOR_FLASH=14\n\nBut, since the original ROM code used hardware-specific values, these numbers do not map to what the assembly code used for those colors. If I wanted to parse the actual data bytes in the ROM code (rather than converting it to a modern enumerated lookup table), I’d need to know which value represented which color. Fortunately, he also updated the room definition structures to use the above labels so it’s obvious:\n\nlet roomDefs: ROOM[] = [ { graphicsData: roomGfxNumberRoom, flags: ROOMFLAG_NONE, color: COLOR_PURPLE, roomUp: 0x00, roomRight: 0x00, roomDown: 0x00, roomLeft: 0x00 }, // 0 - Number Room { graphicsData: roomGfxBelowYellowCastle, flags: ROOMFLAG_LEFTTHINWALL, color: COLOR_OLIVEGREEN, roomUp: 0x08, roomRight: 0x02, roomDown: 0x80, roomLeft: 0x03 }, // 1 - Top Access { graphicsData: roomGfxBelowYellowCastle, flags: ROOMFLAG_NONE, color: COLOR_LIMEGREEN, roomUp: 0x11, roomRight: 0x03, roomDown: 0x83, roomLeft: 0x01 }, // 2 - Top Access ...\n\nCompare those three entries with the same three in the disassembly (and note the order is a bit different):\n\nRoomDataTable: LFE1B: .byte <NumberRoom,>NumberRoom,$66,$0A,$21,$00,$00,$00,$00 LFE24: .byte <BelowYellowCastle,>BelowYellowCastle,$D8,$0A,$A1,$08,$02,$80,$03 LFE2D: .byte <BelowYellowCastle,>BelowYellowCastle, $C8,$0A,$21,$11,$03,$83,$01\n\nAnd we can assume that $66 is PURPLE, $DB is OLIVE GREEN, and $C8 is LIME GREEN. This would let us do our own Atari VCS to Whatever color table for displaying that data.\n\nOf course… I could have just played the game and gone to each room, looked at the color on the screen, then figured it out that way, but he already did the work and I was lazy.\n\nAnd I know what some of you are thinking… I could have just looked at his source code to figure out the attributes bits. But, alas, I could not. He already converted them. He translated those down to just:\n\nconst ROOMFLAG_NONE = 0x00 const ROOMFLAG_MIRROR = 0x01 // bit 0 - 1 if graphics are mirrored, 0 for reversed const ROOMFLAG_LEFTTHINWALL = 0x02 // bit 1 - 1 for left thin wall const ROOMFLAG_RIGHTTHINWALL = 0x04 // bit 2 - 1 for right thin wall\n\n…and he must have figured out that Invisible rooms all use a specific color, because he handles the invisible rooms this way:\n\nfunction Surround() { // get the playfield data const currentRoom: ROOM = roomDefs[objectBall.room] if (currentRoom.color == COLOR_LTGRAY) { // Put it in the same room as the ball (player) and center it under the ball objectSurround.room = objectBall.room objectSurround.x = (objectBall.x-0x1E)/2 objectSurround.y = (objectBall.y+0x18)/2 } ...\n\nHe rewrote the game in a manner that makes sense, rather than trying to do a literal translation of machine-specific assembly code in to C. Not that anyone would ever try such a literal translation…\n\nIt doesn’t look like he bothered to support Black and White color mode, either ;-) and neither will I.\n\nWith the graphics data, room attributes, and colors figured out, the only thing left in the room definition structure are the room exits. As I mentioned in the previous installment, those don’t all seem to be obvious.\n\nWe’ll kick that can down the road a bit, since there are a few more fun things to do before having to think again.\n\nUntil next time…\n\nSee also: part 1, part 2, part 3, part 4 … and more to come…\n\nHow the rooms are defined\n\nIn the previous installment, I introduced how the playfields were encoded in the Atari Adventure game. I had converted the assembly data into C code and made a command-line program that would print out the room graphics.\n\nI then recreated the process in Microsoft Color BASIC on a Radio Shack Color Computer emulator.\n\nMy command-line C program was displaying on an 80-column Windows command prompt window (or Mac OS X terminal) so it had plenty of room to render the 40 pixel wide playfields. The CoCo’s 32-column screen could not, so I changed the BASIC version to use low-resolution (64×32) text-mode graphics. This also let me use colors, though the CoCo only had 8 foreground colors to work with in this mode, with some restrictions from the Motorola MC6847 video display chip.\n\nThe end result was a proof-of-concept showing I was decoding the cartridge data properly, even if I couldn’t render it exactly as the Atari VCS/2600 would have.\n\nThere is much more I need to explore. For instance, each room has a definition data structure that describes things like which graphics data to use, how it is displayed (right half of the screen reversed vs mirrored, thin line on the left or white wall), its color, as well as which rooms are connected to it (Up, Left, Down and Right). Here is an example of the yellow castle data structure bytes:\n\nLFEB4: .byte <CastleDef,>CastleDef,$1A,$0A,$21,$06,$03,$02,$01\n\nThe first entry (CastleDef) is a two byte pointer to the graphics data elsewhere in the ROM:\n\n;Castle Definition CastleDef: .byte $F0,$FE,$15 ;XXXXXXXXXXX X X X R R R RRRRRRRRRRR .byte $30,$03,$1F ;XX XXXXXXX RRRRRRR RR .byte $30,$03,$FF ;XX XXXXXXXXXXRRRRRRRRRR RR .byte $30,$00,$FF ;XX XXXXXXXXRRRRRRRR RR .byte $30,$00,$3F ;XX XXXXXX RRRRRR RR .byte $30,$00,$00 ;XX RR .byte $F0,$FF,$0F ;XXXXXXXXXXXXXX RRRRRRRRRRRRRR\n\nNote that the comments above are misleading. The graphics data only describes the left side of the images (the “X” characters in the comment). The right is created as the room is displayed, based on a bit in the fourth byte of the data. Here are what all the bytes mean:\n\n;Room Data ;Offset 0 : Low byte room graphics data. ;Offset 1 : High byte room graphics data ;Offset 2 : Color ;Offset 3 : B&W Color ;Offset 4 : Bits 5-0 : Playfield Control ; Bit 6 : True if right thin wall wanted. ; Bit 7 : True if left thin wall wanted. ;Offset 5 : Room Above ;Offset 6 : Room Left ;Offset 7 : Room Down ;Offset 8 : Room Right\n\nLooking at that data again, we can describe is as:\n\nCastleDef – 2 byte pointer to graphics data.\n\n$1A – Color.\n\n$0A – B&W Color (the color to use with the Atari color switch is set to Black and White).\n\n$21 – Attributes for how to display the room.\n\n$06 – Room above (up).\n\n$03 – Room left.\n\n$02 – Room down.\n\n$01 – Room right.\n\nThis early disassembly did not specifically describe what offset 4’s bits 5-0 mean, but one of them makes the room mirror (both sides look the same) versus the default of reversed. (Odd description. To me, a mirror reverses an image. It’s more like Duplicate versus Mirror in my mind. But I digress…)\n\nThe castle is a standard Reversed room:\n\nXXXXXXXXXXX X X X R R R RRRRRRRRRRR XX XXXXXXX RRRRRRR RR XX XXXXXXXXXXRRRRRRRRRR RR XX XXXXXXXXRRRRRRRR RR XX XXXXXX RRRRRR RR XX RR XXXXXXXXXXXXXX RRRRRRRRRRRRRR\n\nIt’s attributes of $21 are the bit pattern 00100001.\n\nOne of the black castle mazes is Mirrored. Here is the room that contains the secret “dot” which is used to access the hidden easter egg room:\n\n;Black Maze #3 BlackMaze3: .byte $F0,$F0,$FF ;XXXXXXXX XXXXXXXXMMMMMMMM MMMMMMMM .byte $30,$00,$00 ;XX MM .byte $30,$3F,$FF ;XX XXXXXXXXXXXXXXMM MMMMMMMMMMMMMM .byte $00,$30,$00 ; XX MM .byte $F0,$F0,$FF ;XXXXXXXX XXXXXXXXMMMMMMMM MMMMMMMM .byte $30,$00,$03 ;XX XX MM MM .byte $F0,$F0,$FF ;XXXXXXXX XXXXXXXXMMMMMMMM MMMMMMMM\n\nNote how that “box” is made up by the Mirroring of the left half. Neat! That room is defined as:\n\nLFED8: .byte <BlackMaze3,>BlackMaze3,$08,$08,$24,$13,$16,$13,$14\n\nIts attribute of $24 is the bit pattern of 00101000.\n\nAnd in the game, the room below and to the right of the castle has a thin right wall:\n\nIf I understand which room this it, this is the data that draws it:\n\n;Left of Name Room LeftOfName: .byte $F0,$FF,$FF ;XXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRR .byte $00,$00,$00 .byte $00,$00,$00 .byte $00,$00,$00 .byte $00,$00,$00 .byte $00,$00,$00 ;Below Yellow Castle BelowYellowCastle: .byte $F0,$FF,$0F ;XXXXXXXXXXXXXXXX RRRRRRRRRRRRRRRRRRRR **Line Shared With Above Room ----^\n\nNote a clever technique programmer Warren Robinett used to save three bytes of ROM space. The room definition points to the “LeftOfName” data and a room is 21 bytes. The bottom of that room (a wall with an opening in the middle) is the same as the top of another room, so the definition uses three bytes for the next room data for the last three bytes of the first room. Clever!\n\nThe definition of the “Left Of Name” room (because the hidden easter egg room with Mr. Robinett’s name is to the right of this room) is:\n\nLFE36: .byte <LeftOfName,>LeftOfName,$E8,$0A,$61,$06,$01,$86,$02\n\nIts attribute of $61 is the bit pattern 01100001.\n\nAnd down and to the left of the castle is a room with a thin left wall:\n\nGrrr. That Yorgel the yellow dragon ate me while I was trying to take this screen shot.\n\nIf I am reading things correctly, I believe this uses the same graphics data as the room below the yellow castle (opening at top, wall at bottom, no walls on left or right):\n\nLFE24: .byte <BelowYellowCastle,>BelowYellowCastle,$D8,$0A,$A1,$08,$02,$80,$03\n\nAnd its attributes of $A1 is the bit pattern 11000001.\n\nSo we have:\n\n00100001 – Reversed (castle).\n\n00101000 – Mirrored (maze).\n\n01100001 – Reversed and thin right wall.\n\n10100001 – Reversed and thin left wall.\n\nThus, looking back at the bit definitions:\n\n;Offset 4 : Bits 5-0 : Playfield Control ; Bit 6 : True if right thin wall wanted. ; Bit 7 : True if left thin wall wanted.\n\nIt looks like we have:\n\nBit 0 – Right half of screen is Reversed.\n\nBit 1 – ?\n\nBit 2 – ?\n\nBit 3 – Right half of screen Mirrored.\n\nBit 4 – ?\n\nBit 5 – ?\n\nBit 6 – Thin right wall.\n\nBit 7 – Thin left wall.\n\nIt will take some more code exploring to see what bits 1, 2, 4 and 4 are used for, but understanding what controls Reverse and Mirrored was needed to properly draw the screens. One of those bits is probably used for rendering the “invisible” mazes, but I haven’t gotten to those yet.\n\nQuery: What happens if both bit 0 (Reverse) and bit 3 (Mirrored) are on? Why would those be separate bits? Perhaps there was an efficiency reason for checking for a set bit (less instructions than checking for a clear bit?) or perhaps bit 3 is something else. I guess I need to do more checking in to this, too.\n\nThe last bit of data (I’m assuming you can figure out “Color” and “B&W Color” entries) is the bytes that show which room is up, left, down or right. This is used by the game engine so it knows which room to display when the player moves off the current screen.\n\nI’ll discuss that in a future installment. It’s not as straightforward as it seems. Here’s a quick teaser:\n\nThe “LeftOfName” room (solid walls with an opening at the bottom) is defined as:\n\nLFE36: .byte <LeftOfName,>LeftOfName,$E8,$0A,$61,$06,$01,$86,$02\n\nThe room exists are defined as up ($06), left ($01), down ($86) and right ($02). But there are only 30 rooms ($00 to $1e) so there can be no room $86 (134). Maybe it actually means $06 with the high bit set (100000110). But room $06 is commented as “Bottom of Blue Maze” and looks like this:\n\nBlueMazeBottom: XXXXXXXX XX XX RR RR RRRRRRRR XX XX XX RR RR RR XXXX XXXXXXXXXX RRRRRRRRRR RRRR XXXX RRRR XXXXXXXX RRRRRRRR XX RR XXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRR\n\n…and that most definitely isn’t the room below the “Left of Name” room.\n\nAnd, this room is different between game 1 (“Small Kingdom”) and games 2 and 3. In game 1, it’s a room with an opening at the top, and in games 2 and 3 it is part of an invisible maze.\n\nThis will have to be figured out.\n\nUntil then…\n\nSee also: part 1, part 2, part 3, part 4 … and more to come…\n\nI have been on an Atari Adventure kick lately, which started after I played the game on a friend’s ATGames Legends Ultimate Arcade awhile back. Ignoring the weirdness of playing an Atari VCS game on something that resembles a 1980s arcade machine, it was like stepping back in time to when I lived in Mesquite, Texas (around 1980) and got to play it on a friend’s Atari.\n\nSide note 1: I’ll be sharing the tale of growing up during the video game revolution of the 70s and 80s in a upcoming lengthy article series.\n\nSide note 2: I also have an upcoming series about trying to code the Adventure game logic in Color BASIC on the CoCo.\n\nSince that first exposure to Adventure on an actual Atari, I’d seen the game a few other times.\n\nIndenture for the PC\n\nThere was the Indenture clone for PCs in the early 1990s. You can play it in a browser here:\n\nhttps://archive.org/details/IndentureV1.71996CraigPellAdventure\n\nIt was a nice flashback after not seeing the game in over a decade. The author, Craig Pell, even added new levels with many more rooms. The original had 29 screens (well, 30 counting a hidden one) but Indenture has a level with 300.\n\nSince it was a recreation, it does not accurately recreate the gameplay of the original. But, it’s still great fun.\n\nStella Atari emulator\n\nNext was an encounter with an early DOS version of the Atari emulator Stella. This allowed a modern computer to play the game pretty much exactly as it was on an original Atari. (Though, without using an Atari joystick, it never felt quite real.)\n\nhttps://stella-emu.github.io/\n\nAtari Flashback 2\n\nWhen I learned about the Atari Flashback 2 machine coming out, I was intrigued enough with this mini recreation of the Atari to actually buy one. Unlike the original Flashback unit, which was a Nintendo NES chipset with reprogrammed Atari games, the Flashback 2 was an actual re-engineered Atari machine. It could even be hacked to add a cartridge connector and play real Atari cartridges! And, it game with Adventure. Though I really only powered it on a handful of times before donating it to the Glenside Color Computer Club to be auctioned off at a CoCoFEST!\n\nAtari’s Greatest Hits\n\nIn the years that followed, various software packages were released containing officially licensed Atari games running in some form of emulator. Atari’s Greatest Hits was sold for many consoles and computers. I had the edition that came out for iPhone and iPads:\n\nIt was great fun to play Adventure again, but a pain to do so using virtual touch controls on a tablet screen. Fortunately, the iOS version supported the iCade controllers and I even hacked up an interface to use a “real” Atari joystick on it (the joystick from my Atari Flashback 2). Here is is on my original first generation iPad:\n\nThat, and the Flashback 2, were the closest I’ve come to the real Adventure experience, due to accurate emulation and a real (replica) controller.\n\nWarren Robinett speaks\n\nMy recent re-interest in Adventure was enhanced after watching this 2015 presentation by the game’s original author, Warren Robinett. He details the history of how the game was designed, and some insights in to how the code worked:\n\nIt was this video that got me interested in howthe game worked, rather than just how to play it.\n\nAdventure Revisited port\n\nI was unable to find any dedicated “Everything You Want To Know About How Atari Adventure Worked” website, but I did find a 2006 version (winventure.zip) by Peter Hirschberg. In contained a disassembly of the original Atari Adventure assembly code. He also translated that assembly into C++ and wrote new code to emulate machine-specific things like collision detection and the display. I don’t know where I found the original zip file, but here is the current version:\n\nhttps://sourceforge.net/projects/adventurerevisited/\n\nBecause this version was based on the actual ROM assembly code, it should play much more accurately than the Indenture rewrite from 1991. I haven’t tested this myself since I’ve been busy playing it in an Atari emulator.\n\nSide note: I just realized this is the guy who did the Adventure game for the iPhone back in 2008!\n\nDissecting Adventure\n\nThanks to the disassembly of the original source, and the rewritten version in C++, I was able to start looking at how the game worked. The first thing I did was look at how all the game levels we represented. Each screen was represented by 21 bytes of ROM code!\n\n;Castle Definition CastleDef: .byte $F0,$FE,$15 ;XXXXXXXXXXX X X X R R R RRRRRRRRRRR .byte $30,$03,$1F ;XX XXXXXXX RRRRRRR RR .byte $30,$03,$FF ;XX XXXXXXXXXXRRRRRRRRRR RR .byte $30,$00,$FF ;XX XXXXXXXXRRRRRRRR RR .byte $30,$00,$3F ;XX XXXXXX RRRRRR RR .byte $30,$00,$00 ;XX RR .byte $F0,$FF,$0F ;XXXXXXXXXXXXXX RRRRRRRRRRRRRR\n\nAbove is the data that is used to draw the castles in the game (yellow, white and black). There was another table that defined which set of graphics data to use, as well as what attributes such as “how” to draw it (more on that in a moment), what color to draw it, and what screens were connected to it on each side (up, right, down and left).\n\nThe screen was represented by 20 bits stored as three 8-bit bytes with four unused bits. Those bits represent the left side of the screen, then they are either reversed to create the other half of a symmetrical screen, or they are mirrored (draw the left side on the right) which was used in some of the mazes). It is amazing that the entire screen was defined by only 21 bytes! (And, since there were four unused bits for each three bytes, it could have been compressed further down to 17 bytes, though the extra code needed to handle this might not have fit in to the 2K of ROM space the game used.)\n\nDecoding the data in C\n\nFor fun, I thought I’d try to convert those data bytes in to a C program and see if I could decode and display them. Here is the castle:\n\nMy first attempt at the decoder wasn’t perfect (note that it’s missing the floor of the castle room), but it showed I was on the right track.\n\nDecoding the data in Color BASIC\n\nI next converted the bytes into Color BASIC DATA statements, then wrote a similar program to decode them:\n\nThe CoCo 1’s 32-column screen isn’t wide enough to display 40 ASCII characters, so I was only drawing half the image as a proof-of-concept.\n\nI next converted the PRINT text to SET(x,y,c) plotting commands. This would let me draw on the low-resolution 64×32 8-color screen.\n\nI made a simple program that let me enter a room number and then it would plot the data on the screen. Above is a screen shot from an Atari emulator on the left, and the CoCo screen on the right. Though the aspect ration doesn’t match, at least it shows the graphics are accurate.\n\nThis 64×32 “graphics” mode is actually made up of special text characters that represent a 2×2 graphics block. Those blocks can contain one color plus a black background. Because of this limitation, a screen block can either be the green/orange background color with or without a text character on it, or a black block with 1-4 of it’s 2×2 pixels set to a single color. Because of this limitation, graphics need to be specifically designed.\n\nSince each Adventure screen used only one color for the graphics, I thought this might work out well. But, if I wanted to change the background color, that might present a problem since unless the graphics took up a full character block, they would always have the unused pixels set to black. I did a quick test and it looked like this:\n\nAbove you can see that certain blocks of the castle do not use up a full 2×2 block, so the unused pixels are set to black. I think this gives it a rather interesting 3-D effect, though that was not the intent. Here’s one of the mazes:\n\nI think it looks pretty cool, though not accurate to the original.\n\nThe ROM code also contains the data that makes up the objects in the game, such as the dragons. Here’s a dragon with its mouth open:\n\n;Object 6 : State FF : Graphic GfxDrag1: .byte $80 ;X .byte $40 ; X .byte $26 ; X XX .byte $1F ; XXXXX .byte $0B ; X XX .byte $0E ; XXX .byte $1E ; XXXX .byte $24 ; X X .byte $44 ; X X .byte $8E ;X XXX .byte $1E ; XXXX .byte $3F ; XXXXXX .byte $7F ; XXXXXXX .byte $7F ; XXXXXXX .byte $7F ; XXXXXXX .byte $7F ; XXXXXXX .byte $3E ; XXXXX .byte $1C ; XXX .byte $08 ; X .byte $F8 ;XXXXX .byte $80 ;X .byte $E0 ;XXX .byte $00\n\nWhen I get some time, my next goal is to render all of those game characters, similarly to how I displayed my old VIC-20 game’s customer character set.\n\nTo be continued…"
    }
}