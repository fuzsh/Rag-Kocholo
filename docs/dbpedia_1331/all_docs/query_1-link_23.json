{
    "id": "dbpedia_1331_1",
    "rank": 23,
    "data": {
        "url": "https://stackoverflow.com/questions/13731049/how-to-mock-static-member-variables",
        "read_more_link": "",
        "language": "en",
        "title": "How to mock static member variables",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://i.sstatic.net/Epc6c.png?s=64",
            "https://www.gravatar.com/avatar/58f24547ef7236abc8bf5b5b1329aa76?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/Epc6c.png?s=64",
            "https://www.gravatar.com/avatar/1eb91391d341dfa930ff2e2a59025ce6?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/Epc6c.png?s=64",
            "https://www.gravatar.com/avatar/1eb91391d341dfa930ff2e2a59025ce6?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/WR7iJ.jpg?s=64",
            "https://stackoverflow.com/posts/13731049/ivc/f14b?prg=adf44208-afc0-4961-b421-ce5c2a9263b9"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2012-12-05T19:36:23",
        "summary": "",
        "meta_description": "I have a class ClassToTest which has a dependency on ClassToMock. \r\npublic class ClassToMock {\n\n  private static final String MEMBER_1 = FileReader.readMemeber1();\n\n  protected void someMethod() {\n...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/13731049/how-to-mock-static-member-variables",
        "text": "Your ClassToMock tightly coupled with FileReader, that's why you are not able to test/mock it. Instead of using tool to hack the byte code so you can mock it. I would suggest you do some simple refactorings to break the dependency.\n\nStep 1. Encapsulate Global References\n\nThis technique is also introduced in Michael Feathers's wonderful book : Working Effectively with Legacy Code.\n\nThe title pretty much self explained. Instead of directly reference a global variable, you encapsulate it inside a method.\n\nIn your case, ClassToMock can be refactored into this :\n\npublic class ClassToMock { private static final String MEMBER_1 = FileReader.readMemeber1(); public String getMemberOne() { return MEMBER_1; } }\n\nthen you can easily using Mockito to mock getMemberOne().\n\nUPDATED Old Step 1 cannot guarantee Mockito mock safely, if FileReader.readMemeber1() throw exception, then the test will failled miserably. So I suggest add another step to work around it.\n\nStep 1.5. add Setter and Lazy Getter\n\nSince the problem is FileReader.readMember1() will be invoked as soon as ClassToMock is loaded. We have to delay it. So we make the getter call FileReader.readMember1() lazily, and open a setter.\n\npublic class ClassToMock { private static String MEMBER_1 = null; protected String getMemberOne() { if (MEMBER_1 == null) { MEMBER_1 = FileReader.readMemeber1(); } return MEMBER_1; } public void setMemberOne(String memberOne) { MEMBER_1 = memberOne; } }\n\nNow, you should able to make a fake ClassToMock even without Mockito. However, this should not be the final state of your code, once you have your test ready, you should continue to Step 2.\n\nStep 2. Dependence Injection\n\nOnce you have your test ready, you should refactor it further more. Now Instead of reading the MEMBER_1 by itself. This class should receive the MEMBER_1 from outside world instead. You can either use a setter or constructor to receive it. Below is the code that use setter.\n\npublic class ClassToMock { private String memberOne; public void setMemberOne(String memberOne) { this.memberOne = memberOne; } public String getMemberOne() { return memberOne; } }\n\nThese two step refactorings are really easy to do, and you can do it even without test at hand. If the code is not that complex, you can just do step 2. Then you can easily test ClassToTest\n\nUPDATE 12/8 : answer the comment\n\nSee my another answer in this questions.\n\nUPDATE 12/8 : answer the comment\n\nQuestion : What if FileReader is something very basic like Logging that needs to be there in every class. Would you suggest I follow the same approach there?\n\nIt depends.\n\nThere are something you might want to think about before you do a massive refactor like that.\n\nIf I move FileReader outside, do I have a suitable class which can read from file and provide the result to every single class that needs them ?\n\nBeside making classes easier to test, do I gain any other benefit ?\n\nDo I have time ?\n\nIf any of the answers is \"NO\", then you should better not to.\n\nHowever, we can still break the dependency between all the classes and FileReader with minimal changes.\n\nFrom your question and comment, I assume your system using FileReader as a global reference for reading stuff from a properties file, then provide it to rest of the system.\n\nThis technique is also introduced in Michael Feathers's wonderful book : Working Effectively with Legacy Code, again.\n\nStep 1. Delegate FileReader static methods to instance.\n\nChange\n\npublic class FileReader { public static FileReader getMemberOne() { // codes that read file. } }\n\nTo\n\npublic class FileReader { private static FileReader singleton = new FileReader(); public static String getMemberOne() { return singleton.getMemberOne(); } public String getMemberOne() { // codes that read file. } }\n\nBy doing this, static methods in FileReader now have no knowledge about how to getMemberOne()\n\nStep 2. Extract Interface from FileReader\n\npublic interface AppProperties { String getMemberOne(); } public class FileReader implements AppProperties { private static AppProperties singleton = new FileReader(); public static String getMemberOne() { return singleton.getMemberOne(); } @Override public String getMemberOne() { // codes that read file. } }\n\nWe extract all the method to AppProperties, and static instance in FileReader now using AppProperties.\n\nStep 3. Static setter\n\npublic class FileReader implements AppProperties { private static AppProperties singleton = new FileReader(); public static void setAppProperties(AppProperties prop) { singleton = prop; } ... ... }\n\nWe opened a seam in FileReader. By doing this, we can set change underlying instance in FileReader and it would never notice.\n\nStep 4. Clean up\n\nNow FileReader have two responsibilities. One is read files and provide result, another one is provide a global reference for system.\n\nWe can separate them and give them a good naming. Here is the result :\n\n// This is the original FileReader, // now is a AppProperties subclass which read properties from file. public FileAppProperties implements AppProperties { // implementation. } // This is the class that provide static methods. public class GlobalAppProperties { private static AppProperties singleton = new FileAppProperties(); public static void setAppProperties(AppProperties prop) { singleton = prop; } public static String getMemberOne() { return singleton.getMemberOne(); } ... ... }\n\nEND.\n\nAfter this refactoring, whenever you want to test. You can set a mock AppProperties to GlobalAppProperties\n\nI think this refactoring would be better if all you want to do is break the same global dependency in many classes."
    }
}