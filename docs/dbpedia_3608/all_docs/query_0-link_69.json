{
    "id": "dbpedia_3608_0",
    "rank": 69,
    "data": {
        "url": "https://bazel.build/reference/be/common-definitions",
        "read_more_link": "",
        "language": "en",
        "title": "Common definitions",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.gstatic.com/devrel-devsite/prod/vd185cef2092d5507cf5d5de6d49d6afd8eb38fe69b728d88979eb4a70550ff03/bazel/images/lockup.svg",
            "https://www.gstatic.com/devrel-devsite/prod/vd185cef2092d5507cf5d5de6d49d6afd8eb38fe69b728d88979eb4a70550ff03/bazel/images/lockup.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://www.gstatic.com/devrel-devsite/prod/vd185cef2092d5507cf5d5de6d49d6afd8eb38fe69b728d88979eb4a70550ff03/bazel/images/favicon-prod.png",
        "meta_site_name": "Bazel",
        "canonical_link": "https://bazel.build/reference/be/common-definitions",
        "text": "Report an issueopen_in_new View sourceopen_in_new Nightly · 7.2 · 7.1 · 7.0 · 6.5 · 6.4\n\nThis section defines various terms and concepts that are common to many functions or build rules.\n\nContents\n\nBourne shell tokenization\n\nLabel Expansion\n\nTypical attributes defined by most build rules\n\nAttributes common to all build rules\n\nAttributes common to all test rules (*_test)\n\nAttributes common to all binary rules (*_binary)\n\nConfigurable attributes\n\nImplicit output targets\n\nBourne shell tokenization\n\nCertain string attributes of some rules are split into multiple words according to the tokenization rules of the Bourne shell: unquoted spaces delimit separate words, and single- and double-quotes characters and backslashes are used to prevent tokenization.\n\nThose attributes that are subject to this tokenization are explicitly indicated as such in their definitions in this document.\n\nAttributes subject to \"Make\" variable expansion and Bourne shell tokenization are typically used for passing arbitrary options to compilers and other tools. Examples of such attributes are cc_library.copts and java_library.javacopts. Together these substitutions allow a single string variable to expand into a configuration-specific list of option words.\n\nLabel expansion\n\nSome string attributes of a very few rules are subject to label expansion: if those strings contain a valid label as a substring, such as //mypkg:target, and that label is a declared prerequisite of the current rule, it is expanded into the pathname of the file represented by the target //mypkg:target.\n\nExample attributes include genrule.cmd and cc_binary.linkopts. The details may vary significantly in each case, over such issues as: whether relative labels are expanded; how labels that expand to multiple files are treated, etc. Consult the rule attribute documentation for specifics.\n\nTypical attributes defined by most build rules\n\nThis section describes attributes that are defined by many build rules, but not all.\n\nAttribute Description\n\nAttributes common to all build rules\n\nThis section describes attributes that are implicitly added to all build rules.\n\nAttribute Description compatible_with\n\nList of labels; nonconfigurable; default is []\n\nThe list of environments this target can be built for, in addition to default-supported environments.\n\nThis is part of Bazel's constraint system, which lets users declare which targets can and cannot depend on each other. For example, externally deployable binaries shouldn't depend on libraries with company-secret code. See ConstraintSemantics for details.\n\ndeprecation\n\nString; nonconfigurable; default is None\n\nAn explanatory warning message associated with this target. Typically this is used to notify users that a target has become obsolete, or has become superseded by another rule, is private to a package, or is perhaps considered harmful for some reason. It is a good idea to include some reference (like a webpage, a bug number or example migration CLs) so that one can easily find out what changes are required to avoid the message. If there is a new target that can be used as a drop in replacement, it is a good idea to just migrate all users of the old target.\n\nThis attribute has no effect on the way things are built, but it may affect a build tool's diagnostic output. The build tool issues a warning when a rule with a deprecation attribute is depended upon by a target in another package.\n\nIntra-package dependencies are exempt from this warning, so that, for example, building the tests of a deprecated rule does not encounter a warning.\n\nIf a deprecated target depends on another deprecated target, no warning message is issued.\n\nOnce people have stopped using it, the target can be removed.\n\ndistribs\n\nList of strings; nonconfigurable; default is []\n\nA list of distribution-method strings to be used for this particular target. This is part of a deprecated licensing API that Bazel no longer uses. Don't use this.\n\nexec_compatible_with\n\nList of labels; nonconfigurable; default is []\n\nA list of constraint_values that must be present in the execution platform for this target. This is in addition to any constraints already set by the rule type. Constraints are used to restrict the list of available execution platforms. For more details, see the description of toolchain resolution.\n\nexec_properties\n\nDictionary of strings; default is {}\n\nA dictionary of strings that will be added to the exec_properties of a platform selected for this target. See exec_properties of the platform rule.\n\nIf a key is present in both the platform and target-level properties, the value will be taken from the target.\n\nfeatures\n\nList of feature strings; default is []\n\nA feature is string tag that can be enabled or disabled on a target. The meaning of a feature depends on the rule itself.\n\nThis features attribute is combined with the package level features attribute. For example, if the features [\"a\", \"b\"] are enabled on the package level, and a target's features attribute contains [\"-a\", \"c\"], the features enabled for the rule will be \"b\" and \"c\". See example.\n\nrestricted_to\n\nList of labels; nonconfigurable; default is []\n\nThe list of environments this target can be built for, instead of default-supported environments.\n\nThis is part of Bazel's constraint system. See compatible_with for details.\n\nList of strings; nonconfigurable; default is []\n\nTags can be used on any rule. Tags on test and test_suite rules are useful for categorizing the tests. Tags on non-test targets are used to control sandboxed execution of genrules and Starlark actions, and for parsing by humans and/or external tools.\n\nBazel modifies the behavior of its sandboxing code if it finds the following keywords in the tags attribute of any test or genrule target, or the keys of execution_requirements for any Starlark action.\n\nno-sandbox keyword results in the action or test never being sandboxed; it can still be cached or run remotely - use no-cache or no-remote to prevent either or both of those.\n\nno-cache keyword results in the action or test never being cached (locally or remotely). Note: for the purposes of this tag, the disk cache is considered a local cache, whereas the HTTP and gRPC caches are considered remote. Other caches, such as Skyframe or the persistent action cache, are not affected.\n\nno-remote-cache keyword results in the action or test never being cached remotely (but it may be cached locally; it may also be executed remotely). Note: for the purposes of this tag, the disk cache is considered a local cache, whereas the HTTP and gRPC caches are considered remote. Other caches, such as Skyframe or the persistent action cache, are not affected. If a combination of local disk cache and remote cache are used (combined cache), it's treated as a remote cache and disabled entirely unless --incompatible_remote_results_ignore_disk is set in which case the local components will be used.\n\nno-remote-exec keyword results in the action or test never being executed remotely (but it may be cached remotely).\n\nno-remote keyword prevents the action or test from being executed remotely or cached remotely. This is equivalent to using both no-remote-cache and no-remote-exec.\n\nno-remote-cache-upload keyword disables upload part of remote caching of a spawn. it does not disable remote execution.\n\nlocal keyword precludes the action or test from being remotely cached, remotely executed, or run inside the sandbox. For genrules and tests, marking the rule with the local = True attribute has the same effect.\n\nrequires-network keyword allows access to the external network from inside the sandbox. This tag only has an effect if sandboxing is enabled.\n\nblock-network keyword blocks access to the external network from inside the sandbox. In this case, only communication with localhost is allowed. This tag only has an effect if sandboxing is enabled.\n\nrequires-fakeroot runs the test or action as uid and gid 0 (i.e., the root user). This is only supported on Linux. This tag takes precedence over the --sandbox_fake_username command-line option.\n\nTags on tests are generally used to annotate a test's role in your debug and release process. Typically, tags are most useful for C++ and Python tests, which lack any runtime annotation ability. The use of tags and size elements gives flexibility in assembling suites of tests based around codebase check-in policy.\n\nBazel modifies test running behavior if it finds the following keywords in the tags attribute of the test rule:\n\nexclusive will force the test to be run in the \"exclusive\" mode, ensuring that no other tests are running at the same time. Such tests will be executed in serial fashion after all build activity and non-exclusive tests have been completed. Remote execution is disabled for such tests because Bazel doesn't have control over what's running on a remote machine.\n\nexclusive-if-local will force the test to be run in the \"exclusive\" mode if it is executed locally, but will run the test in parallel if it's executed remotely.\n\nmanual keyword will exclude the target from expansion of target pattern wildcards (..., :*, :all, etc.) and test_suite rules which do not list the test explicitly when computing the set of top-level targets to build/run for the build, test, and coverage commands. It does not affect target wildcard or test suite expansion in other contexts, including the query command. Note that manual does not imply that a target should not be built/run automatically by continuous build/test systems. For example, it may be desirable to exclude a target from bazel test ... because it requires specific Bazel flags, but still have it included in properly-configured presubmit or continuous test runs.\n\nexternal keyword will force test to be unconditionally executed (regardless of --cache_test_results value).\n\nSee Tag Conventions in the Test Encyclopedia for more conventions on tags attached to test targets. target_compatible_with\n\nList of labels; default is []\n\nA list of constraint_values that must be present in the target platform for this target to be considered compatible. This is in addition to any constraints already set by the rule type. If the target platform does not satisfy all listed constraints then the target is considered incompatible. Incompatible targets are skipped for building and testing when the target pattern is expanded (e.g. //..., :all). When explicitly specified on the command line, incompatible targets cause Bazel to print an error and cause a build or test failure.\n\nTargets that transitively depend on incompatible targets are themselves considered incompatible. They are also skipped for building and testing.\n\nAn empty list (which is the default) signifies that the target is compatible with all platforms.\n\nAll rules other than Workspace Rules support this attribute. For some rules this attribute has no effect. For example, specifying target_compatible_with for a cc_toolchain is not useful.\n\nSee the Platforms page for more information about incompatible target skipping.\n\ntestonly\n\nBoolean; nonconfigurable; default is False except for test and test suite targets\n\nIf True, only testonly targets (such as tests) can depend on this target.\n\nEquivalently, a rule that is not testonly is not allowed to depend on any rule that is testonly.\n\nTests (*_test rules) and test suites (test_suite rules) are testonly by default.\n\nThis attribute is intended to mean that the target should not be contained in binaries that are released to production.\n\nBecause testonly is enforced at build time, not run time, and propagates virally through the dependency tree, it should be applied judiciously. For example, stubs and fakes that are useful for unit tests may also be useful for integration tests involving the same binaries that will be released to production, and therefore should probably not be marked testonly. Conversely, rules that are dangerous to even link in, perhaps because they unconditionally override normal behavior, should definitely be marked testonly.\n\ntoolchains\n\nList of labels; nonconfigurable; default is []\n\nThe set of targets whose Make variables this target is allowed to access. These targets are either instances of rules that provide TemplateVariableInfo or special targets for toolchain types built into Bazel. These include:\n\n@bazel_tools//tools/cpp:current_cc_toolchain\n\n@bazel_tools//tools/jdk:current_java_runtime\n\nNote that this is distinct from the concept of toolchain resolution that is used by rule implementations for platform-dependent configuration. You cannot use this attribute to determine which specific cc_toolchain or java_toolchain a target will use.\n\nvisibility\n\nList of labels; nonconfigurable; default is default_visibility from package if specified, or \"//visibility:private\" otherwise\n\nThe visibility attribute on a target controls whether the target can be used in other packages. See the documentation for visibility.\n\nAttributes common to all test rules (*_test)\n\nThis section describes attributes that are common to all test rules.\n\nAttribute Description\n\nAttributes common to all binary rules (*_binary)\n\nThis section describes attributes that are common to all binary rules.\n\nAttribute Description\n\nConfigurable attributes\n\nMost attributes are \"configurable\", meaning that their values may change when the target is built in different ways. Specifically, configurable attributes may vary based on the flags passed to the Bazel command line, or what downstream dependency is requesting the target. This can be used, for instance, to customize the target for multiple platforms or compilation modes.\n\nThe following example declares different sources for different target architectures. Running bazel build :multiplatform_lib --cpu x86 will build the target using x86_impl.cc, while substituting --cpu arm will instead cause it to use arm_impl.cc.\n\ncc_library( name = \"multiplatform_lib\", srcs = select({ \":x86_mode\": [\"x86_impl.cc\"], \":arm_mode\": [\"arm_impl.cc\"] }) ) config_setting( name = \"x86_mode\", values = { \"cpu\": \"x86\" } ) config_setting( name = \"arm_mode\", values = { \"cpu\": \"arm\" } )\n\nThe select() function chooses among different alternative values for a configurable attribute based on which config_setting or constraint_value criteria the target's configuration satisfies.\n\nBazel evaluates configurable attributes after processing macros and before processing rules (technically, between the loading and analysis phases). Any processing before select() evaluation doesn't know which branch the select() chooses. Macros, for example, can't change their behavior based on the chosen branch, and bazel query can only make conservative guesses about a target's configurable dependencies. See this FAQ for more on using select() with rules and macros.\n\nAttributes marked nonconfigurable in their documentation cannot use this feature. Usually an attribute is nonconfigurable because Bazel internally needs to know its value before it can determine how to resolve a select().\n\nSee Configurable Build Attributes for a detailed overview.\n\nImplicit output targets\n\nImplicit outputs in C++ are deprecated. Please refrain from using it in other languages where possible. We don't have a deprecation path yet but they will eventually be deprecated too.\n\nWhen you define a build rule in a BUILD file, you are explicitly declaring a new, named rule target in a package. Many build rule functions also implicitly entail one or more output file targets, whose contents and meaning are rule-specific. For example, when you explicitly declare a java_binary(name='foo', ...) rule, you are also implicitly declaring an output file target foo_deploy.jar as a member of the same package. (This particular target is a self-contained Java archive suitable for deployment.)\n\nImplicit output targets are first-class members of the global target graph. Just like other targets, they are built on demand, either when specified in the top-level built command, or when they are necessary prerequisites for other build targets. They can be referenced as dependencies in BUILD files, and can be observed in the output of analysis tools such as bazel query.\n\nFor each kind of build rule, the rule's documentation contains a special section detailing the names and contents of any implicit outputs entailed by a declaration of that kind of rule."
    }
}