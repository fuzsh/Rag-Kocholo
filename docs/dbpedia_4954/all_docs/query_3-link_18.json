{
    "id": "dbpedia_4954_3",
    "rank": 18,
    "data": {
        "url": "https://www.w3.org/TR/did-core/",
        "read_more_link": "",
        "language": "en",
        "title": "Decentralized Identifiers (DIDs) v1.0",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.w3.org/StyleSheets/TR/2021/logos/W3C",
            "https://www.w3.org/TR/did-core/diagrams/parts-of-a-did.svg",
            "https://www.w3.org/TR/did-core/diagrams/did_brief_architecture_overview.svg",
            "https://www.w3.org/TR/did-core/diagrams/diagram-did-document-entries.svg",
            "https://www.w3.org/TR/did-core/diagrams/diagram-production-consumption.svg",
            "https://www.w3.org/TR/did-core/diagrams/diagram-resolve-resolverepresentation.svg",
            "https://www.w3.org/TR/did-core/diagrams/did_url_dereference_overview.svg",
            "https://www.w3.org/TR/did-core/diagrams/did_detailed_architecture_overview.svg",
            "https://www.w3.org/TR/did-core/diagrams/figure-a.1-did-and-did-document-graph.svg",
            "https://www.w3.org/TR/did-core/diagrams/figure-a.2-also-known-as-graph.svg",
            "https://www.w3.org/TR/did-core/diagrams/figure-b.1-controller-and-subject-equivalence.svg",
            "https://www.w3.org/TR/did-core/diagrams/figure-c.1-independent-did-controllers.svg",
            "https://www.w3.org/TR/did-core/diagrams/figure-c.2-group-did-controllers.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-07-19T00:00:00",
        "summary": "",
        "meta_description": "Decentralized identifiers (DIDs) are a new type of identifier that\nenables verifiable, decentralized digital identity. A DID refers to any\nsubject (e.g., a person, organization, thing, data model, abstract entity, etc.)\nas determined by the controller of the DID. In contrast to\ntypical, federated identifiers, DIDs have been designed so that they may\nbe decoupled from centralized registries, identity providers, and certificate\nauthorities. Specifically, while other parties might be used to help enable the\ndiscovery of information related to a DID, the design enables the\ncontroller of a DID to prove control over it without requiring permission\nfrom any other party. DIDs are URIs that associate a DID\nsubject with a DID document allowing trustable interactions\nassociated with that subject.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://www.w3.org/TR/did-core/",
        "text": "1. Introduction\n\nThis section is non-normative.\n\nAs individuals and organizations, many of us use globally unique identifiers in a wide variety of contexts. They serve as communications addresses (telephone numbers, email addresses, usernames on social media), ID numbers (for passports, drivers licenses, tax IDs, health insurance), and product identifiers (serial numbers, barcodes, RFIDs). URIs (Uniform Resource Identifiers) are used for resources on the Web and each web page you view in a browser has a globally unique URL (Uniform Resource Locator).\n\nThe vast majority of these globally unique identifiers are not under our control. They are issued by external authorities that decide who or what they refer to and when they can be revoked. They are useful only in certain contexts and recognized only by certain bodies not of our choosing. They might disappear or cease to be valid with the failure of an organization. They might unnecessarily reveal personal information. In many cases, they can be fraudulently replicated and asserted by a malicious third-party, which is more commonly known as \"identity theft\".\n\nThe Decentralized Identifiers (DIDs) defined in this specification are a new type of globally unique identifier. They are designed to enable individuals and organizations to generate their own identifiers using systems they trust. These new identifiers enable entities to prove control over them by authenticating using cryptographic proofs such as digital signatures.\n\nSince the generation and assertion of Decentralized Identifiers is entity-controlled, each entity can have as many DIDs as necessary to maintain their desired separation of identities, personas, and interactions. The use of these identifiers can be scoped appropriately to different contexts. They support interactions with other people, institutions, or systems that require entities to identify themselves, or things they control, while providing control over how much personal or private data should be revealed, all without depending on a central authority to guarantee the continued existence of the identifier. These ideas are explored in the DID Use Cases document [DID-USE-CASES].\n\nThis specification does not presuppose any particular technology or cryptography to underpin the generation, persistence, resolution, or interpretation of DIDs. For example, implementers can create Decentralized Identifiers based on identifiers registered in federated or centralized identity management systems. Indeed, almost all types of identifier systems can add support for DIDs. This creates an interoperability bridge between the worlds of centralized, federated, and decentralized identifiers. This also enables implementers to design specific types of DIDs to work with the computing infrastructure they trust, such as distributed ledgers, decentralized file systems, distributed databases, and peer-to-peer networks.\n\nThis specification is for:\n\nAnyone that wants to understand the core architectural principles that are the foundation for Decentralized Identifiers;\n\nSoftware developers that want to produce and consume Decentralized Identifiers and their associated data formats;\n\nSystems integrators that want to understand how to use Decentralized Identifiers in their software and hardware systems;\n\nSpecification authors that want to create new DID infrastructures, known as DID methods, that conform to the ecosystem described by this document.\n\nIn addition to this specification, readers might find the Use Cases and Requirements for Decentralized Identifiers [DID-USE-CASES] document useful.\n\n1.1 A Simple Example\n\nThis section is non-normative.\n\nA DID is a simple text string consisting of three parts: 1) the did URI scheme identifier, 2) the identifier for the DID method, and 3) the DID method-specific identifier.\n\nThe example DID above resolves to a DID document. A DID document contains information associated with the DID, such as ways to cryptographically authenticate a DID controller.\n\nExample 1: A simple DID document\n\n{ \"@context\": [ \"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/suites/ed25519-2020/v1\" ] \"id\": \"did:example:123456789abcdefghi\", \"authentication\": [{ \"id\": \"did:example:123456789abcdefghi#keys-1\", \"type\": \"Ed25519VerificationKey2020\", \"controller\": \"did:example:123456789abcdefghi\", \"publicKeyMultibase\": \"zH3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV\" }] }\n\n1.2 Design Goals\n\nThis section is non-normative.\n\nDecentralized Identifiers are a component of larger systems, such as the Verifiable Credentials ecosystem [VC-DATA-MODEL], which influenced the design goals for this specification. The design goals for Decentralized Identifiers are summarized here.\n\nGoal Description Decentralization Eliminate the requirement for centralized authorities or single point failure in identifier management, including the registration of globally unique identifiers, public verification keys, services, and other information. Control Give entities, both human and non-human, the power to directly control their digital identifiers without the need to rely on external authorities. Privacy Enable entities to control the privacy of their information, including minimal, selective, and progressive disclosure of attributes or other data. Security Enable sufficient security for requesting parties to depend on DID documents for their required level of assurance. Proof-based Enable DID controllers to provide cryptographic proof when interacting with other entities. Discoverability Make it possible for entities to discover DIDs for other entities, to learn more about or interact with those entities. Interoperability Use interoperable standards so DID infrastructure can make use of existing tools and software libraries designed for interoperability. Portability Be system- and network-independent and enable entities to use their digital identifiers with any system that supports DIDs and DID methods. Simplicity Favor a reduced set of simple features to make the technology easier to understand, implement, and deploy. Extensibility Where possible, enable extensibility provided it does not greatly hinder interoperability, portability, or simplicity.\n\n1.3 Architecture Overview\n\nThis section is non-normative.\n\nThis section provides a basic overview of the major components of Decentralized Identifier architecture.\n\nSix internally-labeled shapes appear in the diagram, with labeled arrows between them, as follows. In the center of the diagram is a rectangle labeled DID URL, containing small typewritten text \"did:example:123/path/to/rsrc\". At the center top of the diagram is a rectangle labeled, \"DID\", containing small typewritten text \"did:example:123\". At the top left of the diagram is an oval, labeled \"DID Subject\". At the bottom center of the diagram is a rectangle labeled, \"DID document\". At the bottom left is an oval, labeled, \"DID Controller\". On the center right of the diagram is a two-dimensional rendering of a cylinder, labeled, \"Verifiable Data Registry\".\n\nFrom the top of the \"DID URL\" rectangle, an arrow, labeled \"contains\", extends upwards, pointing to the \"DID\" rectangle. From the bottom of the \"DID URL\" rectangle, an arrow, labeled \"refers, and dereferences, to\", extends downward, pointing to the \"DID document\" rectangle. An arrow from the \"DID\" rectangle, labeled \"resolves to\", points down to the \"DID document\" rectangle. An arrow from the \"DID\" rectangle, labeled \"refers to\", points left to the \"DID subject\" oval. An arrow from the \"DID controller\" oval, labeled \"controls\", points right to the \"DID document\" rectangle. An arrow from the \"DID\" rectangle, labeled \"recorded on\", points downards to the right, to the \"Verifiable Data Registry\" cylinder. An arrow from the \"DID document\" rectangle, labeled \"recorded on\", points upwards to the right to the \"Verifiable Data Registry\" cylinder.\n\nDIDs and DID URLs\n\nA Decentralized Identifier, or DID, is a URI composed of three parts: the scheme did:, a method identifier, and a unique, method-specific identifier specified by the DID method. DIDs are resolvable to DID documents. A DID URL extends the syntax of a basic DID to incorporate other standard URI components such as path, query, and fragment in order to locate a particular resource—for example, a cryptographic public key inside a DID document, or a resource external to the DID document. These concepts are elaborated upon in 3.1 DID Syntax and 3.2 DID URL Syntax.\n\nDID subjects\n\nThe subject of a DID is, by definition, the entity identified by the DID. The DID subject might also be the DID controller. Anything can be the subject of a DID: person, group, organization, thing, or concept. This is further defined in 5.1.1 DID Subject.\n\nDID controllers\n\nThe controller of a DID is the entity (person, organization, or autonomous software) that has the capability—as defined by a DID method—to make changes to a DID document. This capability is typically asserted by the control of a set of cryptographic keys used by software acting on behalf of the controller, though it might also be asserted via other mechanisms. Note that a DID might have more than one controller, and the DID subject can be the DID controller, or one of them. This concept is documented in 5.1.2 DID Controller.\n\nVerifiable data registries\n\nIn order to be resolvable to DID documents, DIDs are typically recorded on an underlying system or network of some kind. Regardless of the specific technology used, any such system that supports recording DIDs and returning data necessary to produce DID documents is called a verifiable data registry. Examples include distributed ledgers, decentralized file systems, databases of any kind, peer-to-peer networks, and other forms of trusted data storage. This concept is further elaborated upon in 8. Methods.\n\nDID documents\n\nDID documents contain information associated with a DID. They typically express verification methods, such as cryptographic public keys, and services relevant to interactions with the DID subject. The generic properties supported in a DID document are specified in 5. Core Properties. A DID document can be serialized to a byte stream (see 6. Representations). The properties present in a DID document can be updated according to the applicable operations outlined in 8. Methods.\n\nDID methods\n\nDID methods are the mechanism by which a particular type of DID and its associated DID document are created, resolved, updated, and deactivated. DID methods are defined using separate DID method specifications as defined in 8. Methods.\n\nDID resolvers and DID resolution\n\nA DID resolver is a system component that takes a DID as input and produces a conforming DID document as output. This process is called DID resolution. The steps for resolving a specific type of DID are defined by the relevant DID method specification. The process of DID resolution is elaborated upon in 7. Resolution.\n\nDID URL dereferencers and DID URL dereferencing\n\nA DID URL dereferencer is a system component that takes a DID URL as input and produces a resource as output. This process is called DID URL dereferencing. The process of DID URL dereferencing is elaborated upon in 7.2 DID URL Dereferencing.\n\n1.4 Conformance\n\nAs well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.\n\nThe key words MAY, MUST, MUST NOT, OPTIONAL, RECOMMENDED, REQUIRED, SHOULD, and SHOULD NOT in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.\n\nThis document contains examples that contain JSON and JSON-LD content. Some of these examples contain characters that are invalid, such as inline comments (//) and the use of ellipsis (...) to denote information that adds little value to the example. Implementers are cautioned to remove this content if they desire to use the information as valid JSON or JSON-LD.\n\nSome examples contain terms, both property names and values, that are not defined in this specification. These are indicated with a comment (// external (property name|value)). Such terms, when used in a DID document, are expected to be registered in the DID Specification Registries [DID-SPEC-REGISTRIES] with links to both a formal definition and a JSON-LD context.\n\nInteroperability of implementations for DIDs and DID documents is tested by evaluating an implementation's ability to create and parse DIDs and DID documents that conform to this specification. Interoperability for producers and consumers of DIDs and DID documents is provided by ensuring the DIDs and DID documents conform. Interoperability for DID method specifications is provided by the details in each DID method specification. It is understood that, in the same way that a web browser is not required to implement all known URI schemes, conformant software that works with DIDs is not required to implement all known DID methods. However, all implementations of a given DID method are expected to be interoperable for that method.\n\nA conforming DID is any concrete expression of the rules specified in 3. Identifier which complies with relevant normative statements in that section.\n\nA conforming DID document is any concrete expression of the data model described in this specification which complies with the relevant normative statements in 4. Data Model and 5. Core Properties. A serialization format for the conforming document is deterministic, bi-directional, and lossless, as described in 6. Representations.\n\nA conforming producer is any algorithm realized as software and/or hardware that generates conforming DIDs or conforming DID Documents and complies with the relevant normative statements in 6. Representations.\n\nA conforming consumer is any algorithm realized as software and/or hardware that consumes conforming DIDs or conforming DID documents and complies with the relevant normative statements in 6. Representations.\n\nA conforming DID resolver is any algorithm realized as software and/or hardware that complies with the relevant normative statements in 7.1 DID Resolution.\n\nA conforming DID URL dereferencer is any algorithm realized as software and/or hardware that complies with the relevant normative statements in 7.2 DID URL Dereferencing.\n\nA conforming DID method is any specification that complies with the relevant normative statements in 8. Methods.\n\n7. Resolution\n\nThis section defines the inputs and outputs of DID resolution and DID URL dereferencing. Their exact implementation is out of scope for this specification, but some considerations for implementers are discussed in [DID-RESOLUTION].\n\nAll conformant DID resolvers MUST implement the DID resolution functions for at least one DID method and MUST be able to return a DID document in at least one conformant representation.\n\n7.1 DID Resolution\n\nThe DID resolution functions resolve a DID into a DID document by using the \"Read\" operation of the applicable DID method as described in 8.2 Method Operations. The details of how this process is accomplished are outside the scope of this specification, but all conforming DID resolvers implement the functions below, which have the following abstract forms:\n\nresolve(did, resolutionOptions) → « didResolutionMetadata, didDocument, didDocumentMetadata » resolveRepresentation(did, resolutionOptions) → « didResolutionMetadata, didDocumentStream, didDocumentMetadata »\n\nThe resolve function returns the DID document in its abstract form (a map). The resolveRepresentation function returns a byte stream of the DID Document formatted in the corresponding representation.\n\nThe upper middle part of the diagram contains a rectangle with dashed grey outline, containing two blue-outlined rectangles, one above the other. The upper, larger rectangle is labeled, in blue, \"Core Properties\", and contains the following INFRA notation:\n\n«[ \"id\" → \"example:123\", \"verificationMethod\" → « «[ \"id\": \"did:example:123#keys-1\", \"controller\": \"did:example:123\", \"type\": \"Ed25519VerificationKey2018\", \"publicKeyBase58\": \"H3C2AVvLMv6gmMNam3uVA\" ]» », \"authentication\" → « \"did:example:123#keys-1\" » ]»\n\nThe lower, smaller rectangle is labeled, in blue, \"Core Representation-specific Entries (JSON-LD)\", and contains the following monospaced INFRA notation:\n\n«[ \"@context\" → \"https://www.w3.org/ns/did/v1\" ]»\n\nFrom the grey-outlined rectangle, three pairs of arrows extend to three different black-outlined rectangles, aligned in a horizontal row side-by-side, in the bottom half of the diagram. Each pair of arrows consists of one blue arrow pointing from the grey-outlined rectangle to the respective black-outlined rectangle, labeled \"produce\", and one red arrow pointing in the reverse direction, labeled \"consume\". The first black-outlined rectangle in the row is labeled \"application/did+ld+json\", and contains the following JSON-LD data:\n\n{ \"@context\": [\"https://www.w3.org/ns/did/v1\"], \"id\": \"did:example:123\", \"verificationMethod\": [{ \"id\": \"did:example:123#keys-1\", \"controller\": \"did:example:123\", \"type\": \"Ed25519VerificationKey2018\", \"publicKeyBase58\": \"H3C2AVvLMv6gmMNam3uVA\" }], \"authentication\": [ \"did:example:123#keys-1\" ] }\n\nThe second rectangle in the row is labeled \"application/did+json\" and contains the following JSON data:\n\n{ \"id\": \"did:example:123\", \"verificationMethod\": [{ \"id\": \"did:example:123#keys-1\", \"controller\": \"did:example:123\", \"type\": \"Ed25519VerificationKey2018\", \"publicKeyBase58\": \"H3C2AVvLMv6gmMNam3uVA\" }], \"authentication\": [ \"did:example:123#keys-1\" ] }\n\nThe third rectangle in the row is labeled \"application/did+cbor\", and contains hexadecimal data.\n\nIn the left part of the diagram, in the middle, there is a box, with black outline and light gray background. This box is labeled \"VERIFIABLE DATA REGISTRY\" and contains a symbol representing a graph with nodes and arcs. From this box, one arrow, labeled \"resolve()\", extends upwards and points to the top half of the diagram where the grey-outlined rectangle is located. Another arrow, labeled \"resolveRepresentation()\", extends downwards and points to the bottom half of the diagram, where the row of three black-outlined rectangles is located.\n\nThe input variables of the resolve and resolveRepresentation functions are as follows:\n\ndid\n\nThis is the DID to resolve. This input is REQUIRED and the value MUST be a conformant DID as defined in 3.1 DID Syntax.\n\nresolutionOptions\n\nA metadata structure containing properties defined in 7.1.1 DID Resolution Options. This input is REQUIRED, but the structure MAY be empty.\n\nThese functions each return multiple values, and no limitations are placed on how these values are returned together. The return values of resolve are didResolutionMetadata, didDocument, and didDocumentMetadata. The return values of resolveRepresentation are didResolutionMetadata, didDocumentStream, and didDocumentMetadata. These values are described below:\n\ndidResolutionMetadata\n\nA metadata structure consisting of values relating to the results of the DID resolution process which typically changes between invocations of the resolve and resolveRepresentation functions, as it represents data about the resolution process itself. This structure is REQUIRED, and in the case of an error in the resolution process, this MUST NOT be empty. This metadata is defined by 7.1.2 DID Resolution Metadata. If resolveRepresentation was called, this structure MUST contain a contentType property containing the Media Type of the representation found in the didDocumentStream. If the resolution is not successful, this structure MUST contain an error property describing the error.\n\ndidDocument\n\nIf the resolution is successful, and if the resolve function was called, this MUST be a DID document abstract data model (a map) as described in 4. Data Model that is capable of being transformed into a conforming DID Document (representation), using the production rules specified by the representation. The value of id in the resolved DID document MUST match the DID that was resolved. If the resolution is unsuccessful, this value MUST be empty.\n\ndidDocumentStream\n\nIf the resolution is successful, and if the resolveRepresentation function was called, this MUST be a byte stream of the resolved DID document in one of the conformant representations. The byte stream might then be parsed by the caller of the resolveRepresentation function into a data model, which can in turn be validated and processed. If the resolution is unsuccessful, this value MUST be an empty stream.\n\ndidDocumentMetadata\n\nIf the resolution is successful, this MUST be a metadata structure. This structure contains metadata about the DID document contained in the didDocument property. This metadata typically does not change between invocations of the resolve and resolveRepresentation functions unless the DID document changes, as it represents metadata about the DID document. If the resolution is unsuccessful, this output MUST be an empty metadata structure. Properties defined by this specification are in 7.1.3 DID Document Metadata.\n\nConforming DID resolver implementations do not alter the signature of these functions in any way. DID resolver implementations might map the resolve and resolveRepresentation functions to a method-specific internal function to perform the actual DID resolution process. DID resolver implementations might implement and expose additional functions with different signatures in addition to the resolve and resolveRepresentation functions specified here.\n\n7.1.1 DID Resolution Options\n\nThe possible properties within this structure and their possible values are registered in the DID Specification Registries [DID-SPEC-REGISTRIES]. This specification defines the following common properties.\n\naccept\n\nThe Media Type of the caller's preferred representation of the DID document. The Media Type MUST be expressed as an ASCII string. The DID resolver implementation SHOULD use this value to determine the representation contained in the returned didDocumentStream if such a representation is supported and available. This property is OPTIONAL for the resolveRepresentation function and MUST NOT be used with the resolve function.\n\n7.1.2 DID Resolution Metadata\n\nThe possible properties within this structure and their possible values are registered in the DID Specification Registries [DID-SPEC-REGISTRIES]. This specification defines the following DID resolution metadata properties:\n\ncontentType\n\nThe Media Type of the returned didDocumentStream. This property is REQUIRED if resolution is successful and if the resolveRepresentation function was called. This property MUST NOT be present if the resolve function was called. The value of this property MUST be an ASCII string that is the Media Type of the conformant representations. The caller of the resolveRepresentation function MUST use this value when determining how to parse and process the didDocumentStream returned by this function into the data model.\n\nerror\n\nThe error code from the resolution process. This property is REQUIRED when there is an error in the resolution process. The value of this property MUST be a single keyword ASCII string. The possible property values of this field SHOULD be registered in the DID Specification Registries [DID-SPEC-REGISTRIES]. This specification defines the following common error values:\n\ninvalidDid\n\nThe DID supplied to the DID resolution function does not conform to valid syntax. (See 3.1 DID Syntax.)\n\nnotFound\n\nThe DID resolver was unable to find the DID document resulting from this resolution request.\n\nrepresentationNotSupported\n\nThis error code is returned if the representation requested via the accept input metadata property is not supported by the DID method and/or DID resolver implementation.\n\n7.1.3 DID Document Metadata\n\nThe possible properties within this structure and their possible values SHOULD be registered in the DID Specification Registries [DID-SPEC-REGISTRIES]. This specification defines the following common properties.\n\ncreated\n\nDID document metadata SHOULD include a created property to indicate the timestamp of the Create operation. The value of the property MUST be a string formatted as an XML Datetime normalized to UTC 00:00:00 and without sub-second decimal precision. For example: 2020-12-20T19:17:47Z.\n\nDID document metadata SHOULD include an updated property to indicate the timestamp of the last Update operation for the document version which was resolved. The value of the property MUST follow the same formatting rules as the created property. The updated property is omitted if an Update operation has never been performed on the DID document. If an updated property exists, it can be the same value as the created property when the difference between the two timestamps is less than one second.\n\ndeactivated\n\nIf a DID has been deactivated, DID document metadata MUST include this property with the boolean value true. If a DID has not been deactivated, this property is OPTIONAL, but if included, MUST have the boolean value false.\n\nDID document metadata MAY include a nextUpdate property if the resolved document version is not the latest version of the document. It indicates the timestamp of the next Update operation. The value of the property MUST follow the same formatting rules as the created property.\n\nversionId\n\nDID document metadata SHOULD include a versionId property to indicate the version of the last Update operation for the document version which was resolved. The value of the property MUST be an ASCII string.\n\nnextVersionId\n\nDID document metadata MAY include a nextVersionId property if the resolved document version is not the latest version of the document. It indicates the version of the next Update operation. The value of the property MUST be an ASCII string.\n\nequivalentId\n\nA DID method can define different forms of a DID that are logically equivalent. An example is when a DID takes one form prior to registration in a verifiable data registry and another form after such registration. In this case, the DID method specification might need to express one or more DIDs that are logically equivalent to the resolved DID as a property of the DID document. This is the purpose of the equivalentId property.\n\nDID document metadata MAY include an equivalentId property. If present, the value MUST be a set where each item is a string that conforms to the rules in Section 3.1 DID Syntax. The relationship is a statement that each equivalentId value is logically equivalent to the id property value and thus refers to the same DID subject. Each equivalentId DID value MUST be produced by, and a form of, the same DID method as the id property value. (e.g., did:example:abc == did:example:ABC)\n\nA conforming DID method specification MUST guarantee that each equivalentId value is logically equivalent to the id property value.\n\nA requesting party is expected to retain the values from the id and equivalentId properties to ensure any subsequent interactions with any of the values they contain are correctly handled as logically equivalent (e.g., retain all variants in a database so an interaction with any one maps to the same underlying account).\n\nNote: Stronger equivalence\n\nequivalentId is a much stronger form of equivalence than alsoKnownAs because the equivalence MUST be guaranteed by the governing DID method. equivalentId represents a full graph merge because the same DID document describes both the equivalentId DID and the id property DID.\n\nIf a requesting party does not retain the values from the id and equivalentId properties and ensure any subsequent interactions with any of the values they contain are correctly handled as logically equivalent, there might be negative or unexpected issues that arise. Implementers are strongly advised to observe the directives related to this metadata property.\n\ncanonicalId\n\nThe canonicalId property is identical to the equivalentId property except: a) it is associated with a single value rather than a set, and b) the DID is defined to be the canonical ID for the DID subject within the scope of the containing DID document.\n\nDID document metadata MAY include a canonicalId property. If present, the value MUST be a string that conforms to the rules in Section 3.1 DID Syntax. The relationship is a statement that the canonicalId value is logically equivalent to the id property value and that the canonicalId value is defined by the DID method to be the canonical ID for the DID subject in the scope of the containing DID document. A canonicalId value MUST be produced by, and a form of, the same DID method as the id property value. (e.g., did:example:abc == did:example:ABC).\n\nA conforming DID method specification MUST guarantee that the canonicalId value is logically equivalent to the id property value.\n\nA requesting party is expected to use the canonicalId value as its primary ID value for the DID subject and treat all other equivalent values as secondary aliases (e.g., update corresponding primary references in their systems to reflect the new canonical ID directive).\n\nNote: Canonical equivalence\n\ncanonicalId is the same statement of equivalence as equivalentId except it is constrained to a single value that is defined to be canonical for the DID subject in the scope of the DID document. Like equivalentId, canonicalId represents a full graph merge because the same DID document describes both the canonicalId DID and the id property DID.\n\nIf a resolving party does not use the canonicalId value as its primary ID value for the DID subject and treat all other equivalent values as secondary aliases, there might be negative or unexpected issues that arise related to user experience. Implementers are strongly advised to observe the directives related to this metadata property.\n\n7.2 DID URL Dereferencing\n\nThe DID URL dereferencing function dereferences a DID URL into a resource with contents depending on the DID URL's components, including the DID method, method-specific identifier, path, query, and fragment. This process depends on DID resolution of the DID contained in the DID URL. DID URL dereferencing might involve multiple steps (e.g., when the DID URL being dereferenced includes a fragment), and the function is defined to return the final resource after all steps are completed. The details of how this process is accomplished are outside the scope of this specification. The following figure depicts the relationship described above.\n\nThe top left part of the diagram contains a rectangle with black outline, labeled \"DID\".\n\nThe bottom left part of the diagram contains a rectangle with black outline, labeled \"DID URL\". This rectangle contains four smaller black-outlined rectangles, aligned in a horizontal row adjacent to each other. These smaller rectangles are labeled, in order, \"DID\", \"path\", \"query\", and \"fragment.\n\nThe top right part of the diagram contains a rectangle with black outline, labeled \"DID document\". This rectangle contains three smaller black-outlined rectangles. These smaller rectangles are labeled \"id\", \"(property X)\", and \"(property Y)\", and are surrounded by multiple series of three dots (ellipses). A curved black arrow, labeled \"DID document - relative fragment dereference\", extends from the rectangle labeled \"(property X)\", and points to the rectangle labeled \"(property Y)\".\n\nThe bottom right part of the diagram contains an oval shape with black outline, labeled \"Resource\".\n\nA black arrow, labeled \"resolves to a DID document\", extends from the rectangle in the top left part of the diagram, labeled \"DID\", and points to the rectangle in the top right part of diagram, labeled \"DID document\".\n\nA black arrow, labeled \"refers to\", extends from the rectangle in the top right part of the diagram, labeled \"DID document\", and points to the oval shape in the bottom right part of diagram, labeled \"Resource\".\n\nA black arrow, labeled \"contains\", extends from the small rectangle labeled \"DID\" inside the rectangle in the bottom left part of the diagram, labeled \"DID URL\", and points to the rectangle in the top left part of diagram, labeled \"DID\".\n\nA black arrow, labeled \"dereferences to a DID document\", extends from the rectangle in the bottom left part of the diagram, labeled \"DID URL\", and points to the rectangle in the top right part of diagram, labeled \"DID document\".\n\nA black arrow, labeled \"dereferences to a resource\", extends from the rectangle in the bottom left part of the diagram, labeled \"DID URL\", and points to the oval shape in the bottom right part of diagram, labeled \"Resource\".\n\nAll conforming DID resolvers implement the following function which has the following abstract form:\n\ndereference(didUrl, dereferenceOptions) → « dereferencingMetadata, contentStream, contentMetadata »\n\nThe input variables of the dereference function are as follows:\n\ndidUrl\n\nA conformant DID URL as a single string. This is the DID URL to dereference. To dereference a DID fragment, the complete DID URL including the DID fragment MUST be used. This input is REQUIRED.\n\nNote: DID URL dereferencer patterns\n\nWhile it is valid for any didUrl to be passed to a DID URL dereferencer, implementers are expected to refer to [DID-RESOLUTION] to further understand common patterns for how a DID URL is expected to be dereferenced.\n\ndereferencingOptions\n\nA metadata structure consisting of input options to the dereference function in addition to the didUrl itself. Properties defined by this specification are in 7.2.1 DID URL Dereferencing Options. This input is REQUIRED, but the structure MAY be empty.\n\nThis function returns multiple values, and no limitations are placed on how these values are returned together. The return values of the dereference include dereferencingMetadata, contentStream, and contentMetadata:\n\ndereferencingMetadata\n\nA metadata structure consisting of values relating to the results of the DID URL dereferencing process. This structure is REQUIRED, and in the case of an error in the dereferencing process, this MUST NOT be empty. Properties defined by this specification are in 7.2.2 DID URL Dereferencing Metadata. If the dereferencing is not successful, this structure MUST contain an error property describing the error.\n\ncontentStream\n\nIf the dereferencing function was called and successful, this MUST contain a resource corresponding to the DID URL. The contentStream MAY be a resource such as a DID document that is serializable in one of the conformant representations, a Verification Method, a service, or any other resource format that can be identified via a Media Type and obtained through the resolution process. If the dereferencing is unsuccessful, this value MUST be empty.\n\ncontentMetadata\n\nIf the dereferencing is successful, this MUST be a metadata structure, but the structure MAY be empty. This structure contains metadata about the contentStream. If the contentStream is a DID document, this MUST be a didDocumentMetadata structure as described in DID Resolution. If the dereferencing is unsuccessful, this output MUST be an empty metadata structure.\n\nConforming DID URL dereferencing implementations do not alter the signature of these functions in any way. DID URL dereferencing implementations might map the dereference function to a method-specific internal function to perform the actual DID URL dereferencing process. DID URL dereferencing implementations might implement and expose additional functions with different signatures in addition to the dereference function specified here.\n\n7.2.1 DID URL Dereferencing Options\n\nThe possible properties within this structure and their possible values SHOULD be registered in the DID Specification Registries [DID-SPEC-REGISTRIES]. This specification defines the following common properties for dereferencing options:\n\naccept\n\nThe Media Type that the caller prefers for contentStream. The Media Type MUST be expressed as an ASCII string. The DID URL dereferencing implementation SHOULD use this value to determine the contentType of the representation contained in the returned value if such a representation is supported and available.\n\n7.2.2 DID URL Dereferencing Metadata\n\nThe possible properties within this structure and their possible values are registered in the DID Specification Registries [DID-SPEC-REGISTRIES]. This specification defines the following common properties.\n\ncontentType\n\nThe Media Type of the returned contentStream SHOULD be expressed using this property if dereferencing is successful. The Media Type value MUST be expressed as an ASCII string.\n\nerror\n\nThe error code from the dereferencing process. This property is REQUIRED when there is an error in the dereferencing process. The value of this property MUST be a single keyword expressed as an ASCII string. The possible property values of this field SHOULD be registered in the DID Specification Registries [DID-SPEC-REGISTRIES]. This specification defines the following common error values:\n\ninvalidDidUrl\n\nThe DID URL supplied to the DID URL dereferencing function does not conform to valid syntax. (See 3.2 DID URL Syntax.)\n\nnotFound\n\nThe DID URL dereferencer was unable to find the contentStream resulting from this dereferencing request.\n\n7.3 Metadata Structure\n\nInput and output metadata is often involved during the DID Resolution, DID URL dereferencing, and other DID-related processes. The structure used to communicate this metadata MUST be a map of properties. Each property name MUST be a string. Each property value MUST be a string, map, list, set, boolean, or null. The values within any complex data structures such as maps and lists MUST be one of these data types as well. All metadata property definitions registered in the DID Specification Registries [DID-SPEC-REGISTRIES] MUST define the value type, including any additional formats or restrictions to that value (for example, a string formatted as a date or as a decimal integer). It is RECOMMENDED that property definitions use strings for values. The entire metadata structure MUST be serializable according to the JSON serialization rules in the [INFRA] specification. Implementations MAY serialize the metadata structure to other data formats.\n\nAll implementations of functions that use metadata structures as either input or output are able to fully represent all data types described here in a deterministic fashion. As inputs and outputs using metadata structures are defined in terms of data types and not their serialization, the method for representation is internal to the implementation of the function and is out of scope of this specification.\n\nThe following example demonstrates a JSON-encoded metadata structure that might be used as DID resolution input metadata.\n\nExample 24: JSON-encoded DID resolution input metadata example\n\n{ \"accept\": \"application/did+ld+json\" }\n\nThis example corresponds to a metadata structure of the following format:\n\nExample 25: DID resolution input metadata example\n\n«[ \"accept\" → \"application/did+ld+json\" ]»\n\nThe next example demonstrates a JSON-encoded metadata structure that might be used as DID resolution metadata if a DID was not found.\n\nExample 26: JSON-encoded DID resolution metadata example\n\n{ \"error\": \"notFound\" }\n\nThis example corresponds to a metadata structure of the following format:\n\nExample 27: DID resolution metadata example\n\n«[ \"error\" → \"notFound\" ]»\n\nThe next example demonstrates a JSON-encoded metadata structure that might be used as DID document metadata to describe timestamps associated with the DID document.\n\nExample 28: JSON-encoded DID document metadata example\n\n{ \"created\": \"2019-03-23T06:35:22Z\", \"updated\": \"2023-08-10T13:40:06Z\" }\n\nThis example corresponds to a metadata structure of the following format:\n\nExample 29: DID document metadata example\n\n«[ \"created\" → \"2019-03-23T06:35:22Z\", \"updated\" → \"2023-08-10T13:40:06Z\" ]»\n\n9. Security Considerations\n\nThis section is non-normative.\n\nThis section contains a variety of security considerations that people using Decentralized Identifiers are advised to consider before deploying this technology in a production setting. DIDs are designed to operate under the threat model used by many IETF standards and documented in [RFC3552]. This section elaborates upon a number of the considerations in [RFC3552], as well as other considerations that are unique to DID architecture.\n\n9.1 Choosing DID Resolvers\n\nThe DID Specification Registries [DID-SPEC-REGISTRIES] contains an informative list of DID method names and their corresponding DID method specifications. Implementers need to bear in mind that there is no central authority to mandate which DID method specification is to be used with any specific DID method name. If there is doubt on whether or not a specific DID resolver implements a DID method correctly, the DID Specification Registries can be used to look up the registered specification and make an informed decision regarding which DID resolver implementation to use.\n\n9.2 Proving Control and Binding\n\nBinding an entity in the digital world or the physical world to a DID, to a DID document, or to cryptographic material requires, the use of security protocols contemplated by this specification. The following sections describe some possible scenarios and how an entity therein might prove control over a DID or a DID document for the purposes of authentication or authorization.\n\nProving Control of a DID and/or DID Document\n\nProving control over a DID and/or a DID Document is useful when updating either in a verifiable data registry or authenticating with remote systems. Cryptographic digital signatures and enable certain security protocols related to DID documents to be cryptographically verifiable. For these purposes, this specification defines useful verification relationships in 5.3.1 Authentication and 5.3.4 Capability Invocation. The secret cryptographic material associated with the verification methods can be used to generate a cryptographic digital signature as a part of an authentication or authorization security protocol.\n\nNote: Signed DID documents\n\nSome DID methods allow digital signatures and other proofs to be included in the DID document or a 7.3 Metadata Structure. However, such proofs by themselves do not necessarily prove control over a DID, or guarantee that the DID document is the correct one for the DID. In order to obtain the correct DID document and verify control over a DID, it is necessary to perform the DID resolution process as defined by the DID method.\n\nBinding to Physical Identity\n\nA DID and DID document do not inherently carry any personal data and it is strongly advised that non-public entities do not publish personal data in DID documents.\n\nIt can be useful to express a binding of a DID to a person's or organization's physical identity in a way that is provably asserted by a trusted authority, such as a government. This specification provides the 5.3.2 Assertion verification relationship for these purposes. This feature can enable interactions that are private and can be considered legally enforceable under one or more jurisdictions; establishing such bindings has to be carefully balanced against privacy considerations (see 10. Privacy Considerations).\n\nThe process of binding a DID to something in the physical world, such as a person or an organization — for example, by using verifiable credentials with the same subject as that DID — is contemplated by this specification and further defined in the Verifiable Credentials Data Model [VC-DATA-MODEL].\n\n9.3 Authentication Service Endpoints\n\nIf a DID document publishes a service intended for authentication or authorization of the DID subject (see Section 5.4 Services), it is the responsibility of the service endpoint provider, subject, or requesting party to comply with the requirements of the authentication protocols supported at that service endpoint.\n\n9.4 Non-Repudiation\n\nNon-repudiation of DIDs and DID document updates is supported if:\n\nThe verifiable data registry supports . See 7.1.3 DID Document Metadata for further information on useful timestamps that can be used during the DID resolution process.\n\nThe subject is monitoring for unauthorized updates as elaborated upon in 9.5 Notification of DID Document Changes.\n\nThe subject has had adequate opportunity to revert malicious updates according to the authorization mechanism for the DID method.\n\n9.5 Notification of DID Document Changes\n\nOne mitigation against unauthorized changes to a DID document is monitoring and actively notifying the DID subject when there are changes. This is analogous to helping prevent account takeover on conventional username/password accounts by sending password reset notifications to the email addresses on file.\n\nIn the case of a DID, there is no intermediary registrar or account provider to generate such notifications. However, if the verifiable data registry on which the DID is registered directly supports change notifications, a subscription service can be offered to DID controllers. Notifications could be sent directly to the relevant service endpoints listed in an existing DID.\n\nIf a DID controller chooses to rely on a third-party monitoring service (other than the verifiable data registry itself), this introduces another vector of attack.\n\n9.6 Key and Signature Expiration\n\nIn a decentralized identifier architecture, there might not be centralized authorities to enforce cryptographic material or cryptographic digital signature expiration policies. Therefore, it is with supporting software such as DID resolvers and verification libraries that requesting parties validate that cryptographic material were not expired at the time they were used. Requesting parties might employ their own expiration policies in addition to inputs into their verification processes. For example, some requesting parties might accept authentications from five minutes in the past, while others with access to high precision time sources might require authentications to be time stamped within the last 500 milliseconds.\n\nThere are some requesting parties that have legitimate needs to extend the use of already-expired cryptographic material, such as verifying legacy cryptographic digital signatures. In these scenarios, a requesting party might instruct their verification software to ignore cryptographic key material expiration or determine if the cryptographic key material was expired at the time it was used.\n\n9.7 Verification Method Rotation\n\nRotation is a management process that enables the secret cryptographic material associated with an existing verification method to be deactivated or destroyed once a new verification method has been added to the DID document. Going forward, any new proofs that a controller would have generated using the old secret cryptographic material can now instead be generated using the new cryptographic material and can be verified using the new verification method.\n\nRotation is a useful mechanism for protecting against verification method compromise, since frequent rotation of a verification method by the controller reduces the value of a single compromised verification method to an attacker. Performing revocation immediately after rotation is useful for verification methods that a controller designates for short-lived verifications, such as those involved in encrypting messages and authentication.\n\nThe following considerations might be of use when contemplating the use of verification method rotation:\n\nVerification method rotation is a proactive security measure.\n\nIt is generally considered a best practice to perform verification method rotation on a regular basis.\n\nHigher security environments tend to employ more frequent verification method rotation.\n\nVerification method rotation manifests only as changes to the current or latest version of a DID document.\n\nWhen a verification method has been active for a long time, or used for many operations, a controller might wish to perform a rotation.\n\nFrequent rotation of a verification method might be frustrating for parties that are forced to continuously renew or refresh associated credentials.\n\nProofs or signatures that rely on verification methods that are not present in the latest version of a DID document are not impacted by rotation. In these cases, verification software might require additional information, such as when a particular verification method was expected to be valid as well as access to a verifiable data registry containing a historical record, to determine the validity of the proof or signature. This option might not be available in all DID methods.\n\nThe section on DID method operations specifies the DID operations to be supported by a DID method specification, including update which is expected to be used to perform a verification method rotation.\n\nA controller performs a rotation when they add a new verification method that is meant to replace an existing verification method after some time.\n\nNot all DID methods support verification method rotation.\n\n9.8 Verification Method Revocation\n\nRevocation is a management process that enables the secret cryptographic material associated with an existing verification method to be deactivated such that it ceases to be a valid form of creating new proofs of digital signatures.\n\nRevocation is a useful mechanism for reacting to a verification method compromise. Performing revocation immediately after rotation is useful for verification methods that a controller designates for short-lived verifications, such as those involved in encrypting messages and authentication.\n\nCompromise of the secrets associated with a verification method allows the attacker to use them according to the verification relationship expressed by controller in the DID document, for example, for authentication. The attacker's use of the secrets might be indistinguishable from the legitimate controller's use starting from the time the verification method was registered, to the time it was revoked.\n\nThe following considerations might be of use when contemplating the use of verification method revocation:\n\nVerification method revocation is a reactive security measure.\n\nIt is considered a best practice to support key revocation.\n\nA controller is expected to immediately revoke any verification method that is known to be compromised.\n\nVerification method revocation can only be embodied in changes to the latest version of a DID Document; it cannot retroactively adjust previous versions.\n\nAs described in 5.2.1 Verification Material, absence of a verification method is the only form of revocation that applies to all DID Methods that support revocation.\n\nIf a verification method is no longer exclusively accessible to the controller or parties trusted to act on behalf of the controller, it is expected to be revoked immediately to reduce the risk of compromises such as masquerading, theft, and fraud.\n\nRevocation is expected to be understood as a controller expressing that proofs or signatures associated with a revoked verification method created after its revocation should be treated as invalid. It could also imply a concern that existing proofs or signatures might have been created by an attacker, but this is not necessarily the case. Verifiers, however, might still choose to accept or reject any such proofs or signatures at their own discretion.\n\nThe section on DID method operations specifies the DID operations to be supported by a DID method specification, including update and deactivate, which might be used to remove a verification method from a DID document.\n\nNot all DID methods support verification method revocation.\n\nEven if a verification method is present in a DID document, additional information, such as a public key revocation certificate, or an external allow or deny list, could be used to determine whether a verification method has been revoked.\n\nThe day-to-day operation of any software relying on a compromised verification method, such as an individual's operating system, antivirus, or endpoint protection software, could be impacted when the verification method is publicly revoked.\n\nRevocation Semantics\n\nAlthough verifiers might choose not to accept proofs or signatures from a revoked verification method, knowing whether a verification was made with a revoked verification method is trickier than it might seem. Some DID methods provide the ability to look back at the state of a DID at a point in time, or at a particular version of the DID document. When such a feature is combined with a reliable way to determine the time or DID version that existed when a cryptographically verifiable statement was made, then revocation does not undo that statement. This can be the basis for using DIDs to make binding commitments; for example, to sign a mortgage.\n\nIf these conditions are met, revocation is not retroactive; it only nullifies future use of the method.\n\nHowever, in order for such semantics to be safe, the second condition — an ability to know what the state of the DID document was at the time the assertion was made — is expected to apply. Without that guarantee, someone could discover a revoked key and use it to make cryptographically verifiable statements with a simulated date in the past.\n\nSome DID methods only allow the retrieval of the current state of a DID. When this is true, or when the state of a DID at the time of a cryptographically verifiable statement cannot be reliably determined, then the only safe course is to disallow any consideration of DID state with respect to time, except the present moment. DID ecosystems that take this approach essentially provide cryptographically verifiable statements as ephemeral tokens that can be invalidated at any time by the DID controller.\n\nRevocation in Trustless Systems\n\nTrustless systems are those where all trust is derived from cryptographically provable assertions, and more specifically, where no metadata outside of the cryptographic system is factored into the determination of trust in the system. To verify a signature of proof for a verification method which has been revoked in a trustless system, a DID method needs to support either or both of the versionId or versionTime, as well as both the updated and nextUpdate, DID document metadata properties. A verifier can validate a signature or proof of a revoked key if and only if all of the following are true:\n\nThe proof or signature includes the versionId or versionTime of the DID document that was used at the point the signature or proof was created.\n\nThe verifier can determine the point in time at which the signature or proof was made; for example, it was anchored on a blockchain.\n\nFor the resolved DID document metadata, the updated timestamp is before, and the nextUpdate timestamp is after, the point in time at which the signature or proof was made.\n\nIn systems that are willing to admit metadata other than those constituting cryptographic input, similar trust may be achieved -- but always on the same basis where a careful judgment is made about whether a DID document's content at the moment of a signing event contained the expected content.\n\n9.9 DID Recovery\n\nRecovery is a reactive security measure whereby a controller that has lost the ability to perform DID operations, such as through the loss of a device, is able to regain the ability to perform DID operations.\n\nThe following considerations might be of use when contemplating the use of DID recovery:\n\nPerforming recovery proactively on an infrequent but regular basis, can help to ensure that control has not been lost.\n\nIt is considered a best practice to never reuse cryptographic material associated with recovery for any other purposes.\n\nRecovery is commonly performed in conjunction with verification method rotation and verification method revocation.\n\nRecovery is advised when a controller or services trusted to act on their behalf no longer have the exclusive ability to perform DID operations as described in 8.2 Method Operations.\n\nDID method specifications might choose to enable support for a quorum of trusted parties to facilitate recovery. Some of the facilities to do so are suggested in 5.1.2 DID Controller.\n\nNot all DID method specifications will recognize control from DIDs registered using other DID methods and they might restrict third-party control to DIDs that use the same method.\n\nAccess control and recovery in a DID method specification can also include a time lock feature to protect against key compromise by maintaining a second track of control for recovery.\n\nThere are currently no common recovery mechanisms that apply to all DID methods.\n\n9.10 The Role of Human-Friendly Identifiers\n\nDIDs achieve global uniqueness without the need for a central registration authority. This comes at the cost of human memorability. Algorithms capable of generating globally unambiguous identifiers produce random strings of characters that have no human meaning. This trade-off is often referred to as Zooko's Triangle.\n\nThere are use cases where it is desirable to discover a DID when starting from a human-friendly identifier. For example, a natural language name, a domain name, or a conventional address for a DID controller, such as a mobile telephone number, email address, social media username, or blog URL. However, the problem of mapping human-friendly identifiers to DIDs, and doing so in a way that can be verified and trusted, is outside the scope of this specification.\n\nSolutions to this problem are defined in separate specifications, such as [DNS-DID], that reference this specification. It is strongly recommended that such specifications carefully consider the:\n\nNumerous security attacks based on deceiving users about the true human-friendly identifier for a target entity.\n\nPrivacy consequences of using human-friendly identifiers that are inherently correlatable, especially if they are globally unique.\n\n9.11 DIDs as Enhanced URNs\n\nIf desired by a DID controller, a DID or a DID URL is capable of acting as persistent, location-independent resource identifier. These sorts of identifiers are classified as Uniform Resource Names (URNs) and are defined in [RFC8141]. DIDs are an enhanced form of URN that provide a cryptographically secure, location-independent identifier for a digital resource, while also providing metadata that enables retrieval. Due to the indirection between the DID document and the DID itself, the DID controller can adjust the actual location of the resource — or even provide the resource directly — without adjusting the DID. DIDs of this type can definitively verify that the resource retrieved is, in fact, the resource identified.\n\nA DID controller who intends to use a DID for this purpose is advised to follow the security considerations in [RFC8141]. In particular:\n\nThe DID controller is expected to choose a DID method that supports the controller's requirements for persistence. The Decentralized Characteristics Rubric [DID-RUBRIC] is one tool available to help implementers decide upon the most suitable DID method.\n\nThe DID controller is expected to publish its operational policies so requesting parties can determine the degree to which they can rely on the persistence of a DID controlled by that DID controller. In the absence of such policies, requesting parties are not expected to make any assumption about whether a DID is a persistent identifier for the same DID subject.\n\n9.12 Immutability\n\nMany cybersecurity abuses hinge on exploiting gaps between reality and the assumptions of rational, good-faith actors. Immutability of DID documents can provide some security benefits. Individual DID methods ought to consider constraints that would eliminate behaviors or semantics they do not need. The more locked down a DID method is, while providing the same set of features, the less it can be manipulated by malicious actors.\n\nAs an example, consider that a single edit to a DID document can change anything except the root id property of the document. But is it actually desirable for a service to change its type after it is defined? Or for a key to change its value? Or would it be better to require a new id when certain fundamental properties of an object change? Malicious takeovers of a website often aim for an outcome where the site keeps its host name identifier, but is subtly changed underneath. If certain properties of the site, such as the ASN associated with its IP address, were required by the specification to be immutable, anomaly detection would be easier, and attacks would be much harder and more expensive to carry out.\n\nFor DID methods tied to a global source of truth, a direct, just-in-time lookup of the latest version of a DID document is always possible. However, it seems likely that layers of cache might eventually sit between a DID resolver and that source of truth. If they do, believing the attributes of an object in the DID document to have a given state when they are actually subtly different might invite exploits. This is particularly true if some lookups are of a full DID document, and others are of partial data where the larger context is assumed.\n\n9.13 Encrypted Data in DID Documents\n\nEncryption algorithms have been known to fail due to advances in cryptography and computing power. Implementers are advised to assume that any encrypted data placed in a DID document might eventually be made available in clear text to the same audience to which the encrypted data is available. This is particularly pertinent if the DID document is public.\n\nEncrypting all or parts of a DID document is not an appropriate means to protect data in the long term. Similarly, placing encrypted data in a DID document is not an appropriate means to protect personal data.\n\nGiven the caveats above, if encrypted data is included in a DID document, implementers are advised to not associate any correlatable information that could be used to infer a relationship between the encrypted data and an associated party. Examples of correlatable information include public keys of a receiving party, identifiers to digital assets known to be under the control of a receiving party, or human readable descriptions of a receiving party.\n\n9.14 Equivalence Properties\n\nGiven the equivalentId and canonicalId properties are generated by DID methods themselves, the same security and accuracy guarantees that apply to the resolved DID present in the id field of a DID document also apply to these properties. The alsoKnownAs property is not guaranteed to be an accurate statement of equivalence, and should not be relied upon without performing validation steps beyond the resolution of the DID document.\n\nThe equivalentId and canonicalId properties express equivalence assertions to variants of a single DID produced by the same DID method and can be trusted to the extent the requesting party trusts the DID method and a conforming producer and resolver.\n\nThe alsoKnownAs property permits an equivalence assertion to URIs that are not governed by the same DID method and cannot be trusted without performing verification steps outside of the governing DID method. See additional guidance in 5.1.3 Also Known As.\n\nAs with any other security-related properties in the DID document, parties relying on any equivalence statement in a DID document should guard against the values of these properties being substituted by an attacker after the proper verification has been performed. Any write access to a DID document stored in memory or disk after verification has been performed is an attack vector that might circumvent verification unless the DID document is re-verified.\n\n9.15 Content Integrity Protection\n\nDID documents which include links to external machine-readable content such as images, web pages, or schemas are vulnerable to tampering. It is strongly advised that external links are integrity protected using solutions such as a hashlink [HASHLINK]. External links are to be avoided if they cannot be integrity protected and the DID document's integrity is dependent on the external link.\n\nOne example of an external link where the integrity of the DID document itself could be affected is the JSON-LD Context [JSON-LD11]. To protect against compromise, DID document consumers are advised to cache local static copies of JSON-LD contexts and/or verify the integrity of external contexts against a cryptographic hash that is known to be associated with a safe version of the external JSON-LD Context.\n\n9.16 Persistence\n\nDIDs are designed to be persistent such that a controller need not rely upon a single trusted third party or administrator to maintain their identifiers. In an ideal case, no administrator can take control away from the controller, nor can an administrator prevent their identifiers' use for any particular purpose such as authentication, authorization, and attestation. No third party can act on behalf of a controller to remove or render inoperable an entity's identifier without the controller's consent.\n\nHowever, it is important to note that in all DID methods that enable cryptographic proof-of-control, the means of proving control can always be transferred to another party by transferring the secret cryptographic material. Therefore, it is vital that systems relying on the persistence of an identifier over time regularly check to ensure that the identifier is, in fact, still under the control of the intended party.\n\nUnfortunately, it is impossible to determine from the cryptography alone whether or not the secret cryptographic material associated with a given verification method has been compromised. It might well be that the expected controller still has access to the secret cryptographic material — and as such can execute a proof-of-control as part of a verification process — while at the same time, a bad actor also has access to those same keys, or to a copy thereof.\n\nAs such, cryptographic proof-of-control is expected to only be used as one factor in evaluating the level of identity assurance required for high-stakes scenarios. DID-based authentication provides much greater assurance than a username and password, thanks to the ability to determine control over a cryptographic secret without transmitting that secret between systems. However, it is not infallible. Scenarios that involve sensitive, high value, or life-critical operations are expected to use additional factors as appropriate.\n\nIn addition to potential ambiguity from use by different controllers, it is impossible to guarantee, in general, that a given DID is being used in reference to the same subject at any given point in time. It is technically possible for the controller to reuse a DID for different subjects and, more subtly, for the precise definition of the subject to either change over time or be misunderstood.\n\nFor example, consider a DID used for a sole proprietorship, receiving various credentials used for financial transactions. To the controller, that identifier referred to the business. As the business grows, it eventually gets incorporated as a Limited Liability Company. The controller continues using that same DID, because to them the DID refers to the business. However, to the state, the tax authority, and the local municipality, the DID no longer refers to the same entity. Whether or not the subtle shift in meaning matters to a credit provider or supplier is necessarily up to them to decide. In many cases, as long as the bills get paid and collections can be enforced, the shift is immaterial.\n\nDue to these potential ambiguities, DIDs are to be considered valid contextually rather than absolutely. Their persistence does not imply that they refer to the exact same subject, nor that they are under the control of the same controller. Instead, one needs to understand the context in which the DID was created, how it is used, and consider the likely shifts in their meaning, and adopt procedures and policies to address both potential and inevitable semantic drift.\n\n9.17 Level of Assurance\n\nAdditional information about the security context of authentication events is often required for compliance reasons, especially in regulated areas such as the financial and public sectors. This information is often referred to as a Level of Assurance (LOA). Examples include the protection of secret cryptographic material, the identity proofing process, and the form-factor of the authenticator.\n\nPayment services (PSD 2) and eIDAS introduce such requirements to the security context. Level of assurance frameworks are classified and defined by regulations and standards such as eIDAS, NIST 800-63-3 and ISO/IEC 29115:2013, including their requirements for the security context, and making recommendations on how to achieve them. This might include strong user authentication where FIDO2/WebAuthn can fulfill the requirement.\n\nSome regulated scenarios require the implementation of a specific level of assurance. Since verification relationships such as assertionMethod and authentication might be used in some of these situations, information about the applied security context might need to be expressed and provided to a verifier. Whether and how to encode this information in the DID document data model is out of scope for this specification. Interested readers might note that 1) the information could be transmitted using Verifiable Credentials [VC-DATA-MODEL], and 2) the DID document data model can be extended to incorporate this information as described in 4.1 Extensibility, and where 10. Privacy Considerations is applicable for such extensions.\n\n10. Privacy Considerations\n\nThis section is non-normative.\n\nSince DIDs and DID documents are designed to be administered directly by the DID controller(s), it is critically important to apply the principles of Privacy by Design [PRIVACY-BY-DESIGN] to all aspects of the decentralized identifier architecture. All seven of these principles have been applied throughout the development of this specification. The design used in this specification does not assume that there is a registrar, hosting company, nor other intermediate service provider to recommend or apply additional privacy safeguards. Privacy in this specification is preventive, not remedial, and is an embedded default. The following sections cover privacy considerations that implementers might find useful when building systems that utilize decentralized identifiers.\n\n10.1 Keep Personal Data Private\n\nIf a DID method specification is written for a public-facing verifiable data registry where corresponding DIDs and DID documents might be made publicly available, it is critical that those DID documents contain no personal data. Personal data can instead be transmitted through other means such as 1) Verifiable Credentials [VC-DATA-MODEL], or 2) service endpoints under control of the DID subject or DID controller.\n\nDue diligence is expected to be taken around the use of URLs in service endpoints to prevent leakage of personal data or correlation within a URL of a service endpoint. For example, a URL that contains a username is dangerous to include in a DID Document because the username is likely to be human-meaningful in a way that can reveal information that the DID subject did not consent to sharing. With the privacy architecture suggested by this specification, personal data can be exchanged on a private, peer-to-peer basis using communication channels identified and secured by verification methods in DID documents. This also enables DID subjects and requesting parties to implement the GDPR right to be forgotten, because no personal data is written to an immutable distributed ledger.\n\n10.2 DID Correlation Risks\n\nLike any type of globally unambiguous identifier, DIDs might be used for correlation. DID controllers can mitigate this privacy risk by using pairwise DIDs that are unique to each relationship; in effect, each DID acts as a pseudonym. A pairwise DID need only be shared with more than one party when correlation is explicitly desired. If pairwise DIDs are the default, then the only need to publish a DID openly, or to share it with multiple parties, is when the DID controller(s) and/or DID subject explicitly desires public identification and correlation.\n\n10.3 DID Document Correlation Risks\n\nThe anti-correlation protections of pairwise DIDs are easily defeated if the data in the corresponding DID documents can be correlated. For example, using identical verification methods or bespoke service endpoints in multiple DID documents can provide as much correlation information as using the same DID. Therefore, the DID document for a pairwise DID also needs to use pairwise unique information, such as ensuring that verification methods are unique to the pairwise relationship.\n\nIt might seem natural to also use pairwise unique service endpoints in the DID document for a pairwise DID. However, unique endpoints allow all traffic between two DIDs to be isolated perfectly into unique buckets, where timing correlation and similar analysis is easy. Therefore, a better strategy for endpoint privacy might be to share an endpoint among a large number of DIDs controlled by many different subjects (see 10.5 Herd Privacy).\n\n10.4 DID Subject Classification\n\nIt is dangerous to add properties to the DID document that can be used to indicate, explicitly or through inference, what type or nature of thing the DID subject is, particularly if the DID subject is a person.\n\nNot only do such properties potentially result in personal data (see 10.1 Keep Personal Data Private) or correlatable data (see 10.2 DID Correlation Risks and 10.3 DID Document Correlation Risks) being present in the DID document, but they can be used for grouping particular DIDs in such a way that they are included in or excluded from certain operations or functionalities.\n\nIncluding type information in a DID Document can result in personal privacy harms even for DID Subjects that are non-person entities, such as IoT devices. The aggregation of such information around a DID Controller could serve as a form of digital fingerprint and this is best avoided.\n\nTo minimize these risks, all properties in a DID document ought to be for expressing cryptographic material, endpoints, or verification methods related to using the DID.\n\n10.5 Herd Privacy\n\nWhen a DID subject is indistinguishable from others in the herd, privacy is available. When the act of engaging privately with another party is by itself a recognizable flag, privacy is greatly diminished.\n\nDIDs and DID methods need to work to improve herd privacy, particularly for those who legitimately need it most. Choose technologies and human interfaces that default to preserving anonymity and pseudonymity. To reduce digital fingerprints, share common settings across requesting party implementations, keep negotiated options to a minimum on wire protocols, use encrypted transport layers, and pad messages to standard lengths.\n\n10.6 Service Privacy\n\nThe ability for a controller to optionally express at least one service endpoint in the DID document increases their control and agency. Each additional endpoint in the DID document adds privacy risk either due to correlation, such as across endpoint descriptions, or because the services are not protected by an authorization mechanism, or both.\n\nDID documents are often public and, since they are standardized, will be stored and indexed efficiently by their very standards-based nature. This risk is worse if DID documents are published to immutable verifiable data registries. Access to a history of the DID documents referenced by a DID represents a form of traffic analysis made more efficient through the use of standards.\n\nThe degree of additional privacy risk caused by using multiple service endpoints in one DID document can be difficult to estimate. Privacy harms are typically unintended consequences. DIDs can refer to documents, services, schemas, and other things that might be associated with individual people, households, clubs, and employers — and correlation of their service endpoints could become a powerful surveillance and inference tool. An example of this potential harm can be seen when multiple common country-level top level domains such as https://example.co.uk might be used to infer the approximate location of the DID subject with a greater degree of probability.\n\nMaintaining Herd Privacy\n\nThe variety of possible endpoints makes it particularly challenging to maintain herd privacy, in which no information about the DID subject is leaked (see 10.5 Herd Privacy).\n\nFirst, because service endpoints might be specified as URIs, they could unintentionally leak personal information because of the architecture of the service. For example, a service endpoint of http://example.com/MyFirstName is leaking the term MyFirstName to everyone who can access the DID document. When linking to legacy systems, this is an unavoidable risk, and care is expected to be taken in such cases. This specification encourages new, DID-aware endpoints to use nothing more than the DID itself for any identification necessary. For example, if a service description were to include http://example.com/did%3Aexample%3Aabc123, no harm would be done because did:example:abc123 is already exposed in the DID Document; it leaks no additional information.\n\nSecond, because a DID document can list multiple service endpoints, it is possible to irreversibly associate services that are not associated in any other context. This correlation on its own may lead to privacy harms by revealing information about the DID subject, even if the URIs used did not contain any sensitive information.\n\nThird, because some types of DID subjects might be more or less likely to list specific endpoints, the listing of a given service could, by itself, leak information that can be used to infer something about the DID subject. For example, a DID for an automobile might include a pointer to a public title record at the Department of Motor Vehicles, while a DID for an individual would not include that information.\n\nIt is the goal of herd privacy to ensure that the nature of specific DID subjects is obscured by the population of the whole. To maximize herd privacy, implementers need to rely on one — and only one — service endpoint, with that endpoint providing a proxy or mediator service that the controller is willing to depend on, to protect such associations and to blind requests to the ultimate service.\n\nService Endpoint Alternatives\n\nGiven the concerns in the previous section, implementers are urged to consider any of the following service endpoint approaches:\n\nNegotiator Endpoint — Service for negotiating mutually agreeable communications channels, preferably using private set intersection. The output of negotiation is a communication channel and whatever credentials might be needed to access it.\n\nTor Endpoint (Tor Onion Router) — Provide a privacy-respecting address for reaching service endpoints. Any service that can be provided online can be provided through TOR for additional privacy.\n\nMediator Endpoint — Mediators provide a generic endpoint, for multiple parties, receive encrypted messages on behalf of those parties, and forward them to the intended recipient. This avoids the need to have a specific endpoint per subject, which could create a correlation risk. This approach is also called a proxy.\n\nConfidential Storage — Proprietary or confidential personal information might need to be kept off of a verifiable data registry to provide additional privacy and/or security guarantees, especially for those DID methods where DID documents are published on a public ledger. Pointing to external resource services provides a means for authorization checks and deletion.\n\nPolymorphic Proxy — A proxy endpoint that can act as any number of services, depending on how it is called. For example, the same URL could be used for both negotiator and mediator functions, depending on a mechanism for re-routing.\n\nThese service endpoint types continue to be an area of innovation and exploration.\n\nB. Architectural Considerations\n\nB.1 Detailed Architecture Diagram\n\nFollowing is a diagram showing the relationships among 4. Data Model, 5. Core Properties, and 8. Methods, and 7. Resolution.\n\nB.2 Creation of a DID\n\nThe creation of a DID is a process that is defined by each DID Method. Some DID Methods, such as did:key, are purely generative, such that a DID and a DID document are generated by transforming a single piece of cryptographic material into a conformant representation. Other DID methods might require the use of a verifiable data registry, where the DID and DID document are recognized to exist by third parties only when the registration has been completed, as defined by the respective DID method. Other processes might be defined by the respective DID method.\n\nB.3 Determining the DID subject\n\nA DID is a specific type of URI (Uniform Resource Identifier), so a DID can refer to any resource. Per [RFC3986]:\n\nthe term \"resource\" is used in a general sense for whatever might be identified by a URI. [...] A resource is not necessarily accessible via the Internet.\n\nResources can be digital or physical, abstract or concrete. Any resource that can be assigned a URI can be assigned a DID. The resource referred to by the DID is the DID subject.\n\nThe DID controller determines the DID subject. It is not expected to be possible to determine the DID subject from looking at the DID itself, as DIDs are generally only meaningful to machines, not human. A DID is unlikely to contain any information about the DID subject, so further information about the DID subject is only discoverable by resolving the DID to the DID document, obtaining a verifiable credential about the DID, or via some other description of the DID.\n\nWhile the value of the id property in the retrieved DID document must always match the DID being resolved, whether or not the actual resource to which the DID refers can change over time is dependent upon the DID method. For example, a DID method that permits the DID subject to change could be used to generate a DID for the current occupant of a particular role—such as the CEO of a company—where the actual person occupying the role can be different depending on when the DID is resolved.\n\nB.4 Referring to the DID document\n\nThe DID refers to the DID subject and resolves to the DID document (by following the protocol specified by the DID method). The DID document is not a separate resource from the DID subject and does not have a URI separate from the DID. Rather the DID document is an artifact of DID resolution controlled by the DID controller for the purpose of describing the DID subject.\n\nThis distinction is illustrated by the graph model shown below.\n\nTwo filled black circles appear at the top of the diagram, one on the left, labeled \"DID Controller\", and one on the right, labeled \"DID Subject\". A rectangle, with lower right corner bent inwards to form a small triangle, appears below, containing the label \"DID Document\". Arrows extend between these three items, as follows. A solid red arrow points directly from the DID Controller circle, rightwards to the DID Subject circle, labeled \"DID\" above it in large font, and \"Identifies\" below it in small italic font. The other arrow labels are also in small italic font. A dotted red arrow, labeled \"Resolves to\", extends from DID Controller, starting in the same line as the first arrow, then curving downward to point to the DID Document rectangle. A green arrow, labeled \"Controls\", points directly from DID Controller to DID Document. A green arrow labeled \"Controller\" points in the opposite direction, from DID Document to DID Controller, making an arc outward to the left of the diagram. A blue arrow, labeled, \"Describes\" points directly from DID Document to DID Subject.\n\nB.5 Statements in the DID document\n\nEach property in a DID document is a statement by the DID controller that describes:\n\nThe string of characters defining identifiers for the DID subject (e.g., the id and alsoKnownAs properties)\n\nHow to interact with the DID subject (e.g., the verificationMethod and service properties).\n\nHow to interpret the specific representation of the DID document (e.g., the @context property for a JSON-LD representation).\n\nThe only required property in a DID document is id, so that is the only statement guaranteed to be in a DID document. That statement is illustrated in Figure 8 with a direct link between the DID and the DID subject.\n\nB.6 Discovering more information about the DID subject\n\nOptions for discovering more information about the DID subject depend on the properties present in the DID document. If the service property is present, more information can be requested from a service endpoint. For example, by querying a service endpoint that supports verifiable credentials for one or more claims (attributes) describing the DID subject.\n\nAnother option is to use the alsoKnownAs property if it is present in the DID document. The DID controller can use it to provide a list of other URIs (including other DIDs) that refer to the same DID subject. Resolving or dereferencing these URIs might yield other descriptions or representations of the DID subject as illustrated in the figure below.\n\nThe diagram contains three small black filled circles, two rectangles with bent corners, arrows between them, and labels, as follows. On the upper left is a circle labeled \"DID Controller\". On the upper right is a circle labeled \"DID Subject\". On the lower-middle right is a circle without a label. On the lower right is a rectangle labeled \"Description\". In the center of the diagram is a rectangle labeled \"DID Document\". Inside the DID Document rectangle, beneath its label, is two lines of code: \"alsoKnownAs: [\", and \"URI]\". A black arrow extends from the second line, to the right, crossing the rectangle border, pointing to the unlabeled circle at the right of the diagram. This arrow is labeled above it in large font, \"URI\", and below it in italic, \"Identifies\". A black arrow points from the unlabeled circle downwards to the Description rectangle, labeled \"Dereferences to\". A blue arrow, labeled \"Describes\", extends from Description, arcing on the right, pointing up to DID Subject. A blue arrow, also labeled \"Describes\", points directly from the rectangle, labeled \"DID Document\", in the center of the diagram, up and to the right to the DID Subject circle. A red arrow, labeled \"alsoKnownAs\", points from DID Subject down to the unlabeled circle. A red arrow, labeled \"DID\" above it in large font, and \"Identifies\" below it in italic font, lies at the top of the image, pointing from DID Controller to DID Subject. A dotted red line starts in the same place but branches off and curves downward to point to the DID Document rectangle at the center of the image. A green arrow, labeled \"Controls\", points directly from DID Controller to DID Document. Another green arrow points in the opposite direction, labeled \"Controller\", curving outwards on the left of the image, from DID Document to DID Controller.\n\nB.7 Serving a representation of the DID subject\n\nIf the DID subject is a digital resource that can be retrieved from the internet, a DID method can choose to construct a DID URL which returns a representation of the DID subject itself. For example, a data schema that needs a persistent, cryptographically verifiable identifier could be assigned a DID, and passing a specified DID parameter (see 3.2.1 DID Parameters) could be used as a standard way to retrieve a representation of that schema.\n\nSimilarly, a DID can be used to refer to a digital resource (such as an image) that can be returned directly from a verifiable data registry if that functionality is supported by the applicable DID method.\n\nB.8 Assigning DIDs to existing web resources\n\nIf the controller of a web page or any other web resource wants to assign it a persistent, cryptographically verifiable identifier, the controller can give it a DID. For example, the author of a blog hosted by a blog hosting company (under that hosting company's domain) could create a DID for the blog. In the DID document, the author can include the alsoKnownAs property pointing to the current URL of the blog, e.g.:\n\n\"alsoKnownAs\": [\"https://myblog.blogging-host.example/home\"]\n\nIf the author subsequently moves the blog to a different hosting company (or to the author's own domain), the author can update the DID document to point to the new URL for the blog, e.g.:\n\n\"alsoKnownAs\": [\"https://myblog.example/\"]\n\nThe DID effectively adds a layer of indirection for the blog URL. This layer of indirection is under the control of the author instead of under the control of an external administrative authority such as the blog hosting company. This is how a DID can effectively function as an enhanced URN (Uniform Resource Name)—a persistent identifier for an information resource whose network location might change over time.\n\nB.9 The relationship between DID controllers and DID subjects\n\nTo avoid confusion, it is helpful to classify DID subjects into two disjoint sets based on their relationship to the DID controller.\n\nB.9.1 Set #1: The DID subject is the DID controller\n\nThe first case, shown in Figure 10, is the common scenario where the DID subject is also the DID controller. This is the case when an individual or organization creates a DID to self-identify.\n\nTwo small black circles appear in the diagram, one on the upper left, labeled, \"DID Controller\", and one on the upper right, labeled \"DID Subject\". A solid red arrow extends from the DID Controller circle to the DID Subject circle, labeled \"DID\" in large bold text above the arrow, and \"Identifies\" in small italic text beneath the arrow. A dotted red double-ended arrow, labeled \"Equivalence\", extends between the two circles, forming an arc in the space between and above them. In the lower part of the diagram is a rectangle with bent corner, outlined in black, containing the label \"DID Document\". Arrows point between this DID Document rectangle and the small black circles for DID Controller and DID Subject, with italic labels, as follows. A blue arrow points from the DID Document to the DID Subject, labeled, \"Describes\". A green arrow points from the DID Controller to the DID Document, labeled \"Controls\". A green arrow points from the DID Document to the DID Controller, in an outward arc, labeled, \"Controller\". A dotted red arrow, labeled \"Resolves to\", extends from the DID controller starting to the right, branching off from the arrow to the DID Subject, then curving downward to point to the DID Document.\n\nFrom a graph model perspective, even though the nodes identified as the DID controller and DID subject in Figure 10 are distinct, there is a logical arc connecting them to express a semantic equivalence relationship.\n\nB.9.2 Set #2: The DID subject is not the DID controller\n\nThe second case is when the DID subject is a separate entity from the DID controller. This is the case when, for example, a parent creates and maintains control of a DID for a child; a corporation creates and maintains control of a DID for a subsidiary; or a manufacturer creates and maintains control of a DID for a product, an IoT device, or a digital file.\n\nFrom a graph model perspective, the only difference from Set 1 that there is no equivalence arc relationship between the DID subject and DID controller nodes.\n\nB.10 Multiple DID controllers\n\nA DID document might have more than one DID controller. This can happen in one of two ways.\n\nB.10.1 Independent Control\n\nIn this case, each of the DID controllers might act on its own, i.e., each one has full power to update the DID document independently. From a graph model perspective, in this configuration:\n\nEach additional DID controller is another distinct graph node (which might be identified by its own DID).\n\nThe same arcs (\"controls\" and \"controller\") exist between each DID controller and the DID document.\n\nThree black circles appear on the left, vertically, each labeled \"DID Controller\". From each of these circles, a pair of green arrows extends towards the center of the diagram, to a single rectangle, labeled \"DID Document\". The rectangle has the lower right corner cut and bent inward to form a small triangle, as if to represent a physical piece of paper with curled corner. Each pair of green arrows consists of one arrow pointing from the black circle to the rectangle, labeled \"Controls\", and one pointing in the opposite direction, from the rectangle to the black circle, labeled \"Controller\". From the right of the rectangle extends a blue arrow, labeled, \"Describes\", pointing to a black circle labeled, \"DID Subject\".\n\nB.10.2 Group Control\n\nIn the case of group control, the DID controllers are expected to act together in some fashion, such as when using a cryptographic algorithm that requires multiple digital signatures (\"multi-sig\") or a threshold number of digital signatures (\"m-of-n\"). From a functional standpoint, this option is similar to a single DID controller because, although each of the DID controllers in the DID controller group has its own graph node, the actual control collapses into a single logical graph node representing the DID controller group as shown in Figure 12.\n\nOn the left are three black filled circles, labeled \"DID Controller Group\" by a brace on the left. From each of these three circles, a green arrow extends to the center right. These three arrows converge towards a single filled white circle. A pair of horizontal green arrows connects this white circle on its right to a rectangle shaped like a page with a curled corner, labeled \"DID Document\". The upper arrow points right, from the white circle to the rectangle, and is labeled \"Controls\". The lower arrow points left, from the rectangle to the white circle, and is labeled \"Controller\". From the right of the rectangle extends a blue arrow, labeled \"Describes\", pointing to a black circle, labeled \"DID Subject\".\n\nThis configuration will often apply when the DID subject is an organization, corporation, government agency, community, or other group that is not controlled by a single individual.\n\nB.11 Changing the DID subject\n\nA DID document has exactly one DID which refers to the DID subject. The DID is expressed as the value of the id property. This property value is immutable for the lifetime of the DID document.\n\nHowever, it is possible that the resource identified by the DID, the DID subject, may change over time. This is under the exclusive authority of the DID controller. For more details, see section 9.16 Persistence.\n\nB.12 Changing the DID controller\n\nThe DID controller for a DID document might change over time. However, depending on how it is implemented, a change in the DID controller might not be made apparent by changes to the DID document itself. For example, if the change is implemented through a shift in ownership of the underlying cryptographic keys or other controls used for one or more of the verification methods in the DID document, it might be indistinguishable from a standard key rotation.\n\nOn the other hand, if the change is implemented by changing the value of the controller property, it will be transparent.\n\nIf it is important to verify a change of DID controller, implementers are advised to authenticate the new DID controller against the verification methods in the revised DID document.\n\nD. Acknowledgements\n\nThe Working Group extends deep appreciation and heartfelt thanks to our Chairs Brent Zundel and Dan Burnett, as well as our W3C Staff Contact, Ivan Herman, for their tireless work in keeping the Working Group headed in a productive direction and navigating the deep and dangerous waters of the standards process.\n\nThe Working Group gratefully acknowledges the work that led to the creation of this specification, and extends sincere appreciation to those individuals that worked on technologies and specifications that deeply influenced our work. In particular, this includes the work of Phil Zimmerman, Jon Callas, Lutz Donnerhacke, Hal Finney, David Shaw, and Rodney Thayer on Pretty Good Privacy (PGP) in the 1990s and 2000s.\n\nIn the mid-2010s, preliminary implementations of what would become Decentralized Identifiers were built in collaboration with Jeremie Miller's Telehash project and the W3C Web Payments Community Group's work led by Dave Longley and Manu Sporny. Around a year later, the XDI.org Registry Working Group began exploring decentralized technologies for replacing its existing identifier registry. Some of the first written papers exploring the concept of Decentralized Identifiers can be traced back to the first several Rebooting the Web of Trust workshops convened by Christopher Allen. That work led to a key collaboration between Christopher Allen, Drummond Reed, Les Chasen, Manu Sporny, and Anil John. Anil saw promise in the technology and allocated the initial set of government funding to explore the space. Without the support of Anil John and his guidance through the years, it is unlikely that Decentralized Identifiers would be where they are today. Further refinement at the Rebooting the Web of Trust workshops led to the first implementers documentation, edited by Drummond Reed, Les Chasen, Christopher Allen, and Ryan Grant. Contributors included Manu Sporny, Dave Longley, Jason Law, Daniel Hardman, Markus Sabadello, Christian Lundkvist, and Jonathan Endersby. This initial work was then merged into the W3C Credentials Community Group, incubated further, and then transitioned to the W3C Decentralized Identifiers Working Group for global standardization.\n\nPortions of the work on this specification have been funded by the United States Department of Homeland Security's (US DHS) Science and Technology Directorate under contracts HSHQDC-16-R00012-H-SB2016-1-002, and HSHQDC-17-C-00019, as well as the US DHS Silicon Valley Innovation Program under contracts 70RSAT20T00000010, 70RSAT20T00000029, 70RSAT20T00000030, 70RSAT20T00000045, 70RSAT20T00000003, and 70RSAT20T00000033. The content of this specification does not necessarily reflect the position or the policy of the U.S. Government and no official endorsement should be inferred.\n\nPortions of the work on this specification have also been funded by the European Union's StandICT.eu program under sub-grantee contract number CALL05/19. The content of this specification does not necessarily reflect the position or the policy of the European Union and no official endorsement should be inferred.\n\nWork on this specification has also been supported by the Rebooting the Web of Trust community facilitated by Christopher Allen, Shannon Appelcline, Kiara Robles, Brian Weller, Betty Dhamers, Kaliya Young, Kim Hamilton Duffy, Manu Sporny, Drummond Reed, Joe Andrieu, and Heather Vescent. Development of this specification has also been supported by the W3C Credentials Community Group, which has been Chaired by Kim Hamilton Duffy, Joe Andrieu, Christopher Allen, Heather Vescent, and Wayne Chang. The participants in the Internet Identity Workshop, facilitated by Phil Windley, Kaliya Young, Doc Searls, and Heidi Nobantu Saul, also supported this work through numerous working sessions designed to debate, improve, and educate participants about this specification.\n\nThe Working Group thanks the following individuals for their contributions to this specification (in alphabetical order, Github handles start with @ and are sorted as last names): Denis Ah-Kang, Nacho Alamillo, Christopher Allen, Joe Andrieu, Antonio, Phil Archer, George Aristy, Baha, Juan Benet, BigBlueHat, Dan Bolser, Chris Boscolo, Pelle Braendgaard, Daniel Buchner, Daniel Burnett, Juan Caballero, @cabo, Tim Cappalli, Melvin Carvalho, David Chadwick, Wayne Chang, Sam Curren, Hai Dang, Tim Daubenschütz, Oskar van Deventer, Kim Hamilton Duffy, Arnaud Durand, Ken Ebert, Vei"
    }
}