{
    "id": "correct_subsidiary_00130_2",
    "rank": 37,
    "data": {
        "url": "https://docs.osgi.org/specification/osgi.core/7.0.0/framework.module.html",
        "read_more_link": "",
        "language": "en",
        "title": "3 Module Layer",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/logo.svg",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-core-req-cap-model.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-req-cap-wiring.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-classloader-delegation-model.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-class-space.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-class-wiring-example.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-wiring-legend.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-bundle-example.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-version-constrained.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-optional-import.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-uses-directive-servlet.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-implied-packages.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-uses-directive-resolving.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-class-loading-flowchart.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-require-bundle-depth-first.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-bundle-cycles.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-split-packages.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-fragment-resource-searching.png",
            "https://docs.osgi.org/specification/osgi.core/7.0.0/images/003-permissions-bundle-sharing.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "images/favicon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Version 1.9\n\n3.1 Introduction\n\nThe standard Java platform provides only limited support for packaging, deploying, and validating Java-based applications and components. Because of this, many Java-based projects, such as JBoss and NetBeans, have resorted to creating custom module-oriented layers with specialized class loaders for packaging, deploying, and validating applications and components. The OSGi Framework provides a generic and standardized solution for Java modularization.\n\n3.2 Bundles\n\nThe Framework defines a unit of modularization, called a bundle. A bundle is comprised of Java classes and other resources, which together can provide functions to end users. Bundles can share Java packages among an exporter bundle and an importer bundle in a well-defined way. In the OSGi framework, bundles are the only entities for deploying Java-based applications.\n\nA bundle is deployed as a Java ARchive (JAR) file. JAR files are used to store applications and their resources in a standard ZIP-based file format. This format is defined by [9] Zip File Format. Bundles normally share the Java Archive extension of .jar. However, there is a special MIME type reserved for OSGi bundles that can be used to distinguish bundles from normal JAR files. This MIME type is:\n\napplication/vnd.osgi.bundle\n\nThe type is defined in [15] OSGi IANA Mime Type.\n\nA bundle is a JAR file that:\n\nContains the resources necessary to provide some functionality. These resources may be class files for the Java programming language, as well as other data such as HTML files, help files, icons, and so on. A bundle JAR file can also embed additional JAR files that are available as resources and classes. This is however not recursive.\n\nContains a manifest file describing the contents of the JAR file and providing information about the bundle. This file uses headers to specify information that the Framework needs to install correctly and activate a bundle. For example, it states dependencies on other resources, such as Java packages, that must be available to the bundle before it can run.\n\nCan contain optional documentation in the OSGI-OPT directory of the JAR file or one of its sub-directories. Any information in this directory is optional. For example, the OSGI-OPT directory is useful to store the source code of a bundle. Management systems may remove this information to save storage space in the OSGi framework.\n\nCan be a multi-release JAR. See Multi-release JAR.\n\nOnce a bundle is resolved, its functionality is provided to other bundles installed in the OSGi framework.\n\n3.2.1 Bundle Manifest Headers\n\nA bundle can carry descriptive information about itself in the manifest file that is contained in its JAR file under the name of META-INF/MANIFEST.MF.\n\nThe Framework defines OSGi manifest headers such as Export-Package and Bundle-ClassPath, which bundle developers use to supply descriptive information about a bundle. Manifest headers must strictly follow the rules for manifest headers as defined in [10] Manifest Format.\n\nA Framework implementation must:\n\nProcess the main section of the manifest. Individual sections of the manifest are only used during bundle signature verification.\n\nIgnore unrecognized manifest headers. The bundle developer can define additional manifest headers as needed.\n\nIgnore unknown attributes and directives.\n\nAll specified manifest headers are listed in the following sections. All headers are optional, unless specifically indicated.\n\n3.2.1.1 Bundle-ActivationPolicy: lazy\n\nThe Bundle-ActivationPolicy specifies how the framework should activate the bundle once started. See Activation Policies.\n\n3.2.1.2 Bundle-Activator: com.acme.fw.Activator\n\nThe Bundle-Activator header specifies the name of the class used to start and stop the bundle. See Starting Bundles.\n\n3.2.1.3 Bundle-Category: osgi, test, nursery\n\nThe Bundle-Category header holds a comma-separated list of category names.\n\n3.2.1.4 Bundle-ClassPath: /jar/http.jar,.\n\nThe Bundle-ClassPath header defines a comma-separated list of JAR file path names or directories (inside the bundle) containing classes and resources. The full stop ('.' \\u002E) specifies the root directory of the bundle's JAR. The full stop is also the default. See Bundle Class Path.\n\n3.2.1.5 Bundle-ContactAddress: 2400 Oswego Road, Austin, TX 74563\n\nThe Bundle-ContactAddress header provides the contact address of the vendor.\n\n3.2.1.6 Bundle-Copyright: OSGi (c) 2002\n\nThe Bundle-Copyright header contains the copyright specification for this bundle.\n\n3.2.1.7 Bundle-Description: Network Firewall\n\nThe Bundle-Description header defines a short description of this bundle.\n\n3.2.1.8 Bundle-Developers: pkriens; [email protected]; name=\"Peter Kriens\"; organization=\"OSGi Alliance\"\n\nThe Bundle-Developers header provides an optional machine readable form of information about the developers of the bundle. This header is purely informational and must not be processed by the OSGi Framework.\n\nThe syntax for this header is as follows:\n\nBundle-Developers ::= developer ( ',' developer ) * developer ::= identifier ( ';' developer-attr ) * identifier ::= argument developer-attr ::= email | name | organization | organization-url | roles | timezone email ::= 'email' '=' <email> name ::= 'name' '=' argument organization ::= 'organization' '=' argument organization-url ::= 'organizationUrl' '=' <url> roles ::= 'roles' '=' argument timezone ::= 'timezone' '=' argument\n\nThis header has the following attributes:\n\nemail - (optional) The email address of the developer.\n\nname - (optional) The name of the developer.\n\norganization - (optional) The name of the organization of the developer.\n\norganization-url - (optional) The URL for the organization of the developer.\n\nroles - (optional) The roles of the developer. This is a comma separated list of role names.\n\ntimezone - (optional) The time zone of where the developer resides. The time zone can be an id such as America/New_York or a numerical offset in hours from UTC.\n\nSee [26] Maven POM Reference, Developers for more information. Tools can use the information in this header for POM generation.\n\n3.2.1.9 Bundle-DocURL: http://www.example.com/Firewall/doc\n\nThe Bundle-DocURL headers must contain a URL pointing to documentation about this bundle.\n\n3.2.1.10 Bundle-Icon: /icons/acme-logo.png;size=64\n\nThe optional Bundle-Icon header provides a list of URLs to icons representing this bundle in different sizes. The following attribute is permitted:\n\nsize - (integer) Specifies the size of the icon in pixels horizontal. It is recommended to always include a 64x64 icon.\n\nThe URLs are interpreted as relative to the bundle. That is, if a URL with a scheme is provided, then this is taken as an absolute URL. Otherwise, the path points to an entry in the JAR file, taking any attached fragments into account. Implementations that want to use this header should at least support the Portable Network Graphics (PNG) format, see [18] Portable Network Graphics (PNG) Specification (Second Edition).\n\n3.2.1.11 Bundle-License: Apache-2.0; link=\"http://opensource.org/licenses/apache2.0.php\"\n\nThe Bundle-License header provides an optional machine readable form of license information. The purpose of this header is to automate some of the license processing required by many organizations like for example license acceptance before a bundle is used. The header is structured to provide the use of unique license naming to merge acceptance requests, as well as links to human readable information about the included licenses. This header is purely informational for management agents and must not be processed by the OSGi Framework.\n\nThe syntax for this header is as follows:\n\nBundle-License ::= '<<EXTERNAL>>' | ( license ( ',' license ) * ) license ::= license-identifier ( ';' license-attr ) * license-attr ::= description | link description ::= 'description' '=' string link ::= 'link' '=' <url>\n\nThis header has the following attributes:\n\nlicense-identifier - Provides a globally unique identifier for this license, preferably world wide, but it should at least be unique with respect to the other clauses. The magic identifier <<EXTERNAL>> is used to indicate that this artifact does not specify any license information but that licensing information is provided in some other way. This is also the default value of this header.\n\nThis identifier should be one of the identifiers defined by [25] Software Package Data Exchange (SPDX) License List. Clients of this bundle can assume that licenses with the same identifier refer to the same license. This can for example be used to minimize the click through licenses.\n\nAlternatively, the identifier can be the canonical URL of the license, it must not be localized by the translator. This URL does not have to exist but must not be used for later versions of the license. It is recommended to use URLs from [19] Open Source Initiative. Other licenses should use the following structure, but this is not mandated:\n\nhttp://<domain-name>/licenses/ <license-name>-<version>.<extension>\n\ndescription - (optional) Provide the description of the license. This is a short description that is usable in a list box on a UI to select more information about the license.\n\nlink - (optional) Provide a URL to a page that defines or explains the license. If this link is absent, the name field is used for this purpose. The URL is relative to the root of the bundle. That is, it is possible to refer to a file inside the bundle.\n\nIf the Bundle-License statement is absent, then this does not mean that the bundle is not licensed. Licensing could be handled outside the bundle and the <<EXTERNAL>> form should be assumed. This header is informational and may not have any legal bearing. Consult a lawyer before using this header to automate licensing processing.\n\n3.2.1.12 Bundle-Localization: OSGI-INF/l10n/bundle\n\nThe Bundle-Localization header contains the location in the bundle where localization files can be found. The default value is OSGI-INF/l10n/bundle. Translations are by default therefore OSGI-INF/l10n/bundle_de.properties, OSGI-INF/l10n/bundle_nl.properties, etc. See Manifest Localization.\n\n3.2.1.13 Bundle-ManifestVersion: 2\n\nThe Bundle-ManifestVersion header defines that the bundle follows the rules of this specification. The Bundle-ManifestVersion header determines whether the bundle follows the rules of this specification. It is 1 (the default) for Release 3 Bundles, 2 for Release 4 and later. Future version of the OSGi framework can define higher numbers for this header.\n\n3.2.1.14 Bundle-Name: Firewall\n\nThe Bundle-Name header defines a readable name for this bundle. This should be a short, human-readable name that can contain spaces.\n\n3.2.1.15 Bundle-NativeCode: /lib/http.DLL; osname = QNX; osversion = 3.1\n\nThe Bundle-NativeCode header contains a specification of native code libraries contained in this bundle. See Loading Native Code Libraries.\n\n3.2.1.16 Bundle-RequiredExecutionEnvironment: CDC-1.0/Foundation-1.0\n\nThe Bundle-RequiredExecutionEnvironment contains a comma-separated list of execution environments that must be present on the OSGi framework. See Execution Environment. This header is deprecated.\n\n3.2.1.17 Bundle-SCM: url=https://github.com/bndtools/bnd, connection=scm:git:https://github.com/bndtools/bnd.git, developerConnection=scm:git:[email protected]:bndtools/bnd.git\n\nThe Bundle-SCM header provides an optional machine readable form of information about the source code of the bundle. This header is purely informational and must not be processed by the OSGi Framework.\n\nThe syntax for this header is as follows:\n\nBundle-SCM ::= scm-attr ( ',' scm-attr ) * scm-attr ::= url | connection | developer-connection | tag url ::= 'url' '=' <url> connection ::= 'connection' '=' <uri> developer-connection ::= 'developerConnection' '=' <uri> tag ::= 'tag' '=' argument\n\nThis header has the following attributes:\n\nurl - (optional) The URL to browse the source code repository.\n\nconnection - (optional) The scm: URI for read access to the source code repository.\n\ndeveloper-connection - (optional) The scm: URI for write access to the source code repository.\n\ntag - (optional) The tag within the source code repository.\n\nSee [27] Maven POM Reference, SCM for more information. Tools can use the information in this header for POM generation.\n\n3.2.1.18 Bundle-SymbolicName: com.acme.daffy\n\nThe Bundle-SymbolicName header specifies a non-localizable name for this bundle. The bundle symbolic name together with a version must identify a unique bundle though it can be installed multiple times in a framework. The bundle symbolic name should be based on the reverse domain name convention, see Bundle-SymbolicName. This header must be set.\n\n3.2.1.19 Bundle-UpdateLocation: http://www.acme.com/Firewall/bundle.jar\n\nThe Bundle-UpdateLocation header specifies a URL where an update for this bundle should come from. If the bundle is updated, this location should be used, if present, to retrieve the updated JAR file.\n\n3.2.1.20 Bundle-Vendor: OSGi Alliance\n\nThe Bundle-Vendor header contains a human-readable description of the bundle vendor.\n\n3.2.1.21 Bundle-Version: 1.1\n\nThe Bundle-Version header specifies the version of this bundle. See Version. The default value is 0.0.0\n\n3.2.1.22 DynamicImport-Package: com.acme.plugin.*\n\nThe DynamicImport-Package header contains a comma-separated list of package names that should be dynamically imported when needed. See Dynamic Import Package.\n\n3.2.1.23 Export-Package: org.osgi.util.tracker;version=1.3\n\nThe Export-Package header contains a declaration of exported packages. See Export-Package.\n\n3.2.1.24 Export-Service: org.osgi.service.log.LogService\n\nDeprecated.\n\n3.2.1.25 Fragment-Host: org.eclipse.swt; bundle-version=\"[3.0.0,4.0.0)\"\n\nThe Fragment-Host header defines the host bundles for this fragment. See Fragment-Host\n\n3.2.1.26 Import-Package: org.osgi.util.tracker,org.osgi.service.io;version=1.4\n\nThe Import-Package header declares the imported packages for this bundle. See Import-Package.\n\n3.2.1.27 Import-Service: org.osgi.service.log.LogService\n\nDeprecated\n\n3.2.1.28 Provide-Capability: com.acme.dict; from=nl; to=de; version:Version=1.2\n\nSpecifies that a bundle provides a set of Capabilities, see Dependencies.\n\n3.2.1.29 Require-Bundle: com.acme.chess\n\nThe Require-Bundle header specifies that all exported packages from another bundle must be imported, effectively requiring the public interface of another bundle. See Require-Bundle\n\n3.2.1.30 Require-Capability: osgi.ee; filter:=\"(&(osgi.ee=AcmeMin)(version=1.1))\"\n\nSpecifies that a bundle requires other bundles to provide a capability, see Dependencies.\n\n3.2.2 Custom Headers\n\nThe manifest is an excellent place to provide metadata belonging to a bundle. This is true for the OSGi Alliance but it is also valid for other organizations. For historic reasons, the OSGi Alliance claims the default namespace, specifically headers that indicate OSGi related matters like names that contain Bundle, Import, Export, etc. Organizations that want to use headers that do not clash with OSGi Alliance defined names or bundle header names from other organizations should prefix custom headers with x-, for example x-LazyStart.\n\nOrganizations external to the OSGi Alliance can request header names in the OSGi namespace. The OSGi Alliance maintains a registry of such names at [16] OSGi Header Registry.\n\nThe Header annotation can be used on a class or package to specify a header for a bundle. This annotation can be processed by bundle assembly tools to generate the specified header information in the bundle's manifest.\n\n3.2.3 Header Value Syntax\n\nEach Manifest header has its own syntax. In all descriptions, the syntax is defined with [11] W3C EBNF. These following sections define a number of commonly used terminals.\n\n3.2.4 Common Header Syntax\n\nMany Manifest header values share a common syntax. This syntax consists of:\n\nheader ::= clause ( ',' clause ) * clause ::= path ( ';' path ) * ( ';' parameter ) * // See 1.3.2\n\nA parameter can be either a directive or an attribute. A directive is an instruction that has some implied semantics for the Framework. An attribute is used for matching and comparison purposes.\n\n3.2.5 Version\n\nVersion specifications are used in several places. A version has the following grammar:\n\nversion ::= major( '.' minor ( '.' micro ( '.' qualifier )? )? )? major ::= number // See 1.3.2 minor ::= number micro ::= number qualifier ::= ( alphanum | '_' | '-' )+\n\nA version must not contain any white space. The default value for a version is 0.0.0.\n\nVersions are supported in the API with the Version class.\n\nThe Version annotation can be used in package-info.java source files to document the version of a package. This annotation can be processed by bundle assembly tools when generating the version information for a bundle's Export-Package manifest header.\n\n3.2.6 Version Ranges\n\nA version range describes a range of versions using a mathematical interval notation. See [12] Mathematical Convention for Interval Notation. The syntax of a version range is:\n\nversion-range ::= interval | atleast interval ::= ( '[' | '(' ) floor ',' ceiling ( ']' | ')' ) atleast ::= version floor ::= version ceiling ::= version\n\nIf a version range is specified as a single version, it must be interpreted as the range [version,∞). The default for a non-specified version range is 0, which maps to [0.0.0,∞).\n\nNote that the use of a comma in the version range requires it to be enclosed in double quotes. For example:\n\nImport-Package: com.acme.foo;version=\"[1.23,2)\", « com.acme.bar;version=\"[4.0, 5.0)\"\n\nIn the following table, for each specified range in the left-hand column, a version x is considered to be a member of the range if the predicate in the right-hand column is true.\n\nTable 3.1 Examples of version ranges\n\nExample Predicate\n\nVersion Ranges are supported in the API with the VersionRange class.\n\n3.2.7 Filter Syntax\n\nThe OSGi specifications use filter expressions extensively. Filter expressions allow for a concise description of a constraint. The syntax of a filter string is based upon the string representation of LDAP search filters as defined in [5] A String Representation of LDAP Search Filters. It should be noted that RFC 2254: A String Representation of LDAP Search Filters supersedes RFC 1960, but only adds extensible matching and is not applicable to this OSGi Framework API.\n\nThe string representation of an LDAP search filter uses a prefix format and is defined by the following grammar:\n\nfilter ::= '(' filter-comp ')' filter-comp ::= and | or | not | operation and ::= '&' filter-list or ::= '|' filter-list not ::= '!' filter filter-list ::= filter | filter filter-list operation ::= simple | present | substring simple ::= attr filter-type value filter-type ::= equal | approx | greater-eq | less-eq equal ::= '=' approx ::= '~=' greater-eq ::= '>=' less-eq ::= '<=' present ::= attr '=*' substring ::= attr '=' initial any final initial ::= () | value any ::= '*' star-value star-value ::= () | value '*' star-value final ::= () | value value ::= <see text> attr ::= <see text>\n\nattr is a string representing an attribute key or name. Attribute names are not case sensitive; that is, cn and CN both refer to the same attribute. attr must not contain the characters '=', '>', '<', '~', '(' or ')'. attr may contain embedded spaces but leading and trailing spaces must be ignored.\n\nvalue is a string representing the value, or part of one, which will be compared against a value in the filtered properties.\n\nIf value must contain one of the characters reverse solidus ('\\' \\u005C), asterisk ('*' \\u002A), parentheses open ('(' \\u0028) or parentheses close (')' \\u0029), then these characters should be preceded with the reverse solidus ('\\' \\u005C) character. Spaces are significant in value. Space characters are defined by Character.isWhiteSpace().\n\nAlthough both the substring and present productions can produce the attr=* construct, this construct is used only to denote a presence filter.\n\nThe substring production only works for attributes that are of type String, Collection of String or String[]. In all other cases the result must be false.\n\nThe evaluation of the approximate match ('~=') filter type is implementation specific but should at least ignore case and white space differences. Codes such as Soundex or other smart closeness comparisons could be used.\n\nValues specified in the filter are compared to values in the properties against which the filter is evaluated. The comparison of these values is not straightforward. Strings compare differently than numbers, and it is also possible for a property to have multiple values.\n\nProperty keys are case insensitive. The object class of the property's value defines the comparison type. The properties values should be of the following types:\n\nFigure 3.1 Primary Property Types\n\ntype ::= scalar | collection | array scalar ::= String | Integer | Long | Float | Double | Byte | Short | Character | Boolean primitive ::= int | long | float | double | byte | short | char | boolean array ::= <Array of primitive> | <Array of scalar> collection ::= <Collection of scalar>\n\nThe following rules apply for comparison:\n\nString - Use String comparison\n\nInteger, Long, Float, Double, Byte, Short, Character objects and primitives - Use numerical comparison. The value should be trimmed of any extraneous white space before the comparison.\n\nBoolean objects - Use comparison defined by Boolean.valueOf(value).booleanValue(). The value should be trimmed of any extraneous white space before this conversion is applied.\n\nArray or Collection elements - Comparison is determined by the object type of the element\n\nArray and Collection elements may be a mix of scalar types. Array and Collection elements may also be null. If the type of the property value is not one of the above types, then it could be possible to create an instance of the above type. The following conversions must be tried in the given order:\n\nA public static method on the required type called valueOf that returns an instance of the given type and takes a single String argument.\n\nA public constructor taking a single String argument.\n\nIf one of these methods is available then the Framework must construct a temporary object by passing the value as the String argument. If the constructor/function is not directly accessible then the invocation should use the setAccessible method to make it accessible.\n\nThe resulting object must be used to compare with the property value according to the following comparison rules:\n\nComparable objects - Comparison through the Comparable interface\n\nOther objects - Equality comparison\n\nIf none of the above comparison rules apply, then the result of the comparison is false.\n\nA filter matches a property with multiple values if it matches at least one of those values. For example:\n\nDictionary dict = new Hashtable(); dict.put( \"cn\", new String[] { \"a\", \"b\", \"c\" } );\n\nThe dict will match against a filter with (cn=a) as well as (cn=b).\n\nService properties are often defined to take a type, a collection of that type, or an array of that type. In those cases, a simple + will be suffixed to the type name. For example String+, indicates that a String, a String[], and a Collection<String> are all valid forms.\n\nFilters are supported in the API with the Filter type. Filters can be created with the FrameworkUtil.createFilter(String) method or the BundleContext.createFilter(String) method.\n\n3.2.8 Multi-release JAR\n\nA bundle JAR file can be a multi-release JAR. See [28] Multi-release JAR File. When a bundle is a multi-release JAR, that is, the manifest contains\n\nMulti-Release: true\n\nthen the Framework must look for a supplemental manifest file, OSGI-INF/MANIFEST.MF, in the versioned directories. For example:\n\nMETA-INF/versions/9/OSGI-INF/MANIFEST.MF\n\nThe Framework must first look in the versioned directory for the major version of the current Java platform and then prior versioned directories in descending order. The first supplemental manifest file found must be used and the Framework must replace the values of the following manifest headers in the manifest with the values of these headers, if present, in the supplemental manifest file.\n\nImport-Package\n\nRequire-Capability\n\nAny other headers in the supplemental manifest file must be ignored.\n\nThe Framework APIs which provide access to the bundle metadata, such as getHeaders() and BundleRevision and BundleWiring, must present the supplemented manifest information. That is, the main manifest with the replacement values from a supplemental manifest, if any, for the running Java platform version.\n\nBoth fragment bundles as well as non-fragment bundles can be multi-release JARs.\n\nSupport for multi-release JARs must only be active on Java 9 and later. On Java 8 and earlier, the JAR must be treated as a non-multi-release JAR.\n\n3.3 Dependencies\n\nOSGi dependency handling is based on a very general model that describes the dependency relationships. This model consists of a small number of primitive concepts:\n\nEnvironment - A container or framework that installs Resources.\n\nResource - An abstraction for an artifact that needs to become installed in some way to provide its intended function. A Bundle is modeled by a Resource but for example a display or secure USB key store can also be Resources.\n\nNamespace - Defines what it means for the Environment when a requirement and capability match in a given Namespace.\n\nCapability - Describing a feature or function of the Resource when installed in the Environment. A capability has attributes and directives.\n\nRequirement - An assertion on the availability of a capability in the Environment. A requirement has attributes and directives. The filter directive contains the filter to assert the attributes of the capability in the same Namespace.\n\nThe relations between these entities are depicted in Figure 3.2.\n\nFigure 3.2 Core Requirement/Capability model\n\nA Resource in general has dependencies on other Resources or can satisfy other Resource's dependencies. Dependency types can vary wildly, a Bundle can require packages from another Bundle (Import-Package), or a Fragment needs a host Bundle (Fragment-Host), or a Bundle requires access to a high resolution display. The OSGi Core specification demonstrates that it is possible to describe these varying types of dependencies with dedicated headers, optimized for each case. However, this model requires that every type of dependency will go through a specification process, limiting the usefulness for parties not participating in this process. Therefore, this specification provides a generic dependency model based on Namespaces. A Namespace is the type of a dependency. For example, the osgi.wiring.package Namespace defines the semantics for Import-Package and Export-Package headers by specifying a number of attributes and directives. Attributes are used for matching and directives provide information about the semantics of the Namespace. For example, in the case of the osgi.wiring.host Namespace (Fragments) the capability's attributes are:\n\nosgi.wiring.host - (String) The host's name.\n\nbundle-version - (Version) The host's version.\n\n* - Any other attributes are allowed.\n\nThe OSGi Framework Namespaces are defined in classes, see Framework Namespaces Specification.\n\nThe purpose of a Namespace is to create an attribute/directive based language that describes a dependency in a generic way unrelated to the specific dependency type. A number of Namespaces have been defined by the OSGi Alliance in this and other specifications. OSGi namespaces start with the reserved osgi. prefix. For example, the osgi.ee namespace defines a capability for specifying an execution environment. A Namespace can also be defined by other organizations and individuals. To minimize name clashes it is recommended to use the reverse domain name rule used for packages and bundle symbolic names. It is also recommended to register these Namespaces with the OSGi Alliance, see [17] OSGi Namespace Registry to prevent clashes.\n\nGiven a Namespace, it is possible to declare a capability of that Namespace. A capability provides the values for the attributes and directives defined in the Namespace. For example, it is possible to translate the Export-Package header to a capability in the osgi.wiring package Namespace.\n\nGiven a capability, it is possible to specify a requirement. A requirement has a filter that can match the attributes of the capability, if so, the requirement is satisfied. Requirements are always associated with a given Namespace, like the capability, and can therefore only be satisfied by Capabilities in the same Namespace. A requirement is satisfied when its filter, as specified with the filter directive, matches a capability's attributes. The filter language specification can be found in Filter Syntax. A requirement can be mandatory or optional, as set with its resolution directive. A requirement can have single or multiple cardinality, indicating it requires at least one or more Capabilities.\n\nA Resource that declares requirements can only provide its intended functionality when its mandatory requirements are satisfied by one or more Capabilities, which in general means they come from other Resources. A Resource that has all its mandatory requirements satisfied is said to be resolved and must provide the functionality described by its Capabilities. A capability can only satisfy a requirement if its Resource is resolved.\n\nThe process of matching up requirements to capabilities is called resolving. In this process, the resolver must create Wires that link requirements to Capabilities. Both the Wire and the requirement/ Capability have a reference to a Resource. In certain cases the requirement/ capability can be declared in one Resource but wired from another Resource. Therefore, a requirement/ capability can have a declared Resource, which is the Resource that declares it. However, when a Resource is wired the Wire has a provider or requirer Resource which can differ from the corresponding declared Resource. When the declared Resource differs from the provider/requirer it is called hosting. This separation is caused by Fragments; with Fragments some requirements and Capabilities are hosted and others remain part of the Fragment.\n\nOnly requirements that are effective must be wired. Each requirement is intended for a certain state of the system. For example, the OSGi Framework only resolves requirements when the requirement has the effective directive set to resolve.\n\nOnce a set of Resources are resolved the Environment, for example the OSGi Framework for bundles, creates a Wiring per Resource to hold the resolved state. This state includes the Wires as well as all Capabilities and requirements, regardless if they are wired or not.\n\nThe Wires between a requirement and a capability must be created according to the semantics implied by their Namespace. The Wires coming out of a resolve operation can be used during run time as specified in their Namespace. For example, the osgi.wiring.* Namespaces are used to control the Class Loading, see Bundle Wiring API Specification. However, they can also serve other purposes as outlined by their Namespace. For example, a Wire could specify a Dependency Injection source and target.\n\nInterfaces for the generic model are defined in Resource API Specification. The Bundle Wiring API Specification chapter describes the Wiring API that is based on this generic package. The generic API is intended for other specifications that want to be compatible with the generic OSGi Core framework's Capability /Requirement model.\n\n3.3.1 Bundles\n\nAll bundles depend on one or more external entities and this is expressed as requirements and Capabilities. Once a bundle is resolved, it assumes that those dependencies are satisfied. The Require-Capability and Provide-Capability headers are manifest headers that declare generic requirements and Capabilities in any Namespace. However, a number of manifest headers in the OSGi specifications are actually requirements on Capabilities specified by other OSGi manifest headers. For example, an Import-Package clause is a requirement on the capability specified by an Export-Package clause. The attributes on an Import-Package clause are treated as assertions on the attributes of the corresponding Export-Package clause. This specification therefore contains a number of Namespaces for these OSGi manifest headers: osgi.wiring.bundle, osgi.wiring.package, and osgi.wiring.host. These namespaces influence the resolver and define the class loading process. For example, a Require-Bundle clause is a requirement that ensures that the exported packages of the required bundle are available to the requirer's class loader.\n\nThe OSGi resolving process is described in Resolving Process. The diagramming technique of the Requirement/Capability model is depicted in Figure 3.3, the details of the wiring are further explained in Bundle Wiring API Specification.\n\nFigure 3.3 Requirements and Capabilities and their Wiring\n\n3.3.2 Example Use Case\n\nA bundle has Windows 7 specific Java code and requires a display that has a resolution of at least 1000x1000 pixels. It also relies on a bundle providing an IP-number-to-location table.\n\nThese dependencies on the environment and another bundle can be expressed with the requirement header in the bundle as follows:\n\nRequire-Capability: com.microsoft; filter:=\"(&(api=win32)(version=7))\", com.acme.display; filter:=\"(&(width>=1000)(height>=1000))\", com.acme.ip2loc\n\nEach clause lives in a namespace, for example com.microsoft. A namespace defines the semantics of the attributes as well as optional rules.\n\nThe deployer of the environment sets the following launching property when starting the framework:\n\norg.osgi.framework.system.capabilities.extra= « com.acme.display; width:Long=1920; height:Long=1080; interlace=p, « com.microsoft; edition=home; version:Version=7; api=win32\n\nThe framework will be able to satisfy the display requirement but it cannot satisfy the ip2loc table requirement. The deployer can then install the bundle with the ip2loc table. This bundle specifies the following header:\n\nProvide-Capability: com.acme.ip2loc; version:Version=1.2\n\nAfter installing and resolving this bundle, the framework can resolve the original bundle because there is now a provider of the ip2loc table.\n\n3.3.3 Bundle Capabilities\n\nA generic capability for a Bundle is defined with the Provide-Capability header. This header has the following syntax:\n\nProvide-Capability ::= capability (',' capability )* capability ::= name-space ( ';' directive | typed-attr )* name-space ::= symbolic-name typed-attr ::= extended ( ':' type )? '=' argument type ::= scalar | list scalar ::= 'String' | 'Version' | 'Long' | 'Double' list ::= 'List' ( '<' scalar '>' )?\n\nThe Capability annotation can be used on a class or package to specify a capability to be provided by the bundle. This annotation can be processed by bundle assembly tools to add the capability to the Provide-Capability header in the bundle's manifest.\n\nThe header has the following directives architected:\n\neffective - (resolve) Specifies the time a capability is available, either resolve (default) or another name. The OSGi framework resolver only considers Capabilities without an effective directive or effective:=resolve. Capabilities with other values for the effective directive can be considered by an external agent.\n\nuses - The uses directive lists package names that are used by this capability. This information is intended to be used for uses constraints, see Package Constraints.\n\nNamespaces can define additional directives and attributes.\n\n3.3.4 Bundle Capability Attributes\n\nAttributes can be typed. Typing is important because it defines how attributes compare. Comparing two versions as strings does not provide the proper comparison semantics for versions. In similar vein, lexicographical ordering is different than numeric ordering.\n\nTypes are specified between the attribute name and the equal sign ('=' \\u003D), the separator is a colon (':' \\u003A). For example:, for a Long:\n\nattr:Long=24\n\nIf no type is specified, the String type is assumed.\n\nThe parsing rules of the corresponding type's String constructor are then used to create a new instance that is placed in the capability's map. Numeric types must trim white space around the value, for other types spaces around the argument are not ignored, however, white space is skipped by the manifest parsing rules. That is:\n\nattr:Long= 23 , //ok attr:Version=\" 23 \", // error attr:Long=\" 23 \", // ok, because nummeric\n\nMulti-valued attributes can be constructed with the List type. The List type can specify a scalar type for the list elements. If no element type is specified, String is assumed. Parsing of the corresponding argument list must be done according to the following rules:\n\nElement values in the list are separated by commas (',' \\u002C).\n\nWhite space around an element value must be trimmed for non-String element types.\n\nCommas or reverse solidi ('\\' \\u005C) that are part of an element value must be escaped by prefixing them with a reverse solidus. In practice, this requires escaping with two reverse solidi because a reverse solidus must already be escaped in strings.\n\nThe whole argument must be surrounded by quotes because the comma is a significant token in the manifest grammar.\n\nThe version attribute requires the Version type to be specified to be compared as a Version rather than as a String:\n\nversion:Version=1.23\n\nFor example:\n\nProvide-Capability: « com.acme.dictionary; from:String=nl; to=de; version:Version=3.4, « com.acme.dictionary; from:String=de; to=nl; version:Version=4.1, « com.acme.ip2location;country:List=\"nl,be,fr,uk\";version:Version=1.3, « com.acme.seps; tokens:List<String>=\"\\\\,,;,\\\\\\\"\"\n\n3.3.5 System Bundle Capabilities\n\nCapabilities can also be provided by the system bundle by specifying the following launch properties:\n\norg.osgi.framework.system.capabilities org.osgi.framework.system.capabilities.extra\n\nThe format for these system properties is identical to the Provide-Capability header. A framework must parse these properties and use them in the resolving process as if provided by the system bundle.\n\nThere are two properties so that the framework can specify its default Capabilities in org.osgi.framework.system.capabilities while the deployer can specify specific deployment Capabilities in the org.osgi.framework.system.capabilities.extra system property. Frameworks can often deduce many Capabilities from their environment.\n\nThe following is an example capability header for the system bundle as defined by the deployer:\n\nmap.put(\"org.osgi.framework.system.capabilities.extra\", \"com.acme.screen; width:Long=640; height:Long=480; card=GeForce\");\n\n3.3.6 Bundle Requirements\n\nThe Bundle's Require-Capability header has the following grammar:\n\nRequire-Capability ::= requirement ( ',' requirement )* requirement ::= name-space ( ';' directive | typed-attr )*\n\nRequirements have attributes that can be set with the Require-Capability header. The purpose of these attributes are to provide further information about the requirement; they are not assertions as they are in the Import-Package, Require-Bundle, and Fragment-Host headers. The attributes of these headers are mapped to the filter directive in their corresponding namespaces.\n\nThe Requirement annotation can be used on a class or package to specify a capability to be required by the bundle. This annotation can be processed by bundle assembly tools to add the requirement to the Require-Capability header in the bundle's manifest.\n\nThe following directives are architected for the Require-Capability header:\n\neffective - (resolve) Specifies the time a requirement is considered, either resolve (default) or another name. The OSGi framework resolver only considers requirements without an effective directive or effective:=resolve. Other requirements can be considered by an external agent. Additional names for the effective directive should be registered with the OSGi Alliance.\n\nresolution - (mandatory|optional) A mandatory requirement forbids the bundle to resolve when the requirement is not satisfied; an optional requirement allows a bundle to resolve even if the requirement is not satisfied. No wirings are created when this requirement cannot be resolved, this can result in Class Not Found Exceptions when the bundle attempts to use a package that was not resolved because it was optional. The default is mandatory.\n\nfilter - (Filter) A filter expression that is asserted on the Capabilities belonging to the given namespace. The matching of the filter against the capability is done on one capability at a time. A filter like (&(a=1)(b=2)) matches only a capability that specifies both attributes at the required value, not two capabilities that each specify one of the attributes correctly. A filter is optional, if no filter directive is specified the requirement always matches. The attribute names in the filter expression are used to locate capability attributes in a case sensitive manner.\n\ncardinality - (single|multiple) Indicates if the requirement can be wired a single time or multiple times. The default is single.\n\nAdditional directives are ignored during resolving. Attributes on the requirement clause are also ignored.\n\n3.4 Execution Environment\n\nThe Java environment provides all packages in the java.* namespace. Prior to Java SE 9, this namespace was not well defined and could be different for different runtime environments. For example, Java SE 5 is not equal to Java SE 7 and an Android environment has substantial differences to a Java SE environment. However, Java SE 6 is backward compatible for Java SE 5, Java SE 1.4, Java SE 1.3 and Java SE 1.2. That is, applications written for Java SE 1.3 must run unchanged on a Java SE 5 environment.\n\nThese differences and backward compatibilities can not be captured using versions because they are variations. For example, [22] Google Android is a variation of a Java SE 5 environment, as is [23] Google App Engine and [24] Google Web Toolkit. All these variations have a different set of packages, types, and methods in the java.* namespace.\n\nStarting in Java SE 9, the platform has been modularized and its packages organized into a set of modules. Depending upon how the platform is configured for execution, some modules and their contained packages may not be present at runtime. However, Java SE 9 provides a standard way to interrogate the Java platform for the packages currently available at runtime. Therefore, the Framework must set the org.osgi.framework.system.packages launching property, see Launching Properties, to the list of Java platform packages currently available at runtime.\n\nFor Java platform versions prior to Java SE 9, the Framework must also set the org.osgi.framework.system.packages launching property to the list of Java platform packages generally known to be available at runtime. Since there is no standard way to interrogate the Java platform for the packages currently available at runtime, a Framework implementation may use a predefined list of packages for the Java platform version.\n\nIn additional to specifying the version of the execution environment via an osgi.ee requirement, see osgi.ee Namespace, a Bundle may also import java.* packages using the Import-Package header. Imports of java.* packages by a bundle will be used during the resolution process, see Resolving Process, to ensure the bundle has visibility to the requested packages by wiring the bundle's import of a java.* package to the export of the java.* package by the Framework's system bundle. However, a bundle always loads classes in java.* packages via parent delegation. See Parent Delegation. Therefore, a bundle is not required to import a java.* package to have visibility to the classes in the package, if the package is present in the current runtime. It only needs to import a java.* package to have the resolution process ensure the package is available from the execution environment. This can avoid a NoClassDefFoundError during execution of the bundle due to a missing java.* package required by the bundle.\n\n3.4.1 Bundle-RequiredExecutionEnvironment\n\nThe Bundle-RequiredExecutionEnvironment manifest header provides the same function as the osgi.ee Namespace. It allows a bundle to depend on the execution environment. This header is deprecated but must be fully supported by a compliant framework. Bundles should not mix these headers but use either an osgi.ee requirement or this header. If both are used, both constraints must be met to resolve.\n\nThe syntax of this header is a list of comma-separated names of execution environments.\n\nBundle-RequiredExecutionEnvironment ::= ee-name ( ',' ee-name )* ee-name ::= bree | <ee name> bree ::= token ( '-' version )? ( '/' token ( '-' version )? )?\n\nFor example:\n\nBundle-RequiredExecutionEnvironment: CDC-1.0/Foundation-1.0, « OSGi/Minimum-1.1\n\nIf a bundle includes this header in the manifest then the bundle must only use methods with signatures that are contained within a proper subset of all mentioned execution environments. Bundles should list all (known) execution environments on which it can run the bundle.\n\nA bundle can only resolve if the framework is running on a VM which implements one of the listed required execution environments. Frameworks should recognize that the current VM can implement multiple execution environments. For example, Java 6 is backward compatible with Java 5 and a bundle requiring the Java 6 execution environment must resolve on a Java 6 VM.\n\nThe Bundle-RequiredExecutionEnvironment header can not prevent a bundle from installing.\n\nThe org.osgi.framework.executionenvironment launching property defines the current execution environment with a comma separated list of execution environment names. If not set, the framework must provide an appropriate value. This property is also deprecated, its function is replaced with org.osgi.framework.system.capabilities[.extra].\n\nAn example:\n\norg.osgi.framework.executionenvironment = JavaSE-1.5, J2SE-1.4, JavaSE-1.4, JavaSE-1.3, OSGi/Minimum-1.1\n\nFrameworks must convert a Bundle-RequiredExecutionEnvironment header to a requirement in the osgi.ee namespace when used in the Wiring API, see Bundle Wiring API Specification. Since the header uses opaque names for the execution environments there is no guaranteed algorithm to map the ee-name to a Require-Capability header. However, the suggested names so far for popular execution environments do have a structure that can be used to create such a header, this pattern was reflected in the bree term. The structure of the bree term for the existing recommendations is:\n\nn1 ( '-' v )? ( '/' n2 ( '-' v )? )?\n\nFor example:\n\nCDC-1.0/Foundation-1.0 OSGi/Minimum-1.2 J2SE-1.4 JavaSE-1.4\n\nEach bree term that matches this pattern can thus be converted into an equivalent osgi.ee Require-Capability filter. First variable n1 must be replaced with JavaSE when it is J2SE since the Require-Capability header uses a single name for the Java Standard Edition. The filter directive can then be constructed from n1, v, and n2. If n2 is not defined or v is not defined then the parenthesized parts in which they participate are not used in the expansion.\n\nbree-filter ::= '(&(osgi.ee=' n1 ( '/' n2 )? ')' ( '(version=' v ')' )? ')'\n\nIf the bree term cannot be parsed into the given constituents then the filter must look like:\n\nfilter ::= '(osgi.ee=' <ee name> ')'\n\nSome examples:\n\nCDC-1.0/Foundation-1.0 (&(osgi.ee=CDC/Foundation)(version=1.0)) OSGi/Minimum-1.2 (&(osgi.ee=OSGi/Minimum)(version=1.2)) J2SE-1.4 (&(osgi.ee=JavaSE)(version=1.4)) JavaSE-1.6 (&(osgi.ee=JavaSE)(version=1.6)) AA/BB-1.7 (&(osgi.ee=AA/BB)(version=1.7)) V1-1.5/V2-1.6 (osgi.ee=V1-1.5/V2-1.6) MyEE-badVersion (osgi.ee=MyEE-badVersion)\n\nEach element of the Bundle-RequiredExecutionEnvironment is ORed together in the final osgi.ee requirement's filter directive. For example:\n\nBundle-RequiredExecutionEnvironment: CDC-1.0/Foundation-1.0, OSGi/Minimum-1.2, J2SE-1.4, JavaSE-1.6, AA/BB-1.7, V1-1.5/V2-1.6, MyEE-badVersion\n\nThis must be converted into the following Require-Capability:\n\nRequire-Capability:osgi.ee; filter:=\"(| (&(osgi.ee=CDC/Foundation)(version=1.0)) (&(osgi.ee=OSGi/Minimum)(version=1.2)) (&(osgi.ee=JavaSE)(version=1.4)) (&(osgi.ee=JavaSE)(version=1.6)) (&(osgi.ee=AA/BB)(version=1.7)) (osgi.ee=V1-1.5/V2-1.6) (osgi.ee=MyEE-badVersion) )\"\n\nEvery org.osgi.resource.Resource representing a Bundle which has a Bundle-RequiredExecutionEnvironment header must have the converted osgi.ee requirement in the list returned by getRequirements(String) for the osgi.ee namespace. In cases where the bundle already has a requirement for the osgi.ee namespace no merging is done, the bundle will simply have an additional osgi.ee requirement added.\n\n3.5 Class Loading Architecture\n\nMany bundles can share a single virtual machine (VM), see [1] Java Virtual Machine Specification. Within this VM, bundles can hide packages and classes from other bundles, as well as share packages with other bundles.\n\nThe key mechanism to hide and share packages is the Java class loader that loads classes from a sub-set of the bundle-space using well-defined rules. Each bundle has a single class loader. That class loader forms a class loading delegation network with other bundles as shown in Figure 3.4.\n\nFigure 3.4 Delegation model\n\nThe class loader can load classes and resources from:\n\nBoot class path - The boot class path contains the java.* packages and its implementation packages.\n\nFramework class path - The Framework usually has a separate class loader for the Framework implementation classes as well as key service interface classes.\n\nBundle Space - The bundle space consists of the JAR file that is associated with the bundle, plus any additional JAR that are closely tied to the bundle, like fragments, see Fragment Bundles.\n\nA class space is then all classes reachable from a given bundle's class loader. Thus, a class space for a given bundle can contain classes from:\n\nThe parent class loader (normally java.* packages from the boot class path)\n\nImported packages\n\nRequired bundles\n\nThe bundle's class path (private packages)\n\nAttached fragments\n\nA class space must be consistent, such that it never contains two classes with the same fully qualified name (to prevent Class Cast Exceptions). However, separate class spaces in an OSGi Platform may contain classes with the same fully qualified name. The modularization layer supports a model where multiple versions of the same class are loaded in the same VM.\n\nFigure 3.5 shows the class space for a Bundle A. The right top of Bundle A is not in the class space because it illustrates that sometimes packages inside a bundle are not accessible to the Bundle itself when an export is substituted.\n\nFigure 3.5 Class Space\n\nThe Framework therefore has a number of responsibilities related to class loading. Before a bundle is used, it must resolve the constraints that a set of bundles place on the sharing of packages. Then select the best possibilities to create a wiring. See Resolving Process for further information. The runtime aspects are described in Runtime Class Loading.\n\n3.5.1 Resolving\n\nThe Framework must resolve bundles. Resolving is the process where any external dependencies are satisfied and then importers are wired to exporters. Resolving is a process of satisfying constraints; constraints that are provided by the Dependencies section and constraints by the different manifest headers like Import/Export Package, Require-Bundle, and Fragment-Host. The resolving process must take place before any code from a bundle can be loaded or executed.\n\nA wire is an actual connection between an exporter and an importer, which are both bundles. A wire is associated with a number of constraints that are defined by its importer's and exporter's manifest headers. A valid wire is a wire that has satisfied all its constraints. Figure 3.6 depicts the class structure of the wiring model. Not all constraints result in a wire.\n\nFigure 3.6 Example class structure of wiring\n\n3.6 Resolving Metadata\n\nThe following sections define the manifest headers that provide the metadata for the resolver.\n\n3.6.1 Bundle-ManifestVersion\n\nA bundle manifest must express the version of the OSGi manifest header syntax in the Bundle-ManifestVersion header. Bundles exploiting this version of the Framework specification (or later) must specify this header. The syntax of this header is as follows:\n\nBundle-ManifestVersion ::= number //See 1.3.2\n\nThe Framework bundle manifest version must be '2'. Bundle manifests written to previous specifications' manifest syntax are taken to have a bundle manifest version of '1', although there is no way to express this in such manifests. Therefore, any other value than 2 for this header is invalid unless the Framework explicitly supports such a later version.\n\nOSGi Framework implementations should support bundle manifests without a Bundle-ManifestVersion header and assume Framework 1.2 compatibility at the appropriate places.\n\nVersion 2 bundle manifests must specify the bundle symbolic name. They need not specify the bundle version because the version header has a default value.\n\n3.6.2 Bundle-SymbolicName\n\nThe Bundle-SymbolicName manifest header is a mandatory header. The bundle symbolic name and bundle version identify a unique bundle. This does not always imply that this pair is unique in a framework, in certain cases the same bundle can be installed multiple times in the same framework, see Bundle Identifiers.\n\nA bundle gets its unique Bundle-SymbolicName from the developer. The Bundle-Name manifest header provides a human-readable name for a bundle and is therefore not replaced by this header.\n\nThe Bundle-SymbolicName manifest header must conform to the following syntax:\n\nBundle-SymbolicName ::= symbolic-name ( ';' parameter ) * // See 1.3.2\n\nThe framework must recognize the following directives for the Bundle-SymbolicName header:\n\nsingleton - Indicates that the bundle can only have a single version resolved in an environment. A value of true indicates that the bundle is a singleton bundle. The default value is false. The Framework must resolve at most one bundle when multiple versions of a singleton bundle with the same symbolic name are installed. Singleton bundles do not affect the resolution of non-singleton bundles with the same symbolic name.\n\nfragment-attachment - Defines how fragments are allowed to be attached, see the fragments in Fragment Bundles. The following values are valid for this directive:\n\nalways - (Default) Fragments can attach at any time while the host is resolved or during the process of resolving.\n\nnever - No fragments are allowed.\n\nresolve-time - Fragments must only be attached during resolving.\n\nmandatory - Provide a list of mandatory attributes. If these attributes are not specifically used in the requirement (Require-Bundle, Fragment-Host) then this bundle must not match. See Mandatory Attributes.\n\nThe header allows the use of arbitrary attributes that can be required by the Require-Bundle and Fragment-Host headers. The following attribute is predefined:\n\nbundle-version - The value of the Bundle-Version header or 0 if no such header is present. Explicitly setting this attribute is an error.\n\nFor example:\n\nBundle-SymbolicName: com.acme.foo;singleton:=true\n\n3.6.3 Bundle-Version\n\nBundle-Version is an optional header; the default value is 0.0.0.\n\nBundle-Version ::= version // See 3.2.5\n\nIf the minor or micro version components are not specified, they have a default value of 0. If the qualifier component is not specified, it has a default value of the empty string (\"\").\n\nVersions are comparable. Their comparison is done numerically and sequentially on the major, minor, and micro components and lastly using the String class compareTo method for the qualifier.\n\nA version is considered equal to another version if the major, minor, micro, and the qualifier components are equal (using String method compareTo).\n\nExample:\n\nBundle-Version: 22.3.58.build-345678\n\n3.6.4 Import-Package\n\nThe Import-Package header defines the constraints on the imports of shared packages. The syntax of the Import-Package header is:\n\nImport-Package ::= import ( ',' import )* import ::= package-names ( ';' parameter )* package-names ::= package-name ( ';' package-name )* // See 1.3.2\n\nThe header allows many packages to be imported. An import definition is the description of a single package for a bundle. The syntax permits multiple package names, separated by semi-colons, to be described in a short form.\n\nImport package directives are:\n\nresolution - Indicates that the packages must be resolved if the value is mandatory, which is the default. If mandatory packages cannot be resolved, then the bundle must fail to resolve. A value of optional indicates that the packages are optional. See Optional Packages.\n\nThe developer can specify arbitrary matching attributes. See Attribute Matching. The following arbitrary matching attributes are predefined:\n\nversion - A version-range to select the exporter's package version. The syntax must follow Version Ranges. For more information on version selection, see Semantic Versioning. If this attribute is not specified, it is assumed to be [0.0.0, ∞).\n\nspecification-version - This attribute is an alias of the version attribute only to ease migration from earlier versions. If the version attribute is present, the values must be equal.\n\nbundle-symbolic-name - The bundle symbolic name of the exporting bundle. In the case of a fragment bundle, this will be the host bundle's symbolic name.\n\nbundle-version - A version-range to select the bundle version of the exporting bundle. The default value is [0.0.0, ∞). See Semantic Versioning. In the case of a fragment bundle, the version is from the host bundle.\n\nIn order to be allowed to import a package, a bundle must have PackagePermission[<package-name>, IMPORT]. See PackagePermission for more information.\n\nAn error aborts an installation or update when:\n\nA directive or attribute appears multiple times, or\n\nThere are multiple import definitions for the same package, or\n\nThe version and specification-version attributes do not match.\n\nExample of a correct definition:\n\nImport-Package: com.acme.foo;com.acme.bar; « version=\"[1.23,1.24]\"; « resolution:=mandatory\n\n3.6.5 Export-Package\n\nThe syntax of the Export-Package header is similar to the Import-Package header; only the directives and attributes are different.\n\nExport-Package ::= export ( ',' export)* export ::= package-names ( ';' parameter )* package-names ::= package-name // See 1.3.2 ( ';' package-name )*\n\nThe header allows many packages to be exported. An export definition is the description of a single package export for a bundle. The syntax permits the declaration of multiple packages in one clause by separating the package names with a semi-colon. Multiple export definitions for the same package are allowed for example, when different attributes are needed for different importers. The Export annotation can be applied to a package to specify the package is to be exported. This annotation can be processed by bundle assembly tools to add the annotated package to the Export-Package header in the bundle's manifest.\n\nExport directives are:\n\nuses - A comma-separated list of package names that are used by the exported package. Note that the use of a comma in the value requires it to be enclosed in double quotes. If this exported package is chosen as an export, then the resolver must ensure that importers of this package wire to the same versions of the package in this list. See Package Constraints.\n\nmandatory - A comma-separated list of attribute names. Note that the use of a comma in the value requires it to be enclosed in double quotes. A bundle importing the package must specify the mandatory attributes, with a value that matches, to resolve to the exported package. See Mandatory Attributes.\n\ninclude - A comma-separated list of class names that must be visible to an importer. Note that the use of a comma in the value requires it to be enclosed in double quotes. For class filtering, see Class Filtering.\n\nexclude -A comma-separated list of class names that must be invisible to an importer. Note that the use of a comma in the value requires it to be enclosed in double quotes. For class filtering, see Class Filtering.\n\nThe following attributes are part of this specification:\n\nversion - The version of the named packages with syntax as defined in Version. It defines the version of the associated packages. The default value is 0.0.0.\n\nspecification-version - An alias for the version attribute only to ease migration from earlier versions. If the version attribute is present, the values must be equal.\n\nAdditionally, arbitrary matching attributes may be specified. See Attribute Matching.\n\nThe Framework will automatically associate each package export definition with the following attributes:\n\nbundle-symbolic-name - The bundle symbolic name of the exporting bundle. In the case of a fragment bundle, this is the host bundle's symbolic name.\n\nbundle-version - The bundle version of the exporting bundle. In the case of a fragment bundle, this is the host bundle's version.\n\nAn installation or update must be aborted when any of the following conditions is true:\n\na directive or attribute appears multiple times\n\nthe bundle-symbolic-name or bundle-version attribute is specified in the Export-Package header.\n\nAn export definition does not imply an automatic import definition. A bundle that exports a package and does not import that package will get that package via its bundle class path. Such an exported only package can be used by other bundles, but the exporting bundle does not accept a substitution for this package from another bundle.\n\nIn order to export a package, a bundle must have PackagePermission[<package>, EXPORTONLY].\n\nExample:\n\nExport-Package: com.acme.foo;com.acme.bar;version=1.23\n\n3.6.6 Importing Exported Packages\n\nBundles that collaborate require the same class loader for types used in the collaboration. If multiple bundles export packages with collaboration types then they will have to be placed in disjoint class-spaces, making collaboration impossible. Collaboration is significantly improved when bundles are willing to import exported packages; these imports will allow a framework to substitute exports for imports.\n\nThough substitution is recommended to increase collaboration, it is not always possible. Importing exported packages can only work when those packages are pure API and not encumbered with implementation details. Import of exported packages should only be done when:\n\nThe exported package does not use private packages. If an exported package uses private packages then it might not be substitutable and is therefore not clean API.\n\nThere is at least one private package that references the exported package. If no such reference exist, there is no purpose in importing it.\n\nIn practice, importing exported packages can only be done with clean API-implementation separation. OSGi services are carefully designed to be as standalone as possible. Many libraries intertwine API and implementation in the same package making it impossible to substitute the API packages.\n\nImporting an exported package must use a version range according to its compatibility requirements, being either a consumer or a provider of that API. See Semantic Versioning for more information.\n\n3.6.7 Interpretation of Legacy Bundles\n\nBundles that are not marked with a Bundle-ManifestVersion that equals 2 or more must treat the headers according the definitions in the Release 3. More specifically, the Framework must map the Release 3 headers to the appropriate Release 4 headers:\n\nImport-Package - An import definition must change the specification-version attribute to the version attribute. An import definition without a specification version needs no replacement since the default version value of 0.0.0 gives the same semantics as Release 3.\n\nExport-Package - An export definition must change the specification-version attribute to the version attribute. The export definition must be appended with the uses directive. The uses directive must contain all imported and exported packages for the given bundle. Additionally, if there is no import definition for this package, then an import definition for this package with the package version must be added.\n\nDynamicImport-Package - A dynamic import definition is unmodified.\n\nA bundle manifest which mixes legacy syntax with bundle manifest version 2 syntax is in error and must cause the containing bundle to fail to install.\n\nThe specification-version attribute is a deprecated synonym for the version attribute in bundle manifest version 2 headers.\n\n3.7 Constraint Solving\n\nThe OSGi Framework package resolver provides a number of mechanisms to match imports to exports. The following sections describe these mechanisms in detail.\n\n3.7.1 Diagrams and Syntax\n\nWires create a graph of nodes. Both the wires as well as nodes (bundles) carry a significant amount of information. In the next sections, the following conventions are used to explain the many details.\n\nBundles are named A, B, C,... That is, uppercase characters starting from the character A. Packages are named p, q, r, s, t,... In other words, lower case characters starting from p. If a version is important, it is indicated with a dash followed by the version: q-1.0. The syntax A.p means the package definition (either import or export) of package p by bundle A.\n\nImport definitions are graphically shown by a white box. Export definitions are displayed with a black box. Packages that are not exported or imported are called private packages. They are indicated with diagonal lines.\n\nBundles are a set of connected boxes. Constraints are written on the wires, which are represented by lines.\n\nFigure 3.7 Legend of wiring instance diagrams, and example\n\nFor example:\n\nA: Import-Package: p; version=\"[1,2)\" Export-Package: q; version=2.2.2; uses:=p Require-Bundle: C B: Export-Package: p; version=1.5.1 C: Export-Package: r\n\nFigure 3.8 shows the same setup graphically.\n\nFigure 3.8 Example bundle diagram\n\n3.7.2 Version Constraints\n\nVersion constraints are a mechanism whereby an import definition can declare a precise version or a version range for matching an export definition.\n\nAn import definition must specify a version range as the value for its version attribute, and the exporter must specify a version as the value for its version attribute. Matching is done with the rules for version range matches as described in Version Ranges.\n\nFor example, the following import and export definition resolve correctly because the version range in the import definition matches the version in the export definition:\n\nA: Import-Package: p; version=\"[1,2)\" B: Export-Package: p; version=1.5.1\n\nFigure 3.9 graphically shows how a constraint can exclude an exporter.\n\nFigure 3.9 Version Constrained\n\n3.7.3 Semantic Versioning\n\nVersion ranges encode the assumptions about binary compatibility. Though the OSGi frameworks do not enforce a specific encoding for a compatibility policy, it is strongly recommended to use the following semantics.\n\nTraditionally, compatibility has always been between two parties. One is the consumer of the code and the other is the provider of the code. API based design introduces a third party in the compatibility policy:\n\nThe API itself\n\nThe provider of the API\n\nThe consumer of the API\n\nA provider of an API is closely bound to that API. Virtually any change to that API makes a provider implementation incompatible with the new version of the API. However, API changes have more leeway from the perspective of a consumer of that API. Many API changes can be made backward compatible for consumers but hardly any API change can be made backward compatible for a provider of that API.\n\nA provider of an API should therefore import that API with a smaller range than a consumer of that API. This policy can be encoded in a version range. The rules are summarized as follows:\n\nmajor - Changes for an incompatible update for both a consumer and a provider of an API.\n\nminor - Changes for a backward compatible update for a consumer but not for a provider.\n\nmicro - A change that does not affect the API, for example, a typo in a comment or a bug fix in an implementation.\n\nBoth consumers and providers should use the version they are compiled against as their base version. It is recommended to ignore the micro part of the version because systems tend to become very rigid if they require the latest bug fix to be deployed all the time. For example, when compiled against version 4.2.1.V201007221030, the base version should be 4.2.\n\nA consumer of an API should therefore import a range that starts with the base version and ends with the next major change, for example: [4.2,5). A provider of an API should import a range that starts with the base version up to the next minor change, for example: [4.2,4.3).\n\n3.7.4 Type Roles for Semantic Versioning\n\nAs mentioned in Semantic Versioning, there are two roles for clients of an API package: API consumers and API providers. API consumers use the API and API providers implement the API. For the types in an API, it is important that the API clearly document which of those types are only to be implemented or extended by API providers and which of those types can be implemented or extended by API consumers. For example, listener interfaces are generally implemented by API consumers and instances of them passed to API providers.\n\nAPI providers are sensitive to changes in types implemented or extended by both API consumers and API providers. An API provider must implement any new changes in API provider types and must understand and likely invoke any new changes in API consumer types. An API consumer can generally ignore compatible changes in API provider types unless it wants to invoke the new function. But an API consumer is sensitive to changes in API consumer types and will probably need modification to implement the new function. For example, in the org.osgi.framework package, the BundleContext type is implemented by the Framework which is the API provider. Adding a new method to BundleContext will require all Framework implementations to be updated to implement the new method. Bundles, which are the API consumers, do not have to change unless they wish to call the new method. However, the BundleActivator type is implemented by bundles and adding a new method to BundleActivator will require all bundles implementing this interface to be modified to implement the new method and will also require all Framework implementations to be modified to utilize the new method. Thus the BundleContext type has an API provider role and the BundleActivator type has an API consumer role in the org.osgi.framework API package.\n\nSince there are generally many API consumer and few API providers, API evolution must be very careful when considering changes to API consumer types while being more relaxed about changes to API provider types. This is because you will need to change the few API providers to support an updated API but you do not want to require the many existing API consumers to change when an API is updated. API consumers should only need to change when the API consumer wants to take advantage of new API.\n\nThe ProviderType and ConsumerType annotations can be used in source files to document the roles of types in a package. API types marked ProviderType must not be implemented or extended by API consumers. These annotations can be processed by bundle assembly tools that support Semantic Versioning when generating the version range information for a bundle's Import-Package manifest header.\n\n3.7.5 Optional Packages\n\nA bundle can indicate that it does not require a package to resolve correctly, but it may use the package if it is available. For example, logging is important, but the absence of a log service should not prevent a bundle from running.\n\nOptional imports can be specified in the following ways:\n\nDynamic Imports - The DynamicImport-Package header is intended to look for an exported package when that package is needed. The key use case for dynamic import is the Class forName method when a bundle does not know in advance the class name it may be requested to load.\n\nResolution Directive - The resolution directive on an import definition specifying the value optional. A bundle may successfully resolve if a suitable optional package is not present.\n\nThe key difference between these two mechanisms is when the wires are made. An attempt is made to establish a wire for a dynamic import every time there is an attempt to load a class in that package, whereas the wire for a resolution optional package may only be established when the bundle is resolved.\n\nThe resolution directive of the import definition can take the value mandatory or optional.\n\nmandatory - (Default) Indicates that the package must be wired for the bundle to resolve.\n\noptional - Indicates that the importing bundle may resolve without the package being wired. If the package is not wired, the class loading will treat this package as if it is not imported.\n\nThe following example will resolve even though bundle B does not provide the correct version (the package will not be available to the code when bundle A is resolved).\n\nA: Import-Package: p; « resolution:=optional; « version=1.6 B: Export-Package: p; « q; « version=1.5.0\n\nFigure 3.10 Optional import\n\nThe implementation of a bundle that uses optional packages must be prepared to handle the fact that the packages may not be available: that is, an exception can be thrown when there is a reference to a class from a missing package. This can be prevented by including a fallback package on the bundle's class path. When an optional package cannot be resolved, any attempts by the bundle to load classes from it will follow normal bundle class loading search order as if the import never existed. It will load it from the bundle's class path or in the end through dynamic class loading when set for that bundle and package.\n\n3.7.6 Package Constraints\n\nClasses can depend on classes in other packages. For example, when they extend classes from another package, or these other classes appear in method signatures. It can therefore be said that a package uses other packages. These inter-package dependencies are modeled with the uses directive on the Export-Package header.\n\nFor example, org.osgi.service.http depends on the package javax.servlet because it is used in the API. The export definition of the org.osgi.service.http must therefore contain the uses directive with the javax.servlet package as its value.\n\nClass space consistency can only be ensured if a bundle has only one exporter for each package. For example, the Http Service implementation requires servlets to extend the javax.servlet.http.HttpServlet base class. If the Http Service bundle would import version 2.4 and the client bundle would import version 2.1 then a class cast exception is bound to happen. This is depicted in Figure 3.11.\n\nFigure 3.11 Uses directive in B, forces A to use javax.servlet from D\n\nIf a bundle imports a package from an exporter then the export definition of that package can imply constraints on a number of other packages through the uses directive. The uses directive lists the packages that the exporter depends upon and therefore constrains the resolver for imports. These constraints ensure that a set of bundles share the same class loader for the same package.\n\nWhen an importer imports a package with uses constraints, the resolver must wire the import to the exporter named in the uses constraint. This exporter may in turn imply additional constraints, and so on. The act of wiring a single import of a package to an exporter can therefore imply a large set of constraints. The term implied package constraints refers to the complete set of constraints constructed from recursively traversing the wires. Implied package constraints are not automatic imports; rather, implied package constraints only constrain how an import definition must be wired.\n\nFor example, in Figure 3.12, bundle A imports package p. Assume this import definition is wired to bundle B. Due to the uses directive (the ellipse symbols indicates the uses directive) this implies a constraint on package q.\n\nFurther, assuming that the import for package q is wired to bundle C, then this implies a constraint on the import of package r and s. Continuing, assuming C.s and C.r are wired to bundle D and E respectively. These bundles both add package t to the set of implied packages for bundle A.\n\nFigure 3.12 Implied Packages\n\nTo maintain class space consistency, the Framework must ensure that none of its bundle imports conflicts with any of that bundle's implied packages.\n\nFor the example, this means that the Framework must ensure that the import definition of A.t is wired to package D.t. Wiring this import definition to package F.t violates the class space consistency. This violation occurs because bundle A could be confronted with objects with the same class name but from the class loaders of bundle D and F. This would potentially create ClassCastExceptions. Alternatively, if all bundles are wired to F.t, then the problem also goes away.\n\nAnother scenario with this case is depicted in Figure 3.11. Bundle A imports the Http Service classes from bundle B. Bundle B has grouped the org.osgi.service.http and the javax.servlet and bundle A is therefore constrained to wire javax.servlet to the same exporter as bundle B.\n\nAs an example of a situation where the uses directive makes resolving impossible consider the following setup that is correctly resolved:\n\nA: Import-Package: q; version=\"[1.0,1.0]\" Export-Package: p; uses:=\"q,r\",r B: Export-Package: q; version=1.0 C: Export-Package: q; version=2.0\n\nThese specific constraints can be resolved because the import A.q can be wired to the export B.q but not C.q due to the version constraint.\n\nAdding a bundle D will now not be possible:\n\nD: Import-Package: p, q; version=2.0\n\nPackage D.p must be wired to package A.p because bundle A is the only exporter. However, this implies the use of package q due the uses directive in the package A.q import. Package A.q is wired to B.q-1.0. However, import package D.q requires version 2.0 and can therefore not be resolved without violating the class space constraint.\n\nThis scenario is depicted in Figure 3.13.\n\nFigure 3.13 Uses directive and resolving\n\n3.7.7 Attribute Matching\n\nAttribute matching is a generic mechanism to allow the importer and exporter to influence the matching process in a declarative way. In order for an import definition to be resolved to an export definition, the values of the attributes specified by the import definition must match the values of the attributes of the export definition. By default, a match is not prevented if the export definition contains attributes that do not occur in the import definition. The mandatory directive in the export definition can reverse this by listing all attributes that the Framework must match in the import definition. Any attributes specified in the DynamicImport-Package is ignored during the resolve phase but can influence runtime class loading.\n\nFor example, the following statements will match.\n\nA: Import-Package: com.acme.foo;company=ACME B: Export-Package: com.acme.foo; « company=\"ACME\"; « security=false\n\nAttribute values are compared string wise except for the version and bundle-version attributes which use version range comparisons. Leading and trailing white space in attribute values must be ignored.\n\nAttribute matching also works for the Require-Bundle and Fragment-Host headers; the attributes to be matched are specified on the Bundle-SymbolicName header.\n\n3.7.8 Mandatory Attributes\n\nThere are two types of attributes: mandatory and optional. Mandatory attributes must be specified in the import definition to match. Optional attributes are ignored when they are not referenced by the importer. Attributes are optional by default.\n\nThe exporter can specify mandatory attributes with the mandatory directive in the export definition. This directive contains a comma-separated list of attribute names that must be specified by the importer to match.\n\nFor example, the following import definition must not match the export definition because security is a mandatory attribute:\n\nA: Import-Package: com.acme.foo;company=ACME B: Export-Package: com.acme.foo; « company=\"ACME\"; « security=false; « mandatory:=security\n\n3.7.9 Class Filtering\n\nAn exporter can limit the visibility of the classes in a package with the include and exclude directives on the export definition. The value of each of these directives is a comma-separated list of class names. Note that the use of a comma in the value requires it to be enclosed in double quotes.\n\nClass names must not include their package name and do not end with .class. That is, the class com.acme.foo.Daffy is named Daffy in either list. The class name can include multiple wildcard asterisks ('*' \\u002A).\n\nThe default for the include directive is an asterisk ('*' \\u002A) (wildcard matching all names), and for the exclude directive, so that no classes are excluded, an empty list that matches no names. If include or exclude directive are specified, the corresponding default is overridden.\n\nA class is only visible if it is:\n\nMatched with an entry in the included list, and\n\nNot matched with an entry in the excluded list.\n\nIn all other cases, loading or finding fails, and a Class Not Found Exception is thrown for a class load. The ordering of include and exclude is not significant.\n\nThe following example shows an export statement, and a list of files with their visibility status.\n\nExport-Package: com.acme.foo; include:=\"Qux*,BarImpl\"; « exclude:=QuxImpl com/acme/foo QuxFoo visible QuxBar visible QuxImpl excluded BarImpl visible\n\nCare must be taken when using filters. For example, a new version of a module that is intended to be backward compatible with an earlier version should not filter out classes that were not filtered out by the earlier version. In addition, when modularizing existing code, filtering out classes from an exported package may break users of the package.\n\nFor example, packages defined by standard bodies often require an implementation class in the standardized package to have package access to the specification classes.\n\npackage org.acme.open; public class Specified { static Specified implementation; public void foo() { implementation.foo(); } } package org.acme.open; public class Implementation { public void initialize(Specified implementation) { Specified.implementation = implementation; } }\n\nThe Implementation class must not be available to external bundles because it allows the implementation to be set. By excluding the Implementation class, only the exporting bundle can see this class. The export definition for this header could look like:\n\nExport-Package: org.acme.open; exclude:=Implementation\n\n3.7.10 Provider Selection\n\nProvider selection allows the importer to select which bundles can be considered as exporters. Provider selection is used when there is no specification contract between the importer and the exporter. The importer tightly couples itself to a specific exporter, typically the bundle that was used for testing. To make the wiring less brittle, the importer can optionally specify a range of bundle versions that will match.\n\nAn importer can select an exporter with the import attributes bundle-symbolic-name and bundle-version. The Framework automatically provides these attributes for each export definition. These attributes must not be specified in an export definition.\n\nThe export definition bundle-symbolic-name attribute will contain the bundle symbolic name as specified in the Bundle-SymbolicName header without any parameters. The export definition bundle-version attribute is set to the value of the Bundle-Version header or its default of 0.0.0 when absent.\n\nThe bundle-symbolic-name is matched as an attribute. The bundle-version attribute is matched using the version range rules as defined in Version Ranges. The import definition must be a version range and the export definition is a version.\n\nFor example, the following definitions will match:\n\nA: Bundle-SymbolicName: A Import-Package: com.acme.foo; « bundle-symbolic-name=B; « bundle-version=\"[1.41,2.0.0)\" B: Bundle-SymbolicName: B Bundle-Version: 1.41 Export-Package: com.acme.foo\n\nThe following statements will not match because bundle B does not specify a version and thus defaults to 0.0.0:\n\nA: Bundle-SymbolicName: A Import-Package: com.acme.foo; « bundle-symbolic-name=B; « bundle-version=\"[1.41,2.0.0)\" B: Bundle-SymbolicName: B Export-Package: com.acme.foo;version=1.42\n\nSelecting an exporter by symbolic name can result in brittleness because of hard coupling of the package to the bundle. For example, if the exporter eventually needs to be refactored into multiple separate bundles, all importers must be changed. Other arbitrary matching attributes do not have this disadvantage as they can be specified independently of the exporting bundle.\n\nThe brittleness problem of the bundle symbolic name in bundle refactoring can be partly overcome by writing a façade bundle using the same bundle symbolic name as the original bundle.\n\n3.8 Resolving Process\n\nResolving is the process that creates a wiring between bundles. Constraints on the wires are statically defined by:\n\nAny mandatory requirement must be matched to at least one capability in the same namespace provided by any of the resolved bundles, including itself and the system bundle.\n\nThe required execution environments as defined by the Bundle-RequiredExecutionEnvironment header.\n\nNative code\n\nImport and export packages (the DynamicImport-Package header is ignored in this phase)\n\nRequired bundles, which import all exported packages from a bundle as defined in Requiring Bundles.\n\nFragments, which provide their contents and definitions to the host as defined in Fragment Bundles\n\nA bundle can only be resolved when a number of constraints are satisfied:\n\nExecution Environment - The underlying VM implements at least one of the execution environments listed in the Bundle-RequiredExecutionEnvironment header. See osgi.ee Namespace.\n\nNative code - The native code dependencies specified in the Bundle-NativeCode header must be resolved. See Loading Native Code Libraries.\n\nThe resolving process is then a constraint-solving algorithm that can be described in terms of requirements on wiring relations. The resolving process is an iterative process that searches through the solution space.\n\nA bundle can be resolved if the following conditions are met:\n\nAll its mandatory requirements are satisfied\n\nAll its mandatory imports are wired\n\nAll its mandatory required bundles are available and their exports wired\n\nA wire is only created when the following conditions are met:\n\nThe importer's version range matches the exporter's version. See Semantic Versioning.\n\nThe importer specifies all mandatory attributes from the exporter. See Mandatory Attributes.\n\nAll the importer's attributes match the attributes of the corresponding exporter. See Attribute Matching\n\nImplied packages referring to the same package as the wire are wired to the same exporter. See Package Constraints.\n\nThe wire is connected to a valid exporter.\n\nThe following list defines the preferences, if multiple choices are possible, in order of decreasing priority:\n\nA resolved exporter must be preferred over an unresolved exporter.\n\nAn exporter with a higher version is preferred over an exporter with a lower version.\n\nAn exporter with a lower bundle ID is preferred over a bundle with a higher ID.\n\n3.8.1 Importing and Exporting the Same Package\n\nIf a bundle has both import and export definitions for the same package, then the Framework needs to decide which to choose.\n\nIt must first try to resolve the overlapping import definition. The following outcomes are possible:\n\nExternal - If this resolves to an export statement in another bundle, then the overlapping export definition in this bundle is discarded.\n\nInternal - If it is resolved to an export statement in this bundle, then the overlapping import definition in this bundle is discarded.\n\nUnresolved - There is no matching export definition. In this case the framework is free to discard either the overlapping export definition or overlapping import definition in this bundle. If the export definition is discarded and the import definition is not optional then the bundle will fail to resolve.\n\nThe above only applies to the import and export package definitions of a bundle. For namespaces other than osgi.wiring.package, a requirement definition of a bundle may be wired to a capability definition of that same bundle.\n\n3.9 Runtime Class Loading\n\nEach bundle installed in the Framework must not have an associated class loader until after it is resolved. After a bundle is resolved, the Framework must create one class loader for each bundle that is not a fragment. The framework may delay creation of the class loader until it is actually needed.\n\nOne class loader per bundle allows all resources within a bundle to have package level access to all other resources in the bundle within the same package. This class loader provides each bundle with its own namespace, to avoid name conflicts, and allows resource sharing with other bundles.\n\nThis class loader must use the wiring as calculated in the resolving process to find the appropriate exporters. If a class is not found in the imports, additional headers in the manifest can control the searching of classes and resources in additional places.\n\nThe following sections define the factors that influence the runtime class loading and then define the exact search order the Framework must follow when a class or resource is loaded.\n\n3.9.1 Bundle Class Path\n\nJAR, ZIP, directories, etc. are called containers. Containers contain entries organized in hierarchical paths. During runtime, an entry from a bundle can actually come from different containers because of attached fragments. The order in which an entry can be found is significant because it can shadow other entries. For a bundle, the search order for a named entry is:\n\nFirst the container of the (host) bundle\n\nThen the (optional) fragment containers in ascending id order\n\nThis search order is called the entry path. A resource (or class) is not loaded via the entry path, but it is loaded through the bundle class path. The bundle class path provides an additional indirection on top of the entry path. It defines an ordered list of container paths. Each container path can be found on the entry path.\n\nEach container, independent of any other containers, can be a multi-release container. See Multi-release Container.\n\nThe full stop ('.' \\u002E) container path is a synonym for the solidus ('/' \\u002F) or the root of a container. The full stop is the default value for a bundle or fragment if no Bundle-ClassPath header is specified.\n\nThe Bundle-ClassPath manifest header must conform to the following syntax:\n\nBundle-ClassPath ::= entry ( ',' entry )* entry ::= target ( ';' target )* ( ';' parameter ) * target ::= path | '.' // See 1.3.2\n\nThe Framework must ignore any unrecognized parameters.\n\nThe content of the effective bundle class path is constructed from the bundle's Bundle-ClassPath header, concatenated with the Bundle-ClassPath headers of any fragments, in ascending bundle id order. The effective Bundle-ClassPath is calculated during resolve time, however, a dynamically attached fragment can append elements at the end if the Framework supports dynamically attached fragments.\n\nAn element from the bundle's Bundle-ClassPath header refers to the first match when searched through the entry path, while a fragment's Bundle-ClassPath can refer only to an entry in its own container.\n\nAn example can illustrate this:\n\nA: Bundle-ClassPath: .,resource.jar B: Fragment-Host: A\n\nThe previous example uses an effective bundle class path of:\n\n/, resource.jar, B:/\n\nThe first element / is the root of a container. The bundle always has a root and can therefore always be found in the (host) bundle. The second element is first looked up in the host bundle's container, and if not found, the entry is looked up in the container of B. The Framework must use the first entry that matches. The last element in the effective bundle class path is the / from fragment B; the / is the default because there is no Bundle-ClassPath specified. However, a fragment can only refer to an internal entry. This full stop therefore refers to the root of the container of fragment B. Assuming, fragment B contains an entry for resource.jar and bundle A does not, then the search order must be:\n\nA:/ B:resource.jar B:/\n\nThe Framework must ignore a container path in the bundle class-path if the container cannot be located when it is needed, which can happen at any time after the bundle is resolved. However, the Framework should publish a Framework Event of type INFO once with an appropriate message for each entry that cannot be located at all.\n\nAn entry on the Bundle-ClassPath can refer to a directory in the container. However, it is not always possible to establish the directory's existence. For example, directories can be omitted in JAR/ZIP files. In such a case, a Framework must probe the directory to see if any resources can be found in this directory. That is, even if the directory construct is absent in the container, if resources can be found assuming this directory, than it must still be chosen for the Bundle-ClassPath.\n\nA host bundle can allow a fragment to insert code ahead of its own code by naming a container in its Bundle-ClassPath that will be provided by a fragment. Fragments can never unilaterally insert code ahead of their host's bundle class path. The following example illustrates the possibilities of the bundle class path in more detail:\n\nA: Bundle-SymbolicName: A Bundle-ClassPath: /,required.jar,optional,default.jar content ... required.jar default.jar B: Bundle-SymbolicName: B Bundle-ClassPath: fragment.jar Fragment-Host: A content ... optional/ content ... fragment.jar\n\nThe names of the bundle class path elements indicate their intention. The required.jar is a container that provides mandatory functionality, it is packaged in bundle A. The optional container is a directory containing optional classes, and the default.jar is a JAR entry with backup code. In this example, the effective bundle class path is:\n\nA:/ A:required.jar B:optional A:default.jar B:fragment.jar\n\nThis will expand to the following (logical) search order for a resource X.class:\n\nA:/X.class A:required.jar!X.class B:optional/X.class A:default.jar!X.class B:fragment.jar!X.class\n\nThe exclamation mark (!) indicates a load from a JAR resource.\n\n3.9.1.1 Multi-release Container\n\nA container can be a multi-release container . A multi-release container supports versioned directories as specified in [28] Multi-release JAR File. When a container is a multi-release container, that is, the container has a META-INF/MANIFEST.MF manifest which specifies\n\nMulti-Release: true\n\nthen the Framework must search the container's versioned directories when attempting to locate an entry in the container.\n\nSupport for multi-release containers must only be active on Java 9 and later. On Java 8 and earlier, the container must be treated as a non-multi-release container.\n\n3.9.2 Dynamic Import Package\n\nDynamic imports are matched to export definitions (to form package wirings) during class loading, and therefore do not affect module resolution. Dynamic imports apply only to packages for which no wire has been established and no definition could be found in any other way. Dynamic import is used as a last resort.\n\nDynamicImport-Package ::= dynamic-description ( ',' dynamic-description )* dynamic-description ::= wildcard-names ( ';' parameter )* wildcard-names ::= wildcard-name ( ';' wildcard-name )* wildcard-name ::= package-name | ( package-name '.*' ) // See 1.3.2 | '*'\n\nNo directives are architected by the Framework for DynamicImport-Package. Arbitrary matching attributes may be specified. The following matching attributes are architected by the Framework:\n\nversion -- A version range to select the version of an export definition. The default value is 0.0.0 .\n\nbundle-symbolic-name - The bundle symbolic name of the exporting bundle.\n\nbundle-version - a version range to select the bundle version of the exporting bundle. The default value is 0.0.0.\n\nPackages may be named explicitly or by using wild-carded expressions such as org.foo.* and *. The wildcard can stand for any suffix, including multiple sub-packages. If a wildcard is used, then the package identified by the prefix must not be included. That is, org.foo.* will include all sub-packages of org.foo but it must not include package org.foo itself.\n\nDynamic imports must be searched in the order in which they are specified. The order is particularly important when package names with wildcards are used. The order will then determine the order in which matching occurs. This means that the more specific package specifications should appear before the broader specifications. For example, the following DynamicImport-Package header indicates a preference for packages supplied by ACME:\n\nDynamicImport-Package: *;vendor=acme, *\n\nIf multiple packages need to be dynamically imported with identical parameters, the syntax permits a list of packages, separated by semicolons, to be specified before the parameters.\n\nDuring class loading, the package of the class being loaded is compared against the specified list of (possibly wild-carded) package names. Each matching package name is used in turn to attempt to wire to an export using the same rules as Import-Package. If a wiring attempt is successful (taking any uses constraints into account), the search is forwarded to the exporter's class loader where class loading continues. The wiring must not subsequently be modified, even if the class cannot be loaded. This implies that once a package is dynamically resolved, subsequent attempts to load classes or resources from that package are treated as normal imports.\n\nIn order for a DynamicImport-Package to be resolved to an export statement, all attributes of the dynamic import definition must match the attributes of the export statement. All mandatory arbitrary attributes (as specified by the exporter, see Mandatory Attributes ) must be specified in the dynamic import definition and match.\n\nOnce a wire is established, any uses constraints from the exporter must be obeyed for further dynamic imports.\n\nDynamic imports are very similar to optional packages, see Optional Packages, but differ in the fact that they are handled after the bundle is resolved.\n\n3.9.3 Parent Delegation\n\nThe Framework must always delegate any package that starts with java. to the parent class loader.\n\nCertain Java virtual machines, also Oracle's VMs, appear to make the erroneous assumption that the delegation to the parent class loader always occurs. This implicit assumption of strictly hierarchical class loader delegation can result in NoClassDefFoundErrors. This happens if the virtual machine implementation expects to find its own implementation classes from any arbitrary class loader, requiring that packages loaded from the boot class loader not be restricted to only the java.* packages.\n\nOther packages that must be loaded from the boot class loader can therefore be specifi"
    }
}