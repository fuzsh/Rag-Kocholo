{
    "id": "correct_subsidiary_00130_3",
    "rank": 94,
    "data": {
        "url": "https://patents.google.com/patent/US11314494",
        "read_more_link": "",
        "language": "en",
        "title": "US11314494B2 - Systems and methods for exporting, publishing, browsing and installing on-demand applications in a multi-tenant database environment - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/48/93/ce/59be015cc95c1f/US11314494-20220426-D00000.png",
            "https://patentimages.storage.googleapis.com/48/b9/2f/dc45c0bccfecf0/US11314494-20220426-D00001.png",
            "https://patentimages.storage.googleapis.com/b6/59/e6/934e5ed74fb57b/US11314494-20220426-D00002.png",
            "https://patentimages.storage.googleapis.com/96/03/36/238c03e0616be8/US11314494-20220426-D00003.png",
            "https://patentimages.storage.googleapis.com/f1/6e/70/da6c431a609056/US11314494-20220426-D00004.png",
            "https://patentimages.storage.googleapis.com/61/ec/e6/9fc622b6b48989/US11314494-20220426-D00005.png",
            "https://patentimages.storage.googleapis.com/86/ae/a0/7808894d8d00c5/US11314494-20220426-D00006.png",
            "https://patentimages.storage.googleapis.com/66/0e/ad/d0e617b22fb397/US11314494-20220426-D00007.png",
            "https://patentimages.storage.googleapis.com/2d/db/f8/a25e50ca052123/US11314494-20220426-D00008.png",
            "https://patentimages.storage.googleapis.com/81/14/de/98f66397de435c/US11314494-20220426-D00009.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2005-09-09T00:00:00",
        "summary": "",
        "meta_description": "In accordance with embodiments, there are provided mechanisms and methods for creating, exporting, viewing and testing, and importing custom applications in a multitenant database environment. These mechanisms and methods can enable embodiments to provide a vehicle for sharing applications across organizational boundaries. The ability to share applications across organizational boundaries can enable tenants in a multi-tenant database system, for example, to easily and efficiently import and export, and thus share, applications with other tenants in the multi-tenant environment.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US11314494B2/en",
        "text": "CROSS-REFERENCE TO RELATED APPLICATIONS\n\nThis application is a continuation of U.S. application Ser. No. 15/453,539 filed Mar. 8, 2017 (now U.S. Pat. No. 10,521,211 issued Dec. 31, 2019), which is a continuation of U.S. application Ser. No. 15/194,418 filed Jun. 27, 2016 (now U.S. Pat. No. 10,235,148 issued Mar. 19, 2019), which is continuation of U.S. application Ser. No. 14/160,537 filed Jan. 21, 2014 (now U.S. Pat. No. 9,378,227 issued Jun. 28, 2016), which is a continuation of U.S. application Ser. No. 13/088,491 filed Apr. 18, 2011 (now U.S. Pat. No. 8,635,232 issued Jan. 21, 2014), which is a continuation of U.S. application Ser. No. 11/530,394 filed Sep. 8, 2006 (now U.S. Pat. No. 7,949,684 issued May 24, 2011), which claims the benefit of U.S. Provisional Application No. 60/715,749 filed Sep. 9, 2005, which are hereby incorporated by reference.\n\nFIELD OF THE INVENTION\n\nThe present invention relates generally to databases, and more particularly to systems and methods for creating and exchanging customized applications in a multi-tenant 15 and/or multi-application database system.\n\nBACKGROUND\n\nNot too long after inventing numbers and a writing system, early humans realized that they had inadvertently created information. With the creation of information came a problem that would vex humankind for the next several millennia: how to store and manage the information.\n\nFortunately, the amount of information created by early humans was relatively small and could be tracked using ten fingers and ten toes. Stone or clay tablets were employed to track information when a more permanent record was desired. One early well known example of this mechanism was used by Moses, who stored a body often 25 Commandments on two such stone tablets. These mechanisms were limited, however, to write-once, read-many implementations and were tightly constrained in capacity.\n\nWith the advent of the Gutenberg printing press, came the ability to store larger quantities of information as well as to produce copies of stored information in volume. While, these mechanisms also were limited to write-once, read-many implementations, they facilitated the widespread dissemination of knowledge, which in tum accelerated the advance of technical progress. A few centuries later, the computer and database software systems appeared. The computer database provided large capacity, write-read storage in a readily available package. For awhile, it appeared that humankind's age old information storage and management problem had finally been solved.\n\nComputer databases, however, are plagued by numerous problems. Each organization, business or agency, installs its own copy of the database. It was not long, however, before users wished to add their own custom objects and applications to their database in addition to the standard objects and standard applications already provided. The desire for customization lead to disparate schema, an organization of the types of information 10 being stored in the database, as well as applications relying upon that schema being implemented by different users. Disparate schema, in tum blocked any hope of users in different organizations of sharing information or applications among one another.\n\nBRIEF SUMMARY\n\nIn accordance with embodiments, there are provided mechanisms and methods for creating, exporting, viewing and testing, and importing custom applications in a multi-tenant database environment. These mechanisms and methods can enable embodiments to provide a vehicle for sharing applications across organizational boundaries. The ability to share applications across organizational boundaries can enable tenants in a multi-tenant database 20 system, for example, to easily and efficiently import and export, and thus share, applications with other tenants in the multi-tenant environment. As used herein, the term multi-tenant database system refers to database system implementing a multi-tenant architecture that enables customer organizations (i.e., tenants) to share applications and data, and database resources, in one logical database. In multi-tenant database environments, even the database 25 tables themselves can be shared across the tenants. For example, each entity in the data model could contain an organization_id column that distinguishes rows for each tenant. Queries and data manipulation in the context of a tenant filter on this (indexed) organization_id column to ensure proper security and the appearance of virtual private databases. This strategy enables multi-tenant database embodiments to be able to expose standard entities such as Account, Contact, Lead, and Opportunity entities to customers.\n\nIn embodiments, using the same physical storage mechanism and schema for the exported container organization as for all other organizations in the multi-tenant database system provides the capability to assure that the container organization can be seamlessly upgraded going forward.\n\nIn embodiments, a package that defines an application is created to facilitate exporting the application. The package may contain metadata and other materials that define 5 the application. When the package is imported into a recipient organization, the package is kept logically separate for the lifetime of the organization. Thus embodiments preserve the uniqueness of the imported package, enabling a user at the recipient organization to be able to navigate to the package as a separate item. Embodiments provide the capability to disable changes to the imported objects in the package as well as to uninstall the package in the future.\n\nAccording to one aspect and by way of example, the ability to define and exchange application functionality with other organizations in a multi-tenant database is provided by creating a package, including metadata, that defines an application at a creating organization and providing the package to another organization. Optionally, the creating organization may provide access to the application by publishing metadata from the package in a directory of applications, or may provide a link to the package, such as for example a URL, to another organization. Interested organizations with access to the application package may view and test such a published package, as well as import and install the package.\n\nAccording to another aspect, a directory of applications is provided. The directory is an online catalog of user-developed applications. The directory includes publicly available applications and private applications that may not be accessed without knowledge of the correct link to the package. Visitors accessing the public directory are able to learn about available applications, view descriptions of applications developed by application builders, and gain access to the import (installation) URLs. Application developers visit the directory site to submit and maintain descriptions of applications they have created, whether public or private. To ensure quality, application entries may be reviewed by internal directory management personnel before being added to the public directory. In one aspect, community feedback in the form of user-submitted ratings, comments, and number of installations are included in the directory and provide a potential recipient a way to gauge the reputation and value of each application. Visitors may browse for applications by business solution category, or sorted by highest rating, developer name, most popular, and other ordering mechanisms.\n\nAccording to another aspect of the present invention, a method is provided for sharing an application in a multi-tenant database environment including a multi-tenant database that stores data and objects for a plurality of organizations. The method typically includes creating a package metadata object that references a set of one or more metadata objects associated with a first organization, storing the package metadata object in a database system, and allowing access to the package metadata object to a user in a second organization. In certain aspects, a method is provided that typically includes creating a package comprising an object and a set of one or more objects that are dependent upon said object, wherein the object and dependent objects are associated with a first organization, storing the package in a database system, and allowing access to the package to a user in a second organization. In certain aspects, the methods include validating the package metadata object or the package.\n\nReference to the remaining portions of the specification, including the drawings and claims, will realize other features and advantages of the present invention. Further features and advantages of the present invention, as well as the structure and operation of various embodiments of the present invention, are described in detail below with respect to the accompanying drawings. In the drawings, like reference numbers indicate identical or functionally similar elements.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nFIG. 1 illustrates an environment wherein a multi-tenant database system might be used.\n\nFIG. 2 illustrates elements of FIG. 1 and various interconnections between the elements.\n\nFIG. 3 shows a data model for a Directory of applications in an embodiment.\n\nFIG. 4 shows a definition of a DirectoryEntry object and other objects in an embodiment.\n\nFIG. 5 shows a solutions category hierarchy in an embodiment.\n\nFIG. 6 shows an example of a GUI screen that allows a user to create a package in 30 an\n\nFIG. 7 shows an example of a GUI screenshot showing information, including included items, for a created package in an embodiment.\n\nFIG. 8 shows an example of a Project data model definition and a Project Member data model definition in an embodiment.\n\nDETAILED DESCRIPTION\n\nIn embodiments, the present invention provides systems and methods for creating and exchanging customized applications in a multi-tenant database system.\n\nCustomers may wish to add their own custom objects and applications to their database system in addition to the standard objects and standard applications already provided. In a traditional client/server application, where the customer has its own physical database, adding custom objects is typically done via DDL (data definition language) against that database to create new physical schema-tables and columns. In an online multi-tenant database system, this approach may be untenable for various reasons. For example, for a database system with a large population of tenants (e.g., on the order of 1,000 or 10,000 or more tenants), the union of all desired schema would overwhelm the underlying data dictionary catalog (e.g., Oracle dictionary). Additionally, the maintenance of all of these schema objects would be a nearly impossible burden for DBAs (database administrators). Further, current relational databases do not support online DDL (in a highly concurrent transactional system) well enough for organizations to remain logically independent. Specifically, the creation of schema by one organization could lock an application for all other customers causing unacceptable delays.\n\nMany application platforms have the concept of different applications that one can install. Windows, for example, has applications that can be installed as does Linux and other operating systems. Several websites allow one to browse and select applications for download and installation. For example, CNET has the download.com site that allows one to download PC based applications. Other enterprise software toolkits have the ability to specify a package of metadata and export it from one environment and import it into another. For example, Peoplesoft has the ability to do this using either importing/exporting over an odbc connection or via a flat file. With flat file and odbc based approaches, there exists the risk of not being able to import packages that were defined or exported using a previous version. Microsoft has an office directory that allows one to download useful spreadsheet or word document templates from their central web site. However, these systems do not allow users to easily and efficiently import and export applications in a multi-tenant environment. These systems also do not preserve the uniqueness of an imported application; one cannot navigate to it as a separate item. Other systems also do not allow one to disable changes to the imported objects in the imported application and uninstall the application in the future.\n\nFIG. 1 illustrates an environment wherein a multi-tenant database system might be used. As illustrated in FIG. 1 any user systems 12 might interact via a network 14 with a multi-tenant database system (MTS) 16. The users of those user systems 12 might be users in differing capacities and the capacity of a particular user system 12 might be entirely determined by permissions (permission levels) for the current user. For example, where a salesperson is using a particular user system 12 to interact with MTS 16, that user system has the capacities allotted to that salesperson. However, while an administrator is using that user system to interact with MTS 16, that user system has the capacities allotted to that administrator. Thus, different users will have different capabilities with regard to accessing and modifying application and database information, including tab and tab set definition and profile information, depending on a user's permission level.\n\nNetwork 14 can be a LAN (local area network), WAN (wide area network), wireless network, point-to-point network, star network, token ring network, hub network, or other configuration. As the most common type of network in current use is a TCPIIP (Transfer Control Protocol and Internet Protocol) network such as the global internetwork of networks often referred to as the âInternetâ with a capital âI,â that will be used in many of the examples herein. However, it should be understood that the networks that the present invention might use are not so limited, although TCP/IP is the currently preferred protocol.\n\nUser systems 12 might communicate with MTS 16 using TCPIIP and, at a higher network level, use other common Internet protocols to communicate, such as HTTP, FTP, AFS, WAP, etc. As an example, where HTTP is used, user system 12 might include an HTTP client commonly referred to as a âbrowserâ for sending and receiving HTTP messages from an HTTP server at MTS 16. Such HTTP server might be implemented as the sole network interface between MTS 16 and network 14, but other techniques might be used as well or instead. In some implementations, the interface between MTS 16 and network 14 includes load sharing functionality, such as round-robin HTTP request distributors to balance loads and distribute incoming HTTP requests evenly over a plurality of servers. Each of the plurality of servers has access to the MTS's data, at least as for the users that are accessing that server.\n\nIn one aspect, the system shown in FIG. 1 implements a web-based customer relationship management (CRM) system. For example, in one aspect, MTS 16 can include application servers configured to implement and execute CRM software applications as well as provide related data, code, forms, web pages and other information to and from user systems 12 and to store to, and retrieve from, a database system related data, objects and web page content. With a multi-tenant system, tenant data is preferably arranged so that data of one tenant is kept logically separate from that of other tenants so that one tenant does not have access to another's data, unless such data is expressly shared. In aspects, system 16 implements applications other than, or in addition to, a CRM application. For example, system 16 may provide tenant access to multiple hosted (standard and custom) applications, including a CRM application.\n\nOne arrangement for elements of MTS 16 is shown in FIG. 1, including a network interface 20, storage 22 for tenant data, storage 24 for system data accessible to MTS 16 and possibly multiple tenants, program code 26 for implementing various functions of MTS 16, and a process space 28 for executing MTS system processes and tenant-specific processes, such as running applications as part of an application hosting service.\n\nSeveral elements in the system shown in FIG. 1 include conventional, well-known elements that need not be explained in detail here. For example, each user system 12 could include a desktop personal computer, workstation, laptop, PDA, cell phone, or any WAP-enabled device or any other computing device capable of interfacing directly or indirectly to the Internet or other network connection. User system 12 typically runs an HTTP client, e.g., a browsing program, such as Microsoft's Internet Explorer browser, Netscape's Navigator browser, Opera's browser, or a WAP-enabled browser in the case of a cell phone, PDA or other wireless device, or the like, allowing a user (e.g., subscriber of the multi-tenant database system) of user system 12 to access, process and view information, pages and applications available to it from MTS 16 over network 14. Each user system 12 also typically includes one or more user interface devices, such as a keyboard, a mouse, touch screen, pen or the like, for interacting with a graphical user interface (GUI) provided by the browser on a display (e.g., monitor screen, LCD display, etc.) in conjunction with pages, forms, applications and other information provided by MTS 16 or other systems or servers. For example, the user interface device can be used to select tabs and tab sets, create and modify applications, and otherwise allow a user to interact with the various GUI pages, for example, as described in U.S. application Ser. No. 11/075,546, entitled âSystems and Methods for Implementing Multi-Application Tabs and Tab Sets,â filed Mar. 8, 2005 (now U.S. Pat. No. 7,774,366 issued Aug. 10, 2010, hereinafter, âU.S. Pat. No. 7,774,366â), which is incorporated by reference in its entirety herein.\n\nAs discussed above, the present invention is suitable for use with the Internet, which refers to a specific global internetwork of networks. However, it should be understood that other networks can be used instead of the Internet, such as an intranet, an extranet, a virtual private network (VPN), a non-TCP/IP based network, any LAN or WAN or the like.\n\nAccording to one embodiment, each user system 12 and all of its components are operator configurable using applications, such as a browser, including computer code run using a central processing unit such as an Intel Pentium processor or the like. Similarly, MTS (and additional instances of MTS's, where more than one is present) and all of their components might be operator configurable using application(s) including computer code run using a central processing unit such as an IntelÂ® Pentium processor or the like, or multiple processor units. Computer code for operating and configuring MTS 16 to intercommunicate and to process web pages, applications and other data and media content as described herein is preferably downloaded and stored on a hard disk, but the entire program code, or portions thereof, may also be stored in any other volatile or non-volatile memory medium or device as is well known, such as a ROM or RAM, or provided on any other information storage media capable of storing program code, such as a compact disk (CD) medium, digital versatile disk (DVD) medium, a floppy disk, and the like. Additionally, the entire program code, or portions thereof, may be transmitted and downloaded from a software source, e.g., over the Internet, or from another server, as is well known, or transmitted over any other conventional network connection as is well known (e.g., extranet, VPN, LAN, etc.) using any communication medium and protocols (e.g., TCP/IP, HTTP, HTTPS, Ethernet, etc.) as are well known. It will also be appreciated that computer code for implementing aspects of the present invention can be implemented in any programming language that can be executed on a server or server system such as, for example, in C, C++, HTML, any other markup language, Javaâ¢, JavaScript, any other scripting language such as VBScript, and many other programming languages as are well known. (Javaâ¢ is a trademark of Sun Microsystems, Inc.)\n\nAccording to one embodiment, each MTS 16 is configured to provide web pages, forms, applications, data and media content to user systems 12 to support the access by user systems 12 as tenants of MTS 16. As such, MTS 16 provides security mechanisms to keep each tenant's data separate unless the data is shared. If more than one MTS is used, they may be located in close proximity to one another (e.g., in a server farm located in a single building or campus), or they may be distributed at locations remote from one another (e.g., one or more servers located in city A and one or more servers located in city B). As used herein, each MTS could include one or more logically and/or physically connected servers distributed locally or across one or more geographic locations. Additionally, the term âserverâ is meant to include a computer system, including processing hardware and process space(s), and an associated storage system and database application (e.g., OODBMS or RDBMS) as is well known in the art. It should also be understood that âserver systemâ and âserverâ are often used interchangeably herein. Similarly, the databases described herein can be implemented as single databases, a distributed database, a collection of distributed databases, a database with redundant online or offline backups or other redundancies, etc., and might include a distributed database or storage network and associated processing intelligence.\n\nFIG. 2 illustrates elements of MTS 16 and various interconnections between these elements in an embodiment. In this example, the network interface is implemented as one or more HTTP application servers 100. Also shown is system process space 102 including individual tenant process spaces 104, a system database 106, tenant database(s) 108 and a tenant management process space 110. Tenant database 108 might be divided into individual tenant storage areas 112, which can be either a physical arrangement or a logical arrangement. Within each tenant storage area 112, user storage 114 might similarly be allocated for each user.\n\nIt should also be understood that each application server 100 may be communicably coupled to database systems, e.g., system database 106 and tenant database(s) 108, via a different network connection. For example, one server 1001 might be coupled via the Internet 14, another server 100 N-1 might be coupled via a direct network link, and another server 100 N might be coupled by yet a different network connection. Transfer Control Protocol and Internet Protocol (TCPIIP) are preferred protocols for communicating between servers 100 and the database system, however, it will be apparent to one skilled in the art that other transport protocols may be used to optimize the system depending on the network interconnect used.\n\nIn aspects, each application server 100 is configured to handle requests for any user/organization. Because it is desirable to be able to add and remove application servers from the server pool at any time for any reason, there is preferably no server affinity for a user and/or organization to a specific application server 100. In one embodiment, therefore, an interface system (not shown) implementing a load balancing function (e.g., an F5 Big-IP load balancer) is communicably coupled between the servers 100 and the user systems 12 to distribute requests to the servers 100. In one aspect, the load balancer uses a least connections algorithm to route user requests to the servers 100. Other examples of load balancing algorithms, such as round robin and observed response time, also can be used. For example, in certain aspects, three consecutive requests from the same user could hit three different servers, and three requests from different users could hit the same server. In this manner, MTS 16 is multi-tenant, wherein MTS 16 handles storage of, and access to, different objects, data and applications across disparate users and organizations.\n\nAs an example of storage, one tenant might be a company that employs a sales force where each salesperson uses MTS 16 to manage their sales process. Thus, a user might maintain contact data, leads data, customer follow-up data, performance data, goals and progress data, etc., all applicable to that user's personal sales process (e.g., in tenant database 108). In the preferred MTS arrangement, since all of this data and the applications to access, view, modify, report, transmit, calculate, etc., can be maintained and accessed by a user system having nothing more than network access, the user can manage his or her sales efforts and cycles from any of many different user systems. For example, if a salesperson is visiting a customer and the customer has Internet access in their lobby, the salesperson can obtain critical updates as to that customer while waiting for the customer to arrive in the lobby.\n\nWhile each user's data might be separate from other users' data regardless of the employers of each user, some data might be organization-wide data shared or accessible by a plurality of users or all of the users for a given organization that is a tenant. Thus, there might be some data structures managed by MTS 16 that are allocated at the tenant level while other data structures might be managed at the user level. Because an MTS might support multiple tenants including possible competitors, the MTS should have security protocols that keep data, applications and application use separate. Also, because many tenants will opt for access to an MTS rather than maintain their own system, redundancy, up-time and backup are additional critical functions and need to be implemented in the MTS.\n\nIn addition to user-specific data and tenant-specific data, MTS 16 might also maintain system level data usable by multiple tenants or other data. Such system level data might include industry reports, news, postings, and the like that are sharable among tenants.\n\nIn certain aspects, client systems 12 communicate with application servers 100 to request and update system-level and tenant-level data from MTS 16 that may require one or more queries to database system 106 and/or database system 108. For example, in one aspect MTS 16 (e.g., an application server 100 in MTS 16) generates automatically a SQL query including one or more SQL statements designed to access the desired information.\n\nEach database can generally be viewed as a collection of objects, such as a set of logical tables, containing data placed into predefined categories. A âtableâ is one representation of a data object, and is used herein to simplify the conceptual description of objects and custom objects according to the present invention. It should be understood that âtableâ and âobjectâ may be used interchangeably herein. Each table generally contains one or more data categories logically arranged, e.g., as columns or fields in a viewable schema. Each row or record of a table contains an instance of data for each category defined by the fields. For example, a CRM database may include a table that describes a customer with fields for basic contact information such as name, address, phone number, fax number, etc. Another table might describe a purchase order, including fields for information such as customer, product, sale price, date, etc. In some multi-tenant database systems, standard entity tables might be provided for use by all tenants. For CRM database applications, such standard entities might include tables for Account, Contact, Lead and Opportunity data, each containing pre-defined fields.\n\nAccording to one aspect, a user can design their own custom applications including custom objects, custom tabs, custom fields, and custom page layouts. U.S. application Ser. No. 10/817,161, entitled âCustom Entities and Fields in a Multi-Tenant Database Systemâ filed Apr. 2, 2004 (now U.S. Pat. No. 7,779,039 issued Aug. 17, 2010), which is herein incorporated by reference in its entirety, discloses systems and methods for creating and customizing objects such as entities and fields. The systems and methods presented therein offer a flexible approach to storing variable schema data in a fixed physical schema. Tabs and tab sets can also be created and customized to define relationships between custom objects and fields, standard objects and fields, and applications and to track related data. U.S. Pat. No. 7,774,366 discloses systems and methods for creating and customizing tabs and tab sets in a multi-tenant environment. A brief summary of tabs and tab set creation and functionality as described therein follows.\n\nCustom Tabs and Tab Sets\n\nIn embodiments, a tab represents a user interface into an element of an application or into a database object. Selection of a tab provides a user access to the object or element of the application represented by the tab. A tab set is a group of related tabs that work as a unit to provide application functionality. New tabs and tab sets may be defined and tab set views may be customized so that an end user can easily and conveniently switch between the various objects and application elements represented by the defined tabs and tab sets. In one aspect, for example, tabs and tab sets may be used as a means to switch between applications in a multiple application environment, such as an on-demand web-based hosted application environment.\n\nA tab set typically includes a name, a logo, and an ordered list of tabs. A tab set is typically viewed in a graphical user interface (GUI) environment, e.g., using a browser application running on a user's computer system. A standard tab set definition may be provided by a host system, e.g., MTS 16. Standard tab sets are pre-defined sets of tabs, e.g., imported from a source that provides a capability (e.g., templating capability) that determines which tabs, tab sets and data a tenant or user is initially provisioned with. One example of standard tab sets are provided by the salesforce.com website through its subscription CRM service. Using these standard tab sets, users are provided access to standard tables or entities such as Account, Contact, Lead and Opportunity entities. As another example, in the salesforce.com service, a user can create custom entities as well as custom fields for standard entities, and a user can create a tab set including tabs representing custom entities and fields.\n\nA user may create custom tab sets and custom tabs. Preferably only administrator level users are provided with tab set creation functionality based on their stored permissions. Additionally, users may customize their view of tab sets, including the order of displayed tabs and which tabs in a tab set are displayed. To allow users to conveniently organize their tabs, each tab may appear in any and all tab sets if desired. Preferably, any user can edit tab combination and order, but cannot rename or replace a logo; tab set naming and logo selection are preferably only administrator level functions. For example, administrators may create new tab sets and customize existing tab sets. For all tab sets, an administrator can specify which tabs are included, and the order that the tabs should be displayed. For organization-specific tab sets, an administrator can also specify the name and provide an optional logo. For standard tab sets provided by the host system, e.g., tab sets provided by salesforce.com, such as Salesforce and Support force tab sets, an administrator is barred from changing the name or logo, nor can the administrator delete the standard tab set. Preferably, any user can fully customize their view of all the tab sets they have permission to view. The tabs a user can view (and use) are based on the user's permission level. A profile for each tab set allows an administrator level user to set the profile level viewability of tabs and tab sets, e.g., so that groups of users at certain permission levels may be restricted from viewing (and using) certain tabs or tab sets, and therefore also may be restricted from accessing or viewing certain objects and applications referenced by the restricted tabs or tab sets.\n\nThus, in one aspect, a tab set can be thought of as a filter that is overlaid on top of an existing profile-level tab visibility definition. An administrator sets the default tabs that are included in each tab set filter, but each user can override as they likeâthe only thing they preferably cannot change is the tab set name and logo. The net result is that tab sets are quite lightweight and flexible. A particular meaning to a tab set is not enforced; each user can generally use tab sets as they wish.\n\nCreating and Exchanging Applications\n\nIn one embodiment, users have the ability to create, post and exchange applications. As used herein, in one aspect, an application is a group or package of multi-tenant database setup data (e.g., metadata) that defines its data model, user interface and business logic. For example, the user may define a tab set, which logically defines the group of metadata that makes up an application. As used herein, a âpackageâ is a metadata object that references the set of metadata objects used in an application in an organization. As used herein, an âorganizationâ can mean a single tenant in a multi-tenant system and/or a set of metadata (both application data and metadata) for a single tenant in a multi-tenant system.\n\nIn one embodiment, the present invention refines the concept of a tab set by allowing a user to precisely define a metadata âpackageâ which includes all setup data (e.g., custom object definitions, page layout definitions, workflow rules, etc.) that make up an application. A package may include 0, 1 or more tab sets. The user can then export this package from one âsourceâ organization to a âcontainerâ organization that is not associated with any tenant in the database system. An exported package is registered with or listed in an application directory. A user that creates and/or exports a package will be referred to herein as a source user or exporting user. The source user can choose to have the package name and application listed in a public portion of the application directory. Another user can import the package into a separate âtargetâ organization allowing this organization to use the application independently of the creating organization. A user that views and/or imports a package will be referred to herein as a viewing user or importing user.\n\nUpon selecting a package for import, code on the server system takes the metadata from the container organization, selects the appropriate recipient organization, reads the metadata from the container organization, and writes that metadata into the recipient organization. Any conflicting metadata (e.g., object or field names) can be resolved by the importing user, e.g., by aborting or by renaming recipient organization objects, fields, etc. It should be noted that the import process preferably does not overwrite any existing recipient organization fields. Also, an import user can uninstall the imported application.\n\nEmbodiments of the package creation process and the export and import processes will now be described.\n\nPackage Creation\n\nIn the source organization, a source user creates a package definition by selecting the appropriate setup data (metadata). This defines the group of setup data that makes up the application. For example, the source user may select a high level tab set (group of tabs). The system then automatically determines object dependencies for the metadata included in the package. For example, in one aspect, the system automatically executes a dependency finder process (e.g., a process that âspidersâ through the object schema and searches for object dependencies) to determine all related objects that are required to use functionality provided by the tab set. In one aspect, this is done in two passesâfirst top down, then bottom up to determine all inverse relationships between objects in the system and those identified by the tab set. Additionally or alternatively, the source user may explicitly specify the collection of setup data to include in the package.\n\nIn one aspect, one or more of the following items (pieces of metadata) can be included in a package:\n\n1. Tab set (this would copy everything referenced by the tab set definition)\n\n2. Custom Object\n\na. Custom fields\n\nb. Relationships (master-detail and Lookup)\n\nc. Picklist values,\n\nd. Page layouts,\n\ne. Search layouts,\n\nf. Related list layouts,\n\ng. Public list views,\n\nh. Custom Links\n\ni. Any other items associated with the custom object\n\n3. Custom Tab Definition\n\n4. S-control, which in one aspect is a JavaScript program that performs custom User Interface and business logic processing. A package creator may specify the s-control that runs on a tab or section of a page so that when a user navigates to the tab or page, an application server downloads the JavaScript for execution on a browser. An API is used to save data back to the service when necessary.\n\n5. Custom Report (One Report Folder will be created for each new app.)\n\n6. Dashboard\n\n7. Email Temp late\n\n8. Document\n\n9. Profile Packages (Including FLS for Custom Objects) (Bundles of permission data associated with profiles, to be defined later)\n\n10. Dependent picklists\n\n11. Workflow rules\n\n12. Record types\n\nAdditional metadata items that may be copied may include:\n\n1. Custom fields for Standard objects\n\n2. Mail Merge Templates\n\n3. Business Processes\n\n4. Assignment Rules (A form of workflow)\n\n5. Auto-response rules (A form of workflow)\n\n6. Escalation rules (A form of workflow)\n\n7. Big Deal alerts I Opportunity Reminders\n\n8. Self Service Portal Settings\n\n9. VLO features, which in one aspect includes definitions of different âdivisionsâ within a company or organization. VLO features allow an application to partition data by divisions and thus limit the scope of reports and list views.\n\n10. Delegated Administration settings\n\n11. Home Page Components\n\nFIG. 6 shows an example of a GUI screen that allows a user to create a package, e.g., by selecting âNewâ with a pointing device, as well as delete and edit existing packages, view a history of installed packages and access a directory from which to install a package. FIG. 7 shows an example of a GUI screenshot showing information, including included items, for a created package. A user is able to edit, delete and publish a package using such a screen.\n\nA user may select to edit a package, e.g., by deleting items or adding items. For example, if a user selects to delete a custom object (or other metadata that is included in a package), the system detects this and alerts the user. If the user wishes to proceed, the metadata is then removed from the package. The next time the user views the package items, the deleted items will be gone. If the package has been exported, the metadata in the exported package is not affected. This feature provides a backup to metadata, but does not provide backup to any records which might have been created, although these records can be saved using a data loader or an Excel plug-in. If a user decides to add new items to a package, a picklist of items available for inclusion may be provided. Any item may be included in more than one package.\n\nWhen adding an application (e.g., a tab set and/or other metadata items) to a package, the system should add all custom items which are related to this application. This includes the custom tabs, the objects behind the tabs, and any custom objects which are related to these. Ideally, the dependency finder process (e.g., spider process) will also detect any custom objects which are related to any standard tabs which make up the added application as well. Even though these standard objects may not be included in the package, the junction objects and other related objects are part of the functionality embodied in the application. Certain object dependencies should always be included. For example, in certain aspects, all the custom fields on a custom object are included with a custom object, and all page layouts are included with a custom object. In certain aspects, custom object related list layouts (that appear on standard objects) are automatically included as well.\n\nOnce the user has finished defining the package, the package is validated. This can be done automatically by the system, e.g., when a user indicates that the package is complete, or it may be done responsive to a user request to validate, e.g., the user selecting a âvalidateâ or similar button on a GUI. This invokes the spidering process that makes sure all required setup data is included in the package definition. This is useful in case a user has changed metadata in the package (e.g., added a relationship, another tab or object, etc.) since metadata items were first added to the package.\n\nIn one embodiment, a package is stored in the database as a set of primary keys of the objects included in the package. FIG. 8 shows an example of a Project data model definition and a Project Member data model definition according to one embodiment.\n\nPackage Export\n\nAfter defining the package, the source user can choose to export the package. Exporting the package makes it available for other organizations to import. In one aspect, when exporting a package, the source user is able to specify whether to allow customizations of the application after it has been imported into other organizations. For example, in certain aspects, a flag is set (by the source user) in the package definition to indicate whether customizations to an exported package are subject to upgrade. In certain aspects, a flag is set (by the source user) to indicate whether a particular component/object in the package can be altered at all.\n\nExporting is implemented, in one aspect, by the system automatically creating a new organization definition, e.g., with an organization of type âcontainerâ, that includes a copy of all items (metadata) in the package including dependent object metadata not explicitly included by the export user in the package definition. In one aspect, this container organization shares the same physical database (e.g., Oracle database) schema as all other organizations. However, the container organization could reside in a different, separate database. Further, this type of organization (org) is preferably ignored by standard expiration and billing processes where applicable. In certain aspects, where multiple database instances are present in a database system environment, an exported package is stored to one of the database instances as a container organization. The container organization is replicated to one or more or all of the remaining database instances. The multiple database instances may, for example, be associated with different geographical regions. For example, one database instance might be associated with Europe (EP) and one might be associated with North America (NA). In this manner, staggered and independent upgrading of database instances is facilitated. For example, installs of packages may continue as new releases/upgrades to the database system are implemented in different instances. For example, where the EP instance is upgraded before (e.g., one or two weeks) the NA instance, installs of package X for NA would happen from the NA instance, and installs of package X for EP would happen from the EP instance replicated copy of package X. This ensures installs from like versions would occur.\n\nWhen the export process completes, the source user receives a URL that includes a unique key of the container organization. Anyone who knows the URL is able to access and import the package in the identified âcontainerâ organization into their own organization, e.g., the metadata associated with that package is copied or instantiated into the schema associated with that organization. The source user may send the URL to another user at another company, or the source user may post the URL to a directory as will be described in more detail below.\n\nOnce a package is exported, the package remains open in the source organization, and the source user can continue to change it. However, the copy of the package in the container organization is preferably locked from further changes.\n\nA source user can export the same package multiple times, creating multiple container organizations. This allows a source user to create a version history of how the package changes over time.\n\nAfter the source user creates and exports the package to a container organization, they can optionally create a second new organization object with organization type âdemonstrationâ. The demonstration organization has its own user id(s) and password(s). Any user who knows the id and password can log into the demonstration organization and view the exported package. Once logged in, the viewing user can manually validate that the required objects are present and the application works as expected. If the exporting user specified that sample data be included in the export package, a viewing user can see the sample data when logging into the demonstration organization or they can add their own sample data directly into the demonstration organization. In one aspect, the source user must create a demonstration organization for their package before they publish it to the public directory. This assures that users browsing the directory have a place to âtry outâ the application before they choose to download or import the package. For example, a package may include a web integration link (WIL)âit is very useful to examine WILs in the demonstration organization to ensure that the services being used by WILs are trusted.\n\nOnce a demonstration organization has been created for a package, the source user can âpublishâ the package to a centralized public directory. Upon publishing, the system notifies the central directory to include the package by sending a message to the directory service. This message, in certain aspects, contains a URL that allows users to navigate from the public directory back to the container organization and import it. The message, in certain aspects, also includes a URL of the demonstration organization. This allows users browsing the public directory to âtry it nowââthey can log into the demonstration organization and thoroughly inspect the functionality. In certain aspects, the message includes descriptive data about the package (e.g., name, description, etc) and a list of objects included in the package. The directory uses this information to provide detailed information for users browsing the directory looking for packages to import. Additional details about the public directory are described below.\n\nPackage Import\n\nTo import and install a package into an organization, an import user navigates to the URL that was generated by the package export process, either through the directory, or via a message from the source user. This URL contains a unique key that identifies a particular exported application and package. The import user may have found this URL by browsing the public directory, or the exporting user may have simply emailed the URL to that user. When the import user clicks on the URL they are able to access, view and import the package.\n\nIn one aspect, installation is a multi-step process with one or more steps performed in the installation wizard. For example, in one aspect, the steps include providing a display of the package contents for the user to examine and confirm they want to install, configuring the security for the existing profiles in the installer's organization, importing the package contents, and deploying the application to the intended users. An import user may also choose to customize any items in the install package.\n\nIn certain aspects, some or all of the following steps may need to be performed or may occur during the package import and install process:\n\nLog into the recipient organization by entering a UseriD and Password. This is a user id for the recipient organization into which the package is to be imported.\n\nOptionally, the exporter may have password protected the package. If this is the case, the import user has to enter the package password before they can import it (this is a different password than the user password required to log into the recipient organization).\n\nIf object names in the package conflict with setup data in the recipient organization, the import process may fail. The import user may change the object names on conflicting objects within the recipient organization and restart the import process.\n\nDuring the import process, the recipient organization is locked to prevent inconsistent metadata updates.\n\nThe import process checks to make sure the importing user has appropriate organization permissions to import a package.\n\nThe import user is asked to define mappings from source organization specific references in the package to values appropriate for the recipient organization. For example, the import user may be prompted to specify a user id, profile or role.\n\nThe setup data is copied into the recipient organization in a âdevelopmentâ mode. This allows the import user to verify that the application functions correctly before deploying it to users within the recipient organization.\n\nThe import process scans the package for malicious functionality. For example, it can check for any Web Integration Links (WILs) that may post data to third party websites.\n\nIf specified in the package definition, the import user is unable to change any of the setup data in the package after it is imported. For example, the import user cannot add or remove fields from a custom object after it is imported if specified in the package definition. This is implemented by the custom object edit screen functionality checking the package definition tables before allowing any edits to an object in the recipient organization.\n\nThe import user can optionally âuninstallâ a package. This can be implemented because the system keeps track of which metadata objects belong to the package (e.g., through the package database schema).\n\nIn certain aspects, packages may be upgraded. For example, if a publisher/export user changes the source package, the import user can choose to pull into their organization the change(s) made by the publisher while preserving any data rows the subscriber had creating since first importing the package. According to certain aspect, one or more flags may be set in the package definition to determine whether and to what extent customizations to a package may be made and upgraded. In one aspect, a âmanageableâ field is provided to identify whether customizations to a particular object are subject to upgrade. For example, if the package or an object in the package is marked as managed, the user is allowed to customize the package or the object, and these customizations will not be altered upon upgrading of the package. In another aspect, a âcontrolâ field is provided to identify whether an object may be modified by the publisher and/or the subscriber. In another aspect, an âimmutableâ field is provided to identify whether an object can or cannot be altered by anyone. For example, the source user can set the immutable flag so that nobody is able to modify the packages after it has been published. An upgrade process that executes checks each of these fields, where present, to determine the extent that customizations are maintained upon upgrading.\n\nApplication Directory\n\nThe present invention also provides a central directory of applications; source users can register packages in a central directory. In one aspect, the central directory includes a public portion that includes published packages intended for use by anyone, and a private portion that includes packages not intended for general use (e.g., packages intended for use by import users as selected by the source user). The directory allows other users to browse published applications and choose which ones they want to install into their organization. In one aspect, the central directory is organized by a category hierarchy that allows users to search and browse by category for the types of application they're interested in. In one aspect, the directory allows users to âtry it nowââthey can look at the demonstration organization containing the package before they install it into their organization. In another aspect, the directory provides an automated approval process that assures submissions are acceptable before they appear in the public directory. In another aspect, the directory includes a ratings system that allows (import) users of an application to vote on an application's usefulness and quality. This voting appears in the public directory for other users to see.\n\nIn certain aspects, the directory is built using JSP pages, JSTL, a JSP tag library, JSP tags, and Java classes. In one aspect, data used by the directory is stored in an organization object managed by one or more directory administrators. Source users of applications may use the directory to input and maintain descriptive information held in a DirectoryEntry object for each application. Directory entries have an associated status field and only applications having a status of âpublishedâ or âpublicâ are rendered for a visitor. A status of âpreviewâ allows source users and directory administrators to see results as they will appear on the web before they become public. In one aspect, a display of applications according to solution categories is dynamically rendered based on a category picklist of values. An applications is tagged with the categories to which it belongs using a multiple select picklist. A new value may be added at any time to the picklist and category label to create a new category.\n\nRoles and Publishing Model\n\nExcept for visitors browsing the site, almost all other uses of the directory site should require the user to either login or have a valid session id. These users may play different roles and may have different permissions to perform actions according to these roles. For example, three basic roles might include developer, publisher, and importer.\n\nDevelopers should be able to hand responsibility for publishing the application over to another trusted person through creation of a publisher role and editing permissions. A publisher (which defaults to the developer himself) may be granted permission to create the original directory entry describing the application, modify it at a later date, add other publishers to assist, or even remove the entry from the directory. As used herein a source user can be either or both of a developer and a publisher.\n\nThe user id of the person logging into the directory is used to determine the roles and rights the user has in regards to each application. Users should have no real access to the organization in which the directory is kept. User id's are, however, used to uniquely identify users and to retrieve information from their own organizations when necessary.\n\nA developer is an original creator of the application and its package through a setup wizard. One (optional) step in the wizard is to submit the application for publication in the Directory. There, the developer, may either enter information himself or designate others to serve as the publisher and maintainer of the directory entry. A publisher of a given directory entry is a user who is responsible for entering and maintaining descriptive information about the application in the directory. Each application's directory entry has an assigned set of publishers along with permissions granted by the original submitter. These permissions give rights to edit fields, change status, remove the application from the directory or even add others as publishers (e.g., with the same or lesser permissions). An importer is any import user, e.g., system administrator of an organization or tenant, who has initiated the import process of an application for deployment in their own organization. During the import process, a record is created in the database system showing what organizations have which applications imported and by whom. This may be used to show how popular an application is and if it is desirable, to restrict comments and ratings to only those users of organizations that have the application installed. Individuals may participate in multiple roles at different times; i.e., a user may be a developer of one application and an import user for another.\n\nReview of Directory Information\n\nPublishers create an application's directory entry, input associated information such as a description, thumbnail, screenshots, and other information. Prior to becoming public, a publisher may preview this information at any time. When the information is ready to be made publicly available for viewing, the publisher changes the state to âsubmittedâ. In one aspect, this initiates a review of the application by a directory administrator, who may request further information, etc. Once the application has completed review, the directory administrator changes its state to âpublicâ. This makes the application available for public viewing within the directory. Depending upon the business process, the public state may also lock out any further changes by publishers. In this case, should the publisher need to update the directory entry after being made public, a request could be filed with the directory administrator to remove the entry from public view, e.g., by changing the state back to new. If it is desirable to allow publishers to modify entries without requesting permission to change and another round of review, a Modified flag in the directory entry can be used to simply indicate that a public entry has been changed.\n\nReputation Management through User Ratings and Comments\n\nIn one aspect, to give visitors an idea of what others think about each application, viewing users may assign a rating to the application and provide personal reviews in the form of comments. In one aspect, only users of organizations that have actually installed the application may provide comments and/or ratings. This entitlement could be deduced, for example, by looking at the import records created by system administrators who initiated the application installation.\n\nTo keep ratings an honest reflection of how the community rates the application, however, it may be necessary to provide some protection from users gaming the system by making multiple postings. In any case, users may want to change their rating of an application from what they initially rated. In one aspect, this is accomplished by treating the ratings system as one would voting; each user casts a vote for one of five possible star ratings associated with the application and each application keeps a tally of the votes for each of the possible ratings. It then becomes trivial to determine the average rating for each application and also yield a more informative histogram of the votes. Users may change their vote at any time, but no matter how many times they make a rating, they only get to vote once per application. A record is kept for each user of their current rating for applications that they have rated or commented on.\n\nDirectory Data Model\n\nFIG. 3 shows a data model for a Directory of applications according to one embodiment. As shown, the Directory data model according to this embodiment includes five main objects: DirectoryEntry, CategoryPage, Publisher, Import and UserReview. It should be appreciated that fewer or more objects may be used.\n\nThe DirectoryEntry object holds information pertaining to each individual application submitted for publication. Information is written to this table by the web site during application submission or modification and may be reviewed and modified by the appropriate internal directory support personnel. FIG. 4 shows a definition of a DirectoryEntry object and other objects according to one embodiment.\n\nAssociated with each entry in the DirectoryEntry object is a status field indicating the status of the directory record. The values allow coupling the external input and editing functions with an internal process of review and preview. Status values might include:\n\nNew: first created with only minimal information\n\nSubmitted: entry ready for internal review before publishing\n\nPreview: allows internal site provider personnel to preview information in the context of the site\n\nPublic: publishable, ready for public viewing\n\nInactive: no longer visible in the directory (deleted)\n\nWhen the state is changed to Public, the developer and other publishers for the application are notified, e.g., by e-mail, and a publish date field or variable is set.\n\nAccording to one aspect, each entry is associated with a multi-select picklist field representing the solution categories under which the application will be listed. The directory dynamically adapts to categories so they may be added at any time. For readability, in one aspect, the picklist values encode the category and/or subcategory into each name.\n\nThe total user votes for a rating, e.g., 1-5 stars, are stored in fields from which the average can be computed. Also, the system can determine and display the ratings for each 10 application, e.g., count how many applications were rated 1-star, 2-star, etc.\n\nThe CategoryPage object is used to form the category hierarchy driving the Directory's dynamic generation of category pages. This object also holds a title for the page along and a list of several applications to display as featured selections on the page.\n\nThe Publisher object holds the user id of a user (e.g., source user) responsible for creating and maintaining the application's directory entry along with their editing permissions. Examples of permission levels include:\n\nEdit: grants someone the right to edit the modifiable fields in the Directory Entry\n\nDelete: grants the user the right to delete the DirectoryEntry\n\nAddUser: grants the user the right to add additional users with the same or more restrictive rights.\n\nIn one aspect, permission ordering from most-to-least is Delete, AddUser, Edit.\n\nThe Import object acts as a record of what imports have been initiated of an application into any particular organization. This object holds ids of the DirectoryEntry (or package id), the system administrator importing the application, the organization affiliation of the system administrator, and the date of import. This object allows ranking of applications based on the number of imports and can be used, if desirable, to limit users to commenting and rating only on those applications that have been imported in their own organizations.\n\nThe UserReview object holds comments and ratings made by a specified user of a particular application entry. Restrictions may be imposed on who can add comments and rate applications such as only allowing authenticated users or even restricting only to those users in organizations that have imported the application. An implementation need not have any such restriction.\n\nImplementing Categories using CategoryPage Objects\n\nA useful user requirement on the Directory is to be able to see a list of applications by solution category. Any application may appear in any number of categories and categories are preferably nested. Additionally, to allow other views of the data, such as by business size or market segment, it is desirable to be list applications accord to different categorization schemes.\n\nAccording to one aspect, categories are assigned as the application of tags (out of a multi-select picklist) to each application entry. A user working on preparing the directory entry for an application is presented with the current categorization scheme in the form of a set of check boxes to indicate which categories apply to the application. The system will assign the necessary picklist values to the application's directory entry.\n\nTo make it easy for a directory administrator to manually make entries and run reports showing which applications are in which categories, in one aspect, each application entry contains a category field containing a multi-select picklist of available categories. For readability, picklist values representing a subcategory should show the path to subcategory, i.e., âConsumer+Gamesâ value would imply the application exists in the subcategory Games under the Consumer category. Multiple values place the application into multiple categories.\n\nBecause categories and their hierarchies are created for the purpose of generating category pages, the hierarchical representation of a particular category hierarchy uses a set of CategoryPage objects. In one aspect, a CategoryPage object exists for each category and/or subcategory available. CategoryPage objects are linked together to form a tree through fields specifying the node's own category and the category of its parent node. Root nodes, are indicated by CategoryPages which have no parent. (See, e.g., FIG. 5). Tree traversal is accomplished by query. For example, to find the labels of top level categories of a particular hierarchy, called All-Solutions, a query might look like:\n\nselect Label from CategoryPage_c where ParentNode_c=Â·All-Solutionsâ².\n\nIn one aspect, display nodes also carry additional information used by JSP pages rendering the list of applications falling into the specified category. This additional information includes a field for maintaining a count of associated applications, page title label, page body text, and applications to feature on the page.\n\nIn summary, directory supported user functions might include: For visitors (viewing and importing users):\n\nView application list filtered and sorted by business area (category), author, date submitted, rating, or other criteria\n\nView full application description (detail page)\n\nView full application specification/profile (such as # of objects, object names, web integration links (WILs), etc.)\n\nView aggregated user ratings of applications\n\nView âhighlightedâ applications according to business area or overall\n\nView top ranked applications\n\nView most popular applications\n\nSubmit/change their rating of individual applications (optional restriction)\n\nPost comments associated with individual applications (optional restriction)\n\nTry out application in app-specific demonstration organization\n\nImport application to their own organization\n\nFor developers (export users):\n\nView application packages that the developer developed\n\nSubmit application for publication along with associated descriptive information.\n\nRemove applications from the directory\n\nEdit/update application descriptions\n\nReceive email notification when application has been approved by provider review\n\nDelegate responsibility over the management and publication of the application to other users\n\nUpload images, pdfs, and other documents associated with the application as attachments to the DirectoryEntry\n\nMiscellaneous\n\nIn one alternate embodiment, rather than using a new type of organization (e.g., container organization) in the database schema to store an exported package, exported packages are implemented as binary large objects in the database (e.g., Oracle db) or as text or binary data stored in a flat file format. However, upgrade scripts may not work well against flat files. Therefore, in one embodiment, a package is implemented as a separate âhiddenâ organization within the database system (e.g., salesforce.com service). This advantageously allows release upgrade scripts to upgrade these exported organizations.\n\nIn one aspect, storing a foreign key to the unique package id on all setup data included in the package is performed instead of storing a package table including the primary keys of all objects in the package. However, the package table approach is preferred as it makes it more efficient to quickly determine which objects were included in the package at runtime. It may be desirable to determine which objects were included in the package at runtime to differentiate between installed packages from the base system or from each other. For example, in the custom object edit screens, custom objects that were imported as read only cannot be modified while all other custom objects (not imported) can be modified.\n\nWhile the invention has been described by way of example and in terms of the specific embodiments, it is to be understood that the invention is not limited to the disclosed embodiments. To the contrary, it is intended to cover various modifications and similar arrangements as would be apparent to those skilled in the art. Therefore, the scope of the appended claims should be accorded the broadest interpretation so as to encompass all such modifications and similar arrangements."
    }
}