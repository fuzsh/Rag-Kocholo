{
    "id": "dbpedia_6686_2",
    "rank": 79,
    "data": {
        "url": "https://www.regular-expressions.info/unicode.html",
        "read_more_link": "",
        "language": "en",
        "title": "Unicode Characters and Properties",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.regular-expressions.info/ads/728/rxbtutorial100.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Jan Goyvaerts"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://https://www.regular-expressions.info//unicode.html",
        "text": "Unicode Regular Expressions\n\nUnicode is a character set that aims to define all characters and glyphs from all human languages, living and dead. With more and more software being required to support multiple languages, or even just any language, Unicode has been strongly gaining popularity in recent years. Using different character sets for different languages is simply too cumbersome for programmers and users.\n\nUnfortunately, Unicode brings its own requirements and pitfalls when it comes to regular expressions. Of the regex flavors discussed in this tutorial, Java, XML and .NET use Unicode-based regex engines. Perl supports Unicode starting with version 5.6. PCRE can optionally be compiled with Unicode support. Note that PCRE is far less flexible in what it allows for the \\p tokens, despite its name “Perl-compatible”. The PHP preg functions, which are based on PCRE, support Unicode when the /u option is appended to the regular expression. Ruby supports Unicode escapes and properties in regular expressions starting with version 1.9. XRegExp brings support for Unicode properties to JavaScript.\n\nRegexBuddy’s regex engine is fully Unicode-based starting with version 2.0.0. RegexBuddy 1.x.x did not support Unicode at all. PowerGREP uses the same Unicode regex engine starting with version 3.0.0. Earlier versions would convert Unicode files to ANSI prior to grepping with an 8-bit (i.e. non-Unicode) regex engine. EditPad Pro supports Unicode starting with version 6.0.0.\n\nCharacters, Code Points, and Graphemes or How Unicode Makes a Mess of Things\n\nMost people would consider à a single character. Unfortunately, it need not be depending on the meaning of the word “character”.\n\nAll Unicode regex engines discussed in this tutorial treat any single Unicode code point as a single character. When this tutorial tells you that the dot matches any single character, this translates into Unicode parlance as “the dot matches any single Unicode code point”. In Unicode, à can be encoded as two code points: U+0061 (a) followed by U+0300 (grave accent). In this situation, . applied to à will match a without the accent. ^.$ will fail to match, since the string consists of two code points. ^..$ matches à.\n\nThe Unicode code point U+0300 (grave accent) is a combining mark. Any code point that is not a combining mark can be followed by any number of combining marks. This sequence, like U+0061 U+0300 above, is displayed as a single grapheme on the screen.\n\nUnfortunately, à can also be encoded with the single Unicode code point U+00E0 (a with grave accent). The reason for this duality is that many historical character sets encode “a with grave accent” as a single character. Unicode’s designers thought it would be useful to have a one-on-one mapping with popular legacy character sets, in addition to the Unicode way of separating marks and base letters (which makes arbitrary combinations not supported by legacy character sets possible).\n\nHow to Match a Single Unicode Grapheme\n\nMatching a single grapheme, whether it’s encoded as a single code point, or as multiple code points using combining marks, is easy in Perl, PCRE, PHP, Boost, Ruby 2.0, Java 9, and the Just Great Software applications: simply use \\X. You can consider \\X the Unicode version of the dot. There is one difference, though: \\X always matches line break characters, whereas the dot does not match line break characters unless you enable the dot matches newline matching mode.\n\nIn .NET, Java 8 and prior, and Ruby 1.9 you can use \\P{M}\\p{M}*+ or (?>\\P{M}\\p{M}*) as a reasonably close substitute. To match any number of graphemes, use (?>\\P{M}\\p{M}*)+ as a substitute for \\X+.\n\nMatching a Specific Code Point\n\nTo match a specific Unicode code point, use \\uFFFF where FFFF is the hexadecimal number of the code point you want to match. You must always specify 4 hexadecimal digits E.g. \\u00E0 matches à, but only when encoded as a single code point U+00E0.\n\nPerl, PCRE, Boost, and std::regex do not support the \\uFFFF syntax. They use \\x{FFFF} instead. You can omit leading zeros in the hexadecimal number between the curly braces. Since \\x by itself is not a valid regex token, \\x{1234} can never be confused to match \\x 1234 times. It always matches the Unicode code point U+1234. \\x{1234}{5678} will try to match code point U+1234 exactly 5678 times.\n\nIn Java, the regex token \\uFFFF only matches the specified code point, even when you turned on canonical equivalence. However, the same syntax \\uFFFF is also used to insert Unicode characters into literal strings in the Java source code. Pattern.compile(\"\\u00E0\") will match both the single-code-point and double-code-point encodings of à, while Pattern.compile(\"\\\\u00E0\") matches only the single-code-point version. Remember that when writing a regex as a Java string literal, backslashes must be escaped. The former Java code compiles the regex à, while the latter compiles \\u00E0. Depending on what you’re doing, the difference may be significant.\n\nJavaScript, which does not offer any Unicode support through its RegExp class, does support \\uFFFF for matching a single Unicode code point as part of its string syntax.\n\nXML Schema and XPath do not have a regex token for matching Unicode code points. However, you can easily use XML entities like &#xFFFF; to insert literal code points into your regular expression.\n\nUnicode Categories\n\nIn addition to complications, Unicode also brings new possibilities. One is that each Unicode character belongs to a certain category. You can match a single character belonging to the “letter” category with \\p{L}. You can match a single character not belonging to that category with \\P{L}.\n\nAgain, “character” really means “Unicode code point”. \\p{L} matches a single code point in the category “letter”. If your input string is à encoded as U+0061 U+0300, it matches a without the accent. If the input is à encoded as U+00E0, it matches à with the accent. The reason is that both the code points U+0061 (a) and U+00E0 (à) are in the category “letter”, while U+0300 is in the category “mark”.\n\nYou should now understand why \\P{M}\\p{M}*+ is the equivalent of \\X. \\P{M} matches a code point that is not a combining mark, while \\p{M}*+ matches zero or more code points that are combining marks. To match a letter including any diacritics, use \\p{L}\\p{M}*+. This last regex will always match à, regardless of how it is encoded. The possessive quantifier makes sure that backtracking doesn’t cause \\P{M}\\p{M}*+ to match a non-mark without the combining marks that follow it, which \\X would never do.\n\nPCRE, PHP, and .NET are case sensitive when it checks the part between curly braces of a \\p token. \\p{Zs} will match any kind of space character, while \\p{zs} will throw an error. All other regex engines described in this tutorial will match the space in both cases, ignoring the case of the category between the curly braces. Still, I recommend you make a habit of using the same uppercase and lowercase combination as I did in the list of properties below. This will make your regular expressions work with all Unicode regex engines.\n\nIn addition to the standard notation, \\p{L}, Java, Perl, PCRE, the JGsoft engine, and XRegExp 3 allow you to use the shorthand \\pL. The shorthand only works with single-letter Unicode properties. \\pLl is not the equivalent of \\p{Ll}. It is the equivalent of \\p{L}l which matches Al or àl or any Unicode letter followed by a literal l.\n\nPerl, XRegExp, and the JGsoft engine also support the longhand \\p{Letter}. You can find a complete list of all Unicode properties below. You may omit the underscores or use hyphens or spaces instead.\n\n\\p{L} or \\p{Letter}: any kind of letter from any language.\n\n\\p{Ll} or \\p{Lowercase_Letter}: a lowercase letter that has an uppercase variant.\n\n\\p{Lu} or \\p{Uppercase_Letter}: an uppercase letter that has a lowercase variant.\n\n\\p{Lt} or \\p{Titlecase_Letter}: a letter that appears at the start of a word when only the first letter of the word is capitalized.\n\n\\p{L&} or \\p{Cased_Letter}: a letter that exists in lowercase and uppercase variants (combination of Ll, Lu and Lt).\n\n\\p{Lm} or \\p{Modifier_Letter}: a special character that is used like a letter.\n\n\\p{Lo} or \\p{Other_Letter}: a letter or ideograph that does not have lowercase and uppercase variants.\n\n\\p{M} or \\p{Mark}: a character intended to be combined with another character (e.g. accents, umlauts, enclosing boxes, etc.).\n\n\\p{Mn} or \\p{Non_Spacing_Mark}: a character intended to be combined with another character without taking up extra space (e.g. accents, umlauts, etc.).\n\n\\p{Mc} or \\p{Spacing_Combining_Mark}: a character intended to be combined with another character that takes up extra space (vowel signs in many Eastern languages).\n\n\\p{Me} or \\p{Enclosing_Mark}: a character that encloses the character it is combined with (circle, square, keycap, etc.).\n\n\\p{Z} or \\p{Separator}: any kind of whitespace or invisible separator.\n\n\\p{Zs} or \\p{Space_Separator}: a whitespace character that is invisible, but does take up space.\n\n\\p{Zl} or \\p{Line_Separator}: line separator character U+2028.\n\n\\p{Zp} or \\p{Paragraph_Separator}: paragraph separator character U+2029.\n\n\\p{S} or \\p{Symbol}: math symbols, currency signs, dingbats, box-drawing characters, etc.\n\n\\p{Sm} or \\p{Math_Symbol}: any mathematical symbol.\n\n\\p{Sc} or \\p{Currency_Symbol}: any currency sign.\n\n\\p{Sk} or \\p{Modifier_Symbol}: a combining character (mark) as a full character on its own.\n\n\\p{So} or \\p{Other_Symbol}: various symbols that are not math symbols, currency signs, or combining characters.\n\n\\p{N} or \\p{Number}: any kind of numeric character in any script.\n\n\\p{Nd} or \\p{Decimal_Digit_Number}: a digit zero through nine in any script except ideographic scripts.\n\n\\p{Nl} or \\p{Letter_Number}: a number that looks like a letter, such as a Roman numeral.\n\n\\p{No} or \\p{Other_Number}: a superscript or subscript digit, or a number that is not a digit 0–9 (excluding numbers from ideographic scripts).\n\n\\p{P} or \\p{Punctuation}: any kind of punctuation character.\n\n\\p{Pd} or \\p{Dash_Punctuation}: any kind of hyphen or dash.\n\n\\p{Ps} or \\p{Open_Punctuation}: any kind of opening bracket.\n\n\\p{Pe} or \\p{Close_Punctuation}: any kind of closing bracket.\n\n\\p{Pi} or \\p{Initial_Punctuation}: any kind of opening quote.\n\n\\p{Pf} or \\p{Final_Punctuation}: any kind of closing quote.\n\n\\p{Pc} or \\p{Connector_Punctuation}: a punctuation character such as an underscore that connects words.\n\n\\p{Po} or \\p{Other_Punctuation}: any kind of punctuation character that is not a dash, bracket, quote or connector.\n\n\\p{C} or \\p{Other}: invisible control characters and unused code points.\n\n\\p{Cc} or \\p{Control}: an ASCII or Latin-1 control character: 0x00–0x1F and 0x7F–0x9F.\n\n\\p{Cf} or \\p{Format}: invisible formatting indicator.\n\n\\p{Co} or \\p{Private_Use}: any code point reserved for private use.\n\n\\p{Cs} or \\p{Surrogate}: one half of a surrogate pair in UTF-16 encoding.\n\n\\p{Cn} or \\p{Unassigned}: any code point to which no character has been assigned.\n\nUnicode Scripts\n\nThe Unicode standard places each assigned code point (character) into one script. A script is a group of code points used by a particular human writing system. Some scripts like Thai correspond with a single human language. Other scripts like Latin span multiple languages.\n\nSome languages are composed of multiple scripts. There is no Japanese Unicode script. Instead, Unicode offers the Hiragana, Katakana, Han, and Latin scripts that Japanese documents are usually composed of.\n\nA special script is the Common script. This script contains all sorts of characters that are common to a wide range of scripts. It includes all sorts of punctuation, whitespace and miscellaneous symbols.\n\nAll assigned Unicode code points (those matched by \\P{Cn}) are part of exactly one Unicode script. All unassigned Unicode code points (those matched by \\p{Cn}) are not part of any Unicode script at all.\n\nThe JGsoft engine, Perl, PCRE, PHP, Ruby 1.9, Delphi, and XRegExp can match Unicode scripts. Here’s a list:\n\n\\p{Common}\n\n\\p{Arabic}\n\n\\p{Armenian}\n\n\\p{Bengali}\n\n\\p{Bopomofo}\n\n\\p{Braille}\n\n\\p{Buhid}\n\n\\p{Canadian_Aboriginal}\n\n\\p{Cherokee}\n\n\\p{Cyrillic}\n\n\\p{Devanagari}\n\n\\p{Ethiopic}\n\n\\p{Georgian}\n\n\\p{Greek}\n\n\\p{Gujarati}\n\n\\p{Gurmukhi}\n\n\\p{Han}\n\n\\p{Hangul}\n\n\\p{Hanunoo}\n\n\\p{Hebrew}\n\n\\p{Hiragana}\n\n\\p{Inherited}\n\n\\p{Kannada}\n\n\\p{Katakana}\n\n\\p{Khmer}\n\n\\p{Lao}\n\n\\p{Latin}\n\n\\p{Limbu}\n\n\\p{Malayalam}\n\n\\p{Mongolian}\n\n\\p{Myanmar}\n\n\\p{Ogham}\n\n\\p{Oriya}\n\n\\p{Runic}\n\n\\p{Sinhala}\n\n\\p{Syriac}\n\n\\p{Tagalog}\n\n\\p{Tagbanwa}\n\n\\p{TaiLe}\n\n\\p{Tamil}\n\n\\p{Telugu}\n\n\\p{Thaana}\n\n\\p{Thai}\n\n\\p{Tibetan}\n\n\\p{Yi}\n\nPerl and the JGsoft flavor allow you to use \\p{IsLatin} instead of \\p{Latin}. The “Is” syntax is useful for distinguishing between scripts and blocks, as explained in the next section. PCRE, PHP, and XRegExp do not support the “Is” prefix.\n\nJava 7 adds support for Unicode scripts. Unlike the other flavors, Java 7 requires the “Is” prefix.\n\nUnicode Blocks\n\nThe Unicode standard divides the Unicode character map into different blocks or ranges of code points. Each block is used to define characters of a particular script like “Tibetan” or belonging to a particular group like “Braille Patterns”. Most blocks include unassigned code points, reserved for future expansion of the Unicode standard.\n\nNote that Unicode blocks do not correspond 100% with scripts. An essential difference between blocks and scripts is that a block is a single contiguous range of code points, as listed below. Scripts consist of characters taken from all over the Unicode character map. Blocks may include unassigned code points (i.e. code points matched by \\p{Cn}). Scripts never include unassigned code points. Generally, if you’re not sure whether to use a Unicode script or Unicode block, use the script.\n\nFor example, the Currency block does not include the dollar and yen symbols. Those are found in the Basic_Latin and Latin-1_Supplement blocks instead, even though both are currency symbols, and the yen symbol is not a Latin character. This is for historical reasons, because the ASCII standard includes the dollar sign, and the ISO-8859 standard includes the yen sign. You should not blindly use any of the blocks listed below based on their names. Instead, look at the ranges of characters they actually match. A tool like RegexBuddy can be very helpful with this. The Unicode property \\p{Sc} or \\p{Currency_Symbol} would be a better choice than the Unicode block \\p{InCurrency_Symbols} when trying to find all currency symbols.\n\n\\p{InBasic_Latin}: U+0000–U+007F\n\n\\p{InLatin-1_Supplement}: U+0080–U+00FF\n\n\\p{InLatin_Extended-A}: U+0100–U+017F\n\n\\p{InLatin_Extended-B}: U+0180–U+024F\n\n\\p{InIPA_Extensions}: U+0250–U+02AF\n\n\\p{InSpacing_Modifier_Letters}: U+02B0–U+02FF\n\n\\p{InCombining_Diacritical_Marks}: U+0300–U+036F\n\n\\p{InGreek_and_Coptic}: U+0370–U+03FF\n\n\\p{InCyrillic}: U+0400–U+04FF\n\n\\p{InCyrillic_Supplementary}: U+0500–U+052F\n\n\\p{InArmenian}: U+0530–U+058F\n\n\\p{InHebrew}: U+0590–U+05FF\n\n\\p{InArabic}: U+0600–U+06FF\n\n\\p{InSyriac}: U+0700–U+074F\n\n\\p{InThaana}: U+0780–U+07BF\n\n\\p{InDevanagari}: U+0900–U+097F\n\n\\p{InBengali}: U+0980–U+09FF\n\n\\p{InGurmukhi}: U+0A00–U+0A7F\n\n\\p{InGujarati}: U+0A80–U+0AFF\n\n\\p{InOriya}: U+0B00–U+0B7F\n\n\\p{InTamil}: U+0B80–U+0BFF\n\n\\p{InTelugu}: U+0C00–U+0C7F\n\n\\p{InKannada}: U+0C80–U+0CFF\n\n\\p{InMalayalam}: U+0D00–U+0D7F\n\n\\p{InSinhala}: U+0D80–U+0DFF\n\n\\p{InThai}: U+0E00–U+0E7F\n\n\\p{InLao}: U+0E80–U+0EFF\n\n\\p{InTibetan}: U+0F00–U+0FFF\n\n\\p{InMyanmar}: U+1000–U+109F\n\n\\p{InGeorgian}: U+10A0–U+10FF\n\n\\p{InHangul_Jamo}: U+1100–U+11FF\n\n\\p{InEthiopic}: U+1200–U+137F\n\n\\p{InCherokee}: U+13A0–U+13FF\n\n\\p{InUnified_Canadian_Aboriginal_Syllabics}: U+1400–U+167F\n\n\\p{InOgham}: U+1680–U+169F\n\n\\p{InRunic}: U+16A0–U+16FF\n\n\\p{InTagalog}: U+1700–U+171F\n\n\\p{InHanunoo}: U+1720–U+173F\n\n\\p{InBuhid}: U+1740–U+175F\n\n\\p{InTagbanwa}: U+1760–U+177F\n\n\\p{InKhmer}: U+1780–U+17FF\n\n\\p{InMongolian}: U+1800–U+18AF\n\n\\p{InLimbu}: U+1900–U+194F\n\n\\p{InTai_Le}: U+1950–U+197F\n\n\\p{InKhmer_Symbols}: U+19E0–U+19FF\n\n\\p{InPhonetic_Extensions}: U+1D00–U+1D7F\n\n\\p{InLatin_Extended_Additional}: U+1E00–U+1EFF\n\n\\p{InGreek_Extended}: U+1F00–U+1FFF\n\n\\p{InGeneral_Punctuation}: U+2000–U+206F\n\n\\p{InSuperscripts_and_Subscripts}: U+2070–U+209F\n\n\\p{InCurrency_Symbols}: U+20A0–U+20CF\n\n\\p{InCombining_Diacritical_Marks_for_Symbols}: U+20D0–U+20FF\n\n\\p{InLetterlike_Symbols}: U+2100–U+214F\n\n\\p{InNumber_Forms}: U+2150–U+218F\n\n\\p{InArrows}: U+2190–U+21FF\n\n\\p{InMathematical_Operators}: U+2200–U+22FF\n\n\\p{InMiscellaneous_Technical}: U+2300–U+23FF\n\n\\p{InControl_Pictures}: U+2400–U+243F\n\n\\p{InOptical_Character_Recognition}: U+2440–U+245F\n\n\\p{InEnclosed_Alphanumerics}: U+2460–U+24FF\n\n\\p{InBox_Drawing}: U+2500–U+257F\n\n\\p{InBlock_Elements}: U+2580–U+259F\n\n\\p{InGeometric_Shapes}: U+25A0–U+25FF\n\n\\p{InMiscellaneous_Symbols}: U+2600–U+26FF\n\n\\p{InDingbats}: U+2700–U+27BF\n\n\\p{InMiscellaneous_Mathematical_Symbols-A}: U+27C0–U+27EF\n\n\\p{InSupplemental_Arrows-A}: U+27F0–U+27FF\n\n\\p{InBraille_Patterns}: U+2800–U+28FF\n\n\\p{InSupplemental_Arrows-B}: U+2900–U+297F\n\n\\p{InMiscellaneous_Mathematical_Symbols-B}: U+2980–U+29FF\n\n\\p{InSupplemental_Mathematical_Operators}: U+2A00–U+2AFF\n\n\\p{InMiscellaneous_Symbols_and_Arrows}: U+2B00–U+2BFF\n\n\\p{InCJK_Radicals_Supplement}: U+2E80–U+2EFF\n\n\\p{InKangxi_Radicals}: U+2F00–U+2FDF\n\n\\p{InIdeographic_Description_Characters}: U+2FF0–U+2FFF\n\n\\p{InCJK_Symbols_and_Punctuation}: U+3000–U+303F\n\n\\p{InHiragana}: U+3040–U+309F\n\n\\p{InKatakana}: U+30A0–U+30FF\n\n\\p{InBopomofo}: U+3100–U+312F\n\n\\p{InHangul_Compatibility_Jamo}: U+3130–U+318F\n\n\\p{InKanbun}: U+3190–U+319F\n\n\\p{InBopomofo_Extended}: U+31A0–U+31BF\n\n\\p{InKatakana_Phonetic_Extensions}: U+31F0–U+31FF\n\n\\p{InEnclosed_CJK_Letters_and_Months}: U+3200–U+32FF\n\n\\p{InCJK_Compatibility}: U+3300–U+33FF\n\n\\p{InCJK_Unified_Ideographs_Extension_A}: U+3400–U+4DBF\n\n\\p{InYijing_Hexagram_Symbols}: U+4DC0–U+4DFF\n\n\\p{InCJK_Unified_Ideographs}: U+4E00–U+9FFF\n\n\\p{InYi_Syllables}: U+A000–U+A48F\n\n\\p{InYi_Radicals}: U+A490–U+A4CF\n\n\\p{InHangul_Syllables}: U+AC00–U+D7AF\n\n\\p{InHigh_Surrogates}: U+D800–U+DB7F\n\n\\p{InHigh_Private_Use_Surrogates}: U+DB80–U+DBFF\n\n\\p{InLow_Surrogates}: U+DC00–U+DFFF\n\n\\p{InPrivate_Use_Area}: U+E000–U+F8FF\n\n\\p{InCJK_Compatibility_Ideographs}: U+F900–U+FAFF\n\n\\p{InAlphabetic_Presentation_Forms}: U+FB00–U+FB4F\n\n\\p{InArabic_Presentation_Forms-A}: U+FB50–U+FDFF\n\n\\p{InVariation_Selectors}: U+FE00–U+FE0F\n\n\\p{InCombining_Half_Marks}: U+FE20–U+FE2F\n\n\\p{InCJK_Compatibility_Forms}: U+FE30–U+FE4F\n\n\\p{InSmall_Form_Variants}: U+FE50–U+FE6F\n\n\\p{InArabic_Presentation_Forms-B}: U+FE70–U+FEFF\n\n\\p{InHalfwidth_and_Fullwidth_Forms}: U+FF00–U+FFEF\n\n\\p{InSpecials}: U+FFF0–U+FFFF\n\nNot all Unicode regex engines use the same syntax to match Unicode blocks. Java, Ruby 2.0, and XRegExp use the \\p{InBlock} syntax as listed above. .NET and XML use \\p{IsBlock} instead. Perl and the JGsoft flavor support both notations. I recommend you use the “In” notation if your regex engine supports it. “In” can only be used for Unicode blocks, while “Is” can also be used for Unicode properties and scripts, depending on the regular expression flavor you’re using. By using “In”, it’s obvious you’re matching a block and not a similarly named property or script.\n\nIn .NET and XML, you must omit the underscores but keep the hyphens in the block names. E.g. Use \\p{IsLatinExtended-A} instead of \\p{InLatin_Extended-A}. In Java, you must omit the hyphens. .NET and XML also compare the names case sensitively, while Perl, Ruby, and the JGsoft flavor compare them case insensitively. Java 4 is case sensitive. Java 5 and later are case sensitive for the “Is” prefix but not for the block names themselves.\n\nThe actual names of the blocks are the same in all regular expression engines. The block names are defined in the Unicode standard. PCRE and PHP do not support Unicode blocks, even though they support Unicode scripts.\n\nDo You Need To Worry About Different Encodings?\n\nWhile you should always keep in mind the pitfalls created by the different ways in which accented characters can be encoded, you don’t always have to worry about them. If you know that your input string and your regex use the same style, then you don’t have to worry about it at all. This process is called Unicode normalization. All programming languages with native Unicode support, such as Java, C# and VB.NET, have library routines for normalizing strings. If you normalize both the subject and regex before attempting the match, there won’t be any inconsistencies.\n\nIf you are using Java, you can pass the CANON_EQ flag as the second parameter to Pattern.compile(). This tells the Java regex engine to consider canonically equivalent characters as identical. The regex à encoded as U+00E0 matches à encoded as U+0061 U+0300, and vice versa. None of the other regex engines currently support canonical equivalence while matching.\n\nIf you type the à key on the keyboard, all word processors that I know of will insert the code point U+00E0 into the file. So if you’re working with text that you typed in yourself, any regex that you type in yourself will match in the same way.\n\nFinally, if you’re using PowerGREP to search through text files encoded using a traditional Windows (often called “ANSI”) or ISO-8859 code page, PowerGREP always uses the one-on-one substitution. Since all the Windows or ISO-8859 code pages encode accented characters as a single code point, nearly all software uses a single Unicode code point for each character when converting the file to Unicode.\n\n| Quick Start | Tutorial | Tools & Languages | Examples | Reference | Book Reviews |\n\n| Introduction | Table of Contents | Special Characters | Non-Printable Characters | Regex Engine Internals | Character Classes | Character Class Subtraction | Character Class Intersection | Shorthand Character Classes | Dot | Anchors | Word Boundaries | Alternation | Optional Items | Repetition | Grouping & Capturing | Backreferences | Backreferences, part 2 | Named Groups | Relative Backreferences | Branch Reset Groups | Free-Spacing & Comments | Unicode | Mode Modifiers | Atomic Grouping | Possessive Quantifiers | Lookahead & Lookbehind | Lookaround, part 2 | Keep Text out of The Match | Conditionals | Balancing Groups | Recursion | Subroutines | Infinite Recursion | Recursion & Quantifiers | Recursion & Capturing | Recursion & Backreferences | Recursion & Backtracking | POSIX Bracket Expressions | Zero-Length Matches | Continuing Matches |"
    }
}