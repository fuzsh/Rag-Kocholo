{
    "id": "correct_foundationPlace_00107_3",
    "rank": 94,
    "data": {
        "url": "https://cipherstash.com/docs/concepts/database-proxy",
        "read_more_link": "",
        "language": "en",
        "title": "Protect Data, Not Just Systems.",
        "top_image": "https://cipherstash.com/favicon.ico",
        "meta_img": "https://cipherstash.com/favicon.ico",
        "images": [
            "https://px.ads.linkedin.com/collect/?pid=5466972&fmt=gif",
            "https://cipherstash.com/diagrams/concept-proxy-deployment-simple.drawio.svg",
            "https://cipherstash.com/diagrams/concept-proxy-deployment-load-balanced.drawio.svg",
            "https://cipherstash.com/diagrams/concept-proxy-actions.drawio.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Apply access control directly to your data with encryption-in-use that works everywhere, from SQL to Spreadsheet.",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "CipherStash Proxy helps you protect sensitive data in your SQL databases with no downtime or changes to client applications.\n\nCipherStash Proxy enhances your existing PostgreSQL database with Encryption-in-Use, data access event monitoring and fine-grained access control.\n\nCipherStash Proxy works in-tandem with your existing infrastructure and is fully contained within your environment.\n\nCipherStash Proxy is simple to deploy and completely transparent to any existing PostgreSQL client.\n\nWhat problem is CipherStash Proxy solving?\n\nCipherStash Proxy is the foundation that brings advanced auditing, identification, and encryption to PostgreSQL.\n\nAudit\n\nAuditing PostgreSQL data access requires a log of the actual records accessed connected with the identity of the user making the access request. PostgreSQL can log database statements, but a record of the executed SQL is not sufficient for understanding the actual records or rows returned. Analysis requires effort to combine logs from multiple services as there is often no single source of truth. Determining the extent of a data breach can be manual and time consuming.\n\nCipherStash Proxy tracks data access events in real-time by connecting sql statements with the actual records returned, and enabling applications to associate client identity.\n\nIdentify\n\nComplete visibility of data access requires the capability to identify the user making the access request.\n\nDatabase access is often tied to deployed application or service rather than an actual user identity. Applications connect to the database on behalf of users, creating an identity mismatch. PostgreSQL does have role-based authentication, but in most cases it is used to narrow the permissions for the database connection initatied by an application. Associating database access controls with an individual identity requires additional effort and is not covered by database statement logging.\n\nCipherStash Proxy enables end-user identity to be passed through and associated with data access.\n\nEncrypt\n\nProtecting data is much simpler if the data is encrypted. We have the technology to protect data, but the state of the art is not good enough.\n\nData is encrypted-at-rest but plaintext-in-use. Anyone connected to the database has full access to the plaintext. Loocking data access to the field level with strict access controls is possible, but again runs our good friend, identity impedance mismatch. Encrypting data inside the database is possible, but requires engineering effort and deep expertise in cryptography. Not all teams have the capacity to combine AES 256 and envelope encryption within a bloom filter structure to enable secure full-text search capabilities on encrypted data.\n\nCipherStash Proxy enables searchable encryption-in-use to protect data continuously.\n\nWhere CipherStash Proxy lives in the stack\n\nThe CipherStash Proxy is available as a Docker container and can be deployed in public or private cloud, on premises, and on any container runtime environment. The Proxy speaks the PostgreSQL protocol, based on the open source pgcat.\n\nTo any connecting client, the CipherStash Proxy should be indistinguishable from PostgreSQL.\n\nThe Proxy can be deployed:\n\nas single logical service managing database access across the container environment\n\nas multiple services managing database access aligned with specific services\n\nbaked into a Docker image managing database access within a single container\n\nIn development and CI, the Proxy can be managed with Docker compose or similar tools.\n\nIn production CipherStash Proxy can be deployed into your existing container infrastructure.\n\nMultiple instances can be deployed behind a load balancer for resilience.\n\nAdditionally, CipherStash Proxy is available as a binary for both amd64 and arm64 architectures. CipherStash can work with you to find the right deployment approach for your environment.\n\nDeployment\n\nDeploy to container environment\n\nDeploy to any container environment that supports Docker.\n\nLoad balanced deployment\n\nLoad balance traffic across several proxy instances for additional resilience.\n\nWhat CipherStash Proxy does\n\nCipherStash Proxy mediates access to your PostgreSQL database and analyses your SQL in real-time to Audit, Identify, and Encrypt. It:\n\nenables services to associate client identity and other contextual information with sql statements\n\ncaptures the record identifiers of data in transit\n\ncreates a complete audit log of all sql statements, record ids, associated identity and context\n\ntransparently encrypt and decrypt data without complex engineering\n\nAudit\n\nCipherStash Proxy connects to records to track data access events in real time.\n\nSee CipherStash Audit for further details.\n\nPrimary key injection\n\nPrimary key injection connects SQL statements to record identifiers.\n\nPrimary key injection transparently ensures that any data access event includes the actual record identifiers. No need to instrument or change your SQL.\n\nCipherStash Proxy uses the database schema to identify sql statements that do not reference a primary key. It injects the missing primary keys into the SQL before execution. Primary keys of accessed records can then be tracked with the data access event. The data is cleaned from the response before it is sent to the client.\n\nThe performance impact on the database is neglible as the primary key is by definition indexed, and the referenced tables are already present in the SQL statement.\n\nWhen combined with CipherStash Identify, the events are also linked to client identity, providing an end-to-end view of data access.\n\nRecord reconciliation\n\nRecord reconciliation extracts the record identifiers, maps them to the appropriate tables, and includes them in the data access event payload sent to Audit.\n\nInjected primary keys are always removed from the sql results before being returned. The process is internal to the CipherStash Proxy, the format of the result set always matches the original query.\n\nIdentify\n\nCipherStash Proxy enables end-user identity to be passed through and associated with data access.\n\nSee End-to-End Identity.\n\nPassthrough identity\n\nPassthrough Identity enables you to connect every SQL statement with real-world identity.\n\nUsing a custom SET CS_IDENTITY sql command, an end-user JWT is passed to the Proxy and validated.\n\nCipherStash Proxy uses the CipherStash Token Service to verify the JWT, extracts subject (sub) and audience (aud) data from the token, and associates this client identity information with data access events.\n\nSee Set Identity.\n\nPassthrough context\n\nPassthrough context provides the flexibility to associate any contextual data with the execution of any SQL statement.\n\nUsing a custom SET CS_CONTEXT sql command, a JSON object of key/values is passed to the Proxy and validated. This context information is associated with any data access events for auditing.\n\nSee Set Context.\n\nEncrypt\n\nCipherStash Proxy enables searchable encryption-in-use to protect data continuously. It supports several different types of encryption:\n\ncolumn encryption using AES256\n\nOrder Revealing Encryption (ORE) for encrypted sorting and filtering\n\nfull-text searchable encryption using AES 256 and envelope encryption with Bloom Filters\n\nencrypted exact matching using HMAC with SHA-256 Encryption\n\nColumns in the database can be configured to use one or more of the different encryption options. Every record is encrypted with a unique key using our Zero Trust Key Management Service.\n\nIn Encrypted mode, CipherStash Proxy inspects your incoming SQL statements, and transparently maps the SQL to access any configured encrypted columns. Data is automatically encrypted on write (insert and update) and decrypted on read (select). The underlying mechanics are totally hidden from your application and existing database access code does not need to change.\n\nWhat signals CipherStash Proxy emits\n\nCipherStash Proxy provides:\n\ndetailed SQL statement logging for development\n\nauditable data access event logging for use with the Audit application\n\ndetailed Prometheus metrics for monitoring and alerting\n\nEncryption-in-use\n\nEncryption-in-use offers a practical, production-ready solution to the cause of most data breaches."
    }
}