{
    "id": "wrong_mix_domain_foundationPlace_00104_1",
    "rank": 69,
    "data": {
        "url": "https://patents.google.com/patent/US20110258242A1/en",
        "read_more_link": "",
        "language": "en",
        "title": "US20110258242A1 - Methods and systems for appending data to large data volumes in a multi-tenant store - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/86/39/e3/2f684796199261/US20110258242A1-20111020-D00000.png",
            "https://patentimages.storage.googleapis.com/63/4f/3e/382358c7794240/US20110258242A1-20111020-D00001.png",
            "https://patentimages.storage.googleapis.com/04/85/60/9f61c869b97699/US20110258242A1-20111020-D00002.png",
            "https://patentimages.storage.googleapis.com/75/fe/05/e39a3fe9c9a33b/US20110258242A1-20111020-D00003.png",
            "https://patentimages.storage.googleapis.com/03/11/b5/15994d8defb793/US20110258242A1-20111020-D00004.png",
            "https://patentimages.storage.googleapis.com/e2/2d/d3/7f9f8210ad6bfc/US20110258242A1-20111020-D00005.png",
            "https://patentimages.storage.googleapis.com/46/db/6e/1722de564f909d/US20110258242A1-20111020-D00006.png",
            "https://patentimages.storage.googleapis.com/2c/0c/3c/80900d65ed635b/US20110258242A1-20111020-D00007.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2010-04-16T00:00:00",
        "summary": "",
        "meta_description": "In accordance with embodiments, there are provided mechanisms and methods for appending data to large data volumes in a multi-tenant store. These mechanisms and methods for appending data to large data volumes can enable embodiments to provide more reliable and faster maintenance of changing data. In an embodiment and by way of example, a method for appending data to large data volumes is provided. The method embodiment includes receiving new data for a database. The new data is written to a temporary log. The size of the log is compared to a threshold. Then the log is written to a data store, if the size of the log is greater than the threshold.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US20110258242A1/en",
        "text": "Methods and systems for appending data to large data volumes in a multi-tenant store Download PDF\n\nInfo\n\nPublication number\n\nUS20110258242A1\n\nUS20110258242A1 US12/961,809 US96180910A US2011258242A1 US 20110258242 A1 US20110258242 A1 US 20110258242A1 US 96180910 A US96180910 A US 96180910A US 2011258242 A1 US2011258242 A1 US 2011258242A1\n\nAuthority\n\nUS\n\nUnited States\n\nPrior art keywords\n\ndata\n\nlog\n\ndatabase\n\nwriting\n\nnew data\n\nPrior art date\n\n2010-04-16\n\nLegal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)\n\nGranted\n\nApplication number\n\nUS12/961,809\n\nOther versions\n\nUS10198463B2 (en\n\nInventor\n\nBill C. Eidson\n\nSimon Z. Fell\n\nCurrent Assignee (The listed assignees may be inaccurate. Google has not performed a legal analysis and makes no representation or warranty as to the accuracy of the list.)\n\nSalesforce Inc\n\nOriginal Assignee\n\nSalesforce com Inc\n\nPriority date (The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed.)\n\n2010-04-16\n\nFiling date\n\n2010-12-07\n\nPublication date\n\n2011-10-20\n\n2010-12-07 Application filed by Salesforce com Inc filed Critical Salesforce com Inc\n\n2010-12-07 Priority to US12/961,809 priority Critical patent/US10198463B2/en\n\n2011-10-20 Publication of US20110258242A1 publication Critical patent/US20110258242A1/en\n\n2014-05-13 Assigned to SALESFORCE.COM, INC. reassignment SALESFORCE.COM, INC. ASSIGNMENT OF ASSIGNORS INTEREST (SEE DOCUMENT FOR DETAILS). Assignors: EIDSON, BILL C., FELL, SIMON Z.\n\n2018-10-30 Priority to US16/175,651 priority patent/US11609895B2/en\n\n2019-02-05 Application granted granted Critical\n\n2019-02-05 Publication of US10198463B2 publication Critical patent/US10198463B2/en\n\nStatus Active legal-status Critical Current\n\n2031-10-24 Adjusted expiration legal-status Critical\n\nLinks\n\nUSPTO\n\nUSPTO PatentCenter\n\nUSPTO Assignment\n\nEspacenet\n\nGlobal Dossier\n\nDiscuss\n\nImages\n\nClassifications\n\nG—PHYSICS\n\nG06—COMPUTING; CALCULATING OR COUNTING\n\nG06F—ELECTRIC DIGITAL DATA PROCESSING\n\nG06F16/00—Information retrieval; Database structures therefor; File system structures therefor\n\nG06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data\n\nG06F16/22—Indexing; Data structures therefor; Storage structures\n\nG06F16/2282—Tablespace storage structures; Management thereof\n\nDefinitions\n\nthe present disclosure relates to storing data and, in particular, to aggregating data for storage in a common repository.\n\na user of such a conventional system typically retrieves data from and stores data on the system using the user's own systems.\n\na user system might remotely access one of a plurality of server systems that might in turn access the database system.\n\nData retrieval from the system might include the issuance of a query from the user system to the database system.\n\nthe database system might process the request for information received in the query and send to the user system information relevant to the request.\n\nthe rapid and efficient retrieval of accurate information and subsequent delivery of this information to the user system relies on the data in the database system complying with certain constraints. However, this limits the types, sizes, and kinds of data that can be stored in the database.\n\nthe database can be supplemented with an additional data store to hold other data and additional data.\n\nthe data can be searchable separately or pointers to the separate data store in the database can be searchable.\n\nthe separate data store adds complexity to modifying, correcting, and updating the database and the data store. This added complexity may interfere with users accessing the database and finding data in the separate data store.\n\na method for appending data to large data volumes includes receiving new data for a database.\n\nthe new data is written to a temporary log.\n\nthe size of the log is compared to a threshold.\n\nthe log is written to a data store, if the size of the log is greater than the threshold.\n\nany of the above embodiments may be used alone or together with one another in any combination.\n\nthe one or more implementations encompassed within this specification may also include embodiments that are only partially mentioned or alluded to or are not mentioned or alluded to at all in this brief summary or in the abstract.\n\nFIG. 1 illustrates a block diagram of a database server structure with appended data an a large data store in an embodiment\n\nFIG. 2 is an operational flow diagram illustrating serving a query at a user terminal in an embodiment\n\nFIG. 3 is an operational flow diagram illustrating serving a query at a database server in an embodiment\n\nFIG. 4 is an operational flow diagram illustrating updating data in a database server structure in an embodiment\n\nFIG. 4 is an operational flow diagram illustrating optimizing data in a database server structure in an embodiment\n\nFIG. 6 illustrates a block diagram of an example of an environment wherein an on-demand database service might be used.\n\nFIG. 7 illustrates a block diagram of an embodiment of elements of FIG. 5 and various possible interconnections between these elements.\n\nSystems and methods are provided for appending data to large data volumes. These systems and methods are particularly valuable in the context of a multi-tenant database.\n\nmulti-tenant database system refers to those systems in which various elements of hardware and software of the database system may be shared by one or more customers. For example, a given application server may simultaneously process requests for a great number of customers, and a given database table may store rows for a potentially much greater number of customers.\n\nquery plan refers to a set of steps used to access information in a database system.\n\na database served and accessed through a database server is augmented with a separate data store.\n\nthe separate data store has a simple file structure with directories and metadata such as ZFS (an open source file system developed by Sun Microsystems), although a different, simpler, or more complex file structure can be used depending on the application.\n\nthe files can be accessed through indices, pointers, or references in the database.\n\nthe data stores files are write-once files with no append capability and a minimum data size, such as 10 MB. The data store therefore can be used to create a small number of large files.\n\nthe described techniques can be applied to other data store systems with different configuration and constraints. Other databases and file formats can also be supported utilizing similar techniques.\n\ndata such as database segments\n\ndata store will be stored in the data store, however, because the data store does not work well with smaller files and cannot append, this data will only be written once there is enough data (perhaps 10 MB) to be aggregated into a larger file.\n\nthe types of data to be aggregated can include incremental data for the database such as inserts, updates, deletes, and supplemental data.\n\nThis data can be accumulated in a database table (called, for example AppendLog), and, once the data in the AppendLog reaches the predetermined size limit, it is flushed to the data store.\n\nthe database table or tables are subject to queries through application servers.\n\nthe queries may be in any of a variety of different forms, such as OQL (Object Query Language), SQL (Structured Query Language) queries, individual get-by-id requests, or any other type of query, for example.\n\nOQL Object Query Language\n\nSQL Structured Query Language\n\nqueries come to the database server, they need to be performed against both the database server AppendLog and the data store segments.\n\nthe database servers need an up-to-date copy of the entire AppendLog and the data store segment metadata.\n\nthe application server when submitting a query request, can, as part of the request, ensure that the database server has an up-to-date copy of the AppendLog data and the data store segment metadata (cached) prior to forwarding the request to the database server.\n\nFIG. 1 shows a block diagram of a database server structure to aid in understanding the description below.\n\na user, client, or customer through a user terminal 102 sends a request to an application server 104 .\n\nthe user terminal may be directly connected or remotely connected to the application server.\n\nthe user terminal may be connected though a wide area network, such as the Internet 110 , or through a local or private network.\n\nthe user request may be to view or receive data or information or to modify or add to data or information that is already stored.\n\nthe application server 104 is coupled to a database server 106 which serves or receives the information of the request to or from the application server.\n\nthe database server includes a table 112 in which the data is stored. This data may contain an append log 114 and a segment file 116 .\n\nthe append log contains some number of smaller files and additional files are appended to it as changes are made to the content of the database. As described below, the append log is eventually consolidated into a single file that is stored and a new append log can be started in its place.\n\nthe segment file contains metadata about files that are stored in another location.\n\nthe metadata can include file names, ordering, location, and contents information. Alternatively, the append log and segment file may be stored in another location.\n\nthe table may be in the form of a conventional relational database or in any other form.\n\nthe application server is also coupled to a data store 108 , as described above.\n\nthe data store stores segment files 118 and may also store a variety of other files, depending on the particular use made of the data store.\n\na query or other request from the application server is provided only to the database server.\n\nthe files of the data store are not searched.\n\nthe table includes searchable pointers or indices to the data in the data store. This allows requests to be serviced more quickly.\n\nthe data store may contain the pointers or indices or may be searched directly.\n\nthe data store includes stored segment files 118 which may be organized using its file system.\n\nthe application server also include an append log 120 and a segment file 122 . These allow the application server to track changes and progress to both the append log and the segment file in order to manage the collection, updating, and storing of such data. These may both be saved by the database server, instead, depending upon the application. There may be and typically will be multiple user terminals, application servers, database servers, and data stores. The diagram of FIG. 1 shows only one of each in order to simplify the drawing and the understanding of the operations described below.\n\nthe database servers are stateless. They locally cache immutable files and have an in-memory cache of immutable data structures. However, they do not have any âon_startupâ bootstrapping or any cross-server synchronization of changes, etc.\n\nan in-memory cache By providing an in-memory cache, the entire database server state (in the database) does not need to be re-created for every request.\n\nthe in-memory cache allows the tables and other data to be synchronized without any startup process. As described below, incremental changes are handled, while the servers are kept stateless, and the data store file metadata is stored in the database.\n\nFIG. 2 shows an example process for serving a query or other data modification to a database server in the context of the append log and segment file.\n\nFIG. 2 is from the perspective of the application server, while FIG. 3 shows the same process from the perspective of the database server.\n\na process begins, at block 204 , when the application server receives a request from a user.\n\nthe request could come from a maintenance application or a developer.\n\nthe request may be to delete an entry in the database, add an entry, modify an entry or perform a much more complex operation.\n\nthe data store is also used to hold large files, such as media, graphic, and high resolution files that are not well-suited to the database. Accordingly, the request may be to add a reference, index, pointer or metadata into the database to allow such a file in the data store to be searched and found from the database.\n\nthe application server having received the request, sends it to a database server that can access the database to service the request.\n\nthe request can contain a current sequence number, so that the database server can ensure that it is working with current data.\n\nthe application server accesses a table which provides the most current sequence number for the append log and the segment file.\n\nthe database server at block 304 receives the query request from the application server as mentioned above.\n\nthe database server compares the received sequence number for its cached version of the append log and segment file to the received sequence number at block 306 . If they match, then the database server processes the request at block 314 .\n\nthe request can be safely processed against the database and also the append log, since the append log will be in its most current form.\n\nthe database server can request that it be sent the latest updates at block 308 .\n\nthe application server at block 206 listens for a catch up request at block 208 . If one is received, then at block 210 , the application server builds an append log and segment file to send to the database server. This may then be sent together with the query request at block 212 .\n\nthe response to the catch up request can be a complete replacement of the prior append log and segment file, or to reduce the amount of transmitted data between the two servers, the response can contain only the data added since the database server's version was last updated.\n\nthe database server for example, can send its most recent sequence number together with its catch up request. By comparing the database server's most recent number to the absolute most recent version, the application server can determine the differences and send only the differences.\n\nthe application server does not send the append log and segment files or their updates with the original request. This is done to reduce the amount of data sent with a request.\n\nboth files may be maintained in a single version and sent to the respective database server in the latest version with each request. The size of the these files can be kept small through frequent updates of the data store or by generating many files.\n\nEach tenant, organization, customer etc. may have several different files for different portions of the database fields.\n\nboth the application server and the database server maintain relational database tables and the append logs and segment files are stored in these tables.\n\nthe append logs and segment files may be stored in any of a variety of different locations in the database that provide sufficient space for the data.\n\na BLOB Binary Large Object\n\nthe BLOB allows several gigabytes of unstructured storage.\n\nthe data may be structured but it need not be structured in a way that is consistent with the rest of the database.\n\nthe database server receives the response to the catch up request including a partial or complete append log and segment file. After applying the updates at block 312 , by updating or replacing, the database server can then process the request at block 314 .\n\nthe results are sent back to the application server.\n\nthe application server receives the results and can then service the user at block 216 , with a confirmation, report, or reply, depending on the nature of the request.\n\nthe database is divided into groups, organizations, etc. so that, while there may be many append logs and segment files, each one is not very large. This is one reason why any one database server may not be up to date for any one particular table.\n\nsequence_number can be used to manage server state for each organization or database table.\n\nthe sequence number can be used to represent the current state of any given database server organization or table.\n\na table such as Table 1, can be used to track the sequence number.\n\nthe table may use standard 32-way organization partitioning and be an index organized table, however it may also take other forms.\n\nthe PK (Primary Key) for the table may be selected as table_id, or any other suitable key.\n\nthe organization identification and the table enumerator are represented as 15 character values, while the sequence number is a number. Any desired string of characters, letter, or number may be used, depending on the application. In the described examples it is either 0 or 1, however a greater range of numbers may be used, depending on the application.\n\nthe sequence, number as described above can be used in all of the different databases in which it occurs.\n\nthe sequence number in any newly visible rows can be checked against an outside source, such as the application server, to ensure that it is greater than all previously visible sequence numbers for that particular organization and table. Based on this check, the integrity of the data can be maintained without an autonomous updating transaction. Instead, the row for this table can be locked and incremented as part of the transaction.\n\nrequests to database servers may contain header information in order to convey the current database server state (core_sequence_num, core_append_log, core_segment_file) for the relevant organization, table_ids involved in the operation.\n\ntable_ids involved in the operation For example, a âgetâ operation would only need the table being âgotâ, but an OQL request would need an entry for each involved table_id).\n\neach request from the application server to the database server contains for-each table_id in any one organization, a header structure containing: current_sequence_number (from core_sequence_number); and an optional âcatch upâ block.\n\nthe catch up block contains: catchup_from_core_sequence_number; the data from core_segment_file from catchup_sequence_number to current_sequence_number; the data from core_append_log from catchup_sequence_number to current_sequence_number; and any of the schemas from the core_append_log_schema that are required.\n\nthe database server always has an up-to-date copy (cached) of the core_append_log and the core_segment_files prior to executing any request; it is logically equivalent to transferring the entire state with every request, but, for efficiency purposes, the server cache ensures that, on-average, only the new append_log data is sent.\n\nthe append log may also be stored in a database table as shown by the example of Table 2.\n\nthe raw_data/raw_data_blob part of the table stores the actual data of the append log. Typically data is simply appended to this field as it is developed.\n\nthe data may be stored in any of a variety of different ways.\n\nthe data is stored as Avro serialized binary data.\n\nAvro is a data serialization system from the Apache Software Foundation Each time there is an insert, update, or delete, a row or set of rows is added to the field in a compressed form. For batch inserts or updates, an append_log row may be created for each insert with the raw_data/raw_data_blob storing the set of data. While Avro serialization is described herein, any of a variety of other data storing techniques may be used instead or in addition.\n\nFIG. 4 shows an example of using the segment file, append log and the tables above to update data in the system.\n\nthe same or a similar process may be used for deletions, insertions, and other changes.\n\nthe application server receives a request to modify data. This can be an addition, deletion, or change. As mentioned above, this request may be in the form of OQL or any other suitable form, depending on the particular implementation and system needs.\n\nthe application sever locates the cache with which it will service the request. This corresponds to the core segment file and the core append log. If there is only one application server, the core files may reside with the application server, but they may also reside in another location.\n\nthe application server upon receiving the request, modifies the data in the cache based on the request. This data will be in the append log.\n\nthe application server accordingly, also increments the data sequence number for the particular append log at block 410 . If appropriate for the applicable protocols, the application server can then reply or confirm to the requestor that the request has been fulfilled at block 412 .\n\nthe application server performs inserts, deletions, and modifications, without any communication with any database server.\n\nthe changes are performed only on the core_append_log.\n\nthe changes will be propagated to the database servers upon processing a new request as in FIGS. 2 and 3 .\n\na database server may also receive an updated append log, or append log portion and sequence number for its append log, so that versions can be tracked between different database servers and between the database server and the application server.\n\nall of the changes to the data are made by adding one or more additional rows to the append logs.\n\nThese can be stored in a free form unstructured field of a database, such as a BLOB field, or in some other easily accessible location.\n\nthe application servers maintain the current version of the append log and send updates to database servers when they are needed.\n\nthe append log may be highly structured, but in the described examples, it is not.\n\nthe append log is processed to apply a usable structure. In one example, this happens when the append log becomes large enough to write to the data store. When the append log becomes large enough, the append log is rewritten and formatted to generate a new segment file. The segment file is then written to the data store. However, the segment file could be used by the application server without being written to the data store as new data accumulates further. Alternatively, the data could be processed to form a new formatted append log. Further data changes could then be added to the new append log until the time for generating a new segment file for the data store.\n\nthe append log provides a location to which new data may very quickly be added. As a result, queries are not slowed by waiting for new data to be combined or consolidated with older data. The system simply appends the new data to the log and moves on. Because data is added to the append log without any significant processing, there may be additions, deletions, and replacements of particular fields in the same log. In order to use the data to reply to a query, the entire append log can be read to determine the actual status of any particular data value. If, for example, an address is added, and then modified in the append log, then only a complete read of the log will provide the current value. When it comes time to process the append log, the replaced values can be deleted, so that only the last, most current values remain.\n\nthe append log may be maintained as it is created.\n\nan address change would not simply be appended, but compared to any other previous entries, so that the earlier values can be changed. This requires more processing and analysis and may delay access to the data, however, it reduces the need to reformat the append log later.\n\nFIG. 5 shows an example of periodically optimizing data from the append log so that a segment file may be written into the data store.\n\nthe application server analyzes the append log to determine its size. The size may be measured in bytes, lines, rows or any other measure. Alternatively, the application server, may analyze the time or number of writes that have been made to the append log. In this example, the application server analyzes the core append log, which is the append log that is the most current.\n\nthe determined size, time, or number is then compared to an appropriate threshold. If the threshold has been reached, then at block 506 , the application server generates and sends an optimization request. Otherwise the application server will wait or count and repeat the analysis and threshold comparison.\n\nthe threshold is selected as a desired size in bytes for writing a file to the data store.\n\nthe data store may have a minimum file size by design, or the system may be configured to limit the file size of files in the data store in order to reduce the total number of files. Alternatively, a threshold may be used to limit the number or frequency of optimization routines.\n\nthe optimization request is sent to the unit that will perform the optimization.\n\nThis may be any unit from, for example, FIG. 1 , or it may be another component not shown in the figures.\n\nthe database server performs the optimization due to its connections within the system and its processing capabilities.\n\nthe application server may include a sequence number for the most current append log and other information as shown in Tables 3 and 4 in its optimization request.\n\nthe database server upon receiving the optimization request from the application server can compare its sequence number for the append log to the received sequence number at block 508 . If the database server does not have the current version of the append log, then at block 510 it sends a catch up request back to the application server.\n\nthe catch up request is a request for the latest version with the sequence number that matches the sequence number received from the application server.\n\nthe application server will respond to the request and at block 512 , the database server receives the most current version of the append log.\n\nthe database server can then perform the optimization.\n\nthe optimization is a process that converts the many entries appended together to form the append log into a single segment file with a structured format. To do so, the database server can read all of the entries in the log compare them and rewrite them as a single set of entries containing only the most current data in the log. The entries can also be organized and sorted for more efficient search, retrieval and modification later.\n\nthe optimization process at block 514 may be performed by reading all of the files at depth 0 and 1 . This is typically all of the files in the append log.\n\nthe application server can then rewrite all of the files as depth 0 files, delete the existing files, and then write the rewritten files into a new segment file.\n\nthe new segment file can then be written into the main cache at block 516 to become the new core segment file.\n\nthe sequence number for the new segment file can be incremented at block 518 .\n\nthe new segment file can also be written into the data store at block 520 .\n\nthe sequence number at the data store can also be incremented or updated to reflect the completion of the operation at block 522 .\n\nthe segment file can be a file that is created and completed by a single optimization operation. At the next optimization operation, a new segment file is then created. Alternatively, the segment file can be updated with each optimization.\n\nthe segment file can then be a set of rows, segments, or sub-files. Each change to the segment file can be accompanied by a change to a sequence number so that versions can be tracked as with the append log.\n\nthe core_segment_file, for this organization/table_id will contain the newly created files at depth 0 , and no files at depth 1 (since those were optimized into depth 0 ).\n\nthe sequence number for each of the new rows will be the same number.\n\nthe lock to increment the sequence number can be taken at the last possible instant before commit.\n\nFIGS. 6 and 7 shows one example of an on-demand database environment that may be suitable, depending on the application.\n\nFIG. 6 illustrates a block diagram of an environment 610 wherein an on-demand database service might be used.\n\nEnvironment 610 may include user systems 612 , network 614 , system 616 , processor system 617 , application platform 618 , network interface 620 , tenant data storage 622 , system data storage 624 , program code 626 , and process space 628 .\n\nenvironment 610 may not have all of the components listed and/or may have other elements instead of, or in addition to, those listed above.\n\nEnvironment 610 is an environment in which an on-demand database service exists.\n\nUser system 612 may be any machine or system that is used by a user to access a database user system.\n\nany of user systems 612 can be a handheld computing device, a mobile phone, a laptop computer, a work station, and/or a network of computing devices.\n\nuser systems 612 might interact via a network 614 with an on-demand database service, which is system 616 .\n\nAn on-demand database service such as system 616\n\nsystem 616 is a database system that is made available to outside users that do not need to necessarily be concerned with building and/or maintaining the database system, but instead may be available for their use when the users need the database system (e.g., on the demand of the users).\n\nSome on-demand database services may store information from one or more tenants stored into tables of a common database image to form a multi-tenant database system (MTS).\n\nMTS multi-tenant database system\n\nâon-demand database service 616 â and âsystem 616 â will be used interchangeably herein.\n\na database image may include one or more database objects.\n\nApplication platform 618 may be a framework that allows the applications of system 616 to run, such as the hardware and/or software, e.g., the operating system.\n\non-demand database service 616 may include an application platform 618 that enables creation, managing and executing one or more applications developed by the provider of the on-demand database service, users accessing the on-demand database service via user systems 612 , or third party application developers accessing the on-demand database service via user systems 612 .\n\nthe users of user systems 612 may differ in their respective capacities, and the capacity of a particular user system 612 might be entirely determined by permissions (permission levels) for the current user. For example, where a salesperson is using a particular user system 612 to interact with system 616 , that user system has the capacities allotted to that salesperson. However, while an administrator is using that user system to interact with system 616 , that user system has the capacities allotted to that administrator.\n\nusers at one permission level may have access to applications, data, and database information accessible by a lower permission level user, but may not have access to certain applications, database information, and data accessible by a user at a higher permission level. Thus, different users will have different capabilities with regard to accessing and modifying application and database information, depending on a user's security or permission level.\n\nNetwork 614 is any network or combination of networks of devices that communicate with one another.\n\nnetwork 614 can be any one or any combination of a LAN (local area network), WAN (wide area network), telephone network, wireless network, point-to-point network, star network, token ring network, hub network, or other appropriate configuration.\n\nLAN local area network\n\nWAN wide area network\n\ntelephone network wireless network\n\npoint-to-point network star network\n\ntoken ring network token ring network\n\nhub network or other appropriate configuration.\n\nTCP/IP Transfer Control Protocol and Internet Protocol\n\nUser systems 612 might communicate with system 616 using TCP/IP and, at a higher network level, use other common Internet protocols to communicate, such as HTTP, FTP, AFS, WAP, etc.\n\nHTTP HyperText Transfer Protocol\n\nuser system 612 might include an HTTP client commonly referred to as a âbrowserâ for sending and receiving HTTP messages to and from an HTTP server at system 616 .\n\nHTTP server might be implemented as the sole network interface between system 616 and network 614 , but other techniques might be used as well or instead.\n\nthe interface between system 616 and network 614 includes load sharing functionality, such as round-robin HTTP request distributors to balance loads and distribute incoming HTTP requests evenly over a plurality of servers. At least as for the users that are accessing that server, each of the plurality of servers has access to the MTS' data; however, other alternative configurations may be used instead.\n\nsystem 616 implements a web-based customer relationship management (CRM) system.\n\nsystem 616 includes application servers configured to implement and execute CRM software applications as well as provide related data, code, forms, webpages and other information to and from user systems 612 and to store to, and retrieve from, a database system related data, objects, and Webpage content.\n\nCRM customer relationship management\n\ndata for multiple tenants may be stored in the same physical database object, however, tenant data typically is arranged so that data of one tenant is kept logically separate from that of other tenants so that one tenant does not have access to another tenant's data, unless such data is expressly shared.\n\nsystem 616 implements applications other than, or in addition to, a CRM application.\n\nsystem 16 may provide tenant access to multiple hosted (standard and custom) applications, including a CRM application.\n\nUser (or third party developer) applications which may or may not include CRM, may be supported by the application platform 618 , which manages creation, storage of the applications into one or more database objects and executing of the applications in a virtual machine in the process space of the system 616 .\n\nFIG. 6 One arrangement for elements of system 616 is shown in FIG. 6 , including a network interface 620 , application platform 618 , tenant data storage 622 for tenant data 623 , system data storage 624 for system data 625 accessible to system 616 and possibly multiple tenants, program code 626 for implementing various functions of system 616 , and a process space 628 for executing MTS system processes and tenant-specific processes, such as running applications as part of an application hosting service. Additional processes that may execute on system 616 include database indexing processes.\n\neach user system 612 could include a desktop personal computer, workstation, laptop, PDA, cell phone, or any wireless access protocol (WAP) enabled device or any other computing device capable of interfacing directly or indirectly to the Internet or other network connection.\n\nWAP wireless access protocol\n\nUser system 612 typically runs an HTTP client, e.g., a browsing program, such as Microsoft's Internet Explorer browser, Netscape's Navigator browser, Opera's browser, or a WAP-enabled browser in the case of a cell phone, PDA or other wireless device, or the like, allowing a user (e.g., subscriber of the multi-tenant database system) of user system 612 to access, process and view information, pages and applications available to it from system 616 over network 614 .\n\nHTTP client e.g., a browsing program, such as Microsoft's Internet Explorer browser, Netscape's Navigator browser, Opera's browser, or a WAP-enabled browser in the case of a cell phone, PDA or other wireless device, or the like.\n\nEach user system 612 also typically includes one or more user interface devices, such as a keyboard, a mouse, trackball, touch pad, touch screen, pen or the like, for interacting with a graphical user interface (GUI) provided by the browser on a display (e.g., a monitor screen, LCD display, etc.) in conjunction with pages, forms, applications and other information provided by system 616 or other systems or servers.\n\nGUI graphical user interface\n\nthe user interface device can be used to access data and applications hosted by system 616 , and to perform searches on stored data, and otherwise allow a user to interact with various GUI pages that may be presented to a user.\n\nembodiments are suitable for use with the Internet, which refers to a specific global internetwork of networks. However, it should be understood that other networks can be used instead of the Internet, such as an intranet, an extranet, a virtual private network (VPN), a non-TCP/IP based network, any LAN or WAN or the like.\n\nVPN virtual private network\n\neach user system 612 and all of its components are operator configurable using applications, such as a browser, including computer code run using a central processing unit such as an Intel PentiumÂ® processor or the like.\n\nsystem 616 (and additional instances of an MTS, where more than one is present) and all of their components might be operator configurable using application(s) including computer code to run using a central processing unit such as processor system 617 , which may include an Intel PentiumÂ® processor or the like, and/or multiple processor units.\n\na computer program product embodiment includes a machine-readable storage medium (media) having instructions stored thereon/in which can be used to program a computer to perform any of the processes of the embodiments described herein.\n\nComputer code for operating and configuring system 616 to intercommunicate and to process webpages, applications and other data and media content as described herein are preferably downloaded and stored on a hard disk, but the entire program code, or portions thereof, may also be stored in any other volatile or non-volatile memory medium or device as is well known, such as a ROM or RAM, or provided on any media capable of storing program code, such as any type of rotating media including floppy disks, optical discs, digital versatile disk (DVD), compact disk (CD), microdrive, and magneto-optical disks, and magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and/or data.\n\nany type of rotating media including floppy disks, optical discs, digital versatile disk (DVD), compact disk (CD), microdrive, and magneto-optical disks, and magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and/or data.\n\nthe entire program code, or portions thereof may be transmitted and downloaded from a software source over a transmission medium, e.g., over the Internet, or from another server, as is well known, or transmitted over any other conventional network connection as is well known (e.g., extranet, VPN, LAN, etc.) using any communication medium and protocols (e.g., TCP/IP, HTTP, HTTPS, Ethernet, etc.) as are well known.\n\na transmission medium e.g., over the Internet\n\nany other conventional network connection e.g., extranet, VPN, LAN, etc.\n\nany communication medium and protocols e.g., TCP/IP, HTTP, HTTPS, Ethernet, etc.\n\ncomputer code for implementing embodiments of the present invention can be implemented in any programming language that can be executed on a client system and/or server or server system such as, for example, C, C++, HTML, any other markup language, JavaTM, JavaScript, ActiveX, any other scripting language, such as VBScript, and many other programming languages as are well known may be used.\n\nJavaTM is a trademark of Sun Microsystems, Inc.\n\neach system 616 is configured to provide webpages, forms, applications, data and media content to user (client) systems 612 to support the access by user systems 612 as tenants of system 616 .\n\nsystem 616 provides security mechanisms to keep each tenant's data separate unless the data is shared.\n\nMTS Mobility Management Entity\n\nthey may be located in close proximity to one another (e.g., in a server farm located in a single building or campus), or they may be distributed at locations remote from one another (e.g., one or more servers located in city A and one or more servers located in city B).\n\neach MTS could include one or more logically and/or physically connected servers distributed locally or across one or more geographic locations.\n\nserver is meant to include a computer system, including processing hardware and process space(s), and an associated storage system and database application (e.g., OODBMS or RDBMS) as is well known in the art. It should also be understood that âserver systemâ and âserverâ are often used interchangeably herein.\n\ndatabase object described herein can be implemented as single databases, a distributed database, a collection of distributed databases, a database with redundant online or offline backups or other redundancies, etc., and might include a distributed database or storage network and associated processing intelligence.\n\nFIG. 7 also illustrates environment 610 . However, in FIG. 7 elements of system 616 and various interconnections in an embodiment are further illustrated.\n\nuser system 612 may include processor system 612 A, memory system 612 B, input system 612 C, and output system 612 D.\n\nFIG. 7 shows network 614 and system 616 .\n\nsystem 616 may include tenant data storage 622 , tenant data 623 , system data storage 624 , system data 625 , User Interface (UI) 730 , Application Program Interface (API) 732 , PL/SOQL 734 , save routines 736 , application setup mechanism 738 , applications servers 7001 - 700 N, system process space 702 , tenant process spaces 704 , tenant management process space 710 , tenant storage area 712 , user storage 714 , and application metadata 716 .\n\nenvironment 610 may not have the same elements as those listed above and/or may have other elements instead of, or in addition to, those listed above.\n\nprocessor system 612 A may be any combination of one or more processors.\n\nMemory system 612 B may be any combination of one or more memory devices, short term, and/or long term memory.\n\nInput system 612 C may be any combination of input devices, such as one or more keyboards, mice, trackballs, scanners, cameras, and/or interfaces to networks.\n\nOutput system 612 D may be any combination of output devices, such as one or more monitors, printers, and/or interfaces to networks.\n\nsystem 616 may include a network interface 620 (of FIG.\n\nEach application server 700 may be configured to tenant data storage 622 and the tenant data 623 therein, and system data storage 624 and the system data 625 therein to serve requests of user systems 612 .\n\nthe tenant data 623 might be divided into individual tenant storage areas 712 , which can be either a physical arrangement and/or a logical arrangement of data.\n\nuser storage 714 and application metadata 716 might be similarly allocated for each user.\n\na copy of a user's most recently used (MRU) items might be stored to user storage 714 .\n\na copy of MRU items for an entire organization that is a tenant might be stored to tenant storage area 712 .\n\na UI 730 provides a user interface and an API 732 provides an application programmer interface to system 616 resident processes to users and/or developers at user systems 612 .\n\nthe tenant data and the system data may be stored in various databases, such as one or more OracleTM databases.\n\nApplication platform 618 includes an application setup mechanism 738 that supports application developers' creation and management of applications, which may be saved as metadata into tenant data storage 622 by save routines 736 for execution by subscribers as one or more tenant process spaces 704 managed by tenant management process 710 for example. Invocations to such applications may be coded using PL/SOQL 734 that provides a programming language style interface extension to API 732 .\n\nPL/SOQL 734 provides a programming language style interface extension to API 732 .\n\na detailed description of some PL/SOQL language embodiments is discussed in commonly owned U.S. Pat. No. 7,730,478 entitled, METHOD AND SYSTEM FOR ALLOWING ACCESS TO DEVELOPED APPLICATIONS VIA A MULTI-TENANT DATABASE ON-DEMAND DATABASE SERVICE issued Jun.\n\nInvocations to applications may be detected by one or more system processes, which manages retrieving application metadata 716 for the subscriber making the invocation and executing the metadata as an application in a virtual machine.\n\nEach application server 700 may be communicably coupled to database systems, e.g., having access to system data 625 and tenant data 623 , via a different network connection.\n\none application server 7001 might be coupled via the network 614 (e.g., the Internet)\n\nanother application server 700 N â 1 might be coupled via a direct network link\n\nanother application server 700 N might be coupled by yet a different network connection.\n\nTransfer Control Protocol and Internet Protocol TCP/IP\n\nTCP/IP Transfer Control Protocol and Internet Protocol\n\neach application server 700 is configured to handle requests for any user associated with any organization that is a tenant. Because it is desirable to be able to add and remove application servers from the server pool at any time for any reason, there is preferably no server affinity for a user and/or organization to a specific application server 700 .\n\nan interface system implementing a load balancing function e.g., an F5 Big-IP load balancer\n\nthe load balancer uses a least connections algorithm to route user requests to the application servers 700 .\n\nOther examples of load balancing algorithms such as round robin and observed response time, also can be used.\n\nsystem 616 is multi-tenant, wherein system 616 handles storage of, and access to, different objects, data and applications across disparate users and organizations.\n\none tenant might be a company that employs a sales force where each salesperson uses system 616 to manage their sales process.\n\na user might maintain contact data, leads data, customer follow-up data, performance data, goals and progress data, etc., all applicable to that user's personal sales process (e.g., in tenant data storage 622 ).\n\ntenant data storage 622 e.g., in tenant data storage 622 .\n\nthe user can manage his or her sales efforts and cycles from any of many different user systems. For example, if a salesperson is visiting a customer and the customer has Internet access in their lobby, the salesperson can obtain critical updates as to that customer while waiting for the customer to arrive in the lobby.\n\nuser systems 612 (which may be client systems) communicate with application servers 700 to request and update system-level and tenant-level data from system 616 that may require sending one or more queries to tenant data storage 622 and/or system data storage 624 .\n\nSystem 616 e.g., an application server 700 in system 616\n\nSystem data storage 624 may generate query plans to access the requested data from the database.\n\nEach database can generally be viewed as a collection of objects, such as a set of logical tables, containing data fitted into predefined categories.\n\na âtableâ is one representation of a data object, and may be used herein to simplify the conceptual description of objects and custom objects according to the present invention. It should be understood that âtableâ and âobjectâ may be used interchangeably herein.\n\nEach table generally contains one or more data categories logically arranged as columns or fields in a viewable schema. Each row or record of a table contains an instance of data for each category defined by the fields.\n\na CRM database may include a table that describes a customer with fields for basic contact information such as name, address, phone number, fax number, etc.\n\nAnother table might describe a purchase order, including fields for information such as customer, product, sale price, date, etc.\n\nstandard entity tables might be provided for use by all tenants.\n\nsuch standard entities might include tables for Account, Contact, Lead, and Opportunity data, each containing pre-defined fields. It should be understood that the word âentityâ may also be used interchangeably herein with âobjectâ and âtableâ.\n\nLandscapes\n\nEngineering & Computer Science (AREA)\n\nTheoretical Computer Science (AREA)\n\nSoftware Systems (AREA)\n\nData Mining & Analysis (AREA)\n\nDatabases & Information Systems (AREA)\n\nPhysics & Mathematics (AREA)\n\nGeneral Engineering & Computer Science (AREA)\n\nGeneral Physics & Mathematics (AREA)\n\nInformation Retrieval, Db Structures And Fs Structures Therefor (AREA)\n\nAbstract\n\nIn accordance with embodiments, there are provided mechanisms and methods for appending data to large data volumes in a multi-tenant store. These mechanisms and methods for appending data to large data volumes can enable embodiments to provide more reliable and faster maintenance of changing data. In an embodiment and by way of example, a method for appending data to large data volumes is provided. The method embodiment includes receiving new data for a database. The new data is written to a temporary log. The size of the log is compared to a threshold. Then the log is written to a data store, if the size of the log is greater than the threshold.\n\nDescription\n\nCLAIM OF PRIORITY\n\nThis application claims the benefit of U.S. Provisional Patent Application No. 61/324,955 entitled Methods and Systems for Appending Data to Large Data Volumes in a Multi-Tenant Store, by Eidson et al., filed Apr. 16, 2010 (Attorney Docket No. 008956P004Z), the entire contents of which are incorporated herein by reference.\n\nCOPYRIGHT NOTICE\n\nA portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.\n\nFIELD OF THE INVENTION\n\nThe present disclosure relates to storing data and, in particular, to aggregating data for storage in a common repository.\n\nBACKGROUND\n\nThe subject matter discussed in the background section should not be assumed to be prior art merely as a result of its mention in the background section. Similarly, a problem mentioned in the background section or associated with the subject matter of the background section should not be assumed to have been previously recognized in the prior art. The subject matter in the background section merely represents different approaches, which in and of themselves may also be inventions.\n\nIn conventional database systems, users access their data resources in one logical database. A user of such a conventional system typically retrieves data from and stores data on the system using the user's own systems. A user system might remotely access one of a plurality of server systems that might in turn access the database system. Data retrieval from the system might include the issuance of a query from the user system to the database system. The database system might process the request for information received in the query and send to the user system information relevant to the request. The rapid and efficient retrieval of accurate information and subsequent delivery of this information to the user system relies on the data in the database system complying with certain constraints. However, this limits the types, sizes, and kinds of data that can be stored in the database.\n\nIn order to provide for more types, kinds, and sizes of data, the database can be supplemented with an additional data store to hold other data and additional data. The data can be searchable separately or pointers to the separate data store in the database can be searchable. However, the separate data store adds complexity to modifying, correcting, and updating the database and the data store. This added complexity may interfere with users accessing the database and finding data in the separate data store.\n\nAccordingly, it is desirable to provide techniques enabling [element 1] of the database system, and/or [element 2] to improve [performance] [security] [efficiency] [the ease of use] of the database system.\n\nBRIEF SUMMARY\n\nIn accordance with embodiments, there are provided mechanisms and methods for appending data to large data volumes in a multi-tenant store. These mechanisms and methods for appending data to large data volumes can enable embodiments to provide more reliable and faster maintenance of changing data.\n\nIn an embodiment and by way of example, a method for appending data to large data volumes is provided. The method embodiment includes receiving new data for a database. The new data is written to a temporary log. The size of the log is compared to a threshold. Then the log is written to a data store, if the size of the log is greater than the threshold.\n\nWhile one or more implementations and techniques are described with reference to an embodiment in which Methods and Systems for Appending Data to Large Data Volumes in a Multi-Tenant Store is implemented in a system having an application server providing a front end for an on-demand database service capable of supporting multiple tenants, the one or more implementations and techniques are not limited to multi-tenant databases nor deployment on application servers. Embodiments may be practiced using other database architectures, i.e., ORACLEÂ®, DB2Â® by IBM and the like without departing from the scope of the embodiments claimed.\n\nAny of the above embodiments may be used alone or together with one another in any combination. The one or more implementations encompassed within this specification may also include embodiments that are only partially mentioned or alluded to or are not mentioned or alluded to at all in this brief summary or in the abstract. Although various embodiments may have been motivated by various deficiencies with the prior art, which may be discussed or alluded to in one or more places in the specification, the embodiments do not necessarily address any of these deficiencies. In other words, different embodiments may address different deficiencies that may be discussed in the specification. Some embodiments may only partially address some deficiencies or just one deficiency that may be discussed in the specification, and some embodiments may not address any of these deficiencies.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nIn the following drawings like reference numbers are used to refer to like elements. Although the following figures depict various examples of the invention, the invention is not limited to the examples depicted in the figures.\n\nFIG. 1 illustrates a block diagram of a database server structure with appended data an a large data store in an embodiment;\n\nFIG. 2 is an operational flow diagram illustrating serving a query at a user terminal in an embodiment;\n\nFIG. 3 is an operational flow diagram illustrating serving a query at a database server in an embodiment;\n\nFIG. 4 is an operational flow diagram illustrating updating data in a database server structure in an embodiment;\n\nFIG. 4 is an operational flow diagram illustrating optimizing data in a database server structure in an embodiment;\n\nFIG. 6 illustrates a block diagram of an example of an environment wherein an on-demand database service might be used; and\n\nFIG. 7 illustrates a block diagram of an embodiment of elements of FIG. 5 and various possible interconnections between these elements.\n\nDETAILED DESCRIPTION\n\nGeneral Overview\n\nSystems and methods are provided for appending data to large data volumes. These systems and methods are particularly valuable in the context of a multi-tenant database.\n\nAs used herein, the term multi-tenant database system refers to those systems in which various elements of hardware and software of the database system may be shared by one or more customers. For example, a given application server may simultaneously process requests for a great number of customers, and a given database table may store rows for a potentially much greater number of customers. As used herein, the term query plan refers to a set of steps used to access information in a database system.\n\nNext, mechanisms and methods for appending data to large data volumes will be described with reference to example embodiments. In one example implementation, a database served and accessed through a database server is augmented with a separate data store. The separate data store has a simple file structure with directories and metadata such as ZFS (an open source file system developed by Sun Microsystems), although a different, simpler, or more complex file structure can be used depending on the application. The files can be accessed through indices, pointers, or references in the database. In the described examples, the data stores files are write-once files with no append capability and a minimum data size, such as 10 MB. The data store therefore can be used to create a small number of large files. The described techniques can be applied to other data store systems with different configuration and constraints. Other databases and file formats can also be supported utilizing similar techniques.\n\nIn the examples described below, data, such as database segments, will be stored in the data store, however, because the data store does not work well with smaller files and cannot append, this data will only be written once there is enough data (perhaps 10 MB) to be aggregated into a larger file. The types of data to be aggregated can include incremental data for the database such as inserts, updates, deletes, and supplemental data. This data can be accumulated in a database table (called, for example AppendLog), and, once the data in the AppendLog reaches the predetermined size limit, it is flushed to the data store.\n\nThe database table or tables are subject to queries through application servers. The queries may be in any of a variety of different forms, such as OQL (Object Query Language), SQL (Structured Query Language) queries, individual get-by-id requests, or any other type of query, for example. When queries come to the database server, they need to be performed against both the database server AppendLog and the data store segments. In order for the database to respond to the query, the database servers need an up-to-date copy of the entire AppendLog and the data store segment metadata. Accordingly, the application server, when submitting a query request, can, as part of the request, ensure that the database server has an up-to-date copy of the AppendLog data and the data store segment metadata (cached) prior to forwarding the request to the database server.\n\nStructural Environment\n\nFIG. 1 shows a block diagram of a database server structure to aid in understanding the description below. In FIG. 1, a user, client, or customer, through a user terminal 102 sends a request to an application server 104. The user terminal may be directly connected or remotely connected to the application server. The user terminal may be connected though a wide area network, such as the Internet 110, or through a local or private network. The user request may be to view or receive data or information or to modify or add to data or information that is already stored.\n\nThe application server 104 is coupled to a database server 106 which serves or receives the information of the request to or from the application server. The database server includes a table 112 in which the data is stored. This data may contain an append log 114 and a segment file 116. The append log contains some number of smaller files and additional files are appended to it as changes are made to the content of the database. As described below, the append log is eventually consolidated into a single file that is stored and a new append log can be started in its place. The segment file contains metadata about files that are stored in another location. The metadata can include file names, ordering, location, and contents information. Alternatively, the append log and segment file may be stored in another location. The table may be in the form of a conventional relational database or in any other form.\n\nThe application server is also coupled to a data store 108, as described above. The data store stores segment files 118 and may also store a variety of other files, depending on the particular use made of the data store. In the described examples, a query or other request from the application server is provided only to the database server. In one example, the files of the data store are not searched. Instead, the table includes searchable pointers or indices to the data in the data store. This allows requests to be serviced more quickly. However, for particular requests, or for particular implementations, the data store may contain the pointers or indices or may be searched directly. As shown, the data store includes stored segment files 118 which may be organized using its file system.\n\nThe application server also include an append log 120 and a segment file 122. These allow the application server to track changes and progress to both the append log and the segment file in order to manage the collection, updating, and storing of such data. These may both be saved by the database server, instead, depending upon the application. There may be and typically will be multiple user terminals, application servers, database servers, and data stores. The diagram of FIG. 1 shows only one of each in order to simplify the drawing and the understanding of the operations described below.\n\nIn one example, the database servers are stateless. They locally cache immutable files and have an in-memory cache of immutable data structures. However, they do not have any âon_startupâ bootstrapping or any cross-server synchronization of changes, etc. By providing an in-memory cache, the entire database server state (in the database) does not need to be re-created for every request. The in-memory cache allows the tables and other data to be synchronized without any startup process. As described below, incremental changes are handled, while the servers are kept stateless, and the data store file metadata is stored in the database.\n\nQuery Handling\n\nFIG. 2 shows an example process for serving a query or other data modification to a database server in the context of the append log and segment file. FIG. 2 is from the perspective of the application server, while FIG. 3 shows the same process from the perspective of the database server.\n\nIn FIG. 2, a process begins, at block 204, when the application server receives a request from a user. Alternatively, the request could come from a maintenance application or a developer. The request may be to delete an entry in the database, add an entry, modify an entry or perform a much more complex operation. In one example, the data store is also used to hold large files, such as media, graphic, and high resolution files that are not well-suited to the database. Accordingly, the request may be to add a reference, index, pointer or metadata into the database to allow such a file in the data store to be searched and found from the database.\n\nAt block 206, the application server, having received the request, sends it to a database server that can access the database to service the request. The request can contain a current sequence number, so that the database server can ensure that it is working with current data. In this example, the application server accesses a table which provides the most current sequence number for the append log and the segment file. By checking a single authoritative version of the append log and segment file sequence number reference, a single application server can send requests to many different database servers. The database servers are not required to maintain any synchronization.\n\nReferring to FIG. 3, the database server at block 304 receives the query request from the application server as mentioned above. The database server then compares the received sequence number for its cached version of the append log and segment file to the received sequence number at block 306. If they match, then the database server processes the request at block 314. The request can be safely processed against the database and also the append log, since the append log will be in its most current form.\n\nOn the other hand, if the sequence numbers do not match, then the database server can request that it be sent the latest updates at block 308. The application server at block 206 listens for a catch up request at block 208. If one is received, then at block 210, the application server builds an append log and segment file to send to the database server. This may then be sent together with the query request at block 212. The response to the catch up request can be a complete replacement of the prior append log and segment file, or to reduce the amount of transmitted data between the two servers, the response can contain only the data added since the database server's version was last updated. The database server, for example, can send its most recent sequence number together with its catch up request. By comparing the database server's most recent number to the absolute most recent version, the application server can determine the differences and send only the differences.\n\nIn this example, the application server does not send the append log and segment files or their updates with the original request. This is done to reduce the amount of data sent with a request. However, as an alternative, both files may be maintained in a single version and sent to the respective database server in the latest version with each request. The size of the these files can be kept small through frequent updates of the data store or by generating many files. Each tenant, organization, customer etc. may have several different files for different portions of the database fields.\n\nIn one example, both the application server and the database server maintain relational database tables and the append logs and segment files are stored in these tables. The append logs and segment files may be stored in any of a variety of different locations in the database that provide sufficient space for the data. In an Oracle Corporation database a BLOB (Binary Large Object) may be used. The BLOB allows several gigabytes of unstructured storage. In the present example, the data may be structured but it need not be structured in a way that is consistent with the rest of the database.\n\nAt block 310, the database server receives the response to the catch up request including a partial or complete append log and segment file. After applying the updates at block 312, by updating or replacing, the database server can then process the request at block 314. At block 316, the results are sent back to the application server. At block 214, the application server receives the results and can then service the user at block 216, with a confirmation, report, or reply, depending on the nature of the request.\n\nIn one example, the database is divided into groups, organizations, etc. so that, while there may be many append logs and segment files, each one is not very large. This is one reason why any one database server may not be up to date for any one particular table.\n\nAs mentioned above, the sequence number (sequence_number) can be used to manage server state for each organization or database table. The sequence number can be used to represent the current state of any given database server organization or table. In one example, a table, such as Table 1, can be used to track the sequence number. The table may use standard 32-way organization partitioning and be an index organized table, however it may also take other forms. The PK (Primary Key) for the table may be selected as table_id, or any other suitable key.\n\nTABLE 1 Core Sequence Number.\n\nValue Type Comments organization_id CHAR(16) ID for organization table_id CHAR(16) ID for table within organization sequence_number NUMBER Current database server sequence number\n\nAs indicated in Table 1, the organization identification and the table enumerator are represented as 15 character values, while the sequence number is a number. Any desired string of characters, letter, or number may be used, depending on the application. In the described examples it is either 0 or 1, however a greater range of numbers may be used, depending on the application.\n\nIn order to synchronize different databases to the same information, the sequence, number as described above, can be used in all of the different databases in which it occurs. In such an example, the sequence number in any newly visible rows can be checked against an outside source, such as the application server, to ensure that it is greater than all previously visible sequence numbers for that particular organization and table. Based on this check, the integrity of the data can be maintained without an autonomous updating transaction. Instead, the row for this table can be locked and incremented as part of the transaction.\n\nAs described, requests to database servers may contain header information in order to convey the current database server state (core_sequence_num, core_append_log, core_segment_file) for the relevant organization, table_ids involved in the operation. (For example, a âgetâ operation would only need the table being âgotâ, but an OQL request would need an entry for each involved table_id).\n\nIn one example, each request from the application server to the database server contains for-each table_id in any one organization, a header structure containing: current_sequence_number (from core_sequence_number); and an optional âcatch upâ block. The catch up block contains: catchup_from_core_sequence_number; the data from core_segment_file from catchup_sequence_number to current_sequence_number; the data from core_append_log from catchup_sequence_number to current_sequence_number; and any of the schemas from the core_append_log_schema that are required.\n\nWhen a database server receives a request, the database server actions can be represented in pseudocode as follows:\n\nExamines its in-memory cache to see what the current sequence_number is for the given (organization_id, table_id). (If there's no entry in the cache, then its current_sequence_number can be set to 0).\n\nIf the request's current_sequence_number=cached current_sequence_number then process the request.\n\nIf the request's current_sequence_number>cached current_sequence_number\n\nIf the optional catchup from block is specified and if its catchup_from_sequence_number<=the cached current_sequence_number, then\n\nUpdate the local cache with all the changes in the catchup block\n\nProcess the request\n\nOtherwise (if there is no catchup block or its catchup_from_sequence_number>current_sequence_number) then send back a DATABASE_SERVER_CATCHUP_REQUIRED specifying the cache current_sequence_number.\n\nOtherwise, if the request's current_sequence_number<cached current_sequence_number\n\n(This is a race-condition state, meaning some other app-server has âpushedâ the server state ahead)\n\nIf the request's current_sequence_number is still cached (not too old), then process the request with the state as of that sequence number.\n\nOtherwise, send back a DATABASE_SERVER_CATCHUP_REQUIRED specifying the cache current_sequence_number\n\nThe application server acting upon a client request, performs the actions described in pseudocode below:\n\nUpon receiving DATABASE_SERVER_SEQUENCE_AHEAD, retry after re-fetching the sequence_number.\n\nUpon receiving DATABASE_SERVER_CATCHUP_REQUIRED, retry the request, but include the âcatchupâ block built from the sequence_number specified in the DATABASE_SERVER_CATCHUP_REQUIRED failure.\n\nWith this protocol, the database server always has an up-to-date copy (cached) of the core_append_log and the core_segment_files prior to executing any request; it is logically equivalent to transferring the entire state with every request, but, for efficiency purposes, the server cache ensures that, on-average, only the new append_log data is sent.\n\nAppend Log\n\nIn one embodiment, the append log may also be stored in a database table as shown by the example of Table 2.\n\nTABLE 2 Core Database Server Append Log\n\norganization_id CHAR(15) The organization table_id CHAR(15) The table database server_append_log_id CHAR(15) PK sequence_number NUMBER Relevant as-of-version raw_data_blob BLOB Raw data for the row(s)\n\nThe raw_data/raw_data_blob part of the table stores the actual data of the append log. Typically data is simply appended to this field as it is developed. The data may be stored in any of a variety of different ways. In one example, the data is stored as Avro serialized binary data. Avro is a data serialization system from the Apache Software Foundation Each time there is an insert, update, or delete, a row or set of rows is added to the field in a compressed form. For batch inserts or updates, an append_log row may be created for each insert with the raw_data/raw_data_blob storing the set of data. While Avro serialization is described herein, any of a variety of other data storing techniques may be used instead or in addition.\n\nFIG. 4 shows an example of using the segment file, append log and the tables above to update data in the system. The same or a similar process may be used for deletions, insertions, and other changes. At block 404, the application server receives a request to modify data. This can be an addition, deletion, or change. As mentioned above, this request may be in the form of OQL or any other suitable form, depending on the particular implementation and system needs.\n\nAt block 406, the application sever locates the cache with which it will service the request. This corresponds to the core segment file and the core append log. If there is only one application server, the core files may reside with the application server, but they may also reside in another location.\n\nAt block 408, the application server, upon receiving the request, modifies the data in the cache based on the request. This data will be in the append log. The application server, accordingly, also increments the data sequence number for the particular append log at block 410. If appropriate for the applicable protocols, the application server can then reply or confirm to the requestor that the request has been fulfilled at block 412.\n\nAs described in FIG. 4, the application server performs inserts, deletions, and modifications, without any communication with any database server. In such a configuration the changes are performed only on the core_append_log. The changes will be propagated to the database servers upon processing a new request as in FIGS. 2 and 3.\n\nIn another example, a database server may also receive an updated append log, or append log portion and sequence number for its append log, so that versions can be tracked between different database servers and between the database server and the application server.\n\nIn one example, all of the changes to the data are made by adding one or more additional rows to the append logs. These can be stored in a free form unstructured field of a database, such as a BLOB field, or in some other easily accessible location. The application servers maintain the current version of the append log and send updates to database servers when they are needed. The append log may be highly structured, but in the described examples, it is not.\n\nTo structure the data, periodically, the append log is processed to apply a usable structure. In one example, this happens when the append log becomes large enough to write to the data store. When the append log becomes large enough, the append log is rewritten and formatted to generate a new segment file. The segment file is then written to the data store. However, the segment file could be used by the application server without being written to the data store as new data accumulates further. Alternatively, the data could be processed to form a new formatted append log. Further data changes could then be added to the new append log until the time for generating a new segment file for the data store.\n\nIn the described examples, the append log provides a location to which new data may very quickly be added. As a result, queries are not slowed by waiting for new data to be combined or consolidated with older data. The system simply appends the new data to the log and moves on. Because data is added to the append log without any significant processing, there may be additions, deletions, and replacements of particular fields in the same log. In order to use the data to reply to a query, the entire append log can be read to determine the actual status of any particular data value. If, for example, an address is added, and then modified in the append log, then only a complete read of the log will provide the current value. When it comes time to process the append log, the replaced values can be deleted, so that only the last, most current values remain.\n\nIn an alternative configuration, the append log may be maintained as it is created. In that configuration, an address change would not simply be appended, but compared to any other previous entries, so that the earlier values can be changed. This requires more processing and analysis and may delay access to the data, however, it reduces the need to reformat the append log later.\n\nOptimization\n\nFIG. 5 shows an example of periodically optimizing data from the append log so that a segment file may be written into the data store. At block 504, the application server analyzes the append log to determine its size. The size may be measured in bytes, lines, rows or any other measure. Alternatively, the application server, may analyze the time or number of writes that have been made to the append log. In this example, the application server analyzes the core append log, which is the append log that is the most current.\n\nThe determined size, time, or number is then compared to an appropriate threshold. If the threshold has been reached, then at block 506, the application server generates and sends an optimization request. Otherwise the application server will wait or count and repeat the analysis and threshold comparison. In one example, the threshold is selected as a desired size in bytes for writing a file to the data store. The data store may have a minimum file size by design, or the system may be configured to limit the file size of files in the data store in order to reduce the total number of files. Alternatively, a threshold may be used to limit the number or frequency of optimization routines.\n\nThe optimization request is sent to the unit that will perform the optimization. This may be any unit from, for example, FIG. 1, or it may be another component not shown in the figures. In one example, the database server performs the optimization due to its connections within the system and its processing capabilities.\n\nThe application server may include a sequence number for the most current append log and other information as shown in Tables 3 and 4 in its optimization request. The database server, upon receiving the optimization request from the application server can compare its sequence number for the append log to the received sequence number at block 508. If the database server does not have the current version of the append log, then at block 510 it sends a catch up request back to the application server. The catch up request is a request for the latest version with the sequence number that matches the sequence number received from the application server. The application server will respond to the request and at block 512, the database server receives the most current version of the append log.\n\nOnce the database server has the most recent version of the append log, it can then perform the optimization. The optimization is a process that converts the many entries appended together to form the append log into a single segment file with a structured format. To do so, the database server can read all of the entries in the log compare them and rewrite them as a single set of entries containing only the most current data in the log. The entries can also be organized and sorted for more efficient search, retrieval and modification later.\n\nThe optimization process at block 514 may be performed by reading all of the files at depth 0 and 1. This is typically all of the files in the append log. The application server can then rewrite all of the files as depth 0 files, delete the existing files, and then write the rewritten files into a new segment file. The new segment file can then be written into the main cache at block 516 to become the new core segment file. The sequence number for the new segment file can be incremented at block 518. The new segment file can also be written into the data store at block 520. The sequence number at the data store can also be incremented or updated to reflect the completion of the operation at block 522.\n\nThe segment file can be a file that is created and completed by a single optimization operation. At the next optimization operation, a new segment file is then created. Alternatively, the segment file can be updated with each optimization. The segment file can then be a set of rows, segments, or sub-files. Each change to the segment file can be accompanied by a change to a sequence number so that versions can be tracked as with the append log.\n\nThe optimization can be described in pseudo-code as follows:\n\nThe application server sends a request to a database server to start optimizing at depth=0.\n\nThe database server processes the request (reading all files at depth=0 and depth=1, and rewriting the combination as a new set of depth=0 files).\n\nOnce done, the application server deletes any existing core_segment_files for the organization/table_id and depth=0 or depth=1, then writes 1 row per newly created files into core_segment_file where\n\norganization_id=<the org>\n\ncore_segment_file_id=<new id>\n\ntable_id=<the table>\n\ndata_store_file=<the file id>\n\ndepth=0âall the new files are at depth 0\n\nsequence_number=<increment core_sequence_number for this organization_id/table_id>, same for all new rows.\n\nstarting_key=<the starting key for this file>\n\nending_key=<the starting key for this file>\n\nAfter that, the core_segment_file, for this organization/table_id will contain the newly created files at depth 0, and no files at depth 1 (since those were optimized into depth 0).\n\nThe sequence number for each of the new rows will be the same number. The lock to increment the sequence number can be taken at the last possible instant before commit.\n\nThe operations and structures described above may be implemented in a variety of different systems and environments. FIGS. 6 and 7 shows one example of an on-demand database environment that may be suitable, depending on the application.\n\nSystem Overview\n\nFIG. 6 illustrates a block diagram of an environment 610 wherein an on-demand database service might be used. Environment 610 may include user systems 612, network 614, system 616, processor system 617, application platform 618, network interface 620, tenant data storage 622, system data storage 624, program code 626, and process space 628. In other embodiments, environment 610 may not have all of the components listed and/or may have other elements instead of, or in addition to, those listed above.\n\nEnvironment 610 is an environment in which an on-demand database service exists. User system 612 may be any machine or system that is used by a user to access a database user system. For example, any of user systems 612 can be a handheld computing device, a mobile phone, a laptop computer, a work station, and/or a network of computing devices. As illustrated in FIG. 6 (and in more detail in FIG. 7) user systems 612 might interact via a network 614 with an on-demand database service, which is system 616.\n\nAn on-demand database service, such as system 616, is a database system that is made available to outside users that do not need to necessarily be concerned with building and/or maintaining the database system, but instead may be available for their use when the users need the database system (e.g., on the demand of the users). Some on-demand database services may store information from one or more tenants stored into tables of a common database image to form a multi-tenant database system (MTS). Accordingly, âon-demand database service 616â and âsystem 616â will be used interchangeably herein. A database image may include one or more database objects. A relational database management system (RDMS) or the equivalent may execute storage and retrieval of information against the database object(s). Application platform 618 may be a framework that allows the applications of system 616 to run, such as the hardware and/or software, e.g., the operating system. In an embodiment, on-demand database service 616 may include an application platform 618 that enables creation, managing and executing one or more applications developed by the provider of the on-demand database service, users accessing the on-demand database service via user systems 612, or third party application developers accessing the on-demand database service via user systems 612.\n\nThe users of user systems 612 may differ in their respective capacities, and the capacity of a particular user system 612 might be entirely determined by permissions (permission levels) for the current user. For example, where a salesperson is using a particular user system 612 to interact with system 616, that user system has the capacities allotted to that salesperson. However, while an administrator is using that user system to interact with system 616, that user system has the capacities allotted to that administrator. In systems with a hierarchical role model, users at one permission level may have access to applications, data, and database information accessible by a lower permission level user, but may not have access to certain applications, database information, and data accessible by a user at a higher permission level. Thus, different users will have different capabilities with regard to accessing and modifying application and database information, depending on a user's security or permission level.\n\nNetwork 614 is any network or combination of networks of devices that communicate with one another. For example, network 614 can be any one or any combination of a LAN (local area network), WAN (wide area network), telephone network, wireless network, point-to-point network, star network, token ring network, hub network, or other appropriate configuration. As the most common type of computer network in current use is a TCP/IP (Transfer Control Protocol and Internet Protocol) network, such as the global internetwork of networks often referred to as the âInternetâ with a capital âI,â that network will be used in many of the examples herein. However, it should be understood that the networks that the present invention might use are not so limited, although TCP/IP is a frequently implemented protocol.\n\nUser systems 612 might communicate with system 616 using TCP/IP and, at a higher network level, use other common Internet protocols to communicate, such as HTTP, FTP, AFS, WAP, etc. In an example where HTTP is used, user system 612 might include an HTTP client commonly referred to as a âbrowserâ for sending and receiving HTTP messages to and from an HTTP server at system 616. Such an HTTP server might be implemented as the sole network interface between system 616 and network 614, but other techniques might be used as well or instead. In some implementations, the interface between system 616 and network 614 includes load sharing functionality, such as round-robin HTTP request distributors to balance loads and distribute incoming HTTP requests evenly over a plurality of servers. At least as for the users that are accessing that server, each of the plurality of servers has access to the MTS' data; however, other alternative configurations may be used instead.\n\nIn one embodiment, system 616, shown in FIG. 6, implements a web-based customer relationship management (CRM) system. For example, in one embodiment, system 616 includes application servers configured to implement and execute CRM software applications as well as provide related data, code, forms, webpages and other information to and from user systems 612 and to store to, and retrieve from, a database system related data, objects, and Webpage content. With a multi-tenant system, data for multiple tenants may be stored in the same physical database object, however, tenant data typically is arranged so that data of one tenant is kept logically separate from that of other tenants so that one tenant does not have access to another tenant's data, unless such data is expressly shared. In certain embodiments, system 616 implements applications other than, or in addition to, a CRM application. For example, system 16 may provide tenant access to multiple hosted (standard and custom) applications, including a CRM application. User (or third party developer) applications, which may or may not include CRM, may be supported by the application platform 618, which manages creation, storage of the applications into one or more database objects and executing of the applications in a virtual machine in the process space of the system 616.\n\nOne arrangement for elements of system 616 is shown in FIG. 6, including a network interface 620, application platform 618, tenant data storage 622 for tenant data 623, system data storage 624 for system data 625 accessible to system 616 and possibly multiple tenants, program code 626 for implementing various functions of system 616, and a process space 628 for executing MTS system processes and tenant-specific processes, such as running applications as part of an application hosting service. Additional processes that may execute on system 616 include database indexing processes.\n\nSeveral elements in the system shown in FIG. 6 include conventional, well-known elements that are explained only briefly here. For example, each user system 612 could include a desktop personal computer, workstation, laptop, PDA, cell phone, or any wireless access protocol (WAP) enabled device or any other computing device capable of interfacing directly or indirectly to the Internet or other network connection. User system 612 typically runs an HTTP client, e.g., a browsing program, such as Microsoft's Internet Explorer browser, Netscape's Navigator browser, Opera's browser, or a WAP-enabled browser in the case of a cell phone, PDA or other wireless device, or the like, allowing a user (e.g., subscriber of the multi-tenant database system) of user system 612 to access, process and view information, pages and applications available to it from system 616 over network 614. Each user system 612 also typically includes one or more user interface devices, such as a keyboard, a mouse, trackball, touch pad, touch screen, pen or the like, for interacting with a graphical user interface (GUI) provided by the browser on a display (e.g., a monitor screen, LCD display, etc.) in conjunction with pages, forms, applications and other information provided by system 616 or other systems or servers. For example, the user interface device can be used to access data and applications hosted by system 616, and to perform searches on stored data, and otherwise allow a user to interact with various GUI pages that may be presented to a user. As discussed above, embodiments are suitable for use with the Internet, which refers to a specific global internetwork of networks. However, it should be understood that other networks can be used instead of the Internet, such as an intranet, an extranet, a virtual private network (VPN), a non-TCP/IP based network, any LAN or WAN or the like.\n\nAccording to one embodiment, each user system 612 and all of its components are operator configurable using applications, such as a browser, including computer code run using a central processing unit such as an Intel PentiumÂ® processor or the like. Similarly, system 616 (and additional instances of an MTS, where more than one is present) and all of their components might be operator configurable using application(s) including computer code to run using a central processing unit such as processor system 617, which may include an Intel PentiumÂ® processor or the like, and/or multiple processor units. A computer program product embodiment includes a machine-readable storage medium (media) having instructions stored thereon/in which can be used to program a computer to perform any of the processes of the embodiments described herein. Computer code for operating and configuring system 616 to intercommunicate and to process webpages, applications and other data and media content as described herein are preferably downloaded and stored on a hard disk, but the entire program code, or portions thereof, may also be stored in any other volatile or non-volatile memory medium or device as is well known, such as a ROM or RAM, or provided on any media capable of storing program code, such as any type of rotating media including floppy disks, optical discs, digital versatile disk (DVD), compact disk (CD), microdrive, and magneto-optical disks, and magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and/or data. Additionally, the entire program code, or portions thereof, may be transmitted and downloaded from a software source over a transmission medium, e.g., over the Internet, or from another server, as is well known, or transmitted over any other conventional network connection as is well known (e.g., extranet, VPN, LAN, etc.) using any communication medium and protocols (e.g., TCP/IP, HTTP, HTTPS, Ethernet, etc.) as are well known. It will also be appreciated that computer code for implementing embodiments of the present invention can be implemented in any programming language that can be executed on a client system and/or server or server system such as, for example, C, C++, HTML, any other markup language, Javaâ¢, JavaScript, ActiveX, any other scripting language, such as VBScript, and many other programming languages as are well known may be used. (Javaâ¢ is a trademark of Sun Microsystems, Inc.).\n\nAccording to one embodiment, each system 616 is configured to provide webpages, forms, applications, data and media content to user (client) systems 612 to support the access by user systems 612 as tenants of system 616. As such, system 616 provides security mechanisms to keep each tenant's data separate unless the data is shared. If more than one MTS is used, they may be located in close proximity to one another (e.g., in a server farm located in a single building or campus), or they may be distributed at locations remote from one another (e.g., one or more servers located in city A and one or more servers located in city B). As used herein, each MTS could include one or more logically and/or physically connected servers distributed locally or across one or more geographic locations. Additionally, the term âserverâ is meant to include a computer system, including processing hardware and process space(s), and an associated storage system and database application (e.g., OODBMS or RDBMS) as is well known in the art. It should also be understood that âserver systemâ and âserverâ are often used interchangeably herein. Similarly, the database object described herein can be implemented as single databases, a distributed database, a collection of distributed databases, a database with redundant online or offline backups or other redundancies, etc., and might include a distributed database or storage network and associated processing intelligence.\n\nFIG. 7 also illustrates environment 610. However, in FIG. 7 elements of system 616 and various interconnections in an embodiment are further illustrated. FIG. 7 shows that user system 612 may include processor system 612A, memory system 612B, input system 612C, and output system 612D. FIG. 7 shows network 614 and system 616. FIG. 7 also shows that system 616 may include tenant data storage 622, tenant data 623, system data storage 624, system data 625, User Interface (UI) 730, Application Program Interface (API) 732, PL/SOQL 734, save routines 736, application setup mechanism 738, applications servers 7001-700N, system process space 702, tenant process spaces 704, tenant management process space 710, tenant storage area 712, user storage 714, and application metadata 716. In other embodiments, environment 610 may not have the same elements as those listed above and/or may have other elements instead of, or in addition to, those listed above.\n\nUser system 612, network 614, system 616, tenant data storage 622, and system data storage 624 were discussed above in FIG. 6. Regarding user system 612, processor system 612A may be any combination of one or more processors. Memory system 612B may be any combination of one or more memory devices, short term, and/or long term memory. Input system 612C may be any combination of input devices, such as one or more keyboards, mice, trackballs, scanners, cameras, and/or interfaces to networks. Output system 612D may be any combination of output devices, such as one or more monitors, printers, and/or interfaces to networks. As shown by FIG. 7, system 616 may include a network interface 620 (of FIG. 6) implemented as a set of HTTP application servers 700, an application platform 618, tenant data storage 622, and system data storage 624. Also shown is system process space 702, including individual tenant process spaces 704 and a tenant management process space 710. Each application server 700 may be configured to tenant data storage 622 and the tenant data 623 therein, and system data storage 624 and the system data 625 therein to serve requests of user systems 612. The tenant data 623 might be divided into individual tenant storage areas 712, which can be either a physical arrangement and/or a logical arrangement of data. Within each tenant storage area 712, user storage 714 and application metadata 716 might be similarly allocated for each user. For example, a copy of a user's most recently used (MRU) items might be stored to user storage 714. Similarly, a copy of MRU items for an entire organization that is a tenant might be stored to tenant storage area 712. A UI 730 provides a user interface and an API 732 provides an application programmer interface to system 616 resident processes to users and/or developers at user systems 612. The tenant data and the system data may be stored in various databases, such as one or more Oracleâ¢ databases.\n\nApplication platform 618 includes an application setup mechanism 738 that supports application developers' creation and management of applications, which may be saved as metadata into tenant data storage 622 by save routines 736 for execution by subscribers as one or more tenant process spaces 704 managed by tenant management process 710 for example. Invocations to such applications may be coded using PL/SOQL 734 that provides a programming language style interface extension to API 732. A detailed description of some PL/SOQL language embodiments is discussed in commonly owned U.S. Pat. No. 7,730,478 entitled, METHOD AND SYSTEM FOR ALLOWING ACCES"
    }
}