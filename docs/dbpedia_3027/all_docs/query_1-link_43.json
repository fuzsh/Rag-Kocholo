{
    "id": "dbpedia_3027_1",
    "rank": 43,
    "data": {
        "url": "https://discourse.mcneel.com/t/distribution-with-limited-randomness/17689",
        "read_more_link": "",
        "language": "en",
        "title": "Distribution with limited randomness",
        "top_image": "https://global.discourse-cdn.com/mcneel/original/3X/a/3/a3d22fa75cb2e26bdc77cc6462014e63abbc920c.png",
        "meta_img": "https://global.discourse-cdn.com/mcneel/original/3X/a/3/a3d22fa75cb2e26bdc77cc6462014e63abbc920c.png",
        "images": [
            "https://discourse.mcneel.com/uploads/default/17465/b41825383def49c7.JPG",
            "https://sea1.discourse-cdn.com/mcneel/uploads/default/17492/f2dc29f680cb709e.JPG",
            "http://www.grasshopper3d.com/favicon.ico",
            "http://api.ning.com:80/files/XrXdcvhIFyDehyQFhK8XKVz9F*68uaHKUBfV4P7YhDNzfZn2viDy8QErJmBCFpuHABG2CHIEc2f3ry4QyTgRJsSh7Hwh9k3s/494057383.jpeg",
            "https://sea1.discourse-cdn.com/mcneel/user_avatar/discourse.mcneel.com/nathancoatney/48/183189_2.png",
            "http://www.grasshopper3d.com/favicon.ico",
            "http://discourse.mcneel.com/uploads/default/_optimized/2b7/c63/34fb6744ce_690x324.JPG"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Normand (Jakob Normand)",
            "elruinascuatroesquin (Juan)",
            "Vanessa (Vanessa Steeg)",
            "pascal (Pascal Golay)"
        ],
        "publish_date": "2015-03-11T16:18:19+00:00",
        "summary": "",
        "meta_description": "Hello Newsgroup, \nI run into the following problem on a regular basis and haven’t found a way to solve it 100% yet, maybe someone can help: \nI would like to be able to randomly distribute a block / object over a 3D surfa&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://global.discourse-cdn.com/mcneel/uploads/default/optimized/3X/e/8/e8ac746b7d3ee947a397b6e4f08d03f650423c3c_2_32x32.ico",
        "meta_site_name": "McNeel Forum",
        "canonical_link": "https://discourse.mcneel.com/t/distribution-with-limited-randomness/17689",
        "text": "Hello Newsgroup,\n\nI run into the following problem on a regular basis and haven’t found a way to solve it 100% yet, maybe someone can help:\n\nI would like to be able to randomly distribute a block / object over a 3D surface but with the possibility to specify a max and min value for the distance between the blocks (or their bounding boxes) this way we could avoid or limit the amount of the intersection of objects e.g. to spread trees over a landscape (please see attached picture)\n\nIdeally I would also be able to specify a random z-axis rotation for the blocks and random scale effects with a specified min/ max setting for the instances, but since this already can be achieved by existing scripts e.g. harmony this would be just for convenience…\n\nI would be very thankfull for any help here.\n\nbest regards\n\nAndreas\n\nHello,\n\nthank you all for your feedback -> great forum !\n\n@pascal: yes, i did a few test with sprinkler, but as I tried to explain in my initial post the results are “too” random for e.g. a forest, the distances between the elements are sometimes too large and even more problematic often too close.\n\n@VaneSteeg: I know curve-plus, but it is for arranging objects on curves, not surfaces or am I wrong?\n\n@nathancoatney: This looks interesting, is it available for download?\n\nactually I already tested a lot of stuff but nothing really does what I need, If anyone would help me with a script / plugin to fulfill the requirements (“even” random distribution with min/max distance, random rotations, vertical alignment of the objects ( like trees on a slope ), user definable scale variations) I would gladly pay for such a tool…\n\nbest\n\nAndreas\n\nThat was an old grasshopper script that I would have a difficult time finding the source for now. I remember the issues with it were:\n\nIt couldn’t handle enough instances for something like a forest, I think mainly because of the drawing overhead.\n\nAt the time I don’t believe Grasshopper could use/manipulate instance objects.\n\nHowever, I am fairly certain this is something achievable with python. The issue will remain with the drawing of the instances. In the end, if Rhino has to draw millions of things, it will slow down, unless there is some trick I don’t know about. If you are using a renderer (like Maxwell, and I think Vray) that has a lightweight proxy object that uses a standard document object such as a point cloud or bounding box, then it is probably a viable idea.\n\nIf there is a small market for such a tool then I wouldn’t mind maintaining it, but I see there are already some free tools that do basically the same thing:\n\nBut maybe controlling the spacing and/or collision detection is a differentiator. I will try to spend my Rhino time working on it, as I would like the tool for myself as well, and have been meaning to put something together for a while now. If it goes anywhere I’ll post something.\n\nThanks,\n\nThat is exactly what is missing right now.\n\nAs I said I already tried numerous solutions including grow, which is a great tool especially when combined with octane, but it also lacks the min / max distance distribution feature, in addition I think I remember that the objects are distributed in the direction of the surface normal , for e.g. trees there has to be an option to keep the objects oriented vertical…\n\nThere is a number of commercial plugins available for e.g. 3d studio, forest pack or scatter are two of them. Their abilities are of course very wide , you can tell them to mix your distribution out of certain percentageges of objects, have a probability to form clusters and so on. But since many of those tasks can already be done in Rhino by other scripts, it is possible for sure to integrate some of this into one solution. I have a lot of ideas for such a program but lack the ability to program it properly. …\n\nBest\n\nAndreas\n\nHi Andy,\n\nJarek posted a tool for distributing trees some years before (maybe you can found it at the old Rhino Forum Archive too). Attached two button scripts from this tool. one for placing random points on a surface and one for copy trees to the points.\n\nCiao,\n\nMicha\n\n-Runscript\n\n(Option Explicit\n\n’Script written and copyrighted by Jaroslaw Bieda\n\n'Script version August 19, 2007 6:10:31 PM\n\nCall RandomPointsOnSurf()\n\nSub RandomPointsOnSurf()\n\nDim strSurface, strSurfaceShrunk Dim arrPoints() Dim arrCurves, idCurve Dim dblCrvDist : dblCrvDist=0 Dim arrDomU, arrDomV Dim t(1), pt, strPoint Dim a, m, j Dim idDistTest Dim intM : intM = 0 'level of point count match Dim blnSkip : blnSkip = vbFalse 'skipping regenerating points while MinDist=0 and switching strMatch levels strSurface = Rhino.GetObject(\"Select surface to generate random points on\",8) If IsNull(strSurface) Then Exit Sub arrCurves=Rhino.GetObjects(\"Select edge curves ( ENTER if none )\",4) Dim l : l=1 If Not IsNull(arrCurves) Then l=0 Call Rhino.EnableRedraw(vbFalse) 'shrinking surface to speed up the process strSurfaceShrunk=Rhino.CopyObject(strSurface) If Rhino.IsSurfaceTrimmed(strSurfaceShrunk) Then Rhino.ShrinkTrimmedSurface(strSurfaceShrunk) arrDomU = Rhino.SurfaceDomain(strSurfaceShrunk, 0) arrDomV = Rhino.SurfaceDomain(strSurfaceShrunk, 1) Call Rhino.DeleteObject(strSurfaceShrunk) Call Rhino.EnableRedraw(vbTrue) If Not IsArray(arrDomU) Or Not IsArray(arrDomV) Then Exit Sub 'OPTIONS Dim strResult, arrOptions() : ReDim arrOptions(5-l) Dim intQuantity : intQuantity = 10 'Initial points number Dim dbDist : dbDist=0 Dim strMatch : strMatch=\"Disabled\" Do arrOptions(0)=\"Randomize\" arrOptions(1)=\"PointCount_\" & intQuantity arrOptions(2)=\"MinPtDist\" If dbDist<1 And dbDist>0 Then arrOptions(2)=\"MinPtDist_between_0_and_1\" arrOptions(3)=\"MatchPointCount_\" & strMatch arrOptions(4)=\"CurveMinDist\" arrOptions(5-l)=\"CREATE\" If blnSkip=False Then ReDim arrPoints(0) : j=0 'GENERATING RANDOM POINTS Call Rhino.EnableRedraw(vbFalse) For a = 1 To intQuantity For m = 0 To intM '-loop for iterations for point count match Do t(0) = arrDomU(0) + (((arrDomU(1) - arrDomU(0))*Rnd)) t(1) = arrDomV(0) + (((arrDomV(1) - arrDomV(0))*Rnd)) pt = Rhino.EvaluateSurface(strSurface, t) If Rhino.IsPointOnSurface(strSurface,pt) Then Exit Do Loop strPoint = Rhino.AddPoint(pt) 'testing for existing points withing given minimum distance If dbDist > 0 Then If IsArray(Rhino.SelectedObjects) Then For Each idDistTest In Rhino.SelectedObjects If FastDistance(pt,Rhino.PointCoordinates(idDistTest)) < dbDist Then Rhino.DeleteObject(strPoint) Exit For End If Next End If End If 'testing distance to curves If l=0 And dblCrvDist>0 And Rhino.IsObject(strPoint) Then For Each idCurve In arrCurves If FastDistance(Rhino.PointCoordinates(strPoint),Rhino.EvaluateCurve(idCurve,Rhino.CurveClosestPoint(idCurve,Rhino.PointCoordinates(strPoint)))) < dblCrvDist Then Rhino.DeleteObject(strPoint) Exit For End If Next End If If Rhino.IsObject(strPoint) Then ReDim Preserve arrPoints(j) arrPoints(j)=strPoint j=j+1 Exit For End If Next Call Rhino.SelectObject(strPoint) 'process percentage and points generated Call Rhino.Prompt(\"Generating points... \"&CStr(Int((100*a)/intQuantity))&\"% | Generated \" & CStr(UBound(arrPoints)+1)&\" points. Press ESC to cancel\") 'refresh every 10% If a Mod (intQuantity/10) = 0 Then Call Rhino.EnableRedraw(vbTrue) Call Rhino.EnableRedraw(vbFalse) End If Next Call Rhino.Print(\"Generated \" & CStr(UBound(Rhino.SelectedObjects)+1)&\" points...\") Call Rhino.EnableRedraw(vbTrue) End If 'OPTIONS strResult = Rhino.GetString(\"Generate random points on surface\",\"CREATE\",arrOptions) Select Case Left(UCase(strResult),2) Case \"CU\" dblCrvDist=Rhino.GetReal(\"Minimum distance from curve?\",dblCrvDist,0) If IsNull(dblCrvDist) Then dblCrvDist=0 Call Rhino.DeleteObjects(Rhino.SelectedObjects) If dblCrvDist>0 Then blnSkip=False Case \"CR\" Exit Do Case \"PO\" intQuantity = Rhino.GetInteger(\"Number of points to generate\",intQuantity,1) Call Rhino.DeleteObjects(Rhino.SelectedObjects) Case \"RA\" Call Rhino.DeleteObjects(Rhino.SelectedObjects) Case \"MI\" dbDist=Rhino.GetReal(\"Minimal point to point distance\",dbDist,0) Call Rhino.DeleteObjects(Rhino.SelectedObjects) If dbDist>0 Then blnSkip = False Case \"MA\" ' setting the level of point count match while minimal distance is defined If dbDist=0 Then blnSkip = vbTrue strMatch=Rhino.Getstring(\"Select point count match attempt level\",strMatch,Array(\"Disabled\",\"Low\",\"Med\",\"High\",\"Max\")) Select Case Left(UCase(strMatch),2) Case \"DE\" intM = 0 Case \"LO\" intM = 10 Case \"ME\" intM = 50 Case \"HI\" intM = 100 Case \"MA\" intM = 300 Case Else strMatch=\"Disabled\" intM=0 End Select If Not blnSkip=True Then Call Rhino.DeleteObjects(Rhino.SelectedObjects) Case Else Call Rhino.DeleteObjects(Rhino.SelectedObjects) Exit Sub End Select Loop Call Rhino.Command(\"!_Group\")\n\nEnd Sub\n\nFunction FastDistance(byref P1,byref P2)\n\nFastDistance=Sqr((P1(0)-P2(0))(P1(0)-P2(0))+(P1(1)-P2(1))(P1(1)-P2(1))+(P1(2)-P2(2))*(P1(2)-P2(2)))\n\nEnd Function)\n\n-runscript\n\n(Option Explicit\n\nCall CopyToPoints()\n\nSub CopyToPoints\n\nDim idObjs : idObjs = Rhino.GetObjects(“Objects to copy”, ,True, True, True)\n\nDim ptFrom : ptFrom = Rhino.GetPoint(“Point to copy from”)\n\nDim ptTarget : ptTarget = Rhino.GetPointCoordinates(“Points to copy to”, False)\n\nDim i For i = 0 To UBound(ptTarget) Call Rhino.CopyObjects(idObjs, ptFrom, ptTarget(i)) Next\n\nEnd Sub)"
    }
}