{
    "id": "dbpedia_3015_2",
    "rank": 84,
    "data": {
        "url": "https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-overview",
        "read_more_link": "",
        "language": "en",
        "title": "Introduction to Azure Service Bus, an enterprise message broker - Azure Service Bus",
        "top_image": "https://learn.microsoft.com/en-us/media/open-graph-image.png",
        "meta_img": "https://learn.microsoft.com/en-us/media/open-graph-image.png",
        "images": [
            "https://learn.microsoft.com/en-us/azure/service-bus-messaging/media/service-bus-messaging-overview/about-service-bus-queue.png",
            "https://learn.microsoft.com/en-us/azure/service-bus-messaging/media/service-bus-messaging-overview/about-service-bus-topic.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-02-23T23:05:00+00:00",
        "summary": "",
        "meta_description": "This article provides a high-level overview of Azure Service Bus, a fully managed enterprise integration serverless message broker.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-overview",
        "text": "What is Azure Service Bus?\n\nAzure Service Bus is a fully managed enterprise message broker with message queues and publish-subscribe topics. Service Bus is used to decouple applications and services from each other, providing the following benefits:\n\nLoad-balancing work across competing workers\n\nSafely routing and transferring data and control across service and application boundaries\n\nCoordinating transactional work that requires a high-degree of reliability\n\nOverview\n\nData is transferred between different applications and services using messages. A message is a container decorated with metadata, and contains data. The data can be any kind of information, including structured data encoded with the common formats such as the following ones: JSON, XML, Apache Avro, Plain Text.\n\nSome common messaging scenarios are:\n\nMessaging. Transfer business data, such as sales or purchase orders, journals, or inventory movements.\n\nDecouple applications. Improve reliability and scalability of applications and services. Producer and consumer don't have to be online or readily available at the same time. The load is leveled such that traffic spikes don't overtax a service.\n\nLoad balancing. Allow for multiple competing consumers to read from a queue at the same time, each safely obtaining exclusive ownership to specific messages.\n\nTopics and subscriptions. Enable 1:n relationships between publishers and subscribers, allowing subscribers to select particular messages from a published message stream.\n\nTransactions. Allows you to do several operations, all in the scope of an atomic transaction. For example, the following operations can be done in the scope of a transaction.\n\nObtain a message from one queue.\n\nPost results of processing to one or more different queues.\n\nMove the input message from the original queue.\n\nThe results become visible to downstream consumers only upon success, including the successful settlement of input message, allowing for once-only processing semantics. This transaction model is a robust foundation for the compensating transactions pattern in the greater solution context.\n\nMessage sessions. Implement high-scale coordination of workflows and multiplexed transfers that require strict message ordering or message deferral.\n\nIf you're familiar with other message brokers like Apache ActiveMQ, Service Bus concepts are similar to what you know. As Service Bus is a platform-as-a-service (PaaS) offering, a key difference is that you don't need to worry about the following actions. Azure takes care of those chores for you.\n\nWorrying about hardware failures\n\nKeeping the operating systems or the products patched\n\nPlacing logs and managing disk space\n\nHandling backups\n\nFailing over to a reserve machine\n\nConcepts\n\nThis section discusses basic concepts of Service Bus.\n\nQueues\n\nMessages are sent to and received from queues. Queues store messages until the receiving application is available to receive and process them.\n\nMessages in queues are ordered and timestamped on arrival. Once the broker accepts the message, the message is always held durably in triple-redundant storage, spread across availability zones if the namespace is zone-enabled. Service Bus keeps messages in memory or volatile storage until client reports them as accepted.\n\nMessages are delivered in pull mode, only delivering messages when requested. Unlike the busy-polling model of some other cloud queues, the pull operation can be long-lived and only complete once a message is available.\n\nTopics\n\nYou can also use topics to send and receive messages. While a queue is often used for point-to-point communication, topics are useful in publish-subscribe scenarios.\n\nTopics can have multiple, independent subscriptions, which attach to the topic and otherwise work exactly like queues from the receiver side. A subscriber to a topic can receive a copy of each message sent to that topic. Subscriptions are named entities. Subscriptions are durable by default, but can be configured to expire and then be automatically deleted. Via the Java Message Service (JMS) API, Service Bus Premium also allows you to create volatile subscriptions that exist for the duration of the connection.\n\nYou can define rules on a subscription. A subscription rule has a filter to define a condition for the message to be copied into the subscription and an optional action that can modify message metadata. For more information, see Topic filters and actions. This feature is useful in the following scenarios:\n\nYou don't want a subscription to receive all messages sent to a topic.\n\nYou want to mark up messages with extra metadata when they pass through a subscription.\n\nNamespaces\n\nA namespace is a container for all messaging components (queues and topics). A namespace can have one or more queues and topics and it often serves as an application container.\n\nA namespace can be compared to a server in the terminology of other brokers, but the concepts aren't directly equivalent. A Service Bus namespace is your own capacity slice of a large cluster made up of dozens of all-active virtual machines. It optionally spans three Azure availability zones. So, you get all the availability and robustness benefits of running the message broker at enormous scale. And, you don't need to worry about underlying complexities. Service Bus is serverless messaging.\n\nAdvanced features\n\nService Bus also has advanced features that enable you to solve more complex messaging problems. The following sections describe these key features:\n\nMessage sessions\n\nTo realize a first-in, first-out (FIFO) guarantee in processing messages in Service Bus queues or subscriptions, use sessions. Sessions can also be used in implementing request-response patterns. The request-response pattern enables the sender application to send a request and provides a way for the receiver to correctly send a response back to the sender application. For more information, see Message sessions.\n\nAuto-forwarding\n\nThe Auto-forwarding feature enables you to chain a queue or subscription to another queue or topic that is part of the same namespace. When auto-forwarding is enabled, Service Bus automatically removes messages that are placed in the first queue or subscription (source) and puts them in the second queue or topic (destination). For more information, see Chaining Service Bus entities with auto-forwarding\n\nDead-lettering\n\nService Bus queues and topic subscriptions provide a secondary subqueue, called a dead-letter queue (DLQ). The dead letter queue holds messages that can't be delivered to any receiver, or messages that can't be processed. You can then remove messages from the DLQ and inspect them. An application might, with help of an operator, correct issues and resubmit the message, log the fact that there was an error, and take a corrective action. For more information, see Overview of Service Bus dead-letter queues.\n\nScheduled delivery\n\nYou can submit messages to a queue or topic for delayed processing. For example, to schedule a job to become available for processing by a system at a certain time. For more information, see Scheduled messages.\n\nMessage deferral\n\nWhen a queue or subscription client receives a message that it's willing to process, but for which processing isn't currently possible because of special circumstances within the application, the entity can defer retrieval of the message to a later point. The message remains in the queue or subscription, but it's set aside. For more information, see Message deferral.\n\nTransactions\n\nA transaction groups two or more operations together into an execution scope. Service Bus supports grouping operations against a single messaging entity (queue, topic, subscription) within the scope of a transaction. For more information, see Overview of Service Bus transaction processing.\n\nFilters and actions\n\nSubscribers can define which messages they want to receive from a topic. These messages are specified in the form of one or more named subscription rules. Each rule consists of a filter condition that selects particular messages, and optionally contains an action that annotates the selected message. For each matching rule condition, the subscription produces a copy of the message, which can be differently annotated for each matching rule. For more information, see Topic filters and actions.\n\nAuto-delete on idle\n\nAuto-delete on idle enables you to specify an idle interval after which the queue is automatically deleted. The interval is reset when there's traffic on the queue. The minimum duration is 5 minutes.\n\nDuplicate detection\n\nIf an error occurs that causes the client to have any doubt about the outcome of a send operation, duplicate detection takes the doubt out of these situations by enabling the sender to resend the same message, and the queue or topic discards any duplicate copies. For more information, see Duplicate detection.\n\nBatch delete of Messages\n\nAzure Service Bus supports deletion of messages in batches. This is useful in scenarios when messages within queues or subscriptions have become expired , or no longer relevant, necessitating a cleanup. For more information, see Batch delete.\n\nSecurity\n\nService Bus supports security protocols such as Shared Access Signatures (SAS), Role Based Access Control (RBAC) (RBAC) and Managed identities for Azure resources.\n\nService Bus supports standard Advanced Message Queuing Protocol (AMQP) 1.0 and HTTP/REST protocols.\n\nGeo-disaster recovery\n\nWhen Azure regions or datacenters experience downtime, Geo-disaster recovery enables data processing to continue operating in a different region or datacenter.\n\nCompliance with standards and protocols\n\nThe primary wire protocol for Service Bus is Advanced Messaging Queueing Protocol (AMQP) 1.0, an open ISO/IEC standard. It allows customers to write applications that work against Service Bus and on-premises brokers such as ActiveMQ or RabbitMQ. The AMQP protocol guide provides detailed information in case you want to build such an abstraction.\n\nService Bus Premium is fully compliant with the Java/Jakarta EE Java Message Service (JMS) 2.0 API. And, Service Bus Standard supports the JMS 1.1 subset focused on queues. JMS is a common abstraction for message brokers and integrates with many applications and frameworks, including the popular Spring framework. To switch from other brokers to Azure Service Bus, you just need to recreate the topology of queues and topics, and change the client provider dependencies and configuration. For an example, see the ActiveMQ migration guide.\n\nClient libraries\n\nFully supported Service Bus client libraries are available via the Azure SDK.\n\nAzure Service Bus for .NET\n\nThird-party frameworks providing higher-level abstractions built on top of the SDK include NServiceBus and MassTransit.\n\nAzure Service Bus libraries for Java\n\nAzure Service Bus provider for Java JMS 2.0\n\nAzure Service Bus modules for JavaScript and TypeScript\n\nAzure Service Bus libraries for Python\n\nAzure Service Bus' primary protocol is AMQP 1.0 and it can be used from any AMQP 1.0 compliant protocol client. Several open-source AMQP clients have samples that explicitly demonstrate Service Bus interoperability. Review the AMQP 1.0 protocol guide to understand how to use Service Bus features with AMQP 1.0 clients directly.\n\nLanguage Library Java Apache Qpid Proton-J C/C++ Azure uAMQP C, Apache Qpid Proton-C Python Azure uAMQP for Python, Apache Qpid Proton Python) PHP Azure uAMQP for PHP Ruby Apache Qpid Proton Ruby Go Azure Go AMQP, Apache Qpid Proton Go C#/F#/VB AMQP .NET Lite, Apache NMS AMQP JavaScript/Node Rhea\n\nIntegration\n\nService Bus fully integrates with many Microsoft and Azure services, for instance:\n\nEvent Grid\n\nLogic Apps\n\nAzure Functions\n\nPower Platform\n\nDynamics 365\n\nAzure Stream Analytics\n\nNext steps\n\nTo get started using Service Bus messaging, see the following articles:"
    }
}