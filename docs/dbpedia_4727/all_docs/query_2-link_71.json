{
    "id": "dbpedia_4727_2",
    "rank": 71,
    "data": {
        "url": "http://www.lieberbiber.de/2015/07/04/hacking-ubuntu-touch-part-8-fastboot/",
        "read_more_link": "",
        "language": "en",
        "title": "Hacking Ubuntu Touch, Part 8: Fastboot",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://www.lieberbiber.de/wp-content/uploads/2017/03/biber_transparent0001-3.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "sturmflut"
        ],
        "publish_date": "2015-07-04T00:00:00",
        "summary": "",
        "meta_description": "NOTE: This is a continuation of the series. NOTE: The information in this article was obtained by analzying the reference",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "LIEBERBIBER",
        "canonical_link": "http://www.lieberbiber.de/2015/07/04/hacking-ubuntu-touch-part-8-fastboot/",
        "text": "NOTE: This is a continuation of the series.\n\nNOTE: The information in this article was obtained by analzying the reference implementation client and disecting the protocol traffic with Wireshark. The signature feature of the reference client seems to be undocumented, most likely for a good reason. Don’t take this as a reference!\n\nSometimes you need direct access to the lower levels of your device, and we have already looked at how ADB enables developers and power users to do many useful things. But what do you do when you can’t rely on the operating system, which runs the ADB daemon? Maybe you want to push and boot a modified kernel just once? Or your OS is broken and no longer exposes an ADB interface, so you have to re-flash everything?\n\nThis is where Fastboot comes in.\n\nFastboot basics\n\nFastboot is a simple interface to the Android bootloader. It is much more generic than vendor-specific protocols (look at all the crazy solutions in the MediaTek articles), but allows vendor-specific extensions. Most Android device bootloaders can be switched to Fastboot mode, but not every device might interpret every possible command. A “locked” bootloader e.g. will typically refuse to flash partitions or only let signed images through. Sometimes it may be possible to unlock the bootloader.\n\nUnlike ADB, which also runs over TCP/IP, Fastboot only supports USB. The design is much simpler, there are only the bootloader and a client on the USB Host. The reference client implementation is part of the Android SDK.\n\nThe Fastboot wire protocol\n\nThe protocol is very simple: It consists of ASCII text commands up to 64 bytes in size, in the form :. All data is transported in USB Bulk mode frames. The bootloader will answer every command with an ASCII text response of up to 64 bytes in length. The following responses are legal:\n\nINFO, potentially followed by an informational message that the reference client prints to stderr.\n\nOKAY, potentially followed by a response that may or may not be checked.\n\nFAIL, potentially followed by a failure reason.\n\nDATA, followed by the amount of data the bootloader is willing to accept. This is always compared against the amount of data the client announced as a parameter with the command, and the command is aborted if it wants to send more data than the bootloader can take.\n\nIf the command has a payload, it is sent in a second transfer after a positive response.\n\nThe following commands are used in the reference implementation:\n\ngetvar: queries a bootloader variable. Every bootloader may expose different variables, the following ones are actively used by the reference client and exposed by the MediaTek Little Kernel:\n\npartition-type: returns the type of the partition with the given name, e.g. “raw data” or “ext4”.\n\npartition-size: returns the size of the partition with the given name in hexadecimal.\n\nmax-download-size returns the maximum amount of data that can be written to the device using the download command, if there is a limit.\n\nproduct returns the product name, e.g. “krillin” on the bq Aquaris E4.5 Ubuntu Edition.\n\nkernel returns “lk” on the bq Aquaris E4.5 Ubuntu Edition.\n\nversion returns “0.5” on the bq Aquaris E4.5 Ubuntu Edition.\n\nerase: erases the partition with the given name.\n\ndownload: sends size (in hexadecimal, max. 32 bits) bytes of data to the bootloader memory for later processing.\n\nflash: writes the data the bootloader has previously received using the download command to the partition with the given name. Note that if multiple pairs of the download and flash commands are issued to the same partition, every flash command will append its data at the end of the previous writes. This means that large partitions have to be written in blocks of max-download-size bytes.\n\nsignature activates a 256 bytes long signature that was previously sent to the device using the download command. I am not sure what the bootloader does with this signature, probably it is uses for a cryptographic verification process.\n\ncontinue aborts Fastboot mode and the bootloader continues to boot normally.\n\nboot boots into an Android boot image that was previously sent to the device using the download command.\n\nreboot-bootloader reboots into the bootloader.\n\nOEM commands\n\nThe bootloader may implement additional, manufacturer-specific commands. These do not follow the usual protocol command format, and they cannot have a payload. Some manufacturers implement a lot of OEM commands, as can be seen here. MediaTek just implements two: fastboot oem p2u on and fastboot oem p2u off, these enable or disable the redirection of Linux kernel messages to the UART.\n\nNote that the most well-known OEM command, fastboot oem unlock, is not available on the most devices. This command was invented by Google for their Nexus devices.\n\nReference client commands\n\nThe reference fastboot client supports the following commands:\n\ndevices: Detects and lists attached devices.\n\ngetvar : Issues the getvar wire command with the given variable.\n\nformat : Formats the given partition. The client will first request the partition-type of the partition and compare it against a list of known “generators” (mkfs tools), of which there currently is just one: ext4. If there is a generator for the returned partition type, the partition-size is requested and an empty filesystem image generated on /tmp on the host. This image is then downloaded to device memory and flashed to the given partition.\n\nsignature : The given signature file is downloaded to the device and activated using the signature command.\n\nreboot: Issues the reboot wire command.\n\nreboot-bootloader: Issues the reboot-bootloader wire command.\n\ncontinue: issues the continue wire command.\n\nboot []: Loads the given kernel image file (and optionally the ramdisk), builds an Android boot image on the fly, downloads the generated image to device memory and issues the boot wire command.\n\nflash []: Checks the max-download-size the device supports, then downloads the given image file to the partition with the given name in chunks (“sparse mode”, if necessary). If no filename is given, the client tries to guess the filename from a list of default filenames (boot.img, recovery.img etc.) and the product name.\n\nflash:raw []: Loads the given kernel image file (and optionally the ramdisk), builds an Android boot image on the fly, downloads the generated image to device memory and flashes it to the given partition.\n\nflashall: This is probably intended for automated flashing on production lines. The client reads key-value pairs from a configuration file called android-info.txt and requests every key using the getvar command. The responses are compared to the values from the configuration file, making sure that the device is in the expected state. Then boot.img, recovery.img, system.img and their associated signature files are downloaded, activated and written to the corresponding partitions.\n\nupdate : Applies a device update from a ZIP archive. This is exactly the same step as flashall, except that the image and signature files are extracted from the archive.\n\noem : Sends an OEM command.\n\nThe reference client supports the concatenation of commands, e.g. the following works:\n\nThe following command line options are supported:\n\n-w: Erase and format the userdata and cache partitions before executing any other commands.\n\n-u: Erase partitions before flashing them.\n\n-b : Set an alternative base address for the boot and flash:raw commands.\n\n-n : Set an alternative page size for the boot and flash:raw commands (default: 2048).\n\n-s : Set a target device serial number in case multiple devices are connected. Can also be set through the ANDROID_SERIAL environment variable.\n\n-S : Overrides the the max-download-size limit reported by the device.\n\n-l: List device paths when executing the devices command.\n\n-p : Set the product name, can also be set through the ANDROID_PRODUCT_OUT environment variable.\n\n-c : override the kernel command line used when generating Android boot images on the fly.\n\n-i : Specify a vendor ID in case the client does not detect the USB device.\n\nThat’s it for today. If you know better and/or something has changed, please do find me on the Freenode IRC or on Launchpad.net and get in contact!"
    }
}