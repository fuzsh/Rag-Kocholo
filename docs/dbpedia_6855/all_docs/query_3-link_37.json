{
    "id": "dbpedia_6855_3",
    "rank": 37,
    "data": {
        "url": "https://github.com/peter-evans/create-pull-request/blob/main/docs/examples.md",
        "read_more_link": "",
        "language": "en",
        "title": "create-pull-request/docs/examples.md at main · peter-evans/create-pull-request",
        "top_image": "https://opengraph.githubassets.com/a4a2cf6e17d7c14979059218c4153b50fb3e65a9c83ec138aa3bbf0c6797b9e9/peter-evans/create-pull-request",
        "meta_img": "https://opengraph.githubassets.com/a4a2cf6e17d7c14979059218c4153b50fb3e65a9c83ec138aa3bbf0c6797b9e9/peter-evans/create-pull-request",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "peter-evans"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "A GitHub action to create a pull request for changes to your repository in the actions workspace - create-pull-request/docs/examples.md at main · peter-evans/create-pull-request",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/peter-evans/create-pull-request/blob/main/docs/examples.md",
        "text": "Use case: Create a pull request to update X on push\n\nUpdate project authors\n\nKeep a branch up-to-date with another\n\nUse case: Create a pull request to update X on release\n\nUpdate changelog\n\nUse case: Create a pull request to update X periodically\n\nUpdate NPM dependencies\n\nUpdate Gradle dependencies\n\nUpdate Cargo dependencies\n\nUpdate SwaggerUI for GitHub Pages\n\nKeep a fork up-to-date with its upstream\n\nSpider and download a website\n\nUse case: Create a pull request to update X by calling the GitHub API\n\nCall the GitHub API from an external service\n\nCall the GitHub API from another GitHub Actions workflow\n\nUse case: Create a pull request to modify/fix pull requests\n\nautopep8\n\nMisc workflow tips\n\nFiltering push events\n\nDynamic configuration using variables\n\nUsing a markdown template\n\nDebugging GitHub Actions\n\nUse case: Create a pull request to update X on push\n\nThis pattern will work well for updating any kind of static content based on pushed changes. Care should be taken when using this pattern in repositories with a high frequency of commits.\n\nUpdate project authors\n\nRaises a pull request to update a file called AUTHORS with the git user names and email addresses of contributors.\n\nKeep a branch up-to-date with another\n\nThis is a use case where a branch should be kept up to date with another by opening a pull request to update it. The pull request should then be updated with new changes until it is merged or closed.\n\nIn this example scenario, a branch called production should be updated via pull request to keep it in sync with main. Merging the pull request is effectively promoting those changes to production.\n\nUse case: Create a pull request to update X on release\n\nThis pattern will work well for updating any kind of static content based on the tagged commit of a release. Note that because release is one of the events which checkout a commit it is necessary to supply the base input to the action.\n\nUpdate changelog\n\nRaises a pull request to update the CHANGELOG.md file based on the tagged commit of the release. Note that git-chglog requires some configuration files to exist in the repository before this workflow will work.\n\nThis workflow assumes the tagged release was made on a default branch called main.\n\nUse case: Create a pull request to update X periodically\n\nThis pattern will work well for updating any kind of static content from an external source. The workflow executes on a schedule and raises a pull request when there are changes.\n\nUpdate NPM dependencies\n\nThis workflow will create a pull request for npm dependencies. It works best in combination with a build workflow triggered on push and pull_request. A Personal Access Token (PAT) can be used in order for the creation of the pull request to trigger further workflows. See the documentation here for further details.\n\nThe above workflow works best in combination with a build workflow triggered on push and pull_request.\n\nUpdate Gradle dependencies\n\nThe following workflow will create a pull request for Gradle dependencies. It requires first configuring your project to use Gradle lockfiles. See here for how to configure your project and use the following workflow.\n\nUpdate Cargo dependencies\n\nThe following workflow will create a pull request for Cargo dependencies. It optionally uses cargo-edit to update Cargo.toml and keep it in sync with Cargo.lock.\n\nUpdate SwaggerUI for GitHub Pages\n\nWhen using GitHub Pages to host Swagger documentation, this workflow updates the repository with the latest distribution of SwaggerUI.\n\nYou must create a file called swagger-ui.version at the root of your repository before running.\n\nKeep a fork up-to-date with its upstream\n\nThis example is designed to be run in a seperate repository from the fork repository itself. The aim of this is to prevent committing anything to the fork's default branch would cause it to differ from the upstream.\n\nIn the following example workflow, owner/repo is the upstream repository and fork-owner/repo is the fork. It assumes the default branch of the upstream repository is called main.\n\nThe Personal Access Token (PAT) should have repo scope. Additionally, if the upstream makes changes to the .github/workflows directory, the action will be unable to push the changes to a branch and throw the error \"(refusing to allow a GitHub App to create or update workflow .github/workflows/xxx.yml without workflows permission)\". To allow these changes to be pushed to the fork, add the workflow scope to the PAT. Of course, allowing this comes with the risk that the workflow changes from the upstream could run and do something unexpected. Disabling GitHub Actions in the fork is highly recommended to prevent this.\n\nWhen you merge the pull request make sure to choose the Rebase and merge option. This will make the fork's commits match the commits on the upstream.\n\nThis workflow spiders a website and downloads the content. Any changes to the website will be raised in a pull request.\n\nUse case: Create a pull request to update X by calling the GitHub API\n\nYou can use the GitHub API to trigger a webhook event called repository_dispatch when you want to trigger a workflow for any activity that happens outside of GitHub. This pattern will work well for updating any kind of static content from an external source.\n\nYou can modify any of the examples in the previous section to work in this fashion.\n\nSet the workflow to execute on: repository_dispatch.\n\nAn on: repository_dispatch workflow can be triggered by a call to the GitHub API as follows.\n\n[username] is a GitHub username\n\n[token] is a repo scoped Personal Access Token\n\n[repository] is the name of the repository the workflow resides in.\n\nAn on: repository_dispatch workflow can be triggered from another workflow with repository-dispatch action.\n\nNote: While the following approach does work, my strong recommendation would be to use a slash command style \"ChatOps\" solution for operations on pull requests. See slash-command-dispatch for such a solution.\n\nThis is a pattern that lends itself to automated code linting and fixing. A pull request can be created to fix or modify something during an on: pull_request workflow. The pull request containing the fix will be raised with the original pull request as the base. This can be then be merged to update the original pull request and pass any required tests.\n\nNote that due to token restrictions on public repository forks, workflows for this use case do not work for pull requests raised from forks. Private repositories can be configured to enable workflows from forks to run without restriction.\n\nThe following is an example workflow for a use case where autopep8 action runs as both a check on pull requests and raises a further pull request to apply code fixes.\n\nHow it works:\n\nWhen a pull request is raised the workflow executes as a check\n\nIf autopep8 makes any fixes a pull request will be raised for those fixes to be merged into the current pull request branch. The workflow then deliberately causes the check to fail.\n\nWhen the pull request containing the fixes is merged the workflow runs again. This time autopep8 makes no changes and the check passes.\n\nThe original pull request can now be merged.\n\nFor workflows using on: push you may want to ignore push events for tags and only execute for branches. Specifying branches causes only events on branches to trigger the workflow. The '**' wildcard will match any branch name.\n\nIf you have a workflow that contains jobs to handle push events on branches as well as tags, you can make sure that the job where you use create-pull-request action only executes when github.ref is a branch by using an if condition as follows.\n\nThe following examples show how configuration for the action can be dynamically defined in a previous workflow step. Note that the step where output variables are defined must have an id.\n\nIn this example, a markdown template file is added to the repository at .github/pull-request-template.md with the following content.\n\nThe template is rendered using the render-template action and the result is used to create the pull request.\n\nRunner diagnostic logging provides additional log files that contain information about how a runner is executing an action. To enable runner diagnostic logging, set the secret ACTIONS_RUNNER_DEBUG to true in the repository that contains the workflow."
    }
}