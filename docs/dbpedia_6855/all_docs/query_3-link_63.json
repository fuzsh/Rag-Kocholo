{
    "id": "dbpedia_6855_3",
    "rank": 63,
    "data": {
        "url": "https://nim-lang.org/docs/tut1.html",
        "read_more_link": "",
        "language": "en",
        "title": "Nim Tutorial (Part I)",
        "top_image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=",
        "meta_img": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Source Edit\n\nAuthor:Andreas Rumpf Version:2.0.8\n\nIntroduction\n\n\"Der Mensch ist doch ein Augentier -- SchÃ¶ne Dinge wÃ¼nsch' ich mir.\"\n\nThis document is a tutorial for the programming language Nim.\n\nThis tutorial assumes that you are familiar with basic programming concepts like variables, types, or statements.\n\nHere are several other resources for learning Nim:\n\nNim Basics tutorial - a gentle introduction of the concepts mentioned above\n\nLearn Nim in 5 minutes - quick, five-minute introduction to Nim\n\nThe Nim manual - many more examples of the advanced language features\n\nAll code examples in this tutorial, as well as the ones found in the rest of Nim's documentation, follow the Nim style guide.\n\nThe first program\n\nWe start the tour with a modified \"hello world\" program:\n\necho \"What's your name? \" var name: string = readLine(stdin) echo \"Hi, \", name, \"!\"\n\nSave this code to the file \"greetings.nim\". Now compile and run it:\n\nnim compile --run greetings.nim\n\nWith the --run switch Nim executes the file automatically after compilation. You can give your program command-line arguments by appending them after the filename:\n\nnim compile --run greetings.nim arg1 arg2\n\nCommonly used commands and switches have abbreviations, so you can also use:\n\nnim c -r greetings.nim\n\nThis is a debug version. To compile a release version use:\n\nnim c -d:release greetings.nim\n\nBy default, the Nim compiler generates a large number of runtime checks aiming for your debugging pleasure. With -d:release some checks are turned off and optimizations are turned on.\n\nFor benchmarking or production code, use the -d:release switch. For comparing the performance with unsafe languages like C, use the -d:danger switch in order to get meaningful, comparable results. Otherwise, Nim might be handicapped by checks that are not even available for C.\n\nThough it should be pretty obvious what the program does, I will explain the syntax: statements which are not indented are executed when the program starts. Indentation is Nim's way of grouping statements. Indentation is done with spaces only, tabulators are not allowed.\n\nString literals are enclosed in double-quotes. The var statement declares a new variable named name of type string with the value that is returned by the readLine procedure. Since the compiler knows that readLine returns a string, you can leave out the type in the declaration (this is called local type inference). So this will work too:\n\nvar name = readLine(stdin)\n\nNote that this is basically the only form of type inference that exists in Nim: it is a good compromise between brevity and readability.\n\nThe \"hello world\" program contains several identifiers that are already known to the compiler: echo, readLine, etc. These built-ins are declared in the system module which is implicitly imported by any other module.\n\nLexical elements\n\nLet us look at Nim's lexical elements in more detail: like other programming languages Nim consists of (string) literals, identifiers, keywords, comments, operators, and other punctuation marks.\n\nString and character literals\n\nString literals are enclosed in double-quotes; character literals in single quotes. Special characters are escaped with \\: \\n means newline, \\t means tabulator, etc. There are also raw string literals:\n\nr\"C:\\program files\\nim\"\n\nIn raw literals, the backslash is not an escape character.\n\nThe third and last way to write string literals is long-string literals. They are written with three quotes: \"\"\" ... \"\"\"; they can span over multiple lines and the \\ is not an escape character either. They are very useful for embedding HTML code templates for example.\n\nComments start anywhere outside a string or character literal with the hash character . Documentation comments start with :\n\nvar myVariable: int\n\nDocumentation comments are tokens; they are only allowed at certain places in the input file as they belong to the syntax tree! This feature enables simpler documentation generators.\n\nMultiline comments are started with and terminated with ]. Multiline comments can also be nested.\n\nNumbers\n\nNumerical literals are written as in most other languages. As a special twist, underscores are allowed for better readability: 1_000_000 (one million). A number that contains a dot (or 'e' or 'E') is a floating-point literal: 1.0e9 (one billion). Hexadecimal literals are prefixed with 0x, binary literals with 0b and octal literals with 0o. A leading zero alone does not produce an octal.\n\nThe var statement\n\nThe var statement declares a new local or global variable:\n\nvar x, y: int\n\nIndentation can be used after the var keyword to list a whole section of variables:\n\nvar x, y: int a, b, c: string\n\nConstants\n\nConstants are symbols which are bound to a value. The constant's value cannot change. The compiler must be able to evaluate the expression in a constant declaration at compile time:\n\nconst x = \"abc\"\n\nIndentation can be used after the const keyword to list a whole section of constants:\n\nconst x = 1 y = 2 z = y + 5\n\nThe let statement\n\nThe let statement works like the var statement but the declared symbols are single assignment variables: After the initialization their value cannot change:\n\nlet x = \"abc\" x = \"xyz\"\n\nThe difference between let and const is: let introduces a variable that can not be re-assigned, const means \"enforce compile time evaluation and put it into a data section\":\n\nconst input = readLine(stdin)\n\nlet input = readLine(stdin)\n\nThe assignment statement\n\nThe assignment statement assigns a new value to a variable or more generally to a storage location:\n\nvar x = \"abc\" x = \"xyz\"\n\n= is the assignment operator. The assignment operator can be overloaded. You can declare multiple variables with a single assignment statement and all the variables will have the same value:\n\nvar x, y = 3 echo \"x \", x echo \"y \", y x = 42 echo \"x \", x echo \"y \", y\n\nControl flow statements\n\nThe greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.\n\nIf statement\n\nThe if statement is one way to branch the control flow:\n\nlet name = readLine(stdin) if name == \"\": echo \"Poor soul, you lost your name?\" elif name == \"name\": echo \"Very funny, your name is name.\" else: echo \"Hi, \", name, \"!\"\n\nThere can be zero or more elif parts, and the else part is optional. The keyword elif is short for else if, and is useful to avoid excessive indentation. (The \"\" is the empty string. It contains no characters.)\n\nCase statement\n\nAnother way to branch is provided by the case statement. A case statement allows for multiple branches:\n\nlet name = readLine(stdin) case name of \"\": echo \"Poor soul, you lost your name?\" of \"name\": echo \"Very funny, your name is name.\" of \"Dave\", \"Frank\": echo \"Cool name!\" else: echo \"Hi, \", name, \"!\"\n\nAs it can be seen, for an of branch a comma-separated list of values is also allowed.\n\nThe case statement can deal with integers, other ordinal types, and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:\n\nfrom std/strutils import parseInt echo \"A number please: \" let n = parseInt(readLine(stdin)) case n of 0..2, 4..7: echo \"The number is in the set: {0, 1, 2, 4, 5, 6, 7}\" of 3, 8: echo \"The number is 3 or 8\"\n\nHowever, the above code does not compile: the reason is that you have to cover every value that n may contain, but the code only handles the values 0..8. Since it is not very practical to list every other possible integer (though it is possible thanks to the range notation), we fix this by telling the compiler that for every other value nothing should be done:\n\n... case n of 0..2, 4..7: echo \"The number is in the set: {0, 1, 2, 4, 5, 6, 7}\" of 3, 8: echo \"The number is 3 or 8\" else: discard\n\nThe empty discard statement is a do nothing statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an else branch.\n\nIn general, the case statement is used for subrange types or enumerations where it is of great help that the compiler checks that you covered any possible value.\n\nWhile statement\n\nThe while statement is a simple looping construct:\n\necho \"What's your name? \" var name = readLine(stdin) while name == \"\": echo \"Please tell me your name: \" name = readLine(stdin)\n\nThe example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).\n\nFor statement\n\nThe for statement is a construct to loop over any element an iterator provides. The example uses the built-in countup iterator:\n\necho \"Counting to ten: \" for i in countup(1, 10): echo i\n\nThe variable i is implicitly declared by the for loop and has the type int, because that is what countup returns. i runs through the values 1, 2, .., 10. Each value is echo-ed. This code does the same:\n\necho \"Counting to 10: \" var i = 1 while i <= 10: echo i inc i\n\nSince counting up occurs so often in programs, Nim also has a .. iterator that does the same:\n\nfor i in 1 .. 10: ...\n\nCounting down can be achieved as easily (but is less often needed):\n\necho \"Counting down from 10 to 1: \" for i in countdown(10, 1): echo i\n\nZero-indexed counting has two shortcuts ..< and .. ^1 (backward index operator) to simplify counting to one less than the higher index:\n\nfor i in 0 ..< 10: ...\n\nor\n\nvar s = \"some string\" for i in 0 ..< s.len: ...\n\nor\n\nvar s = \"some string\" for idx, c in s[0 .. ^1]: ...\n\nOther useful iterators for collections (like arrays and sequences) are\n\nitems and mitems, which provides immutable and mutable elements respectively, and\n\npairs and mpairs which provides the element and an index number (immutable and mutable respectively)\n\nfor index, item in [\"a\",\"b\"].pairs: echo item, \" at index \", index\n\nScopes and the block statement\n\nControl flow statements have a feature not covered yet: they open a new scope. This means that in the following example, x is not accessible outside the loop:\n\nwhile false: var x = \"hi\" echo x\n\nA while (for) statement introduces an implicit block. Identifiers are only visible within the block they have been declared. The block statement can be used to open a new block explicitly:\n\nblock myblock: var x = \"hi\" echo x\n\nThe block's label (myblock in the example) is optional.\n\nBreak statement\n\nA block can be left prematurely with a break statement. The break statement can leave a while, for, or a block statement. It leaves the innermost construct, unless a label of a block is given:\n\nblock myblock: echo \"entering block\" while true: echo \"looping\" break echo \"still in block\" echo \"outside the block\" block myblock2: echo \"entering block\" while true: echo \"looping\" break myblock2 echo \"still in block\" echo \"outside the block\"\n\nContinue statement\n\nLike in many other programming languages, a continue statement starts the next iteration immediately:\n\nfor i in 1 .. 5: if i <= 3: continue echo i\n\nWhen statement\n\nExample:\n\nwhen system.hostOS == \"windows\": echo \"running on Windows!\" elif system.hostOS == \"linux\": echo \"running on Linux!\" elif system.hostOS == \"macosx\": echo \"running on Mac OS X!\" else: echo \"unknown operating system\"\n\nThe when statement is almost identical to the if statement, but with these differences:\n\nEach condition must be a constant expression since it is evaluated by the compiler.\n\nThe statements within a branch do not open a new scope.\n\nThe compiler checks the semantics and produces code only for the statements that belong to the first condition that evaluates to true.\n\nThe when statement is useful for writing platform-specific code, similar to the #ifdef construct in the C programming language.\n\nStatements and indentation\n\nNow that we covered the basic control flow statements, let's return to Nim indentation rules.\n\nIn Nim, there is a distinction between simple statements and complex statements. Simple statements cannot contain other statements: Assignment, procedure calls, or the return statement are all simple statements. Complex statements like if, when, for, while can contain other statements. To avoid ambiguities, complex statements must always be indented, but single simple statements do not:\n\nif x: x = false if x: if y: y = false else: y = true if x: x = false y = false\n\nExpressions are parts of a statement that usually result in a value. The condition in an if statement is an example of an expression. Expressions can contain indentation at certain places for better readability:\n\nif thisIsaLongCondition() and thisIsAnotherLongCondition(1, 2, 3, 4): x = true\n\nAs a rule of thumb, indentation within expressions is allowed after operators, an open parenthesis and after commas.\n\nWith parenthesis and semicolons (;) you can use statements where only an expression is allowed:\n\nconst fac4 = (var x = 1; for i in 1..4: x *= i; x)\n\nProcedures\n\nTo define new commands like echo and readLine in the examples, the concept of a procedure is needed. You might be used to them being called methods or functions in other languages, but Nim differentiates these concepts. In Nim, new procedures are defined with the proc keyword:\n\nproc yes(question: string): bool = echo question, \" (y/n)\" while true: case readLine(stdin) of \"y\", \"Y\", \"yes\", \"Yes\": return true of \"n\", \"N\", \"no\", \"No\": return false else: echo \"Please be clear: yes or no\" if yes(\"Should I delete all your important files?\"): echo \"I'm sorry Dave, I'm afraid I can't do that.\" else: echo \"I think you know what the problem is just as well as I do.\"\n\nThis example shows a procedure named yes that asks the user a question and returns true if they answered \"yes\" (or something similar) and returns false if they answered \"no\" (or something similar). A return statement leaves the procedure (and therefore the while loop) immediately. The (question: string): bool syntax describes that the procedure expects a parameter named question of type string and returns a value of type bool. The bool type is built-in: the only valid values for bool are true and false. The conditions in if or while statements must be of type bool.\n\nSome terminology: in the example question is called a (formal) parameter, \"Should I...\" is called an argument that is passed to this parameter.\n\nResult variable\n\nA procedure that returns a value has an implicit result variable declared that represents the return value. A return statement with no expression is shorthand for return result. The result value is always returned automatically at the end of a procedure if there is no return statement at the exit.\n\nproc sumTillNegative(x: varargs[int]): int = for i in x: if i < 0: return result = result + i echo sumTillNegative() echo sumTillNegative(3, 4, 5) echo sumTillNegative(3, 4 , -1 , 6)\n\nThe result variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialized with the type's default value. Note that referential data types will be nil at the start of the procedure, and thus may require manual initialization.\n\nA procedure that does not have any return statement and does not use the special result variable returns the value of its last expression. For example, this procedure\n\nproc helloWorld(): string = \"Hello, World!\"\n\nreturns the string \"Hello, World!\".\n\nParameters\n\nParameters are immutable in the procedure body. By default, their value cannot be changed because this allows the compiler to implement parameter passing in the most efficient way. If a mutable variable is needed inside the procedure, it has to be declared with var in the procedure body. Shadowing the parameter name is possible, and actually an idiom:\n\nproc printSeq(s: seq, nprinted: int = -1) = var nprinted = if nprinted == -1: s.len else: min(nprinted, s.len) for i in 0 ..< nprinted: echo s[i]\n\nIf the procedure needs to modify the argument for the caller, a var parameter can be used:\n\nproc divmod(a, b: int; res, remainder: var int) = res = a div b remainder = a mod b var x, y: int divmod(8, 5, x, y) echo x echo y\n\nIn the example, res and remainder are var parameters. Var parameters can be modified by the procedure and the changes are visible to the caller. Note that the above example would better make use of a tuple as a return value instead of using var parameters.\n\nDiscard statement\n\nTo call a procedure that returns a value just for its side effects and ignoring its return value, a discard statement must be used. Nim does not allow silently throwing away a return value:\n\ndiscard yes(\"May I ask a pointless question?\")\n\nThe return value can be ignored implicitly if the called proc/iterator has been declared with the discardable pragma:\n\nproc p(x, y: int): int {.discardable.} = return x + y p(3, 4)\n\nNamed arguments\n\nOften a procedure has many parameters and it is not clear in which order the parameters appear. This is especially true for procedures that construct a complex data type. Therefore, the arguments to a procedure can be named, so that it is clear which argument belongs to which parameter:\n\nproc createWindow(x, y, width, height: int; title: string; show: bool): Window = ... var w = createWindow(show = true, title = \"My Application\", x = 0, y = 0, height = 600, width = 800)\n\nNow that we use named arguments to call createWindow the argument order does not matter anymore. Mixing named arguments with ordered arguments is also possible, but not very readable:\n\nvar w = createWindow(0, 0, title = \"My Application\", height = 600, width = 800, true)\n\nThe compiler checks that each parameter receives exactly one argument.\n\nDefault values\n\nTo make the createWindow proc easier to use it should provide default values; these are values that are used as arguments if the caller does not specify them:\n\nproc createWindow(x = 0, y = 0, width = 500, height = 700, title = \"unknown\", show = true): Window = ... var w = createWindow(title = \"My Application\", height = 600, width = 800)\n\nNow the call to createWindow only needs to set the values that differ from the defaults.\n\nNote that type inference works for parameters with default values; there is no need to write title: string = \"unknown\", for example.\n\nOverloaded procedures\n\nNim provides the ability to overload procedures similar to C++:\n\nproc toString(x: int): string = result = if x < 0: \"negative\" elif x > 0: \"positive\" else: \"zero\" proc toString(x: bool): string = result = if x: \"yep\" else: \"nope\" assert toString(13) == \"positive\" assert toString(true) == \"yep\"\n\n(Note that toString is usually the $ operator in Nim.) The compiler chooses the most appropriate proc for the toString calls. How this overloading resolution algorithm works exactly is not discussed here -- see the manual for details. Ambiguous calls are reported as errors.\n\nOperators\n\nThe Nim standard library makes heavy use of overloading - one reason for this is that each operator like + is just an overloaded proc. The parser lets you use operators in infix notation (a + b) or prefix notation (+ a). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does a @ @ b mean (a) @ (@b) or (a@) @ (b)? It always means (a) @ (@b), because there are no postfix operators in Nim.)\n\nApart from a few built-in keyword operators such as and, or, not, operators always consist of these characters: + - * \\ / < > = @ $ ~ & % ! ? ^ . |\n\nUser-defined operators are allowed. Nothing stops you from defining your own @!?+~ operator, but doing so may reduce readability.\n\nThe operator's precedence is determined by its first character. The details can be found in the manual.\n\nTo define a new operator enclose the operator in backticks \"`\":\n\nproc `$` (x: myDataType): string = ...\n\nThe \"`\" notation can also be used to call an operator just like any other procedure:\n\nif `==`( `+`(3, 4), 7): echo \"true\"\n\nForward declarations\n\nEvery variable, procedure, etc. needs to be declared before it can be used. (The reason for this is that it is non-trivial to avoid this need in a language that supports metaprogramming as extensively as Nim does.) However, this cannot be done for mutually recursive procedures:\n\nproc even(n: int): bool\n\nproc odd(n: int): bool = assert(n >= 0) if n == 0: false else: n == 1 or even(n-1) proc even(n: int): bool = assert(n >= 0) if n == 1: false else: n == 0 or odd(n-1)\n\nHere odd depends on even and vice versa. Thus even needs to be introduced to the compiler before it is completely defined. The syntax for such a forward declaration is simple: just omit the = and the procedure's body. The assert just adds border conditions, and will be covered later in Modules section.\n\nLater versions of the language will weaken the requirements for forward declarations.\n\nThe example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.\n\nFuncs and methods\n\nAs mentioned in the introduction, Nim differentiates between procedures, functions, and methods, defined by the proc, func, and method keywords respectively. In some ways, Nim is a bit more pedantic in its definitions than other languages.\n\nFunctions are closer to the concept of a pure mathematical function, which might be familiar to you if you've ever done functional programming. Essentially they are procedures with additional limitations set on them: they can't access global state (except const) and can't produce side-effects. The func keyword is basically an alias for proc tagged with {.noSideEffects.}. Functions can still change their mutable arguments however, which are those marked as var, along with any ref objects.\n\nUnlike procedures, methods are dynamically dispatched. This sounds a bit complicated, but it is a concept closely related to inheritance and object-oriented programming. If you overload a procedure (two procedures with the same name but of different types or with different sets of arguments are said to be overloaded), the procedure to use is determined at compile-time. Methods, on the other hand, depend on objects that inherit from the RootObj. This is something that is covered in much greater depth in the second part of the tutorial.\n\nIterators\n\nLet's return to the simple counting example:\n\necho \"Counting to ten: \" for i in countup(1, 10): echo i\n\nCan a countup proc be written that supports this loop? Let's try:\n\nproc countup(a, b: int): int = var res = a while res <= b: return res inc(res)\n\nHowever, this does not work. The problem is that the procedure should not only return, but return and continue after an iteration has finished. This return and continue is called a yield statement. Now the only thing left to do is to replace the proc keyword by iterator and here it is -- our first iterator:\n\niterator countup(a, b: int): int = var res = a while res <= b: yield res inc(res)\n\nIterators look very similar to procedures, but there are several important differences:\n\nIterators can only be called from for loops.\n\nIterators cannot contain a return statement (and procs cannot contain a yield statement).\n\nIterators have no implicit result variable.\n\nIterators do not support recursion.\n\nIterators cannot be forward declared, because the compiler must be able to inline an iterator. (This restriction will be gone in a future version of the compiler.)\n\nHowever, you can also use a closure iterator to get a different set of restrictions. See first-class iterators for details. Iterators can have the same name and parameters as a proc since essentially they have their own namespaces. Therefore, it is common to wrap iterators in procs of the same name which accumulate the result of the iterator and return it as a sequence, like split from the strutils module.\n\nBasic types\n\nThis section deals with the basic built-in types and the operations that are available for them in detail.\n\nBooleans\n\nNim's boolean type is called bool and consists of the two pre-defined values true and false. Conditions in while, if, elif, and when statements must be of type bool.\n\nThe operators not, and, or, xor, <, <=, >, >=, !=, == are defined for the bool type. The and and or operators perform short-circuit evaluation. For example:\n\nwhile p != nil and p.name != \"xyz\": p = p.next\n\nCharacters\n\nThe character type is called char. Its size is always one byte, so it cannot represent most UTF-8 characters, but it can represent one of the bytes that makes up a multibyte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was especially designed for this. Character literals are enclosed in single quotes.\n\nChars can be compared with the ==, <, <=, >, >= operators. The $ operator converts a char to a string. Chars cannot be mixed with integers; to get the ordinal value of a char use the ord proc. Converting from an integer to a char is done with the chr proc.\n\nStrings\n\nString variables are mutable, so appending to a string is possible, and quite efficient. Strings in Nim are both zero-terminated and have a length field. A string's length can be retrieved with the builtin len procedure; the length never counts the terminating zero. Accessing the terminating zero is an error, it only exists so that a Nim string can be converted to a cstring without doing a copy.\n\nThe assignment operator for strings copies the string. You can use the & operator to concatenate strings and add to append to a string.\n\nStrings are compared using their lexicographical order. All the comparison operators are supported. By convention, all strings are UTF-8 encoded, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation s[i] means the i-th char of s, not the i-th unichar.\n\nA string variable is initialized with the empty string \"\".\n\nIntegers\n\nNim has these integer types built-in: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64.\n\nThe default integer type is int. Integer literals can have a type suffix to specify a non-default integer type:\n\nlet x = 0 y = 0'i8 z = 0'i32 u = 0'u\n\nMost often integers are used for counting objects that reside in memory, so int has the same size as a pointer.\n\nThe common operators + - * div mod < <= == != > >= are defined for integers. The and or xor not operators are also defined for integers and provide bitwise operations. Left bit shifting is done with the shl, right shifting with the shr operator. Bit shifting operators always treat their arguments as unsigned. For arithmetic bit shifts ordinary multiplication or division can be used.\n\nUnsigned operations all wrap around; they cannot lead to over- or under-flow errors.\n\nLossless Automatic type conversion is performed in expressions where different kinds of integer types are used. However, if the type conversion would cause loss of information, the RangeDefect is raised (if the error cannot be detected at compile time).\n\nFloats\n\nNim has these floating-point types built-in: float float32 float64.\n\nThe default float type is float. In the current implementation, float is always 64-bits.\n\nFloat literals can have a type suffix to specify a non-default float type:\n\nvar x = 0.0 y = 0.0'f32 z = 0.0'f64\n\nThe common operators + - * / < <= == != > >= are defined for floats and follow the IEEE-754 standard.\n\nAutomatic type conversion in expressions with different kinds of floating-point types is performed: the smaller type is converted to the larger. Integer types are not converted to floating-point types automatically, nor vice versa. Use the toInt and toFloat procs for these conversions.\n\nType Conversion\n\nConversion between numerical types is performed by using the type as a function:\n\nvar x: int32 = 1.int32 y: int8 = int8('a') z: float = 2.5 sum: int = int(x) + int(y) + int(z)\n\nInternal type representation\n\nAs mentioned earlier, the built-in $ (stringify) operator turns any basic type into a string, which you can then print to the console using the echo proc. However, advanced types, and your own custom types, won't work with the $ operator until you define it for them. Sometimes you just want to debug the current value of a complex type without having to write its $ operator. You can use then the repr proc which works with any type and even complex data graphs with cycles. The following example shows that even for basic types there is a difference between the $ and repr outputs:\n\nvar myBool = true myCharacter = 'n' myString = \"nim\" myInteger = 42 myFloat = 3.14 echo myBool, \":\", repr(myBool) echo myCharacter, \":\", repr(myCharacter) echo myString, \":\", repr(myString) echo myInteger, \":\", repr(myInteger) echo myFloat, \":\", repr(myFloat)\n\nAdvanced types\n\nIn Nim new types can be defined within a type statement:\n\ntype biggestInt = int64 biggestFloat = float64\n\nEnumeration and object types may only be defined within a type statement.\n\nEnumerations\n\nA variable of an enumeration type can only be assigned one of the enumeration's specified values. These values are a set of ordered symbols. Each symbol is mapped to an integer value internally. The first symbol is represented at runtime by 0, the second by 1, and so on. For example:\n\ntype Direction = enum north, east, south, west var x = south echo x\n\nAll the comparison operators can be used with enumeration types.\n\nAn enumeration's symbol can be qualified to avoid ambiguities: Direction.south.\n\nThe $ operator can convert any enumeration value to its name, and the ord proc can convert it to its underlying integer value.\n\nFor better interfacing to other programming languages, the symbols of enum types can be assigned an explicit ordinal value. However, the ordinal values must be in ascending order.\n\nOrdinal types\n\nEnumerations, integer types, char and bool (and subranges) are called ordinal types. Ordinal types have quite a few special operations:\n\nOperationComment ord(x)returns the integer value that is used to represent x's value inc(x)increments x by one inc(x, n)increments x by n; n is an integer dec(x)decrements x by one dec(x, n)decrements x by n; n is an integer succ(x)returns the successor of x succ(x, n)returns the n'th successor of x pred(x)returns the predecessor of x pred(x, n)returns the n'th predecessor of x\n\nThe inc, dec, succ and pred operations can fail by raising an RangeDefect or OverflowDefect. (If the code has been compiled with the proper runtime checks turned on.)\n\nSubranges\n\nA subrange type is a range of values from an integer or enumeration type (the base type). Example:\n\ntype MySubrange = range[0..5]\n\nMySubrange is a subrange of int which can only hold the values 0 to 5. Assigning any other value to a variable of type MySubrange is a compile-time or runtime error. Assignments from the base type to one of its subrange types (and vice versa) are allowed.\n\nThe system module defines the important Natural type as range[0..high(int)] (high returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often unwise: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's Natural type helps to avoid this common programming error.\n\nSets\n\nThe set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:\n\nint8-int16\n\nuint8/byte-uint16\n\nchar\n\nenum\n\nOrdinal subrange types, i.e. range[-10..10]\n\nor equivalent. When constructing a set with signed integer literals, the set's base type is defined to be in the range 0 .. DefaultSetElements-1 where DefaultSetElements is currently always 2^8. The maximum range length for the base type of a set is MaxSetElements which is currently always 2^16. Types with a bigger range length are coerced into the range 0 .. MaxSetElements-1.\n\nThe reason is that sets are implemented as high performance bit vectors. Attempting to declare a set with a larger type will result in an error:\n\nvar s: set[int64]\n\nNote: Nim also offers hash sets (which you need to import with import std/sets), which have no such restrictions.\n\nSets can be constructed via the set constructor: {} is the empty set. The empty set is type compatible with any concrete set type. The constructor can also be used to include elements (and ranges of elements):\n\ntype CharSet = set[char] var x: CharSet x = {'a'..'z', '0'..'9'}\n\nThe module `std/setutils` provides a way to initialize a set from an iterable:\n\nimport std/setutils let uniqueChars = myString.toSet\n\nThese operations are supported by sets:\n\noperationmeaning A + Bunion of two sets A * Bintersection of two sets A - Bdifference of two sets (A without B's elements) A == Bset equality A <= Bsubset relation (A is subset of B or equal to B) A < Bstrict subset relation (A is a proper subset of B) e in Aset membership (A contains element e) e notin AA does not contain element e contains(A, e)A contains element e card(A)the cardinality of A (number of elements in A) incl(A, elem)same as A = A + {elem} excl(A, elem)same as A = A - {elem}\n\nBit fields\n\nSets are often used to define a type for the flags of a procedure. This is a cleaner (and type safe) solution than defining integer constants that have to be or'ed together.\n\nEnum, sets and casting can be used together as in:\n\ntype MyFlag* {.size: sizeof(cint).} = enum A B C D MyFlags = set[MyFlag] proc toNum(f: MyFlags): int = cast[cint](f) proc toFlags(v: int): MyFlags = cast[MyFlags](v) assert toNum({}) == 0 assert toNum({A}) == 1 assert toNum({D}) == 8 assert toNum({A, C}) == 5 assert toFlags(0) == {} assert toFlags(7) == {A, B, C}\n\nNote how the set turns enum values into powers of 2.\n\nIf using enums and sets with C, use distinct cint.\n\nFor interoperability with C see also the bitsize pragma.\n\nArrays\n\nAn array is a simple fixed-length container. Each element in an array has the same type. The array's index type can be any ordinal type.\n\nArrays can be constructed using []:\n\ntype IntArray = array[0..5, int] var x: IntArray x = [1, 2, 3, 4, 5, 6] for i in low(x) .. high(x): echo x[i]\n\nThe notation x[i] is used to access the i-th element of x. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the --bound_checks:off command line switch.\n\nArrays are value types, like any other Nim type. The assignment operator copies the whole array contents.\n\nThe built-in len proc returns the array's length. low(a) returns the lowest valid index for the array a and high(a) the highest valid index.\n\ntype Direction = enum north, east, south, west BlinkLights = enum off, on, slowBlink, mediumBlink, fastBlink LevelSetting = array[north..west, BlinkLights] var level: LevelSetting level[north] = on level[south] = slowBlink level[east] = fastBlink echo level echo low(level) echo len(level) echo high(level)\n\nThe syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided into height levels accessed through their integer index:\n\ntype LightTower = array[1..10, LevelSetting] var tower: LightTower tower[1][north] = slowBlink tower[1][east] = mediumBlink echo len(tower) echo len(tower[1]) echo tower\n\nNote how the built-in len proc returns only the array's first dimension length. Another way of defining the LightTower to better illustrate its nested nature would be to omit the previous definition of the LevelSetting type and instead write it embedded directly as the type of the first dimension:\n\ntype LightTower = array[1..10, array[north..west, BlinkLights]]\n\nIt is quite common to have arrays start at zero, so there's a shortcut syntax to specify a range from zero to the specified index minus one:\n\ntype IntArray = array[0..5, int] QuickArray = array[6, int] var x: IntArray y: QuickArray x = [1, 2, 3, 4, 5, 6] y = x for i in low(x) .. high(x): echo x[i], y[i]\n\nSequences\n\nSequences are similar to arrays but of dynamic length which may change during runtime (like strings). Since sequences are resizable they are always allocated on the heap and garbage collected.\n\nSequences are always indexed with an int starting at position 0. The len, low and high operations are available for sequences too. The notation x[i] can be used to access the i-th element of x.\n\nSequences can be constructed by the array constructor [] in conjunction with the array to sequence operator @. Another way to allocate space for a sequence is to call the built-in newSeq procedure.\n\nA sequence may be passed to an openarray parameter.\n\nExample:\n\nvar x: seq[int] x = @[1, 2, 3, 4, 5, 6]\n\nSequence variables are initialized with @[].\n\nThe for statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The for statement is looping over the results from the items() iterator from the system module. But if you use the two-variable form, the first variable will hold the index position and the second variable will hold the value. Here the for statement is looping over the results from the pairs() iterator from the system module. Examples:\n\nfor value in @[3, 4, 5]: echo value for i, value in @[3, 4, 5]: echo \"index: \", $i, \", value:\", $value\n\nOpen arrays\n\nNote: Openarrays can only be used for parameters.\n\nOften fixed-size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The openarray type allows this. Openarrays are always indexed with an int starting at position 0. The len, low and high operations are available for open arrays too. Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter.\n\nvar fruits: seq[string] capitals: array[3, string] capitals = [\"New York\", \"London\", \"Berlin\"] fruits.add(\"Banana\") fruits.add(\"Mango\") proc openArraySize(oa: openArray[string]): int = oa.len assert openArraySize(fruits) == 2 assert openArraySize(capitals) == 3\n\nThe openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.\n\nVarargs\n\nA varargs parameter is like an openarray parameter. However, it is also a means to implement passing a variable number of arguments to a procedure. The compiler converts the list of arguments to an array automatically:\n\nproc myWriteln(f: File, a: varargs[string]) = for s in items(a): write(f, s) write(f, \"\\n\") myWriteln(stdout, \"abc\", \"def\", \"xyz\") myWriteln(stdout, [\"abc\", \"def\", \"xyz\"])\n\nThis transformation is only done if the varargs parameter is the last parameter in the procedure header. It is also possible to perform type conversions in this context:\n\nproc myWriteln(f: File, a: varargs[string, `$`]) = for s in items(a): write(f, s) write(f, \"\\n\") myWriteln(stdout, 123, \"abc\", 4.0) myWriteln(stdout, [$123, $\"abc\", $4.0])\n\nIn this example $ is applied to any argument that is passed to the parameter a. Note that $ applied to strings is a nop.\n\nSlices\n\nSlices look similar to subranges types in syntax but are used in a different context. A slice is just an object of type Slice which contains two bounds, a and b. By itself a slice is not very useful, but other collection types define operators which accept Slice objects to define ranges.\n\nvar a = \"Nim is a programming language\" b = \"Slices are useless.\" echo a[7 .. 12] b[11 .. ^2] = \"useful\" echo b\n\nIn the previous example slices are used to modify a part of a string. The slice's bounds can hold any value supported by their type, but it is the proc using the slice object which defines what values are accepted.\n\nTo understand the different ways of specifying the indices of strings, arrays, sequences, etc., it must be remembered that Nim uses zero-based indices.\n\nSo the string b is of length 19, and two different ways of specifying the indices are\n\n\"Slices are useless.\" | | | 0 11 17 using indices ^19 ^8 ^2 using ^ syntax\n\nwhere b[0 .. ^1] is equivalent to b[0 .. b.len-1] and b[0 ..< b.len], and it can be seen that the ^1 provides a shorthand way of specifying the b.len-1. See the backwards index operator.\n\nIn the above example, because the string ends in a period, to get the portion of the string that is \"useless\" and replace it with \"useful\".\n\nb[11 .. ^2] is the portion \"useless\", and b[11 .. ^2] = \"useful\" replaces the \"useless\" portion with \"useful\", giving the result \"Slices are useful.\"\n\nNote 1: alternate ways of writing this are b[^8 .. ^2] = \"useful\" or as b[11 .. b.len-2] = \"useful\" or as b[11 ..< b.len-1] = \"useful\".\n\nNote 2: As the ^ template returns a distinct int of type BackwardsIndex, we can have a lastIndex constant defined as const lastIndex = ^1, and later used as b[0 .. lastIndex].\n\nObjects\n\nThe default type to pack different values together in a single structure with a name is the object type. An object is a value type, which means that when an object is assigned to a new variable all its components are copied as well.\n\nEach object type Foo has a constructor Foo(field: value, ...) where all of its fields can be initialized. Unspecified fields will get their default value.\n\ntype Person = object name: string age: int var person1 = Person(name: \"Peter\", age: 30) echo person1.name echo person1.age var person2 = person1 person2.age += 14 echo person1.age echo person2.age let person3 = Person(age: 12, name: \"Quentin\") let person4 = Person(age: 3) doAssert person4.name == \"\"\n\nObject fields that should be visible from outside the defining module have to be marked with *.\n\ntype Person* = object name*: string age*: int\n\nTuples\n\nTuples are very much like what you have seen so far from objects. They are value types where the assignment operator copies each component. Unlike object types though, tuple types are structurally typed, meaning different tuple-types are equivalent if they specify fields of the same type and of the same name in the same order.\n\nThe constructor () can be used to construct tuples. The order of the fields in the constructor must match the order in the tuple's definition. But unlike objects, a name for the tuple type may not be used here.\n\nLike the object type the notation t.field is used to access a tuple's field. Another notation that is not available for objects is t[i] to access the i'th field. Here i must be a constant integer.\n\ntype Person = tuple name: string age: int PersonX = tuple[name: string, age: int] PersonY = (string, int) var person: Person personX: PersonX personY: PersonY person = (name: \"Peter\", age: 30) personX = person personY = (\"Peter\", 30) person = personY personY = person person = (\"Peter\", 30) echo person.name echo person.age echo person[0] echo person[1] var building: tuple[street: string, number: int] building = (\"Rue del Percebe\", 13) echo building.street\n\nEven though you don't need to declare a type for a tuple to use it, tuples created with different field names will be considered different objects despite having the same field types.\n\nTuples can be unpacked during variable assignment. This can be handy to assign directly the fields of the tuples to individually named variables. An example of this is the splitFile proc from the os module which returns the directory, name, and extension of a path at the same time. For tuple unpacking to work you must use parentheses around the values you want to assign the unpacking to, otherwise, you will be assigning the same value to all the individual variables! For example:\n\nimport std/os let path = \"usr/local/nimc.html\" (dir, name, ext) = splitFile(path) baddir, badname, badext = splitFile(path) echo dir echo name echo ext echo baddir echo badname echo badext\n\nTuple unpacking is also supported in for-loops:\n\nlet a = [(10, 'a'), (20, 'b'), (30, 'c')] for (x, c) in a: echo x for i, (x, c) in a: echo i, c\n\nFields of tuples are always public, they don't need to be explicitly marked to be exported, unlike for example fields in an object type.\n\nReference and pointer types\n\nReferences (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory.\n\nNim distinguishes between traced and untraced references. Untraced references are also called pointers. Traced references point to objects in a garbage-collected heap, untraced references point to manually allocated objects or objects elsewhere in memory. Thus, untraced references are unsafe. However, for certain low-level operations (e.g. accessing the hardware), untraced references are necessary.\n\nTraced references are declared with the ref keyword; untraced references are declared with the ptr keyword.\n\nThe empty [] subscript notation can be used to de-refer a reference, meaning to retrieve the item the reference points to. The . (access a tuple/object field operator) and [] (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:\n\ntype Node = ref object le, ri: Node data: int var n = Node(data: 9) echo n.data\n\nTo allocate a new traced object, the built-in procedure new can be used:\n\nvar n: Node new(n)\n\nTo deal with untraced memory, the procedures alloc, dealloc and realloc can be used. The system module's documentation contains further details.\n\nIf a reference points to nothing, it has the value nil.\n\nProcedural type\n\nA procedural type is a (somewhat abstract) pointer to a procedure. nil is an allowed value for a variable of a procedural type. Nim uses procedural types to achieve functional programming techniques.\n\nExample:\n\nproc greet(name: string): string = \"Hello, \" & name & \"!\" proc bye(name: string): string = \"Goodbye, \" & name & \".\" proc communicate(greeting: proc (x: string): string, name: string) = echo greeting(name) communicate(greet, \"John\") communicate(bye, \"Mary\")\n\nA subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. The different calling conventions are listed in the manual.\n\nDistinct type\n\nA Distinct type allows for the creation of a new type that \"does not imply a subtype relationship between it and its base type\". You must explicitly define all behavior for the distinct type. To help with this, both the distinct type and its base type can cast from one type to the other. Examples are provided in the manual.\n\nModules\n\nNim supports splitting a program into pieces with a module concept. Each module is in its own file. Modules enable information hiding and separate compilation. A module may gain access to the symbols of another module by using the import statement. Only top-level symbols that are marked with an asterisk (*) are exported:\n\nvar x*, y: int proc `*` *(a, b: seq[int]): seq[int] = newSeq(result, len(a)) for i in 0 ..< len(a): result[i] = a[i] * b[i] when isMainModule: assert(@[1, 2, 3] * @[1, 2, 3] == @[1, 4, 9])\n\nThe above module exports x and *, but not y.\n\nA module's top-level statements are executed at the start of the program. This can be used to initialize complex data structures for example.\n\nEach module has a special magic constant isMainModule that is true if the module is compiled as the main file. This is very useful to embed tests within the module as shown by the above example.\n\nA symbol of a module can be qualified with the module.symbol syntax. And if a symbol is ambiguous, it must be qualified. A symbol is ambiguous if it is defined in two (or more) different modules and both modules are imported by a third one:\n\nvar x*: string\n\nvar x*: int\n\nimport A, B write(stdout, x) write(stdout, A.x) var x = 4 write(stdout, x)\n\nBut this rule does not apply to procedures or iterators. Here the overloading rules apply:\n\nproc x*(a: int): string = $a\n\nproc x*(a: string): string = $a\n\nimport A, B write(stdout, x(3)) write(stdout, x(\"\")) proc x*(a: int): string = discard write(stdout, x(3))\n\nExcluding symbols\n\nThe normal import statement will bring in all exported symbols. These can be limited by naming symbols that should be excluded using the except qualifier.\n\nimport mymodule except y\n\nFrom statement\n\nWe have already seen the simple import statement that just imports all exported symbols. An alternative that only imports listed symbols is the from import statement:\n\nfrom mymodule import x, y, z\n\nThe from statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified in order to be used.\n\nfrom mymodule import x, y, z x()\n\nfrom mymodule import nil mymodule.x() x()\n\nSince module names are generally long to be descriptive, you can also define a shorter alias to use when qualifying symbols.\n\nfrom mymodule as m import nil m.x()\n\nInclude statement\n\nThe include statement does something fundamentally different than importing a module: it merely includes the contents of a file. The include statement is useful to split up a large module into several files:\n\ninclude fileA, fileB, fileC\n\nPart 2"
    }
}