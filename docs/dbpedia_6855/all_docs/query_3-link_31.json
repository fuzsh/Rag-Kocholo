{
    "id": "dbpedia_6855_3",
    "rank": 31,
    "data": {
        "url": "https://weechat.org/files/doc/weechat/stable/weechat_user.en.html",
        "read_more_link": "",
        "language": "en",
        "title": "WeeChat user’s guide",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "SÃ©bastien Helleu"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "/buflist enable|disable|toggle bar refresh [<item>[,<item>...]] enable: enable buflist disable: disable buflist toggle: toggle buflist bar: add the \"buflist\" bar refresh: force the refresh of some bar items (if no item is given, all bar items used are refreshed, according to option buflist.look.use_items) The lines with buffers are displayed using string evaluation (see /help eval for the format), with these options: - buflist.look.display_conditions: conditions to display a buffer in the list - buflist.format.buffer: format for a buffer which is not current buffer - buflist.format.buffer_current: format for the current buffer The following variables can be used in these options: - bar item data (see hdata \"bar_item\" in API doc for a complete list), for example: - ${bar_item.name} - window data, where the bar item is displayed (there's no window in root bars, see hdata \"window\" in API doc for a complete list), for example: - ${window.number} - ${window.buffer.full_name} - buffer data (see hdata \"buffer\" in API doc for a complete list), for example: - ${buffer.number} - ${buffer.name} - ${buffer.full_name} - ${buffer.short_name} - ${buffer.nicklist_nicks_count} - irc_server: IRC server data, defined only on an IRC buffer (see hdata \"irc_server\" in API doc) - irc_channel: IRC channel data, defined only on an IRC channel buffer (see hdata \"irc_channel\" in API doc) - extra variables added by buflist for convenience: - ${format_buffer}: the evaluated value of option buflist.format.buffer; this can be used in option buflist.format.buffer_current to just change the background color for example - ${current_buffer}: a boolean (\"0\" or \"1\"), \"1\" if this is the current buffer; it can be used in a condition: ${if:${current_buffer}?...:...} - ${merged}: a boolean (\"0\" or \"1\"), \"1\" if the buffer is merged with at least another buffer; it can be used in a condition: ${if:${merged}?...:...} - ${format_number}: indented number with separator (evaluation of option buflist.format.number) - ${number}: indented number, for example \" 1\" if there are between 10 and 99 buffers; for merged buffers, this variable is set with number for the first buffer and spaces for the next buffers with same number - ${number2}: indented number, for example \" 1\" if there are between 10 and 99 buffers - ${number_displayed}: \"1\" if the number is displayed, otherwise \"0\" - ${indent}: indentation for name (channel, private and list buffers are indented) (evaluation of option buflist.format.indent) - ${format_nick_prefix}: colored nick prefix for a channel (evaluation of option buflist.format.nick_prefix) - ${color_nick_prefix}: color of nick prefix for a channel (set only if the option buflist.look.nick_prefix is enabled) - ${nick_prefix}: nick prefix for a channel (set only if the option buflist.look.nick_prefix is enabled) - ${format_name}: formatted name (evaluation of option buflist.format.name) - ${name}: the short name (if set), with a fallback on the name - ${color_hotlist}: the color depending on the highest hotlist level for the buffer (evaluation of option buflist.format.hotlist_xxx where xxx is the level) - ${format_hotlist}: the formatted hotlist (evaluation of option buflist.format.hotlist) - ${hotlist}: the raw hotlist - ${hotlist_priority}: \"none\", \"low\", \"message\", \"private\" or \"highlight\" - ${hotlist_priority_number}: -1 = none, 0 = low, 1 = message, 2 = private, 3 = highlight - ${format_lag}: the lag for an IRC server buffer, empty if there's no lag (evaluation of option buflist.format.lag) - ${format_tls_version}: indicator of TLS version for a server buffer, empty for channels (evaluation of option buflist.format.tls_version)\n\n/fset -bar -refresh -up|-down [<number>] -left|-right [<percent>] -go <line>|end -toggle -add [<value>] -reset -unset -set -setnew -append -mark -format -export [-help|-nohelp] <filename> -import <filename> <filter> -bar: add the help bar -refresh: refresh list of options, then whole screen (command: /window refresh) -up: move the selected line up by \"number\" lines -down: move the selected line down by \"number\" lines -left: scroll the buffer by \"percent\" of width on the left -right: scroll the buffer by \"percent\" of width on the right -go: select a line by number, first line number is 0 (\"end\" to select the last line) -toggle: toggle the boolean value -add: add \"value\" (which can be a negative number) for integers, colors and enums, set/append to value for other types (set for a negative value, append for a positive value) -reset: reset the value of option -unset: unset the option -set: add the /set command in input to edit the value of option (move the cursor at the beginning of value) -setnew: add the /set command in input to edit a new value for the option -append: add the /set command to append something in the value of option (move the cursor at the end of value) -mark: toggle mark -format: switch to the next available format -export: export the options and values displayed to a file (each line has format: \"/set name value\" or \"/unset name\") -import: import the options from a file (all lines containing commands are executed) -help: force writing of help on options in exported file (see /help fset.look.export_help_default) -nohelp: do not write help on options in exported file (see /help fset.look.export_help_default) filter: set a new filter to see only matching options (this filter can be used as input in fset buffer as well); allowed formats are: `*`: show all options (no filter) `xxx`: show only options with \"xxx\" in name `f:xxx`: show only configuration file \"xxx\" `t:xxx`: show only type \"xxx\" (bool/int/str/col/enum or boolean/integer/string/color/enum) `d`: show only changed options `d:xxx`: show only changed options with \"xxx\" in name `d=xxx`: show only changed options with \"xxx\" in value `d==xxx`: show only changed options with exact value \"xxx\" `h=xxx`: show only options with \"xxx\" in description (translated) `he=xxx`: show only options with \"xxx\" in description (in English) `=xxx`: show only options with \"xxx\" in value `==xxx`: show only options with exact value \"xxx\" `c:xxx`: show only options matching the evaluated condition \"xxx\", using following variables: file, section, option, name, parent_name, type, type_en, type_short (bool/int/str/col/enum), type_tiny (b/i/s/c/e), default_value, default_value_undef, value, quoted_value, value_undef, value_changed, parent_value, min, max, description, description2, description_en, description_en2, string_values, allowed_values The lines with options are displayed using string evaluation (see /help eval for the format), with these options: - fset.format.option1: first format for an option - fset.format.option2: second format for an option The following variables can be used in these options: - option data, with color and padded by spaces on the right: - ${file}: configuration file (for example \"weechat\" or \"irc\") - ${section}: section - ${option}: option name - ${name}: full option name (file.section.option) - ${parent_name}: parent option name - ${type}: option type (translated) - ${type_en}: option type (in English) - ${type_short}: short option type (bool/int/str/col/enum) - ${type_tiny}: tiny option type (b/i/s/c/e) - ${default_value}: option default value - ${default_value_undef}: \"1\" if default value is null, otherwise \"0\" - ${value}: option value - ${value_undef}: \"1\" if value is null, otherwise \"0\" - ${value_changed}: \"1\" if value is different from default value, otherwise \"0\" - ${value2}: option value, with inherited value if null - ${parent_value}: parent option value - ${min}: min value - ${max}: max value - ${description}: option description (translated) - ${description2}: option description (translated), \"(no description)\" (translated) if there's no description - ${description_en}: option description (in English) - ${description_en2}: option description (in English), \"(no description)\" if there's no description - ${string_values}: string values allowed for set of an enum option - ${allowed_values}: allowed values - ${marked}: \"1\" if option is marked, otherwise \"0\" - ${index}: index of option in list - option data, with color but no spaces: - same names prefixed by underscore, for example: ${_name}, ${_type}, ... - option data, raw format (no colors/spaces): - same names prefixed by two underscores, for example: ${__name}, ${__type}, ... - option data, only spaces: - same names prefixed with \"empty_\", for example: ${empty_name}, ${empty_type} - other data: - ${selected_line}: \"1\" if the line is selected, otherwise \"0\" - ${newline}: insert a new line at point, so the option is displayed on multiple lines For keys, input and mouse actions on the buffer, see key bindings in User's guide. Note: if input has one or more leading spaces, the following text is interpreted as a filter, without the spaces. For example \" q\" searches all options with \"q\" inside name while \"q\" closes the fset buffer. Examples: /fset d:irc.* /fset nicklist /fset =red /fset ==red /fset c:${file} == irc && ${type_en} == integer\n\n/buffer list add [-free] [-switch] <name> clear [<number>|<name>|-merged|-all [<id>|<number>|<name>...]] move <number>|-|+ swap <id1>|<number1>|<name1> [<id2>|<number2>|<name2>] cycle <id>|<number>|<name> [<id>|<number>|<name>...] merge <id>|<number>|<name> unmerge [<number>|-all] hide [<id>|<number>|<name>|-all [<id>|<number>|<name>...]] unhide [<id>|<number>|<name>|-all [<id>|<number>|<name>...]] switch [-previous] zoom renumber [<number1> [<number2> [<start>]]] close [<n1>[-<n2>]|<name>...] notify [<level>] listvar [<id>|<number>|<name>] setvar <name> [<value>] delvar <name> set <property> [<value>] setauto <property> [<value>] get <property> jump smart|last_displayed|prev_visited|next_visited <id>|<number>|-|+|<name> list: list buffers (without argument, this list is displayed) add: add a new buffer (it can be closed with \"/buffer close\" or input \"q\") clear: clear buffer content (number for a buffer, \"-merged\" for merged buffers, \"-all\" for all buffers, or nothing for current buffer) move: move buffer in the list (may be relative, for example -1); \"-\" = move to first buffer number, \"+\" = move to last buffer number + 1 swap: swap two buffers (swap with current buffer if only one number/name given) cycle: jump loop between a list of buffers merge: merge current buffer to another buffer (chat area will be mix of both buffers); by default ctrl-x switches between merged buffers unmerge: unmerge buffer from other buffers which have same number hide: hide the buffer unhide: unhide the buffer switch: switch to next merged buffer (or to previous buffer with \"-previous\") zoom: zoom on merged buffer renumber: renumber buffers (works only if option weechat.look.buffer_auto_renumber is off) close: close buffer (number/range or name is optional) notify: display or set notify level for current buffer: this level determines whether buffer will be added to hotlist or not: none: never highlight: for highlights only message: for messages from users + highlights all: for all messages reset: reset to default value (all) listvar: display local variables in a buffer setvar: set a local variable in the current buffer delvar: delete a local variable from the current buffer set: set a property in the current buffer setauto: like \"set\" and also define option \"weechat.buffer.<name>.<property>\" so that the property is saved in configuration and applied each time this buffer is opened get: display a property of current buffer jump: jump to another buffer: smart: next buffer with activity last_displayed: last buffer displayed (before last jump to a buffer) prev_visited: previously visited buffer next_visited: jump to next visited buffer id: jump to buffer by id number: jump to buffer by number, possible prefix: \"+\": relative jump, add number to current \"-\": relative jump, sub number to current \"*\": jump to number, using option \"weechat.look.jump_current_to_previous_buffer\" -: jump to first buffer number +: jump to last buffer number name: jump to buffer by (partial) name; if the name starts with \"(?i)\", the search is case insensitive (for example \"(?i)upper\" will find buffer \"irc.libera.#UPPERCASE\") Examples: /buffer move 5 /buffer swap 1 3 /buffer swap #weechat /buffer cycle #chan1 #chan2 #chan3 /buffer merge 1 /buffer merge #weechat /buffer close 5-7 /buffer #weechat /buffer +1 /buffer +\n\n/eval [-n|-s] [-d] <expression> [-n] [-d [-d]] -c <expression1> <operator> <expression2> -n: display result without sending it to buffer (debug mode) -s: split expression before evaluating it (many commands can be separated by semicolons) -d: display debug output after evaluation (with two -d: more verbose debug) -c: evaluate as condition: use operators and parentheses, return a boolean value (\"0\" or \"1\") expression: expression to evaluate, variables with format ${variable} are replaced (see below) operator: a logical or comparison operator (see below) An expression is considered as \"true\" if it is not NULL, not empty, and different from \"0\". The comparison is made using floating point numbers if the two expressions are valid numbers, with one of the following formats: integer (examples: 5, -7), floating point number (examples: 5.2, -7.5, 2.83e-2), hexadecimal number (examples: 0xA3, -0xA3). To force a string comparison, you can add double quotes around each expression, for example: 50 > 100 == 0 and \"50\" > \"100\" == 1 Some variables are replaced in expression, using the format ${variable}, which can be, by order of priority: - ${raw_hl:string}: the string itself without evaluation but with syntax highlighting - ${raw:string}: the string itself without evaluation - ${hl:string}: the string with syntax highlighting - ${name}: the user-defined variable - ${weechat_config_dir}: WeeChat config directory - ${weechat_data_dir}: WeeChat data directory - ${weechat_state_dir}: WeeChat state directory - ${weechat_cache_dir}: WeeChat cache directory - ${weechat_runtime_dir}: WeeChat runtime directory - ${eval:string}: the evaluated string - ${eval_cond:string}: the evaluated condition - ${esc:string} or ${\\string}: the string with escaped chars - ${chars:range}: the string with a range of chars, \"range\" is one of: \"digit\", \"xdigit\", \"lower\", \"upper\", \"alpha\", \"alnum\" or \"c1-c2\" (\"c1\" and \"c2\" are code points with c1 â¤ c2) - ${lower:string}: the string converted to lower case - ${upper:string}: the string converted to upper case - ${hide:char,string}: the string with hidden chars - ${cut:max,suffix,string}: the string with max chars (excluding the suffix) - ${cut:+max,suffix,string}: the string with max chars (including the suffix) - ${cutscr:max,suffix,string}: the string with max chars displayed on screen (excluding the suffix) - ${cutscr:+max,suffix,string}: the string with max chars displayed on screen (including the suffix) - ${rev:string}: the reversed string - ${revscr:string}: the reversed string for display (color codes are not reversed) - ${repeat:count,string}: the repeated string - ${length:string}: the length of the string (number of UTF-8 chars) - ${lengthscr:string}: the length of the string on screen (sum of the width of each UTF-8 char displayed on screen, colors codes are ignored) - ${split:N,separators,flags,string}: Nth item of the split string (N is an integer â¥ 1 or â¤ -1, if negative, counts from the last item) - ${split:random,separators,flags,string}: random item of the split string - ${split:count,separators,flags,string}: number of items of the split string - ${split_shell:N,string}: Nth item of the split shell arguments (N is an integer â¥ 1 or â¤ -1, if negative, counts from the last item) - ${split_shell:random,string}: random item of the split shell arguments - ${split_shell:count,string}: number of items of the split shell arguments - ${color:name}: the color (see \"Plugin API reference\", function \"color\") - ${modifier:name,data,string}: the modifier - ${info:name,arguments}: the info (arguments are optional) - ${base_encode:base,string}: the string encoded to base: 16, 32, 64 or 64url - ${base_decode:base,string}: the string decoded from base: 16, 32, 64 or 64url - ${date} or ${date:format}: current date/time - ${env:NAME}: the environment variable - ${if:condition?value_if_true:value_if_false}: the result of ternary operator - ${calc:expression}: the result of the expression with parentheses and operators (+, -, *, /, //, %, **) - ${random:min,max}: a random integer number between \"min\" and \"max\" (inclusive) - ${translate:string}: the translated string - ${define:name,value}: declaration of a user variable (return an empty string) - ${hdata_count:name[list]}: number of items in this hdata with list - ${hdata_count:name[ptr]}: number of items in this hdata with pointer - ${sec.data.xxx}: the value of the secured data \"xxx\" - ${file.section.option}: the value of the config option - ${name}: the local variable in buffer - the hdata name/variable (the value is automatically converted to string), by default \"window\" and \"buffer\" point to current window/buffer. Format for hdata can be one of following: - ${hdata.var1.var2...}: start with a hdata (pointer must be known), and ask variables one after one (other hdata can be followed) - ${hdata[list].var1.var2...}: start with a hdata using a list/pointer/pointer name, for example: - ${buffer[gui_buffers].full_name}: full name of first buffer in linked list of buffers - ${plugin[weechat_plugins].name}: name of first plugin in linked list of plugins - ${hdata[pointer].var1.var2...}: start with a hdata using a pointer, for example: - ${buffer[0x1234abcd].full_name}: full name of the buffer with this pointer (can be used in triggers) - ${buffer[my_pointer].full_name}: full name of the buffer with this pointer name (can be used in triggers) - ${hdata[pointer].var1.method()}: when var1 is a hashtable, methods can be called: \"keys()\", \"values()\", \"keys_sorted()\", \"keys_values()\" and \"keys_values_sorted()\" For name of hdata and variables, please look at \"Plugin API reference\", function \"weechat_hdata_get\". Logical operators (by order of priority): && boolean \"and\" || boolean \"or\" Comparison operators (by order of priority): =~ is matching POSIX extended regex !~ is NOT matching POSIX extended regex ==* is matching mask, case sensitive (wildcard \"*\" is allowed) !!* is NOT matching mask, case sensitive (wildcard \"*\" is allowed) =* is matching mask, case insensitive (wildcard \"*\" is allowed) !* is NOT matching mask, case insensitive (wildcard \"*\" is allowed) ==- is included, case sensitive !!- is NOT included, case sensitive =- is included, case insensitive !- is NOT included, case insensitive == equal != not equal <= less or equal < less >= greater or equal > greater Examples (simple strings): /eval -n ${raw:${info:version}} ==> ${info:version} /eval -n ${eval_cond:${window.win_width}>100} ==> 1 /eval -n ${info:version} ==> 4.4.1 /eval -n ${env:HOME} ==> /home/user /eval -n ${weechat.look.scroll_amount} ==> 3 /eval -n ${sec.data.password} ==> secret /eval -n ${window} ==> 0x2549aa0 /eval -n ${window.buffer} ==> 0x2549320 /eval -n ${window.buffer.full_name} ==> core.weechat /eval -n ${window.buffer.number} ==> 1 /eval -n ${buffer.local_variables.keys_values()} ==> plugin:core,name:weechat /eval -n ${buffer.local_variables.plugin} ==> core /eval -n ${hdata_count:buffer[gui_buffers]} ==> 15 /eval -n ${\\t} ==> <tab> /eval -n ${chars:digit} ==> 0123456789 /eval -n ${chars:J-T} ==> JKLMNOPQRST /eval -n ${lower:TEST} ==> test /eval -n ${upper:test} ==> TEST /eval -n ${hide:-,${relay.network.password}} ==> -------- /eval -n ${cut:3,+,test} ==> tes+ /eval -n ${cut:+3,+,test} ==> te+ /eval -n ${date:%H:%M:%S} ==> 07:46:40 /eval -n ${if:${info:term_width}>80?big:small} ==> big /eval -n ${rev:Hello} ==> olleH /eval -n ${repeat:5,-} ==> ----- /eval -n ${length:test} ==> 4 /eval -n ${split:1,,,abc,def,ghi} ==> abc /eval -n ${split:-1,,,abc,def,ghi} ==> ghi /eval -n ${split:count,,,abc,def,ghi} ==> 3 /eval -n ${split:random,,,abc,def,ghi} ==> def /eval -n ${split_shell:1,\"arg 1\" arg2} ==> arg 1 /eval -n ${split_shell:-1,\"arg 1\" arg2} ==> arg2 /eval -n ${split_shell:count,\"arg 1\" arg2} ==> 2 /eval -n ${split_shell:random,\"arg 1\" arg2} ==> arg2 /eval -n ${calc:(5+2)*3} ==> 21 /eval -n ${random:0,10} ==> 3 /eval -n ${base_encode:64,test} ==> dGVzdA== /eval -n ${base_decode:64,dGVzdA==} ==> test /eval -n ${define:len,${calc:5+3}}${len}x${len} ==> 8x8 Examples (conditions): /eval -n -c ${window.buffer.number} > 2 ==> 0 /eval -n -c ${window.win_width} > 100 ==> 1 /eval -n -c (8 > 12) || (5 > 2) ==> 1 /eval -n -c (8 > 12) && (5 > 2) ==> 0 /eval -n -c abcd =~ ^ABC ==> 1 /eval -n -c abcd =~ (?-i)^ABC ==> 0 /eval -n -c abcd =~ (?-i)^abc ==> 1 /eval -n -c abcd !~ abc ==> 0 /eval -n -c abcd =* a*d ==> 1 /eval -n -c abcd =- bc ==> 1\n\n/filter list enable|disable|toggle [<name>|<mask>|@ [<name>|<mask>|@...]] add|addreplace <name> <buffer>[,<buffer>...] <tags> <regex> rename <name> <new_name> recreate <name> del <name>|<mask> [<name>|<mask>...] list: list all filters enable: enable filters (filters are enabled by default) disable: disable filters toggle: toggle filters mask: name where wildcard \"*\" is allowed (\"@\" = enable/disable all filters in current buffer) add: add a filter addreplace: add or replace an existing filter name: filter name rename: rename a filter recreate: set input with the command used to edit the filter del: delete filters buffer: comma separated list of buffers where filter is active: - this is full name including plugin (example: \"irc.libera.#weechat\" or \"irc.server.libera\") - \"*\" means all buffers - a name starting with \"!\" is excluded - wildcard \"*\" is allowed tags: comma separated list of tags (for example \"irc_join,irc_part,irc_quit\"): - logical \"and\": \"+\" between tags (for example: \"nick_toto+irc_action\") - wildcard \"*\" is allowed - if tag starts with \"!\", then it is excluded and must NOT be in message regex: POSIX extended regular expression to search in line: - use \"\\t\" to separate prefix from message, special chars like \"|\" must be escaped: \"\\|\" - if regex starts with \"!\", then matching result is reversed (use \"\\!\" to start with \"!\") - two regular expressions are created: one for prefix and one for message - regex are case insensitive, they can start by \"(?-i)\" to become case sensitive The default key alt+\"=\" toggles filtering on/off globally and alt+\"-\" toggles filtering on/off in the current buffer. Tags most commonly used: no_filter, no_highlight, no_log, log0..log9 (log level), notify_none, notify_message, notify_private, notify_highlight, self_msg, nick_xxx (xxx is nick in message), prefix_nick_ccc (ccc is color of nick), host_xxx (xxx is username + host in message), irc_xxx (xxx is command name or number, see /server raw or /debug tags), irc_numeric, irc_error, irc_action, irc_ctcp, irc_ctcp_reply, irc_smart_filter, away_info. To see tags for lines in buffers: /debug tags Examples: use IRC smart filter on all buffers: /filter add irc_smart * irc_smart_filter * use IRC smart filter on all buffers except those with \"#weechat\" in name: /filter add irc_smart *,!*#weechat* irc_smart_filter * filter all IRC join/part/quit messages: /filter add joinquit * irc_join,irc_part,irc_quit * filter nicks displayed when joining channels or with /names: /filter add nicks * irc_366 * filter nick \"toto\" on IRC channel #weechat: /filter add toto irc.libera.#weechat nick_toto * filter IRC join/action messages from nick \"toto\": /filter add toto * nick_toto+irc_join,nick_toto+irc_action * filter lines containing \"weechat sucks\" on IRC channel #weechat: /filter add sucks irc.libera.#weechat * weechat sucks filter lines that are strictly equal to \"WeeChat sucks\" on all buffers: /filter add sucks2 * * (?-i)^WeeChat sucks$\n\n/input <action> [<arguments>] action: the action, one of: return: simulate key \"enter\" split_return: split input on newlines then simulate key \"enter\" for each line complete_next: complete word with next completion complete_previous: complete word with previous completion search_text_here: search text in buffer at current position search_text: search text in buffer search_history: search text in command line history search_switch_case: switch exact case for search search_switch_regex: switch search type: string/regular expression search_switch_where: switch search in messages/prefixes search_previous: search previous line search_next: search next line search_stop_here: stop search at current position search_stop: stop search delete_previous_char: delete previous char delete_next_char: delete next char delete_previous_word: delete previous word delete_previous_word_whitespace: delete previous word (until whitespace) delete_next_word: delete next word delete_beginning_of_line: delete from beginning of line until cursor delete_beginning_of_input: delete from beginning of input until cursor delete_end_of_line: delete from cursor until end of line delete_end_of_input: delete from cursor until end of input delete_line: delete current line delete_input: delete entire input clipboard_paste: paste from the internal clipboard transpose_chars: transpose two chars undo: undo last command line action redo: redo last command line action move_beginning_of_line: move cursor to beginning of line move_beginning_of_input: move cursor to beginning of input move_end_of_line: move cursor to end of line move_end_of_input: move cursor to end of input move_previous_char: move cursor to previous char move_next_char: move cursor to next char move_previous_word: move cursor to previous word move_next_word: move cursor to next word move_previous_line: move cursor to previous line move_next_line: move cursor to next line history_previous: recall previous command in current buffer history history_next: recall next command in current buffer history history_global_previous: recall previous command in global history history_global_next: recall next command in global history history_use_get_next: send the current history entry (found with search or recalled with \"up\"key) and insert the next history entry in the command line without sending it grab_key: grab a key (optional argument: delay for end of grab, default is 500 milliseconds) grab_key_command: grab a key with its associated command (optional argument: delay for end of grab, default is 500 milliseconds) grab_mouse: grab mouse event code grab_mouse_area: grab mouse event code with area insert: insert text in command line (escaped chars are allowed, see /help print) send: send text to the buffer arguments: optional arguments for the action This command is used by key bindings or plugins.\n\n/key [list|listdefault|listdiff] [<context>] bind <key> [<command> [<args>]] bindctxt <context> <key> [<command> [<args>]] unbind <key> unbindctxt <context> <key> reset <key> resetctxt <context> <key> resetall -yes [<context>] missing [<context>] legacy <key> [<key>...] list: list all current keys listdefault: list default keys listdiff: list differences between current and default keys (keys added, redefined or deleted) context: name of context (\"default\" or \"search\") bind: bind a command to a key or display command bound to key (for context \"default\") bindctxt: bind a command to a key or display command bound to key, for given context command: command (many commands can be separated by semicolons); quotes can be used to preserve spaces at the beginning/end of command unbind: remove a key binding (for context \"default\") unbindctxt: remove a key binding for given context reset: reset a key to default binding (for context \"default\") resetctxt: reset a key to default binding, for given context resetall: restore bindings to the default values and delete ALL personal bindings (use carefully!) missing: add missing keys (using default bindings), useful after installing new WeeChat version legacy: display new name for legacy keys When binding a command to a key, it is recommended to use key alt+k (or Esc then k), and then press the key to bind: this will insert key name in command line. For some keys you might need to use /debug key, this displays the raw key code that can be used (for example the key ctrl+backspace could be \"ctrl-h\" or \"ctrl-?\", depending on your terminal and other settings). Modifiers allowed (in this order when multiple are used): \"meta-\": alt key \"ctrl-\": control key \"shift-\": shift key, can only be used with key names below Key names allowed: f0 to f20, home, insert, delete, end, backspace, pgup, pgdn, up, down, right, left, tab, return, comma, space. Combo of keys must be separated by a comma. For context \"mouse\" (possible in context \"cursor\" too), key has format: \"@area:key\" or \"@area1>area2:key\" where area can be: *: any area on screen chat: chat area (any buffer) chat(xxx): chat area for buffer with name \"xxx\" (full name including plugin) bar(*): any bar bar(xxx): bar \"xxx\" item(*): any bar item item(xxx): bar item \"xxx\" Wildcard \"*\" is allowed in key to match many mouse events. A special value for command with format \"hsignal:name\" can be used for context mouse, this will send the hsignal \"name\" with the focus hashtable as argument. Another special value \"-\" can be used to disable key (it will be ignored when looking for keys). Examples: /key bind meta-r /buffer #weechat /key reset meta-r /key bind meta-v,f1 /help /key bindctxt search f12 /input search_stop /key bindctxt mouse @item(buffer_nicklist):button3 /msg nickserv info ${nick}\n\n/upgrade [-yes] [<path_to_binary>|-save|-quit] -o|-ol -yes: required if option \"weechat.look.confirm_upgrade\" is enabled path_to_binary: path to WeeChat binary (default is current binary) -dummy: do nothing (option used to prevent accidental completion with \"-quit\") -save: only save the session, do not quit nor reload WeeChat; the configuration files are not saved (if needed you can use /save before this command) -quit: close *ALL* connections, save session and quit WeeChat, which makes possible a delayed restoration (see below) -o: send number of upgrades and date of first/last start to current buffer as input (English string) -ol: send number of upgrades and date of first/last start to current buffer as input (translated string) This command upgrades and reloads a running WeeChat session. The new WeeChat binary must have been compiled or installed with a package manager before running this command. Note: TLS connections are lost during upgrade (except with -save), because the reload of TLS sessions is currently not possible with GnuTLS. There is automatic reconnection after upgrade. Important: use of option \"-save\" can be dangerous, it is recommended to use only /upgrade (or with \"-quit\") for a standard upgrade and a restart; the option \"-save\" can be used to save the session regularly and restore it in case of after abnormal exit (power outage, crash, etc.). Upgrade process has 4 steps: 1. save session into files for core and plugins (buffers, history, ..) 2. unload all plugins (configuration files (*.conf) are written on disk) 3. save WeeChat configuration (weechat.conf) 4. execute new WeeChat binary and reload session. With option \"-quit\", the process is: 1. close *ALL* connections (irc, xfer, relay, ...) 2. save session into files (*.upgrade) 3. unload all plugins 4. save WeeChat configuration 5. quit WeeChat With option \"-save\", the process is: 1. save session into files (*.upgrade) with a disconnected state for IRC servers and Relay clients (but no disconnection is made) With -quit or -save, you can restore the session later with this command: weechat --upgrade IMPORTANT: you must restore the session with exactly same configuration (files *.conf) and if possible the same WeeChat version (or a more recent one). It is possible to restore WeeChat session on another machine if you copy the content of WeeChat home directories (see /debug dirs)."
    }
}