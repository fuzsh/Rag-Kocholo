{
    "id": "dbpedia_6855_3",
    "rank": 84,
    "data": {
        "url": "https://peterdev.pl/execute-a-shell-command-in-php/",
        "read_more_link": "",
        "language": "en",
        "title": "Executing shell commands from a PHP script",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://peterdev.pl/assets/unix-process-diagram.svg",
            "https://peterdev.pl/assets/me.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Piotr Horzycki - Java",
            "PHP developer's blog"
        ],
        "publish_date": "2021-04-02T19:00:00+00:00",
        "summary": "",
        "meta_description": "All the details of calling an external process from PHP.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "Piotr Horzycki - Java and PHP developer’s blog",
        "canonical_link": "https://peterdev.pl/execute-a-shell-command-in-php/",
        "text": "If you need to call an external program from your PHP script, for example to create a PDF file or convert images, there are several ways to do that.\n\nI strongly recommend using the Symfony Process Component. It wraps around native PHP functions like proc_open() and it provides extra level of security. It is also very convenient because of an object-oriented interface. Take a look at this example:\n\nMost guides around the web will simply tell you about functions like exec(), but that’s not how you should do it. You can either end up with security issues in your application, or just lack features.\n\nThis has been a short introduction. If you have more time to read, let me show you all the details of calling an external process from a PHP script.\n\nInput, output and exit codes\n\nA program running under an operating system is a process. This is the word we are going to use. We can run processes for example by entering commands inside a terminal.\n\nA command usually consists of the program file name followed optionally by a set of arguments. Every program expects different arguments, and if we don’t know them, we simply ask the program for help:\n\nA process has several connectors to the surrounding environment. It’s using them to transfer data over streams.\n\nA stream is just a sequence of bytes. There are three default streams in a terminal:\n\nstandard input (STDIN), connected to the keyboard\n\nstandard output (STDOUT), connected to the screen\n\nstandard error output (STDERR), either displayed on the screen or written to a log file\n\nUsing streams gives us great flexibility. Instead of operating on a real console or real files in PHP, we can send a string variable to a process and then read the output into another variable. We don’t need to remember to delete a file. This will help a lot for example with PDF conversions.\n\nWhen calling processes that operate on files by default, sometimes a hyphen (-) is used in place of a file name argument to indicate that the process should read from STDIN instead, or write to STDOUT instead of a real file.\n\nAdditional input to a process consists of environment variables. These can be some user-specific data stored in their home directories, or variables provided at the process startup. They make the arguments list shorter because we don’t have to specify common settings on every command call. Perhaps the most known environment variable is PATH which stores a list of directories where commands are searched.\n\nA process can also return a special code - exit code - which indicates success or failure. The convention is to use 0 in case of success and any other code from 1 to 255 to show a different situation.\n\nYou can connect several processes in a chain using the pipe operator. This means that the output of the first process is tied to the input of the second process, and so on. Such mechanism is commonly used in terminals, for example to paginate long output:\n\nIn the example above, the output of the ls command was sent to the less command. If the ls failed, the chain would break and the second command would not be called.\n\nBy default, we have to wait until each process terminates. This means our PHP script will also be paused when executing an external command. If you add an ampersand (&) at the end of the command, the command will run independently. It won’t block your script and will last even after the script stops. You might need this especially when launching lengthy processes like generating a 100-page report.\n\nIt’s good to have some control over such a background action. Fortunately, every process receives an identifier after being opened. The process identifier (PID) can be used later for example to check if the process is still running or to shut it down.\n\nNow that we have the general rules covered, we can switch to the PHP world.\n\nBasic execution from a PHP script\n\nThere are four (!) PHP functions which purpose is to run an external command and return output:\n\nexec() accepts command as input and returns the last line from the result of the command. Optionally, it can fill a provided array with every line of the output and also assign the return code to the variable. On failure, the function returns false.\n\npassthru() executes a command and passes the raw output directly to the browser. The PHP documentation recommends it in case if binary output has to be sent without interference.\n\nshell_exec() executes a command and returns the complete output as a string. It does not provide the exit code. The function return value is confusing because it can be null both if an error occured or if the command produced no output.\n\nsystem() acts like passthru(), but it also returns the last line of the output. This function works well only with text output.\n\nTo confuse you even more, PHP has a backtick operator which works just like shell_exec():\n\nI don’t use any of these functions because none of them provides full control over streams.\n\nEscaping arguments\n\nSometimes the full command is made from several parts, for example a file name coming from a user. We have to filter such input data properly to make sure it does not contain any unescaped special characters like spaces, quotes, backticks, slashes, and so on. They could either break the command or cause security issues.\n\nAn attacker could inject any other command and perhaps access protected data:\n\nEvery command argument should be filtered by the escapeshellarg() function. This will ensure that your input data will be properly treated as a single safe argument:\n\nOf course the filename parameter should be further filtered to make sure an attacker cannot access any other directories outside the current one:\n\nOpening and controlling a process\n\nThe proc_open() function provides the most possibilities to control a process execution. Its usage requires a lot more code than the one-liners mentioned earlier, but it pays off.\n\nHere’s an example of calling a wkhtmltopdf program which converts an input HTML document to a PDF. We’ll supply the HTML contents to STDIN and read the output from STDOUT:\n\nHere you can see how we invoked the wkhtmltopdf process and told it to operate on standard input/output streams instead of real files (notice the two hyphens). Our script was halted until the external program returned full output and terminated. If everything went fine, $exitCode should equal 0.\n\nThere are three optional arguments to proc_open(), in consecutive order:\n\n$cwd - current working directory; if not specified, the process will operate in the same directory as the current PHP process.\n\n$env - an array of environment variables. If not provided, the child process will inherit all the environment of the PHP process.\n\n$other_options - at the moment this can only contain Windows-specific console options. Nothing to see here.\n\nIf you only need a unidirectional pipe, you can use the popen() function (isn’t PHP function naming confusing?). A one-way communication is easier to handle:\n\nThe most convenient solution: The Process Component\n\nAll the code demonstrated above looks like low-level C programming. It’s not really comfortable in the modern age of object-oriented programming and abstractions. Today you shouldn’t worry about resources, pointers and streams.\n\nTo include the Process component in your project, just use Composer in the command line:\n\nTo remind you, the basic usage consists of just creating an instance of the Process class, providing input arguments and getting output:\n\nNotice that we pass input arguments as an array. We no longer create a long command invocation by hand; the Process component assembles the call, taking care of proper argument escaping. Instead of exit codes, we use exceptions just like it should be done in a modern object-oriented environment.\n\nAn alternative to $process->mustRun() is just using $process->run() and then checking the result of $process->isSuccessful().\n\nThe process will inherit all environment variables from the PHP process running the script. You can provide additional variables (or override them) at runtime:\n\nRefer to the documentation of the specific process you are calling to know all the input rules.\n\nAsynchronous and background processes\n\nAs we know, running a child process blocks the parent process by default. This is the easiest and safest behavior.\n\nSome processes take considerable amount of time and it would be good to let the user know what is happening. You can provide an anonymous function which is going to receive every piece of output coming from a child process:\n\nIf our main script logic does not strictly depend on the complete child process execution, we can run things in parallel. While a child process does its job, we can do other things in the meantime and occassionally check on that process:\n\nTimeouts\n\nTo prevent a process from hanging forever, two types of timeout mechanisms were introduced:\n\na general timeout, measured from the process start,\n\nan idle timeout, measured from the last output received from a process.\n\nBy default, a process has a general timeout of 60 seconds. You can change it with the setTimeout() method of the Process class. The other clock can be adjusted with setIdleTimeout().\n\nWhen running a lengthy command asynchronously, you must use checkTimeout() to see if the timeout is reached.\n\nRemember there are plenty of other timeouts in the surrounding environment. PHP has also its own maximum script execution times - different for a web server and CLI (Command-line Interface).\n\nIf your child process stops unexpectedly, this might mean that you’re exceeding some timeout, either set by yourself, the PHP environment, an operating system, a database or anything else.\n\nReporting progress of time-consuming tasks\n\nWhen a user requests a report, a package or any other piece of data which preparation takes more time, you should not make people stare at the loading icon forever. They will either think that their internet connection is broken, or the server went down. They might panically hit the “Refresh” button, and thus make even more trouble by causing multiple requests to start. They might even hang your server.\n\nThe basic solution is to add a message which says “This might take a few minutes.” However, a user might hit a browser timeout while watching that loading icon.\n\nIt’s better to send the results in an e-mail, or make some push notification which says “ok, you can download your file here.” The user knows that they don’t have to wait until the process is done, they can just leave the computer for a while and come back later.\n\nIf the process produces a series of files, let’s say a hundred PDFs, it is fairly easy to track progress. The worker process simply has to report the number of finished items, for example by writing it to a file. Your frontend will simply read that file and render a nice progress bar. You can also track time of every item preparation to make fancy estimations about the remaining time.\n\nWhy not go even further and have anonymous statistics of all user requests? You can then tell users: “this usually takes 3 to 5 minutes.”\n\nQueueing tasks\n\nYour server has limited resources. What happens if a thousand users suddenly request a freshly generated PDF document?\n\nIn bars, restaurants and shops, people wait in line to be served. There might be for example three people on the counter, and every one of them can serve one customer at a time.\n\nSame rules apply to computing. A processor has a finite number of cores. Running more processes than the number of cores requires your processor to switch between tasks. Your PHP installation when using FPM also has some pool settings which defines how many requests can be handled simultaneously.\n\nWhen you know how much tasks your system can take at once, you should enforce limits and use some queue system. It can be RabbitMQ or Kafka, for example. These are battle-tested tools which are going to control your queues. I’m not covering them in this book.\n\nHaving a queue means that your user will have even more waiting time. You should take this into account when informing users about estimated delivery time. However, this is a basic way to ensure that your customers will be served at all, eventually. If you let everyone in at the same time, chances are no one will be served successfully and you’ll get bad reviews.\n\nWrapping up\n\nThere’s a lot of low-level PHP functions to call external commands, but today the best option is to use a wrapper library like Symfony Process.\n\nWhen running other processes from your PHP scripts, you need to know how a process works, how to read and write data, and how much tasks your server can handle at once. Try queueing time-consuming tasks."
    }
}