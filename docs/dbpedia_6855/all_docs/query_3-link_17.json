{
    "id": "dbpedia_6855_3",
    "rank": 17,
    "data": {
        "url": "https://stackoverflow.com/questions/1074212/how-can-i-see-the-raw-sql-queries-django-is-running",
        "read_more_link": "",
        "language": "en",
        "title": "How can I see the raw SQL queries Django is running?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/1d502f7932af0a41d8ff6ab5d9cf3406?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/65e1ee6b43149bbfb6d80ce8edb6e425?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/443f71885827eac7afa2a87bb70be610?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/b608596ef16a11a0836745c118f1ff7d?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/VR75R.png",
            "https://www.gravatar.com/avatar/5347c683b6963f418d1b16c65917bf3f?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/l779G.jpg?s=64",
            "https://i.sstatic.net/2YEyO.gif?s=64",
            "https://www.gravatar.com/avatar/5d7cf8623583105a6cb6e132a5ee9fc2?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/IBHo9.jpg?s=64",
            "https://www.gravatar.com/avatar/372fabe5d3962d54b0c9474e35a05359?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/IBHo9.jpg?s=64",
            "https://www.gravatar.com/avatar/e4edbbea49c03ba770f48c3363e3ae65?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/0af0c4a8d193a90fd49e7abbc01af1fb?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/5953314abb5194a939a7a79309a397c0?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/lKobA.jpg?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://graph.facebook.com/100001073502361/picture?type=large",
            "https://i.sstatic.net/0ihpR.jpg?s=64",
            "https://www.gravatar.com/avatar/da170931f86bbd079bce7b23aaef874d?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/6MU8m.png",
            "https://www.gravatar.com/avatar/c1b6a11feeac84ae77a137448062e0d0?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/7e6c17b782eae8e9012ce543df490034?s=64&d=identicon&r=PG",
            "https://lh3.googleusercontent.com/-rTfGuextoM8/AAAAAAAAAAI/AAAAAAAAYXg/EUrv08pOV98/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/f842ea3d5a89e95a9932a580c5620e39?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/6010464aba06865d7a982c3a1456d377?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/HBrDi.jpg?s=64",
            "https://i.sstatic.net/FE4xL.png?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/YtbQ6.jpg?s=64",
            "https://www.gravatar.com/avatar/4b25b5559eb1cea24326ae7cc3c7a0b6?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/An3gf.jpg?s=64",
            "https://i.sstatic.net/X5dfT.jpg?s=64",
            "https://lh3.googleusercontent.com/-otga3zCFG9Y/AAAAAAAAAAI/AAAAAAAAANc/sOnDH92HIZ8/photo.jpg?sz=64",
            "https://graph.facebook.com/1468698976588226/picture?type=large",
            "https://www.gravatar.com/avatar/e46bdea94469294d74ac30a970289acf?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/Fc0xo.jpg?s=64",
            "https://stackoverflow.com/posts/1074212/ivc/a81a?prg=27b61b71-a813-4df2-9c50-46d2764f6981"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-07-02T13:03:07",
        "summary": "",
        "meta_description": "Is there a way to show the SQL that Django is running while performing a query?",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/1074212/how-can-i-see-the-raw-sql-queries-django-is-running",
        "text": "See the docs FAQ: \"How can I see the raw SQL queries Django is running?\"\n\ndjango.db.connection.queries contains a list of the SQL queries:\n\nfrom django.db import connection print(connection.queries)\n\nQuerysets also have a query attribute containing the query to be executed:\n\nprint(MyModel.objects.filter(name=\"my name\").query)\n\nNote that the output of the query is not valid SQL, because:\n\n\"Django never actually interpolates the parameters: it sends the query and the parameters separately to the database adapter, which performs the appropriate operations.\"\n\nFrom Django bug report #17741.\n\nBecause of that, you should not send query output directly to a database.\n\nIf you need to reset the queries to, for example, see how many queries are running in a given period, you can use reset_queries from django.db:\n\nfrom django.db import reset_queries from django.db import connection reset_queries() # Run your query here print(connection.queries) >>> []\n\nI find by far the most useful, simple, and reliable method is to ask your database. For example on Linux for Postgres you might do:\n\nsudo su postgres tail -f /var/log/postgresql/postgresql-8.4-main.log\n\nEach database will have slightly different procedure. In the database logs you'll see not only the raw SQL, but any connection setup or transaction overhead django is placing on the system.\n\nAnother option, see logging options in settings.py described by this post\n\nhttp://dabapps.com/blog/logging-sql-queries-django-13/\n\ndebug_toolbar slows down each page load on your dev server, logging does not so it's faster. Outputs can be dumped to console or file, so the UI is not as nice. But for views with lots of SQLs, it can take a long time to debug and optimize the SQLs through debug_toolbar since each page load is so slow.\n\nThough you can do it with the code supplied, I find that using the debug toolbar app is a great tool to show queries. You can download it from github here.\n\nThis gives you the option to show all the queries ran on a given page along with the time to query took. It also sums up the number of queries on a page along with total time for a quick review. This is a great tool, when you want to look at what the Django ORM does behind the scenes. It also have a lot of other nice features, that you can use if you like.\n\nI developed an extension for this purpose, so you can easily put a decorator on your view function and see how many queries are executed.\n\nTo install:\n\npip install django-print-sql\n\nTo use as a context manager:\n\nfrom django_print_sql import print_sql # Set `count_only` to `True` will print the number of executed SQL statements only with print_sql(count_only=False): # Write the code you want to analyze in here, # e.g., some complex foreign key lookup, # or analyzing a DRF serializer's performance for user in User.objects.all()[:10]: user.groups.first()\n\nTo use as a decorator:\n\nfrom django_print_sql import print_sql_decorator @print_sql_decorator(count_only=False) # This works on class-based views as well def get(request): # Your view code here\n\nGitHub: django-print-sql\n\nIf you make sure your settings.py file has:\n\ndjango.core.context_processors.debug listed in CONTEXT_PROCESSORS\n\nDEBUG=True\n\nyour IP in the INTERNAL_IPS tuple\n\nThen you should have access to the sql_queries variable. I append a footer to each page that looks like this:\n\n{%if sql_queries %} <div class=\"footNav\"> <h2>Queries</h2> <p> {{ sql_queries|length }} Quer{{ sql_queries|pluralize:\"y,ies\" }}, {{sql_time_sum}} Time {% ifnotequal sql_queries|length 0 %} (<span style=\"cursor: pointer;\" onclick=\"var s=document.getElementById('debugQueryTable').style;s.disp\\ lay=s.display=='none'?'':'none';this.innerHTML=this.innerHTML=='Show'?'Hide':'Show';\">Show</span>) {% endifnotequal %} </p> <table id=\"debugQueryTable\" style=\"display: none;\"> <col width=\"1\"></col> <col></col> <col width=\"1\"></col> <thead> <tr> <th scope=\"col\">#</th> <th scope=\"col\">SQL</th> <th scope=\"col\">Time</th> </tr> </thead> <tbody> {% for query in sql_queries %} <tr class=\"{% cycle odd,even %}\"> <td>{{ forloop.counter }}</td> <td>{{ query.sql|escape }}</td> <td>{{ query.time }}</td> </tr> {% endfor %} </tbody> </table> </div> {% endif %}\n\nI got the variable sql_time_sum by adding the line\n\ncontext_extras['sql_time_sum'] = sum([float(q['time']) for q in connection.queries])\n\nto the debug function in django_src/django/core/context_processors.py.\n\nDjango SQL Sniffer is another alternative for viewing (and seeing the stats of) raw executed queries coming out of any process utilising Django ORM. I've built it to satisfy a particular use-case that I had, which I haven't seen covered anywhere, namely:\n\nno changes to the source code that the target process is executing (no need to register a new app in django settings, import decorators all over the place etc.)\n\nno changes to logging configuration (e.g. because I'm interested in one particular process, and not the entire process fleet that the configuration applies to)\n\nno restarting of target process needed (e.g. because it's a vital component, and restarts may incur some downtime)\n\nTherefore, Django SQL Sniffer can be used ad-hoc, and attached to an already running process. The tool then \"sniffs\" the executed queries and prints them to console as they are executed. When the tool is stopped a statistical summary is displayed with outlier queries based on some possible metric (count, max duration and total combined duration).\n\nHere's a screenshot of an example where I attached to a Python shell\n\nYou can check out the live demo and more details on the github page.\n\nI put this function in a util file in one of the apps in my project:\n\nimport logging import re from django.db import connection logger = logging.getLogger(__name__) def sql_logger(): logger.debug('TOTAL QUERIES: ' + str(len(connection.queries))) logger.debug('TOTAL TIME: ' + str(sum([float(q['time']) for q in connection.queries]))) logger.debug('INDIVIDUAL QUERIES:') for i, query in enumerate(connection.queries): sql = re.split(r'(SELECT|FROM|WHERE|GROUP BY|ORDER BY|INNER JOIN|LIMIT)', query['sql']) if not sql[0]: sql = sql[1:] sql = [(' ' if i % 2 else '') + x for i, x in enumerate(sql)] logger.debug('\\n### {} ({} seconds)\\n\\n{};\\n'.format(i, query['time'], '\\n'.join(sql)))\n\nThen, when needed, I just import it and call it from whatever context (usually a view) is necessary, e.g.:\n\n# ... other imports from .utils import sql_logger class IngredientListApiView(generics.ListAPIView): # ... class variables and such # Main function that gets called when view is accessed def list(self, request, *args, **kwargs): response = super(IngredientListApiView, self).list(request, *args, **kwargs) # Call our function sql_logger() return response\n\nIt's nice to do this outside the template because then if you have API views (usually Django Rest Framework), it's applicable there too.\n\nI believe this ought to work if you are using PostgreSQL:\n\nfrom django.db import connections from app_name import models from django.utils import timezone # Generate a queryset, use your favorite filter, QS objects, and whatnot. qs=models.ThisDataModel.objects.filter(user='bob',date__lte=timezone.now()) # Get a cursor tied to the default database cursor=connections['default'].cursor() # Get the query SQL and parameters to be passed into psycopg2, then pass # those into mogrify to get the query that would have been sent to the backend # and print it out. Note F-strings require python 3.6 or later. print(f'{cursor.mogrify(*qs.query.sql_with_params())}')\n\nThere's another way that's very useful if you need to reuse the query for some custom SQL. I've used this in an analytics app that goes far beyond what Django's ORM can do comfortably, so I'm including ORM-generated SQL as subqueries.\n\nfrom django.db import connection from myapp.models import SomeModel queryset = SomeModel.objects.filter(foo='bar') sql_query, params = queryset.query.as_sql(None, connection)\n\nThis will give you the SQL with placeholders, as well as a tuple with query params to use. You can pass this along to the DB directly:\n\nwith connection.connection.cursor(cursor_factory=DictCursor) as cursor: cursor.execute(sql_query, params) data = cursor.fetchall()\n\nI've made a small snippet you can use:\n\nfrom django.conf import settings from django.db import connection def sql_echo(method, *args, **kwargs): settings.DEBUG = True result = method(*args, **kwargs) for query in connection.queries: print(query) return result # HOW TO USE EXAMPLE: # # result = sql_echo(my_method, 'whatever', show=True)\n\nIt takes as parameters a function (contains SQL queries) to inspect and args, kwargs needed to call that function. As the result, it returns what function returns and prints SQL queries in a console.\n\nYou can use connection.queries to get the raw SQL queries running in Django as shown below:\n\n# \"store/views.py\" from django.db import transaction from .models import Person from django.db import connection from django.http import HttpResponse @transaction.atomic def test(request): Person.objects.create(name=\"John\") # INSERT qs = Person.objects.select_for_update().get(name=\"John\") # SELECT FOR UPDATE qs.name = \"Tom\" qs.save() # UPDATE qs.delete() # DELETE for query in connection.queries: # Here print(query) return HttpResponse(\"Test\")\n\nThen, the raw queries are printed on console as shown below:\n\n{'sql': 'INSERT INTO \"store_person\" (\"name\") VALUES (\\'John\\') RETURNING \"store_person\".\"id\"', 'time': '0.000'} {'sql': 'SELECT \"store_person\".\"id\", \"store_person\".\"name\" FROM \"store_person\" WHERE \"store_person\".\"name\" = \\'John\\' LIMIT 21 FOR UPDATE', 'time': '0.000'} {'sql': 'UPDATE \"store_person\" SET \"name\" = \\'Tom\\' WHERE \"store_person\".\"id\" = 179', 'time': '0.000'} {'sql': 'DELETE FROM \"store_person\" WHERE \"store_person\".\"id\" IN (179)', 'time': '0.000'} [24/Dec/2022 06:29:32] \"GET /store/test/ HTTP/1.1\" 200 9\n\nThen, put reset_queries() after Person.objects.select_for_update() if you want to get only UPDATE and DELETE queries without INSERT and SELECT FOR UPDATE queries as shown below:\n\n# \"store/views.py\" from django.db import transaction from .models import Person from django.db import reset_queries from django.db import connection from django.http import HttpResponse @transaction.atomic def test(request): Person.objects.create(name=\"John\") # INSERT qs = Person.objects.select_for_update().get(name=\"John\") # SELECT FOR UPDATE reset_queries() # Here qs.name = \"Tom\" qs.save() # UPDATE qs.delete() # DELETE for query in connection.queries: # Here print(query) return HttpResponse(\"Test\")\n\nThen, only UPDATE and DELETE queries are printed without INSERT and SELECT FOR UPDATE queries as shown below:\n\n{'sql': 'UPDATE \"store_person\" SET \"name\" = \\'Tom\\' WHERE \"store_person\".\"id\" = 190', 'time': '0.000'} {'sql': 'DELETE FROM \"store_person\" WHERE \"store_person\".\"id\" IN (190)', 'time': '0.000'} [24/Dec/2022 07:00:01] \"GET /store/test/ HTTP/1.1\" 200 9\n\nSeveral great answers here already.\n\nOne more way.\n\nIn test, do something like this:\n\nwith self.assertNumQueries(3): response = self.client.post(reverse('payments:pay_list')) # or whatever\n\nIf the number of queries is wrong, the test fails and prints all the raw SQL queries in the console.\n\nAlso, such tests help to control that the number of SQL queries does not grow as the code changes and the database load does not get excessive."
    }
}