{
    "id": "dbpedia_5258_3",
    "rank": 64,
    "data": {
        "url": "https://stackoverflow.com/questions/14313510/how-to-calculate-rolling-moving-average-using-python-numpy-scipy",
        "read_more_link": "",
        "language": "en",
        "title": "How to calculate rolling / moving average using python + NumPy / SciPy?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/c9d4ff02e8aa158f35f7f23cb45f8a4e?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/27d2ba661868f686b136b1a010376115?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/dce2259ff9b547103d54acf1ea622314?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/Hj2XY.jpg?s=64",
            "https://i.sstatic.net/auGP2.png?s=64",
            "https://i.sstatic.net/3FRYH.jpg?s=64",
            "https://i.sstatic.net/WLMMD.png?s=64",
            "https://www.gravatar.com/avatar/2d5c2f3ab025528bf49a11cfc757c0e4?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/eb2a984c4cf40fc03446c5d2e46877ff?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://lh5.googleusercontent.com/-z92gC2OVrUw/AAAAAAAAAAI/AAAAAAAAAAA/AMZuuclfrq4vTf14qeOujnnUiQj6kn1TWg/photo.jpg?sz=64",
            "https://lh3.googleusercontent.com/-KKYRDbvgkp4/AAAAAAAAAAI/AAAAAAAAADI/riDa9tl2pZk/photo.jpg?sz=64",
            "https://lh3.googleusercontent.com/-sszWW6Bs75k/AAAAAAAAAAI/AAAAAAAAAH0/wYyE5K7M6uM/photo.jpg?sz=64",
            "https://i.sstatic.net/6UbytrBM.jpg?s=64",
            "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/da3871bf5450fa726f20557fa3f18f51?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/IRB44.jpg?s=64",
            "https://lh3.googleusercontent.com/a-/AAuE7mC1m5pbSvtQQ_ptZOE701VGkEUv2jMuibmdGgbHg3w=k-s64",
            "https://www.gravatar.com/avatar/24458758dd3206b653b0a80fc238d373?s=64&d=identicon&r=PG",
            "https://lh4.googleusercontent.com/-ImGasab69Eo/AAAAAAAAAAI/AAAAAAAAAB8/LAC3c_gVDrE/photo.jpg?sz=64",
            "https://graph.facebook.com/2691104950936323/picture?type=large",
            "https://i.sstatic.net/g8tFC.jpg?s=64",
            "https://www.gravatar.com/avatar/f27774a5cf3d037d8238616627e892ea?s=64&d=identicon&r=PG",
            "https://stackoverflow.com/posts/14313510/ivc/5019?prg=bd2f53ff-1589-4930-94e0-044fbeac0f83"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2013-01-14T04:59:12",
        "summary": "",
        "meta_description": "There seems to be no function that simply calculates the moving average on numpy/scipy, leading to convoluted solutions.\n\nMy question is two-fold:\r\nWhat's the easiest way to (correctly) implement a",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/14313510/how-to-calculate-rolling-moving-average-using-python-numpy-scipy",
        "text": "A simple way to achieve this is by using np.convolve. The idea behind this is to leverage the way the discrete convolution is computed and use it to return a rolling mean. This can be done by convolving with a sequence of np.ones of a length equal to the sliding window length we want.\n\nIn order to do so we could define the following function:\n\ndef moving_average(x, w): return np.convolve(x, np.ones(w), 'valid') / w\n\nThis function will be taking the convolution of the sequence x and a sequence of ones of length w. Note that the chosen mode is valid so that the convolution product is only given for points where the sequences overlap completely.\n\nSome examples:\n\nx = np.array([5,3,8,10,2,1,5,1,0,2])\n\nFor a moving average with a window of length 2 we would have:\n\nmoving_average(x, 2) # array([4. , 5.5, 9. , 6. , 1.5, 3. , 3. , 0.5, 1. ])\n\nAnd for a window of length 4:\n\nmoving_average(x, 4) # array([6.5 , 5.75, 5.25, 4.5 , 2.25, 1.75, 2. ])\n\nHow does convolve work?\n\nLets have a more in depth look at the way the discrete convolution is being computed. The following function aims to replicate the way np.convolve is computing the output values:\n\ndef mov_avg(x, w): for m in range(len(x)-(w-1)): yield sum(np.ones(w) * x[m:m+w]) / w\n\nWhich, for the same example above would also yield:\n\nlist(mov_avg(x, 2)) # [4.0, 5.5, 9.0, 6.0, 1.5, 3.0, 3.0, 0.5, 1.0]\n\nSo what is being done at each step is to take the inner product between the array of ones and the current window. In this case the multiplication by np.ones(w) is superfluous given that we are directly taking the sum of the sequence.\n\nBellow is an example of how the first outputs are computed so that it is a little clearer. Lets suppose we want a window of w=4:\n\n[1,1,1,1] [5,3,8,10,2,1,5,1,0,2] = (1*5 + 1*3 + 1*8 + 1*10) / w = 6.5\n\nAnd the following output would be computed as:\n\n[1,1,1,1] [5,3,8,10,2,1,5,1,0,2] = (1*3 + 1*8 + 1*10 + 1*2) / w = 5.75\n\nAnd so on, returning a moving average of the sequence once all overlaps have been performed.\n\nNumPy's lack of a particular domain-specific function is perhaps due to the Core Team's discipline and fidelity to NumPy's prime directive: provide an N-dimensional array type, as well as functions for creating, and indexing those arrays. Like many foundational objectives, this one is not small, and NumPy does it brilliantly.\n\nThe (much) larger SciPy contains a much larger collection of domain-specific libraries (called subpackages by SciPy devs)--for instance, numerical optimization (optimize), signal processsing (signal), and integral calculus (integrate).\n\nMy guess is that the function you are after is in at least one of the SciPy subpackages (scipy.signal perhaps); however, i would look first in the collection of SciPy scikits, identify the relevant scikit(s) and look for the function of interest there.\n\nScikits are independently developed packages based on NumPy/SciPy and directed to a particular technical discipline (e.g., scikits-image, scikits-learn, etc.) Several of these were (in particular, the awesome OpenOpt for numerical optimization) were highly regarded, mature projects long before choosing to reside under the relatively new scikits rubric. The Scikits homepage liked to above lists about 30 such scikits, though at least several of those are no longer under active development.\n\nFollowing this advice would lead you to scikits-timeseries; however, that package is no longer under active development; In effect, Pandas has become, AFAIK, the de facto NumPy-based time series library.\n\nPandas has several functions that can be used to calculate a moving average; the simplest of these is probably rolling_mean, which you use like so:\n\n>>> # the recommended syntax to import pandas >>> import pandas as PD >>> import numpy as NP >>> # prepare some fake data: >>> # the date-time indices: >>> t = PD.date_range('1/1/2010', '12/31/2012', freq='D') >>> # the data: >>> x = NP.arange(0, t.shape[0]) >>> # combine the data & index into a Pandas 'Series' object >>> D = PD.Series(x, t)\n\nNow, just call the function rolling_mean passing in the Series object and a window size, which in my example below is 10 days.\n\n>>> d_mva = PD.rolling_mean(D, 10) >>> # d_mva is the same size as the original Series >>> d_mva.shape (1096,) >>> # though obviously the first w values are NaN where w is the window size >>> d_mva[:3] 2010-01-01 NaN 2010-01-02 NaN 2010-01-03 NaN\n\nverify that it worked--e.g., compared values 10 - 15 in the original series versus the new Series smoothed with rolling mean\n\n>>> D[10:15] 2010-01-11 2.041076 2010-01-12 2.041076 2010-01-13 2.720585 2010-01-14 2.720585 2010-01-15 3.656987 Freq: D >>> d_mva[10:20] 2010-01-11 3.131125 2010-01-12 3.035232 2010-01-13 2.923144 2010-01-14 2.811055 2010-01-15 2.785824 Freq: D\n\nThe function rolling_mean, along with about a dozen or so other function are informally grouped in the Pandas documentation under the rubric moving window functions; a second, related group of functions in Pandas is referred to as exponentially-weighted functions (e.g., ewma, which calculates exponentially moving weighted average). The fact that this second group is not included in the first (moving window functions) is perhaps because the exponentially-weighted transforms don't rely on a fixed-length window\n\nHere are a variety of ways to do this, along with some benchmarks. The best methods are versions using optimized code from other libraries. The bottleneck.move_mean method is probably best all around. The scipy.convolve approach is also very fast, extensible, and syntactically and conceptually simple, but doesn't scale well for very large window values. The numpy.cumsum method is good if you need a pure numpy approach.\n\nNote: Some of these (e.g. bottleneck.move_mean) are not centered, and will shift your data.\n\nimport numpy as np import scipy as sci import scipy.signal as sig import pandas as pd import bottleneck as bn import time as time def rollavg_direct(a,n): 'Direct \"for\" loop' assert n%2==1 b = a*0.0 for i in range(len(a)) : b[i]=a[max(i-n//2,0):min(i+n//2+1,len(a))].mean() return b def rollavg_comprehension(a,n): 'List comprehension' assert n%2==1 r,N = int(n/2),len(a) return np.array([a[max(i-r,0):min(i+r+1,N)].mean() for i in range(N)]) def rollavg_convolve(a,n): 'scipy.convolve' assert n%2==1 return sci.convolve(a,np.ones(n,dtype='float')/n, 'same')[n//2:-n//2+1] def rollavg_convolve_edges(a,n): 'scipy.convolve, edge handling' assert n%2==1 return sci.convolve(a,np.ones(n,dtype='float'), 'same')/sci.convolve(np.ones(len(a)),np.ones(n), 'same') def rollavg_cumsum(a,n): 'numpy.cumsum' assert n%2==1 cumsum_vec = np.cumsum(np.insert(a, 0, 0)) return (cumsum_vec[n:] - cumsum_vec[:-n]) / n def rollavg_cumsum_edges(a,n): 'numpy.cumsum, edge handling' assert n%2==1 N = len(a) cumsum_vec = np.cumsum(np.insert(np.pad(a,(n-1,n-1),'constant'), 0, 0)) d = np.hstack((np.arange(n//2+1,n),np.ones(N-n)*n,np.arange(n,n//2,-1))) return (cumsum_vec[n+n//2:-n//2+1] - cumsum_vec[n//2:-n-n//2]) / d def rollavg_roll(a,n): 'Numpy array rolling' assert n%2==1 N = len(a) rolling_idx = np.mod((N-1)*np.arange(n)[:,None] + np.arange(N), N) return a[rolling_idx].mean(axis=0)[n-1:] def rollavg_roll_edges(a,n): # see https://stackoverflow.com/questions/42101082/fast-numpy-roll 'Numpy array rolling, edge handling' assert n%2==1 a = np.pad(a,(0,n-1-n//2), 'constant')*np.ones(n)[:,None] m = a.shape[1] idx = np.mod((m-1)*np.arange(n)[:,None] + np.arange(m), m) # Rolling index out = a[np.arange(-n//2,n//2)[:,None], idx] d = np.hstack((np.arange(1,n),np.ones(m-2*n+1+n//2)*n,np.arange(n,n//2,-1))) return (out.sum(axis=0)/d)[n//2:] def rollavg_pandas(a,n): 'Pandas rolling average' return pd.DataFrame(a).rolling(n, center=True, min_periods=1).mean().to_numpy() def rollavg_bottlneck(a,n): 'bottleneck.move_mean' return bn.move_mean(a, window=n, min_count=1) N = 10**6 a = np.random.rand(N) functions = [rollavg_direct, rollavg_comprehension, rollavg_convolve, rollavg_convolve_edges, rollavg_cumsum, rollavg_cumsum_edges, rollavg_pandas, rollavg_bottlneck, rollavg_roll, rollavg_roll_edges] print('Small window (n=3)') %load_ext memory_profiler for f in functions : print('\\n'+f.__doc__+ ' : ') %timeit b=f(a,3) print('\\nLarge window (n=1001)') for f in functions[0:-2] : print('\\n'+f.__doc__+ ' : ') %timeit b=f(a,1001) print('\\nMemory\\n') print('Small window (n=3)') N = 10**7 a = np.random.rand(N) %load_ext memory_profiler for f in functions[2:] : print('\\n'+f.__doc__+ ' : ') %memit b=f(a,3) print('\\nLarge window (n=1001)') for f in functions[2:-2] : print('\\n'+f.__doc__+ ' : ') %memit b=f(a,1001)\n\nTiming, Small window (n=3)\n\nDirect \"for\" loop : 4.14 s ± 23.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) List comprehension : 3.96 s ± 27.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) scipy.convolve : 1.07 ms ± 26.7 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) scipy.convolve, edge handling : 4.68 ms ± 9.69 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) numpy.cumsum : 5.31 ms ± 5.11 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) numpy.cumsum, edge handling : 8.52 ms ± 11.1 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) Pandas rolling average : 9.85 ms ± 9.63 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) bottleneck.move_mean : 1.3 ms ± 12.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) Numpy array rolling : 31.3 ms ± 91.9 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) Numpy array rolling, edge handling : 61.1 ms ± 55.9 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nTiming, Large window (n=1001)\n\nDirect \"for\" loop : 4.67 s ± 34 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) List comprehension : 4.46 s ± 14.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) scipy.convolve : 103 ms ± 165 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) scipy.convolve, edge handling : 272 ms ± 1.23 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) numpy.cumsum : 5.19 ms ± 12.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) numpy.cumsum, edge handling : 8.7 ms ± 11.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) Pandas rolling average : 9.67 ms ± 199 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) bottleneck.move_mean : 1.31 ms ± 15.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\nMemory, Small window (n=3)\n\nThe memory_profiler extension is already loaded. To reload it, use: %reload_ext memory_profiler scipy.convolve : peak memory: 362.66 MiB, increment: 73.61 MiB scipy.convolve, edge handling : peak memory: 510.24 MiB, increment: 221.19 MiB numpy.cumsum : peak memory: 441.81 MiB, increment: 152.76 MiB numpy.cumsum, edge handling : peak memory: 518.14 MiB, increment: 228.84 MiB Pandas rolling average : peak memory: 449.34 MiB, increment: 160.02 MiB bottleneck.move_mean : peak memory: 374.17 MiB, increment: 75.54 MiB Numpy array rolling : peak memory: 661.29 MiB, increment: 362.65 MiB Numpy array rolling, edge handling : peak memory: 1111.25 MiB, increment: 812.61 MiB\n\nMemory, Large window (n=1001)\n\nscipy.convolve : peak memory: 370.62 MiB, increment: 71.83 MiB scipy.convolve, edge handling : peak memory: 521.98 MiB, increment: 223.18 MiB numpy.cumsum : peak memory: 451.32 MiB, increment: 152.52 MiB numpy.cumsum, edge handling : peak memory: 527.51 MiB, increment: 228.71 MiB Pandas rolling average : peak memory: 451.25 MiB, increment: 152.50 MiB bottleneck.move_mean : peak memory: 374.64 MiB, increment: 75.85 MiB\n\nI expanded on answers from argentum2f and Vittorio Carmignani. Here's the numba implementation that beats best known so far method from the bottleneck:\n\nimport numba import numpy as np import time as time import bottleneck as bn @numba.njit(fastmath=True) def rolling_moving_average(arr: np.ndarray, n: int = 2): if n <= 0: raise ValueError(\"n must be greater than 0\") if n > len(arr): raise ValueError(\"n must be less than or equal to the length of the array\") result = np.empty(len(arr) - n + 1, dtype=arr.dtype) sum_window = np.sum(arr[:n]) mult=1/n result[0] = sum_window*mult for i in range(1, len(arr) - n + 1): sum_window += arr[i + n - 1] - arr[i - 1] result[i] = sum_window *mult return result def rollavg_bottlneck(a,n): 'bottleneck.move_mean' return bn.move_mean(a, window=n, min_count=n) N = 10**6 a = np.random.rand(N) functions = [rollavg_bottlneck, rolling_moving_average] for f in functions: test_val=f(a,3) # potential prewarm for jit-compiled funcs for window_size in (3,1001): print(f'Window size={window_size}') for f in functions: print('\\n'+str(f.__name__)+ ': ') %timeit b=f(a,window_size) print(f\"{rollavg_bottlneck(np.arange(10),3)} vs {rolling_moving_average(np.arange(10),3)}\")\n\nWindow size=3\n\nrollavg_bottlneck: 6.75 ms ± 27.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\nrolling_moving_average: 5.22 ms ± 53.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\nWindow size=1001\n\nrollavg_bottlneck: 6.43 ms ± 42.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\nrolling_moving_average: 5.25 ms ± 60.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n[nan nan 1. 2. 3. 4. 5. 6. 7. 8.] vs [1 2 3 4 5 6 7 8]\n\nNote that outputs differ in alignment slightly."
    }
}