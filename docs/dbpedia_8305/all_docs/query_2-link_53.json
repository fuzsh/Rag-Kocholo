{
    "id": "dbpedia_8305_2",
    "rank": 53,
    "data": {
        "url": "https://solr.apache.org/guide/6_6/result-clustering.html",
        "read_more_link": "",
        "language": "en",
        "title": "Apache Solr Reference Guide 6.6",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://solr.apache.org/guide/6_6/images/result-clustering/carrot2.png",
            "https://solr.apache.org/guide/6_6/images/result-clustering/carrot2-workbench.png",
            "https://solr.apache.org/guide/6_6/images/solr-sunOnly-small.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "images/icons/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "The clustering (or cluster analysis) plugin attempts to automatically discover groups of related search hits (documents) and assign human-readable labels to these groups.\n\nBy default in Solr, the clustering algorithm is applied to the search result of each single query -â this is called an on-line clustering. While Solr contains an extension for full-index clustering (off-line clustering) this section will focus on discussing on-line clustering only.\n\nClusters discovered for a given query can be perceived as dynamic facets. This is beneficial when regular faceting is difficult (field values are not known in advance) or when the queries are exploratory in nature. Take a look at the Carrot2 project’s demo page to see an example of search results clustering in action (the groups in the visualization have been discovered automatically in search results to the right, there is no external information involved).\n\nThe query issued to the system was Solr. It seems clear that faceting could not yield a similar set of groups, although the goals of both techniques are similarâto let the user explore the set of search results and either rephrase the query or narrow the focus to a subset of current documents. Clustering is also similar to Result Grouping in that it can help to look deeper into search results, beyond the top few hits.\n\nEach document passed to the clustering component is composed of several logical parts:\n\na unique identifier,\n\norigin URL,\n\nthe title,\n\nthe main content,\n\na language code of the title and content.\n\nThe identifier part is mandatory, everything else is optional but at least one of the text fields (title or content) will be required to make the clustering process reasonable. It is important to remember that logical document parts must be mapped to a particular schema and its fields. The content (text) for clustering can be sourced from either a stored text field or context-filtered using a highlighter, all these options are explained below in the configuration section.\n\nA clustering algorithm is the actual logic (implementation) that discovers relationships among the documents in the search result and forms human-readable cluster labels. Depending on the choice of the algorithm the clusters may (and probably will) vary. Solr comes with several algorithms implemented in the open source Carrot2 project, commercial alternatives also exist.\n\nThe “techproducts” example included with Solr is pre-configured with all the necessary components for result clustering — but they are disabled by default.\n\nTo enable the clustering component contrib and a dedicated search handler configured to use it, specify a JVM System Property when running the example:\n\nbin/solr start -e techproducts -Dsolr.clustering.enabled=true\n\nYou can now try out the clustering handler by opening the following URL in a browser:\n\nhttp://localhost:8983/solr/techproducts/clustering?q=:&rows=100\n\nThe output XML should include search hits and an array of automatically discovered clusters at the end, resembling the output shown here:\n\n<response> <lst name=\"responseHeader\"> <int name=\"status\">0</int> <int name=\"QTime\">299</int> </lst> <result name=\"response\" numFound=\"32\" start=\"0\" maxScore=\"1.0\"> <doc> <str name=\"id\">GB18030TEST</str> <str name=\"name\">Test with some GB18030 encoded characters</str> <arr name=\"features\"> <str>No accents here</str> <str>è¿æ¯ä¸ä¸ªåè½</str> <str>This is a feature (translated)</str> <str>è¿ä»½æä»¶æ¯å¾æå æ³½</str> <str>This document is very shiny (translated)</str> </arr> <float name=\"price\">0.0</float> <str name=\"price_c\">0,USD</str> <bool name=\"inStock\">true</bool> <long name=\"_version_\">1448955395025403904</long> <float name=\"score\">1.0</float> </doc> <!-- more search hits, omitted --> </result> <arr name=\"clusters\"> <lst> <arr name=\"labels\"> <str>DDR</str> </arr> <double name=\"score\">3.9599865057283354</double> <arr name=\"docs\"> <str>TWINX2048-3200PRO</str> <str>VS1GB400C3</str> <str>VDBDB1A16</str> </arr> </lst> <lst> <arr name=\"labels\"> <str>iPod</str> </arr> <double name=\"score\">11.959228467119022</double> <arr name=\"docs\"> <str>F8V7067-APL-KIT</str> <str>IW-02</str> <str>MA147LL/A</str> </arr> </lst> <!-- More clusters here, omitted. --> <lst> <arr name=\"labels\"> <str>Other Topics</str> </arr> <double name=\"score\">0.0</double> <bool name=\"other-topics\">true</bool> <arr name=\"docs\"> <str>adata</str> <str>apple</str> <str>asus</str> <str>ati</str> <!-- other unassigned document IDs here --> </arr> </lst> </arr> </response>\n\nThere were a few clusters discovered for this query (*:*), separating search hits into various categories: DDR, iPod, Hard Drive, etc. Each cluster has a label and score that indicates the \"goodness\" of the cluster. The score is algorithm-specific and is meaningful only in relation to the scores of other clusters in the same set. In other words, if cluster A has a higher score than cluster B, cluster A should be of better quality (have a better label and/or more coherent document set). Each cluster has an array of identifiers of documents belonging to it. These identifiers correspond to the uniqueKey field declared in the schema.\n\nDepending on the quality of input documents, some clusters may not make much sense. Some documents may be left out and not be clustered at all; these will be assigned to the synthetic Other Topics group, marked with the other-topics property set to true (see the XML dump above for an example). The score of the other topics group is zero.\n\nDynamic clustering of search results comes with two major performance penalties:\n\nIncreased cost of fetching a larger-than-usual number of search results (50, 100 or more documents),\n\nAdditional computational cost of the clustering itself.\n\nFor simple queries, the clustering time will usually dominate the fetch time. If the document content is very long the retrieval of stored content can become a bottleneck. The performance impact of clustering can be lowered in several ways:\n\nfeed less content to the clustering algorithm by enabling carrot.produceSummary attribute,\n\nperform clustering on selected fields (titles only) to make the input smaller,\n\nuse a faster algorithm (STC instead of Lingo, Lingo3G instead of STC),\n\ntune the performance attributes related directly to a specific algorithm.\n\nSome of these techniques are described in Apache SOLR and Carrot2 integration strategies document, available at http://carrot2.github.io/solr-integration-strategies. The topic of improving performance is also included in the Carrot2 manual at http://doc.carrot2.org/#section.advanced-topics.fine-tuning.performance."
    }
}