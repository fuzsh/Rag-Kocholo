{
    "id": "dbpedia_8305_3",
    "rank": 10,
    "data": {
        "url": "https://solr.apache.org/guide/8_7/result-clustering.html",
        "read_more_link": "",
        "language": "en",
        "title": "Apache Solr Reference Guide 8.7",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://solr.apache.org/guide/8_7/images/solr-sunOnly-small.png",
            "https://solr.apache.org/guide/8_7/images/result-clustering/carrot2.png",
            "https://solr.apache.org/guide/8_7/images/result-clustering/carrot2-workbench.png",
            "https://solr.apache.org/guide/8_7/images/solr-sunOnly-small.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "images/icons/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Result Clustering\n\nThe clustering (or cluster analysis) plugin attempts to automatically discover groups of related search hits (documents) and assign human-readable labels to these groups.\n\nBy default in Solr, the clustering algorithm is applied to the search result of each single query -â this is called an on-line clustering. While Solr contains an extension for full-index clustering (off-line clustering) this section will focus on discussing on-line clustering only.\n\nClusters discovered for a given query can be perceived as dynamic facets. This is beneficial when regular faceting is difficult (field values are not known in advance) or when the queries are exploratory in nature. Take a look at the Carrot2 project’s demo page to see an example of search results clustering in action (the groups in the visualization have been discovered automatically in search results to the right, there is no external information involved).\n\nThe query issued to the system was Solr. It seems clear that faceting could not yield a similar set of groups, although the goals of both techniques are similarâto let the user explore the set of search results and either rephrase the query or narrow the focus to a subset of current documents. Clustering is also similar to Result Grouping in that it can help to look deeper into search results, beyond the top few hits.\n\nClustering Concepts\n\nEach document passed to the clustering component is composed of several logical parts:\n\na unique identifier,\n\norigin URL,\n\nthe title,\n\nthe main content,\n\na language code of the title and content.\n\nThe identifier part is mandatory, everything else is optional but at least one of the text fields (title or content) will be required to make the clustering process reasonable. It is important to remember that logical document parts must be mapped to a particular schema and its fields. The content (text) for clustering can be sourced from either a stored text field or context-filtered using a highlighter, all these options are explained below in the configuration section.\n\nA clustering algorithm is the actual logic (implementation) that discovers relationships among the documents in the search result and forms human-readable cluster labels. Depending on the choice of the algorithm the clusters may (and probably will) vary. Solr comes with several algorithms implemented in the open source Carrot2 project, commercial alternatives also exist.\n\nClustering Quick Start Example\n\nThe “techproducts” example included with Solr is pre-configured with all the necessary components for result clustering — but they are disabled by default.\n\nTo enable the clustering component contrib and a dedicated search handler configured to use it, specify a JVM System Property when running the example:\n\nbin/solr start -e techproducts -Dsolr.clustering.enabled=true\n\nYou can now try out the clustering handler by opening the following URL in a browser:\n\nhttp://localhost:8983/solr/techproducts/clustering?q=*:*&rows=100&wt=xml\n\nThe output XML should include search hits and an array of automatically discovered clusters at the end, resembling the output shown here:\n\nThere were a few clusters discovered for this query (*:*), separating search hits into various categories: DDR, iPod, Hard Drive, etc. Each cluster has a label and score that indicates the \"goodness\" of the cluster. The score is algorithm-specific and is meaningful only in relation to the scores of other clusters in the same set. In other words, if cluster A has a higher score than cluster B, cluster A should be of better quality (have a better label and/or more coherent document set). Each cluster has an array of identifiers of documents belonging to it. These identifiers correspond to the uniqueKey field declared in the schema.\n\nDepending on the quality of input documents, some clusters may not make much sense. Some documents may be left out and not be clustered at all; these will be assigned to the synthetic Other Topics group, marked with the other-topics property set to true (see the XML dump above for an example). The score of the other topics group is zero.\n\nInstalling the Clustering Contrib\n\nThe clustering contrib extension requires dist/solr-clustering-*.jar and all JARs under contrib/clustering/lib.\n\nClustering Configuration\n\nDeclaration of the Clustering Search Component and Request Handler\n\nClustering extension is a search component and must be declared in solrconfig.xml. Such a component can be then appended to a request handler as the last component in the chain (because it requires search results which must be previously fetched by the search component).\n\nAn example configuration could look as shown below.\n\nInclude the required contrib JARs. Note that by default paths are relative to the Solr core so they may need adjustments to your configuration, or an explicit specification of the $solr.install.dir.\n\n<lib dir=\"${solr.install.dir:../../..}/contrib/clustering/lib/\" regex=\".*\\.jar\" /> <lib dir=\"${solr.install.dir:../../..}/dist/\" regex=\"solr-clustering-\\d.*\\.jar\" />\n\nDeclaration of the search component. Each component can also declare multiple clustering pipelines (\"engines\"), which can be selected at runtime by passing clustering.engine=(engine name) URL parameter.\n\nA request handler to which we append the clustering component declared above.\n\nConfiguration Parameters of the Clustering Component\n\nThe following parameters of each clustering engine or the entire clustering component (depending where they are declared) are available.\n\nclustering\n\nWhen true, clustering component is enabled.\n\nclustering.engine\n\nDeclares which clustering engine to use. If not present, the first declared engine will become the default one.\n\nclustering.results\n\nWhen true, the component will perform clustering of search results (this should be enabled).\n\nclustering.collection\n\nWhen true, the component will perform clustering of the whole document index (this section does not cover full-index clustering).\n\nAt the engine declaration level, the following parameters are supported.\n\ncarrot.algorithm\n\nThe algorithm class.\n\ncarrot.resourcesDir\n\nAlgorithm-specific resources and configuration files (stop words, other lexical resources, default settings). By default points to conf/clustering/carrot2/\n\ncarrot.outputSubClusters\n\nIf true and the algorithm supports hierarchical clustering, sub-clusters will also be emitted. Default value: true.\n\ncarrot.numDescriptions\n\nMaximum number of per-cluster labels to return (if the algorithm assigns more than one label to a cluster).\n\nThe carrot.algorithm parameter should contain a fully qualified class name of an algorithm supported by the Carrot2 framework. Currently, the following algorithms are available:\n\norg.carrot2.clustering.lingo.LingoClusteringAlgorithm (open source)\n\norg.carrot2.clustering.stc.STCClusteringAlgorithm (open source)\n\norg.carrot2.clustering.kmeans.BisectingKMeansClusteringAlgorithm (open source)\n\ncom.carrotsearch.lingo3g.Lingo3GClusteringAlgorithm (commercial)\n\nFor a comparison of characteristics of these algorithms see the following links:\n\nhttp://doc.carrot2.org/#section.advanced-topics.fine-tuning.choosing-algorithm\n\nhttp://project.carrot2.org/algorithms.html\n\nhttp://carrotsearch.com/lingo3g-comparison.html\n\nThe question of which algorithm to choose depends on the amount of traffic (STC is faster than Lingo, but arguably produces less intuitive clusters, Lingo3G is the fastest algorithm but is not free or open source), expected result (Lingo3G provides hierarchical clusters, Lingo and STC provide flat clusters), and the input data (each algorithm will cluster the input slightly differently). There is no one answer which algorithm is \"the best\".\n\nContextual and Full Field Clustering\n\nThe clustering engine can apply clustering to the full content of (stored) fields or it can run an internal highlighter pass to extract context-snippets before clustering. Highlighting is recommended when the logical snippet field contains a lot of content (this would affect clustering performance). Highlighting can also increase the quality of clustering because the content passed to the algorithm will be more focused around the query (it will be query-specific context). The following parameters control the internal highlighter.\n\ncarrot.produceSummary\n\nWhen true the clustering component will run a highlighter pass on the content of logical fields pointed to by carrot.title and carrot.snippet. Otherwise full content of those fields will be clustered.\n\ncarrot.fragSize\n\nThe size, in characters, of the snippets (aka fragments) created by the highlighter. If not specified, the default highlighting fragsize (hl.fragsize) will be used.\n\ncarrot.summarySnippets\n\nThe number of summary snippets to generate for clustering. If not specified, the default highlighting snippet count (hl.snippets) will be used.\n\nLogical to Document Field Mapping\n\nAs already mentioned in Clustering Concepts, the clustering component clusters \"documents\" consisting of logical parts that need to be mapped onto physical schema of data stored in Solr. The field mapping attributes provide a connection between fields and logical document parts. Note that the content of title and snippet fields must be stored so that it can be retrieved at search time.\n\ncarrot.title\n\nThe field (alternatively comma- or space-separated list of fields) that should be mapped to the logical document’s title. The clustering algorithms typically give more weight to the content of the title field compared to the content (snippet). For best results, the field should contain concise, noise-free content. If there is no clear title in your data, you can leave this parameter blank.\n\ncarrot.snippet\n\nThe field (alternatively comma- or space-separated list of fields) that should be mapped to the logical document’s main content. If this mapping points to very large content fields the performance of clustering may drop significantly. An alternative then is to use query-context snippets for clustering instead of full field content. See the description of the carrot.produceSummary parameter for details.\n\ncarrot.url\n\nThe field that should be mapped to the logical document’s content URL. Leave blank if not required.\n\nClustering Multilingual Content\n\nThe field mapping specification can include a carrot.lang parameter, which defines the field that stores ISO 639-1 code of the language in which the title and content of the document are written. This information can be stored in the index based on apriori knowledge of the documents' source or a language detection filter applied at indexing time. All algorithms inside the Carrot2 framework will accept ISO codes of languages defined in LanguageCode enum.\n\nThe language hint makes it easier for clustering algorithms to separate documents from different languages on input and to pick the right language resources for clustering. If you do have multi-lingual query results (or query results in a language different than English), it is strongly advised to map the language field appropriately.\n\ncarrot.lang\n\nThe field that stores ISO 639-1 code of the language of the document’s text fields.\n\ncarrot.lcmap\n\nA mapping of arbitrary strings into ISO 639 two-letter codes used by carrot.lang. The syntax of this parameter is the same as langid.map.lcmap, for example: langid.map.lcmap=japanese:ja polish:pl english:en\n\nThe default language can also be set using Carrot2-specific algorithm attributes (in this case the MultilingualClustering.defaultLanguage attribute).\n\nTweaking Algorithm Settings\n\nThe algorithms that come with Solr are using their default settings which may be inadequate for all data sets. All algorithms have lexical resources and resources (stop words, stemmers, parameters) that may require tweaking to get better clusters (and cluster labels). For Carrot2-based algorithms it is probably best to refer to a dedicated tuning application called Carrot2 Workbench (screenshot below). From this application one can export a set of algorithm attributes as an XML file, which can be then placed under the location pointed to by carrot.resourcesDir.\n\nProviding Defaults for Clustering\n\nThe default attributes for all engines (algorithms) declared in the clustering component are placed under carrot.resourcesDir and with an expected file name of engineName-attributes.xml. So for an engine named lingo and the default value of carrot.resourcesDir, the attributes would be read from a file in conf/clustering/carrot2/lingo-attributes.xml.\n\nAn example XML file changing the default language of documents to Polish is shown below.\n\n<attribute-sets default=\"attributes\"> <attribute-set id=\"attributes\"> <value-set> <label>attributes</label> <attribute key=\"MultilingualClustering.defaultLanguage\"> <value type=\"org.carrot2.core.LanguageCode\" value=\"POLISH\"/> </attribute> </value-set> </attribute-set> </attribute-sets>\n\nTweaking Algorithms at Query-Time\n\nThe clustering component and Carrot2 clustering algorithms can accept query-time attribute overrides. Note that certain things (for example lexical resources) can only be initialized once (at startup, via the XML configuration files).\n\nAn example query that changes the LingoClusteringAlgorithm.desiredClusterCountBase parameter for the Lingo algorithm:\n\nhttp://localhost:8983/solr/techproducts/clustering?q=*:*&rows=100&LingoClusteringAlgorithm.desiredClusterCountBase=20\n\nThe clustering engine (the algorithm declared in solrconfig.xml) can also be changed at runtime by passing clustering.engine=name request attribute:\n\nhttp://localhost:8983/solr/techproducts/clustering?q=*:*&rows=100&clustering.engine=kmeans\n\nPerformance Considerations with Dynamic Clustering\n\nDynamic clustering of search results comes with two major performance penalties:\n\nIncreased cost of fetching a larger-than-usual number of search results (50, 100 or more documents),\n\nAdditional computational cost of the clustering itself.\n\nFor simple queries, the clustering time will usually dominate the fetch time. If the document content is very long the retrieval of stored content can become a bottleneck. The performance impact of clustering can be lowered in several ways:\n\nfeed less content to the clustering algorithm by enabling carrot.produceSummary attribute,\n\nperform clustering on selected fields (titles only) to make the input smaller,\n\nuse a faster algorithm (STC instead of Lingo, Lingo3G instead of STC),\n\ntune the performance attributes related directly to a specific algorithm.\n\nSome of these techniques are described in Apache SOLR and Carrot2 integration strategies document, available at http://carrot2.github.io/solr-integration-strategies. The topic of improving performance is also included in the Carrot2 manual at http://doc.carrot2.org/#section.advanced-topics.fine-tuning.performance.\n\nAdditional Resources\n\nThe following resources provide additional information about the clustering component in Solr and its potential applications.\n\nApache Solr and Carrot2 integration strategies: http://carrot2.github.io/solr-integration-strategies\n\nClustering and Visualization of Solr search results (Berlin BuzzWords conference, 2011): http://2011.berlinbuzzwords.de/sites/2011.berlinbuzzwords.de/files/solr-clustering-visualization.pdf"
    }
}