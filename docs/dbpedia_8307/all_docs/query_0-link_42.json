{
    "id": "dbpedia_8307_0",
    "rank": 42,
    "data": {
        "url": "https://solr.apache.org/guide/solr/latest/query-guide/result-clustering.html",
        "read_more_link": "",
        "language": "en",
        "title": "Result Clustering :: Apache Solr Reference Guide",
        "top_image": "https://solr.apache.org/guide/_/img/favicon.ico",
        "meta_img": "https://solr.apache.org/guide/_/img/favicon.ico",
        "images": [
            "https://solr.apache.org/guide/_/img/solr-sunOnly-small.png",
            "https://solr.apache.org/guide/solr/latest/query-guide/_images/result-clustering/carrot2.png",
            "https://solr.apache.org/guide/solr/latest/query-guide/_images/result-clustering/carrot2-docs-attrs1.png",
            "https://solr.apache.org/guide/solr/latest/query-guide/_images/result-clustering/carrot2-docs-attrs2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "../../../_/img/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://solr.apache.org/guide/solr/latest/query-guide/result-clustering.html",
        "text": "The clustering (or cluster analysis) plugin attempts to automatically discover groups of related search hits (documents) and assign human-readable labels to these groups.\n\nThe clustering algorithm in Solr is applied to documents included in search result of each single query -â this is called an on-line clustering.\n\nClusters discovered for a given query can be perceived as dynamic facets. This is beneficial when regular faceting is difficult (field values are not known in advance) or when the queries are exploratory in nature. Take a look at the Carrot2 project’s demo page to see an example of search results clustering in action (the groups in the visualization have been discovered automatically in search results to the right, there is no external information involved).\n\nThe query issued to the system was Apache Solr. It seems clear that faceting could not yield a similar set of groups, although the goals of both techniques are similar — to let the user explore the set of search results and either rephrase the query or narrow the focus to a subset of current documents. Clustering is also similar to Result Grouping in that it can help to look deeper into search results, beyond the top few hits.\n\nThe clustering extension works as a search component. It needs to be declared and configured in solrconfig.xml, for example:\n\n<searchComponent class=\"org.apache.solr.handler.clustering.ClusteringComponent\" name=\"clustering\"> <lst name=\"engine\"> <str name=\"name\">lingo</str> <str name=\"clustering.fields\">title, content</str> <str name=\"clustering.algorithm\">Lingo</str> </lst> </searchComponent>\n\nThe above declares the clustering component with a single engine — there may be multiple engines declared and switched at runtime. We will return to the details of how to configure engines later.\n\nThe clustering component must be attached to a SearchHandler and explicitly enabled via property clustering. It is important to attach it as the last component in the handler’s pipeline, as shown below:\n\n<requestHandler name=\"/select\" class=\"solr.SearchHandler\"> <lst name=\"defaults\"> <bool name=\"clustering\">true</bool> <str name=\"clustering.engine\">lingo</str> </lst> <arr name=\"last-components\"> <str>clustering</str> </arr> </requestHandler>\n\nOnce attached, as in the example above, the clustering will be performed automatically on all documents matching the search handler’s query. The clustering extension will take into account all text fields listed in clustering.fields parameter of the engine and will produce a section of the response called clusters containing the discovered structure of groups, for example (JSON response for brevity):\n\n{ \"clusters\": [ { \"labels\": [\"Memory\"], \"score\": 6.80, \"docs\":[ \"0579B002\", \"EN7800GTX/2DHTV/256M\", \"TWINX2048-3200PRO\", \"VDBDB1A16\", \"VS1GB400C3\"]}, { \"labels\":[\"Coins and Notes\"], \"score\":28.560285143284457, \"docs\":[\"EUR\", \"GBP\", \"NOK\", \"USD\"]}, { \"labels\":[\"TFT LCD\"], \"score\":15.355729924203429, \"docs\":[\"3007WFP\", \"9885A004\", \"MA147LL/A\", \"VA902B\"]} ] }\n\nThe labels element of each cluster is a dynamically discovered phrase that describes and applies to all document identifiers under docs element.\n\nThe \"techproducts\" example included with Solr is pre-configured with all the necessary components for result clustering — but they are disabled by default.\n\nTo enable the clustering component extension and the dedicated search handler configured to use it, specify a JVM System Property when running the example:\n\nbin/solr start -e techproducts -Dsolr.clustering.enabled=true\n\nYou can now try out the clustering handler by opening the following URL in a browser:\n\nhttp://localhost:8983/solr/techproducts/clustering?q=*:*&rows=100&wt=xml\n\nThe output XML should include search hits and an array of automatically discovered clusters at the end, resembling the output shown here:\n\n<response> <lst name=\"responseHeader\"> <int name=\"status\">0</int> <int name=\"QTime\">299</int> </lst> <result name=\"response\" numFound=\"32\" start=\"0\" maxScore=\"1.0\"> <doc> <str name=\"id\">GB18030TEST</str> <str name=\"name\">Test with some GB18030 encoded characters</str> <arr name=\"features\"> <str>No accents here</str> <str>è¿æ¯ä¸ä¸ªåè½</str> <str>This is a feature (translated)</str> <str>è¿ä»½æä»¶æ¯å¾æå æ³½</str> <str>This document is very shiny (translated)</str> </arr> <float name=\"price\">0.0</float> <str name=\"price_c\">0,USD</str> <bool name=\"inStock\">true</bool> <long name=\"_version_\">1448955395025403904</long> <float name=\"score\">1.0</float> </doc> <!-- more search hits, omitted --> </result> <arr name=\"clusters\"> <lst> <arr name=\"labels\"> <str>DDR</str> </arr> <double name=\"score\">3.9599865057283354</double> <arr name=\"docs\"> <str>TWINX2048-3200PRO</str> <str>VS1GB400C3</str> <str>VDBDB1A16</str> </arr> </lst> <lst> <arr name=\"labels\"> <str>iPod</str> </arr> <double name=\"score\">11.959228467119022</double> <arr name=\"docs\"> <str>F8V7067-APL-KIT</str> <str>IW-02</str> <str>MA147LL/A</str> </arr> </lst> <!-- More clusters here, omitted. --> <lst> <arr name=\"labels\"> <str>Other Topics</str> </arr> <double name=\"score\">0.0</double> <bool name=\"other-topics\">true</bool> <arr name=\"docs\"> <str>adata</str> <str>apple</str> <str>asus</str> <str>ati</str> <!-- other unassigned document IDs here --> </arr> </lst> </arr> </response>\n\nA few clusters discovered for this query (*:*), separate all search hits into various categories: DDR, iPod, Hard Drive, etc. Each cluster has a label and score that indicates the \"goodness\" of the cluster. The score is algorithm-specific and is meaningful only in relation to the scores of other clusters in the same set. In other words, if cluster A has a higher score than cluster B, cluster A should be of better quality (have a better label and/or more coherent document set). Each cluster has an array of identifiers of documents belonging to it. These identifiers correspond to the uniqueKey field declared in the schema.\n\nSometimes cluster labels may not make much sense (this depends on many factors — text in clustered fields, number of documents, algorithm paramerters). Also, some documents may be left out and not be clustered at all; these will be assigned to the synthetic Other Topics group, marked with the other-topics property set to true (see the XML dump above for an example). The score of the other topics group is zero.\n\nThe clustering algorithms that come with Solr use their default parameter values and language resources. We highly recommend tuning both for production uses. Improving the default language resources to include words and phrases common to a particular document domain will improve clustering quality significantly.\n\nCarrot2 algorithms have an extensive set of parameters and language resource tuning options. Please refer to up-to-date project documentation. In particular, the language resources section and each algorithm’s attributes section.\n\nChanging Clustering Algorithm Parameters\n\nClustering algorithm settings can be changed via Solr parameters either permanently (in the Engine’s declaration) or per-request (via Solr URL parameters).\n\nFor example, let’s assume the following engine configuration:\n\n<lst name=\"engine\"> <str name=\"name\">lingo</str> <str name=\"clustering.algorithm\">Lingo</str> <str name=\"clustering.fields\">name, features</str> <str name=\"clustering.language\">English</str> </lst>\n\nFirst, locate the configuration parameters for the Lingo algorithm at Carrot2 documentation site:\n\nThen locate the particular setting you’d like to change and note the REST API path to that setting (in this case the parameter is minClusterSize and its path is preprocessing.documentAssigner.minClusterSize):\n\nNow add the full path-value pair to the engine’s configuration:\n\n<lst name=\"engine\"> <str name=\"name\">lingo</str> <str name=\"clustering.algorithm\">Lingo</str> <str name=\"clustering.fields\">name, features</str> <str name=\"clustering.language\">English</str> <int name=\"preprocessing.documentAssigner.minClusterSize\">3</int> </lst>\n\nThe following rules apply.\n\nThe type of the parameter must be consistent with the type listed in Carrot2 specification.\n\nIf the parameter is added to the engine’s configuration in solrconfig.xml, the core must be reloaded for the changes to be picked up. Alternatively, pass the parameter via the request URL to change things dynamically on a per-request basis. For example, if you have the \"techproducts\" example running, this will cut the clusters to only those containing at least three documents: http://localhost:8983/solr/techproducts/clustering?q=*:*&rows=100&wt=json&preprocessing.documentAssigner.minClusterSize=3\n\nFor complex types, the parameter key with the name of the instantiated type must precede any of its own parameters.\n\nCustom Language Resources\n\nClustering algorithms rely on language and domain-specific language resources to improve the quality of clusters (by discarding domain-specific noise and boilerplate language).\n\nBy default, language resources are read from the engine-declared algorithm default JAR. You can pass a custom location for these resources by specifying the clustering.resources parameter. The value of this parameter resolves to a location relative to Solr core’s configuration directory. For example, the following definition:\n\n<lst name=\"engine\"> <str name=\"name\">lingo</str> <str name=\"clustering.algorithm\">Lingo</str> <str name=\"clustering.fields\">name, features</str> <str name=\"clustering.language\">English</str> <str name=\"clustering.resources\">lingo-resources</str> </lst>\n\nwould result in the following log entry and expected resource location:\n\nClustering algorithm resources first looked up relative to: [.../example/techproducts/solr/techproducts/conf/lingo-resources]\n\nThe best way to start tuning algorithm resources is to copy all the defaults from its corresponding Carrot2 JAR file (or Carrot2 distribution)."
    }
}