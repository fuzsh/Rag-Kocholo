{
    "id": "dbpedia_8307_3",
    "rank": 54,
    "data": {
        "url": "https://c4model.com/",
        "read_more_link": "",
        "language": "en",
        "title": "The C4 model for visualising software architecture",
        "top_image": "https://static.structurizr.com/workspace/36141/diagrams/Containers-key.png",
        "meta_img": "",
        "images": [
            "https://c4model.com/img/sketch-1.jpg",
            "https://c4model.com/img/sketch-2.jpg",
            "https://c4model.com/img/sketch-3.jpg",
            "https://c4model.com/img/sketch-4.jpg",
            "https://c4model.com/img/map-4.jpg",
            "https://c4model.com/img/map-3.jpg",
            "https://c4model.com/img/map-2.jpg",
            "https://c4model.com/img/map-1.jpg",
            "https://static.structurizr.com/workspace/36141/diagrams/SystemContext.png",
            "https://static.structurizr.com/workspace/36141/diagrams/Containers.png",
            "https://static.structurizr.com/workspace/36141/diagrams/Components.png",
            "https://c4model.com/img/class-diagram.png",
            "https://c4model.com/img/c4-overview.png",
            "https://c4model.com/img/zoom-in.svg",
            "https://c4model.com/img/abstractions.png",
            "https://c4model.com/img/glyphicons-basic-351-link.svg",
            "https://static.structurizr.com/workspace/36141/diagrams/SystemContext.png",
            "https://static.structurizr.com/workspace/36141/diagrams/SystemContext-key.png",
            "https://c4model.com/img/glyphicons-basic-351-link.svg",
            "https://static.structurizr.com/workspace/36141/diagrams/Containers.png",
            "https://static.structurizr.com/workspace/36141/diagrams/Containers-key.png",
            "https://c4model.com/img/glyphicons-basic-351-link.svg",
            "https://static.structurizr.com/workspace/36141/diagrams/Components.png",
            "https://static.structurizr.com/workspace/36141/diagrams/Components-key.png",
            "https://c4model.com/img/glyphicons-basic-351-link.svg",
            "https://c4model.com/img/class-diagram.png",
            "https://c4model.com/img/glyphicons-basic-351-link.svg",
            "https://static.structurizr.com/workspace/28201/diagrams/SystemLandscape.png",
            "https://static.structurizr.com/workspace/28201/diagrams/SystemLandscape-key.png",
            "https://c4model.com/img/glyphicons-basic-351-link.svg",
            "https://static.structurizr.com/workspace/36141/diagrams/SignIn.png",
            "https://static.structurizr.com/workspace/36141/diagrams/SignIn-key.png",
            "https://c4model.com/img/glyphicons-basic-351-link.svg",
            "https://static.structurizr.com/workspace/36141/diagrams/LiveDeployment.png",
            "https://static.structurizr.com/workspace/36141/diagrams/LiveDeployment-key.png",
            "https://static.structurizr.com/workspace/54915/diagrams/AmazonWebServicesDeployment.png",
            "https://c4model.com/img/notation-person.png",
            "https://c4model.com/img/notation-software-system.png",
            "https://c4model.com/img/notation-container.png",
            "https://c4model.com/img/notation-component.png",
            "https://c4model.com/img/notation-relationship.png",
            "https://c4model.com/img/spring-petclinic-system-context.png",
            "https://c4model.com/img/spring-petclinic-containers.png",
            "https://c4model.com/img/spring-petclinic-components.png",
            "https://c4model.com/img/spring-petclinic-system-context-plantuml.png",
            "https://c4model.com/img/spring-petclinic-containers-plantuml.png",
            "https://c4model.com/img/spring-petclinic-components-plantuml.png",
            "https://c4model.com/img/spring-petclinic-system-context-staruml.png",
            "https://c4model.com/img/spring-petclinic-containers-staruml.png",
            "https://c4model.com/img/spring-petclinic-components-staruml.png",
            "https://static.structurizr.com/workspace/36141/diagrams/Containers-key.png",
            "https://c4model.com/img/alternative-1.png",
            "https://c4model.com/img/alternative-2.png",
            "https://c4model.com/img/alternative-3.png",
            "https://c4model.com/img/book.png",
            "https://i.creativecommons.org/l/by/4.0/88x31.png",
            "https://c4model.com/img/simonbrown.jpg",
            "https://c4model.com/img/structurizr.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Introduction\n\nAsk somebody in the building industry to visually communicate the architecture of a building and you'll be presented with site plans, floor plans, elevation views, cross-section views and detail drawings. In contrast, ask a software developer to communicate the software architecture of a software system using diagrams and you'll likely get a confused mess of boxes and lines ... inconsistent notation (colour coding, shapes, line styles, etc), ambiguous naming, unlabelled relationships, generic terminology, missing technology choices, mixed abstractions, etc.\n\nAs an industry, we do have the Unified Modeling Language (UML), ArchiMate and SysML, but asking whether these provide an effective way to communicate software architecture is often irrelevant because many teams have already thrown them out in favour of much simpler \"boxes and lines\" diagrams. Abandoning these modelling languages is one thing but, perhaps in the race for agility, many software development teams have lost the ability to communicate visually.\n\nMaps of your code\n\nThe C4 model was created as a way to help software development teams describe and communicate software architecture, both during up-front design sessions and when retrospectively documenting an existing codebase. It's a way to create maps of your code, at various levels of detail, in the same way you would use something like Google Maps to zoom in and out of an area you are interested in.\n\nLevel 1: A System Context diagram provides a starting point, showing how the software system in scope fits into the world around it.\n\nLevel 2: A Container diagram zooms into the software system in scope, showing the high-level technical building blocks.\n\nLevel 3: A Component diagram zooms into an individual container, showing the components inside it.\n\nLevel 4: A code (e.g. UML class) diagram can be used to zoom into an individual component, showing how that component is implemented.\n\nThe C4 model is an \"abstraction-first\" approach to diagramming software architecture, based upon abstractions that reflect how software architects and developers think about and build software. The small set of abstractions and diagram types makes the C4 model easy to learn and use. Please note that you don't need to use all 4 levels of diagram; only those that add value - the System Context and Container diagrams are sufficient for many software development teams.\n\nDifferent levels of zoom allow you to tell different stories to different audiences.\n\nHover your mouse over the diagram, find elements with a , and double-click to zoom-in.\n\nAbstractions\n\nIn order to create these maps of your code, we first need a common set of abstractions to create a ubiquitous language that we can use to describe the static structure of a software system. A software system is made up of one or more containers (applications and data stores), each of which contains one or more components, which in turn are implemented by one or more code elements (classes, interfaces, objects, functions, etc). And people may use the software systems that we build.\n\nPerson\n\nA person represents one of the human users of your software system (e.g. actors, roles, personas, etc).\n\nSoftware System\n\nA software system is the highest level of abstraction and describes something that delivers value to its users, whether they are human or not. This includes the software system you are modelling, and the other software systems upon which your software system depends (or vice versa).\n\nUnfortunately the term \"software system\" is the hardest of the C4 model abstractions to define, and this isn't helped by the fact that each organisation will also have their own terminology for describing the same thing, typically using terms such as \"application\", \"product\", \"service\", etc. One way to think about it is that a software system is something a single software development team is building, owns, has responsibility for, and can see the internal implementation details of. Perhaps the code for that software system resides in a single source code repository, and anybody on the team is entitled to modify it. In many cases, the boundary of a software system will correspond to the boundary of a single team. It may also be the case that everything inside the boundary of a software system is deployed at the same time.\n\nContainer (applications and data stores)\n\nNot Docker! In the C4 model, a container represents an application or a data store. A container is something that needs to be running in order for the overall software system to work. In real terms, a container is something like:\n\nServer-side web application: A Java EE web application running on Apache Tomcat, an ASP.NET MVC application running on Microsoft IIS, a Ruby on Rails application running on WEBrick, a Node.js application, etc.\n\nClient-side web application: A JavaScript application running in a web browser using Angular, Backbone.JS, jQuery, etc.\n\nClient-side desktop application: A Windows desktop application written using WPF, an OS X desktop application written using Objective-C, a cross-platform desktop application written using JavaFX, etc.\n\nMobile app: An Apple iOS app, an Android app, a Microsoft Windows Phone app, etc.\n\nServer-side console application: A standalone (e.g. \"public static void main\") application, a batch process, etc.\n\nServerless function: A single serverless function (e.g. Amazon Lambda, Azure Function, etc).\n\nDatabase: A schema or database in a relational database management system, document store, graph database, etc such as MySQL, Microsoft SQL Server, Oracle Database, MongoDB, Riak, Cassandra, Neo4j, etc.\n\nBlob or content store: A blob store (e.g. Amazon S3, Microsoft Azure Blob Storage, etc) or content delivery network (e.g. Akamai, Amazon CloudFront, etc).\n\nFile system: A full local file system or a portion of a larger networked file system (e.g. SAN, NAS, etc).\n\nShell script: A single shell script written in Bash, etc.\n\netc\n\nComponent\n\nThe word \"component\" is a hugely overloaded term in the software development industry, but in this context a component is a grouping of related functionality encapsulated behind a well-defined interface. If you're using a language like Java or C#, the simplest way to think of a component is that it's a collection of implementation classes behind an interface. Aspects such as how those components are packaged (e.g. one component vs many components per JAR file, DLL, shared library, etc) is a separate and orthogonal concern.\n\nAn important point to note here is that all components inside a container typically execute in the same process space. In the C4 model, components are not separately deployable units.\n\nNotation\n\nThe C4 model is notation independent, and doesn't prescribe any particular notation. As a starting point though, a simple notation that works well on whiteboards, paper, sticky notes, index cards and a variety of diagraming tools is as follows.\n\nYou can then use colour and shapes to supplement the diagram, either to add additional information or simply to make the diagram more aesthetically pleasing.\n\nC4 and UML\n\nAlthough the example diagrams above are created using a \"boxes and lines\" notation, the core diagrams can be illustrated using UML with the appropriate use of packages, components and stereotypes. The resulting UML diagrams do tend to lack the same degree of descriptive text though, because adding such text isn't possible (or easy) with some UML tools.\n\nHere are three examples of a System Context, Container and Component diagram for comparison.\n\nSystem Context diagram\n\nContainer diagram\n\nComponent diagram\n\nC4 and ArchiMate\n\nSee C4 Model, Architecture Viewpoint and Archi 4.7 for details of how to create C4 model diagrams with ArchiMate.\n\nDiagram key/legend\n\nAny notation used should be as self-describing as possible, but all diagrams should have a key/legend to make the notation explicit. This applies to diagrams created with notations such as UML, ArchiMate and SysML too, as not everybody will know the notation being used.\n\nNotation, notation, notation\n\nAlthough the C4 model is an abstraction-first approach and notation independent, you still need to ensure that your diagram notation makes sense, and that the diagrams are comprehensible. A good way to think about this is to ask yourself whether each diagram can stand alone, and be (mostly) understood without a narrative. You can use this short software architecture diagram review checklist to help. And here are some recommendations related to notation.\n\nDiagrams\n\nEvery diagram should have a title describing the diagram type and scope (e.g. \"System Context diagram for My Software System\").\n\nEvery diagram should have a key/legend explaining the notation being used (e.g. shapes, colours, border styles, line types, arrow heads, etc).\n\nAcronyms and abbreviations (business/domain or technology) should be understandable by all audiences, or explained in the diagram key/legend.\n\nElements\n\nThe type of every element should be explicitly specified (e.g. Person, Software System, Container or Component).\n\nEvery element should have a short description, to provide an \"at a glance\" view of key responsibilities.\n\nEvery container and component should have a technology explicitly specified.\n\nRelationships\n\nEvery line should represent a unidirectional relationship.\n\nEvery line should be labelled, the label being consistent with the direction and intent of the relationship (e.g. dependency or data flow). Try to be as specific as possible with the label, ideally avoiding single words like, \"Uses\".\n\nRelationships between containers (typically these represent inter-process communication) should have a technology/protocol explicitly labelled.\n\nAlternative visualisations\n\nFinally, don't feel that you need to always use a traditional \"boxes and arrows\" diagram. Although this is usually the default approach, there are other, often interactive, visualisations that can be used to show the same C4 model abstractions in very different ways.\n\nTraditional \"boxes and arrows\" diagrams are the default approach for documentation and presentations.\n\nA D3.js force-directed graph is a very concise way to visualise larger software architectures, also providing an easy way to explore dependencies.\n\nIlograph's interactive diagrams provide a way to selectively zoom in and out, allowing you to explore your entire software architecture model."
    }
}