{
    "id": "dbpedia_8307_0",
    "rank": 28,
    "data": {
        "url": "https://wiki.python.org/moin/ParallelProcessing",
        "read_more_link": "",
        "language": "en",
        "title": "ParallelProcessing",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://wiki.python.org/wiki/europython/img/python-logo.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Parallel Processing and Multiprocessing in Python\n\nA number of Python-related libraries exist for the programming of solutions either employing multiple CPUs or multicore CPUs in a symmetric multiprocessing (SMP) or shared memory environment, or potentially huge numbers of computers in a cluster or grid environment. This page seeks to provide references to the different libraries and solutions available.\n\nJust In Time Compilation\n\nSome Python libraries allow compiling Python functions at run time, this is called Just In Time (JIT) compilation.\n\nNuitka - As the authors say: Nuitka is a Python compiler written in Python !\n\nYou feed Nuitka your Python app, it does a lot of clever things, and spits out an executable or extension module.\n\nNuitka translates Python into a C program that then is linked against libpython to execute exactly like CPython\n\nFor version 0.6 of Nuitka and Python 2.7 speedup was 312% !\n\nNumba - Numba is an open source JIT compiler that translates a subset of Python and NumPy code into fast machine code.\n\nNumba can use vectorized instructions (SIMD - Single Instruction Multiple Data) like SSE/AVX\n\nNumba can simplify multithreading\n\nNumba can compile on GPU\n\nPythran - Pythran is an ahead of time compiler for a subset of the Python language, with a focus on scientific computing.\n\nIt takes a Python module annotated with a few interface description and turns it into a native Python module with the same interface, but (hopefully) faster.\n\nIt is meant to efficiently compile scientific programs, and takes advantage of multi-cores and SIMD instruction units.\n\nPyston - Pyston is a faster CPython implementation using C optimisation and DynASM Just In Time compiler\n\nAfter having been stopped in 2017 new version is back again since Python 3.8.8\n\nIt says to be 30% faster than CPython by just replacing CPython by Pyston version without updating your code.\n\nCython - Cython is a language which adds C types declaration to Python language\n\nThus, it allows converting Cython code to C code and compile it as a C python library that can be imported as a real python package\n\nCython also helps removing the GIL to parallelize code\n\nSymmetric Multiprocessing\n\nSome libraries, often to preserve some similarity with more familiar concurrency models (such as Python's threading API), employ parallel processing techniques which limit their relevance to SMP-based hardware, mostly due to the usage of process creation functions such as the UNIX fork system call. However, a technique called process migration may permit such libraries to be useful in certain kinds of computational clusters as well, notably single-system image cluster solutions (Kerrighed, OpenSSI, OpenMosix being examples).\n\ndispy - Python module for distributing computations (functions or programs) computation processors (SMP or even distributed over network) for parallel execution. The computations can be scheduled by supplying arguments in SIMD style of parallel processing. The computation units can be shared by multiple processes/users simultaneously if desired. dispy is implemented with asynchronous sockets, coroutines and efficient polling mechanisms for high performance and scalability.\n\ndelegate - fork-based process creation with pickled data sent through pipes\n\nforkmap (original) - fork-based process creation using a function resembling Python's built-in map function (Unix, Mac, Cygwin). (Original version)\n\nforkfun (modified) - fork-based process creation using a function resembling Python's built-in map function (Unix, Mac, Cygwin). (New version from July-2011 with modifications)\n\nJoblib - Joblib is a set of tools to provide lightweight pipelining in Python. In particular:\n\ntransparent disk-caching of functions and lazy re-evaluation (memoize pattern)\n\neasy simple parallel computing (single computer)\n\nppmap - variant of forkmap using pp to manage the subprocesses (Unix, Mac, Cygwin)\n\nPOSH Python Object Sharing is an extension module to Python that allows objects to be placed in shared memory. POSH allows concurrent processes to communicate simply by assigning objects to shared container objects. (POSIX/UNIX/Linux only)\n\npp (Parallel Python) - process-based, job-oriented solution with cluster support (Windows, Linux, Unix, Mac)\n\npprocess (previously parallel/pprocess) - fork-based process creation with asynchronous channel-based communications employing pickled data (tutorial) (currently only POSIX/UNIX/Linux, perhaps Cygwin)\n\nprocessing - process-based using either fork on Unix or the subprocess module on Windows, implementing an API like the standard library's threading API and providing familiar objects such as queues and semaphores. Can use native semaphores, message queues etc or can use of a manager process for sharing objects (Unix and Windows). Included in Python 2.6/3.0 as multiprocessing, and backported under the same name.\n\nPyCSP Communicating Sequential Processes for Python allows easy construction of processes and synchronised communication.\n\nPyMP - OpenMP inspired, fork-based framework for conveniently creating parallel for-loops and sections. Supports Python 2 and 3. (Unix only)\n\nRay - Parallel (and distributed) process-based execution framework which uses a lightweight API based on dynamic task graphs and actors to flexibly express a wide range of applications. Uses shared-memory and zero-copy serialization for efficient data handling within a single machine. Supports low-latency and high-throughput task scheduling. Includes higher-level libraries for machine learning and AI applications. Supports Python 2 and 3. (Linux, Mac)\n\nremoteD - fork-based process creation with a dictionary-based communications paradigm (platform independent, according to PyPI entry)\n\ntorcpy - a platform-agnostic adaptive load balancing library that orchestrates the scheduling of task parallelism on both shared and distributed memory platforms. It takes advantage of MPI and multithreading, supports parallel nested loops and map functions and task stealing at all levels of parallelism.\n\nVecPy (Vectorizing Python for concurrent SIMD execution) - Takes as input a Python function on scalars and outputs a symantically equivalent C++ function over vectors which leverages multi-threading and SIMD vector intrinsics. Generated code is compiled into a native, shared library that can be called from Python (as a module), Java (through JNI), and C++. (Linux-only; requires Python 3, g++)\n\nAdvantages of such approaches include convenient process creation and the ability to share resources. Indeed, the fork system call permits efficient sharing of common read-only data structures on modern UNIX-like operating systems.\n\nCluster Computing\n\nUnlike SMP architectures and especially in contrast to thread-based concurrency, cluster (and grid) architectures offer high scalability due to the relative absence of shared resources, although this can make the programming paradigms seem somewhat alien to uninitiated developers. In this domain, some overlap with other distributed computing technologies may be observed (see DistributedProgramming for more details).\n\nbatchlib - a distributed computation system with automatic selection of processing services (no longer developed)\n\nCelery - a distributed task queue based on distributed message passing\n\nCharm4py - General-purpose parallel/distributed computing framework for the productive development of fast, parallel and scalable applications. Built on top of Charm++, a mature runtime system used in High-performance Computing, capable of scaling applications to supercomputers. It is based on an efficient actor model, allowing many actors per process, asynchronous method invocation, actor migration and load balancing. Seamlessly integrates modern concurrency features into the actor model. Supports Linux, Windows, macOS.\n\nDask - Dask is a flexible library for parallel computing in Python. It offers\n\nDynamic task scheduling optimized for computation. This is similar to Airflow, Luigi, Celery, or Make, but optimized for interactive computational workloads.\n\n“Big Data” collections like parallel arrays, dataframes, and lists that extend common interfaces like NumPy, Pandas, or Python iterators to larger-than-memory or distributed environments. These parallel collections run on top of dynamic task schedulers.\n\nIt extends Numpy/Pandas data structures allowing computing on many cores, many servers and managing data that does not fit in memory\n\nDeap is a evolutionary algorithm library, which contains a parallelization module named DTM, standing for Distributed Task Manager, which allows an easy parallelization over a cluster of computers. This module can be used separately -- e.g. to compute something else than evolutionary algorithms -- and offers an interface similar to the multiprocessing.Pool module (map, apply, synchronous or asynchronous spawns, etc.), providing a complete abstraction of the startup process and the communication and load balancing layers. It currently works over MPI, with mpi4py or PyMPI, or directly over TCP. Its unique structure allows some interesting features, like nested parallel map (a parallel map calling another distributed operation, and so on).\n\ndisco - an implementation of map-reduce. Developed by Nokia. Core written in Erlang, jobs in Python. Inspired by Google's mapreduce and Apache hadoop.\n\ndispy - Python module for distributing computations (functions or programs) along with any dependencies (files, other Python functions, classes, modules) to nodes connected via network. The computations can be scheduled by supplying arguments in SIMD style of parallel processing. The nodes can be shared by multiple processes/users simultaneously if desired. dispy is implemented with asynchronous sockets, coroutines and efficient polling mechanisms for high performance and scalability.\n\nDistributedPython - Very simple Python distributed computing framework, using ssh and the multiprocessing and subprocess modules. At the top level, you generate a list of command lines and simply request they be executed in parallel. Works in Python 2.6 and 3.\n\nexec_proxy - a system for executing arbitrary programs and transferring files (no longer developed)\n\nexecnet - asynchronous execution of client-provided code fragments (formerly py.execnet)\n\nIPython - the IPython shell supports interactive parallel computing across multiple IPython instances\n\njob_stream - An MPI/multiprocessing-based library for easy, distributed pipeline processing, with an emphasis on running scientific simulations. Uses decorators in a way that allows users to organize their code similarly to a traditional, non-distributed application. Can be used to realize map/reduce or more complicated distributed frameworks. Python 3 and 2.7+ compatible.\n\njug - A task based parallel framework\n\nmpi4py - MPI-based solution\n\nNetWorkSpaces appears to be a rebranding and rebinding of Lindaspaces for Python\n\nPaPy - Parallel(uses multiprocessing) and distributed(uses RPyC) work-flow engine, with a distributed imap implementation.\n\npapyros - lightweight master-slave based parallel processing. Clients submit jobs to a master object which is monitored by one or more slave objects that do the real work. Two main implementations are currently provided, one using multiple threads and one multiple processes in one or more hosts through Pyro.\n\npp (Parallel Python) - \"is a python module which provides mechanism for parallel execution of python code on SMP (systems with multiple processors or cores) and clusters (computers connected via network).\"\n\nPyCOMPSs - A task based a programming model which aims to ease the development of parallel applications for distributed infrastructures, such as Clusters and Clouds. Offers a sequential interface, but at execution time the runtime system is able to exploit the inherent parallelism of applications at task level.\n\nPyLinda - distributed computing using tuple spaces\n\npyMPI - MPI-based solution\n\npypar - Numeric Python and MPI-based solution\n\npyPastSet - tuple-based structured distributed shared memory system in Python using the powerful Pyro distributed object framework for the core communication.\n\npypvm - PVM-based solution\n\npynpvm - PVM-based solution for NumPy\n\nPyro PYthon Remote Objects, distributed object system, takes care of network communication between your objects once you split them over different machines on the network\n\nRay - Parallel and distributed process-based execution framework which uses a lightweight API based on dynamic task graphs and actors to flexibly express a wide range of applications. Uses shared-memory and zero-copy serialization for efficient data handling within a single machine. Provides recovery from process and machine failures. Uses a bottom-up hierarchical scheduling scheme to support low-latency and high-throughput task scheduling. Includes higher-level libraries for machine learning and AI applications. Supports Python 2 and 3. (Linux, Mac)\n\nrthread - distributed execution of functions via SSH\n\nScientificPython contains three subpackages for parallel computing:\n\nScientific.DistributedComputing.MasterSlave implements a master-slave model in which a master process requests computational tasks that are executed by an arbitrary number of slave processes. The strong points are ease of use and the possibility to work with a varying number of slave process. It is less suited for the construction of large, modular parallel applications. Ideal for parallel scripting. Uses \"Pyro\". (works wherever Pyro works)\n\nScientific.BSP is an object-oriented implementation of the \"Bulk Synchronous Parallel (BSP)\" model for parallel computing, whose main advantages over message passing are the impossibility of deadlocks and the possibility to evaluate the computational cost of an algorithm as a function of machine parameters. The Python implementation of BSP features parallel data objects, communication of arbitrary Python objects, and a framework for defining distributed data objects implementing parallelized methods. (works on all platforms that have an MPI library or an implementation of BSPlib)\n\nScientific.MPI is an interface to MPI that emphasizes the possibility to combine Python and C code, both using MPI. Contrary to pypar and pyMPI, it does not support the communication of arbitrary Python objects, being instead optimized for Numeric/NumPy arrays. (works on all platforms that have an MPI library)\n\nSCOOP (Scalable COncurrent Operations in Python) is a distributed task module allowing concurrent parallel programming on various environments, from heterogeneous grids to supercomputers. It provides a parallel map function, among others.\n\nseppo - based on Pyro mobile code, providing a parallel map function which evaluates each iteration \"in a different process, possibly in a different computer\".\n\nPySpark - PySpark allow using Spark cluster with Python\n\n\"Star-P for Python is an interactive parallel computing platform ...\"\n\nsuperpy distributes python programs across a cluster of machines or across multiple processors on a single machine. Key features include:\n\nSend tasks to remote servers or to same machine via XML RPC call\n\nGUI to launch, monitor, and kill remote tasks\n\nGUI can automatically launch tasks every day, hour, etc.\n\nWorks on the Microsoft Windows operating system\n\nCan run as a windows service\n\nJobs submitted to windows can run as submitting user or as service user\n\nInputs/outputs are python objects via python pickle\n\nPure python implementation\n\nSupports simple load-balancing to send tasks to best servers\n\ntorcpy - a platform-agnostic adaptive load balancing library that orchestrates the scheduling of task parallelism on both shared and distributed memory platforms. It takes advantage of MPI and multithreading, supports parallel nested loops and map functions and task stealing at all levels of parallelism.\n\nCloud Computing\n\nCloud computing is similar to cluster computing, except the developer's compute resources are owned and managed by a third party, the \"cloud provider\". By not having to purchase and set up hardware, the developer is able to run massively parallel workloads cheaper and easier.\n\nGoogle App Engine - supports Python.\n\nPiCloud - is a cloud-computing platform that integrates into Python. It allows developers to leverage the computing power of Amazon Web Services (AWS) without having to manage, maintain, or configure their own virtual servers. PiCloud integrates into a Python code base via its custom library, cloud. Offloading the execution of a function to PiCloud's auto-scaling cluster (located on AWS) is as simple as passing the desired function into PiCloud's cloud library.\n\nFor example, invoking cloud.call(foo) results in foo() being executed on PiCloud. Invoking cloud.map(foo, range(10)) results in 10 functions, foo(0), foo(1), etc. being executed on PiCloud.\n\nPyCOMPSs - A task based a programming model which aims to ease the development of parallel applications for distributed infrastructures, such as Clusters and Clouds. Offers a sequential interface, but at execution time the runtime system is able to exploit the inherent parallelism of applications at task level.\n\nStarCluster - is a cluster-computing toolkit for the AWS cloud. StarCluster has been designed to simplify the process of building, configuring, and managing clusters of virtual machines on Amazon’s EC2 cloud. It allows you to easily create one or more clusters, add/remove nodes to a running cluster, easily build new AMIs, easily create and format new EBS volumes, write plugins in python to customize cluster configuration, and much more. See StarCluster's documentation for more details.\n\nGrid Computing\n\nRelated Projects\n\nHydra File System - a distributed file system\n\nKosmos Distributed File System - has Python bindings\n\nTahoe: a secure, decentralized, fault-tolerant filesystem\n\nTrove classifiers\n\nTopic :: System :: Distributed Computing\n\nEditorial Notes\n\nThe above lists should be arranged in ascending alphabetical order - please respect this when adding new frameworks or tools."
    }
}