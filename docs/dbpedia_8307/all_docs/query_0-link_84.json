{
    "id": "dbpedia_8307_0",
    "rank": 84,
    "data": {
        "url": "https://learn.microsoft.com/en-us/azure/cosmos-db/mongodb/quickstart-python",
        "read_more_link": "",
        "language": "en",
        "title": "Quickstart - Azure Cosmos DB for MongoDB for Python with MongoDB driver",
        "top_image": "https://learn.microsoft.com/en-us/media/open-graph-image.png",
        "meta_img": "https://learn.microsoft.com/en-us/media/open-graph-image.png",
        "images": [
            "https://learn.microsoft.com/en-us/azure/reusable-content/ce-skilling/azure/media/cosmos-db/yes-icon.svg",
            "https://img.shields.io/static/v1?style=for-the-badge&label=GitHub+Codespaces&message=Open&color=brightgreen&logo=github",
            "https://img.shields.io/static/v1?style=for-the-badge&label=Dev+Containers&message=Open&color=blue&logo=visualstudiocode",
            "https://learn.microsoft.com/en-us/azure/cosmos-db/mongodb/media/quickstart-python/cosmos-python-app.png",
            "https://learn.microsoft.com/en-us/azure/cosmos-db/mongodb/media/quickstart-nodejs/resource-hierarchy.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-08-14T17:44:00+00:00",
        "summary": "",
        "meta_description": "Learn how to build a Python app to manage Azure Cosmos DB for MongoDB account resources in this quickstart.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://learn.microsoft.com/en-us/azure/cosmos-db/mongodb/quickstart-python",
        "text": "APPLIES TO: MongoDB\n\nGet started with MongoDB to create databases, collections, and docs within your Azure Cosmos DB resource. Follow these steps to deploy a minimal solution to your environment using the Azure Developer CLI.\n\nAPI for MongoDB reference documentation | pymongo package | Azure Developer CLI\n\nPrerequisites\n\nSetting up\n\nDeploy this project's development container to your environment. Then, use the Azure Developer CLI (azd) to create an Azure Cosmos DB for MongoDB account and deploy a containerized sample application. The sample application uses the client library to manage, create, read, and query sample data.\n\nOpen a terminal in the root directory of the project.\n\nAuthenticate to the Azure Developer CLI using azd auth login. Follow the steps specified by the tool to authenticate to the CLI using your preferred Azure credentials.\n\nazd auth login\n\nUse azd init to initialize the project.\n\nazd init --template cosmos-db-mongodb-python-quickstart\n\nNote\n\nThis quickstart uses the azure-samples/cosmos-db-mongodb-python-quickstart template GitHub repository. The Azure Developer CLI automatically clones this project to your machine if it is not already there.\n\nDuring initialization, configure a unique environment name.\n\nTip\n\nThe environment name will also be used as the target resource group name. For this quickstart, consider using msdocs-cosmos-db.\n\nDeploy the Azure Cosmos DB account using azd up. The Bicep templates also deploy a sample web application.\n\nazd up\n\nDuring the provisioning process, select your subscription and desired location. Wait for the provisioning process to complete. The process can take approximately five minutes.\n\nOnce the provisioning of your Azure resources is done, a URL to the running web application is included in the output.\n\nDeploying services (azd deploy) (â) Done: Deploying service web - Endpoint: <https://[container-app-sub-domain].azurecontainerapps.io> SUCCESS: Your application was provisioned and deployed to Azure in 5 minutes 0 seconds.\n\nUse the URL in the console to navigate to your web application in the browser. Observe the output of the running app.\n\nInstall the client library\n\nCreate a requirements.txt file in your app directory that lists the PyMongo and python-dotenv packages.\n\n# requirements.txt pymongo python-dotenv\n\nCreate a virtual environment and install the packages.\n\nWindows\n\nLinux/macOS\n\n# py -3 uses the global python interpreter. You can also use python3 -m venv .venv. py -3 -m venv .venv source .venv/Scripts/activate pip install -r requirements.txt\n\npython3 -m venv .venv source .venv/bin/activate pip install -r requirements.txt\n\nObject model\n\nLet's look at the hierarchy of resources in the API for MongoDB and the object model that's used to create and access these resources. The Azure Cosmos DB creates resources in a hierarchy that consists of accounts, databases, collections, and documents.\n\nHierarchical diagram showing an Azure Cosmos DB account at the top. The account has two child database shards. One of the database shards includes two child collection shards. The other database shard includes a single child collection shard. That single collection shard has three child doc shards.\n\nEach type of resource is represented by a Python class. Here are the most common classes:\n\nMongoClient - The first step when working with PyMongo is to create a MongoClient to connect to Azure Cosmos DB's API for MongoDB. The client object is used to configure and execute requests against the service.\n\nDatabase - Azure Cosmos DB's API for MongoDB can support one or more independent databases.\n\nCollection - A database can contain one or more collections. A collection is a group of documents stored in MongoDB, and can be thought of as roughly the equivalent of a table in a relational database.\n\nDocument - A document is a set of key-value pairs. Documents have dynamic schema. Dynamic schema means that documents in the same collection don't need to have the same set of fields or structure. And common fields in a collection's documents may hold different types of data.\n\nTo learn more about the hierarchy of entities, see the Azure Cosmos DB resource model article.\n\nCode examples\n\nAuthenticate the client\n\nGet database\n\nGet collection\n\nCreate an index\n\nCreate a document\n\nGet an document\n\nQuery documents\n\nThe sample code described in this article creates a database named adventureworks with a collection named products. The products collection is designed to contain product details such as name, category, quantity, and a sale indicator. Each product also contains a unique identifier. The complete sample code is at https://github.com/Azure-Samples/azure-cosmos-db-mongodb-python-getting-started/tree/main/001-quickstart/.\n\nFor the steps below, the database won't use sharding and shows a synchronous application using the PyMongo driver. For asynchronous applications, use the Motor driver.\n\nAuthenticate the client\n\nIn the project directory, create an run.py file. In your editor, add require statements to reference packages you'll use, including the PyMongo and python-dotenv packages.\n\nimport os import sys from random import randint import pymongo from dotenv import load_dotenv\n\nGet the connection information from the environment variable defined in an .env file.\n\nload_dotenv() CONNECTION_STRING = os.environ.get(\"COSMOS_CONNECTION_STRING\")\n\nDefine constants you'll use in the code.\n\nDB_NAME = \"adventureworks\" COLLECTION_NAME = \"products\"\n\nConnect to Azure Cosmos DB's API for MongoDB\n\nUse the MongoClient object to connect to your Azure Cosmos DB for MongoDB resource. The connect method returns a reference to the database.\n\nclient = pymongo.MongoClient(CONNECTION_STRING)\n\nGet database\n\nCheck if the database exists with list_database_names method. If the database doesn't exist, use the create database extension command to create it with a specified provisioned throughput.\n\n# Create database if it doesn't exist db = client[DB_NAME] if DB_NAME not in client.list_database_names(): # Create a database with 400 RU throughput that can be shared across # the DB's collections db.command({\"customAction\": \"CreateDatabase\", \"offerThroughput\": 400}) print(\"Created db '{}' with shared throughput.\\n\".format(DB_NAME)) else: print(\"Using database: '{}'.\\n\".format(DB_NAME))\n\nGet collection\n\nCheck if the collection exists with the list_collection_names method. If the collection doesn't exist, use the create collection extension command to create it.\n\n# Create collection if it doesn't exist collection = db[COLLECTION_NAME] if COLLECTION_NAME not in db.list_collection_names(): # Creates a unsharded collection that uses the DBs shared throughput db.command( {\"customAction\": \"CreateCollection\", \"collection\": COLLECTION_NAME} ) print(\"Created collection '{}'.\\n\".format(COLLECTION_NAME)) else: print(\"Using collection: '{}'.\\n\".format(COLLECTION_NAME))\n\nCreate an index\n\nCreate an index using the update collection extension command. You can also set the index in the create collection extension command. Set the index to name property in this example so that you can later sort with the cursor class sort method on product name.\n\nindexes = [ {\"key\": {\"_id\": 1}, \"name\": \"_id_1\"}, {\"key\": {\"name\": 2}, \"name\": \"_id_2\"}, ] db.command( { \"customAction\": \"UpdateCollection\", \"collection\": COLLECTION_NAME, \"indexes\": indexes, } ) print(\"Indexes are: {}\\n\".format(sorted(collection.index_information())))\n\nCreate a document\n\nCreate a document with the product properties for the adventureworks database:\n\nA category property. This property can be used as the logical partition key.\n\nA name property.\n\nAn inventory quantity property.\n\nA sale property, indicating whether the product is on sale.\n\n\"\"\"Create new document and upsert (create or replace) to collection\"\"\" product = { \"category\": \"gear-surf-surfboards\", \"name\": \"Yamba Surfboard-{}\".format(randint(50, 5000)), \"quantity\": 1, \"sale\": False, } result = collection.update_one( {\"name\": product[\"name\"]}, {\"$set\": product}, upsert=True ) print(\"Upserted document with _id {}\\n\".format(result.upserted_id))\n\nCreate a document in the collection by calling the collection level operation update_one. In this example, you'll upsert instead of create a new document. Upsert isn't necessary in this example because the product name is random. However, it's a good practice to upsert in case you run the code more than once and the product name is the same.\n\nThe result of the update_one operation contains the _id field value that you can use in subsequent operations. The _id property was created automatically.\n\nGet a document\n\nUse the find_one method to get a document.\n\ndoc = collection.find_one({\"_id\": result.upserted_id}) print(\"Found a document with _id {}: {}\\n\".format(result.upserted_id, doc))\n\nIn Azure Cosmos DB, you can perform a less-expensive point read operation by using both the unique identifier (_id) and a partition key.\n\nQuery documents\n\nAfter you insert a doc, you can run a query to get all docs that match a specific filter. This example finds all docs that match a specific category: gear-surf-surfboards. Once the query is defined, call Collection.find to get a Cursor result, and then use sort.\n\n\"\"\"Query for documents in the collection\"\"\" print(\"Products with category 'gear-surf-surfboards':\\n\") allProductsQuery = {\"category\": \"gear-surf-surfboards\"} for doc in collection.find(allProductsQuery).sort( \"name\", pymongo.ASCENDING ): print(\"Found a product with _id {}: {}\\n\".format(doc[\"_id\"], doc))\n\nTroubleshooting:\n\nIf you get an error such as The index path corresponding to the specified order-by item is excluded., make sure you created the index.\n\nRun the code\n\nThis app creates an API for MongoDB database and collection and creates a document and then reads the exact same document back. Finally, the example issues a query that returns documents that match a specified product category. With each step, the example outputs information to the console about the steps it has performed.\n\nTo run the app, use a terminal to navigate to the application directory and run the application.\n\npython run.py\n\nThe output of the app should be similar to this example:\n\nCreated db 'adventureworks' with shared throughput. Created collection 'products'. Indexes are: ['_id_', 'name_1'] Upserted document with _id <ID> Found a document with _id <ID>: {'_id': <ID>, 'category': 'gear-surf-surfboards', 'name': 'Yamba Surfboard-50', 'quantity': 1, 'sale': False} Products with category 'gear-surf-surfboards': Found a product with _id <ID>: {'_id': ObjectId('<ID>'), 'name': 'Yamba Surfboard-386', 'category': 'gear-surf-surfboards', 'quantity': 1, 'sale': False}\n\nClean up resources\n\nWhen you no longer need the Azure Cosmos DB for NoSQL account, you can delete the corresponding resource group."
    }
}