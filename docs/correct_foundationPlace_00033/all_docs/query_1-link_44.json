{
    "id": "correct_foundationPlace_00033_1",
    "rank": 44,
    "data": {
        "url": "https://help.marklogic.com/Knowledgebase/Article/View/marklogic-search-faq",
        "read_more_link": "",
        "language": "en",
        "title": "MarkLogic Search FAQ",
        "top_image": "https://www.progress.com/images/default-source/default-album/progress-album/images-album/social-image.png",
        "meta_img": "https://www.progress.com/images/default-source/default-album/progress-album/images-album/social-image.png",
        "images": [
            "https://help.marklogic.com/__swift/themes/client/images/ml-loader.gif",
            "https://help.marklogic.com/__swift/themes/client/images/icon_star_5.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "Progress.com",
        "canonical_link": "https://www.progress.com/resources",
        "text": "Question\n\nAnswer\n\nFurther Reading\n\nWhat is MarkLogic's Built-In search feature?\n\nMarkLogic is a database with a built-in search engine, providing a single platform to load data from different silos and search/query across all of that data\n\nIt uses an \"Ask Anything\" Universal Index where data is indexed as soon as it is loaded - so you can immediately begin asking questions of your data\n\nYou want built-in search in your database because it:\n\nRemoves the need for a bolt-on search engine for full-text searches, unlike other databases\n\nEnables you to immediately search/discover any new data loaded into MarkLogic, while also keeping track of your data as you harmonize it\n\nCan be leveraged when building apps (both transactional and analytical) that require powerful queries to be run efficiently, as well as when you want to build Google-like search features into your application\n\nDocumentation:\n\nBuilt-in search\n\nSearch All Your Data With an \"Ask Anything\" Universal Index\n\n\"Ask Anything\" Universal Index\n\nWhat features are available with MarkLogic search?\n\nMarkLogic includes rich full-text search features. All of the search features are implemented as extension functions available in XQuery, and most of them are also available through the REST and Java interfaces. This section provides a brief overview some of the main search features in MarkLogic and includes the following parts:\n\nHigh Performance Full Text Search\n\nSearch APIs\n\nSupport for Multiple Query Styles\n\nFull XPath Search Support in XQuery\n\nLexicon and Range Index-Based APIs\n\nAlerting API and Built-Ins\n\nSemantic Searches\n\nTemplate Driven Extraction (TDE)\n\nWhere to Find Additional Search Information\n\nDocumentation:\n\nSearching in MarkLogic Server\n\nDeveloping Search Applications in MarkLogic Server\n\nSearch Customization using Query Options\n\nKB Article:\n\nSemantics, SQL, TDE, and Optic Primer\n\nWhat are the various search APIs provided by MarkLogic?\n\nMarkLogic provides search features through a set of layered APIs.\n\nThe built-in, core, full-text search foundations are the XQuery cts:* and JavaScript cts.* APIs\n\nThe XQuery search:*, JavaScript jsearch.*, and REST APIs above this foundation provide a higher level of abstraction that enable rapid development of search applications.\n\nE.g.: The XQuery search:* API is built using cts:* features such as cts:search, cts:word-query, and cts:element-value-query.\n\nOn top of the REST API are the Java and Node.js Client APIs that enable users familiar with those interfaces access to the MarkLogic search features\n\nThis diagram illustrates the layering of the Java, Node.js, REST, XQuery (search and cts), and JavaScript APIs.\n\nDocumentation:\n\nSearch APIs\n\nWhat happens if you decide to change your index settings after loading content?\n\nThe index settings are designed to apply to an entire database and MarkLogic Server indexes records (or documents/fragments) on ingestion based on these settings. If you change any index settings on a database in which documents are already loaded:\n\nIf the “reindexer” setting on the database is enabled, reindexing happens automatically\n\nOtherwise, one should force reindex through the “reindex” option on the database “configure” page or by reloading the data\n\nSince the reindexer operation is resource intensive, on a production cluster, consider scheduling the reindex during a time when your cluster is less busy.\n\nAdditionally, as reindexing is resource intensive, you’ll be best served to test any index changes on subsets of your data (as reindexing subsets will be faster and use fewer resources), then only promote those index changes to your full dataset once you’re sure those index settings are the ones you’ll want going forward\n\nDocumentation:\n\nText indexes\n\nKB Article:\n\nIndexing best practices\n\nWhat is the role of language baseline setting? What are the differences between legacy and ML9 settings?\n\nThe language baseline configuration is for tokenization and stemming language support. The legacy language baseline setting is specified to allow MarkLogic to continue to use the older (MarkLogic 8 and prior versions) stemming and tokenization language support, whereas the ML9 setting would specify that the newer MarkLogic libraries (introduced in MarkLogic 9) are used.\n\nIf you upgrade to MarkLogic 9 or later from an earlier version of MarkLogic, your installation will continue to use the legacy stemming and tokenization libraries as the language baseline.\n\nAny fresh installation of MarkLogic will use the new libraries. If necessary, you can change the baseline configuration using admin:cluster-set-language-baseline.\n\nNote: In most cases, stemming and tokenization will be more precise in MarkLogic 9 and later.\n\nDocumentation:\n\nKnown incompatibilities with previous releases\n\nWhat is the difference between unfiltered vs filtered searches?\n\nIn a typical search:\n\nMarkLogic Server will first do index resolution from the D-Nodes - which results in unfiltered search results. Note that unfiltered index resolution is fast but may include false-positive results\n\nAs a second step, the Server will then do filtering of those unfiltered search results on the E-Nodes to remove false positives from the above result set - which results in filtered search results. In contrast to unfiltered searches, filtered searches are slower but more accurate\n\nWhile searches are filtered by default, it is often also possible to explicitly perform a search unfiltered. In general, if search speed, scale, and accuracy are priorities for your application, you’ll want to pay attention to your schemas and data models so unfiltered searches return accurate results without the need for the slower filtering step\n\nDocumentation:\n\ncts:search\n\nFast Pagination and Unfiltered Searches\n\nKB Articles:\n\nFast searches: resolving from the indexes vs. filtering\n\nWhen should I look into query or data model tuning?\n\nIs filtering during a search bad?\n\nFiltering isn’t necessarily bad but:\n\nIt is still an extra step of processing and therefore not performant at scale\n\nA bad data model often makes things even worse because they’ll typically require unnecessary retrieval of large amounts of unneeded information during index resolution - all of which then will be filtered on the e-nodes\n\nTo avoid performance issues with respect to filtering, try:\n\nAdding additional indexes\n\nImproving your data model to more easily index/search without filtering\n\nStructuring documents and configuring indexes to maximize both query accuracy and speed through unfiltered index resolution alone\n\nDocumentation:\n\ncts:search\n\nFast Pagination and Unfiltered Searches\n\nKB Articles:\n\nFast searches: resolving from the indexes vs. filtering\n\nWhen should I look into query or data model tuning?\n\nWhat is the difference between cts.search vs jsearch?\n\ncts.search() runs filtered by default.\n\nJSearch runs unfiltered by default.\n\nJSearch can enable filtering by chaining the filter() method when building the query: http://docs.marklogic.com/DocumentsSearch.filter\n\nNote: Filtering is not performant at scale, so the better approach is to tune your data model and indexes such that filtering is not necessary.\n\nDocumentation:\n\ncts:search\n\nCreating JavaScript search applications\n\nHow do data models affect Search?\n\nSome data model designs pull lots of unnecessary data from the indexes with every query. That means your application will:\n\nNeed to do a lot of filtering on the e-nodes\n\nUse more CPU cycles on the e-node to do that filtering\n\nEven with filtering disabled, you’re still be pulling lots of position information from the indexes - which means you’ll be using lots of CPU on the e-nodes to evaluate which positions are correct (and unlike filtering, position processing can’t be toggled on/off)\n\nRetrieving more data means an increased likelihood of CACHEFULL errors\n\nHow you represent your data heavily informs the speed, accuracy, and ease of construction of your queries. If your application needs to perform and/or scale, its data model is the first and most important thing on which to focus\n\nDocumentation:\n\nData Modeling Tutorial\n\nKB Articles:\n\nWhen should i look into query or data-model tuning?\n\nPerformance Issues in MarkLogic Server: what they look like - and what you should do about them\n\nHow do I optimize my application’s queries?\n\nThere are several things to consider when looking at query performance:\n\nHow fast does performance need to be for your application?\n\nWhat indexes are defined for the database?\n\nIs your code written in the most efficient way possible?\n\nCan range indexes and lexicons speed up your queries?\n\nAre your server parameters set appropriately for your system?\n\nIs your system sufficiently large for your needs?\n\nAccess patterns and resource requirements differ for analytic workloads\n\nHere is a checklist for optimizing query performance:\n\nIs your query running in “Accidental” update mode?\n\nAre you running cts:search unfiltered?\n\nProfile your code\n\nUse indexes when appropriate\n\nOptimize cts:search using indexes\n\nTuning queries with query-meters and query-trace\n\nDocumentation:\n\nQuery Performance and Tuning Guide\n\nTuning Queries with query-meters and query-trace\n\nBlog:\n\nA checklist for optimizing Query Performance\n\nKB Article:\n\nPerformance Issues in MarkLogic Server: what they look like - and what you should do about them\n\nHow to ensure wildcard searches are fast?\n\nThe following database settings can affect the performance and accuracy of wildcard searches:\n\nword lexicons\n\nelement, element attribute, and field word lexicons. (Use an element word lexicon for a JSON property).\n\nthree character searches, two character searches, or one character searches. You do not need one or two character searches if three character searches is enabled.\n\nthree character word positions\n\ntrailing wildcard searches, trailing wildcard word positions, fast element trailing wildcard searches\n\nfast element character searches\n\nThe three character searches index combined with the word lexicon provides the best performance for most queries, and the fast element character searches index is useful when you submit element queries. One and two character searches indexes are only used if you submit wildcard searches that try to match only one or two characters and you do not have the combination of a word lexicon and the three character searches index. Because one and two character searches generally return a large number of matches and result in much larger index storage footprints, they usually are not worth subsequent disk space and load time trade-offs for most applications\n\nLastly, consider using query plans to help optimize your queries. You can learn more about query optimization by consulting our Query Performance and Tuning Guide\n\nDocumentation:\n\nRecommended Wildcard Index Settings\n\nUnderstanding the Wildcard Indexes\n\nUnderstanding and using Wildcard Searches\n\nBlog:\n\nThe Secrets to Wildcard Search in MarkLogic\n\nWhat are the factors that affect relevance score calculations?\n\nThe score is a number that is calculated based on\n\nStatistical information, including the number of documents in a database\n\nThe frequency in which the search terms appear in the database\n\nThe frequency in which the search term appears in the document\n\nThe relevance of a returned search item is determined based on its score compared with other scores in the result set, where items with higher scores are deemed to be more relevant to the search.\n\nBy default, search results are returned in relevance order, so changing the scores can change the order in which search results are returned.\n\nDocumentation:\n\nUnderstanding How Scores and Relevance are Calculated\n\nKB Article:\n\nUnderstanding Term Frequency rules for relevance calculations\n\nHow do I restrict my searches to only parts of my documents (or exclude parts of my documents from searches altogether)?\n\nMarkLogic Server has multiple ways to include/exclude parts of documents from searches.\n\nAt the highest level you can apply these restrictions globally by including/excluding elements in word queries. Alternative (and preferably), you can also define specific fields, which are a mechanism designed to restrict searches to specifically targeted elements within your document\n\nKB Article:\n\nBest practices when trying to search (or not search) parts of documents\n\nHow do I specify that the match must be restricted to the top level attributes of my JSON document?\n\nYou can configure fields in the database settings that are used with the cts:field-word-query, cts:field-words, and cts:field-word-match APIs, as well as with the field lexicon APIs in order to fetch the desired results.\n\nYou can create a field for each top-level JSON property you want to match with indexes. In the field specification you should use a path expression /property-name for the top-level property \"property-name\". Then use field queries to match the top level property.\n\nDepending on your use-case, this could be an expensive operation due to the indexes involved resulting in slower document loads and larger database files.\n\nDocumentation:\n\nFields Database Settings"
    }
}