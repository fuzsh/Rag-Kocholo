{
    "id": "correct_foundationPlace_00033_1",
    "rank": 39,
    "data": {
        "url": "https://cleverllamas.com/articles/reviews/optic/geospatial/",
        "read_more_link": "",
        "language": "en",
        "title": "Optic Geospatial",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://cleverllamas.com/images/llama.svg",
            "https://cleverllamas.com/assets/llamaverse-8d83fb32.png",
            "https://cleverllamas.com/assets/multiple-documents-8ed317d8.png",
            "https://cleverllamas.com/assets/projected-pastures-d992eeb3.png",
            "https://cleverllamas.com/assets/who-is-where-40bec2ae.png",
            "https://cleverllamas.com/assets/who-is-where-full-2e94b476.png",
            "https://cleverllamas.com/assets/who-is-naughty-table-9a282874.png",
            "https://cleverllamas.com/assets/who-is-naughty-74718ade.png",
            "https://cleverllamas.com/assets/who-mixes-ec415488.png",
            "https://cleverllamas.com/assets/who-moved-6268f066.png",
            "https://cleverllamas.com/assets/which-way-did-they-go-471496eb.png",
            "https://cleverllamas.com/images/llamas.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "We Master MarkLogic",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Geospatial features in MarkLogic are not new. They have been around since the start of MarkLogic 9.0. However, they have been limited to the MarkLogic CTS related APIs. With the release of MarkLogic 11, the Optic API now supports geospatial features. This article will explore the use of the Optic API for geospatial features.\n\n# What did MarkLogic have for Geospatial features prior to MarkLogic 11?\n\nThe geospatial implementation started like some other new features - a new index type and appropriate tooling to support it. The geospatial index supports many types of spatial features such as complex polygons, points, lines, and circles. In MarkLogic prior to 11, like all indexes, they are scoped to a fragment. For most use-cases, this translates to a document. You could easily add many geospatial features into a single document. These will index fine and are searchable using various geospatial related search functions. However, to find out \"which\" feature in your document matched requires post-processing (filtering) in some manner or other. This also leads to double-querying (post-process to then re-match the correct version). This really limited the use-cases in which one might want or need more than one geospatial feature in a single document.\n\nIn Summary - Document Oriented:\n\nMultiple geospatial artifacts allowed and indexed\n\nBut âWhich one matchedâ takes work:\n\nSearchable expression(filtered) - or walk the document yourself looking for the right one\n\nFragment root/parent\n\n# What's the difference in MarkLogic 11?\n\nInstead of Document Oriented, TDE Driven\n\nAs many records as possible from a fragment of a single document\n\nIndexed and aware of self - but also fragment(document)\n\nTo start off, all the power of MarkLogic is still there. You can still index many geospatial features in a single document. However, in normal MarkLogic practice, this foundation has been extended. When we dove into the details of the release, the feeling was that the title \"Optic Geospatial\" was a bit reserved in describing the power of the release. The update actually has multiple hidden gems:\n\nThe heart of the release is the first bullet point extract geospatial features embedded into a document as a row. This means that you can now query for a feature and get single results per feature.\n\nIndexes available via TDE (rows, triples)\n\n(point , box , circle , linestring , polygon , complexPolygon , and a generic region)\n\nGEO library available via Optic API (just like others such as ofn, oxdmp, oxs etc)\n\nSQL and SPARQL also support geospatial features extracted from the TDE templates\n\nTo further prove the point of how versatile the release is, the samples later on are mixed between SQL and Optic.\n\n# Exploring the Optic API Geospatial Features\n\n# Llamaverse\n\nWith much of our testing, we try to stick with a single, familiar set of data. We then just extend the dataset as needed. For this purpose, I am using the Llamaverse geospatial data. This is familiar to those who have read the articles on GraphQL. Those examples answered questions based on relationships. We'll answer questions based on geospatial data.\n\nPrior to MarkLogic 11, we would need to store every feature in a separate document if we wanted to be able to query for each feature individually without the overhead of post-processing.\n\n# TDE Template to project features into their own rows.\n\n# Alter the content to match some TDE requirements.\n\nOne interesting item points out a limitation of the TDE template grammar and features. Although you can do some complex work in creating your values in the configuration of a TDE row or triple, you cannot import modules to assist you. Furthermore, MarkLogic does not import any libraries as part of this process. The documentation is, however, very clear on what you can do and what functions are available. What this means, is that we cannot, for example, make use of the geospatial toolbox. With the rapid growth of features and fixes around the OpticAPI, I am sure that this will be addressed in the future.\n\nWe represent the geospatial data as geojson. However, the underlying geospatial indexes do not readily understand this yet.\n\nThe TDE engine expects cts features (such as a polygon represented as a list of cts: points or in the format of WKT (Well Known Text)). Therefore, we need to convert our coordinates into a format that is accepted. This is not necessarily impossible to do at runtime - a splits and joins and replaces. However that is a bit messy and difficult to maintain. Instead, I chose to use the tools made for that purpose and add a new version of the polygons by using a transform on ingest.\n\nThe new element added is called ctsPoly2 and is just another property for each polygon. You will see that referenced in one of the TDE templates.\n\n# Pastures TDE Template\n\nWe can now query the pastures directly since they have been projected into their own rows.\n\n# Llamas TDE Template\n\nLlamas may not be the most sprightly of creatures, but they are still able to move around. We can use the same technique to project the llamas into their own rows. For this, we will assume that there is a report of all llamas and their location at a given time. This is a common use-case for geospatial data. We can then use the Optic API to query for llamas in a given area at a given time.\n\n# Reporting the whereabouts of the llamas\n\n# Who is where at 10 o'clock?\n\nTo answer this question, we can use the SQL interface to the database. This is a very simple query that uses the geospatial functions to find all the llamas and their location at 10:00 o'clock. Two queries are included . They are slightly different.\n\n# Full Report of Locations\n\nOf course, we may just want a report of all llamas and where they were at any time. If you look closely, you will notice one llama that is not in a pasture. We'll come back to that later.\n\n# SQL - Who's a naughty llama at 11 o' clock?\n\nSomeone reported a rogue llama this morning. Our report at 11 o'clock shows a llama that has switched location. We can simply find the llama that was not in a pasture at that time.\n\n# Hmm... It was Winnie..\n\n# Optic - Who's a naughty llama at 12 o' clock?\n\nFor this example. We decided to be a bit more fluid in the way we expressed the optic query. We define the plans as we need them, use op.col and op.view-col as appropriate. Furthermore, we chose to express this result in a notExistsJoin. There are other ways in which this could have been expressed. However, this is a good example of how flexible the Optic API is.\n\n# Hmm... It was Adam..\n\n# Mix in Optic Power with GeoSpatial Power\n\nSo far, we have just done a few samples. To push things a bit further, we thought of a few more interesting questions that we could answer.\n\n# Who mixes with Whom?\n\nAs a quick analysis of which Llamas may have been in contact with each other, we can do a simple exercise. For this, We chose to do a bounding box based on all the locations sampled per llama and see where those bounding boxes overlap. This is a very simple way of doing this. In a more complete example, one would have to extend the query for more than overlap (covers, is covered by, touches, etc). In addition, a bounding box is a bit generous in size. Taking time to draw a polygon from the points or perhaps overlapping circles from each point could be more precise. But for this example we will stick with the bounding box. We rely heavily on grouping aggregates to prepare our data for us.\n\n# Who moved the most\n\nAs with the above example, there are other ways that one might choose to do this. As a quick example, our choice was just to find the distances between all points for each llama and find the max distance.\n\n# Which way did they go?\n\nWe already know that Winnie and Adam both left the reservation (literally). It also looks like the sneaky little llamas removed their trackers. Still, we should be able to figure out which way they were heading before they left. It is technically possible for me to have gotten the answer in a different way - grouping and using op.arrayAggregate to list the points as I did in other samples and then from there taken the first two using op.call() to access fn.subsequence() to grab the last two entries. However, I did this exercise to also push the work to the D-nodes as much as possible.\n\n# Conclusion\n\nOverall, the flexibility of using the MarkLogic Geospatial features against individual projected rows or sets of triples appears to be amazingly valuable and useful. It does what it claims to do - expose the already rich geospatial feature via SQL,SPARQL and OPTIC by way of hooking into existing items and adding new geospatial datatypes to the TDE template library. However, there are a few items to keep in mind as listed below.\n\n# TDE Template Limitations\n\nAs mentioned above, TDE template engine, by design, is limited by what tooling is used to process. This makes sense since template extraction at insert/runtime has a direct effect on processing time. In addition, there is no way to hook into other libraries. That means even though there may be a library available in MarkLogic that can help prepare your data to be in the format needed for indexing as a geospatial feature, it may be unreachable at index time. This leaves you with having to transform the data as a step before inserting. This is not new. However, we found that it became more apparent when we were trying to use the geospatial features. For many situations, this may never be encountered, depending on the source data used.\n\n# Performance\n\nIt is never appropriate to mention performance in these types of tests. They are done on small instances and in some cases, using preview versions of code that may have extra tracing etc. However, it is important to remember: MarkLogic is a distributed database. Items projected into rows are indexed in the same forest as the document. MarkLogic balances documents across forests and nodes. Therefore, (unless you have implemented some forest rules to keep things together), your rows are across the nodes. As much as possible, work is done on the D-Nodes (resolve, filter, sort). If you write queries (SQL, Sparql, Optic) etc. and have a constant on one side of the equation (where schema-a.col.foo = 12), then life is good. However, items like where schema-a.col.foo = schema-b.col.bar then there is an inevitable situation in which data has to be transmitted across nodes to resolve the filtering and joining and self-joins.\n\nThe above is not new. However, when writing queries, it is important to keep this in mind. Some of the ways that things were written above include essentially table aliases and left and right values from indexes that are no longer simple values (RegionA Overlaps Region B).\n\nThe samples above are used to articulate concepts only. Many of these samples go against the grain of what is recommended for performance(actually doing many of the items mentioned above). However, they are used to show the flexibility of the Optic API and the power of the Geospatial features. Breaking them into questions where you have a constant as part of a query would help - example: (1) Who is off the reservation right now(Wendy)? and (2) from that constant (Wendy), what are her last two known positions.\n\n# State of mind\n\nSometimes when writing queries like the above, they just flow out and work. Then I step back and look at what was written and wonder how I did that. I find Optic API to be a very powerful tool. When mixing Geospatial queries into it as well, it's important to be in the right frame of mind when deciding how to join, and most importantly, when and how to filter and group to get the results in an efficient manner.\n\nThis is fun and powerful. Overall, a pleasure to test."
    }
}