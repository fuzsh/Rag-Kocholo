{
    "id": "wrong_mix_range_leader_00036_2",
    "rank": 62,
    "data": {
        "url": "https://pyfound.blogspot.com/2023/05/",
        "read_more_link": "",
        "language": "en",
        "title": "Python Software Foundation News",
        "top_image": "https://s3.dualstack.us-east-2.amazonaws.com/pythondotorg-assets/media/psf/grants/report-2006-10/psf-logo.png",
        "meta_img": "https://s3.dualstack.us-east-2.amazonaws.com/pythondotorg-assets/media/psf/grants/report-2006-10/psf-logo.png",
        "images": [
            "https://3.bp.blogspot.com/-nWqAgbDyLhA/Vrl1s7DIFLI/AAAAAAAAOo8/_hGVqcEcFqY/s1600-r/psf-logo.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi4ACb3kr0fWAbdjl0tzHpGzioUYGYX9wrXnK915nFqYIKZPU_-DRDuiT1RVqY9FUs4-C4mwMeEnoKWP284KUtqm2Y7O4MJTSrUIHEeptUZl4U_dB4Q6Q3j_7mWveS-ksCQTD662HbZW3tInYRVrKia0qFxl6VC-TDg3pIrv3qcv6totiI/s320/image_2023-05-27_222414441.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEghK9GiEpyTkxBrAoaC_bG_5ophtqVcxtc-70dyCa5Y2g35CoVdQiPjiTc2lr4x4UeRq6bJW-TwhfT0kDykcpTS3GZubW9BwrnqoWxnTHe5L5Vih6H-NsAkq_OrmCiWQyWTwG7u_2rQIH6mIsIHcRAtS2KHIyIrvofK1TIpIrSR-iJrOCw/s320/Nanjekye%20slide%20screenshot.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhW9jyCByps_8fSzctINDv6FRBbC8f-H_wz7eVrD_4aEGCy-hm0H1umibAftp2nXc4KYVrbABUvnLDLEQPmOi5necf69ruuyHTjABgJOyBZ64eO3lBsmHJ4S9ogosVzKVzvGloPjQMVXFWjB6fnD3djhfqsuKTBDxbiuRf4bMf-yDjpYHs/s320/image_2023-05-27_220847107.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhz0cEgI5ArFR9lfrczf74Z1y3C536LXYM7iW8WJKi3G_A_Usgp-Bhl8tbOqL7lCkZgpa4Nod76W7FRbSAZ6jwekyynJXd7CDYTSnoilbuGTvRpgvjkYpAMuTBCUwQYeFMpOKsRafkrus1HHzPUC6RFtS0Zu0okF4UVZyeJj_NnQD1C4ck/s320/Sam%20Gross%20picture.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjH_0AUlHvdFlA1D5qHlngSRaT8smzG9Su1UAdEMgz1reCrG_-ESm8WYB-zVK8j7LHT-qqxlWavJRBY7YJilLayk-EFAVAZDUp55w5q_IZ0wndNeuB_3Ibxar87rKePkdA9q8sCaAR0X3SOf7qa8WuSJOSE8yN6X2aUyqCIMmNjgN6uPqg/s320/DALL%C2%B7E%202023-05-18%2016.24.34%20-%20A%20Van%20Gogh%20painting%20of%20a%20man%20doing%20computer%20programming%20on%20a%20dinghy%20in%20the%20middle%20of%20a%20storm%20at%20sea,%20sunlight%20dramatically%20piercing%20through%20the%20clouds.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiO-1oRlIU4n4U5yQPoikvJjW6AHx9ke2CQxHtAPTlekE-bdXMCstMR2jRCaU74nO9ndcVJunKVHdC5NtLiTEFO0cjWDPpZWBe_rfMMtVEGNL5OWUImK-QZMZuW-OxBAi274wv_CbCZU6peUlUBVKErDJo-z5yBd0nS9tVcKFnpkNxJRwQ/s320/image_2023-05-27_221430833.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgPyFD0leE8UsskX9WuC7J1LZA2470XLK2seL82YQrGQJnqix-bdWFgei-_q02a2k-NCoccvTWV9E7oWg8LEEJvfiNIiZ71P3YorGvuefXGY4YsvEvMybNEA0RyoeyUYWF_NfIon8DQ3J_A_UM5epaSEaFg6BQoeNiR9XFMp-J_EK5Vkzk/s320/Cuni%20slide%20screenshot.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg5SAdpZyRNSY-AqgNxZ6KGXs030pc2EiBkPt7c34tZPisLgt72Ps36i6GfdL9kql4bou9lEFpfqBBRAEMc8CIACo78Mr1wlHwVinPsuU3SNxXlQcsI72m4Yxwk_YrCbU1aEVATPvPAH_ZM4-_ylFfsuvOLqm4bKL0V_yAGJTNlB9C2MJE/s320/image_2023-05-27_221734482.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg0jGMJJRJ-p-vUDoVQIKuEoMM61NmDLbLXDQALevgnSOaiGfI728qgxcuHau8OxqciLoVxuMJslnd7vuizRHWau4prrClJn3XyKkgPaftHrSFdK-FE2QOgiE8wshlhIoxp3l4FuqbP-tp0t3vcbWUD4gwVBnlEOmiGEkCgQ8XAslBHcdg/s320/image_2023-05-18_145653379.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/a/AVvXsEhKd0EQEStk2AWmSAjsGgsESDcswdm1vnDv77ZrTgwbJdOD6Om0nyFfH6gxIT1fvBo6Tt9bykJuS1pIkPD1qNFnLiINcLdtiebwaDA4CvfOCyNkoq5nRNKZ9K0_7FPWhsYhLJXGxbv7BCL2XEMHZNQxfl61szs8q0yAX56kyk_PKSXXG4A",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjMf7wl_3NSqzHPBtLs31nHWssIZ1rIY3Wd5AmZKsrmQJnxvn0AQT0yF-cbuP6oldqPjC3L75USN9wYhENRXMmLoPgfEvVx6bUiu7RMNHpkWeexNYmKKRIetyQkdAFlloeZt1KAS9tP9OCu4F9QXY7mF2L11TasEGT2MTrKODgJRDqqkj8/s320/image_2023-05-27_221125338.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhX0X3Sj-KVFyXteYb66VcF4DxKMmhlqV8vVWfpThq6bbC0YOz3mUPA-j_64U6v8GKN10JYLZ0LNBuOJMOv11D2zokJHdPxbfkoL1Etvn0OUdk1MLsv1TZydBMSNVVic8plYV6MvDjo_hMTGbxSZTph8uWkXagYijQkp45wrkHUjZJq2O8ysw/w400-h266/pycon23.JPG",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/a/AVvXsEi0d1JAcXu962gjfuEKscZMczSxI7IAnt7EvD_MLu7BoMClEYxIl1fzdlnSbnYa0XzvfM-gOLOia2dIUewL6JFgbyjeBtYUUKR9Mpshg_7U0fwqXhY9Mkeg-uV3D5Ru-uKyUOswg2hySU6kGflLpBWY-kJ3gC3960SODPRsmASkuiavjbU",
            "https://blogger.googleusercontent.com/img/a/AVvXsEiY5RbnRYMXpHo5AYTKNrKuRGJH9uwQ8158ypEk9tb09F7AK_XpST-9SfY9Prn6Rw8fd1syzEqVRTCzuPVrTAjYn8VGJmJbIjhaxwWjG8STo6SU9m4ais2PKwQPlHJ_ByqK20J9uWbojLt2ojf3LgSeFVy7RG1L4UjCF7Ol1i3hGYZ7Wyw",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhNHMtg7BSQza8aOAebA4arhofrKFaaX0MulKsXjgTFBc--7H5bWHuumjdw-DMOHN_eGH1cBA4sZzumqMPp0caSMVZv2aySrlwd7R9jMgjwwsMEpluO89sKCEsbAiHli5fg_i65HkN2OJoXnCqlKQiCA9HBlICEB_NUcFOsN3WcCPKOAbU/s320/image_2023-05-27_223251699.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/a/AVvXsEjz18FEpI2W8Dx9w0LUFcj4KhCu2ml9sKxdPh33P6IBGuLx65qgBsTMJTwHPXtX7CzPYtkL81sxGJv8RJ8RQlCwKKkGy7epUxp4io7PRMeO6_ZAWF1yvlWqtg6cEiGtwhcRUl-8F7g8M3p8jwKK2b-9YHEbaacoz8OUi4LglXSPXvo3maY",
            "https://blogger.googleusercontent.com/img/a/AVvXsEjMxObGvaIvslDc98eA-L5NJPCh56mPTurCwLIsqKxY3BHmVUaXFKcXLdFJgNMG2Ag0MxL3Q4kagE0SAAIFH-KNhuSa3k6BL0sWhn5dWK1ro1DJy7FhPwVDaZKr1o0aToh_MTmnIKy6NAFZGSSfPj1CDSBlw1tdPoUm_R-N4Z-hMnRTl4M",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/a/AVvXsEinkl3WkxN3nTJap16aR2WhbP1k4BJw92phSFrhsrCWHOWl2raf6mjtgC7pt4NxSkiugearJ82UJRuepNqcZCEnB2Adm9c1EEv32nHzQf79hx-B2ZOqdk_M6Y6sWkGD7SMsq5l1ZE1xYyxGwrz5U1wnBHlqDOlDfiWHNtFwc_69mS7pRTH6=s250"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Deb Nicholson",
            "Alex Waygood"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "News from the Python Software Foundation",
        "meta_lang": "en",
        "meta_favicon": "https://pyfound.blogspot.com/favicon.ico",
        "meta_site_name": "Python Software Foundation Blog",
        "canonical_link": "https://pyfound.blogspot.com/2023/05/",
        "text": "The Python Language Summit 2023 began with an extended discussion of Python’s C API – the interface through which it is possible to communicate between code written in Python and code written in low-level languages, like C. The fullness of this interface is a significant factor behind the vibrancy of Python’s ecosystem, enabling libraries such as NumPy and pandas that are foundational to Python’s widespread use in data science.\n\nThree speakers had booked slots to discuss the C API this year: Mark Shannon, Guido van Rossum, and Antonio Cuni. The conversation evolved naturally from one talk to the next, so in this blog post, I’ll be discussing the three talks together.\n\nAll at sea on the C API\n\nThe C API at sea (illustration by DALL-E)\n\n“I still don’t know what the C-API is, and I’ve been trying for years!”\n\n-- Mark Shannon, CPython Core Developer\n\nMark Shannon spoke on the problems (as he saw them) with Python’s C API. Shannon lamented that with every minor Python version, a slew of third-party C extensions seemed to break. He argued that the root cause was that the needs of C extensions were not adequately met by the formal C API, which had evolved in a haphazard and often-unplanned way over the past three decades of Python’s existence.\n\nAs a result of the C API’s flaws, Shannon said, extension authors were forced to reach beyond the formal API and into implementation details that had emerged as a kind of “implicit API”. The implementation details that constituted the new “implicit API” had become so widely depended upon that it was now impossible for CPython to change some parts of its code without breaking large parts of the Python ecosystem.\n\nShannon believes that the new “implicit API” should be formalised in Python 3.13. This, he argues, would put an end to the cycle of CPython releases inevitably leading to widespread breakages in C extensions.\n\nSam Gross, who (among other things) has contributed to pytorch, agreed with Shannon that the C API was lacking in many areas. Gross argued that there was a great deal of important functionality that wasn’t exposed to extension authors. “Projects just end up copying-and-pasting CPython C code,” Gross said, meaning the extensions broke with each new release of CPython.\n\nPablo Galindo Salgado, release manager for Python 3.10 and 3.11, said that the release process for those versions had felt like a “game of whackamole” when it came to third-party C extensions breaking. Salgado argued that CPython needed to reach out to the authors of extensions such as pytorch to gather detailed feedback on what core functionality was missing from the API. Several attendees expressed frustration with a perceived tendency among C extension authors to immediately reach into CPython implementation details when something they needed was missing from the API. The result of this was that CPython core developers were often in the dark about which things the C API should be providing, but currently wasn’t. “We might not be able to give you a solution,” Salgado said, “But please come to us and tell us what your problem is, if you have a problem!”\n\nGross proposed that CPython should run third-party test suites with new versions of CPython as they were being developed, so that the Core Dev team would be able to spot third-party breakages early and gauge the impact of their changes. Pytorch operated a similar programme, Gross said, and it had been successful in helping to limit breakages of third-party pytorch models as the core pytorch team evolved their API.\n\nBrandt Bucher noted, however, that the problem often wasn’t so much that CPython was unaware when they were breaking third-party code – the benchmarks run in the pyperformance suite often served as an early warning signal for breakages in C extensions. The problem was often that CPython would offer to help affected projects, only to have their help rejected. Several core developers had previously sent pull requests to help third-party projects become compatible with an upcoming version of CPython, only for their pull requests to remain unmerged for several months due to burned-out maintainers of these projects.\n\nLet’s get specific\n\nGuido van Rossum speaks to the Language Summit on the C API\n\n(photo by Hugo van Kemenade)\n\nShannon was clear about what he thought the problem with the C API was. The problem was that the C API was insufficient for the authors of C extensions, leading these authors to reach into CPython implementation details, leading to an unending cycle of projects breaking with each new release of CPython. Others, however, argued that this wasn’t so much a specific problem but a genre of problems. Each specific project might have a different notion about which things were imperfect with the C API, and which things were missing from the C API. Each imperfection or absence could be considered a concrete problem in its own way. “Things break for everybody, but things break in different ways for different people,” Carol Willing argued. “We need more granularity in our understanding of that.”\n\nAs Mark Shannon’s slot drew to an end, Guido van Rossum opted to continue the discussion that Shannon had started, but sought to draw attention to a more precise enumeration of the difficulties C API users were facing.\n\n“There’s lots of ideas here, but I don’t know what the problem is!”\n\n-- Carol Willing, CPython Core Developer\n\nSimon Cross, a contributor to the HPy project, reported that the HPy project had, in the early stages of the project, put together a long list of the problems, as they saw them, with the CPython C API. Cross offered to share the list with the Core Dev team. Thomas Wouters, a Google employee, also offered to provide a list of difficulties Google had experienced when upgrading to recent Python releases, something the company keeps detailed records of. There was agreement that putting together a comprehensive list of problems with the existing API was an important first step, before CPython could consider drawing up plans to fix the problem.\n\nThe C API discussions ended with an agreement that further discussion was required. Interested parties can follow the ongoing conversation at https://github.com/capi-workgroup/problems/issues. The plan is to work towards an informational PEP, with input from an array of stakeholders, outlining a consensus around the problems and pitfalls in the current C API. Once the problems with the status quo have been enumerated in detail, the community might be in a position to consider possible solutions.\n\nHPy: A possible solution?\n\nA slide from Antonio Cuni's talk on HPy\n\nWhile the C API discussions ended with a detailed discussion of the problems in the current C API, the first talk of the day was in fact by Antonio Cuni, a core developer with the HPy project. HPy is an alternative C API for Python – an API that seeks to avoid many of the pitfalls of the current API. The contention of the HPy developers is that the current C API is bad for CPython, bad for alternative implementations of Python such as PyPy or GraalPython, and, ultimately, bad for end users.\n\nHPy is a specification of a new API and ABI for extending Python that is Python implementation agnostic and designed to hide and abstract internal details\n\n-- The HPy GitHub README\n\nCuni began by describing the key goals of the HPy project:\n\nAn API that doesn’t leak CPython-specific implementation details\n\nA 0% (or close to 0%) performance overhead when compared with CPython’s current C API\n\nA “Universal ABI” that allows compiled extension modules to use the same interface to communicate with PyPy (for example) as they would do to communicate with CPython\n\nAn API that is garbage-collection friendly.\n\nCuni argued that if the Python ecosystem as a whole moved to using HPy, instead of the “official” C API, there would be dramatically fewer breakages of C extensions with each new Python release. Cuni’s proposal was that CPython should “officially bless” HPy as the recommended C API for Python.\n\nHPy Hpy Hooray?\n\nSimon Cross, HPy Core Developer\n\n(photo by Hugo van Kemenade)\n\nCuni’s talk was exuberant, but it was at times somewhat unclear what exactly he was asking for from the room. “The investment from CPython,” Cuni argued “would be a political investment rather than a technical one”. Thomas Wouters, however, argued that the CPython team didn’t have the “moral authority” to coerce extension authors into using HPy. Hynek Schlawack agreed, arguing that it was perhaps unrealistic to migrate the entire Python ecosystem towards HPy.\n\nMany were uncertain about what it would even mean to “officially bless” HPy – would CPython host HPy’s documentation on docs.python.org? Or would CPython simply add a note to the documentation of the C API that the “official” C API was no longer the recommended way to write a C extension? Guido van Rossum emphasised that a top-down approach from the Core Dev team to extension authors wouldn’t work: nobody wanted a repeat of the decade-long transition from Python 2 to Python 3. Carol Willing agreed that pushing C extension authors to use HPy could be counterproductive, arguing that it was important to remember the impact of our decisions on end users of Python.\n\nOther core developers were sceptical about the fundamentals of HPy itself. HPy’s origin story lies in difficulties PyPy encountered when it trying to use CPython’s existing C API. These difficulties led to attempts to create an API that could be easily used on either Python implementation. Larry Hastings argued that blessing an API that was friendlier to PyPy had clear benefits to PyPy (and other implementations), but that it was less clear where CPython stood to gain from this change.\n\nCuni’s response was that if the ecosystem migrated to an API that exposed fewer implementation details directly, CPython would be able to refactor its internal implementation far more seamlessly, as CPython would no longer have to worry about breaking a multitude of third-party C extensions with every internal reorganisation of code. Cuni mentioned efforts to run CPython using WebAssembly as a specific area where CPython could stand to gain, as the HPy API could interact far more easily with the Javascript garbage collector. And Cuni also noted that HPy made it easy for extension authors to test whether they were sticking to the API or not, something which is famously hard to know with the current C API. “We don’t know all the experimentation that this might enable,” Cuni exclaimed, however, “Because we haven’t implemented this change yet!”\n\nMark Shannon was another core developer expressing scepticism about HPy. Shannon argued that while HPy had strengths over the “official” C API, it was far from perfect. “We should try to fix CPython’s API” before CPython recommended users switch to HPy, Shannon argued. Simon Cross, also of the HPy project, said that the team welcomed feedback about where they could improve. It was still easy for HPy to make changes, Cross argued, given they had not yet achieved widespread adoption.\n\nFurther Reading on HPy\n\nHPy’s overview of changes needed to the C API.\n\nHPy’s explanation of why the changes are needed.\n\nBrett Cannon came to the Python Language Summit this year with a fundamental question for the assembled core developers: What is the standard library for?\n\nAccording to a quick python -c \"import sys; print(len(sys.stdlib_module_names))\" call on my laptop, the standard library in Python 3.11 consists of 305 importable modules. Many of these are implementation details that, if you’re a good citizen, you really shouldn’t be importing – but the point stands that the Python standard library is perhaps now larger than it should be.\n\nBut the goal of his question, Cannon explained, wasn’t to decide which modules to get rid of. Instead, it was to create guidelines on when and why new modules should be accepted into the standard library.\n\n\"We need to audit the standard library, and not deprecate it, but decide which bits should probably not have been added if we had perfect hindsight.\n\n-- Guido van Rossum, CPython Core Developer and former BDFL\n\nCarol Willing agreed that the core dev team shouldn’t be looking to remove modules en masse, but should decide what kinds of modules they wanted to admit in the future. Łukasz Langa agreed, and pointed out that it was often hard removing modules even when we wanted to, due to the fact that “the standard library is a huge import cycle”.\n\nWhere do we go now?\n\nCannon himself put forward two possible answers to his question, before tossing it out to the audience:\n\nThe standard library should contain everything required to bootstrap an installer.\n\nThe standard library should make it easy for beginners to be able to write scripts without installing anything.\n\nThe conversation was free-flowing, but a common point of consensus among the attendees was that the standard library should focus on tools and utilities that allow users to write better Python code. Hynek Schlawack cited dataclasses as an example of a module that made writing classes much less painful, and generally led to them writing better code as a result. (Schlawack is the author of the attrs library, the third-party inspiration for dataclasses, which itself is still going strong.) Filipe Laíns agreed, arguing that the core dev team should focus on building business implementations for third-party libraries to build on top of.\n\n“The default answer for ‘Should this be in the standard library?’ should be ‘No’, but we should bless smaller utilities that help people write better Python code”\n\n-- Antonio Cuni, HPy Core Developer\n\nThere was a certain amount of regret in the air about modules that perhaps should never have been added to the standard library, and had proved themselves to be significant maintenance burdens in the years since, but could now never be removed. tkinter, it was universally agreed, was the primary example here; possibly multiprocessing also.\n\nGuido van Rossum pondered whether asyncio should ever have been added to the standard library, remarking that it had been difficult to evolve asyncio while it was in the standard library, and had possibly been added before it was “fully baked”. The ssl integration had probably been a mistake, he said, and should have been left to third parties.\n\nŁukasz Langa noted that modules such as asyncio and typing, which had continued to evolve rapidly after being added to the standard library, had helped spur new syntax changes to Python that had been to the language’s betterment. Without asyncio in the standard library, Langa argued, we would probably never have adopted the async/await syntax that is now the foundation of asynchronous Python programming.\n\nZac Hatfield-Dods, maintainer of several prominent third-party packages, said that different standard-library packages had different impacts on the Python ecosystem. Pytest, one of the libraries he maintains, had managed to flourish and find success despite the existence of unittest in the standard library. But another library he helps out with, the asynchronous Trio framework, had struggled to attract users while asyncio had been part of the standard library. “Nobody supports alternative async implementations,” he complained, despite Trio’s development often being years ahead of where asyncio is. (In the coffee break afterwards, Hatfield-Dods was keen to emphasise that he is, in fact, a fan of asyncio and the work of the asyncio maintainers.)\n\nZac Hatfield-Dods (left), speaking at the Language Summit\n\n(Photo by Hugo van Kemenade)\n\nCannon brought up the question of whether a module like pathlib belonged. “It’s just sugar,” he remarked – i.e., hardly a “core utility” or a protocol that allowed people to write better code. But it has nonetheless been one of the more popular additions to the standard library in recent years. Langa again pushed back, arguing that without the addition of pathlib to the standard library, we would never have added os.PathLike, a protocol that had allowed a common interface for describing file-system paths in Python. “A third-party PyPI package wouldn’t have convinced us to make that change,” Langa argued.\n\nSeveral attendees noted that adding a module to the standard library often made it hard for users to use features added to the module in newer versions of Python, due to CPython’s slow development cycle. One solution could be to provide third-party versions of standard-library modules on PyPI, backporting the latest features of a module to older versions of Python. Thomas Wouters argued that previous attempts at providing these backport modules had often been disastrous. However, Jelle Zijlstra noted that typing_extensions, which backports features from the latest version of the typing module, had been incredibly successful (though it was sometimes hard to maintain).\n\nOverall, there was agreement that the original motivations for a large, “batteries-included” standard library no longer held up to scrutiny. “In the good old days,” Ned Deily reminisced, “We said ‘batteries-included’ because we didn’t have a good story for third-party installation.” But in 2023, installing third-party packages from PyPI is much easier.\n\nOften, Thomas Wouters noted, people preferred using standard-library modules in a corporate setting due to the fact that the installation of any third-party package would require approval from their company’s IT department. But, he noted, this was hardly Python’s problem.\n\nHow does working with ASTs relate to pattern-matching? Well, a function to determine whether (to a reasonable approximation) an arbitrary AST node represents the symbol collections.deque might have looked something like this, before pattern matching…\n\nimport ast # This obviously won't work if the symbol is imported with an alias # in the source code we're inspecting # (e.g. \"from collections import deque as d\"). # But let's not worry about that here :-) def node_represents_collections_dot_deque(node: ast.AST) -> bool: \"\"\"Determine if *node* represents 'deque' or 'collections.deque'\"\"\" return ( isinstance(node, ast.Name) and node.id == \"deque\" ) or ( isinstance(node, ast.Attribute) and isinstance(node.value, ast.Name) and node.value.id == \"collections\" and node.value.attr == \"deque\" )\n\nBut in Python 3.10, pattern matching allows an elegant destructuring syntax:\n\nimport ast def node_represents_collections_dot_deque(node: ast.AST) -> bool: \"\"\"Determine if *node* represents 'deque' or 'collections.deque'\"\"\" match node: case ast.Name(\"deque\"): return True case ast.Attribute(ast.Name(\"collections\"), \"deque\"): return True case_: return False\n\nI know which one I prefer.\n\nFor some, though, this still isn’t enough – and Michael “Sully” Sullivan is one of them. At the Python Language Summit 2023, Sullivan shared ideas for where pattern matching could go next.\n\nPlaying with matches (without getting burned)\n\nSullivan’s contention is that, while pattern matching provides elegant syntactic sugar in simple cases such as the one above, our ability to chain destructurings using pattern matching is currently fairly limited. For example, say we want to write a function inspecting Python AST that takes an ast.FunctionDef node and identifies whether the node represents a synchronous function with exactly two parameters, both of them annotated as accepting integers. The function would behave so that the following holds true:\n\n>>> import ast >>> source = \"def add_2(number1: int, number2: int): pass\" >>> node = ast.parse(source).body[0] >>> type(node) <class 'ast.FunctionDef'> >>> is_function_taking_two_ints(node) True\n\nWith pre-pattern-matching syntax, we might have written such a function like this:\n\ndef is_int(node: ast.AST | None) -> bool: \"\"\"Determine if *node* represents 'int' or 'builtins.int'\"\"\" return ( isinstance(node, ast.Name) and node.id == \"int\" ) or ( isinstance(node, ast.Attribute) and isinstance(node.value, ast.Name) and node.value.id == \"builtins\" and node.attr == \"int\" ) def is_function_taking_two_ints(node: ast.FunctionDef) -> bool: \"\"\"Determine if *node* represents a function that accepts two ints\"\"\" args = node.args.posonlyargs + node.args.args return len(args) == 2 and all(is_int(node.annotation) for node in args)\n\nIf we wanted to rewrite this using pattern matching, we could possibly do something like this:\n\ndef is_int(node: ast.AST | None) -> bool: \"\"\"Determine if *node* represents 'int' or 'builtins.int'\"\"\" match node: case ast.Name(\"int\"): return True case ast.Attribute(ast.Name(\"builtins\"), \"int\"): return True case_: return False def is_function_taking_two_ints(node: ast.FunctionDef) -> bool: \"\"\"Determine if *node* represents a function that accepts two ints\"\"\" match node.args.posonlyargs + node.args.args: case [ast.arg(), ast.arg()] as arglist: return all(is_int(arg.annotation) for arg in arglist) case_: return False\n\nThat leaves a lot to be desired, however! The is_int() helper function can be rewritten in a much cleaner way. But integrating it into the is_function_taking_two_ints() is… somewhat icky! The code feels harder to understand than before, whereas the goal of pattern matching is to improve readability.\n\nSomething like this, (ab)using metaclasses, gets us a lot closer to what it feels pattern matching should be like. By using one of Python’s hooks for customising isinstance() logic, it’s possible to rewrite our is_int() helper function as a class, meaning we can seamlessly integrate it into our is_function_taking_two_ints() function in a very expressive way:\n\nimport abc import ast class PatternMeta(abc.ABCMeta): def __instancecheck__(cls, inst: object) -> bool: return cls.match(inst) class Pattern(metaclass=PatternMeta): \"\"\"Abstract base class for types representing 'abstract patterns'\"\"\" @staticmethod @abc.abstractmethod def match(node) -> bool: \"\"\"Subclasses must override this method\"\"\" raise NotImplementedError class int_node(Pattern): \"\"\"Class representing AST patterns signifying `int` or `builtins.int`\"\"\" @staticmethod def match(node) -> bool: match node: case ast.Name(\"int\"): return True case ast.Attribute(ast.Name(\"builtins\"), \"int\"): return True case_: return False def is_function_taking_two_ints(node: ast.FunctionDef) -> bool: \"\"\"Determine if *node* represents a function that accepts two ints\"\"\" match node.args.posonlyargs + node.args.args: case [ ast.arg(annotation=int_node()), ast.arg(annotation=int_node()), ]: return True case_: return False\n\nThis is still hardly ideal, however – that’s a lot of boilerplate we’ve had to introduce to our helper function for identifying int annotations! And who wants to muck about with metaclasses?\n\nA slide from Sullivan's talk\n\nA __match__ made in heaven?\n\nSullivan proposes that we make it easier to write helper functions for pattern matching, such as the example above, without having to resort to custom metaclasses. Two competing approaches were brought for discussion.\n\nThe first idea – a __match__ special method – is perhaps the easier of the two to immediately grasp, and appeared in early drafts of the pattern matching PEPs. (It was eventually removed from the PEPs in order to reduce the scope of the proposed changes to Python.) The proposal is that any class could define a __match__ method that could be used to customise how match statements apply to the class. Our is_function_taking_two_ints() case could be rewritten like so:\n\nclass int_node: \"\"\"Class representing AST patterns signifying `int` or `builtins.int`\"\"\" # The __match__ method is understood by Python to be a static method, # even without the @staticmethod decorator, # similar to __new__ and __init_subclass__ def __match__(node) -> ast.Name | ast.Attribute: match node: case ast.Name(\"int\"): # Successful matches can return custom objects, # that can be bound to new variables by the caller return node case ast.Attribute(ast.Name(\"builtins\"), \"int\"): return node case_: # Return `None` to indicate that there was no match return None def is_function_taking_two_ints(node: ast.FunctionDef) -> bool: \"\"\"Determine if *node* represents a function that accepts two ints\"\"\" match node.args.posonlyargs + node.args.args: case [ ast.arg(annotation=int_node()), ast.arg(annotation=int_node()), ]: return True case_: return False\n\nThe second idea is more radical: the introduction of some kind of new syntax (perhaps reusing Python’s -> operator) that would allow Python coders to “apply” functions during pattern matching. With this proposal, we could rewrite is_function_taking_two_ints() like so:\n\ndef is_int(node: ast.AST | None) -> bool: \"\"\"Determine if *node* represents 'int' or 'builtins.int'\"\"\" match node: case ast.Name(\"int\"): return True case ast.Attribute(ast.Name(\"builtins\"), \"int\"): return True case_: return False def is_function_taking_two_ints(node: ast.FunctionDef) -> bool: \"\"\"Determine if *node* represents a function that accepts two ints\"\"\" match node.args.posonlyargs + node.args.args: case [ ast.arg(annotation=is_int -> True), ast.arg(annotation=is_int -> True), ] case_: return False\n\nMatch-maker, match-maker, make me a __match__…\n\nA slide from Sullivan's talk\n\nThe reception in the room to Sullivan’s ideas was positive; the consensus seemed to be that there was clearly room for improvement in this area. Brandt Bucher, author of the original pattern matching implementation in Python 3.10, concurred that this kind of enhancement was needed. Łukasz Langa, meanwhile, said he’d received many queries from users of other programming languages such as C#, asking how to tackle this kind of problem.\n\nThe proposal for a __match__ special method follows a pattern common in Python’s data model, where double-underscore “dunder” methods are overridden to provide a class with special behaviour. As such, it will likely be less jarring, at first glance, to those new to the idea. Attendees of Sullivan’s talk seemed, broadly, to slightly prefer the __match__ proposal, and Sullivan himself said he thought it “looked prettier”.\n\nJelle Zijlstra argued that the __match__ dunder would provide an elegant symmetry between the construction and destruction of objects. Brandt Bucher, meanwhile, said he thought the usability improvements weren’t significant enough to merit new syntax.\n\nNonetheless, the alternative proposal for new syntax also has much to recommend it. Sullivan argued that having dedicated syntax to express the idea of “applying” a function during pattern matching was more explicit. Mark Shannon agreed, noting the similarity between this idea and features in the Haskell programming language. “This is functional programming,” Shannon argued. “It feels weird to apply OOP models to this.”\n\nAddendum: pattern-matching resources and recipes\n\nIn the meantime, while we wait for a PEP, there are plenty of innovative uses of pattern matching springing up in the ecosystem. For further reading/watching/listening, I recommend:\n\n“A perfect match: The history, design and future of Python’s structural pattern matching” – A talk by Brandt Bucher at PyCon 2022\n\n“Structural Pattern Matching in the Real World” – A talk by Raymond Hettinger at Pycon Italia 2022\n\nRegexMatcher: a class integrating pattern matching with Python’s re module. A 2022 Advent of Code solution by Ned Batchelder.\n\napproximately: A way to compare float and complex numbers using pattern matching, while avoiding the perils of floating-point arithmetic. A StackOverflow Q&A by Raymond Hettinger.\n\n“A few related schemes for implementing view patterns in Python”: A gist by Michael Sullivan (from February 2023)"
    }
}