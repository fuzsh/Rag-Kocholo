{
    "id": "dbpedia_2348_2",
    "rank": 57,
    "data": {
        "url": "https://forum.arduino.cc/t/guru-meditation-error-core-1-paniced-interrupt-wdt-timeout-on-cpu1-when-setting-timer-interrupt-despite-isr-being-a-simple-flag-toggle-function/1101017",
        "read_more_link": "",
        "language": "en",
        "title": "Guru Meditation Error: Core 1 panic'ed (Interrupt wdt timeout on CPU1) when setting timer interrupt - despite ISR being a simple flag toggle function",
        "top_image": "https://europe1.discourse-cdn.com/arduino/original/3X/1/f/1f6eb1c9b79d9518d1688c15fe9a4b7cdd5636ae.svg",
        "meta_img": "https://europe1.discourse-cdn.com/arduino/original/3X/1/f/1f6eb1c9b79d9518d1688c15fe9a4b7cdd5636ae.svg",
        "images": [
            "https://avatars.discourse-cdn.com/v4/letter/g/bbce88/48.png",
            "https://avatars.discourse-cdn.com/v4/letter/g/bbce88/48.png",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/idahowalker/48/238858_2.png",
            "https://europe1.discourse-cdn.com/arduino/original/4X/b/7/4/b74643b48f432c039fe4cc1908720d33e9feac46.png",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/c/8/a/c8a64c484b339a4c90378b505ae4af7ea1ba00c9_2_690x360.jpeg",
            "https://europe1.discourse-cdn.com/arduino/original/4X/e/b/4/eb40040489ca862876625a210c578c12470cd4bf.png",
            "https://europe1.discourse-cdn.com/arduino/original/4X/0/4/0/040c6a554a9ef930e440b65b2839282b2a35f032.png",
            "https://avatars.discourse-cdn.com/v4/letter/g/bbce88/48.png",
            "https://emoji.discourse-cdn.com/twitter/rofl.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/sob.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/ec2021/48/997272_2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2023-03-12T16:12:51+00:00",
        "summary": "",
        "meta_description": "Issue: \nSo it appears that my issue is, whenever I set the timer interrupt, I get a watch dog timer error. Usually, I would assume this would be due to the code holding up the vTaskDelay of the esp32 somewhere, but my IS&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://europe1.discourse-cdn.com/arduino/optimized/3X/c/c/cc4b0921af3d89006e843364a2b18989ad72f83e_2_32x32.png",
        "meta_site_name": "Arduino Forum",
        "canonical_link": "https://forum.arduino.cc/t/guru-meditation-error-core-1-paniced-interrupt-wdt-timeout-on-cpu1-when-setting-timer-interrupt-despite-isr-being-a-simple-flag-toggle-function/1101017",
        "text": "Issue:\n\nSo it appears that my issue is, whenever I set the timer interrupt, I get a watch dog timer error. Usually, I would assume this would be due to the code holding up the vTaskDelay of the esp32 somewhere, but my ISR is literally just a single set-flag. What exactly is going wrong here?\n\nMy code with phone numbers dedacted:\n\n#define TINY_GSM_MODEM_SIM7600 #define TINY_GSM_RX_BUFFER 1024 // Set RX buffer to 1Kb #define SerialAT Serial1 //Timeren til PULSE sms hw_timer_t *Timer0_Cfg = NULL; // Set serial for debug console (to the Serial Monitor, default speed 115200) #define SerialMon Serial // See all AT commands, if wanted // #define DUMP_AT_COMMANDS // set GSM PIN, if any #define GSM_PIN \"6508\" // Nummer til SMS samt besked #define SMS_TARGET_NOISY \"+DEDACTED\" #define SMS_TARGET_PULSE \"+DEDACTED\" #define SMS_MESSAGE_NOISY \"BRAND ALARM\" #define SMS_MESSAGE_PULSE \"PULSE\" //Netværks indstillinger fra Debugging 1 koden #define NETWORK_MODE 38 #define PREFFERED_NETWORK_MODE 38 // Your GPRS credentials, if any const char apn[] = \"websp\"; //SET TO YOUR APN const char gprsUser[] = \"\"; const char gprsPass[] = \"\"; #include <TinyGsmClient.h> #include <SPI.h> #include <Ticker.h> #ifdef DUMP_AT_COMMANDS #include <StreamDebugger.h> StreamDebugger debugger(SerialAT, SerialMon); TinyGsm modem(debugger); #else TinyGsm modem(SerialAT); #endif // LilyGO T-SIM7000G Pinout #define UART_BAUD 115200 #define PIN_DTR 25 #define PIN_TX 27 #define PIN_RX 26 #define PWR_PIN 4 #define SD_MISO 2 #define SD_MOSI 15 #define SD_SCLK 14 #define SD_CS 13 #define LED_PIN 12 //Indstillinger for dBAMåleren #define VREF 3.3 //Voltagen som din MCU bruger, Arduino = 5 #define soundSensorPin 25 //Den pin på MCU'en, der er forbundet til outputtet på dBA måleren #define analogMaxRange 4096 //Analog max range for din MCU, esp32: 4096, Arduino: 1023 //Funktionelle indstillinger #define dBAMax 80.0 //Hvornår der skal sendes en SMS #define errorMeasurement 10.0 //Fejlmarginen #define waitBeforeSendingtext (50*1000) //Målt i millisekunder, tid før vi sender noisySMS #define waitBeforeGoingIdle (10*1000) //Hvor lang tid dBAMeasurement må være under vores dBAMax, før vi går tilbage til idle stadiet #define waitIntervalBetweenPulseText (3600*1000) //Antal millisekunder i mellem, at vi sender en pulse SMS //Relæ indstillinger #define relayPin 12 int relayState = 0; //Variable vedrørende FSMD'en - MÅ IKKE ÆNDRES //States: //Idle 0, dBA above Max 1, dBA momentarily below max 2, send noisy text 3, send pulse text 4 int state = 0; //Initialiserer stadiet ved 0 float dbAMeasurement; unsigned long timeSinceLastIdle; //Bruges til at triggere loudSMS unsigned long timeSinceLastPulse = 0; //Bruges til at pulseSMS unsigned long timeSincedBAMax; //Tid der er gået siden, vi optog vores første dBAMax i denne omgang //Funktioner //Funktion til at sende pulse text void IRAM_ATTR Timer0_ISR() { state = 4; } //Hvad der skal ske med relæet, når vi sender brandalarm void brandalarmRelay(int newState) { digitalWrite(relayPin,newState); } void sendText(String SMSTarget,String message,TinyGsm modem){ modem.sendSMS(SMSTarget, message); } float getdBAMeasurement(){ float dbAMeasurement = ((analogRead(soundSensorPin) / 4096.0 * VREF)*50.0); //Slipper for at bruge clock cycluser på at definere variable delay(125); //Sampling cyclus delay for stabilitet return dbAMeasurement; } bool isAbovedBAThreshold(){ float dbAMeasurement = getdBAMeasurement(); if(dbAMeasurement>(dBAMax - errorMeasurement)){ return true; }else{ return false; } } void modemPowerOn() { pinMode(PWR_PIN, OUTPUT); digitalWrite(PWR_PIN, LOW); delay(1000); digitalWrite(PWR_PIN, HIGH); } void modemPowerOff() { pinMode(PWR_PIN, OUTPUT); digitalWrite(PWR_PIN, LOW); delay(1500); digitalWrite(PWR_PIN, HIGH); } void modemRestart() { modemPowerOff(); delay(1000); modemPowerOn(); } void setup() { // Set console baud rate SerialMon.begin(115200); delay(10); // Set LED OFF pinMode(LED_PIN, OUTPUT); digitalWrite(LED_PIN, HIGH); modemPowerOn(); Serial.println(\"===========================\"); SerialAT.begin(UART_BAUD, SERIAL_8N1, PIN_RX, PIN_TX); Serial.println(\"/**********************************************************/\"); Serial.println(\"To initialize the network test, please make sure your LTE \"); Serial.println(\"antenna has been connected to the SIM interface on the board.\"); Serial.println(\"/**********************************************************/\\n\\n\"); delay(10000); String res; Serial.println(\"========INIT========\"); if (!modem.init()) { modemRestart(); delay(2000); Serial.println(\"Failed to restart modem, attempting to continue without restarting\"); return; } Serial.println(\"========SIMCOMATI======\"); modem.sendAT(\"+SIMCOMATI\"); modem.waitResponse(1000L, res); res.replace(GSM_NL \"OK\" GSM_NL, \"\"); Serial.println(res); res = \"\"; Serial.println(\"=======================\"); Serial.println(\"=====Preferred mode selection=====\"); modem.sendAT(\"+CNMP?\"); if (modem.waitResponse(1000L, res) == 1) { res.replace(GSM_NL \"OK\" GSM_NL, \"\"); Serial.println(res); } res = \"\"; Serial.println(\"=======================\"); Serial.println(\"=====Preferred selection between CAT-M and NB-IoT=====\"); modem.sendAT(\"+CMNB?\"); if (modem.waitResponse(1000L, res) == 1) { res.replace(GSM_NL \"OK\" GSM_NL, \"\"); Serial.println(res); } res = \"\"; Serial.println(\"=======================\"); String name = modem.getModemName(); Serial.println(\"Modem Name: \" + name); String modemInfo = modem.getModemInfo(); Serial.println(\"Modem Info: \" + modemInfo); // Unlock your SIM card with a PIN if needed if (GSM_PIN && modem.getSimStatus() != 3) { modem.simUnlock(GSM_PIN); } for (int i = 0; i <= 4; i++) { uint8_t network[] = { 2, /*Automatic*/ 13, /*GSM only*/ 38, /*LTE only*/ 51 /*GSM and LTE only*/ }; Serial.printf(\"Try %d method\\n\", network[i]); modem.setNetworkMode(network[i]); delay(3000); bool isConnected = false; int tryCount = 60; while (tryCount--) { int16_t signal = modem.getSignalQuality(); Serial.print(\"Signal: \"); Serial.print(signal); Serial.print(\" \"); Serial.print(\"isNetworkConnected: \"); isConnected = modem.isNetworkConnected(); Serial.println(isConnected ? \"CONNECT\" : \"NO CONNECT\"); if (isConnected) { break; } delay(1000); digitalWrite(LED_PIN, !digitalRead(LED_PIN)); } if (isConnected) { break; } } digitalWrite(LED_PIN, HIGH); Serial.println(); Serial.println(\"Device is connected .\"); Serial.println(); Serial.println(\"=====Inquiring UE system information=====\"); modem.sendAT(\"+CPSI?\"); if (modem.waitResponse(1000L, res) == 1) { res.replace(GSM_NL \"OK\" GSM_NL, \"\"); Serial.println(res); //THIS PART PRINTS } //Timer setup Timer0_Cfg = timerBegin(0, 80, true); timerAttachInterrupt(Timer0_Cfg, &Timer0_ISR, true); timerAlarmWrite(Timer0_Cfg, waitIntervalBetweenPulseText*1000, true); //Tid mellem kald = ticks * 80/8*10^7 timerAlarmEnable(Timer0_Cfg); Serial.println(\"Timer configured correctly\"); //SMS for at teste forbindelsem modem.sendSMS(\"+DEDACTED\", \"Forbindelse oprettet\"); } void loop() { while (1) { switch(state){ case 0: // Idle: Venter på at dbAMeasurement går over dbAMax - Error //Serial.println(\"Back in state 0\"); dbAMeasurement = getdBAMeasurement(); timeSinceLastIdle = millis(); //Millisekunder siden start Serial.println(dbAMeasurement); //Serial.println(timeSinceLastIdle); //Serial.println(timeSinceLastPulse); if ((dbAMeasurement>(dBAMax - errorMeasurement))&(state != 4)){ //If we go above the allowed dBAMeasurement, we start counting until we send noisySMS state = 1; } break; case 1: // We're counting up to sending the loudSMS //Serial.println(\"Back in state 1\"); dbAMeasurement = getdBAMeasurement(); Serial.println(dbAMeasurement); timeSincedBAMax = millis() - timeSinceLastIdle; //Serial.println(timeSincedBAMax); if(timeSincedBAMax>waitBeforeSendingtext){ state = 3; //SendnoisySMS } if(dbAMeasurement<(dBAMax - errorMeasurement)){ state = 2; //Momentært under dBAMax } break; case 2: // Hvis vi momentært går under dBAMax //Serial.println(\"Back in state 2\"); dbAMeasurement = getdBAMeasurement(); if((millis() - timeSincedBAMax)> waitBeforeGoingIdle){ //Når der er gået lang nok tid, hvor vi ikke måler en høj nok lyd, så genstarter vi timeren for at sende noisySMS state = 0; } if(dbAMeasurement>(dBAMax - errorMeasurement)){ //Vi går igen over vores threshold og går tilbage til tælle op til at sende noisySMS uden at genstarte timeren state = 1; } break; case 3: // Send noisySMS //Serial.println(\"Back in state 3\"); modem.sendSMS(SMS_TARGET_NOISY,SMS_MESSAGE_NOISY); brandalarmRelay(relayState); relayState = !relayState; state = 0; break; case 4: //Serial.println(\"Back in state 4\"); timeSinceLastPulse = millis(); modem.sendSMS(SMS_TARGET_PULSE,SMS_MESSAGE_PULSE); state = 1; //There is no cost to going back to state 1 instead of state 0 delay(1000); break; } } }\n\nMy serial output:\n\n========INIT======== =========================== /**********************************************************/ To initialize the network test, please make sure your LTE antenna has been connected to the SIM interface on the board. /**********************************************************/ ========INIT======== ========SIMCOMATI====== Manufacturer: SIMCOM INCORPORATED Model: SIMCOM_SIM7600E-L1C Revision: DEDACTED QCN: IMEI: DEDACTED MEID: +GCAP: +CGSM DeviceInfo: DEDACTED ======================= =====Preferred mode selection===== +CNMP: 2 ======================= =====Preferred selection between CAT-M and NB-IoT===== ======================= Modem Name: SIMCOM SIM7600E-L1C Modem Info: Manufacturer: SIMCOM INCORPORATED Model: SIMCOM_SIM7600E-L1C Revision: SIM7600M11_A_V2.0.1 IMEI: DEDACTED+GCAP: +CGSM Try 2 method Signal: 31 isNetworkConnected: CONNECT Device is connected . =====Inquiring UE system information===== +CPSI: LTE,Online,238-20,0x5DE1,42027018,261,EUTRAN-BAND3,1850,5,5,-123,-798,-467,15 Guru Meditation Error: Core 1 panic'ed (Interrupt wdt timeout on CPU1). Core 1 register dump: PC : 0x4008bdfe PS : 0x00060035 A0 : 0x800812bb A1 : 0x3ffbee3c A2 : 0x3ffbdbc8 A3 : 0xffffffff A4 : 0x0000cdcd A5 : 0x00060023 A6 : 0x00060021 A7 : 0x0000abab A8 : 0x8008bdd1 A9 : 0xffffffff A10 : 0x00000003 A11 : 0x00060023 A12 : 0x00060021 A13 : 0x3ffb2630 A14 : 0x007bdbc8 A15 : 0x003fffff SAR : 0x00000020 EXCCAUSE: 0x00000006 EXCVADDR: 0x00000000 LBEG : 0x4008723e LEND : 0x40087249 LCOUNT : 0x00000000 Core 1 was running in ISR context: EPC1 : 0x400ddeef EPC2 : 0x00000000 EPC3 : 0x00000000 EPC4 : 0x00000000 Backtrace:0x4008bdfb:0x3ffbee3c |<-CORRUPTED Core 0 register dump: PC : 0x400f3e7a PS : 0x00060535 A0 : 0x800dcc2d A1 : 0x3ffbd1b0 A2 : 0x00000000 A3 : 0x400868c4 A4 : 0x00060020 A5 : 0x80000000 A6 : 0x007beeb8 A7 : 0x003fffff A8 : 0x800dc82e A9 : 0x3ffbd180 A10 : 0x00000000 A11 : 0x3ffbeeb4 A12 : 0x3ffbeeb4 A13 : 0x00000000 A14 : 0x00060020 A15 : 0x00000000 SAR : 0x0000001a EXCCAUSE: 0x00000006 EXCVADDR: 0x00000000 LBEG : 0x00000000 LEND : 0x00000000 LCOUNT : 0x00000000 Backtrace:0x400f3e77:0x3ffbd1b00x400dcc2a:0x3ffbd1d0 0x4008a64d:0x3ffbd1f0 ELF file SHA256: 0000000000000000 Rebooting... ets Jul 29 2019 12:21:46 rst:0xc (SW_CPU_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT) configsip: 0, SPIWP:0xee clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00 mode:DIO, clock div:1 load:0x3fff0030,len:1344 load:0x40078000,len:13864 load:0x40080400,len:3608 entry 0x400805f0 =========================== /**********************************************************/ To initialize the network test, please make sure your LTE antenna has been connected to the SIM interface on the board. /**********************************************************/ ========INIT======== Failed to restart modem, attempting to continue without restarting 164.96\n\nAs can be seen after reset it will go down to the void loop part of my code, where \"164.96\" is the measurement of my sensor.\n\nJust looked through your code and found this:\n\n// At line 68 #define waitIntervalBetweenPulseText (3600*1000) // At line 260: timerAlarmWrite(Timer0_Cfg, waitIntervalBetweenPulseText*1000, true);\n\nThis way the timer is set to 3600*1000*1000 microseconds, that's 3600 seconds or with other words one hour. Is that the intended time to wait?\n\nI know it does just circumvent the timer issue but I would rather not use any hardware timer for this purpose, millis() is more than enough, isn't it?\n\nec2021\n\nP.S.: In a different thread there was a problem with AlarmTimers of the ESP32 as well\n\nhttps://forum.arduino.cc/t/delay-on-hw-interrupt/1101079\n\nI also encountered problems when trying to restart one a shot timer during loop(). Of course the task was different (an action should be taken with a delay of 1 up to 19 milliseconds after an interrupt occured).\n\nI found something interesting - obviously having to do with the use of #defines ...\n\nJust used a very simple timer interrupt example and modified it to find out about when the problem occurs:\n\nvolatile int interruptCounter; int totalInterruptCounter; hw_timer_t * timer = NULL; portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED; void IRAM_ATTR onTimer() { portENTER_CRITICAL_ISR(&timerMux); interruptCounter++; portEXIT_CRITICAL_ISR(&timerMux); } #define MaxTimeInMilliSecsWorking (2147*1000) #define MinTimeInMilliSecsNotWorking (2148*1000) void SetTimerToMilliSecs(uint64_t value){ Serial.print(\"Before Timer Alarm is set to\\t\"); Serial.print(value); Serial.println(\" msecs\"); timer = timerBegin(0, 80, true); timerAttachInterrupt(timer, &onTimer, true); timerAlarmWrite(timer, value*1000, true); timerAlarmEnable(timer); Serial.println(\"After Timer Alarm was set\"); } void DoesNotWork(){ Serial.println(\"Before Timer Alarm is set to MinTimeInMilliSecsNotWorking\"); timer = timerBegin(0, 80, true); timerAttachInterrupt(timer, &onTimer, true); timerAlarmWrite(timer, MinTimeInMilliSecsNotWorking*1000, true); timerAlarmEnable(timer); // The next line is not printed!!!!! Serial.println(\"After Timer Alarm was set\"); } void DoesWork(){ Serial.println(\"Before Timer Alarm is set to MaxTimeInMilliSecsWorking\"); timer = timerBegin(0, 80, true); timerAttachInterrupt(timer, &onTimer, true); timerAlarmWrite(timer, MaxTimeInMilliSecsWorking*1000, true); timerAlarmEnable(timer); // The next line is printed!!!!! Serial.println(\"After Timer Alarm was set\"); } void setup() { Serial.begin(115200); int state = 4; switch(state){ case 1: DoesWork(); break; case 2: DoesNotWork(); break; case 3: SetTimerToMilliSecs(MinTimeInMilliSecsNotWorking); break; case 4: SetTimerToMilliSecs(3600*1000); break; } } void loop() { if (interruptCounter > 0) { portENTER_CRITICAL(&timerMux); interruptCounter--; portEXIT_CRITICAL(&timerMux); totalInterruptCounter++; Serial.print(\"An interrupt has occurred. Total number: \"); Serial.println(totalInterruptCounter); } }\n\nNothing much to it. You can play with the variable state in setup() to call one of the four routines .\n\nOne of them (the one named DoesNotWork() ) uses\n\n#define MinTimeInMilliSecsNotWorking (2148*1000)\n\nand if you upload it to an ESP32 (as I did) the\n\nSerial.println(\"After Timer Alarm was set\");\n\ndoes not appear ... If one uses\n\n#define MaxTimeInMilliSecsWorking (2147*1000)\n\nthen the second line appears ...\n\nAnd using the \"not working define\" with the function\n\nvoid SetTimerToMilliSecs(uint64_t value){}\n\nlets the second print line appear also, even with 3600*1000.\n\nI guess that the compiler has some problems with the #defines when uint64_t is required ... ?!??\n\nec2021\n\nP.S.: I am using Joy-IT SBC-NodeMCU-ESP32 and doublechecked the behaviour with a second board. Actually the simulator Wokwi does not show this behaviour ... Although it seems to be quite precise otherwise. https://joy-it.net/en/products/SBC-NodeMCU-ESP32"
    }
}