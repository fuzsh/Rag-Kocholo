{
    "id": "dbpedia_2920_1",
    "rank": 68,
    "data": {
        "url": "https://arxiv.org/html/2407.00784v1",
        "read_more_link": "",
        "language": "en",
        "title": "CSUM: A Novel Mechanism for Updating CubeSat while Preserving Authenticity and Integrity",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://arxiv.org/html/x1.png",
            "https://arxiv.org/html/x2.png",
            "https://arxiv.org/html/x3.png",
            "https://arxiv.org/html/x4.png",
            "https://arxiv.org/html/x5.png",
            "https://arxiv.org/html/x6.png",
            "https://arxiv.org/html/extracted/5701142/images/timing_information.png",
            "https://arxiv.org/html/x7.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Authentication",
            "CubeSat",
            "Data Freshness",
            "Integrity",
            "Secure Software Update."
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Ankit Gangwal, Aashish Paliwal\n\nInternational Institute of Information Technology Hyderabad, India\n\ngangwal@iiit.ac.in, aashish.paliwal@research.iiit.ac.in\n\nAbstract\n\nThe recent rise of CubeSat has revolutionized global space explorations, as it offers cost-effective solutions for low-orbit space applications (including climate monitoring, weather measurements, communications, and earth observation). A salient feature of CubeSat is that applications currently on-boarded can either be updated or entirely replaced by new applications via software updates, which allows reusing in-orbit hardware, reduces space debris, and saves cost as well as time. Securing software updates employing traditional methods (e.g., encryption) remains impractical mainly due to the low-resource capabilities of CubeSat. Therefore, the security of software updates for CubeSats remains a critical issue.\n\nIn this paper, we propose CubeSat Update Mechanism (CSUM), a lightweight scheme to provide integrity, authentication, and data freshness guarantees for software update broadcasts to CubeSats using a hash chain. We empirically evaluate our proof of concept implementation to demonstrate the feasibility and effectiveness of our approach. CSUM can validate 50,000 consecutive updates successfully in less than a second. We also perform a comparative analysis of different cryptographic primitives. Our empirical evaluations show that the hash-based approach is at least 61√ó\\times√ó faster than the conventional mechanisms, even in resource-constrained environments. Finally, we discuss the limitations, challenges, and potential future research directions for CubeSat software update procedures.\n\nIndex Terms:\n\nAuthentication, CubeSat, Data Freshness, Integrity, Secure Software Update.\n\nI Introduction\n\nSpace exploration and deployment of satellites have become an indispensable part of modern science. These satellites serve various purposes, including navigation [1], weather forecast [2], and data collection [3]. In the past few years, CubeSat (CS) - a novel type of miniature satellite - has attracted significant interest from researchers in academia as well as industry [4]. Each CS unit measures 10√ó10√ó1010101010\\times 10\\times 1010 √ó 10 √ó 10 cubic centimeters (10‚Å¢c‚Å¢m310ùëêsuperscriptùëö310\\ cm^{3}10 italic_c italic_m start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT). The rise of CS has significantly reduced the cost associated with satellite deployment, consequently democratizing the field. In particular, the reduction in satellite deployment cost has enabled small to mid-sized companies, universities, research institutes, and even developing nations [5] to participate in space expeditions.\n\nWhile CS provides a cost-effective means for entering the satellite playground, it also introduces a new array of challenges that do not apply to traditional satellites. The fundamental reason for such unprecedented challenges is the limited availability of resources (including computing power, memory, and communication bandwidth) in CS. One such challenge within resource-constrained environments is the software update process [6], and CSs are no different. In fact, it is even more crucial to secure the software update process for CSs as they are mission-critical, where even a minute error can lead to mission failure or the complete loss of a satellite. Furthermore, it is essential for CS‚Äôs software to be modular and reusable [7].\n\nMalicious software updates can lead to unauthorized control, data manipulation, and communication interference, which can lead to severe consequences (e.g., increased risk for mission failure, lack of data integrity, even complete loss of control over CS). Moreover, unauthorized access to a satellite poses a significant risk not just to its owners, but to the broader space environment as well. As a representative example, an attacker taking control of a satellite and activating its thrusters could lead to the Kessler Syndrome [8]. Kessler Syndrome is a scenario where debris from one satellite collision spreads and hits other satellites, creating more debris in a domino effect. Such a chain reaction could potentially block access to space for decades, as observed in different simulations [9, 10]. CS commonly utilizes amateur radio frequencies for communication (i.e., UHF/VHF [11]), resulting in relatively low data rates (typically ranging from 9.6 Kbps to 100 Kbps). For instance, the daily throughput of ThingSat [12] is approximately 1500 KB [11]. Furthermore, utilizing standard cryptographic schemes to handle malicious updates is impractical since cryptographic operations tend to be expensive in terms of computational resources; making them unsuitable for CS‚Äôs resource-constrained environment.\n\nThe on-board software is one of the most critical components of any space mission. It encompasses the core capabilities of the space system, ranging from daily activities within the system (like navigation, communication, and energy management) to more specialized tasks (like data collection and processing). The effectiveness of a space system relies heavily on the correct functioning of on-board hardware and software. Post-launch, satellites may face unexpected events and operating conditions. While some issues can be mitigated via exception handling (if anticipated during initial software development), others may be fixed through software updates.\n\nOver-the-Air (OTA) updates have overwhelmingly affected various user-centric domains, e.g., smartphones, smart TVs, automobiles, and IoT devices. OTA enables manufacturers to deliver software updates remotely, eliminating the need for physical access to a device. For the end users, OTA updates offer a convenient way to receive the latest functionality without visiting the service center. For manufacturers, it provides a way to improve their products‚Äô value by delivering new features, bug fixes, and security patches on time. The importance of OTA updates extends beyond convenience. OTA updates are critical for the lifecycle management of modern devices to ensure they remain efficient, secure, and up-to-date with minor user intervention.\n\nIn this paper, we introduce CSUM, a lightweight scheme designed to enhance the security of software updates in CS. CSUM is designed to take into account the constrained hardware capabilities of CS and the limited communication bandwidth between Ground Station (GS) and CS. It aims to preserve software updates‚Äô integrity, authenticity, and freshness, thereby safeguarding CS from adversaries attempting to tamper with in-transmission software updates. Our approach advocates for using lightweight hash functions because a single public-key computation is roughly equivalent to hundreds of hash computations in processing time [16].\n\nThe major contributions of our paper are as follows:\n\n1.\n\nWe propose CSUM, a novel and lightweight scheme that utilizes hash chains to ensure authentication, integrity, and freshness for CS software update broadcasts.\n\n2.\n\nWe validate the effectiveness of CSUM via empirical evaluations of its proof of concept implementation. Our results show that CSUM can validate 50,000 consecutive updates in just 0.81 seconds.\n\n3.\n\nFurthermore, we perform a comparative analysis of different cryptographic primitives. Our analyses show that the hash-based approach outperforms the traditional mechanisms even in resource-constrained environments. In particular, encryption, decryption, signing, and signature verification operations are over 155, 126, 64, and 61 times slower than the hash-based approach, respectively.\n\nOrganization: Section II provides an overview of the related research works and background knowledge. We discuss our system and adversary model along with security requirements in Section III, elaborate CSUM in Section IV, and discuss our results in Section V. We present CSUM‚Äôs security analysis in Section VI. Section VII highlights the potential limitations of our proposed solution. Finally, Section VIII concludes the paper and highlights the possible future directions for CS software update procedure.\n\nII Background\n\nSection II-A delves into the advancements in securing space systems, particularly through OTA software updates, and highlights the challenges in securing software updates in resource-constrained environments. Section II-B introduces cryptographic fundamentals essential for our proposed scheme.\n\nII-A Related works\n\nThe security of space-based assets (like CS) has not been extensively researched as their terrestrial counterparts (like connected vehicles), especially concerning OTA software updates. Recently, researchers have been looking into CS security, focusing on the unique challenges posed by the limited resources available on such platforms. Halder et al. [17] underlines the significance of OTA updates and categorizes existing OTA update techniques for connected vehicles. Various secure update techniques for connected vehicles have been developed to address integrity, authenticity, and confidentiality. These techniques include Uptane [18], a secure software repository framework that enhances compromise resilience by distributing responsibilities across distinct roles. Blockchain-based schemes [19] eliminate cloud involvement and utilize smart contracts to ensure update integrity and authenticity, while hash function-based protocols [20] safeguard the transmission integrity of software updates. Frameworks, such as SecUp [21], utilize a combination of symmetric and asymmetric key cryptography to ensure secure and efficient OTA updates. Moreover, hardware-based solutions leveraging Hardware Security Modules (HSM) [22] and Trusted Platform Modules (TPM) [23] provide robust security at hardware-level.\n\nSouza et al. [24] emphasize the difficulties in implementing secure software updates due to these resource constraints, proposing a multi-layered mission software approach for CS. Similarly, Bellissimo et al. [6] highlights the challenges in securing software updates in deployed systems, complexities in safeguarding against known attacks, and the challenges of applying secure content distribution methods in resource-limited devices. Willbold et al. [25] offers a comprehensive threat taxonomy against satellite firmware, including an analysis of real-world satellite firmware security issues and a survey among professional satellite developers to shed light on the satellite security landscape.\n\nThe authors in [26, 27, 11] discuss different firmware update mechanisms for an in-orbit CS. S√ºnter et al. [27] explore firmware updating systems for nano-satellites using the ESTCube-1 mission [28] to compare four distinct update procedures, highlighting their implementation complexities and error recovery mechanisms for in-orbit satellite software management. Fitzsimmons [26] improves CS robustness through a software update mechanism, focusing on update usability, validation, and system recovery to extend mission capabilities and safeguard against operational anomalies. The author utilizes MD5 for integrity, but the scheme does not address authentication. Bezem and Fjellby [29] tackle the absence of inherent security features in satellite communications by enhancing the CS Space Protocol with HMAC and sequence numbers to prevent replay attacks. However, apart from focusing exclusively on replay attacks, the scheme also requires secure infrastructure, which is comparatively costly. Molina et al. [11] addresses secure software updates for multi-tenant CS through Cubedate, a framework designed for continuous software deployment to orbiting CS. Despite its innovative approach, the framework relies on digital signatures and encryption, raising concerns about computational feasibility in the constrained environment, alongside its dependence on a single trust anchor. Challa et al. [30] proposed CubeSec and GndSec, lightweight security solutions for CS communications, acknowledging the need for efficient security measures in resource-constrained environments. However, the security of their approach relies heavily on pre-shared keys as they utilize symmetric encryption.\n\nIn traditional pre-shared key systems, all security properties are lost once the key (or trust anchor) is compromised. In our approach, even if a CS is compromised, adversaries can only validate tokens and read the next one when it comes; they cannot create the next key due to the pre-image resistance of cryptographic hash functions. This significantly limits the damage an adversary can do as long as they can only read the trust anchor and not replace it.\n\nTo summarize, using standard cryptographic primitives (i.e., encryption in CubeSec [30], CubeDate [11], and GndSec [30] as well as digital signatures in CubeDate [11] and NUTS [29]) make state-of-the-art CS security solutions computationally expensive. CSUM overcomes computational overheads by limiting the use of public-key operations to just one instance (i.e., to create a one-time trust anchor) and utilizing lightweight hash function in subsequent operations.\n\nII-B Prerequisites\n\nII-B1 Cryptographic hash function\n\nA hash function transforms a message of any length into a random-looking fixed-size string. For a hash function to be considered a cryptographic hash function, it must contain three properties:\n\n‚Ä¢\n\nPre-image resistance: Given a hash function output HùêªHitalic_H, it should be computationally infeasible to find input value mùëömitalic_m such that h‚Å¢(m)=H‚Ñéùëöùêªh(m)=Hitalic_h ( italic_m ) = italic_H.\n\n‚Ä¢\n\nSecond pre-image resistance: Given an input value m1subscriptùëö1m_{1}italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, it should be computationally infeasible to find a different input value m2subscriptùëö2m_{2}italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT such that h‚Å¢(m1)=h‚Å¢(m2),where ‚Å¢m1‚â†m2formulae-sequence‚Ñésubscriptùëö1‚Ñésubscriptùëö2where subscriptùëö1subscriptùëö2h(m_{1})=h(m_{2}),\\text{where }m_{1}\\neq m_{2}italic_h ( italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) = italic_h ( italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) , where italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ‚â† italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT.\n\n‚Ä¢\n\nCollision resistance: It should be computationally infeasible to find two distinct inputs m1subscriptùëö1m_{1}italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and m2subscriptùëö2m_{2}italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT such that h‚Å¢(m1)=h‚Å¢(m2)‚Ñésubscriptùëö1‚Ñésubscriptùëö2h(m_{1})=h(m_{2})italic_h ( italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) = italic_h ( italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ).\n\nII-B2 Hash chain\n\nHash chain utilizes a cryptographic hash function to create a linked chain of hashes. A hash chain is constructed by recursively applying a cryptographic hash function to a randomly generated seed as shown in Figure 1. Hash chains inherently inherit the properties of cryptographic hash functions while also exhibiting their own unique characteristics due to their iterative structure.\n\nIII System architecture and threat model\n\nIn this section, we outline the system model (cf. Section III-A), describe the adversary model for CSUM (cf. Section III-B), and specified the security requirements for CS (cf. Section. III-C).\n\nIII-A System model\n\nCSUM focuses on ensuring the secure delivery of Software Update Package (S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P) from GS to CS while considering the inherent vulnerabilities of the communication systems linking them. Our system model comprises three primary entities: administrator, GS, and CS. The administrator plays a pivotal role in the initial setup by generating a seed to create a hash chain, which acts as a trust anchor and lays the foundation for secure communication. The administrator is also responsible for creating S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps and corresponding Transmission Token (T‚Å¢TùëáùëáTTitalic_T italic_T), which are essential for authorizing updates. GS is responsible for transmitting S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps and its corresponding T‚Å¢TùëáùëáTTitalic_T italic_Ts received from the administrator to CS. CS is tasked with the reception and verification of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P and their accompanying T‚Å¢TùëáùëáTTitalic_T italic_Ts, ensuring the security of the deployment process. CS is equipped to perform critical cryptographic operations despite its limited resources.\n\nThe communication link between GS and CS is inherently insecure but reliable and susceptible to threats such as replay attacks, message alteration, and injection. Despite these challenges, both the administrator and CS are considered secure entities with secure internal storage capabilities to resist direct attacks. Operating within a constrained environment, CS must efficiently manage its limited bandwidth, processing capabilities, and storage, highlighting the need for streamlined and lightweight security solutions. A reliable transfer protocol, like Saratoga protocol [31], can mitigate issues related to packet losses and propagation delay. Our proposed scheme is agnostic to transport mechanisms as long as we transmit both S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P and the corresponding T‚Å¢TùëáùëáTTitalic_T italic_T.\n\nFigure 2 illustrates a communication system where the administrator interacts with the Ground Station over the Internet, with the potential for both secure and insecure data transmission. However, the communication between the Ground Station and the CS is insecure.\n\nIII-B Adversary Model\n\nOur adversary model considers a highly capable adversary with computational resources surpassing those typically available in a CS environment. The adversary operates within Probabilistic Polynomial Time (PPT) and targets vulnerabilities primarily within the communication framework connecting GS and CS. We assume that the trusted components in the overall CS infrastructure, including the administrator, CS, and GS, remain secure throughout the system‚Äôs operational life.\n\nThe adversary possesses a diverse array of attack capabilities to compromise software updates between GS and CS. These capabilities include passive eavesdropping on the communication channel, active interception and data manipulation to facilitate Man-in-the-Middle attacks, executing replay attacks by re-transmitting legitimate S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P, injecting malicious S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P, and overwhelming CS (and its verification capacity) by flooding CS with fake S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P and T‚Å¢TùëáùëáTTitalic_T italic_T.\n\nThe adversary‚Äôs objectives include disrupting genuine communication, deceiving CS into accepting malicious S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps, extracting sensitive information from transmitted messages, and wasting CS resources. Despite these capabilities, the adversary is bound by PPT, which restricts its ability to break strong cryptographic systems within a reasonable time frame. Additionally, the adversary is incapable of altering the initially trusted data placed in a CS (e.g., trust anchor).\n\nIII-C Security Goals\n\nThe primary objective of CSUM is to secure the transmission of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps from GS to CS against threats on insecure channels. We aim to achieve the following critical security goals [32]:\n\n1.\n\nAuthentication: To ensure that S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps originate from a verified source, CSUM incorporates the use of authentication tokens. This mechanism ensures that only authorized entities can initiate software updates.\n\n2.\n\nIntegrity: CSUM is designed to detect any unauthorized modifications in S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps received by CS. Thereby safeguarding the integrity of the transmitted data.\n\n3.\n\nData freshness: It is crucial that CS receives the most recent S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P. CSUM mitigates the risk of replayed attacks by adversaries, ensuring that only the latest valid S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P are installed.\n\nIV Proposed Scheme\n\nCS is designed to operate under limited resources, e.g., extremely low bandwidth, constrained memory, and minimal processing power. Formulating effective security strategies within these constraints is non-trivial and presents a significant challenge. These constraints force us to move away from traditional cryptographic mechanisms that are robust but resource-intensive. Thus, such mechanisms are impractical for low-resource environments, like CS. In contrast, cryptographic hash functions emerge as a better solution due to their significantly lower computational overheads [16]. CSUM utilizes a lightweight hash function to ensure the authentication and integrity of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps sent from GS to CS.\n\nCSUM aims to minimize reliance on resource-intensive public-key operations and replace them with efficient hash operations instead. This approach holds significant advantages for CS due to the lightweight nature of hash functions compared to encryption and signature schemes. The proposed scheme aims to achieve authentication, integrity, and freshness with constant network overhead (i.e., output length of a single hash function).\n\nNow we elucidate different phases (cf. Section IV-A) and operations (cf. Section IV-B) in CSUM. We also present a sample execution of CSUM in Section IV-C.\n\nIV-A Phases\n\nCSUM involves setup, key encapsulation, and authentication and integrity phases. We utilize several symbols as defined in TABLE I while explaining CSUM.\n\nIV-A1 Setup phase\n\nThe setup phase initializes the system, where the administrator employs a hardware random number generator [33] to produce a random seed. The generated seed undergoes iterative hashing to form a hash chain [34]. The resulting tip, hn‚Å¢(s‚Å¢e‚Å¢e‚Å¢d)superscript‚Ñéùëõùë†ùëíùëíùëëh^{n}(seed)italic_h start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( italic_s italic_e italic_e italic_d ), is stored in CS memory as a Trust Anchor (T‚Å¢Aùëáùê¥TAitalic_T italic_A) for subsequent operations.\n\nPrior to launch, storing T‚Å¢Aùëáùê¥TAitalic_T italic_A in CS is straightforward. Post-launch introduces considerations for secure transmission. Confidentiality is ensured through pre-existing mechanisms supporting confidentiality, allowing direct transfer of T‚Å¢Aùëáùê¥TAitalic_T italic_A without additional security layers. Encryption becomes necessary only when the default mechanism lacks confidentiality support despite the additional overhead.\n\nIV-A2 Key encapsulation phase\n\nThe key encapsulation phase conceals a one-time Authentication Token (AT) without utilizing encryption techniques. Our key encapsulation involves a bitwise XOR operation (‚äïdirect-sum\\oplus‚äï) between the current A‚Å¢Tùê¥ùëáATitalic_A italic_T (i.e., A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT) and the result of applying a cryptographic hash function (h‚Ñéhitalic_h) to the concatenation of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P and the previous A‚Å¢Tùê¥ùëáATitalic_A italic_T (i.e., A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT) as shown in Eq. (1).\n\nT‚Å¢T‚âîA‚Å¢Tc‚Å¢u‚Å¢r‚Å¢r‚äïh‚Å¢(S‚Å¢U‚Å¢P‚à•A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢v)‚âîùëáùëádirect-sumùê¥subscriptùëáùëêùë¢ùëüùëü‚Ñé‚à•ùëÜùëàùëÉùê¥subscriptùëáùëùùëüùëíùë£TT\\coloneqq AT_{curr}\\oplus h(SUP\\mathbin{\\|}AT_{prev})italic_T italic_T ‚âî italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT ‚äï italic_h ( italic_S italic_U italic_P ‚à• italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT ) (1)\n\nIn simpler terms, we combine A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT with a hashed value derived from the concatenation of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P and A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT to generate T‚Å¢TùëáùëáTTitalic_T italic_T. Figure 3 shows interconnection between subsequent T‚Å¢TùëáùëáTTitalic_T italic_Ts.\n\nIV-A3 Authentication and integrity phase\n\nThe authentication and integrity phase is crucial in ensuring the secure transmission of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps from GS to CS. This phase links T‚Å¢TùëáùëáTTitalic_T italic_T to A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT, S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P, and A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT (previous state of hash chain) while confirming the validity of A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT. CSUM ensures integrity by associating the hash of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P to T‚Å¢TùëáùëáTTitalic_T italic_T as shown in Eq. (1). Any attempt by an adversary to alter S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P results in CS failing to extract the correct A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT from T‚Å¢TùëáùëáTTitalic_T italic_T, leading to the rejection of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P. A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT verification requires a single hash operation, as shown in Eq. (2).\n\nh‚Å¢(A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢r)=A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢v‚Ñéùê¥subscriptùëáùëêùë¢ùëüùëüùê¥subscriptùëáùëùùëüùëíùë£h(AT_{curr})=AT_{prev}italic_h ( italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT ) = italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT (2)\n\nOverall, the proposed scheme leverages hash functions to ensure authentication and integrity in a resource-constrained environment, making it suitable for CS with limited bandwidth, processing power, and memory. The hash chain and T‚Å¢TùëáùëáTTitalic_T italic_T mechanisms provide a lightweight yet effective approach to secure software updates in the presence of potential adversaries and insecure communication channels.\n\nIV-B Operations\n\nThis section explains the tasks executed by the administrator, GS, and CS within the proposed scheme. Figure 4 presents a sequence diagram that illustrates CSUM for securely installing software updates on CSs.\n\nIV-B1 Administrator operation\n\nSeveral crucial tasks are undertaken to ensure the proper functioning of CSUM at the administrator‚Äôs end. These tasks include generating a hash chain and creating a S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P with the corresponding T‚Å¢TùëáùëáTTitalic_T italic_T. The administrator initializes the scheme by generating a random seed; the generated seed is hashed iteratively to create a hash chain. Each S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P sent to CS is accompanied by its corresponding T‚Å¢TùëáùëáTTitalic_T italic_T, formulated as shown in Eq. (1). Algorithm 1 presents the pseudocode for T‚Å¢TùëáùëáTTitalic_T italic_T generation by the administrator for each S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P.\n\nThe administrator and GS can communicate in an encrypted or plain text manner. However, we require an integrity mechanism while sending S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps without encryption. We especially require an encrypted connection between the administrator and GS only while sending T‚Å¢Aùëáùê¥TAitalic_T italic_A during the initial setup phase. For regular S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps, the administrator creates and sends S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P and the corresponding T‚Å¢TùëáùëáTTitalic_T italic_T to the GS. Algorithm 1 details the psuedocode for this case.\n\nIV-B2 Ground station operations\n\nGS receives S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P and T‚Å¢TùëáùëáTTitalic_T italic_T from the administrator. It forwards both S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P and T‚Å¢TùëáùëáTTitalic_T italic_T to CS in unencrypted form. GS has more resources than CS in terms of computational power. It enables GS to manage communication links with multiple satellites simultaneously and process large amounts of data transmitted from such satellites.\n\nIV-B3 CubeSat operations\n\nCS extracts both S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P and its corresponding T‚Å¢TùëáùëáTTitalic_T italic_T from a transmission received from the GS. Subsequently, CS deciphers A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT using received S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P, T‚Å¢TùëáùëáTTitalic_T italic_T and A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT, using Eq. (3).\n\nA‚Å¢Tc‚Å¢u‚Å¢r‚Å¢r‚âîT‚Å¢T‚äïh‚Å¢(S‚Å¢U‚Å¢P‚à•A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢v)‚âîùê¥subscriptùëáùëêùë¢ùëüùëüdirect-sumùëáùëá‚Ñé‚à•ùëÜùëàùëÉùê¥subscriptùëáùëùùëüùëíùë£\\displaystyle AT_{curr}\\coloneqq TT\\oplus h(SUP\\mathbin{\\|}AT_{prev})italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT ‚âî italic_T italic_T ‚äï italic_h ( italic_S italic_U italic_P ‚à• italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT ) (3)\n\nFollowing token extraction, CS verifies the authenticity of deciphered A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT by comparing its hash with A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT as shown in Eq. (2). Successful verification confirms the integrity and authenticity of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P, and thus, CS installs S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P and updates A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT. Algorithm 2 provides psuedocode for AT extraction, AT verification, and S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P installation at CS.\n\nThe flowchart depicted in Figure 5 outlines the verification procedure for T‚Å¢TùëáùëáTTitalic_T italic_T at CS. If CS receive S‚Å¢U‚Å¢Ps‚Å¢e‚Å¢n‚Å¢tùëÜùëàsuperscriptùëÉùë†ùëíùëõùë°SUP^{sent}italic_S italic_U italic_P start_POSTSUPERSCRIPT italic_s italic_e italic_n italic_t end_POSTSUPERSCRIPT and T‚Å¢TùëáùëáTTitalic_T italic_T without any modification to S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P or T‚Å¢TùëáùëáTTitalic_T italic_T during transmission then S‚Å¢U‚Å¢Ps‚Å¢e‚Å¢n‚Å¢t=S‚Å¢U‚Å¢Pr‚Å¢e‚Å¢cùëÜùëàsuperscriptùëÉùë†ùëíùëõùë°ùëÜùëàsuperscriptùëÉùëüùëíùëêSUP^{sent}=SUP^{rec}italic_S italic_U italic_P start_POSTSUPERSCRIPT italic_s italic_e italic_n italic_t end_POSTSUPERSCRIPT = italic_S italic_U italic_P start_POSTSUPERSCRIPT italic_r italic_e italic_c end_POSTSUPERSCRIPT, D‚Å¢T=A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê∑ùëáùê¥subscriptùëáùëêùë¢ùëüùëüDT=AT_{curr}italic_D italic_T = italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT. Here, t‚Å¢o‚Å¢k‚Å¢e‚Å¢nùë°ùëúùëòùëíùëõtokenitalic_t italic_o italic_k italic_e italic_n is a local variable stored in CS such that other parties are unable to access it.\n\nIV-C Sample execution\n\nWe now present a sample execution of CSUM to illustrate its working better. Consider a hash chain of size three as depicted in Figure 6. After hashing the seed thrice, the administrator obtains T3subscriptùëá3T_{3}italic_T start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT, which is securely stored on CS in the t‚Å¢o‚Å¢k‚Å¢e‚Å¢nùë°ùëúùëòùëíùëõtokenitalic_t italic_o italic_k italic_e italic_n variable as its T‚Å¢Aùëáùê¥TAitalic_T italic_A (prior to CS‚Äôs launch in space). Given the hash chain has a length of three, it can support two successful software updates in CSUM. During such updates, two distinct S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P are broadcast to CS. TABLE II lists the computations at both the administrator and CS for each update iteration.\n\n1s‚Å¢tsuperscript1ùë†ùë°1^{st}1 start_POSTSUPERSCRIPT italic_s italic_t end_POSTSUPERSCRIPT software update: The administrator prepares S‚Å¢U‚Å¢P=s‚Å¢w‚Å¢1ùëÜùëàùëÉùë†ùë§1SUP=sw1italic_S italic_U italic_P = italic_s italic_w 1 and generates T‚Å¢T=T2‚äïh‚Å¢(s‚Å¢w‚Å¢1‚à•T3)ùëáùëádirect-sumsubscriptùëá2‚Ñé‚à•ùë†ùë§1subscriptùëá3TT=T_{2}\\oplus h(sw1\\mathbin{\\|}T_{3})italic_T italic_T = italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ‚äï italic_h ( italic_s italic_w 1 ‚à• italic_T start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ) as described in Eq. (1). Here, A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢r=T2ùê¥subscriptùëáùëêùë¢ùëüùëüsubscriptùëá2AT_{curr}=T_{2}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT = italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢v=T3ùê¥subscriptùëáùëùùëüùëíùë£subscriptùëá3AT_{prev}=T_{3}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT = italic_T start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT. Upon receiving a software update, CS creates P‚Å¢T=h‚Å¢(S‚Å¢U‚Å¢Pr‚Å¢e‚Å¢c‚à•t‚Å¢o‚Å¢k‚Å¢e‚Å¢n)ùëÉùëá‚Ñé‚à•ùëÜùëàsuperscriptùëÉùëüùëíùëêùë°ùëúùëòùëíùëõPT=h(SUP^{rec}\\mathbin{\\|}token)italic_P italic_T = italic_h ( italic_S italic_U italic_P start_POSTSUPERSCRIPT italic_r italic_e italic_c end_POSTSUPERSCRIPT ‚à• italic_t italic_o italic_k italic_e italic_n ) and uses it to derive D‚Å¢T=T‚Å¢T‚äïP‚Å¢Tùê∑ùëádirect-sumùëáùëáùëÉùëáDT=TT\\oplus PTitalic_D italic_T = italic_T italic_T ‚äï italic_P italic_T as specified in Eq. (3). If S‚Å¢U‚Å¢Pr‚Å¢e‚Å¢cùëÜùëàsuperscriptùëÉùëüùëíùëêSUP^{rec}italic_S italic_U italic_P start_POSTSUPERSCRIPT italic_r italic_e italic_c end_POSTSUPERSCRIPT is equal to s‚Å¢w‚Å¢1ùë†ùë§1sw1italic_s italic_w 1, then D‚Å¢Tùê∑ùëáDTitalic_D italic_T resolves to T2subscriptùëá2T_{2}italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT (matching A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT). With D‚Å¢T=T2ùê∑ùëásubscriptùëá2DT=T_{2}italic_D italic_T = italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and t‚Å¢o‚Å¢k‚Å¢e‚Å¢n=T3ùë°ùëúùëòùëíùëõsubscriptùëá3token=T_{3}italic_t italic_o italic_k italic_e italic_n = italic_T start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT, CS checks whether h‚Å¢(D‚Å¢T)=t‚Å¢o‚Å¢k‚Å¢e‚Å¢n‚Ñéùê∑ùëáùë°ùëúùëòùëíùëõh(DT)=tokenitalic_h ( italic_D italic_T ) = italic_t italic_o italic_k italic_e italic_n to authenticate S‚Å¢U‚Å¢Pr‚Å¢e‚Å¢cùëÜùëàsuperscriptùëÉùëüùëíùëêSUP^{rec}italic_S italic_U italic_P start_POSTSUPERSCRIPT italic_r italic_e italic_c end_POSTSUPERSCRIPT (cf. Eq. (2)). Given the relationship between T2subscriptùëá2T_{2}italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and T3subscriptùëá3T_{3}italic_T start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT (cf. Figure 6), the verification is successful. CS now installs s‚Å¢w1ùë†subscriptùë§1sw_{1}italic_s italic_w start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and updates its t‚Å¢o‚Å¢k‚Å¢e‚Å¢n=T2ùë°ùëúùëòùëíùëõsubscriptùëá2token=T_{2}italic_t italic_o italic_k italic_e italic_n = italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT.\n\n2n‚Å¢dsuperscript2ùëõùëë2^{nd}2 start_POSTSUPERSCRIPT italic_n italic_d end_POSTSUPERSCRIPT software update: The administrator prepares S‚Å¢U‚Å¢P=s‚Å¢w‚Å¢2ùëÜùëàùëÉùë†ùë§2SUP=sw2italic_S italic_U italic_P = italic_s italic_w 2 and calculates T‚Å¢T=T1‚äïh‚Å¢(s‚Å¢w‚Å¢2‚à•T2)ùëáùëádirect-sumsubscriptùëá1‚Ñé‚à•ùë†ùë§2subscriptùëá2TT=T_{1}\\oplus h(sw2\\mathbin{\\|}T_{2})italic_T italic_T = italic_T start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ‚äï italic_h ( italic_s italic_w 2 ‚à• italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ). Now, A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢r=T1ùê¥subscriptùëáùëêùë¢ùëüùëüsubscriptùëá1AT_{curr}=T_{1}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT = italic_T start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢v=T2ùê¥subscriptùëáùëùùëüùëíùë£subscriptùëá2AT_{prev}=T_{2}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT = italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Upon receiving a software update, CS calculate P‚Å¢T=h‚Å¢(S‚Å¢U‚Å¢Pr‚Å¢e‚Å¢c‚à•t‚Å¢o‚Å¢k‚Å¢e‚Å¢n)ùëÉùëá‚Ñé‚à•ùëÜùëàsuperscriptùëÉùëüùëíùëêùë°ùëúùëòùëíùëõPT=h(SUP^{rec}\\mathbin{\\|}token)italic_P italic_T = italic_h ( italic_S italic_U italic_P start_POSTSUPERSCRIPT italic_r italic_e italic_c end_POSTSUPERSCRIPT ‚à• italic_t italic_o italic_k italic_e italic_n ) and use it to derive D‚Å¢T=T‚Å¢T‚äïP‚Å¢Tùê∑ùëádirect-sumùëáùëáùëÉùëáDT=TT\\oplus PTitalic_D italic_T = italic_T italic_T ‚äï italic_P italic_T. If S‚Å¢U‚Å¢Pr‚Å¢e‚Å¢cùëÜùëàsuperscriptùëÉùëüùëíùëêSUP^{rec}italic_S italic_U italic_P start_POSTSUPERSCRIPT italic_r italic_e italic_c end_POSTSUPERSCRIPT is equal to s‚Å¢w‚Å¢2ùë†ùë§2sw2italic_s italic_w 2, then D‚Å¢Tùê∑ùëáDTitalic_D italic_T resolves to T1subscriptùëá1T_{1}italic_T start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT (matching A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT). With D‚Å¢T=T1ùê∑ùëásubscriptùëá1DT=T_{1}italic_D italic_T = italic_T start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and t‚Å¢o‚Å¢k‚Å¢e‚Å¢n=T2ùë°ùëúùëòùëíùëõsubscriptùëá2token=T_{2}italic_t italic_o italic_k italic_e italic_n = italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, CS checks whether h‚Å¢(D‚Å¢T)=t‚Å¢o‚Å¢k‚Å¢e‚Å¢n‚Ñéùê∑ùëáùë°ùëúùëòùëíùëõh(DT)=tokenitalic_h ( italic_D italic_T ) = italic_t italic_o italic_k italic_e italic_n to authenticate S‚Å¢U‚Å¢Pr‚Å¢e‚Å¢cùëÜùëàsuperscriptùëÉùëüùëíùëêSUP^{rec}italic_S italic_U italic_P start_POSTSUPERSCRIPT italic_r italic_e italic_c end_POSTSUPERSCRIPT. Given the relationship between T1subscriptùëá1T_{1}italic_T start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and T2subscriptùëá2T_{2}italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, the verification is successful. CS now installs s‚Å¢w2ùë†subscriptùë§2sw_{2}italic_s italic_w start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and updates its t‚Å¢o‚Å¢k‚Å¢e‚Å¢n=T1ùë°ùëúùëòùëíùëõsubscriptùëá1token=T_{1}italic_t italic_o italic_k italic_e italic_n = italic_T start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT.\n\nTo summarize, CSUM sends A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT to CS in such a way that only CS that has the knowledge of corresponding A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT can extract it.\n\nV Experimental Evaluation\n\nWe performed experiments on a Lenovo ThinkPad P14s Gen 2 machine. We implemented our proposed scheme using python 3.7 and utilized four common open-source packages including Putty, Notepad++, FileZilla, and Audacity with sizes <<< 16 MB to simulate S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P being sent to CS.\n\nEncryption/decryption-based schemes are traditionally employed to provide authentication, confidentiality, and integrity. However, they may not inherently guarantee data freshness, which is crucial to prevent replay attacks. Moreover, decryption operations at CS can impose a significant computational burden. Signature-based schemes primarily focus on ensuring authentication and integrity with the potential to provide freshness depending on the specific implementation. However, signature verification operations at CS can also introduce computational overhead.\n\nTo this end, we designed an experiment with different commonly used software applications, including Putty v0.80 [35], NotePad++ v8.6 [36], FileZilla v3.66.4 [37], and Audacity v3.4.2 [38]. We performed the following cryptographic operations: encryption, decryption, signature generation, signature verification, and hashing on these open-source software packages to collect timing data. We utilize RSA with a 2048-bit key with PSS padding [39] for signing, AES with a 256-bit key in CBC mode for encryption, and SHA-256 for hashing. We used hazmat layer from the Python cryptography library [40] to implement cryptographic primitives. The results are shown in Figure 7. Encryption, signature generation, and hashing operations are performed at administrator (without any resource limitation) while decryption, signature verification, and hashing operation are done at CS (with limited resources).\n\nAs shown in Figure 7, we observe that hashing operations are consistently the fastest across various file sizes, taking only 0.000161s for a 1.58 MB file, 0.000564s for a 4.59 MB file, 0.000313s for a 12.22 MB file, and 0.000110s for a 15.09 MB file. Signature verification, a process that ensures data integrity and authenticity, is more time-consuming than hashing, with times ranging from 0.001681s for the smallest file to 0.019880s for the largest file. Decryption times, which ensures confidentiality, data integrity and authenticity, is even more expensive then signature verification, requiring 0.003326s for the smallest file and scaling up to 0.040679s for the largest tested file.\n\nWe have taken previous literature and our results into account and decided to utilize hash-based mechanism to design CSUM. CSUM takes a different approach by employing a hash-based mechanism, which inherently assures authentication, integrity, and freshness while using a hash chain. Freshness is assured by the sequential nature of the hash chain, which prevents the reuse of old hashes. CSUM simplifies the verification process by requiring only a single hash operation at CS, significantly reducing computational overhead.\n\nPerformance: TABLE LABEL:tab:hashchain_performance shows the performance analysis of the hash chain, particularly, the time taken to generate the hash chain and the verification time. CSUM takes less than 0.01s to generate a hash chain for 10,000 updates, and it gradually increases to 0.056s for 50,000 updates. This rise indicates a proportional increment in the computational load associated with a larger number of targeted updates. Naturally, the number of targeted updates directly affects to number of times our system has to hash the seed to create the hash chain. On another side, verifying 10,000 updates requires about 0.18s, which increases to 0.805s for 50,000 updates. This increase is steeper since more operations are involved in verifying S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps than in generating a hash chain. Overall, both the hash chain generation time and verification of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps grow linearly with the number of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps.\n\nNetwork overhead: The network overhead in our approach is independent of the size of a S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P, and it is determined by the fixed output length of the utilized hash function, i.e., 256 bits in our implementation. Therefore, our proposed scheme has a constant network overhead.\n\nVI Security Analysis\n\nFigure 8 outlines security features provided by different components of CSUM‚Äôs T‚Å¢TùëáùëáTTitalic_T italic_T. In particular, T‚Å¢TùëáùëáTTitalic_T italic_T integrates authentication with A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT, ensures the integrity of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P through hashing, and maintains freshness with hash chain continuity. This approach effectively safeguards against unauthorized access and data manipulation. To summarize, CSUM leverages a hash chain for generating A‚Å¢Tùê¥ùëáATitalic_A italic_T and embeds A‚Å¢Tùê¥ùëáATitalic_A italic_T within T‚Å¢TùëáùëáTTitalic_T italic_T to preserve authenticity, integrity, and freshness for each S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P transmission.\n\nVI-A Authentication\n\nAuthentication is facilitated by utilizing A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT, which is known only to the legitimate entities involved in the software update process. In CSUM, each A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT is cryptographically linked to A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT as shown in Eq. (2), preventing adversaries from determining the pre-image of A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT in polynomial time without breaking pre-image resistance property of a cryptographic hash function. Including A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT within T‚Å¢TùëáùëáTTitalic_T italic_T enables CS to verify the origin of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P, preventing impersonation and unauthorized access.\n\nSuccessfully guessing A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT allows the recovery of A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT, enabling an adversary to create a valid T‚Å¢TùëáùëáTTitalic_T italic_T for their altered update. However, the likelihood of accurately guessing A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT is extremely low, i.e., 1/22561superscript22561/2^{256}1 / 2 start_POSTSUPERSCRIPT 256 end_POSTSUPERSCRIPT. Alternatively, correctly guessing A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT permits the extraction of A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT, not by deriving pre-image but by employing Eq. (3). However, the probability of guessing A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT remains similarly low.\n\nVI-B Integrity\n\nThe integrity of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P is maintained by incorporating the hash of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P concatenated with A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT in a T‚Å¢TùëáùëáTTitalic_T italic_T, rendering T‚Å¢TùëáùëáTTitalic_T italic_T update specific. Any changes in S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P data would result in a distinct hash output, generating different T‚Å¢TùëáùëáTTitalic_T italic_T and an invalid A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT as depicted in Eq. (2). If Eq. (2) is not satisfied during verification at CS, it indicates tampering with S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P, leading to rejection. Now we delve into a brief proof-by-contradiction for asserting ‚ÄúAny unauthorized modification to S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P is detectable.‚Äù\n\n‚Ä¢\n\nAssume an adversary can make an undetectable modification to S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P.\n\n‚Ä¢\n\nAn undetectable modification implies that after altering S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P, the resulting T‚Å¢TùëáùëáTTitalic_T italic_T is still valid, i.e., T‚Å¢T‚âîA‚Å¢Tc‚Å¢u‚Å¢r‚Å¢r‚äïh‚Å¢(S‚Å¢U‚Å¢P‚Ä≤‚à•A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢v)‚âîùëáùëádirect-sumùê¥subscriptùëáùëêùë¢ùëüùëü‚Ñé‚à•ùëÜùëàsuperscriptùëÉ‚Ä≤ùê¥subscriptùëáùëùùëüùëíùë£TT\\coloneqq AT_{curr}\\oplus h(SUP^{\\prime}\\mathbin{\\|}AT_{prev})italic_T italic_T ‚âî italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT ‚äï italic_h ( italic_S italic_U italic_P start_POSTSUPERSCRIPT ‚Ä≤ end_POSTSUPERSCRIPT ‚à• italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT ).\n\n‚Ä¢\n\nThis requires h‚Å¢(S‚Å¢U‚Å¢P‚à•A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢v)=h‚Å¢(S‚Å¢U‚Å¢P‚Ä≤‚à•A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢v)‚Ñé‚à•ùëÜùëàùëÉùê¥subscriptùëáùëùùëüùëíùë£‚Ñé‚à•ùëÜùëàsuperscriptùëÉ‚Ä≤ùê¥subscriptùëáùëùùëüùëíùë£h(SUP\\mathbin{\\|}AT_{prev})=h(SUP^{\\prime}\\mathbin{\\|}AT_{prev})italic_h ( italic_S italic_U italic_P ‚à• italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT ) = italic_h ( italic_S italic_U italic_P start_POSTSUPERSCRIPT ‚Ä≤ end_POSTSUPERSCRIPT ‚à• italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT ). However, finding such S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P‚Ä≤, where h‚Å¢(S‚Å¢U‚Å¢P‚à•A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢v)‚Ñé‚à•ùëÜùëàùëÉùê¥subscriptùëáùëùùëüùëíùë£h(SUP\\mathbin{\\|}AT_{prev})italic_h ( italic_S italic_U italic_P ‚à• italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT ) is equal to h‚Å¢(S‚Å¢U‚Å¢P‚Ä≤‚à•A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢v)‚Ñé‚à•ùëÜùëàsuperscriptùëÉ‚Ä≤ùê¥subscriptùëáùëùùëüùëíùë£h(SUP^{\\prime}\\mathbin{\\|}AT_{prev})italic_h ( italic_S italic_U italic_P start_POSTSUPERSCRIPT ‚Ä≤ end_POSTSUPERSCRIPT ‚à• italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT ) breaks second pre-image resistance of a cryptographic hash function.\n\nOur assumption leads to a contradiction, establishing that integrity in CSUM is maintained via detection of modifications.\n\nVI-C Freshness\n\nFreshness is ensured by leveraging the sequential nature of the hash chain used to generate A‚Å¢Tùê¥ùëáATitalic_A italic_T. Since each A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT is used only once and is replaced by the next in the hash chain for the subsequent update, ensuring that each T‚Å¢TùëáùëáTTitalic_T italic_T is unique. We are utilizing each token in the hash chain as a one-time password. CS verifies Eq. (2) to ascertain the freshness of an update, mitigating replay attacks where adversaries attempt to resend old S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps with previously valid T‚Å¢TùëáùëáTTitalic_T italic_Ts.\n\nAttack prevention: CSUM inherently protects against common attacks including:\n\n1.\n\nReplay attacks: CSUM utilizes one-time tokens derived from a hash chain, making it resistant to replay attacks. CS rejects previously captured S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P along with their respective T‚Å¢TùëáùëáTTitalic_T italic_Ts as they fail to correct A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT, leading to the automatic rejection of the update.\n\n2.\n\nMalicious update attacks: CSUM generates a portion of the T‚Å¢TùëáùëáTTitalic_T italic_T using a hash of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P combined with A‚Å¢Tp‚Å¢r‚Å¢e‚Å¢vùê¥subscriptùëáùëùùëüùëíùë£AT_{prev}italic_A italic_T start_POSTSUBSCRIPT italic_p italic_r italic_e italic_v end_POSTSUBSCRIPT to tackle malicious update attacks. Any modification in S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_P renders the resulting T‚Å¢TùëáùëáTTitalic_T italic_T invalid, preventing CS from deriving the correct A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT and resulting in the rejection of a malicious update.\n\n3.\n\nToken swapping attacks: CSUM is resistant to token swapping attacks as CS could not derive correct A‚Å¢Tc‚Å¢u‚Å¢r‚Å¢rùê¥subscriptùëáùëêùë¢ùëüùëüAT_{curr}italic_A italic_T start_POSTSUBSCRIPT italic_c italic_u italic_r italic_r end_POSTSUBSCRIPT from old authentic TT, leading to the automatic rejection of the outdated update.\n\nVII Limitations\n\nThe potential limitations of CSUM are as follows:\n\n1.\n\nUnique hash chain for each satellite: CSUM requires a unique hash chain for every satellite. However, it may not be an issue as the administrator and GS are resource-rich. The size of the hash chain, which the administrator generates, is minimal. For instance, storing a hash chain of length 100 requires only 3.2 KB. Moreover, the size of each token is the same as the size of the hash function output (making it suitable for the administrator, GS, and even CS). Finally, there are a finite number of satellites under the control of GS.\n\n2.\n\nRe-initialize hash chain: CSUM requires re-initializing the hash chain once all the tokens are used in the existing hash chain. Authors in [41, 42, 43] demonstrate efficient ways to re-initialize the hash chain, which can be extended to our work as well.\n\n3.\n\nLack of confidentiality: An increasing number of CS projects are moving towards open-source software [44]. The emphasis has shifted from the principle of security through obscurity towards a model that prefers transparency and collaborative security practices. Open-source projects benefit from this paradigm by allowing broader inspection and collective improvement. Therefore, the security of CSUM does not rely on concealing the software‚Äôs components but rather on the robustness of the cryptographic methods implemented.\n\nVIII Conclusion and future work\n\nThe fundamental requirements of authentication, integrity, and data freshness are essential for ensuring the security of S‚Å¢U‚Å¢PùëÜùëàùëÉSUPitalic_S italic_U italic_Ps broadcast to CS. In this paper, we propose a lightweight scheme that ensures authentication, integrity, and data freshness for CS software updates, providing a practical solution specifically tailored to the resource-constrained environment of CS. We validate the practical feasibility and efficacy of our proposed approach by developing a proof of concept. CSUM does have limitations, such as the requirement for unique hash chains for each CS and the need for hash chain re-initialization. Despite these challenges, our work significantly improves the overall security and the performance of the software update procedure for CS.\n\nIn the future, we will explore a scalable and secure group update scheme for a cluster of CSs, eliminating the need for unique A‚Å¢Tùê¥ùëáATitalic_A italic_T per satellite/update.\n\nReferences\n\n[1] W. Lechner and S. Baumann, ‚ÄúGlobal Navigation Satellite Systems,‚Äù Computers and Electronics in Agriculture, vol. 25, no. 1-2, pp. 67‚Äì85, 2000.\n\n[2] S. Kalsi, ‚ÄúSatellite based Weather Forecasting,‚Äù Satellite remote sensing and GIS applications in agricultural meteorology, vol. 331, 2002.\n\n[3] M. Antonini, A. De Luise, M. Ruggieri, and D. Teotino, ‚ÄúSatellite Data Collection & Forwarding Systems,‚Äù IEEE Aerospace and Electronic Systems Magazine, vol. 20, no. 9, pp. 25‚Äì29, 2005.\n\n[4] M. Swartwout, ‚ÄúThe First One Hundred Cubesats: A Statistical Look,‚Äù Journal of Small Satellites, vol. 2, no. 2, pp. 213‚Äì233, 2013.\n\n[5] K. Woellert, P. Ehrenfreund, A. J. Ricco, and H. Hertzfeld, ‚ÄúCubesats: Cost-effective Science and Technology Platforms for Emerging and Developing Nations,‚Äù Elsevier Advances in Space Research, vol. 47, no. 4, pp. 663‚Äì684, 2011.\n\n[6] A. Bellissimo, J. Burgess, and K. Fu, ‚ÄúSecure Software Updates: Disappointments and New Challenges,‚Äù in USENIX Workshop on Hot Topics in Security, 2006.\n\n[7] M. Eshaq, I. Al-Midfa, Z. Al-Shamsi, S. Atalla, S. Al-Mansoori, and H. Al-Ahmad, ‚ÄúFlight Software Design and Implementation for a CubeSat,‚Äù in IEEE Advances in Science and Engineering Technology International Conferences, 2023, pp. 1‚Äì6.\n\n[8] D. J. Kessler, N. L. Johnson, J. Liou, and M. Matney, ‚ÄúThe Kessler Syndrome: Implications to Future Space Operations,‚Äù Advances in the Astronautical Sciences, vol. 137, no. 8, 2010.\n\n[9] J. Pavur and I. Martinovic, ‚ÄúThe Cyber-ASAT: On the Impact of Cyber Weapons in Outer Space,‚Äù in IEEE Int. Conf. on Cyber Conflict, 2019, pp. 1‚Äì18.\n\n[10] J. Drmola and T. Hubik, ‚ÄúKessler Syndrome: System Dynamics Model,‚Äù Space Policy, pp. 29‚Äì39, 2018.\n\n[11] F.-X. Molina, E. Baccelli, K. Zandberg, D. Donsez, and O. Alphand, ‚ÄúCubedate: Securing Software Updates in Orbit for Low-Power Payloads Hosted on CubeSats,‚Äù in IFIP/IEEE Int. Conf. on Performance Evaluation and Modeling in Wired and Wireless Networks, 2023, pp. 1‚Äì6.\n\n[12] (2022) Thingsat project. CSUG - Grenoble University Space Center. [Online]. Available: https://www.csug.fr/projects/thingsat-project/\n\n[13] R. Nilchiani, ‚ÄúValuing Software-based Options for Space Systems Flexibility,‚Äù Acta Astronautica, vol. 65, no. 3-4, pp. 429‚Äì441, 2009.\n\n[14] B. Garrido, A. Garcia, N. Alfaro, and J. Asensio, ‚ÄúMINISAT01 on-board Software Maintenance,‚Äù in Data Systems in Aerospace, vol. 422, 1998, p. 65.\n\n[15] W. Marshall and C. Boshuizen, ‚ÄúPlanet Labs‚Äô Remote Sensing Satellite System,‚Äù 2013.\n\n[16] C.-S. Park, ‚ÄúOne-time Password based on Hash Chain without Shared Secret and Re-registration,‚Äù Computers & Security, vol. 75, pp. 138‚Äì146, 2018.\n\n[17] S. Halder, A. Ghosal, and M. Conti, ‚ÄúSecure Over-The-Air Software Updates in Connected Vehicles: A Survey,‚Äù Computer Networks, vol. 178, p. 107343, 2020.\n\n[18] T. Karthik, A. Brown, S. Awwad, D. McCoy, R. Bielawski, C. Mott, S. Lauzon, A. Weimerskirch, and J. Cappos, ‚ÄúUptane: Securing Software Updates for Automobiles,‚Äù in International Conference on Embedded Security in Car, 2016, pp. 1‚Äì11.\n\n[19] M. Baza, M. Nabil, N. Lasla, K. Fidan, M. Mahmoud, and M. Abdallah, ‚ÄúBlockchain-based Firmware Update Scheme Tailored for Autonomous Vehicles,‚Äù in IEEE Wireless Communications & Networking, 2019, p. 7.\n\n[20] D. K. Nilsson and U. E. Larson, ‚ÄúSecure Firmware Updates over the Air in Intelligent Vehicles,‚Äù in IEEE International Conference on Communications Workshops, 2008, pp. 380‚Äì384.\n\n[21] M. Steger, C. A. Boano, T. Niedermayr, M. Karner, J. Hillebrand, K. Roemer, and W. Rom, ‚ÄúAn Efficient and Secure Automotive Wireless Software Update Framework,‚Äù IEEE Transactions on Industrial Informatics, vol. 14, no. 5, pp. 2181‚Äì2193, 2017.\n\n[22] M. S. Idrees, H. Schweppe, Y. Roudier, M. Wolf, D. Scheuermann, and O. Henniger, ‚ÄúSecure Automotive On-Board Protocols: A Case of Over-the-Air Firmware Updates,‚Äù in Springer Communication Technologies for Vehicles. Nets4Cars/Nets4Trains, 2011, pp. 224‚Äì238.\n\n[23] R. Petri, M. Springer, D. Zelle, I. McDonald, A. Fuchs, and C. Krau√ü, ‚ÄúEvaluation of Lightweight TPMs for Automotive Software Updates over the Air,‚Äù in International Conf. on Embedded Security in Car, 2016, pp. 1‚Äì15.\n\n[24] K. V. de Souza, Y. Bouslimani, and M. Ghribi, ‚ÄúFlight Software Development for a CubeSat Application,‚Äù IEEE Journal on Miniaturization for Air and Space Systems, vol. 3, no. 4, pp. 184‚Äì196, 2022.\n\n[25] J. Willbold, M. Schloegel, M. V√∂gele, M. Gerhardt, T. Holz, and A. Abbasi, ‚ÄúSpace Odyssey: An Experimental Software Security Analysis of Satellites,‚Äù in IEEE Symposium on Security and Privacy, 2023.\n\n[26] S. Fitzsimmons, Reliable Software Updates for On-orbit Cubesat Satellites. California Polytechnic State University, 2012.\n\n[27] I. S√ºnter, A. Slavinskis, U. Kvell, A. Vahter, H. Kuuste, M. Noorma, J. Kutt, R. Vendt, K. Tarbe, M. Pajusalu et al., ‚ÄúFirmware Updating Systems for Nanosatellites,‚Äù IEEE Aerospace and Electronic Systems Magazine, vol. 31, no. 5, pp. 36‚Äì44, 2016.\n\n[28] A. Slavinskis, M. Pajusalu, H. Kuuste, E. Ilbis, T. Eenm√§e, I. S√ºnter, K. Laizans, H. Ehrpais, P. Liias, E. Kulu et al., ‚ÄúESTCube-1 In-Orbit Experience and Lessons Learned,‚Äù IEEE Aerospace and Electronic Systems Magazine, vol. 30, no. 8, pp. 12‚Äì22, 2015.\n\n[29] B. Bezem and P. K. J. Fjellby, ‚ÄúAuthenticated Uplink for the Small, Low Orbit Student Satellite NUTS,‚Äù Department of Telematics, NTNU, 2012.\n\n[30] O. Challa, G. Bhat, and J. Mcnair, ‚ÄúCubeSec and GndSec: A Lightweight Security Solution for CubeSat Communications,‚Äù 2012.\n\n[31] L. Wood, W. M. Eddy, W. Ivancic, J. McKim, and C. Jackson, ‚ÄúSaratoga: A Delay-Tolerant Networking Convergence Layer with Efficient Link Utilization,‚Äù in IEEE International Workshop on Satellite and Space Communications, 2007, pp. 168‚Äì172.\n\n[32] C. Boyd, A. Mathuria, and D. Stebila, Protocols for Authentication and Key Establishment. Springer, 2020.\n\n[33] R. Davies, ‚ÄúHardware Random Number Generators,‚Äù in 15th Australian Statistics Conference, 2000.\n\n[34] L. Lamport, ‚ÄúPassword Authentication with Insecure Communication,‚Äù Communications of the ACM, vol. 24, no. 11, pp. 770‚Äì772, 1981.\n\n[35] (2023) Putty v0.80. [Online]. Available: https://the.earth.li/ sgtatham/putty/0.80/w64/putty.exe\n\n[36] (2023) Notepad++ v8.6. [Online]. Available: https://github.com/notepad-plus-plus/notepad-plus-plus/releases/download/v8.6/npp.8.6.Installer.x64.exe\n\n[37] (2023) FileZilla v3.66.4. [Online]. Available: https://download.filezilla-project.org/ client/FileZilla_3.66.4_win64_sponsored2-setup.exe\n\n[38] (2023) Audacity v3.4.2. [Online]. Available: https://github.com/audacity/audacity/releases/download/ Audacity-3.4.2/audacity-win-3.4.2-64bit.exe\n\n[39] M. Bellare and P. Rogaway, ‚ÄúPSS: Provably Secure Encoding Method for Digital Signatures,‚Äù 1998.\n\n[40] (2023) Cryptography. [Online]. Available: https://pypi.org/project/cryptography/\n\n[41] V. Goyal, ‚ÄúHow to Re-initialize a Hash Chain,‚Äù Crypto. ePrint Archive, 2004.\n\n[42] Y. Zhao and D. Li, ‚ÄúAn Improved Elegant Method to Re-initialize Hash Chains,‚Äù Crypto. ePrint Archive, 2005.\n\n[43] H. Zhang, X. Li, and R. Ren, ‚ÄúA Novel Self-renewal Hash Chain and its Implementation,‚Äù in IEEE/IFIP International Conference on Embedded and Ubiquitous Computing, 2008, pp. 144‚Äì149.\n\n[44] M. Shalashov and A. Kiseleva, ‚ÄúReview of Open-source Cubesat Projects,‚Äù in Journal of Physics: Conference Series, vol. 1925, no. 1, 2021, p. 012039."
    }
}