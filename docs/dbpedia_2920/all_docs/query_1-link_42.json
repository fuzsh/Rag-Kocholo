{
    "id": "dbpedia_2920_1",
    "rank": 42,
    "data": {
        "url": "https://docs.kubos.com/0.2.2/libcsp/csp_8h_source.html",
        "read_more_link": "",
        "language": "en",
        "title": "csp.h Source File",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.kubos.com/0.2.2/kubos.png",
            "https://docs.kubos.com/0.2.2/libcsp/search/mag_sel.png",
            "https://docs.kubos.com/0.2.2/libcsp/search/close.png",
            "https://docs.kubos.com/0.2.2/libcsp/doxygen.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "27 #ifndef _CSP_H_\n\n28 #define _CSP_H_\n\n30 #ifdef __cplusplus\n\n31 extern \"C\" {\n\n32 #endif\n\n35 #include <stdint.h>\n\n37 #include <csp/csp_autoconfig.h>\n\n52 int csp_init(uint8_t my_node_address);\n\n54 void csp_terminate(void);\n\n60 void csp_set_address(uint8_t addr);\n\n66 uint8_t csp_get_address(void);\n\n73 void csp_set_hostname(char *hostname);\n\n79 char *csp_get_hostname(void);\n\n86 void csp_set_model(char *model);\n\n92 char *csp_get_model(void);\n\n99 void csp_set_revision(char *revision);\n\n105 char *csp_get_revision(void);\n\n171 int csp_transaction(uint8_t prio, uint8_t dest, uint8_t port, uint32_t timeout, void *outbuf, int outlen, void *inbuf, int inlen);\n\n184 int csp_transaction_persistent(csp_conn_t *conn, uint32_t timeout, void *outbuf, int outlen, void *inbuf, int inlen);\n\n206 int csp_sendto(uint8_t prio, uint8_t dest, uint8_t dport, uint8_t src_port, uint32_t opts, csp_packet_t *packet, uint32_t timeout);\n\n217 int csp_sendto_reply(csp_packet_t * request_packet, csp_packet_t * reply_packet, uint32_t opts, uint32_t timeout);\n\n231 csp_conn_t *csp_connect(uint8_t prio, uint8_t dest, uint8_t dport, uint32_t timeout, uint32_t opts);\n\n288 int csp_listen(csp_socket_t *socket, size_t conn_queue_length);\n\n303 int csp_route_start_task(unsigned int task_stack_size, unsigned int priority);\n\n317 int csp_route_work(uint32_t timeout);\n\n327 int csp_bridge_start(unsigned int task_stack_size, unsigned int task_priority, csp_iface_t * _if_a, csp_iface_t * _if_b);\n\n338 int csp_promisc_enable(unsigned int buf_size);\n\n345 void csp_promisc_disable(void);\n\n368 int csp_sfp_send(csp_conn_t * conn, void * data, int totalsize, int mtu, uint32_t timeout);\n\n381 int csp_sfp_send_own_memcpy(csp_conn_t * conn, void * data, int totalsize, int mtu, uint32_t timeout, void * (*memcpyfcn)(void *, const void *, size_t));\n\n391 int csp_sfp_recv(csp_conn_t * conn, void ** dataout, int * datasize, uint32_t timeout);\n\n402 int csp_sfp_recv_fp(csp_conn_t * conn, void ** dataout, int * datasize, uint32_t timeout, csp_packet_t * first_packet);\n\n425 int csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options);\n\n431 void csp_ping_noreply(uint8_t node);\n\n439 void csp_ps(uint8_t node, uint32_t timeout);\n\n446 void csp_memfree(uint8_t node, uint32_t timeout);\n\n453 void csp_buf_free(uint8_t node, uint32_t timeout);\n\n459 void csp_reboot(uint8_t node);\n\n465 void csp_shutdown(uint8_t node);\n\n472 void csp_uptime(uint8_t node, uint32_t timeout);\n\n483 void csp_rdp_set_opt(unsigned int window_size, unsigned int conn_timeout_ms,\n\n484 unsigned int packet_timeout_ms, unsigned int delayed_acks,\n\n485 unsigned int ack_timeout, unsigned int ack_delay_count);\n\n496 void csp_rdp_get_opt(unsigned int *window_size, unsigned int *conn_timeout_ms,\n\n497 unsigned int *packet_timeout_ms, unsigned int *delayed_acks,\n\n498 unsigned int *ack_timeout, unsigned int *ack_delay_count);\n\n506 int csp_xtea_set_key(char *key, uint32_t keylen);\n\n514 int csp_hmac_set_key(char *key, uint32_t keylen);\n\n526 #ifdef __AVR__\n\n527 typedef uint32_t csp_memptr_t;\n\n528 #else\n\n530 #endif\n\n539 #include <stdarg.h>\n\n543 #ifdef __cplusplus\n\n545 #endif\n\n547 #endif // _CSP_H_\n\nvoid * csp_memptr_t\n\nDefinition: csp.h:529\n\nint csp_send(csp_conn_t *conn, csp_packet_t *packet, uint32_t timeout)\n\nSend a packet on an already established connection.\n\nint csp_transaction(uint8_t prio, uint8_t dest, uint8_t port, uint32_t timeout, void *outbuf, int outlen, void *inbuf, int inlen)\n\nPerform an entire request/reply transaction Copies both input buffer and reply to output buffeer...\n\ncsp_packet_t * csp_read(csp_conn_t *conn, uint32_t timeout)\n\nRead data from a connection This fuction uses the RX queue of a connection to receive a packet If no ...\n\nInterface struct.\n\nDefinition: csp_types.h:190\n\nchar * csp_get_hostname(void)\n\ncsp_get_hostname Get current subsystem hostname.\n\nvoid(* csp_debug_hook_func_t)(csp_debug_level_t level, const char *format, va_list args)\n\nSet csp_debug hook function.\n\nDefinition: csp.h:540\n\nvoid csp_debug_hook_set(csp_debug_hook_func_t f)\n\nint csp_conn_sport(csp_conn_t *conn)\n\nint csp_bridge_start(unsigned int task_stack_size, unsigned int task_priority, csp_iface_t *_if_a, csp_iface_t *_if_b)\n\nStart the bridge task.\n\nvoid csp_cmp_set_memcpy(csp_memcpy_fnc_t fnc)\n\nint csp_sfp_send_own_memcpy(csp_conn_t *conn, void *data, int totalsize, int mtu, uint32_t timeout, void *(*memcpyfcn)(void *, const void *, size_t))\n\nSame as csp_sfp_send but with option to supply your own memcpy function.\n\nchar * csp_get_model(void)\n\ncsp_get_model Get current model name.\n\nvoid csp_buffer_print_table(void)\n\nPrint buffer usage table.\n\nint csp_conn_dport(csp_conn_t *conn)\n\nint csp_conn_dst(csp_conn_t *conn)\n\nvoid csp_shutdown(uint8_t node)\n\nShutdown subsystem.\n\nint csp_sfp_recv(csp_conn_t *conn, void **dataout, int *datasize, uint32_t timeout)\n\nThis is the counterpart to the csp_sfp_send function.\n\nvoid csp_rdp_get_opt(unsigned int *window_size, unsigned int *conn_timeout_ms, unsigned int *packet_timeout_ms, unsigned int *delayed_acks, unsigned int *ack_timeout, unsigned int *ack_delay_count)\n\nGet RDP options.\n\nint csp_sfp_send(csp_conn_t *conn, void *data, int totalsize, int mtu, uint32_t timeout)\n\nSend multiple packets using the simple fragmentation protocol CSP will add total size and offset to a...\n\nstruct csp_conn_s csp_socket_t\n\nForward declaration of socket and connection structures.\n\nDefinition: csp_types.h:217\n\nint csp_route_start_task(unsigned int task_stack_size, unsigned int priority)\n\nStart the router task.\n\nvoid csp_reboot(uint8_t node)\n\nReboot subsystem.\n\nint csp_sendto_reply(csp_packet_t *request_packet, csp_packet_t *reply_packet, uint32_t opts, uint32_t timeout)\n\nSend a packet as a direct reply to the source of an incoming packet, but still without holding an ent...\n\nstruct csp_conn_s csp_conn_t\n\nDefinition: csp_types.h:218\n\ncsp_packet_t * csp_promisc_read(uint32_t timeout)\n\nGet packet from promiscuous mode packet queue Returns the first packet from the promiscuous mode pack...\n\nint csp_init(uint8_t my_node_address)\n\ncsp_init Start up the can-space protocol\n\nint csp_close(csp_conn_t *conn)\n\ncsp_close Closes a given connection and frees buffers used.\n\ncsp_memptr_t(* csp_memcpy_fnc_t)(csp_memptr_t, const csp_memptr_t, size_t)\n\nDefinition: csp.h:532\n\nint csp_promisc_enable(unsigned int buf_size)\n\nEnable promiscuous mode packet queue This function is used to enable promiscuous mode for the router...\n\nvoid csp_buf_free(uint8_t node, uint32_t timeout)\n\nRequest number of free buffer elements.\n\ncsp_debug_level_t\n\nDebug levels.\n\nDefinition: csp_debug.h:38\n\ncsp_socket_t * csp_socket(uint32_t opts)\n\ncsp_socket Create CSP socket endpoint\n\nvoid csp_ps(uint8_t node, uint32_t timeout)\n\nRequest process list.\n\nuint8_t csp_get_address(void)\n\ncsp_get_address Get the systems own address\n\nint csp_hmac_set_key(char *key, uint32_t keylen)\n\nSet HMAC key.\n\nvoid csp_set_revision(char *revision)\n\ncsp_set_revision Set subsystem revision.\n\nvoid csp_memfree(uint8_t node, uint32_t timeout)\n\nRequest amount of free memory.\n\ncsp_conn_t * csp_connect(uint8_t prio, uint8_t dest, uint8_t dport, uint32_t timeout, uint32_t opts)\n\ncsp_connect Used to establish outgoing connections This function searches the port table for free slo...\n\nvoid csp_promisc_disable(void)\n\nDisable promiscuous mode.\n\nvoid csp_set_address(uint8_t addr)\n\ncsp_set_address Set the systems own address\n\nint csp_listen(csp_socket_t *socket, size_t conn_queue_length)\n\nSet socket to listen for incoming connections.\n\nvoid csp_conn_print_table(void)\n\nPrint connection table.\n\ncsp_conn_t * csp_accept(csp_socket_t *socket, uint32_t timeout)\n\nWait for a new connection on a socket created by csp_socket.\n\nint csp_send_prio(uint8_t prio, csp_conn_t *conn, csp_packet_t *packet, uint32_t timeout)\n\nSend a packet on an already established connection, and change the default priority of the connection...\n\nint csp_sendto(uint8_t prio, uint8_t dest, uint8_t dport, uint8_t src_port, uint32_t opts, csp_packet_t *packet, uint32_t timeout)\n\nSend a packet without previously opening a connection.\n\nint csp_conn_src(csp_conn_t *conn)\n\nvoid csp_rdp_set_opt(unsigned int window_size, unsigned int conn_timeout_ms, unsigned int packet_timeout_ms, unsigned int delayed_acks, unsigned int ack_timeout, unsigned int ack_delay_count)\n\nSet RDP options.\n\nvoid csp_route_end_task()\n\nEnds the router task.\n\nint csp_route_work(uint32_t timeout)\n\nCall the router worker function manually (without the router task) This must be run inside a loop or ...\n\nvoid csp_service_handler(csp_conn_t *conn, csp_packet_t *packet)\n\nIf the given packet is a service-request (that is uses one of the csp service ports) it will be handl...\n\nvoid csp_close_socket(csp_socket_t *socket)\n\nCloses a given socket and frees queue used.\n\ncsp_packet_t * csp_recvfrom(csp_socket_t *socket, uint32_t timeout)\n\nRead data from a connection-less server socket This fuction uses the socket directly to receive a fra...\n\nint csp_xtea_set_key(char *key, uint32_t keylen)\n\nSet XTEA key.\n\nint csp_sfp_recv_fp(csp_conn_t *conn, void **dataout, int *datasize, uint32_t timeout, csp_packet_t *first_packet)\n\nThis is the counterpart to the csp_sfp_send function.\n\nint csp_transaction_persistent(csp_conn_t *conn, uint32_t timeout, void *outbuf, int outlen, void *inbuf, int inlen)\n\nUse an existing connection to perform a transaction, This is only possible if the next packet is on t...\n\nchar * csp_get_revision(void)\n\ncsp_get_revision Get subsystem revision.\n\nCSP PACKET STRUCTURE Note: This structure is constructed to fit with all interface frame types in ord...\n\nDefinition: csp_types.h:174\n\nvoid csp_uptime(uint8_t node, uint32_t timeout)\n\nRequest subsystem uptime.\n\nvoid csp_terminate(void)\n\nint csp_bind(csp_socket_t *socket, uint8_t port)\n\nBind port to socket.\n\nint csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options)\n\nSend a single ping/echo packet.\n\nint csp_conn_check_alive(csp_conn_t *conn)\n\nvoid csp_set_model(char *model)\n\ncsp_set_model Set subsystem model name.\n\nvoid csp_set_hostname(char *hostname)\n\ncsp_set_hostname Set subsystem hostname.\n\nvoid csp_ping_noreply(uint8_t node)\n\nSend a single ping/echo packet without waiting for reply."
    }
}