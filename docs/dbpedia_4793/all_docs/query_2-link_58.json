{
    "id": "dbpedia_4793_2",
    "rank": 58,
    "data": {
        "url": "https://www.geeksforgeeks.org/zombie-processes-prevention/",
        "read_more_link": "",
        "language": "en",
        "title": "Zombie Processes and their Prevention",
        "top_image": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_200x200-min.png",
        "meta_img": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_200x200-min.png",
        "images": [
            "https://media.geeksforgeeks.org/gfg-gg-logo.svg",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/Google-news.svg",
            "https://media.geeksforgeeks.org/wp-content/uploads/zombie1_1.png",
            "https://media.geeksforgeeks.org/wp-content/uploads/zombie1_2.png",
            "https://media.geeksforgeeks.org/wp-content/uploads/zom_final.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/Google-news.svg",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/new-premium-rbanner-us.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/gfgFooterLogo.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/googleplay.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/appstore.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/suggestChangeIcon.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/createImprovementIcon.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Data Structures",
            "Algorithms",
            "Python",
            "Java",
            "C",
            "C++",
            "JavaScript",
            "Android Development",
            "SQL",
            "Data Science",
            "Machine Learning",
            "PHP",
            "Web Development",
            "System Design",
            "Tutorial",
            "Technical Blogs",
            "Interview Experience",
            "Interview Preparation",
            "Programming",
            "Competitive Programming",
            "Jobs",
            "Coding Contests",
            "GATE CSE",
            "HTML",
            "CSS",
            "React",
            "NodeJS",
            "Placement",
            "Aptitude",
            "Quiz",
            "Computer Science",
            "Programming Examples",
            "GeeksforGeeks Courses",
            "Puzzles",
            "SSC",
            "Banking",
            "UPSC",
            "Commerce",
            "Finance",
            "CBSE",
            "School",
            "k12",
            "General Knowledge",
            "News",
            "Mathematics",
            "Exams"
        ],
        "tags": null,
        "authors": [
            "GeeksforGeeks"
        ],
        "publish_date": "2017-04-03T12:07:54",
        "summary": "",
        "meta_description": "A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions.",
        "meta_lang": "en",
        "meta_favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "meta_site_name": "GeeksforGeeks",
        "canonical_link": "https://www.geeksforgeeks.org/zombie-processes-prevention/",
        "text": "Zombie state: When a process is created in UNIX using fork() system call, the parent process is cloned. If the parent process calls wait() system call, then the execution of the parent is suspended until the child is terminated. At the termination of the child, a ‘SIGCHLD’ signal is generated by the kernel which is delivered to the parent. Parent, on receipt of ‘SIGCHLD’ reads the status of the child from the process table.\n\nPrerequisites: fork() in C, Zombie Process\n\nEven though the child is terminated, there is an entry in the process table corresponding to the child where the status is stored. When the parent collects the status, this entry is deleted (or we also say the parent reaped its child process) . Thus, all the traces of the child process are removed from the system. If the parent decides not to wait for the child’s termination and executes its subsequent task, then at the termination of the child, the exit status is not read. Hence, there remains an entry in the process table even after the termination of the child. This state of the child process is known as the Zombie state.\n\nOutput :\n\nNow check the process table using the following command in the terminal\n\n$ ps -eaf\n\nHere the entry [a.out] defunct shows the zombie process.\n\nWhy do we need to prevent the creation of the Zombie process?\n\nThere is one process table per system. The size of the process table is finite. If too many zombie processes are generated, then the process table will be full. That is, the system will not be able to generate any new process, then the system will come to a standstill. Hence, we need to prevent the creation of zombie processes.\n\nDifferent ways in which the creation of Zombie can be Prevented\n\n1. Using wait() system call: When the parent process calls wait(), after the creation of a child, it indicates that, it will wait for the child to complete and it will reap the exit status of the child. The parent process is suspended(waits in a waiting queue) until the child is terminated. It must be understood that during this period, the parent process does nothing just wait.\n\n(Point 2. is wrong and doesn’t prevent zombie creation, its the job of parent process to remove the child process from process list and is not done by the kernel, infact SIG_IGN is the default handler for SIGCHLD signal to the parent process).\n\n2. By ignoring the ‘SIGCHLD’ signal: When a child is terminated, a corresponding SIGCHLD signal is delivered to the parent, if we call the ‘signal(SIGCHLD,SIG_IGN)’, then the SIGCHLD signal is ignored by the system, and the child process entry is deleted from the process table Thus, no zombie is created. However, in this case, the parent cannot know about the exit status of the child.\n\n3. By using a signal handler: The parent process installs a signal handler for the SIGCHLD signal. The signal handler calls wait() system call within it. In this scenario, when the child terminated, the SIGCHLD is delivered to the parent. On receipt of SIGCHLD, the corresponding handler is activated, which in turn calls the wait() system call. Hence, the parent collects the exit status almost immediately and the child entry in the process table is cleared. Thus no zombie is created.\n\nOutput:\n\nHere no any [a.out] defunct i.e. no Zombie process is created.\n\n4. Double fork: This involves creating a grandchild process which is then orphaned by the parent process. This ensures that the grandchild process is inherited by the init process, which reaps it automatically. This prevents the creation of a zombie process.\n\n5. Using the waitpid() system call: This system call is similar to the wait() system call, but it allows the parent process to wait for a specific child process to terminate. This way, the parent can collect the exit status of the child and prevent the creation of a zombie process."
    }
}