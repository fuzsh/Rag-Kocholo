{
    "id": "dbpedia_8584_2",
    "rank": 82,
    "data": {
        "url": "http://alhassy.com/emacs.d/",
        "read_more_link": "",
        "language": "en",
        "title": "A Life Configuring Emacs",
        "top_image": "https://endlessparentheses.com/images/comment-box.gif",
        "meta_img": "",
        "images": [
            "https://img.shields.io/badge/A_Life-Configuring_Emacs-success?logo=gnu-emacs",
            "https://img.shields.io/badge/A_Life_Configuring-Emacs-success?logo=gnu",
            "https://img.shields.io/badge/Currently_Reorganising-Not_Polished-yellow?logo=nil",
            "https://img.shields.io/badge/Elisp-CheatSheet-success?logo=Gnu-Emacs",
            "https://img.shields.io/badge/Lifemacs-CheatSheet-informational?logo=Gnu-Emacs",
            "https://img.shields.io/badge/Emacs-27-green?logo=gnu-emacs",
            "https://img.shields.io/badge/Org-9.4-blue?logo=gnu",
            "https://img.shields.io/badge/license-GNU_3-informational?logo=read-the-docs",
            "https://img.shields.io/twitter/url?url=https://github.com/alhassy/org-special-block-extras",
            "https://img.shields.io/badge/author-musa_al--hassy-purple?logo=nintendo-3ds",
            "https://img.shields.io/badge/-buy_me_a%C2%A0coffee-gray?logo=buy-me-a-coffee",
            "https://img.shields.io/badge/org--special--block--extras-2.0-informational?logo=Gnu-Emacs",
            "https://alhassy.github.io/emacs.d/images/literate-programming.png",
            "https://img.shields.io/badge/Lifemacs-CheatSheet-informational?logo=Gnu-Emacs",
            "https://img.shields.io/badge/Elisp-CheatSheet-success?logo=Gnu-Emacs",
            "http://alhassy.com/emacs.d/images/literate-programming.png",
            "https://img.shields.io/badge/Workflow-CheatSheet-informational?logo=nil",
            "http://alhassy.com/emacs.d/images/workflow.png",
            "http://alhassy.com/emacs.d/test.png",
            "http://alhassy.com/emacs.d/images/services-dashboard.png",
            "https://endlessparentheses.com/images/comment-box.gif",
            "https://i.redd.it/g6yi40gbivv31.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Musa Al-hassy"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "My Emacs Initialisation File, Written in Org-mode.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "A snippet, template, mechanism is a tool that when you press some keystrokes inserts some text, possibly with some fields (‘blanks’) to fill in. Possibly interesting read:\n\nSnippet Expansion With Yasnippet: Save Yourself Keystrokes and Headaches —a nice before introduction to Yasnippet (“Yet another snippet”)\n\nTweaking Emacs: Snippets —a brief article on using snippets for uniformity across languages and to mitigate verbosity of weak languages (i.e., those without macros).\n\nYasnippet is a pleasant utility for template expansion with the alluring feature to allow arbitrary Lisp code to be executed during expansion. The declaration of templates is verbose, requiring a particular file hierarchy, as such I utilise Yankpad which allows me to employ an Org-mode approach: Each template corresponds to an org heading of the form Key:Words:For:Expansion:Here: name of snippet here and the template body is then the body of the org heading. Any of Key, Words, For, Expansion, Here will rewrite into the body of the org tree. This is much more terse, and I even don't bother with that; instead preferring to tangle my templates using yankpad as a mere interface. It is important to note that Yankpad also provides features that are not in Yassnippet, such as allowing arbitrary language code to be executed —one simply uses an org-src block!\n\nHere is a nice self-contained tutorial.\n\nThere can only be one major completion backend for any mode, but other backends can serve as secondary ones. Here's a function to make company-yankpad a secondary of all existing backends.\n\n;; Add yasnippet support for all company backends ;; (cl-defun my/company-backend-with-yankpad (backend) \"There can only be one main completition backend, so let's enable yasnippet/yankpad as a secondary for all completion backends. Src: https://emacs.stackexchange.com/a/10520/10352\" (if (and (listp backend) (member 'company-yankpad backend)) backend (append (if (consp backend) backend (list backend)) '(:with company-yankpad))))\n\n;; Yet another snippet extension program (use-package yasnippet :diminish yas-minor-mode :config (yas-global-mode 1) ;; Always have this on for when using yasnippet syntax within yankpad ;; respect the spacing in my snippet declarations (setq yas-indent-line 'fixed)) ;; Alternative, Org-based extension program (use-package yankpad :diminish :config ;; Location of templates (setq yankpad-file \"~/.emacs.d/yankpad.org\") ;; Ignore major mode, always use defaults. ;; Yankpad will freeze if no org heading has the name of the given category. (setq yankpad-category \"Default\") ;; Load the snippet templates ---useful after yankpad is altered (yankpad-reload) ;; Set company-backend as a secondary completion backend to all existing backends. (setq company-backends (mapcar #'my/company-backend-with-yankpad company-backends)))\n\nWith these settings, along with the company backend, I may type a keyword then TAB it into expansion.\n\nYankpad requires we have an org file that contains our templates, so we tangle such a file ~/.emacs.d/yankpad.org, and have all of our templates be globally accessible. Here is the start of my file:\n\n#+Description: This is file is generated from my init.org; do not edit. * Default :global:\n\nFully discussed example: Using the clipboard for Org-links\n\nHere's an example of a common template I perform by hand —no more! I have the expected habit of copying (to clipboard) a URL from someplace then forming a link to it by writing [[URL] [description]], since the URL & syntax are already known, let's expand those and place the cursour at the only unknown —the description.\n\n** my_org_insert_link: cleverly insert a link copied to clipboard [[${1:`(clipboard-yank)`}][$2]] $0\n\nWhat's going on here? ( The above, verbatim: [[${1:`(clipboard-yank)`}][$2]] $0. )\n\nThis template is expanded with the keyword my-org-insert-link, then TAB.\n\nThe cursour lands at position $1, which has default text being the result of evaluating (clipboard-yank).\n\nWe may evaluate Lisp code anywhere by enclosing it in backticks.\n\nIf we're satisfied with the current field, we simply tab to the next field. Otherwise, we simply write text —which overwrites the default text.\n\nAfter enough tabbing we complete the template and the cursour lands at position $0.\n\n⟪ Having default or mirrored text for $2 would not allow me to see the URL field, lest I wish to change it or at least confirm it's what I want. Hence, the $2 field has no default. ⟫\n\nLet's overwrite the usual way to insert such links, via C-c C-l.\n\n(cl-defun org-insert-link () \"Makes an org link by inserting the URL copied to clipboard and prompting for the link description only. Type over the shown link to change it, or tab to move to the description field. This overrides Org-mode's built-in ‘org-insert-link’ utility; whence C-c C-l uses the snippet.\" (interactive) (insert \"my_org_insert_link\") (yankpad-expand))\n\nWarning! Snippet names cannot have hypens in them —in this setup at least.\n\nThe Yasnippet manual is an accessible read, as is the Yankpad manual, and showcases many other utilities; such as having certain snippets being enabled only in particular modes or on demand. Of note is that field $n can be accessed in code with the invocation (yas-field-value n).\n\nIncidentally, I used this snippet setup to demo the idea of repetitious code in grouping constructs within dependently-typed languages, which was accepted and led to my doctoral research on a ‘do it yourself module system’.\n\nThe rest of this section is other templates, not much for now, concluding with actually loading this snippet mechanism globally.\n\nThe remaining subsections discuss contents of my yankpad file.\n\nThis produces a pop-up list of org-mode block types, if src is selected, then a list of my commonly used languages pops-up. Alternatively, ignore the pop-up menu and write any block or language name.\n\n** begin: produce an org-mode block #+begin_${1:environment$(let* ((block '(\"src\" \"example\" \"quote\" \"verse\" \"center\" \"latex\" \"html\" \"ascii\")) (langs '(\"c\" \"emacs-lisp\" \"lisp\" \"latex\" \"python\" \"sh\" \"haskell\" \"plantuml\" \"prolog\")) (type (yas-choose-value block))) (concat type (when (equal type \"src\") (concat \" \" (yas-choose-value langs)))))} $0 #+end_${1:$(car (split-string yas-text))}\n\nIn this case, yas-text is equivalent to (yas-field-value 1); it generally refers to the value of the field being mirrored with ${n: ⋯yas-text⋯}.\n\nHowever, going through pop-ups takes precious time —besides being slightly annyoing. Let's introduce a template for my most utilised kind of language blocks.\n\n** s_org: src block for org #+begin_src org $0 #+end_src\n\nHowever, doing this for each language I want is a waste of time and textual space. Why? The purpose of templates is to reduce repetition, yet the above block would be repeated with only 3 parts ‘unknown’: The expansion keyword, the description, and the org-mode source block name. Whence, the template text is generated by the following basic loop —whose source block is named my-org-lang-templates.\n\n;; We make an org BLOCK snippet template for each LANG the user has declared. ;; (cl-loop for (shortcut block takes-language-argument? default-text) in '((\"s_\" \"src\" t) (\"is_\" \"inline source\" t) ;; Treated specially below (\"e_\" \"example\" t) (\"q_\" \"quote\") (\"v_\" \"verse\") (\"c_\" \"center\") (\"ex_\" \"export\") ;; only HTML and LATEX ;; https://alhassy.github.io/org-special-block-extras/#Summary (\"p_\" \"parallel\" nil \"\\n$0\\n#+columnbreak:\\n\") (\"d_\" \"details\" nil \"${1:title}\\n$0\") (\"ed_\" \"edcomm\" nil \"${1:editor}\\n$0\") (\"doc_\" \"documentation\" nil \"${1: mandatory entry name}\\n$0\") (\"def_\" \"latex-definitions\")) for languages = (if takes-language-argument? (-cons* \"org\" \"agda2\" \"any\" ;; Extra ‘languages’ ;; Also include whatever languages we've loaded for literate programming. (--map (symbol-name (car it)) org-babel-load-languages)) '(\"\")) ;; The “empty language” concat (cl-loop for lang in languages for key = (concat shortcut (if (s-blank? lang) block lang)) for description = (if (s-blank? lang) block (concat block \" for \" lang)) concat (if (equal \"is_\" shortcut) (concat \"\\n** \" key \": \" description \"\\nsrc_\" lang \"[:exports code]{$1} $0\") (concat \"\\n** \" key \": \" description \"\\n#+begin_\" block \" \" lang (or default-text \"\\n$0\") \"\\n#+end_\" block \"\\n\"))))\n\nThe resulting text of this block, generated below, is tangled to our yankpad by utilising a noweb source block invocation. An example of the resulting text is the above s_org block. The result is (last I checked) 83 template expansions —that would have been a bit much to write by hand.\n\n#+begin_src org :tangle \"~/.emacs.d/yankpad.org\" :noweb yes <<my-org-lang-templates()>> #+end_src\n\nnil\n\nNow s_, due to company mode, brings up a list of languages that I can then scroll down through, then “enter” upon to expand. Moreover, the prefix s_ means that the key is mostly irrelevant, since I needn't remember it because company-mode immediately lists possible completions along with the descriptions for the snippets. Likewise for examples with e_ or quotes with q_. Super neat stuff :-)\n\nAin't this reminiscent of meta-programming ;-)\n\nUsing noweb invocations, any time the tangling is performed, the yankpad is kept up to date —no personal intervention from myself.\n\nWith the advent of org-special-block-extras, I've made increased usage of links –such as green:hello which yields hello and [[kbd:][green]] which yields .\n\n** ll_make_a_link: insert a link template ${1:`(let* ((τ (read-string \"Link type: \")) (δ (read-string \"Link Description: \")) (⊤ (if (s-contains? \":\" τ) τ (s-concat τ \":\")))) (format \"[[%s][%s]]\" ⊤ δ))`} $0\n\nSometimes it can be tough to journal, but filling in a template can be a way to get started. Later on, we will setup 4.5 which will allow us to write journal_guided then TAB to obtain the template below. Each $𝓃 indicates a position that we may input text, after which we TAB to move to next location.\n\nJust like the undo-tree setup at the start of this read, we use a noweb-ref to present this template in a natural position; then later when template expansion it setup, we request it to be tangled.\n\n** journal_guided: Introspection & Growth I'm writing from ${1:location}. Gut answer, today I feel ${2:scale}/10. ⇒ ${3:Few words or paragraphs to explain what's on your mind.} ${4: All things which cause us to groan or recoil are part of the tax of life. These things you should never hope or seek to escape. Life is a battle, and to live is to fight. ⟨ Press TAB once you've read this mantra. ⟩ $(when yas-moving-away-p \"\") } `(progn (eww \"https://www.dailyinspirationalquotes.in/\") (sit-for 2) (when nil let eww load) (read-only-mode -1) (goto-line 52) (kill-line) (kill-buffer) (yank))` ${7: Self Beliefs: + I am working on a healthier lifestyle, including a low-carb diet. - I’m also investing in a healthy, long-lasting relationship. ➩ These are what I want and are important to me. ⇦ + I will not use any substances to avoid real issues in my life. I must own them. + Everything I’m searching for is already inside of me. + Progress is more important than perfection. ⟨ Press TAB once you've read these beliefs. ⟩ $(when yas-moving-away-p \"\") } *Three things I'm grateful for:* 1. ${8:??? … e.g., old relationship, something great yesterday, an opportunity I have today, something simple near me within sight} 2. ${9:??? … e.g., old relationship, something great yesterday, an opportunity I have today, something simple near me within sight} 3. ${10:??? … e.g., old relationship, something great yesterday, an opportunity I have today, something simple near me within sight} *Three things that would make today great:* 1. ${11:???} 2. ${12:???} 3. ${13:???} *What one thing is top of mind today?* ${14:???} *What’s one opportunity I want to go after?* ${15:???} *What’s one thing I’m really proud of OR I’m amazed and in awe of?* ${16:???} $0\n\nBesides a bit of webscraping to obtain a daily inspirational quote image, and the necessary yasnippet code, this template was taken from a discussion on Hacker news: “I find journaling indispensable”. In time, I will likely alter it to meet my needs, but I like it as it is right now (•̀ᴗ•́)و\n\n(cl-defun my/notify (message &key (titled \"\") at repeat-every-hour open) \"Notify user with both an visual banner, with a beep sound, and a text-to-speech recitation. When the user clicks on the resulting notification, unless a given OPEN url is provided, the Emacs application is brough into focus. MESSAGE and TITLE are strings; AT is a time string as expected of `run-at-time' such as \\\"11.23pm\\\" or \\\"5 sec\\\"; REPEAT-EVERY-HOUR is a floating-point number of hours to continuously repeat the alert. OPEN is a URL that is opened when the user clicks the notification. This can be a web or file URL, or any custom URL scheme. I initially used optional arguments, but realised that in due time it would be more informative to use named arguments instead. Example uses: ;; In 5 minutes from now, remind me to watch this neato video! (my/notify \\\"🔔 Get things done! 📎 💻 \\\" :open \\\"https://www.youtube.com/watch?v=23tusPiiNZk&ab_channel=Motiversity\\\" :at \\\"5 minutes\\\") ;; Remind me to exercise every 1.5hours; starting at 8:00am. (my/notify \\\"Take a 5min break and get your blood flowing!\\\" :titled \\\"Exercise\\\" :at \\\"8:00am\\\" :repeat-every-hour 1.5) ;; Actually getting things done! (my/notify \\\"Is what you're doing actually in alignment with your goals? Maybe it's time to do another task?\\\" :titled \\\"Check your agenda!\\\" :at \\\"10:00am\\\" :repeat-every-hour 2) \" (run-at-time at ;; the time to make the alert (when repeat-every-hour (* 60 60 repeat-every-hour)) #'async-shell-command (format \"%s\" `(terminal-notifier -title ,(pp-to-string titled) -message ,(s-replace \"\\\\n\" \"\\n\" (pp-to-string message)) ;; Play a random sound when the notification appears. See sound names with: ls /System/Library/Sounds ;; Use the special NAME “default” for the default notification sound. -sound ,(progn (require 'seq) (seq-random-elt (s-split \"\\n\" (shell-command-to-string \"ls /System/Library/Sounds\")))) ;; Don't create duplicates of the notification, just one instance; ;; i.e., each notification belongs to a group and only one alert of the group may be present at any one time. -group ,(pp-to-string titled) ;; Activate the application specified by ID when the user clicks the notification. -activate org.gnu.Emacs ,@(when open `(-open ,(pp-to-string open))) ;; Run the shell command COMMAND when the user clicks the notification. ;; -execute COMMAND & ;; … and then speak! … ;; ;; say ,(s-replace \"\\\\n\" \" \" (pp-to-string message)) ))))"
    }
}