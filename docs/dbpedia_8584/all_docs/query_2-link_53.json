{
    "id": "dbpedia_8584_2",
    "rank": 53,
    "data": {
        "url": "https://ark.tbdrobotics.com/docs/overviews/config/",
        "read_more_link": "",
        "language": "en",
        "title": "Config Parsing",
        "top_image": "https://ark.tbdrobotics.com/favicons/favicon-16x16.png",
        "meta_img": "https://ark.tbdrobotics.com/favicons/favicon-16x16.png",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Config Files Each configuration is defined through an rbuf file. The configuration system will then load content in a YAML file into the concrete C++ structure defined by the rbuf.\nFor a simple example:\n--- config: default: my_parameter: 10 If you had an rbuf that looked like:\nschema MyConfig { uint32 my_parameter; } Then you could load the above YAML into that rbuf, and my_parameter would equal 10.\nDurations have the ability to have a &lsquo;suffix&rsquo; applied to them.",
        "meta_lang": "en",
        "meta_favicon": "/favicons/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://ark.tbdrobotics.com/docs/overviews/config/",
        "text": "Config Files\n\nEach configuration is defined through an rbuf file. The configuration system will then load content in a YAML file into the concrete C++ structure defined by the rbuf.\n\nFor a simple example:\n\nIf you had an rbuf that looked like:\n\nThen you could load the above YAML into that rbuf, and my_parameter would equal 10.\n\nDurations have the ability to have a ‘suffix’ applied to them. While they are stored as nanoseconds in the rbuf/generated code, they can be written in seconds, minutes, or milliseconds by applying the appropriate suffix. For example, 1_s means “one second” and 50_ms means “50 milliseconds”.\n\nConfig Options\n\nConfiguration files can also have ‘options’ which allow you to specify different parameter sets that users may be interested in switching between.\n\nFor example:\n\nIn this example, if you used the default option, you would get 10 and 20 back, for parameters a and b respectively. If you asked for the extra option, you’d get back 10 and 15. This is because extra has overridden parameter_b with the value 15.\n\nThis makes use of the YAML anchoring syntax.\n\nConfig Metadata\n\nConfiguration files can have the concept of ‘metadata’ which is not normally parsed. These metadata objects are typically full structures of their own, and contain data not directly associated with the configuration, but related to it.\n\nFor example:\n\nIn this example, there is a metadata block known as stage_config. This can be processed and fetched into the ark::pipeline::StageConfig structure. This particular metadata is used by the pipeline to configure namespacing, and to help downstream customers understand what type of stage this configuration is.\n\nConfig Package\n\nConceptually, a ConfigPackage consists of many different individual configurations, which can then be fetched at execution time.\n\nFor each configuration, you define the path to the YAML file to load, the option to make use of from that file, and any “overrides”.\n\nAs a quick example:\n\nBuilding on the options example, this would load the config YAML you specified, choose the extra option for you, then change parameter_a to 30, giving you back 30 and 15 for parameter_a and parameter_b, respectively.\n\nYou can fetch this configuration by using the following API:\n\nNote that you can optionally provide a list of search paths to from_file – that will allow the config package loader to search in alternate locations for included files. It will still search the current working directory if the file cannot be found otherwise.\n\nYou can further fetch metadata from it by using this API:\n\nNote that if the metadata is not present, this will return a default-initialized structure.\n\nA ConfigPackage is assumed to contain all of the configuration for a pipeline, so, all of your stages will have configuration stored in this package.\n\nNote that for testing, it is a lot of boilerplate to make a ConfigPackage for every test that you are writing. You can add a stage and a paired configuration to a pipeline with this helper:\n\nThis works similarly to add_stage() - all arguments after the configuration struct are just forwarded to the stage constructor, and the API returns a pointer to the created stage.\n\nUsing with Pipelines\n\nPipelines can have a configuration package set, and these are provided to each of the stages through the StageInterface system.\n\nSet the config package on a pipeline like this:\n\nThe package is copied and stored in the pipeline as a shared pointer. You can retrieve this from your stages through the StageInterface passed into your stage in initialize():\n\nThe above code fetches the config from the package that was registered with the name of the stage. You can fetch other configurations from the package if you like as well, using something like this:\n\nThis will return the configuration under ‘Name of Config to Use’, deserialized into the MyConfig structure.\n\nSee the pipeline section on configuration for more details.\n\nConfig Package Configuration\n\nYou can further adjust what configuration your system gets by configuring how the config package loads. You can do this via either command line interface or C++ APIs.\n\nIf you are using ark::main routines for your pipeline, you will have two options:\n\n--config-option - Allows selection of an ‘option’ for an individual stage/config block\n\n--config-override - Allows you to override a specific parameter within a stage/config block\n\nAs an example, say you have a sensor in a stage named SensorStage and it has two options (default and debug). For example:\n\nYou can swap from the default option to debug option with:\n\nIf you wanted to just override the parameter itself, you could do:\n\nYou can specify overrides and options multiple times.\n\nThese can be configured programmatically when loading config packages via the ConfigPackage::from_file method by populating the ark::config::ConfigPackageParseConfig structure. It allows you to adjust the same options, with the same syntax.\n\nSerializing\n\nYou can serialize and deserialize a full ConfigPackage, allowing you to log your configuration (or restore it later for viewing).\n\nThe APIs from_wire() and to_wire() will pass you back a serializable ConfigPackageWireData structure. This is an rbuf that can be written to logs or sent over the wire, containing all of your configuration data (in YAML form).\n\nParsing Individual Configurations\n\nIf you simply want to parse a YAML file into an rbuf, you can use the parse_config API on its own.\n\nAside from being YAML, the only real benefit over just parsing JSON is that the type checking and error messages are a bit more sensical.\n\nAs an example, say you have this YAML file:\n\nYou can parse that into a structure with this C++ code:\n\nNote that you can also request a specific option in your config file, as a second argument to parse_config:\n\nBy default, the default configuration is returned, just as with the package.\n\nIf you wish to return all of the configurations (options) at once (for example, to enumerate all of the names, or just because you want to load multiple configurations from the same file), you can do so with the parse_config_with_all_options API:\n\nCan be parsed with:\n\nThe configs object (in this case) is a std::map<std::string, video::VideoCaptureStageConfiguration> object, with the keys being default and second.\n\nUsing Variants\n\nYou can use variants within the YAML files. For example, if you have a configuration that looks something like:\n\nYou can configure it in YAML as such:\n\nOr alternatively,\n\nThe variant will be set properly in your C++ code based on the type field, as the nested object will be set from the value field.\n\nOptional Values"
    }
}