{
    "id": "correct_foundationPlace_00134_1",
    "rank": 85,
    "data": {
        "url": "https://forums.swift.org/t/swift-package-install-subcommand/58065",
        "read_more_link": "",
        "language": "en",
        "title": "`swift package install` Subcommand",
        "top_image": "https://global.discourse-cdn.com/swift/original/1X/0a90dde98a223f5841eeca49d89dc9f57592e8d6.png",
        "meta_img": "https://global.discourse-cdn.com/swift/original/1X/0a90dde98a223f5841eeca49d89dc9f57592e8d6.png",
        "images": [
            "https://emoji.discourse-cdn.com/apple/sweat_smile.png?v=12",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/calebkleveter/48/9273_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/mackoj/48/28251_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/migueldeicaza/48/31910_2.png",
            "https://emoji.discourse-cdn.com/apple/sweat_smile.png?v=12",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/serena/48/31019_2.png",
            "https://emoji.discourse-cdn.com/apple/sweat_smile.png?v=12",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/sdggiesbrecht/48/4768_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/stevapple/48/31979_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/serena/48/31019_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/stackotter/48/20670_2.png",
            "https://global.discourse-cdn.com/swift/original/2X/b/bad3e5f9ad67c1ddf145107ce7032ac1d7b22563.svg",
            "https://global.discourse-cdn.com/swift/optimized/3X/e/f/efa5b84003e4b97e315fd6d498bd85146da689e5_2_690x345.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/serena/48/31019_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/stackotter/48/20670_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/stackotter/48/20670_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/stackotter/48/20670_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/stackotter/48/20670_2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Serena (Serena)",
            "stevapple (YR Chen)",
            "SDGGiesbrecht (Jeremy David Giesbrecht)",
            "rauhul (Rauhul Varma)",
            "mman (Martin Man)",
            "xwu (Xiaodi Wu)"
        ],
        "publish_date": "2022-06-12T13:34:24+00:00",
        "summary": "",
        "meta_description": "Hello Swift Forums, \nI&#39;d like to know everyone&#39;s thoughts on a swift package install subcommand for SPM, which would clone &amp; compile a remote target executable, then move the compiled binary to a specified output path, i&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://global.discourse-cdn.com/swift/optimized/2X/6/610ef4c64700c53fad713dda8c9563c461d82e41_2_32x32.ico",
        "meta_site_name": "Swift Forums",
        "canonical_link": "https://forums.swift.org/t/swift-package-install-subcommand/58065",
        "text": "Hello Swift Forums,\n\nI'd like to know everyone's thoughts on a swift package install subcommand for SPM, which would clone & compile a remote target executable, then move the compiled binary to a specified output path, ie\n\nswift package install https://github.com/SerenaKit/NVRAMKit --target nvramutil -o /some/directory\n\nWhich would clone the given URL, compile the executable target specified, and output the binary at the specified output path.\n\nPlease let me know your thoughts on this, I have a working implementation thought a bit janky\n\nHas there ever been an implementation made before? I've made kind of a working one however there are still topics I want to discuss which haven't been fully resolved by those convos, ie, where should the bins even be installed? /usr/local/bin seems like the best solution here, however it may interfere if an existing binary exists there with the same name as the one being compiled, and something like ~/.swiftpm/bin would require the user to add said directory to their $PATH\n\nI think everyone could easily agree about something like the form in your original post, where the destination directory is specified manually. You currently have to manually filter the products directory to figure out what is actually part of the product (dynamic libraries, resources, etc.) and what is just intermediate junk (object files, source indices, synthesized headers, etc.) I am not sure install is the right word for it, since it is more a matter of bundling in order to vend, but it would be the first step toward a real installation command and still very useful on its own.\n\nDeciding on a default install location for permanent installations will be more contentious. It must support all the things SwiftPM does (most notably dynamic libraries and resources), and that makes it a non‐trivial decision.\n\nWe cannot support install only as an one-off option. We need to have a full set of tool to install, update and remove them. Also, how should we deal with dynamic libraries? If we place them together, different versions of the same dependency will certainly collide.\n\nOne solution I’ve come up with is to use the pre-pitched SwiftPM scripting support, which means we can put such file:\n\n#!/usr/bin/env swift script @package(…) import Executable Executable.main()\n\ninto $PATH, and manage it with the script management toolset.\n\nWith custom SwiftPM plugin, a tool developer is already able to write such a plugin to copy or link its product into a designated directory (with sandbox disabled), which can provide much more functionalities than what you proposed. To officially support this feature, we still need to investigate deeper, and I personally don’t think it’s of very high priority — particularly given that we have a solution by SwiftPM plugin now.\n\nI think it's a great idea & would love to see it become part of the package manager. I have written a program to accomplish the same task (mine's a bit janky as well). I'm using \"deploy\" as the verb. Naming the executable swift-deploy allows the Swift frontend to pick up it up from path through the swift command, so \"swift deploy\" is all I need to type to create a zip archive for deployment.\n\nA plugin still requires cloning the package yourself, and also only works for packages with the plugin. I think this proposed feature is trying to replace what mint does, and personally I’m all for that. Mint is getting a bit old and isn’t really maintained anymore (many easy issues and prs are sitting unfixed and unmerged). But it provides very useful functionality for distributing executable tools written in swift.\n\nOne possible default would be copying the tool and any dynamic libraries and resources it requires into ~/.swiftpm/bin/tool-name_version/ and then symlinking the executable into /usr/local/bin. This avoids clashes in dynamic library version I think (the executable should find libraries within the same directory as it). And would make versioning pretty easy. A more portable solution may be symlinking to ~/.swiftpm/bin/tool-name instead and requiring the swiftpm bin die to be added to the path (swiftpm could offer to automatically add that to the path on most systems the first time install gets run.\n\nWhat I meant was that installing an executable must work no matter how many of SwiftPM’s features it and its dependency graph exercise. It is not reasonable to tell users they can no longer update an installed executable because one of its transitive dependencies started using this or that feature.\n\nI am not suggesting that dynamic libraries or resources should be somehow installable as independent entities. My only concern is that if two installed executables depend on the same resources at different versions, they cannot stomp each other out, but must exist side‐by‐side. That rules out naïve dumping of products into /usr/local/bin.\n\nThe second is the strategy I use externally now (because of reduced odds of conflict with other installers), but the first seems reasonable to me as well, and I would be fine with either. I just suggest deferring it and focusing on arbitrary user‐controlled installation, because I expect it to not be long before someone comes around insisting that that is not where things belong on platform such‐and‐such. Discussions about this feature have shipwrecked on this very point several times in the past.\n\n./configure —prefix=/where/to/install && make install\n\nIs available and used on all *nix systems for ages and is a foundation for all Linux package managers as well as for brew used on macOS.\n\nIt works nicely by installing what is required where specified. Versioning and upgrades are left to the next layer to handle. Specifically brew does that very nicely allowing multiple versions of the same tool to exist at the same time.\n\nSo from where I sit, simple spm plugin that will mimic the ages old make install into given prefix will provide a solid foundation to build upon without reinventing the wheel…\n\nUpdate: I've made working, reliable implementations of 3 subcommands:\n\nswift package install-package\n\nswift package update-package\n\nswift package remove-package\n\nWhen using swift package install-package, the compiled binary is moved to ~/.swiftpm/bin, if the user doesn't have ~/.swiftpm/bin in their PATH, a warning is emitted.\n\nEach installed package is recorded in a JSON file in ~/.swiftpm/ by the name of installed-packages.json, the following info is recorded down:\n\nName (of the binary)\n\nRepo URL\n\nCommit checksum built from (so that later, we can compare when upgrading)\n\nBranch built from\n\nFull path as to where the compiled binary is placed\n\nUpgrading also works, and does so by comparing the checksum from which the executable was built from to the latest commit checksum of the repo, if it doesn't match, then it clones the repo, builds a new executable and replaces the old one.\n\nHere is the implementation:\n\nProbably a bit of a nitpick, but the trailing -package feels a bit clunky in these commands.\n\nMy main question is will these commands be able to install local packages? (an essential ability imo) Also, if given that the subcommands aren't necessarily operating on a package in a directory, it seems a little odd having them under the package subcommand because the description, and --package-path option, of the package subcommand contradict that usage:\n\nOVERVIEW: Perform operations on Swift packages ... --package-path <package-path> Specify the package path to operate on (default current directory). This changes the working directory before any other operation\n\nAnother consideration is the reliance on the package being a git repository, there might need to be some fallback behaviour for local packages that aren't git repositories (e.g. always assuming that the installed version is out of date when running update). Or maybe the update command doesn't really make sense for local packages. Maybe the update command shouldn't be included at all, because it could trip people up if they forgot which source they currently have a specific tool installed from (e.g. local vs github). As a precedent, Rust's cargo doesn't have an update command as far as I can tell, you just run install again (it's always clear where the package is going to get installed when done this way).\n\nRust's cargo tool might be a good place to look for inspiration. More specifically; cargo install, cargo uninstall and cargo pkgid (pkgid is used to identify packages in the uninstall subcommand).\n\nSwift package already have update and remove subcommands, so I couldn't just add new ones with the same name.\n\nThe implementation clones the repo URL given, adding support for local repos (ie swift package install .) could be done, i'll look into it today.\n\nI believe we can do better, which is why I made the update command. If we went the rust way, we'd have to get people to manually edit the JSON, and I do not want to do that.\n\nI'll be honest, I didn't want to go the route of relying on git. However, git makes it way easier to version each installed package / executable, believe me, it was either this or having to manually get the checksum of the binary produced, which would require us to recompile the repo every time the user requested to update."
    }
}