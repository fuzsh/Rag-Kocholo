{
    "id": "dbpedia_2451_3",
    "rank": 83,
    "data": {
        "url": "https://qubip.eu/the-role-of-quantum-computers-in-shors-algorithm/",
        "read_more_link": "",
        "language": "en",
        "title": "Quantum Computers' Role in Shor’s Algorithm",
        "top_image": "https://qubip.eu/wp-content/uploads/2023/09/QUBIP_logo.png",
        "meta_img": "https://qubip.eu/wp-content/uploads/2023/09/QUBIP_logo.png",
        "images": [
            "https://qubip.eu/wp-content/uploads/2023/09/QUBIP_Logo-300x145.jpg",
            "https://qubip.eu/wp-content/uploads/2023/09/QUBIP_Logo_White-300x145.png",
            "https://qubip.eu/wp-content/uploads/2023/09/Flag_of_Europe.jpg",
            "https://qubip.eu/wp-content/uploads/2023/09/Senza-titolo-1-1.png",
            "https://qubip.eu/wp-content/uploads/2023/09/QUBIP_Logo_White-300x145.png",
            "https://qubip.eu/wp-content/uploads/2023/09/Flag_of_Europe.jpg",
            "https://qubip.eu/wp-content/uploads/2023/09/Senza-titolo-1-1.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Qubip"
        ],
        "publish_date": "2023-10-16T17:39:53+00:00",
        "summary": "",
        "meta_description": "In 1994, Peter Shor published a paper in which he explained how to solve the computation of discrete logarithm and the factorization of large numbers in a computationally feasible way by using a quantum computer.",
        "meta_lang": "it",
        "meta_favicon": "https://qubip.eu/wp-content/uploads/2023/09/Favicon-66x66.png",
        "meta_site_name": "QUBIP",
        "canonical_link": "https://qubip.eu/the-role-of-quantum-computers-in-shors-algorithm/",
        "text": "Today widely used asymmetric cryptographic schemes are based on ideas that appear in two fundamental and very important papers from the 1970s, namely Diffie-Hellman [DH76] and RSA [RSA78]. The (difficult to solve) mathematical problems on which these schemes are based are:\n\nthe computation of discrete logarithm;\n\nthe factorization of large numbers.\n\nThe difficulty in solving the above problems is that the known ways to do that are computationally infeasible; namely, their cost, as measured by either the amount of memory used or the runtime, is finite but impossibly large.\n\nIn 1994, Peter Shor published a paper [Sho94] in which he explained how to solve both problems in a computationally feasible way by using a quantum computer. Thus, with just one blow, Shor showed how to break the asymmetric cryptography schemes developed in the 1970s and also their elliptic curve analogs developed in the 1980s.\n\nThe common thing shared by the above math problems is that you can solve them if you can efficiently compute the period p of periodic functions, i.e., f(x + p) = f(x) for all x.\n\nThen, the role of the quantum computer in Shor’s algorithm is to compute the period of periodic functions. More precisely, you are going to pass a periodic function f(x) as input to a quantum computer, and you are going to get as output the period p of f(x).\n\nThe mathematical link between factorization and periods was already understood by Gauss and developed in his famous “Disquisitiones Arithmeticae”. Here are the main observations:\n\n(a) fast computation of periods of periodic functions implies fast computation of non-trivial square roots of 1 modulo n;\n\n(b) fast computation of non-trivial square roots of 1 implies fast computation of non-trivial divisors of n.\n\nTo understand claim (b), recall that a non-trivial square root of 1 modulo n is a natural number x, 1 < x < n − 1, such that\n\nx2 = 1(modn).\n\nTake for example n = 15. Then 4 and 11 are non-trivial square roots of 1.\n\nSo assume you have such an x. Then, moving 1 to the left-hand side of the equation, you have\n\nx2 − 1 = (x − 1)(x + 1) = 0(modn).\n\nSo by computing gcd(x − 1,n) and gcd(x + 1,n), you get a non-trivial divisor of n. Computing gcd is known to be computationally feasible since Euclid’s times. Notice that for n = 15 the two non trivial square roots 4,11 gave the divisors gcd(4 + 1,15) = 5 and gcd(4 − 1,15) = 3.\n\nNow, to understand claim (a), pick some natural number a and consider the function f : ℤ →{0,1,…,n − 1} defined as:\n\nf(z) := az(modn)\n\nwhere az(modn) is the remainder of the division of az by n. It is quite easy to see that for most choices of a, the function f is a periodic function. So if you have a fast way to compute the period p of f, then you have\n\nap = 1(modn).\n\nNow if p = 2k is even, then x = ak is a non-trivial square root of 1, and you can use it to factorize n as explained above. If the period p is odd, then you try with another a, i.e., you change the periodic function and it is not an issue since there are almost the same number of odd and even periods.\n\nTo give an example, consider a = 7 and n = 15. Then the period of f(z) = 7z(mod15) is p = 4. You can check that 74 = 1(mod15). Then 72 = 4(mod15) is a non trivial square root of 1 modulo 15.\n\nTo get some insight into what is going on inside a quantum computer, we need to recall some facts about Fourier analysis.\n\nIt is well known that periodic functions are strongly related to Fourier analysis. But in almost all lectures on Fourier analysis, the period of the functions is well-known and fixed, usually to 2π, which is the length of the unit circle. Actually, the functions f you are going to learn how to compute their Fourier transforms f^ or Fourier coefficients are functions from the unit circle to complex numbers. So it is not so clear or obvious how to use Fourier analysis to compute periods of periodic functions. Things are more clear if you know the abstract theory called commutative harmonic analysis. In such a setting, it is straightforward to notice that the support of the Fourier transform f^ consists of multiples of the period p. The setting of commutative harmonic analysis involves a commutative group G, an invariant measure μ, the dual group Ĝ of characters χ’s, and the Fourier transform given by the integral:\n\nf^(χ) := ∫ Gf ⋅ χdμ.\n\nSo f^ has as domain the dual group of characters, and basic facts of harmonic analysis imply that the support of f^ are multiples of the periods of f.\n\nTo understand the above in the case of the periodic function f(z) = az, the above integral becomes a sum, but I still use the integral symbol:\n\nf^(z) = ∫ ℤf(x) ⋅ ex⋅zdx\n\nand if p is the period of f, a straightforward computation yields to\n\n(ez⋅p − 1)∫ ℤf(x) ⋅ ex⋅zdx = 0.\n\nHence the support of f^ consists of those characters corresponding to complex numbers z = i2π p s for an integer s ∈ ℤ.\n\nSumming up, if you have an efficient black box to compute the support of the Fourier coefficients of a periodic function, then you can compute its period p.\n\nIn his paper, Shor explained how to use a quantum computer to compute the Fourier transform, hence the period. Such a quantum computer consists of a register and the operators that change the state of the register.\n\nThe register is made up of a certain number of so-called qubits, which are the quantum analog of flip-flops. The mathematical model of one qubit is the 2-dimensional complex vector space V generated by two perpendicular unit vectors e0 and e1. The states of the qubit are the vectors of length one. A register of n qubits is modeled as the tensor product Vn = V ⊗⋯ ⊗V. Notice that the dimension is 2n. The states of the register are the unit vectors of Vn. The operators that can be used to change the state of the register are the unitary transformations of Vn, namely, complex linear maps of Vn that preserve the length of the vectors. At some point, to get the solution to your problem, you should read (or better yet, measure) the register. The output of such a measurement is going to be one of the 2n unit vectors forming the basis of tensor products. These 2n unit vectors can be regarded as the classical possible 2n states of a register with n flip-flops.\n\nTo illustrate the situation, imagine a register with 2 qubits. The state of such a register is a linear combination of the 22 = 4 tensor products:\n\ne0 ⊗ e0,e0 ⊗ e1,e1 ⊗ e0,e1 ⊗ e1.\n\nAssume that before the measurement, the state of the register is the linear combination:\n\nae0 ⊗ e0 + be0 ⊗ e1 + ce1 ⊗ e0 + de1 ⊗ e1\n\nwhere a, b, c, and d are complex numbers such that |a|2 + |b|2 + |c|2 + |d|2 = 1. If you measure the register, you can obtain e0 ⊗ e0 with probability |a|2, e0 ⊗ e1 with probability |b|2, and so on. Namely, the coefficients of the linear combination give you, in advance, the probabilities of the result of the measurement. Finally, after the measurement, the state of the register becomes the output of the measurement. For example, if you measure e1 ⊗ e0, then the state of the register becomes e1 ⊗ e0. Somehow after the measurement, the register loses information and is updated, by the laws of quantum physics, to the result of the measurement. So it is important to keep in mind that you are not going to read the register until you are sure, with high probability, that you are going to extract the result you need from the output of the\n\nmeasurement.\n\nYou can think of a quantum program as a sequence of unitary operators that take the register from an initial state to a final state ending with a measurement. The interesting thing is that you can put the register in a state in which all 2n outputs are equiprobable. Then you can apply an operator (or a sequence of operators) to such an equiprobable state instead of applying it to just one state, as happens in a classical register of flip-flops. This gives a kind of parallelism. For example, take n as a huge composite number. To compute the Fourier transform of f(x) = ax(modn) you need to compute all powers ax(modn) for too many values of x, which is a computationally infeasible task. The fast square-multiply algorithm can be used to compute a power ax for a given x, even if x is huge. In his paper, Shor explains how the square-multiply algorithm can be quantized (i.e., adapted to a quantum computer) and hence applied to the equiprobable state. So you can think that the quantum computer has managed somehow to compute all the powers at once. Remember that you cannot read the register, so you can try to quantize algorithms that are somehow uniform, i.e., the flow of instructions does not depend on reading the data. Here are two examples.\n\nFirst example: You have two bases of a finite-dimensional vector space. To perform a change of coordinates between them, you use a matrix M. Namely, you take the coordinates x of some vector, multiply Mx = y, and y are the new coordinates. Notice that the matrix M does not depend on the values of x! So the algorithm to change coordinates is uniform.\n\nSecond example: You have a matrix A, and you want to compute the Echelon reduced form E. You apply elementary row reductions, but from the very beginning, to know which reduction you should apply, you need to read data from A. Thus the algorithm to reduce a matrix A is not uniform.\n\nThe above perhaps gives you some intuition of why the Fourier transform can be expected to be quantized: just recall that Fourier transform is a change of basis of a vector space. Indeed, the function f(x) is a vector of some vector space, and the Fourier coefficients are its coordinates w.r.t. the basis of exponential functions. Thus the Fourier transform is indeed a change of coordinates.\n\nSo roughly speaking, Shor’s algorithm implements the Fourier transform of f(x) = ax(modn) in the setting of the quantum computer and then reads the register to obtain the support of its Fourier transform f^, hence it computes the period p of f(x). Actually, when you read the register to extract the period from the measurement, it is necessary to use a classical computer to get the period p.\n\nSumming up, you can regard the quantum computer as an accelerator that performs a specific computation very efficiently (e.g., periods of periodic functions). You can also regard the quantum computer on top of a classical computer as explained in Richard Borcherds’ [Bor21] YouTube post “The teapot test for quantum computers”.\n\nReferences\n\n[Bor21] Richard E. Borcherds. The teapot test for quantum computers. [Online]. Available: https://www.youtube.com/watch?v=sFhhQRxWTIM, 2021.\n\n[DH76] W. Diffie and M. Hellman. New directions in cryptography. IEEE Transactions on Information Theory, 22(6):644–654, 1976.\n\n[RSA78] R. L. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital signatures and public-key cryptosystems. Commun. ACM, 21(2):120–126, 1978.\n\n[Sho94] P.W. Shor. Algorithms for quantum computation: discrete logarithms and factoring. In Proceedings 35th Annual Symposium on Foundations of Computer Science, pages 124–134, 1994."
    }
}