{
    "id": "dbpedia_2451_3",
    "rank": 93,
    "data": {
        "url": "https://quantumpedia.uk/quantum-algorithm-1-shors-algorithm-for-factorization-part-1-cffcb4f0d0c1",
        "read_more_link": "",
        "language": "en",
        "title": "Quantum Algorithm (1): Shor’s algorithm for factorization — part 1",
        "top_image": "https://miro.medium.com/v2/resize:fit:767/0*jjJAFevdfprcLWWH.jpg",
        "meta_img": "https://miro.medium.com/v2/resize:fit:767/0*jjJAFevdfprcLWWH.jpg",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/1*ngdGBgmhcK62WizEUIpspg.png",
            "https://miro.medium.com/v2/resize:fill:144:144/1*ngdGBgmhcK62WizEUIpspg.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "QUANTUMPEDIA - The Quantum Encyclopedia",
            "quantumpedia.uk"
        ],
        "publish_date": "2023-02-15T00:36:48.245000+00:00",
        "summary": "",
        "meta_description": "Do you know how secure your online transactions really are? Well, thanks to Peter Shor’s groundbreaking quantum algorithm, the days of secure encryption could be numbered! Shor’s algorithm is a…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/1*m-R_BkNf1Qjr1YbyOIJY2w.png",
        "meta_site_name": "Medium",
        "canonical_link": "https://quantumpedia.uk/quantum-algorithm-1-shors-algorithm-for-factorization-part-1-cffcb4f0d0c1",
        "text": "What’s Quantum Fourier Transform?\n\nThe quantum Fourier transform (QFT) is a powerful tool for encoding decimal numbers into quantum states in the frequency domain. To do this, we first represent the decimal number x as a binary number x_b, and then initialize n qubits to represent the binary number. We then apply the QFT to the quantum state |x_b⟩ to obtain the encoded quantum state |x⟩, which represents the frequency components of the time-domain signal. The specific gate sequence used in the QFT depends on the number of qubits and the desired encoding precision.\n\nThe encoded quantum state |x⟩ is useful for solving various quantum algorithms, including period finding in Shor's algorithm for factoring large integers. Each basis state in |x⟩ corresponds to a frequency component of the signal, and the probability amplitudes of the basis states indicate the strength of each frequency component. Furthermore, this encoding can also be used to implement amplitude encoding, a common technique for initializing quantum states in quantum machine learning algorithms.\n\nConceptually, the QFT converts a quantum state that is represented as a superposition of basis states into a superposition of basis states that represent the frequency components of the original state. This is similar to how the classical Fourier transform converts a signal in the time domain into a signal in the frequency domain.\n\nThe QFT is a highly parallel and reversible operation, which makes it well-suited for quantum computing. It can be implemented using a sequence of controlled rotations or using a circuit of Hadamard gates and controlled-phase gates. These implementations make use of the inherent quantum properties of superposition and entanglement.\n\nIn addition, the QFT has many applications in quantum computing beyond Shor’s algorithm. For example, it can be used for quantum phase estimation, which is important in many quantum algorithms, including quantum simulation and quantum chemistry. It can also be used to solve linear systems of equations, which has applications in optimization and machine learning.\n\nCode implementation for Quantum Fourier Transform: (Qiskit)\n\n# import numpy and math\n\nimport numpy as np\n\nfrom numpy import pi\n\nimport math\n\n# importing Qiskit\n\nfrom qiskit import QuantumCircuit, transpile, assemble, Aer, IBMQ\n\nfrom qiskit.providers.ibmq import least_busy\n\nfrom qiskit.tools.monitor import job_monitor\n\nfrom qiskit.visualization import plot_histogram, plot_bloch_multivector\n\n# define functions for generating QFT\n\ndef qft_rotations(circuit, n):\n\n\"\"\"Performs qft on the first n qubits in circuit (without swaps)\"\"\"\n\nif n == 0:\n\nreturn circuit\n\nn -= 1\n\ncircuit.h(n)\n\nfor qubit in range(n):\n\ncircuit.cp(pi/2**(n-qubit), qubit, n)\n\n# At the end of our function, we call the same function again on\n\n# the next qubits (we reduced n by one earlier in the function)\n\nqft_rotations(circuit, n)\n\ndef swap_registers(circuit, n):\n\nfor qubit in range(n//2):\n\ncircuit.swap(qubit, n-qubit-1)\n\nreturn circuit\n\ndef qft(circuit, n):\n\n\"\"\"QFT on the first n qubits in circuit\"\"\"\n\nqft_rotations(circuit, n)\n\nswap_registers(circuit, n)\n\nreturn circuit\n\ndef inverse_qft(circuit, n):\n\n\"\"\"Does the inverse QFT on the first n qubits in circuit\"\"\"\n\n# First we create a QFT circuit of the correct size:\n\nqft_circ = qft(QuantumCircuit(n), n)\n\n# Then we take the inverse of this circuit\n\ninvqft_circ = qft_circ.inverse()\n\n# And add it to the first n qubits in our existing circuit\n\ncircuit.append(invqft_circ, circuit.qubits[:n])\n\nreturn circuit.decompose() # .decompose() allows us to see the individual gates\n\n# number of qubit is defined by our encoding number with the relationship of 2^n\n\n# for example : encoding number <8 , 2^3 = 8 , so # qubits = 3\n\n# Solving number:\n\nnumber = 16\n\nnqubits = math.ceil(math.log2(number))\n\n# Quantum circuit for QFT\n\nqc = QuantumCircuit(nqubits)\n\nfor qubit in range(nqubits):\n\nqc.h(qubit)\n\nfor qubit in range(nqubits):\n\nqc.p(number*pi/(2**(nqubits-qubit)),qubit)\n\nqc = inverse_qft(qc, nqubits)\n\nqc.measure_all()\n\nqc.draw()\n\nBased on the code we can generate the following quantum circuit for QFT:\n\nOnce you have created a quantum circuit using Qiskit, you may want to run it on a real quantum computer. The following code snippet demonstrates how to use Qiskit to get a list of available quantum computers provided by the IBM Quantum Experience and select the least busy one that meets the circuit’s requirements.\n\nIBMQ.load_account()\n\nprovider = IBMQ.get_provider(hub='ibm-q')\n\nbackends = provider.backends()\n\nfor backend in backends:\n\nprint(\"Backend name:\", backend.name())\n\nprint(\"Number of qubits:\", backend.configuration().n_qubits)\n\nprint(\"Is simulator:\", backend.configuration().simulator)\n\nprint(\"Is operational:\", backend.status().operational)\n\nprint()\n\nThen we can apply this circuit to a real quantum computer by following the code: (here we choose least busy quantum computer)\n\n# Load our saved IBMQ accounts and get the least busy backend device with less than or equal to nqubits\n\nIBMQ.load_account()\n\nprovider = IBMQ.get_provider(hub='ibm-q')\n\nprint(\"Available System\", provider)\n\nbackend = least_busy(provider.backends(filters=lambda x: x.configuration().n_qubits >= nqubits\n\nand not x.configuration().simulator\n\nand x.status().operational==True))\n\nprint(\"least busy backend: \", backend)\n\n# Job Submission\n\nshots = 2048\n\ntranspiled_qc = transpile(qc, backend, optimization_level=3)\n\njob = backend.run(transpiled_qc, shots=shots)\n\njob_monitor(job)\n\n# Visualizing the result by histogram (with 2048 shots)\n\ncounts = job.result().get_counts()\n\nplot_histogram(counts)\n\nAfter applying the quantum circuit constructed in the previous code, the result is obtained by measuring the qubits. The resulting binary representation is ‘1000’. To convert this binary representation to decimal, we add the values of each bit that is equal to 1, multiplied by its corresponding power of 2. In this case, the leftmost bit is equal to 1, corresponding to the value 2⁴, resulting in the decimal value of 16.\n\nIt is worth noting that the qubits in Qiskit are indexed from right to left, meaning that the rightmost bit corresponds to the least significant bit in the binary representation, while the leftmost bit corresponds to the most significant bit. Therefore, in this case, the leftmost bit that is equal to 1 corresponds to the value of ²⁴, which is the most significant bit and contributes the most to the resulting decimal value.\n\nIn conclusion, the QFT is a key component of many quantum algorithms, including Shor’s algorithm for factoring large integers and quantum phase estimation for estimating the eigenvalues of unitary operators. The QFT enables us to efficiently transform between the time domain and frequency domain of quantum states, which is a powerful tool for solving various problems in quantum computing.\n\nIn Part 2, we will explore the application of the QFT in Shor’s algorithm for factoring large integers, which involves finding the period of a function modulo a given integer. The QFT is used to efficiently find the period by transforming the function into the frequency domain and measuring the resulting quantum state."
    }
}