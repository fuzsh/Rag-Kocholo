{
    "id": "yago_12704_1",
    "rank": 80,
    "data": {
        "url": "https://stackoverflow.com/questions/329355/cannot-delete-directory-with-directory-deletepath-true",
        "read_more_link": "",
        "language": "en",
        "title": "Cannot delete directory with Directory.Delete(path, true)",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://i.sstatic.net/NZoTQ.png?s=64",
            "https://www.gravatar.com/avatar/1cd48a4e200eceec0b7946fcb207b3a7?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/f2922a76f2d4a84f285870476f72e8b9?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/UHGaR.jpg?s=64",
            "https://i.sstatic.net/Haz6W.jpg?s=64",
            "https://i.sstatic.net/lIi8J.jpg?s=64",
            "https://www.gravatar.com/avatar/16be06b16d37545f788c64f48955ce47?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/DgEW1.jpg?s=64",
            "https://www.gravatar.com/avatar/882af55cb13c9884bb4bfaa43388b986?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/ov5u9.jpg?s=64",
            "https://i.sstatic.net/6VS9J.png?s=64",
            "https://www.gravatar.com/avatar/79c962b8740942a1a88909a35c66ff64?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/WVaPd.jpg?s=64",
            "https://www.gravatar.com/avatar/bde1abf9482ea5f95283b781e9d34325?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/da682c7ec9a8375da6b0800ee6977e15?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/ToOjW.png?s=64",
            "https://i.sstatic.net/Z5c6A.jpg?s=64",
            "https://www.gravatar.com/avatar/16bdee967a646348ce99b88a7b9f310f?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/7d3dac9b66ba5f24a38c09e01830adab?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/2f07c19cd1ad4bf62734368f4169fbe1?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/GifRI.jpg?s=64",
            "https://i.sstatic.net/NXmaZ.png?s=64",
            "https://www.gravatar.com/avatar/8923f4ee3369259a4c73b450a81b8431?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/238e9e291777947b5825e0b68065aa26?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/bQ0vm.jpg?s=64",
            "https://i.sstatic.net/4d3qO.jpg",
            "https://i.sstatic.net/QT6F3.jpg",
            "https://www.gravatar.com/avatar/bf708cab6026b7780e96436d124b2047?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wlo8z.png?s=64",
            "https://www.gravatar.com/avatar/9777d5a9a11dea632e66552d46c11b07?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/8e93a8053f3e1887a7511aab404c8931?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/203f9bcf6c666c86af2be889b3353faa?s=64&d=identicon&r=PG",
            "https://graph.facebook.com/100000392600136/picture?type=large",
            "https://graph.facebook.com/10153844100526915/picture?type=large",
            "https://www.gravatar.com/avatar/f7fd90e8fb862f9e7228ce50e5ffabd2?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/d7db4d281067ef0e0682a3e1b0800660?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://lh3.googleusercontent.com/a/AAcHTtc08rISb_zcLyKBvOqW3zwhBVonya8wFIwhJZSqNPGJHIeM=k-s64",
            "https://i.sstatic.net/MTZr2.png?s=64",
            "https://stackoverflow.com/posts/329355/ivc/5f6f?prg=f5ee45d1-48ab-4a56-b0c8-03ed311f0ef9"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Nick Nick"
        ],
        "publish_date": "2008-11-30T20:57:03",
        "summary": "",
        "meta_description": "I'm using .NET 3.5, trying to recursively delete a directory using:\n\nDirectory.Delete(myPath, true);\r\nMy understanding is that this should throw if files are in use or there is a permissions proble...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/329355/cannot-delete-directory-with-directory-deletepath-true",
        "text": "Editor's note: Although this answer contains some useful information, it is factually incorrect about the workings of Directory.Delete. Please read the comments for this answer, and other answers to this question.\n\nI ran into this problem before.\n\nThe root of the problem is that this function does not delete files that are within the directory structure. So what you'll need to do is create a function that deletes all the files within the directory structure then all the directories before removing the directory itself. I know this goes against the second parameter but it's a much safer approach. In addition, you will probably want to remove READ-ONLY access attributes from the files right before you delete them. Otherwise that will raise an exception.\n\nJust slap this code into your project.\n\npublic static void DeleteDirectory(string target_dir) { string[] files = Directory.GetFiles(target_dir); string[] dirs = Directory.GetDirectories(target_dir); foreach (string file in files) { File.SetAttributes(file, FileAttributes.Normal); File.Delete(file); } foreach (string dir in dirs) { DeleteDirectory(dir); } Directory.Delete(target_dir, false); }\n\nAlso, for me I personally add a restriction on areas of the machine that are allowed to be deleted because do you want someone to call this function on C:\\WINDOWS (%WinDir%) or C:\\.\n\nIf you are trying to recursively delete directory a and directory a\\b is open in Explorer, b will be deleted but you will get the error 'directory is not empty' for a even though it is empty when you go and look. The current directory of any application (including Explorer) retains a handle to the directory. When you call Directory.Delete(true), it deletes from bottom up: b, then a. If b is open in Explorer, Explorer will detect the deletion of b, change directory upwards cd .. and clean up open handles. Since the file system operates asynchronously, the Directory.Delete operation fails due to conflicts with Explorer.\n\nIncomplete solution\n\nI originally posted the following solution, with the idea of interrupting the current thread to allow Explorer time to release the directory handle.\n\n// incomplete! try { Directory.Delete(path, true); } catch (IOException) { Thread.Sleep(0); Directory.Delete(path, true); }\n\nBut this only works if the open directory is the immediate child of the directory you are deleting. If a\\b\\c\\d is open in Explorer and you use this on a, this technique will fail after deleting d and c.\n\nA somewhat better solution\n\nThis method will handle deletion of a deep directory structure even if one of the lower-level directories is open in Explorer.\n\n/// <summary> /// Depth-first recursive delete, with handling for descendant /// directories open in Windows Explorer. /// </summary> public static void DeleteDirectory(string path) { foreach (string directory in Directory.GetDirectories(path)) { DeleteDirectory(directory); } try { Directory.Delete(path, true); } catch (IOException) { Directory.Delete(path, true); } catch (UnauthorizedAccessException) { Directory.Delete(path, true); } }\n\nDespite the extra work of recursing on our own, we still have to handle the UnauthorizedAccessException that can occur along the way. It's not clear whether the first deletion attempt is paving the way for the second, successful one, or if it's merely the timing delay introduced by the throwing/catching an exception that allows the file system to catch up.\n\nYou might be able to reduce the number of exceptions thrown and caught under typical conditions by adding a Thread.Sleep(0) at the beginning of the try block. Additionally, there is a risk that under heavy system load, you could fly through both of the Directory.Delete attempts and fail. Consider this solution a starting point for more robust recursive deletion.\n\nGeneral answer\n\nThis solution only addresses the peculiarities of interacting with Windows Explorer. If you want a rock-solid delete operation, one thing to keep in mind is that anything (virus scanner, whatever) could have an open handle to what you are trying to delete, at any time. So you have to try again later. How much later, and how many times you try, depends on how important it is that the object be deleted. As MSDN indicates,\n\nRobust file iteration code must take into account many complexities of the file system.\n\nThis innocent statement, supplied with only a link to the NTFS reference documentation, ought to make your hairs stand up.\n\n(Edit: A lot. This answer originally only had the first, incomplete solution.)\n\nBefore going further, check for the following reasons that are under your control:\n\nIs the folder set as a current directory of your process? If yes, change it to something else first.\n\nHave you opened a file (or loaded a DLL) from that folder? (and forgot to close/unload it)\n\nOtherwise, check for the following legitimate reasons outside of your control:\n\nThere are files marked as read-only in that folder.\n\nYou don't have a deletion permission to some of those files.\n\nThe file or subfolder is open in Explorer or another app.\n\nIf any of the above is the problem, you should understand why it happens before trying to improve your deletion code. Should your app be deleting read-only or inaccessible files? Who marked them that way, and why?\n\nOnce you have ruled out the above reasons, there's still a possibility of spurious failures. The deletion will fail if anyone holds a handle to any of the files or folders being deleted, and there are many reasons why someone may be enumerating the folder or reading its files:\n\nsearch indexers\n\nanti-viruses\n\nbackup software\n\nThe general approach to deal with spurious failures is to try multiple times, pausing between the attempts. You obviously don't want to keep trying forever, so you should give up after a certain number of attempts and either throw an exception or ignore the error. Like this:\n\nprivate static void DeleteRecursivelyWithMagicDust(string destinationDir) { const int magicDust = 10; for (var gnomes = 1; gnomes <= magicDust; gnomes++) { try { Directory.Delete(destinationDir, true); } catch (DirectoryNotFoundException) { return; // good! } catch (IOException) { // System.IO.IOException: The directory is not empty System.Diagnostics.Debug.WriteLine(\"Gnomes prevent deletion of {0}! Applying magic dust, attempt #{1}.\", destinationDir, gnomes); // see http://stackoverflow.com/questions/329355/cannot-delete-directory-with-directory-deletepath-true for more magic Thread.Sleep(50); continue; } return; } // depending on your use case, consider throwing an exception here }\n\nIn my opinion, a helper like that should be used for all deletions because spurious failures are always possible. However, YOU SHOULD ADAPT THIS CODE TO YOUR USE CASE, not just blindly copy it.\n\nI had spurious failures for an internal data folder generated by my app, located under %LocalAppData%, so my analysis goes like this:\n\nThe folder is controlled solely by my application, and the user has no valid reason to go and mark things as read-only or inaccessible inside that folder, so I don't try to handle that case.\n\nThere's no valuable user-created stuff in there, so there's no risk of forcefully deleting something by mistake.\n\nBeing an internal data folder, I don't expect it to be open in explorer, at least I don't feel the need to specifically handle the case (i.e. I'm fine handling that case via support).\n\nIf all attempts fail, I choose to ignore the error. Worst case, the app fails to unpack some newer resources, crashes and prompts the user to contact support, which is acceptable to me as long as it does not happen often. Or, if the app does not crash, it will leave some old data behind, which again is acceptable to me.\n\nI choose to limit retries to 500ms (50 * 10). This is an arbitrary threshold which works in practice; I wanted the threshold to be short enough so that users wouldn't kill the app, thinking that it has stopped responding. On the other hand, half a second is plenty of time for the offender to finish processing my folder. Judging from other SO answers which sometimes find even Sleep(0) to be acceptable, very few users will ever experience more than a single retry.\n\nI retry every 50ms, which is another arbitrary number. I feel that if a file is being processed (indexed, checked) when I try to delete it, 50ms is about the right time to expect the processing to be completed in my case. Also, 50ms is small enough to not result in a noticeable slowdown; again, Sleep(0) seems to be enough in many cases, so we don't want to delay too much.\n\nThe code retries on any IO exceptions. I don't normally expect any exceptions accessing %LocalAppData%, so I chose simplicity and accepted the risk of a 500ms delay in case a legitimate exception happens. I also didn't want to figure out a way to detect the exact exception that I want to retry on.\n\nYou can reproduce the error by running:\n\nDirectory.CreateDirectory(@\"C:\\Temp\\a\\b\\c\\\"); Process.Start(@\"C:\\Temp\\a\\b\\c\\\"); Thread.Sleep(1000); Directory.Delete(@\"C:\\Temp\\a\\b\\c\"); Directory.Delete(@\"C:\\Temp\\a\\b\"); Directory.Delete(@\"C:\\Temp\\a\");\n\nWhen trying to delete directory 'b', it throws the IOException \"The directory is not empty\". That's stupid since we just deleted the directory 'c'.\n\nFrom my understanding, the explanation is that directory 'c' is stamped as deleted. But the delete is not yet commited in the system. The system has reply the job is done, while in fact, it is still processing. The system probably wait the file explorer has focus on the parent directory to commit the delete.\n\nIf you look on the source code of the Delete function (http://referencesource.microsoft.com/#mscorlib/system/io/directory.cs) you will see it uses the native Win32Native.RemoveDirectory function. This do-not-wait behavior is noted here :\n\nThe RemoveDirectory function marks a directory for deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed.\n\n(http://msdn.microsoft.com/en-us/library/windows/desktop/aa365488(v=vs.85).aspx)\n\nSleep and retry is the solution. Cf the ryascl's solution.\n\nAs mentioned above the \"accepted\" solution fails on reparse points. There's a much shorter solution that properly replicates the functionality:\n\npublic static void rmdir(string target, bool recursive) { string tfilename = Path.GetDirectoryName(target) + (target.Contains(Path.DirectorySeparatorChar.ToString()) ? Path.DirectorySeparatorChar.ToString() : string.Empty) + Path.GetRandomFileName(); Directory.Move(target, tfilename); Directory.Delete(tfilename, recursive); }\n\nI know, doesn't handle the permissions cases mentioned later, but for all intents and purposes FAR BETTER provides the expected functionality of the original/stock Directory.Delete() - and with a lot less code too.\n\nYou can safely carry on processing because the old dir will be out of the way ...even if not gone because the 'file system is still catching up' (or whatever excuse MS gave for providing a broken function).\n\nAs a benefit, if you know your target directory is large/deep and don't want to wait (or bother with exceptions) the last line can be replaced with:\n\nThreadPool.QueueUserWorkItem((o) => { Directory.Delete(tfilename, recursive); });\n\nYou are still safe to carry on working.\n\nI've had this same problem with Windows Workflow Foundation on a build server with TFS2012. Internally, the workflow called Directory.Delete() with the recursive flag set to true. It appears to be network related in our case.\n\nWe were deleting a binary drop folder on a network share before re-creating and re-populating it with the latest binaries. Every other build would fail. When opening the drop folder after a failed build, the folder was empty, which indicates that every aspect of the Directory.Delete() call was successful except for deleting the actually directory.\n\nThe problem appears to be caused by the asynchronous nature of network file communications. The build server told the file server to delete all of the files and the file server reported that it had, even though it wasn't completely finished. Then the build server requested that the directory be deleted and the file server rejected the request because it hadn't completely finished deleting the files.\n\nTwo possible solutions in our case:\n\nBuild up the recursive deletion in our own code with delays and verifications between each step\n\nRetry up to X times after an IOException, giving a delay before trying again\n\nThe latter method is quick and dirty but seems to do the trick.\n\nThis is because of FileChangesNotifications.\n\nIt happens since ASP.NET 2.0. When you delete some folder within an app, it gets restarted. You can see it yourself, using ASP.NET Health Monitoring.\n\nJust add this code to your web.config/configuration/system.web:\n\n<healthMonitoring enabled=\"true\"> <rules> <add name=\"MyAppLogEvents\" eventName=\"Application Lifetime Events\" provider=\"EventLogProvider\" profile=\"Critical\"/> </rules> </healthMonitoring>\n\nAfter that check out Windows Log -> Application. What is going on:\n\nWhen you delete folder, if there is any sub-folder, Delete(path, true) deletes sub-folder first. It is enough for FileChangesMonitor to know about removal and shut down your app. Meanwhile your main directory is not deleted yet. This is the event from Log:\n\nDelete() didn't finish its work and because app is shutting down, it raises an exception:\n\nWhen you do not have any subfolders in a folder that you are deleting, Delete() just deletes all files and that folder, app is getting restarted too, but you don't get any exceptions, because app restart doesn't interrupt anything. But still, you lose all in-process sessions, app doesn't response to requests when restarting, etc.\n\nWhat now?\n\nThere are some workarounds and tweaks to disable this behaviour, Directory Junction, Turning Off FCN with Registry, Stopping FileChangesMonitor using Reflection (since there is no exposed method), but they all don't seem to be right, because FCN is there for a reason. It is looking after structure of your app, which is not structure of your data. Short answer is: place folders you want to delete outside of your app. FileChangesMonitor will get no notifications and your app will not be restarted every time. You will get no exceptions. To get them visible from the web there are two ways:\n\nMake a controller that handles incoming calls and then serves files back by reading from folder outside an app (outside wwwroot).\n\nIf your project is big and performance is most important, set up separate small and fast webserver for serving static content. Thus you will leave to IIS his specific job. It could be on the same machine (mongoose for Windows) or another machine (nginx for Linux). Good news is you don't have to pay extra microsoft license to set up static content server on linux.\n\nHope this helps."
    }
}