{
    "id": "dbpedia_7235_0",
    "rank": 62,
    "data": {
        "url": "https://www.sentinelone.com/blog/prometheus-metrics-by-example/",
        "read_more_link": "",
        "language": "en",
        "title": "Prometheus Metrics by Example: 5 Things You Can Learn",
        "top_image": "https://www.sentinelone.com/wp-content/uploads/2020/01/31123928/prometheus_metrics_shown_by_graph_measuring_flame.png",
        "meta_img": "https://www.sentinelone.com/wp-content/uploads/2020/01/31123928/prometheus_metrics_shown_by_graph_measuring_flame.png",
        "images": [
            "https://www.sentinelone.com/wp-content/themes/sentinelone/carbine/assets/svg/search-icon.svg",
            "https://www.sentinelone.com/wp-content/themes/sentinelone/carbine/assets/svg/search-icon.svg",
            "https://www.sentinelone.com/wp-content/themes/sentinelone/carbine/assets/svg/navigation-close-dark.svg",
            "https://www.sentinelone.com/wp-content/themes/sentinelone/assets/svg/header-logo-dark.svg",
            "https://www.sentinelone.com/wp-content/uploads/2021/09/Blog-1_SCALYR_Post_1200x628-1-1600x900.jpg",
            "https://www.sentinelone.com/wp-content/uploads/2020/01/31123928/prometheus_metrics_shown_by_graph_measuring_flame.png",
            "https://www.sentinelone.com/wp-content/uploads/2020/01/26205348/prometheus_core_metrics.jpg",
            "https://www.sentinelone.com/wp-content/uploads/2020/01/26210419/PrometheusPQ02.png",
            "https://www.sentinelone.com/wp-content/uploads/2020/01/26210633/PrometheusPQ01.png",
            "https://www.sentinelone.com/wp-content/uploads/2021/03/Blog_CTA_03.jpg",
            "https://www.sentinelone.com/wp-content/uploads/2022/04/labs_blog_cta.png",
            "https://www.sentinelone.com/wp-content/uploads/2022/04/mitre_blog_cta.jpg",
            "https://px.ads.linkedin.com/collect/?pid=2225260&fmt=gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "SentinelOne"
        ],
        "publish_date": "2020-08-05T16:13:12+00:00",
        "summary": "",
        "meta_description": "In this post, we'll discuss Prometheus metrics and highlight five things you can learn to get the most out of this useful tool.",
        "meta_lang": "en",
        "meta_favicon": "/wp-content/themes/sentinelone/assets/favicon-whyte/apple-touch-icon.png",
        "meta_site_name": "SentinelOne",
        "canonical_link": "https://www.sentinelone.com/blog/prometheus-metrics-by-example/",
        "text": "Whenever I looked up for monitoring system on the internet, Prometheus is something that frequently came up. After a point, I was like “Alright, I’ve been seeing this too much. Let’s give it a try!”. So, I started using Prometheus. I did the basic installation and configuring but I didn’t find it as impressive as much as I was reading about it on the internet. Soon, I realized that I wasn’t using Prometheus to its utmost potential.\n\nOnce you’ve been able to install, configure, and run sample queries to explore metrics in Prometheus, the next step is to learn how to get the most of it.\n\nPerhaps you’re just evaluating whether Prometheus works for your use case. For new users like me when I started, it could be confusing what to do next. For instance, which metrics are available? How do you see the metrics from servers or applications? Is it possible to see logs? In this post, I’ll answer these questions and share some other things you can learn to get the most out of Prometheus.\n\nSo, here are five things you can learn to have a better idea of how to use Prometheus.\n\n1. Core Metric Types Available\n\nOne of the first things you need to know is that metrics have a unique name with a raw value at the time it was collected. For instance, a metric with the name “go_gc_duration_seconds” will tell the GC (garbage collector) duration of each invocation from a Go application (in this case, Prometheus is the application). But for certain metrics, you’ll also have a type like “count” or “sum,” as seen in the graphic below (notice the suffixes):\n\nAt this moment, for Prometheus, all metrics are time-series data. The Prometheus client libraries are the ones in charge of aggregating metrics data, like count or sum. Usually, these client libraries—like the Go library from the graphic above—have four types of metrics: counter, gauge, history, and summary. Let me briefly explain them:\n\nCounter is for cumulative values, like the number of requests or errors.\n\nGauge is to represent a single value that can go up or down, like CPU usage.\n\nHistogram is used to track the size of an event, like a request time, and will group values in custom quantiles (buckets) depending on the data.\n\nSummary is similar to a histogram, but the difference is that the quantiles don’t depend on the data (typically, you’ll have 0.5, 0.9, or 0.99 quantiles).\n\nI’d advise you to always take a look at the client library docs to understand what metric types they can generate when you use them. Also, read Prometheus docs on best practices for histograms and summaries.\n\n2. Direct Instrumentation With Client Libraries\n\nAt this moment, I’ve talked about some of the default metrics you’ll get with a fresh Prometheus installation. The first metrics you’ll be able to explore will be about the Prometheus instance you’re using. Therefore, if you want to have more metrics in Prometheus, you have to instrument your applications to do so—this process is called “direct instrumentation.” And here’s where the client libraries come in.\n\nPrometheus has a list of official libraries for languages like Go or Java. But there are also third-party libraries that cover pretty much all the popular programming languages.\n\nThe benefit of using these libraries is that in your code, you only have to add a few lines of code to start emitting metrics. You don’t have to worry about Prometheus’ text format or how to expose the “metrics” endpoint correctly (more on this later). These libraries will help you get started quickly. Moreover, you’ll get some default metrics out of the box, like CPU usage.\n\nIn case you want to see some code, here’s the “Hello, World!” for instrumenting a Go application:\n\npackage main import ( \"net/http\" \"time\" \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promauto\" \"github.com/prometheus/client_golang/prometheus/promhttp\" ) func recordMetrics() { go func() { for { opsProcessed.Inc() time.Sleep(2 * time.Second) } }() } var ( opsProcessed = promauto.NewCounter(prometheus.CounterOpts{ Name: \"myapp_processed_ops_total\", Help: \"The total number of processed events\", }) ) func main() { recordMetrics() http.Handle(\"/metrics\", promhttp.Handler()) http.ListenAndServe(\":2112\", nil) }\n\n3. Indirect Instrumentation With Exporters\n\nThere might be other applications or systems that you don’t own and therefore can’t instrument to emit metrics—for instance, an NGINX server. As long as there are some logs you can read—like the error and access logs provided by NGINX—you’re good. In these scenarios, you need what Prometheus calls “exporters.”\n\nAn exporter is a tool that you deploy with your applications or systems. Exporters act as a proxy between your systems and Prometheus. Prometheus will ask this proxy for metrics, and this tool will take care of processing data, transform it, and return it to Prometheus—this process is called “indirect instrumentation.”\n\nThere are tons of exporters, and each one is configured differently. For example, there’s a node exporter that you could install in a Linux machine and start emitting OS metrics for consumption by Prometheus. Windows has support as well. And continuing with the NGINX example, you could install an exporter for NGINX written in Lua and then have an nginx.conf file like this:\n\nserver { listen 9145; allow 192.168.0.0/16; deny all; location /metrics { content_by_lua ' metric_connections:set(ngx.var.connections_reading, {\"reading\"}) metric_connections:set(ngx.var.connections_waiting, {\"waiting\"}) metric_connections:set(ngx.var.connections_writing, {\"writing\"}) prometheus:collect() '; }\n\n4. Prometheus Is Suitable for Metrics Only\n\nOne thing that’s essential to keep in mind is that Prometheus is a tool for collecting and exploring metrics only. This is because Prometheus works with a data model with time series, in which data is identified by a metric name and contains key/value pairs.\n\nIn other words, you can’t use Prometheus for logging or event-driven architectures in which you must track individual events. Notice that none of the examples or use cases I’ve used in previous sections are for logs. Prometheus is suitable for storing CPU usage, latency requests, error rates, or networking bandwidth.\n\nAnother essential feature from Prometheus is that it makes trade-offs with the data it collects. This means that it will prefer to offer data that is 99.99% correct (per their docs) instead of breaking the monitoring system or degrading performance. So, expect to lose some data, and don’t use it for critical information like bank account balances.\n\n5. Prometheus Is a Pull-Based Metrics System\n\nFrom the code and configuration examples I used in the previous section, you may have noticed that we need to expose a “/metrics” endpoint. Client libraries, or exporters, don’t send metrics directly to Prometheus.\n\nInstead, what they do is to expose an endpoint that returns a payload with all the metrics available in the Prometheus format. Every certain amount of time—say, five minutes—Prometheus will consume this endpoint to collect data. This endpoint has to return a payload in a format that Prometheus can understand.\n\nSo, Prometheus pulls (or “scrapes”) metrics whenever it needs. This is what’s called a “pull-based system,” and it’s a good approach when you have to monitor a lot of servers and applications. You’d prefer to have data arriving late, rather than to lose data.\n\nPrometheus has a blog post that talks about the challenges, benefits, and downsides of both pull and push systems. I’m not trying to go more in-depth on this subject. What I want you to know is that the preferred way of working with Prometheus is by exposing an endpoint that emits metrics in a specific format. It doesn’t mean that Prometheus can’t work with a push-based approach. But you should choose this approach only when it’s necessary.\n\nNumeric Time-Series Monitoring\n\nToday I focused on the metrics side of Prometheus. Once you have data arriving at the tool, you’ll need to start analyzing it, creating graphs, and creating alerts. Otherwise, metrics alone won’t be too beneficial.\n\nPrometheus is a simple tool, as reflected by UI. And once you understand the basics of how and why it works the way it works, the rest will be evident. For me, in the beginning, I was treating Prometheus as a push-based system and thought that it was only useful for Kubernetes. But as this post shows, Prometheus can collect metrics from a variety of sources.\n\nWith the help of client libraries, you don’t have to code each integration anymore. The benefit here is that you don’t have to worry about Prometheus text format. Prometheus text format became a standard a couple of years ago. But it is not a global standard. A team of engineers is working on developing a neutral standard that would be relevant for all the vendors. This is known as the OpenMetrics Project.\n\nSo, that’s it! Remember that Prometheus is a numeric time-series monitoring tool—and that metrics won’t arrive from heaving or by using a magic trick. You need to instrument your systems properly. If you’d like to go deeper with Prometheus, I’d recommend you read the book Prometheus Up & Running by Brian Brazil."
    }
}