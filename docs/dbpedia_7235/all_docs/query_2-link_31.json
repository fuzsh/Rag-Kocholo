{
    "id": "dbpedia_7235_2",
    "rank": 31,
    "data": {
        "url": "https://www.form3.tech/blog/engineering/customers-incidents-prometheus",
        "read_more_link": "",
        "language": "en",
        "title": "Keeping Customers Informed During Incidents with Prometheus",
        "top_image": "http://localhost:3000/_prismic-media/d17aeaa9f899e24554dd08935f47464f37d91e01431a3a1c299f4e6beec783fa.jpg",
        "meta_img": "http://localhost:3000/_prismic-media/d17aeaa9f899e24554dd08935f47464f37d91e01431a3a1c299f4e6beec783fa.jpg",
        "images": [
            "https://www.form3.tech/_nuxt/img/logo-dark.339ede7.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_prismic-media/a0488456d1c9518dcba57f42d410c9ec67c386a32f1684beb57a2a83ca0fec5c.png",
            "https://www.form3.tech/_nuxt/img/arrow-right-teal.f8b08f0.svg",
            "https://www.form3.tech/_prismic-media/0c67c87669e0cf40fe649828e46addd6beeea89b3177057917faa1972e05e719.png",
            "https://www.form3.tech/_nuxt/img/arrow-right-teal.f8b08f0.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_prismic-media/0aa2294aa3128e346ee4657906a81b4ea7c935cf9a1c8766b7c0d1b0e00d67e5.png=compress,format&rect=0,0,300,300&w=240&h=240",
            "https://www.form3.tech/_nuxt/img/dark-angle-angle-front-and-back.2206315.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_nuxt/img/arrow-right-dark.dba56c9.svg",
            "https://www.form3.tech/_prismic-media/08acbef2a2e6fc952242a6da1d68250bc16c9b9e4d6e222fd6f4dbea4777db77.png",
            "https://www.form3.tech/_nuxt/img/arrow-right-teal.f8b08f0.svg",
            "https://www.form3.tech/_prismic-media/ad412d85e59485d343c6c3f1bd1b5fc569e7f60f1342ab8d42612f61b783f92a.png%2Ccompress&rect=0%2C10%2C600%2C300&w=400&h=200",
            "https://www.form3.tech/_nuxt/img/arrow-right-teal.f8b08f0.svg",
            "https://www.form3.tech/_nuxt/img/logo-dark.339ede7.svg",
            "https://www.form3.tech/_prismic-media/95afe4569a64cba095443b2305d62eb9eecbfb2d165ae4867715619473475c35.svg",
            "https://www.form3.tech/_prismic-media/3139b8c1786ceb8f0cd8409b6dbd2cbd8dd608c9a1087258ab15f76e9f00ab1c.png",
            "https://www.form3.tech/_prismic-media/40ce5b78767b0e1ce0cef01b1ed1bf0fef2d68e53353d648c09eb543d73a87d5.svg",
            "https://www.form3.tech/_prismic-media/51ebd9182f2b238e1458704b7197681d8ba99eeba3ffe4a0f60dd915475a1d4b.jpg 1024w,/_prismic-media/46c45ba0cc95b6b8c43818aa5f56e46067f7f57e9e30dad7e9a602f3b79ec3a1.jpg 640w",
            "https://www.form3.tech/_nuxt/img/github-circle-white-48px.cf33952.svg",
            "https://www.form3.tech/_nuxt/img/twitter-circle-white-48px.19aa0bf.svg",
            "https://www.form3.tech/_nuxt/img/linkedin-circle-white-48px.ea7908f.svg",
            "https://www.form3.tech/_nuxt/img/chevron-down-20px-dark.2c1d915.svg",
            "https://www.form3.tech/_nuxt/img/chevron-down-20px-dark.2c1d915.svg",
            "https://www.form3.tech/_nuxt/img/chevron-down-20px-dark.2c1d915.svg",
            "https://www.form3.tech/_nuxt/img/chevron-down-20px-dark.2c1d915.svg",
            "https://www.form3.tech/_nuxt/img/linkedin-line-dark.04daa3c.svg",
            "https://www.form3.tech/_nuxt/img/twitter-line-dark.3d5eff8.svg",
            "https://www.form3.tech/_nuxt/img/youtube-line-dark.c7bad6c.svg",
            "https://www.form3.tech/_nuxt/img/instagram-line-dark.f92ab92.svg",
            "https://www.form3.tech/_nuxt/img/linkedin-line-dark.04daa3c.svg",
            "https://www.form3.tech/_nuxt/img/twitter-line-dark.3d5eff8.svg",
            "https://www.form3.tech/_nuxt/img/youtube-line-dark.c7bad6c.svg",
            "https://www.form3.tech/_nuxt/img/instagram-line-dark.f92ab92.svg",
            "https://www.form3.tech/_nuxt/img/aws-partner-icon-dark.3ec7b9c.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "prometheus",
            "incidents",
            "grafana"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Maintaining customer satisfaction during incidents is crucial for any business. In this blogpost, Piotr shares how we leverage Prometheus to expose business metrics in a secure and cost-effective way to keep customers informed and happy during those stressful situations.",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "In today's rapidly-evolving digital landscape, a strong online presence and seamless service delivery are crucial for businesses to keep their competitive edge. For industries such as payments, where interruptions in service can result in significant financial and reputational consequences, incident management is especially critical.\n\nIn the past, businesses relied on basic processes to detect and respond to incidents, such as posting updates on social media platforms like Twitter. Unfortunately, these approaches often resulted in slow response times and poorly structured communication with customers. As customer expectations continue to rise, mature incident management processes have become essential. While it's impossible to completely prevent incidents, businesses must have reliable and robust processes in place to detect, respond, and communicate effectively during incidents.\n\nAt Form3, we take our incident management processes a step further by providing customers with the ability to integrate product metrics into their incident response procedures. Unlike many third-party providers who only offer dashboard displays of their products, we offer our customers the ability to fetch and convert Prometheus metrics into different formats, enabling seamless integration with their chosen monitoring solutions. This means our customers are able to assess the impact of the outage, enabling them to take their own mitigation steps and communicate effectively with customers of their own.\n\nWhile our approach offers many benefits and significant value for our customers, it also presents a unique set of challenges on both technical and organisational levels. In this series, we will guide you through our complete solution, with a focus on metric consumption in this first article, followed by two subsequent articles. Part 2 (link to follow!) will focus on secure and effective method of metric ingestion. In Part 3 we will zoom out to the organisational level and the challenges that come with effective implementation of this product.\n\nLet's begin!\n\nAs previously mentioned, Form3's preferred monitoring system is Prometheus. While we won't delve too deeply into the specifics of its functionality, it is a cloud-agnostic, open-source project licensed under Apache 2.0, solution that provides us with the ability to monitor our infrastructure and applications using metrics such as counters, gauges, and histograms. We utilise these metrics in a number of ways, including using them in conjunction with Grafana, which is a metric, logs and tracing visualisation software. We are using their SaaS offering that enables us to focus on value added services, exactly like the one described in this article. These tools provide benefits both from a debugging perspective of our systems and for alerting purposes that summon on-call engineers when something goes bad. To make metrics easily explorable and engineer-friendly, we typically store them in a single storage location per environment, with isolation between environments to prevent errors in one environment from affecting another. Nonetheless, this approach presents a challenge:\n\nHow do we split metrics, make them accessible to customers and not break a bank at the same time?\n\nThe problem is that External Metrics are stored in the same location as internal metrics, and creating a separate storage location would be costly in terms of additional servers and fees, especially as we are a multi-tenant platform. Storing metrics separately for each customer is just not feasible.\n\nEnter Metrics API\n\nTo address this issue, we have developed Metrics API, a query-enhancing service that enables us to store all metrics together while still providing access to a subset of external metrics.\n\nMetrics API will serve as an intermediary between our Prometheus server and our customers. When a customer wants to access their metrics, Metrics API will authenticate their request and check if they have access rights based on their organisation ID. If authorised, Metrics API will execute a PromQL query against the Prometheus server to retrieve the requested metrics and return them to the customer.\n\nTo implement this solution, we will expose this service via an API gateway that will handle the authentication and authorisation of the requests. The API gateway will also handle rate limiting and other security-related concerns.\n\nSlice & Dice Metrics\n\nIn order to separate internal and external metrics while minimising costs, Metrics API service splits metrics into subsets based on their labels. This is possible thanks toÂ PromQLÂ (Prometheus Query Language), which allows us to slice and dice metrics in various ways, given the source of the metric assigns special labels to it to indicate its dimensions.\n\nFor example, to distinguish between internal and external metrics, we can add a unique label, such asÂ metric_purpose=\"external\". To split them for each customer, we can use a UUID label for each organisation represented on our platform (e.g.:Â organisation_id=\"UUID\") or anything that identifies the entity for which the metric is produced. Additional dimensions such as a list of products could also be added with labels likeÂ origin=\"product_name\". However, we should be aware that each label increases maintenance costs as it introduces new complexities to the code.\n\nIn summary, the following query will retrieve all external metrics for an organisation with a givenÂ UUID:Â {metric_purpose=\"external\", organisation_id=\"UUID\"}. In addition to that Metrics API also includes usability features, such as automatic label filling so customers can submit any valid query, for instance an empty one:Â {}.\n\nSo, the problem we're solving with Metrics API is\n\nHow do we enforce the minimal required set of labels on each customers' query?\n\nWhen it comes to providing good isolation of metrics through label selectors, we need to be careful with labels that allow for looser selection, such asÂ organisation_id. For example, if a customer has multiple organisations but only one user to fetch these metrics, on the one hand we would want to allow them to select a subset of organisation IDs instead of just one. On the other hand however, we cannot allow just any regular expression for these labels when the customer has full power for it. Therefore, we only allow a very limited set of regular expressions, such as an alphanumeric string (without special characters) or an alternative of them -Â organisation_id =~ \"UUID1|UUD2\". Negative queries, such asÂ organisation_id != X, are all forbidden in order to prevent potential security risks. Moreover, we don't need to worry about other labels, as the restricted labels properly narrow down the set of queryable metrics.\n\nNow that we understand why we need Metrics API, what problem we're trying to solve, and how to do it, let's talk about the implementation.\n\nImplementation Scope\n\nMetrics API is essentially a HTTP proxy that mimics a subset of Prometheus API endpoints. While we won't go into details about the general implementation, we'll focus on the interesting parts: which endpoints we need to implement, how to implement them using Prometheus as a library, and what technical challenges we faced during the implementation.\n\nThe core functionality of Metrics API is to fetch metric data in Prometheus format. In other words we're interested in implementing these three endpoints:Â /api/v1/query,Â /api/v1/query_range, andÂ /federate.\n\n/api/v1/queryÂ endpoint is used by Grafana, among others, inÂ stat panelsÂ to display a current statistic.\n\n/api/v1/query_rangeÂ endpoint is used by Grafana inÂ time series panelsÂ to display how the value changes in time.\n\nIf your customers only use Grafana, these endpoints would suffice. We should also note that while you could implement additional endpoints for querying label names and values, they may not add much value compared to the implementation effort required.\n\n/federateÂ endpoint, on the other hand, allows Prometheus instances to be federated. One useful scenario is that customers can set up their own Prometheus instance to federate with Metrics API and send alerts based on their custom alerting rules.\n\nThe Heart of Metrics API\n\nNow let's move on to the core of the Metrics API service - its query enhancing engine. At Form3, the majority of our services are implemented using Go. Go is a programming language that was developed by Google, with a focus on building efficient, scalable, and reliable software. Because of its simplicity, speed, and ease of use, it is an ideal language for our purposes.\n\nPrometheus is written in Go, we were able to leverage its functionality with minimal effort to securely parse and enhance incoming PromQL queries. To parse the query, we utilise theÂ ParseExprÂ function from theÂ github.com/prometheus/prometheus/promql/parserÂ package, which returns an expression struct that represents the abstract syntax tree of the input query.\n\nAs an example, consider the following Prometheus query:Â rate(http_requests_total{job=\"api-server\"}[5m]). The corresponding abstract syntax tree is shown below:\n\nThe AST shows the structure of the query in a tree-like format, where each node represents an operation or function call, and its children represent the arguments or operands. In this case, the top-level node is a function call to theÂ rateÂ function, which has two arguments: a vector selector and a duration scalar. The vector selector is itself a function call to theÂ http_requests_totalÂ metric, with a label matcher that selects only the metrics with aÂ jobÂ label equal toÂ \"api-server\".\n\nExpressions in PromQL consist of multiple elements, but for our purposes, we are specifically interested in theÂ parser.VectorSelectorÂ nodes within the AST. These nodes are responsible for selecting metrics, and if we can modify them to enforce the rules outlined in the previous section, we will achieve our objective. To accomplish this, we must traverse the AST and modify all Vector Selectors accordingly. While it may seem daunting to implement a tree algorithm, it is not that complicated using a recursive function, which we outlined below.\n\nImportant Note: All code examples in this article have been simplified for clarity.Â For instance the code snippet below considers onlyÂ caseÂ types relevant to the example discussed above. To parse any and all Prometheus queries, the code must consider all possible AST node types, which can be foundÂ here.\n\nThe recursive function above is responsible for traversing the abstract syntax tree of the Prometheus query and modifying allÂ *parser.VectorSelectorÂ nodes using theÂ labelModÂ function. Although this function is relatively simple, we believe it could be useful to see how to implement it.\n\nNow that we understand how to locate and modify each vector selector, let's explore how we might implement theÂ labelModÂ function. As the rules become more complex, the implementation will likewise become more complicated. TheÂ labelModÂ function modifies one label at a time, with each label modification split into one of its sub-functions. To keep things simple, let's focus on enforcing theÂ metric_purpose=\"external\"Â rule to separate external metrics from internal ones.\n\nDuring the implementation of the Metrics API service, we encountered a few technical challenges. It turns out that seemingly the most boring task presented the most interesting ones.\n\nReady, Set, Stream!\n\nImplementing theÂ /federateÂ endpoint was necessary because Grafana Cloud (our metrics storage provider) doesn't provide it. Fortunately, all the data served by this endpoint could be fetched fromÂ /api/v1/queryÂ one, which is used for fetching instant vectors. The only difference, and the work we have to do, is response formatting. Sounds easy, right?\n\nThe problem is that some queries can have large amounts of metrics returned, especially if a customer was monitoring multiple organisations on our platform. This resulted in a huge memory footprint for our Metrics API, which was consuming around 500 megabytes of memory, making it hard to justify given it's such a small service. To solve this issue, we decided to stream both:\n\nthe incoming JSON response from Prometheus,\n\nthe formattedÂ /federateÂ response to the customer.\n\nStreaming allowed us to parse the incoming JSON response as it was being transferred from the backend storage, format it, and send it to the customer in theÂ /federateÂ format without keeping the whole response in memory. Instead, we only kept the amount we parsed, which was just one metric at a time.\n\nThis resulted in the memory footprint reduction to just 15 megabytes, which is a 33 times decrease!\n\nThe Implementation\n\nIn this section we'll focus on memory optimisations that made such a drastic difference. In reality, the implementation has to consider many things. For instance - always populating the response with at least one metric. Otherwise, the federating Prometheus on customers' side would think that we are down if no metrics are returned, but in fact it could be that they've just inserted a query that returns an empty set of metrics. With that out of the way, let's see the code!\n\nThe biggest difference boils down to instead of using\n\nAfter decoding a single metric sample we need to convert it to theÂ /federateÂ format. To do this effectively we use a helper buffer that allows us to quickly create the output array of bytes we need. We need this because in Go, strings are immutable, which means that once created, their value cannot be modified. Concatenating two strings, therefore, requires creating a new string that contains the contents of both strings. This process can be expensive both in terms of both memory allocation as well as copying. Using a buffer in Go can help mitigate this cost by allowing you to build up a string incrementally without creating a new string for each concatenation operation. A buffer is a mutable sequence of bytes that can be used to efficiently build up a larger string by appending smaller strings to it. When the byte representation of the final string has been constructed, you can use theÂ String()Â method of the buffer to obtain the value.\n\nWe omit the implementation ofÂ writeMetricInFederateFormatÂ as it just concatenates strings using the aforementioned buffer - no magic there."
    }
}