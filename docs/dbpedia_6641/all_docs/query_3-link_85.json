{
    "id": "dbpedia_6641_3",
    "rank": 85,
    "data": {
        "url": "https://teachyourselfcs.com/",
        "read_more_link": "",
        "language": "en",
        "title": "Teach Yourself Computer Science",
        "top_image": "https://teachyourselfcs.com/favicon.ico",
        "meta_img": "https://teachyourselfcs.com/favicon.ico",
        "images": [
            "https://teachyourselfcs.com/bilotta-tweet.png",
            "https://teachyourselfcs.com/sicp.jpg",
            "https://teachyourselfcs.com/csapp.jpg",
            "https://teachyourselfcs.com/skiena.jpg",
            "https://teachyourselfcs.com/polya.jpg",
            "https://teachyourselfcs.com/ostep.jpeg",
            "https://teachyourselfcs.com/top-down.jpg",
            "https://teachyourselfcs.com/redbook.jpg",
            "https://teachyourselfcs.com/data-reality.jpg",
            "https://teachyourselfcs.com/dragon.jpg",
            "https://teachyourselfcs.com/ddia.jpg"
        ],
        "movies": [
            "https://oznova.substack.com/embed"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "All the resources you need to give yourself a world class computer science education",
        "meta_lang": "",
        "meta_favicon": "favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Most undergraduate CS programs start with an “introduction” to computer programming. The best versions of these courses cater not just to novices, but also to those who missed beneficial concepts and programming models while first learning to code.\n\nOur standard recommendation for this content is the classic Structure and Interpretation of Computer Programs, which is available online for free both as a book, and as a set of MIT video lectures. While those lectures are great, our video suggestion is actually Brian Harvey’s SICP lectures (for the 61A course at Berkeley) instead. These are more refined and better targeted at new students than are the MIT lectures.\n\nWe recommend working through at least the first three chapters of SICP and doing the exercises. For additional practice, work through a set of small programming problems like those on exercism.\n\nSince this guide was first published in 2016, one of the most commonly asked questions has been whether we’d now recommend recordings of a more recent iteration of 61A taught by John DeNero, and/or the corresponding book Composing Programs, which is “in the tradition of SICP” but uses Python. We think the DeNero resources are also great, and some students may end up preferring them, but we still suggest SICP, Scheme, and Brian Harvey’s lectures as the first set of resources to try.\n\nWhy? Because SICP is unique in its ability—at least potentially—to alter your fundamental beliefs about computers and programming. Not everybody will experience this. Some will hate the book, others won't get past the first few pages. But the potential reward makes it worth trying.\n\nIf you don't enjoy SICP, try Composing Programs. If that still doesn't suit, try How to Design Programs. If none of these seem to be rewarding your effort, perhaps that's a sign that you should focus on other topics for some time, and revisit the discipline of programming in another year or two.\n\nFinally, a point of clarification: this guide is NOT designed for those who are entirely new to programming. We assume that you are a competent programmer without a background in computer science, looking to fill in some knowledge gaps. The fact that we've included a section on \"programming\" is simply a reminder that there may be more to learn. For those who've never coded before, but who'd like to, you might prefer a guide like this one.\n\nComputer Architecture—sometimes called “computer systems” or “computer organization”—is an important first look at computing below the surface of software. In our experience, it’s the most neglected area among self-taught software engineers.\n\nOur favorite introductory book is Computer Systems: A Programmer's Perspective, and a typical introductory computer architecture course using the book would cover most of chapters 1-6.\n\nWe love CS:APP for the practical, programmer-oriented approach. While there's much more to computer architecture than what's covered in the book, it serves as a great starting point for those who'd like to understand computer systems primarily in order to write faster, more efficient and more reliable software.\n\nFor those who'd prefer both a gentler introduction to the topic and a balance of hardware and software concerns, we suggest The Elements of Computing Systems, also known as “Nand2Tetris”. This is an ambitious book attempting to give you a cohesive understanding of how everything in a computer works. Each chapter involves building a small piece of the overall system, from writing elementary logic gates in HDL, through a CPU and assembler, all the way to an application the size of a Tetris game.\n\nWe recommend reading through the first six chapters of the book and completing the associated projects. This will develop your understanding of the relationship between the architecture of the machine and the software that runs on it.\n\nThe first half of the book (and all of its projects), are available for free from the Nand2Tetris website. It’s also available as a Coursera course with accompanying videos.\n\nIn seeking simplicity and cohesiveness, Nand2Tetris trades off depth. In particular, two very important concepts in modern computer architectures are pipelining and memory hierarchy, but both are mostly absent from the text.\n\nOnce you feel comfortable with the content of Nand2Tetris, we suggest either returning to CS:APP, or considering Patterson and Hennessy’s Computer Organization and Design, an excellent and now classic text. Not every section in the book is essential; we suggest following Berkeley’s CS61C course “Great Ideas in Computer Architecture” for specific readings. The lecture notes and labs are available online, and past lectures are on the Internet Archive.\n\nFrequently asked questions\n\nWho is the target audience for this guide?\n\nWe have in mind that you are a self-taught software engineer, bootcamp grad or precocious high school student, or a college student looking to supplement your formal education with some self-study. The question of when to embark upon this journey is an entirely personal one, but most people tend to benefit from having some professional experience before diving too deep into CS theory. For instance, we notice that students love learning about database systems if they have already worked with databases professionally, or about computer networking if they’ve worked on a web project or two.\n\nWhat about AI/graphics/pet-topic-X?\n\nWe’ve tried to limit our list to computer science topics that we feel every practicing software engineer should know, irrespective of specialty or industry, but with a focus on systems. In our experience, these will be the highest ROI topics for the overwhelming majority of self-taught engineers and bootcamp grads, and provide a solid foundation for further study. Subsequently, you’ll be in a much better position to pick up textbooks or papers and learn the core concepts without much guidance. Here are our suggested starting points for a couple of common “electives”:\n\nFor artificial intelligence: do Berkeley’s intro to AI course by watching the videos and completing the excellent Pacman projects. As a textbook, use Russell and Norvig’s Artificial Intelligence: A Modern Approach.\n\nFor machine learning: do Andrew Ng’s Coursera course. Be patient, and make sure you understand the fundamentals before racing off to shiny new topics like deep learning.\n\nFor computer graphics: work through Berkeley’s CS 184 material, and use Computer Graphics: Principles and Practice as a textbook.\n\nHow strict is the suggested sequencing?\n\nRealistically, all of these subjects have a significant amount of overlap, and refer to one another cyclically. Take for instance the relationship between discrete math and algorithms: learning math first would help you analyze and understand your algorithms in greater depth, but learning algorithms first would provide greater motivation and context for discrete math. Ideally, you’d revisit both of these topics many times throughout your career.\n\nAs such, our suggested sequencing is mostly there to help you just get started… if you have a compelling reason to prefer a different sequence, then go for it. The most significant “pre-requisites” in our opinion are: computer architecture before operating systems or databases, and networking and operating systems before distributed systems.\n\nHow does this compare to Open Source Society or freeCodeCamp curricula?\n\nWhen this guide was first written in 2016, the OSS guide had too many subjects, suggested inferior resources for many of them, and provided no rationale or guidance around why or what aspects of particular courses are valuable. We strove to limit our list of courses to those which you really should know as a software engineer, irrespective of your specialty, and to help you understand why each course is included. In the subsequent years, the OSS guide has improved, but we still think that this one provides a clearer, more cohesive path.\n\nfreeCodeCamp is focused mostly on programming, not computer science. For why you might want to learn computer science, see above. If you are new to programming, we suggest prioritizing that, and returning to this guide in a year or two.\n\nWhat about language X?\n\nLearning a particular programming language is on a totally different plane to learning about an area of computer science — learning a language is much easier and much less valuable. If you already know a couple of languages, we strongly suggest simply following our guide and fitting language acquisition in the gaps, or leaving it for afterwards. If you’ve learned programming well (such as through Structure and Interpretation of Computer Programs), and especially if you have learned compilers, it should take you little more than a weekend to learn the essentials of a new language, after which you can learn about the libraries/tooling/ecosystem on the job.\n\nWhat about trendy technology X?\n\nNo single technology is important enough that learning to use it should be a core part of your education. On the other hand, it’s great that you’re excited to learn about that thing. The trick is to work backwards from the particular technology to the underlying field or concept, and learn that in depth before seeing how your trendy technology fits into the bigger picture.\n\nWhy are you still recommending SICP?\n\nLook, just try it. Some people find SICP mind blowing, a characteristic shared by very few other books. If you don't like it, you can always try something else and perhaps return to SICP later.\n\nWhy are you still recommending the Dragon book?\n\nThe Dragon book is still the most complete single resource for compilers. It gets a bad rap, typically for overemphasizing certain topics that are less fashionable to cover in detail these days, such as parsing. The thing is, the book was never intended to be studied cover to cover, only to provide enough material for an instructor to put together a course. Similarly, a self-learner can choose their own adventure through the book, or better yet follow the suggestions that lecturers of public courses have made in their course outlines.\n\nHow can I get textbooks cheaply?\n\nMany of the textbooks we suggest are freely available online, thanks to the generosity of their authors. For those that aren’t, we suggest buying used copies of older editions. As a general rule, if there has been more than a couple of editions of a textbook, it’s quite likely that an older edition is perfectly adequate. It’s certainly unlikely that the newest version is 10x better than an older one, even if that’s what the price difference is!\n\nWho made this?\n\nThis guide was originally written by Oz Nova and Myles Byrne, with 2020 updates by Oz. It is based on our experience teaching foundational computer science to over 1,000 mostly self-taught engineers and bootcamp grads in small group settings in San Francisco and live online. Thank you to all of our students for your continued feedback on self-teaching resources.\n\nFor updates to this guide and general computer science news and resources, you may also like to sign up for Oz's newsletter:"
    }
}