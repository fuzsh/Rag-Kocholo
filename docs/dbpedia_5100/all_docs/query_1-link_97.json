{
    "id": "dbpedia_5100_1",
    "rank": 97,
    "data": {
        "url": "https://hexdocs.pm/zxcvbn/ZXCVBN.Matching.html",
        "read_more_link": "",
        "language": "en",
        "title": "ZXCVBN.Matching â ZXCVBN v0.2.0",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "a \"date\" is recognized as: any 3-tuple that starts or ends with a 2- or 4-digit year, with 2 or 0 separator chars (1.1.91 or 1191), maybe zero-padded (01-01-91 vs 1-1-91), a month between 1 and 12, a day between 1 and 31.\n\nnote: this isn't true date parsing in that \"feb 31st\" is allowed, this doesn't check for leap years, etc.\n\nrecipe: start with regex to find maybe-dates, then attempt to map the integers onto month-day-year to filter the maybe-dates into dates. finally, remove matches that are substrings of other matches to reduce noise.\n\nnote: instead of using a lazy or greedy regex to find many dates over the full string, this uses a ^...$ regex against every substring of the password -- less performant but leads to every possible date match."
    }
}