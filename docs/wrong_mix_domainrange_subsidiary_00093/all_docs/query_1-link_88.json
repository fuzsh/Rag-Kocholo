{
    "id": "wrong_mix_domainrange_subsidiary_00093_1",
    "rank": 88,
    "data": {
        "url": "https://net.cybbh.io/public/networking/latest/03_transport/fg.html",
        "read_more_link": "",
        "language": "en",
        "title": "TRANSPORT to APPLICATION LAYER FG :: Cyber Common Technical Core",
        "top_image": "https://git.cybbh.space/global-objects/resources/raw/master/images/USACYSup001.png",
        "meta_img": "",
        "images": [
            "https://git.cybbh.space/global-objects/resources/raw/master/images/USACYSup001.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/PortRanges.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/TCPstates.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/TCPHeader.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/net_2.3_TCP.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/TCPFlagsBPF.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/TCP_Flags_Breakout.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/TCPchart.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/TCP_Options1.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/MTU_MSS_Frame1.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/TCP_Options2.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/MTU_MSS_Frame2.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/UDPHeader.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/net_2.4_UDP.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/TCP_DEMO_Example.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/UDP_DEMO_Example.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/VPN_Connection.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/remotevpn.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/sitetosite.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/l2tp.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/pptp.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/ipsectrans.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/ipsectunnel.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/basic_proxy.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/socks.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/smb.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/telnet.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/ssh.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/ssh_architecture.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/ssh_protocol.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/http.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/dns.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/DNS_Architecture.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/DNS_request.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/ftp.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/ftp_active.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/ftp_passive.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/tftp.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/smtp.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/pop.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/imap.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/dhcp.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/ntp.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/tacacs-s.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/tacacs-e.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/radius.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/Diameter_Header.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/snmp.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/rtp.png",
            "https://net.cybbh.io/public/networking/latest/03_transport/_images/rdp.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "TRANSPORT to APPLICATION LAYER FG\n\n3.0 Outcomes\n\nExplain OSI Layer 4 ports, protocols and headers\n\nDescribe Transport Layer Protocols\n\nReview Well-known, Registered and Dynamic port ranges\n\nDescribe TCP reliability using sequence and acknowledgment numbers\n\nAnalyze TCP and UDP headers\n\nExplain TCP Options\n\nIdentify hexadecimal representations of transport layer protocol headers\n\nExplain OSI Layer 5 protocols and headers\n\nUnderstand Virtual Private Networks (VPN)\n\nExamine L2TP and PPTP tunning protocols\n\nUnderstand proxies\n\nExamine SOCKS protocol\n\nExamine Network Basic Input Output System (NETBIOS) protocol\n\nRecognize well-known NetBIOS suffixes (services) and their potential for operational impact\n\nExamine Server Message Block protocol\n\nExamine Remote Procedure Call (RPC) protocol\n\nExplain OSI Layer 6 functions and responsibilities\n\nExplain the presentation layer functions and responsibilities\n\nExplain OSI Layer 7 protocols and headers\n\nAnalyze Telnet protocol\n\nAnalyze Secure Shell Protocol (SSH)\n\nAnalyze Hypertext Transfer Protocol (Secure) (HTTP(s))\n\nAnalyze Domain Name System (DNS) protocol\n\nExamine DNS usage with UDP and TCP\n\nExplain DNS Records\n\nExplain DNS architecture\n\nAnalyze File Transfer Protocol (FTP)\n\nAnalyze Trivial File Transfer Protocol (TFTP)\n\nAnalyze Simple Mail Transfer Protocol (SMTP)\n\nAnalyze Post Office Protocol (POP)\n\nAnalyze Internet Message Access Protocol (IMAP)\n\nAnalyze Dynamic Host Configuration Protocol (DHCP) version 4 and 6 protocol\n\nExplain DHCP Vulnerabilities\n\nAnalyze Network Time Protocol (NTP) and vulnerability\n\nAnalyze Terminal Access Controller Access-Control System Plus (TACACS+) Protocol\n\nAnalyze Remote Authentication Dial-In User Service (RADIUS) protocol\n\nAnalyze Diameter Protocol\n\nAnalyze Simple Network Management Protocol (SNMP)\n\nAnalyze Real-time Transport Protocol (RTP)\n\nAnalyze Remote Desktop Protocol (RDP)\n\nAnalyze Kerberos\n\nAnalyze Lightweight Directory Access Protocol (LDAP)\n\nThe functions and protocols at Layers 4 through 7 of the OSI model are instrumental in cybersecurity for their roles in facilitating end-to-end communication, managing network traffic, and providing various application-layer services. Layer 4 (Transport layer) protocols such as TCP (Transmission Control Protocol) and UDP (User Datagram Protocol) play a vital role in ensuring reliable and efficient data transmission across networks. TCP provides connection-oriented communication, error detection, and flow control, making it suitable for applications requiring guaranteed delivery, while UDP offers connectionless communication, making it ideal for real-time and latency-sensitive applications. Understanding these protocols enables cybersecurity professionals to optimize network performance, troubleshoot connectivity issues, and implement security measures such as firewall rules based on TCP or UDP port numbers.\n\nMoving up the OSI model, Layer 5 (Session layer) protocols are responsible for establishing, maintaining, and terminating sessions between communicating devices. While less commonly implemented as distinct protocols, the concepts of session management are crucial in cybersecurity for ensuring secure and authenticated communication between endpoints. By understanding session management principles, cybersecurity professionals can implement secure authentication mechanisms, manage session timeouts, and detect and mitigate session hijacking attacks.\n\nLayer 6 (Presentation layer) is primarily concerned with data representation and encryption, ensuring that data exchanged between applications is formatted and interpreted correctly. Protocols such as SSL/TLS (Secure Sockets Layer/Transport Layer Security) operate at this layer to provide encryption, authentication, and data integrity for secure communication over the internet. Knowledge of presentation layer protocols enables cybersecurity professionals to implement secure communication channels, protect sensitive data from eavesdropping, and ensure interoperability between different systems and applications.\n\nFinally, Layer 7 (Application layer) protocols encompass a wide range of application-specific functions and services, including email, web browsing, file transfer, and remote access. Protocols such as HTTP (Hypertext Transfer Protocol), SMTP (Simple Mail Transfer Protocol), and SSH (Secure Shell) operate at this layer to enable communication between end-user applications and network services. Understanding Layer 7 protocols is essential for identifying and mitigating application-layer attacks such as SQL injection, cross-site scripting (XSS), and phishing. Additionally, knowledge of application layer protocols allows cybersecurity professionals to implement security controls, such as web application firewalls (WAFs) and intrusion detection systems (IDS), to protect against these threats.\n\nIn summary, the functions and protocols at Layers 4 through 7 of the OSI model are critical components of cybersecurity, enabling secure and reliable communication, managing network traffic, and providing essential application-layer services. By understanding and leveraging these protocols effectively, cybersecurity professionals can enhance network security, protect against cyber threats, and ensure the confidentiality, integrity, and availability of critical assets and information.\n\nReferences:\n\nInstructor Note\n\nInstructor Notes\n\n3.1 Explain OSI Layer 4 ports, protocols and headers\n\nLayer 4 of the OSI (Open Systems Interconnection) model is the Transport Layer. The Transport Layer is responsible for providing end-to-end communication between hosts, ensuring that data is reliably delivered and that communication sessions are established, maintained, and terminated.\n\nThe two main protocols at this layer are:\n\nTCP (Transmission Control Protocol) provides reliable, connection-oriented communication by establishing a connection, ensuring data delivery, and handling error detection and recovery. TCP is commonly used for applications that require reliable and ordered delivery of data, such as web browsing, email, and file transfer.\n\nThe protocol data unit (PDU) for TCP is Segment.\n\nTCP Header: The TCP header contains fields such as source port, destination port, sequence number, acknowledgment number, checksum, and control flags (e.g., SYN, ACK, FIN). These fields are used to establish connections, manage data transmission, and handle flow control and error recovery.\n\nUDP (User Datagram Protocol) provides unreliable, connectionless communication by sending data packets without establishing a connection or ensuring delivery. UDP is commonly used for real-time applications, multimedia streaming, DNS, and other applications where low overhead and minimal delay are preferred over reliability.\n\nThe protocol data unit (PDU) for UDP is Datagram.\n\nUDP Header: The UDP header contains fields such as source port, destination port, length, and checksum. Unlike TCP, UDP does not include sequence numbers, acknowledgment numbers, or control flags, as it provides a simple, connectionless transport mechanism without reliability features.\n\nAddressing used at this layer are ports.\n\nPorts are communication endpoints that allow multiple applications or services to run on a single device and communicate over a network. Ports are identified by numbers ranging from 0 to 65535.\n\nWell-known ports (0-1023) are reserved for specific services, such as HTTP (port 80) and SMTP (port 25).\n\nRegistered ports (1024-49151) are used by applications and services registered with the Internet Assigned Numbers Authority (IANA).\n\nDynamic or private ports (49152-65535) are available for temporary use by client applications when establishing connections.\n\nReferences:\n\nInstructor Note\n\nInstructor Notes\n\n3.1.1 Describe Transport Layer Protocols\n\nThe Transport layer (Layer 4) is responsible for the transfer of data, ensuring that data is error-free and in order.\n\nTransport layer communication falls under two categories:\n\nConnection-oriented (TCP-Segments-Unicast traffic)\n\nRequires that a connection with specific agreed-upon parameters be established before data is sent.\n\nProvides segmentation and sequencing.\n\nProvides connection establishment and acknowledgments to provide reliability.\n\nProvides flow control (or windowing).\n\nCommon application layer protocols or functions that rely on TCP are SSH, Telnet, FTP, SMTP, POP, IMAP, and HTTP(s).\n\nGet more information in RFC 793\n\nConnection-less (UDP-Datagrams-Broadcast, Multicast, Unicast Traffic)\n\nRequires no connection before data is sent.\n\nProvides no ordering, duplicate protection or delivery guarantee.\n\nApplication layer protocols will normally provide the reliability if needed.\n\nDoes provide integrity checking using the checksum.\n\nCommon application layer protocols or functions that rely on UDP are DNS, TFTP, and QUIC (Quick UDP Internet Connections).\n\nGet more information in RFC 768\n\nReferences:\n\nhttps://datatracker.ietf.org/doc/html/rfc793\n\nhttps://www.ietf.org/rfc/rfc768.txt\n\nInstructor Note\n\nInstructor Notes\n\n3.1.2 Review Well-known, Registered and Dynamic port ranges\n\nPorts are used in computer networking to facilitate communication between different applications, services, or devices. They serve as endpoints for network communication and help distinguish between multiple concurrent communication channels.\n\nIdentifying Applications and Services:\n\nPorts are numbered identifiers assigned to specific applications or services running on a device.\n\nEach application or service that communicates over a network uses one or more ports to send and receive data.\n\nPorts help network devices understand which application or service should receive incoming data packets.\n\nMultiplexing and Demultiplexing:\n\nPorts enable multiplexing, which allows multiple applications or services to share a single network connection or network interface.\n\nWhen data packets arrive at a device, the operating system uses the destination port number to demultiplex the packets and forward them to the appropriate application or service.\n\nWithout ports, computers would be limited to engaging in only one communication session at a time, severely constraining their ability to multitask and efficiently handle network traffic.\n\nEstablishing Communication Channels:\n\nPorts play a crucial role in establishing communication channels between devices on a network.\n\nIn client-server communication, a client application connects to a server application by specifying the server’s IP address and port number.\n\nOnce the connection is established, data can be exchanged between the client and server through the designated port.\n\nNetwork Security:\n\nPorts are essential for configuring network security policies, such as firewalls and access control lists (ACLs).\n\nFirewall rules can be configured to allow or block traffic based on specific port numbers, helping to protect network resources from unauthorized access or malicious activity.\n\nNetwork Troubleshooting:\n\nPorts are often used in network troubleshooting to diagnose connectivity issues or analyze network traffic.\n\nBy examining the port numbers associated with network traffic, network administrators can identify the applications or services involved and pinpoint the source of network problems.\n\nWell-known (System) port numbers (0-1023), which are assigned by IANA are responsible for maintaining the official assignments of port numbers for specific uses. This range is dedicated for common protocols and services across all operating systems. Changes to systems well-known port numbers require elevated or root privileges.\n\nRegistered (User) port numbers (1024-49151) can be registered with IANA for a specific service by a requesting entity. This range is loosely controled by IANA. Some operating systems may use this range as dynamically assigned source ports. There are services and protocols that have ports in this range such as Remote Desktop Protocol (RDP on port 3389). Many services and protocols in this port range may be limited to specific operating systems. Changes to systems registered port numbers do not need elevated or root privileges.\n\nDynamic (Private) port numbers (49152-65535) can not be registered with IANA. These ports are for use as temporary, private, or/and for automatic allocation of ephemeral ports. This range is not controlled in any way by IANA for any protocols and services. Changes to systems dynamic port numbers do not need elevated or root privileges.\n\nImportant to note that binding is an integral step for server side socket (IP address + port number) that provides an address to a end-user to request services. Restrictions to the well-known port numbers is needed to protect major network services such as HTTP, HTTPS, SSH, FTP, etc. Without these restrictions a unauthorized user could run a program that listened on these ports for login (access) details or could run a unauthorized server application.\n\nSource Port:\n\nWhen a client initiates communication, it selects a source port to use for outgoing packets.\n\nThe source port helps the client device identify which application or service on the sending device originated the communication.\n\nSource ports are typically chosen from the dynamic port range (49152-65535) by the operating system or application.\n\nThe server however will use the service port as its source port.\n\nDestination Port:\n\nThe client specifies the destination port as the number used by the receiving application or service.\n\nIt client specifies the port on the destination server where the communication is intended to be delivered.\n\nWhen the server receives incoming packets, it uses the destination port number to determine which application or service should handle the data.\n\nDestination ports are typically well-known (1-1023) or registered port numbers (1024-49151) that are associated with specific services or applications.\n\nThe server however will use the client’s dynamically assigned source port as its destination port to send replies back to the client.\n\nReferences:\n\nhttps://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml\n\nhttps://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers\n\nInstructor Note\n\nInstructor Notes\n\n3.1.3 Describe TCP reliability using sequence and acknowledgment numbers\n\nTCP is a connection oriented protocol and therefore is divided into one of 3 phases.\n\nConnection establishment\n\n3-way Handshake. Any system can initiate the connection but is typically initiated from a client to request connection to a server.\n\nSYN - Client initiates the connection by setting the SYN flag and sending his initial starting SEQ number in the SEQ number field. The ACK flag and field are set to zero. The client can additionally specify other communication parameters. These parameters can only be negotiated during the SYN phase and can not be changed later in the communication.\n\nMaximum Segment Size (MSS) (Kind=2). Largest amount of data that can be transmitted in a single TCP segment.\n\nWindow scale factor (Kind=3). Extends the window size field in TCP headers to support larger data transfers by multiplying the window size value by a power of two, effectively expanding the range of available window sizes.\n\nSelective Acknoledgement (SACK) (Kind=5). Option allowing a receiver to inform the sender about specific segments that have been received successfully, enhancing performance by enabling retransmission of only missing segments rather than entire blocks of data.\n\nSYN-ACK - Server responds to the client by turning on the ACK flag and adding 1 to client’s SEQ number and placing the value in the ACK field. The server will turn on the SYN flag and insert its own SEQ number in the SEQ number field. The server can additionally specify other communication parameters such as its Window scale factor, Maximum Segment Size (MSS), and Selective Acknoledgement (SACK).\n\nACK - Client will then set the ACK flag add 1 to the server’s SEQ number and place in the ACK field and send to server. The SEQ number will be the next number in sequence from the starting. The SYN flag however will not be turned on. This completes the handshake and both sides are now in the ESTABLISHED state and all data transfer is bi-directional.\n\nData Transfer\n\nDuring the ESTABLISHED state communication can go in either direction. Data can be either set to or pulled from the server.\n\nPSH-ACK - Server is sending data to client so it turns on the PSH flag. It will insert its next incrementing SEQ number in the SEQ field. In the payload, it will send either the amount of bytes its able to send, or the amount the client is able to receive, depending on which is smaller. This is determined by the window size of each side. This can increase or decrease during the communication. The ACK flag will also be set to ACK the last SEQ number from the Client +1.\n\nACK - The client will set his incrementing SEQ number in the SEQ field and then set the ACK flag and ACK field to the next expected byte number from the server in the ACK field.\n\nConnection Termination\n\n4-way termination. Either the client or server can initiate the connection termination. Each end can only close its half of the connection which means that each end needs to request to close. Whichever initiates it follows this process:\n\nFIN-ACK - Initiator will set the FIN flag to inform the other end that it is closing its end of the connection. It will set its SEQ number to the next incrementing number.\n\nACK - Receiver will set the ACK flag and ACK the initiator’s SEQ number +1 in the ACK field.\n\nFIN-ACK - Receiver then initiates its connection termination buy setting the FIN flag and setting its own SEQ number in the SEQ field.\n\nIf the close was initiated by the client, the server can respond to the FIN-ACK sent by the client in one of two ways.\n\nPassive Close by Server: The server receives the FIN segment from the client and sends back an ACK segment to acknowledge the termination request but does not sent a FIN-ACK itself.\n\nActive Close by Server: The server does send a FIN-ACK.\n\nACK - Original initiator then sets the ACK flag and ACKs the receiver’s SEQ number +1 in the ACK field. SEQ number will be the next incrementing SEQ number.\n\nReferences:\n\nhttps://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/\n\nInstructor Note\n\nInstructor Notes\n\n3.1.4 Analyze TCP and UDP headers\n\nThis section will cover the two main headers, TCP and UDP. A greater understanding of the headers will help provide you information on how to modify or to identify abnormal TCP segments and UDP datagrams.\n\nReferences:\n\nInstructor Note\n\nInstructor Notes\n\n3.1.4.1 TCP Headers\n\nByte Number Field Name Bit Range Length Description\n\nTCP segments will have the Protocol field set to 6 in the IPv4 Header or the Next Header field set to 6 in the IPv6 Header.\n\n00 1f 29 5e 4d 26 00 50 56 bb 3a a0 08 00 45 00 00 3c 83 1b 40 00 40 06 15 0a c0 a8 14 46 4a 7d 83 1b d5 1d 00 19 6b 7f c7 2d 00 00 00 00 a0 02 72 10 a2 b5 00 00 02 04 05 b4 04 02 08 0a 0a 99 44 36 00 00 00 00 01 03 03 07\n\nEthernet Header:\n\n00 1f 29 5e 4d 26 is the destination MAC\n\n00 50 56 bb 3a a0 is the source MAC\n\n08 00 is the ethertype for IPv4\n\nIPv4 Header:\n\n45 to identify the Version is 4 and the IHL is 5 which means the IP header is 20 bytes in length. (IHL x 4)\n\n00 is the DSCP. Used for Quality of Service (QoS).\n\n00 3c is the Total length of 60 bytes. This includes the 20 byte header and 40 bytes of payload.\n\n83 1b is the Identification field. Value is 33563.\n\n40 00 is the Flags and fragmentation offset field. This value has the Dont Fragement (DF) turned on and no fragmentation offset.\n\n80 00 is the value for the Reserved (Evil bit).\n\n20 00 to 3F FF is the range for the More Fragements (MF) bit and fragmentation offset.\n\n40 is the Time to Live field. Currently set to 64.\n\n06 is the Protocol field. Currently set to identify TCP.\n\n01 is for ICMPv4\n\n11 is for UDP\n\n15 0a is the Checksum field\n\nc0 a8 14 46 is the source IP address. Currently set to 192.168.20.70.\n\n4a 7d 83 1b is the destination IP address. Currently set to 74.125.131.27.\n\nTCP Header:\n\nd5 1d is the source port field. Currently set to 54557.\n\n00 19 is the destination port field. Currently set to 25.\n\n6b 7f c7 2d is the sequence number field. Currently set to 1803536173.\n\n00 00 00 00 is the acknowledgment field. Currently set to 0.\n\na0 is the offset and reserved fields.\n\na is the offset field to identify the length of the TCP header. The a means that the TCP header is 40 bytes in length. (offset x 4)\n\n0 is the reserved field. This should always be 0.\n\n02 is the TCP flags field. Currently the SYN flag is set.\n\n80 is the Congestion window reduced (CWR) flag.\n\n40 is the ECN-Echo flag.\n\n20 is the Urgent pointer flag. If set then system should check Urgent pointer field.\n\n10 is the Acknowledgment flag. Used to inform sender of recieved data.\n\n08 is the Push flag. Used to inform recipient that data is in payload.\n\n04 is the Reset flag. Sent to close connection.\n\n02 is the Synchronize flag. Used to synchronize starting sequence numbers at the start of the conneciton during the 3-way handshake.\n\n01 is the Finish flag. Used to inform other end that connection is being terminated.\n\n72 10 is the window size field. Currently set to 29200.\n\na2 b5 is the checksum field.\n\n00 00 is the urgent pointer field. Should only be set if URG flag is on. This is not commonly used in modern networking. Currently set to 0.\n\nTCP Options:\n\n02 04 05 b4 is the Maximum segment size (MSS) option field. Used to determine the MSS for the communicaiton. Kind = 2. Length = 4. MSS = 1460\n\n04 02 is the Selective Acknoledgement (SACK) permitted option. Used to determine if SACK is permitted or not. Kind - 4. Length = 2.\n\n08 0a 0a 99 44 36 00 00 00 00 is the timestamps option. Used to measure TCP roundtrip time (RTT). Kind = 8. Length = 10. Timestamp = 177816630. Timestamp echo reply = 0.\n\n01 is the No-Operation (NOP) option. Kind = 1\n\n03 03 07 is the window scale option. Used to to increase the maximum window size from 65,535 bytes to 1 Gigabyte. Kind = 3. Length = 3. Shift count = 7 (multiply by 128).\n\nAnything after this will be payload.\n\nReferences:\n\nhttps://tools.ietf.org/html/rfc3540\n\nhttps://en.wikipedia.org/wiki/Transmission_Control_Protocol#Flow_control\n\nhttps://en.wikipedia.org/wiki/Transmission_Control_Protocol#Window_scaling\n\nhttp://www.networksorcery.com/enp/protocol/tcp.htm#Options\n\nInstructor Note\n\nInstructor Notes\n\n3.1.4.1.1 TCP Flags\n\nCWR: Congestion Windows Reduced - The congestion window reduced flag is used by the sending host to indicate it received a packet with the ECE flag set. (Not comonly used unless Explicit Congestion Notification (ECN) is used in the TCP header.)\n\nECE: Explicit Congestion Notification (ECN) Echo - This flag is responsible for indicating if the TCP peer is ECN capable. (Not comonly used unless Explicit Congestion Notification (ECN) is used in the TCP header.)\n\nURG: Urgent - Indicates that the urgent pointer field is valid and contains urgent data. The urgent flag is used to notify the receiver to process the urgent packets before processing all other packets. Has become less relevant for modern TCP communications.\n\nACK: Acknowledgment - The acknowledgment flag is used to acknowledge the successful receipt of a packet.\n\nPSH: Push - The push flag is somewhat similar to the URG flag and tells the receiver to process these packets as they are received instead of buffering them. This flag is only used during the established phase when sending data. Should be sent with an ACK flag.\n\nRST: Reset - The reset flag gets sent from the receiver to the sender when a packet is sent to a particular host that was not expecting it. Most commonly used in response to a TCP connection on a closed port.\n\nSYN: Synchronize - The synchronization flag is used as a first step in establishing a three way handshake between two hosts. Is only legitimately used during the 3-way handshake.\n\nFIN: Finished - The finished flag means no more data from sender. Used as part of the 4-way TCP connection termination. Should be sent with an ACK flag.\n\nTwo mnemonics to remember the TCP flags are:\n\nCollection of Exceptionally Unskilled Attackers Pester Real Security Folks\n\nCoach Explained to the University of Alaska to Play Really Snowy Football\n\nHexadecimal – base 16: From Wikipedia\n\n“In mathematics and computer science, hexadecimal (also base 16, or hex) is a positional numeral system with a radix, or base, of 16. It uses sixteen distinct symbols, most often the symbols 0–9 to represent values zero to nine, and A, B, C, D, E, F (or alternatively a–f) to represent values ten to fifteen. For example, the hexadecimal number 2AF3 is equal, in decimal, to (2 × 163) + (10 × 162) + (15 × 161) + (3 × 160), or 10995.\n\nEach hexadecimal digit represents four binary digits (bits), and the primary use of hexadecimal notation is a human-friendly representation of binary-coded values in computing and digital electronics. One hexadecimal digit represents a nibble (4 bits), which is half of an octet. For example, byte values can range from 0 to 255 (decimal), but may be more conveniently represented as two hexadecimal digits in the range 00 to FF. Hexadecimal is also commonly used to represent computer memory addresses.”\n\nIn the image above, a hex representation of 0x02 in a hex output at byte 13 would identify a SYN flag being set to ON. A 0x12 at that same byte number would indicate that a SYN, ACK flags are set to ON. Finally a 0x10 on byte 13 would identify a ACK flag.\n\nTCP Flags:\n\n8\n\n4\n\n2\n\n1\n\n8\n\n4\n\n2\n\n1\n\n128\n\n64\n\n32\n\n16\n\n8\n\n4\n\n2\n\n1\n\nURG\n\nCWR\n\nECE\n\nACK\n\nPSH\n\nRST\n\nSYN\n\nFIN\n\nSYN\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n1\n\n0\n\n0x02\n\nSYN/ACK\n\n0\n\n0\n\n0\n\n1\n\n0\n\n0\n\n1\n\n0\n\n0x12\n\nACK\n\n0\n\n0\n\n0\n\n1\n\n0\n\n0\n\n0\n\n0\n\n0x10\n\nEstablished\n\n-\n\n-\n\n-\n\n-\n\n-\n\n-\n\n-\n\n-\n\nPSH/ACK\n\n0\n\n0\n\n0\n\n1\n\n1\n\n0\n\n0\n\n0\n\n0x18\n\nACK\n\n0\n\n0\n\n0\n\n1\n\n0\n\n0\n\n0\n\n0\n\n0x10\n\nPSH/ACK\n\n0\n\n0\n\n0\n\n1\n\n1\n\n0\n\n0\n\n0\n\n0x18\n\nACK\n\n0\n\n0\n\n0\n\n1\n\n0\n\n0\n\n0\n\n0\n\n0x10\n\nGraceful\n\nTermination\n\n-\n\n-\n\n-\n\n-\n\n-\n\n-\n\n-\n\n-\n\nFIN/ACK\n\n0\n\n0\n\n0\n\n1\n\n0\n\n0\n\n0\n\n1\n\n0x11\n\nACK\n\n0\n\n0\n\n0\n\n1\n\n0\n\n0\n\n0\n\n0\n\n0x10\n\nFIN/ACK\n\n0\n\n0\n\n0\n\n1\n\n0\n\n0\n\n0\n\n1\n\n0x11\n\nACK\n\n0\n\n0\n\n0\n\n1\n\n0\n\n0\n\n0\n\n0\n\n0x10\n\nUnGraceful\n\nTermination\n\n-\n\n-\n\n-\n\n-\n\n-\n\n-\n\n-\n\n-\n\nRST\n\n0\n\n0\n\n0\n\n0\n\n0\n\n1\n\n0\n\n0\n\n0x04\n\nRFC recommended response to illegal flag combinations:\n\nSome illegal flag combinations may include null (no flags), URG-PSH-FIN (x-mas tree scan), FIN without ACK. Per the RFC, operating systems should silently discard packets containing illegal combinations.\n\nMost Linux distributions follow the RFC’s guidance which is to not respond.\n\nWindows and MacOS often reply to these combinations with a RST-ACK. This can make those OSes harder to enumerate via TCP scanning, since open/closed ports illicit the same response.\n\nWhen and why are illegal flag combinations or TCP options used?\n\nIllegal flag combinations are often used during network scanning or enumeration to find out what ports are open through a firewall, services a host is running, or information about the OS.\n\nTCP options are also commonly used in identifying OSes by tools such as P0f. This is because different operating systems can use different Window sizes, windows scaling and MSS values.\n\nReferences:\n\nhttps://datatracker.ietf.org/doc/html/rfc793\n\nhttps://datatracker.ietf.org/doc/html/rfc3168\n\nInstructor Note\n\nInstructor Notes\n\n3.1.4.1.2 TCP States\n\nLISTEN - represents waiting for a connection request from any remote TCP and port.\n\nSYN-SENT - represents waiting for a matching connection request after having sent a connection request.\n\nSYN-RECEIVED - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.\n\nESTABLISHED - represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection.\n\nFIN-WAIT-1 - represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.\n\nFIN-WAIT-2 - represents waiting for a connection termination request from the remote TCP.\n\nCLOSE-WAIT - represents waiting for a connection termination request from the local user.\n\nCLOSING - represents waiting for a connection termination request acknowledgment from the remote TCP.\n\nLAST-ACK - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).\n\nTIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.\n\nCLOSED - represents no connection state at all.\n\nReferences:\n\nhttps://datatracker.ietf.org/doc/html/rfc793\n\nInstructor Note\n\nInstructor Notes\n\n3.1.4.1.3 Explain TCP Options\n\nTCP Options:\n\nKind 0 - End of Options List: Indicates the end of the TCP options list. This option is a single byte with the value 0, serving as a delimiter for the end of the options.\n\nKind 1 - No Options or NOP: The NOP option is used for padding and alignment purposes. It has no operational effect but allows for the proper alignment of subsequent options. NOP is 1 byte in length and is used with other options to ensure they are in even 32-bit (4 byte) WORDS.\n\nKind 2 - Maximum Segment Size (MSS): The MSS option is specified during the 3-way handshake when the SYN flag is set. This identifies how many bytes of data that it can receive in a single segment. This is typically small enough to avoid the need for IP fragmentation. This is different from MTU which is the maximum packet size in bytes. The MTU is determined primarily by the network the host is connected to. The MSS should typically not exceed the value of the MTU minus the IP/TCP headers. Setting a MSS to a smaller value will then reflect a smaller packet size and can be less than 1500. For example: If you set the MSS to 1400 bytes, this will then have a minimum of 20 bytes of TCP header and 20 bytes of IP header (assuming no options). This will make the maximum packet size of 1440 bytes. This is less than the 1500 MTU so it gives room for other headers such as encryption or options. Reference RFC 793, Youtube Video\n\nKind 3 - TCP Window Scaling: The window size field in the TCP header is a 16 bit field so the value of this field can only be from 0-65,535. This means that the sender of this segment can only theoretically receive between 0 bytes to 65,535 bytes of data before 1 ACK is sent. This is due to its receive buffers ability to hold and process data. Because of more modern computers having the feature of larger memory buffers, it can request to receive more data than what the window size field is able to be set to. Using the TCP Window scale option, the segment sender can set a multiplier (i.e. 0, 1, 2, 4, up to 14 etc). This will adjust a calculated window size that you can see in Wireshark to the window size multiplied by the multiplier setting. If the sender using this option it will enable it for use on the receiver’s end. During the transfer process the receiver’s window size can decrease. This is typically due to its buffer becoming filled faster than it can process the data. Once the receive buffer is filled it will set its window size to zero until the data can be sufficiently processed. During the wait the sender will send keep-alives to keep connection open to avoid any timeouts and the receiver will ACK these messages to let sender know they are still active but window size will stay at zero. Once the receiver’s buffers are cleared it will then send a message with the window size and scaling set to what it can now receive. Reference RFC 7323, Youtube video 1, Youtube Video 2\n\nKind 4 - SACK Permitted: Indicates that the sender is willing to receive Selective Acknowledgment (SACK) information from the receiver. The length is typically 2 bytes.\n\nKind 5 - SACK (Selective Acknowledgment): Contains information about segments that have been received successfully. SACK allows for more efficient recovery from lost or out-of-order segments. The length is variable, depending on the number of SACK blocks.\n\nKind 8 - Timestamps: Used for timestamp synchronization between TCP peers. The sender includes a timestamp value in the TCP header, and the receiver echoes it back. Timestamps are useful for calculating round-trip times and can be used in congestion control algorithms. The length is typically 10 bytes.\n\nKind 14 - TCP Alternate Checksum Request: Requests an alternative checksum for the TCP header and data. This option is not widely used, and the length is typically 3 bytes.\n\nKind 15 - TCP Alternate Checksum Data: Contains the alternative checksum for the TCP header and data. Like the request option, this option is not commonly used, and the length is typically variable.\n\nDEMO TCP Open wireshark and capture traffic while you browse to www.espn.com\n\nBelow images are shown for reference and explanation of the traffic capture.\n\nSYN\n\nActucal client’s(192.168.65.20) window size, in bits, is 28200(Window size value) x 128(window scale 2^7)(TCP Option Multplier)=3609600\n\nAbove image shows MTU and MSS relationship.\n\nSYN, ACK\n\nActucal server’s(13.107.21.200) window size, in bits, is 65535(Window size value) x 256(window scale 2^8)(TCP Option Multplier)=16776960\n\nAbove image shows MTU and MSS relationship.\n\nIndepth on TCP Options\n\nReferences:\n\nhttps://datatracker.ietf.org/doc/html/rfc793#page-18\n\nhttps://www.youtube.com/watch?v=XMcYwr-yJGA\n\nhttps://datatracker.ietf.org/doc/html/rfc7323#page-8\n\nhttps://www.youtube.com/watch?v=Qpkr_12RQ7k\n\nhttps://www.youtube.com/watch?v=2PJVHvthrNU\n\nInstructor Note\n\nInstructor Notes\n\n3.1.4.2 UDP Headers\n\nByte Number Field Name Bit Range Length Description\n\nSome attributes that UDP does not have, which makes it a protocol better suited for certain applications like VoIP, Streaming Media or DNS.\n\nUDP has a much smaller header. It does not address sequencing of datagrams (although Protocols like RTP riding over UDP can help to assist with this). It also does not have windowing, flow control, or a re-transmission mechanism.\n\nThese attributes make the protocol more lightweight and suited for latency sensitive applications, or applications that do not benefit from a stateful connection.\n\nUDP scans are difficult to use since the protocol is not stateful, no response is required from the target when a datagram is sent. ** UDP scanning is possible however because of the helper protocol ICMP. ICMP will provide \"port unreachable\" messages if the port being scanned is closed.\n\nDue to the lack of flow control, UDP scans can easily overwhelm a host. This can result in the target being unable to process and provide ICMP messages response to all the probes sent, therefore skewing the results.\n\nUDP datagrams will have the Protocol field set to 17 in the IPv4 Header or the Next Header field set to 17 in the IPv6 Header.\n\n00 1f 29 5e 4d 26 00 50 56 bb 3a a0 08 00 45 00 00 3c 83 1b 40 00 40 11 15 0a c0 a8 14 46 4a 7d 83 1b dc de 00 35 00 36 7c 15 03 c4 01 20 00 01 00 00 00 00 00 01 04 6f 63 73 70 08 76 65 72 69 73 69 67 6e 03 6e 65 74 00 00 1c 00 01 00 00 29 10 00 00 00 00 00 00 00\n\nEthernet Header:\n\n00 1f 29 5e 4d 26 is the destination MAC\n\n00 50 56 bb 3a a0 is the source MAC\n\n08 00 is the ethertype for IPv4\n\nIPv4 Header:\n\n45 to identify the Version is 4 and the IHL is 5 which means the IP header is 20 bytes in length. (IHL x 4)\n\n00 is the DSCP. Used for Quality of Service (QoS).\n\n00 3c is the Total length of 60 bytes. This includes the 20 byte header and 40 bytes of payload.\n\n83 1b is the Identification field. Value is 33563.\n\n40 00 is the Flags and fragmentation offset field. This value has the Dont Fragement (DF) turned on and no fragmentation offset.\n\n80 00 is the value for the Reserved (Evil bit).\n\n20 00 to 3F FF is the range for the More Fragements (MF) bit and fragmentation offset.\n\n40 is the Time to Live field. Currently set to 64.\n\n11 is the Protocol field. Currently set to identify UDP.\n\n01 is for ICMPv4\n\n06 is for TCP\n\n15 0a is the Checksum field\n\nc0 a8 14 46 is the source IP address. Currently set to 192.168.20.70.\n\n4a 7d 83 1b is the destination IP address. Currently set to 74.125.131.27.\n\nUDP Header:\n\ndc de is the source port field. Currently set to 56542.\n\n00 35 is the destination port field. Currently set to 53.\n\n00 36 is the length field. Currently set to 54 bytes. This includes 8 bytes of UDP header and 46 bytes of payload.\n\n7c 15 is the checksum field.\n\nAnything after this will be payload.\n\nGet more information in RFC 768\n\n(Well Known ports)\n\nDEMO Use Wireshark to demo layer 4. Show the TCP and UDP headers.\n\nTCP DEMO Example\n\nUDP DEMO Example\n\nReferences:\n\nhttps://tools.ietf.org/html/rfc768\n\nhttp://www.meridianoutpost.com/resources/articles/well-known-tcpip-ports.php\n\nInstructor Note\n\nIdentify well-known port range and how they are used (0-1023). Ensure you discuss privilege required for a OS to bind a well-known port. Compare and discuss ephemeral ports and their use in communications.\n\n3.2 Explain OSI Layer 5 protocols and headers\n\nLayer 5 of the OSI (Open Systems Interconnection) model is the Session Layer. The Session Layer is responsible for managing communication sessions between devices, including establishing, maintaining, and terminating these sessions. Unlike lower layers, which focus on the transmission of data, the Session Layer deals with the organization and synchronization of communication sessions. While the OSI model defines the Session Layer, it’s worth noting that in many practical network implementations, the functions of the Session Layer are often combined with those of the Presentation Layer or are implemented within application-layer protocols. Therefore, Layer 5 protocols are not as prevalent or standardized as those in lower layers.\n\nSession Layer — The main purpose of this layer is to maintain the state of your ongoing connections. This state is not used in a connection-less protocol. Functions for managing sessions, including session synchronization, checkpointing, and recovery in the event of communication failures. These functions ensure that communication sessions remain synchronized and consistent between devices.\n\nThis layer provides the capabilities to open, close and manage sessions between the application layer processes. The communication at this layer consist of requests and responses that occur between the local and remote applications. Session-layer makes use of remote procedure calls (RPCs), Net-Beui, SOCKS, SMB, WINS, named-pipes, PPTP and other protocols.\n\nReferences:\n\nInstructor Note\n\nInstructor Notes\n\n3.2.1 Understand Virtual Private Networks (VPN)\n\nVirtual Private Networks (VPN) allows connections through a network that is not accessible to everyone else. This \"private\" connection makes is look like a direct connection, when in fact it is not. VPNs work by encapsulating an IP packet into another IP packet for traversal across a (generally) public network. The outer IP packet headers used for the traversal is then removed and the original packet headers are then used for further routing decisions.\n\nVPN connections are typically unencrypted but can be secured using encryption, such as IPSEC or TLS/SSL, to make it more secure for sensitive information. Some protocols used to provide confidentiality for VPN tunnels.\n\nIPsec: Provides a suite of protocols for secure IP communication, including Authentication Header (AH), Encapsulating Security Payload (ESP), and Internet Key Exchange (IKE).\n\nSSL/TLS: Utilizes the SSL/TLS protocol suite to create secure connections between clients and servers, commonly used in SSL VPNs.\n\nOpenVPN: An open-source VPN protocol that uses SSL/TLS for encryption and authentication, known for its flexibility and cross-platform compatibility.\n\nWhen using VPNs, the overhead of additional optional packet headers and security features (GRE, PTP, IPSEC, etc) must be taken in account for the MTU and MSS sizes. Some communications do not handle the tunneling automatically and reduce its MTU size. These communication methods may require manual MTU configurations.\n\nTypes of VPNs:\n\nRemote Access VPN (Client-to-Site VPN):\n\nAllows individual users to securely connect to a private network from remote locations over the internet.\n\nThese VPNs are commonly used by employees working from home or while traveling to access company resources such as files, applications, and internal systems.\n\nRemote access VPNs typically use protocols like SSL/TLS or IPsec to create encrypted tunnels between the user’s device and the corporate network.\n\nUses OpenVPN, IPsec, or Wireguard installed on the client system to create the tunnel to the Network Access Server in the main office.\n\nSite-to-Site VPN: (aka router-to-router VPN)\n\nConnects multiple sites or networks together over the internet, creating a secure communication link between them.\n\nSite-to-site VPNs are commonly used to connect branch offices to a central headquarters, or to connect geographically distributed data centers.\n\nCan be configured as point-to-point, point-to-multipoint, or full mesh.\n\nUses IPSEC, MPLS, SSL, PPTP, L2TP, and others to create the tunnel.\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/Virtual_private_network\n\nhttps://nvd.nist.gov/vuln/detail/CVE-2024-3661\n\nhttps://www.helpnetsecurity.com/2024/05/08/tunnelvision-cve-2024-3661/\n\nhttps://www.helpnetsecurity.com/2023/08/14/vpn-vulnerabilities-tunnelcrack-attacks/\n\nhttps://www.greyson.com/remote-access-vpn-guide/\n\nhttps://en.wikipedia.org/wiki/WireGuard\n\nhttps://en.wikipedia.org/wiki/OpenVPN\n\nInstructor Note\n\nInstructor Notes\n\n3.2.1.1 L2TP (TCP 1701)\n\nLayer Two Tunneling Protocol (L2TP) serves as an extension of the Point-to-Point Tunneling Protocol (PPTP) commonly employed by internet service providers (ISPs) to establish virtual private networks (VPNs). The primary objective of L2TP is to enable secure data transmission through the creation of tunnels. To uphold security and privacy standards, L2TP necessitates the use of an encryption protocol within the established tunnel.\n\nL2TP exhibits the capability to transport a diverse range of Layer 2 (L2) data types across an Internet Protocol (IP) or Layer Three (L3) network. The initiation of this process involves the establishment of a tunnel connecting an L2TP Access Concentrator (LAC) and an L2TP Network Server (LNS) on the internet. This configuration facilitates the implementation of a Point-to-Point Protocol (PPP) link layer, which is encapsulated and seamlessly transferred across the internet for secure and efficient communication.\n\nSpecified in RFC 2661 Has origins from Cisco’s L2F and Microsoft’s PPTP. Does not provide any encryption itself. Relies on other encryption methods for confidentiality.\n\nL2TP Wiki Reference\n\nL2TP Example PCAP from Cloudshark\n\nReferences:\n\nhttps://tools.ietf.org/html/rfc2661\n\nhttps://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol\n\nhttps://www.cloudshark.org/captures/42d07a525b55\n\nInstructor Note\n\nInstructor Notes\n\n3.2.1.2 PPTP (TCP 1723)\n\nPoint-to-Point Tunneling Protocol (PPTP) stands as a foundational networking protocol that empowers the secure deployment of Virtual Private Networks (VPNs) over the Internet. Conceived by Microsoft and collaborative contributors, PPTP is intricately designed to forge a private and encrypted communication conduit between clients and servers, guaranteeing the secure transmission of data.\n\nAuthentication Mechanisms: PPTP boasts support for a range of robust authentication mechanisms, including Password Authentication Protocol (PAP), Challenge Handshake Authentication Protocol (CHAP), and Microsoft CHAP (MS-CHAP). These mechanisms play a pivotal role in fortifying the verification processes, ensuring the genuine identity of the connecting parties.\n\nEncapsulation and Encryption Expertise: PPTP demonstrates its prowess by encapsulating data within its proprietary packets, establishing a secure tunnel for data transmission. Furthermore, it incorporates encryption protocols such as Microsoft Point-to-Point Encryption (MPPE) to safeguard the confidentiality of the transmitted data. This dual-layered approach enhances the privacy and integrity of the communication channel.\n\nAwareness of Limitations: Recognizing its historical prevalence, it’s crucial to acknowledge the limitations associated with PPTP. While it was widely adopted in the past, PPTP has exhibited security vulnerabilities, prompting a gradual decline in usage. Organizations and users have increasingly favored more secure VPN protocols like L2TP/IPsec and OpenVPN to address evolving security standards and ensure a higher level of data protection.\n\nSpecified in RFC 2637 Developed by Microsoft. Obsolete method to create VPN tunnels. Has many well know vulnerabilities.\n\nPPTP Wiki Reference\n\nPPTP Example PCAP from Cloudshark\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/Virtual_private_network\n\nhttps://tools.ietf.org/html/rfc2637\n\nhttps://en.wikipedia.org/wiki/Point-to-Point_Tunneling_Protocol\n\nhttps://www.cloudshark.org/captures/7a6644ad437e\n\nInstructor Note\n\nInstructor Notes\n\n3.2.1.3 IP Security (IPSec)\n\nIPsec (Internet Protocol Security) is a suite of protocols used to secure IP communications by providing encryption, authentication, and integrity protection at the network layer (Layer 3) of the OSI model. It is widely used to establish Virtual Private Networks (VPNs) and secure data transmission over IP networks, including the internet.\n\nTransport mode and Tunnel mode are two operational modes of IPsec (Internet Protocol Security) used to provide security for IP communications.\n\nTransport Mode:\n\nIn Transport mode, IPsec only encrypts the payload (data) of the original IP packet, leaving the original IP header intact.\n\nTransport mode is typically used for end-to-end communication between two hosts or devices.\n\nWhen using Transport mode, only the data portion of the IP packet is protected by IPsec, while the original IP header, including the source and destination IP addresses, remains visible to intermediate devices.\n\nTransport mode is often used for scenarios where the communicating endpoints need to establish a secure connection while maintaining direct communication with each other.\n\nExample use cases for Transport mode include securing communication between individual hosts or devices within a private network or securing VoIP (Voice over IP) traffic between two endpoints.\n\nTunnel Mode:\n\nIn Tunnel mode, IPsec encapsulates the entire original IP packet within a new IP packet, adding an additional IP header. Tunnel mode is commonly used to create secure VPN (Virtual Private Network) connections between networks or network devices, such as routers or firewalls.\n\nWhen using Tunnel mode, the original IP packet, including its header and payload, is encrypted and encapsulated within a new IP packet.\n\nThe new IP header contains the IP addresses of the VPN gateway devices (tunnel endpoints), which are responsible for encrypting and decrypting the data as it passes through the VPN tunnel.\n\nTunnel mode provides network-level security, ensuring that all traffic between the VPN gateway devices is encrypted and protected from eavesdropping or tampering.\n\nExample use cases for Tunnel mode include connecting branch offices to a central headquarters network over the internet, creating secure connections between remote users and a corporate network, or establishing site-to-site VPN connections between data centers.\n\nHeaders used by IPSec:\n\nESP Header (Encapsulating Security Payload):\n\nUses IP protocol number 50 to indicate IPSec with ESP Header payload.\n\nThe Encapsulating Security Payload provides confidentiality, integrity, and optional authentication for IP packets.\n\nIt encrypts the payload of IP packets to protect the confidentiality of the data being transmitted.\n\nThe ESP header includes fields for the Security Parameters Index (SPI), sequence number, padding, authentication data (MAC), and other parameters.\n\nESP can operate in either Transport mode (encrypts only the IP payload) or Tunnel mode (encrypts the entire IP packet).\n\nPerforms integrity check only on ESP header and payload. Not the outer IP header.\n\nDoes support protocols like NAT that alter the outer header.\n\nModification or changes to the outer header does not affect ESP.\n\nAH Header (Authentication Header):\n\nUses IP protocol number 51 to indicate IPSec with AH Header payload.\n\nThe Authentication Header provides data integrity, authentication, and anti-replay protection for IP packets.\n\nIt is used to ensure that the data received has not been altered or tampered with during transmission.\n\nThe AH header includes fields for the Security Parameters Index (SPI), sequence number, authentication data (Message Authentication Code, MAC), and other parameters.\n\nAH can operate in either Transport mode (protects only the IP payload) or Tunnel mode (protects the entire IP packet).\n\nPerforms integrity check on entire packet to include outer IP header.\n\nIntegrity done only on immutable fields: Version, Length, Next Header/protocol, Source address, Destination address\n\nMutable fields: DSCP/Traffic Class, Flow Label, TTL/Hop Limit\n\nDoes not support protocols like NAT that alter the outer header.\n\n\"mostly\" obsolete\n\nIKE Header (Internet Key Exchange):\n\nIKE typically uses UDP port 500 for its main communication channel.\n\nIKEv2 may use UDP port 4500 for NAT traversal (UDP encapsulation) to overcome NAT (Network Address Translation) issues.\n\nIKE is used to establish Security Associations (SAs) and negotiate cryptographic parameters for IPsec.\n\nIt operates at the application layer (Layer 7) and is used to exchange keying material, negotiate encryption and authentication algorithms, and authenticate IPsec peers.\n\nThe IKE header includes fields for message type, exchange type, cryptographic algorithms, key exchange data, and other parameters.\n\nIKE is typically used in conjunction with IPsec to establish secure VPN connections.\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/IPsec\n\nInstructor Note\n\nInstructor Notes\n\n3.2.1.4 OpenVPN\n\nOpenVPN is an open-source VPN (Virtual Private Network) software that provides secure communication over the internet by creating encrypted tunnels between devices or networks. It is widely used for remote access VPNs, site-to-site VPNs, and other secure networking applications.\n\nOpenVPN requires special software that implements the OpenVPN protocol. There are client and server versions. The client software runs on your device (computer, phone, etc.) and the server software runs on the VPN provider’s server. This software creates the encrypted tunnel and manages the data transmission.\n\nIt’s known for being very secure due to strong encryption algorithms and multiple authentication methods. OpenVPN uses the OpenSSL library to provide encryption of both the data and control channels.\n\nIt offers a high degree of customization, making it suitable for a wide range of uses. Because of the customization options, setting up OpenVPN can be more complex for non-technical users compared to some other VPN solutions.\n\nOpenVPN can be configured to use UDP or TCP as it’s transport layer protocols:\n\nUDP Protocol (Default):\n\nOpenVPN often uses UDP for communication, providing a lightweight and connectionless transport protocol suitable for VPNs.\n\nThe default UDP port number for OpenVPN is 1194.\n\nTCP Protocol:\n\nOpenVPN can also be configured to use TCP for communication, which can be useful in scenarios where UDP traffic is restricted or blocked.\n\nThe default TCP port number for OpenVPN is 1194, but it can be configured to use other port numbers such as port 443.\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/OpenVPN\n\nhttps://en.wikipedia.org/wiki/OpenSSL\n\nInstructor Note\n\nInstructor Notes\n\n3.2.2 Understand proxies\n\nA proxy, or proxy server, functions as a vital intermediary that stands between a user’s device, be it a computer or smartphone, and the vast expanse of the internet. Operating as a sophisticated gateway, it expertly facilitates the exchange of requests and responses between the user and the destination server, seamlessly navigating the intricate web of online communication. Proxies, with their multifaceted capabilities, empower users and organizations by delivering anonymity, content filtering, and performance optimization. In this dynamic role, proxies serve as instrumental guardians of privacy, gatekeepers for access control, and enhancers of overall internet efficiency.\n\nThis allows for your device’s information, such as IP address and possibly your MAC address, to stay hidden. Besides privacy, a proxy can provide additional benefits such as load balancing or security.\n\nWhen utilizing proxies for secure communications, we must remember that the client only creates a secure connection to the proxy, and the proxy will create the secure connection with the remote server. This means that if the proxy server should be compromised, the data communication can be intercepted.\n\nTypical communication with a proxy server is done over TCP port 1080 but The Onion Router (TOR) browsing uses TCP port 9050 by default.\n\nHere are key aspects of a proxy:\n\nAnonymity: One of the primary functions of a proxy is to provide anonymity for the user. When you connect to a website through a proxy, the website sees the IP address of the proxy server rather than your actual IP address. This can be useful for privacy and security reasons.\n\nContent Filtering: Proxies can be configured to filter and block access to specific content or websites. This is often employed in organizations and institutions to control and monitor internet usage.\n\nAccess Control: Proxies can control access to certain resources based on predefined rules. This allows administrators to restrict or grant access to specific websites, services, or content.\n\nImproved Performance: In some cases, proxies can improve network performance by caching frequently requested content. When a user requests a resource that has been cached, the proxy can deliver it directly, reducing the load on the destination server and improving response times.\n\nSecurity: Proxies can enhance security by acting as a barrier between the user and the internet. They can filter out malicious content, block access to known malicious websites, and provide an additional layer of defense against cyber threats.\n\nLoad Balancing: Proxies can distribute incoming network traffic across multiple servers, helping to balance the load and ensure efficient utilization of resources. This is known as load balancing and can improve the overall performance and reliability of a network.\n\nTypes of Proxies:\n\nForward Proxy: Acts on behalf of clients, typically used to access the internet.\n\nReverse Proxy: Acts on behalf of servers, often used to distribute incoming client requests to multiple servers.\n\nTransparent Proxy: Operates without altering the request or response, providing anonymity.\n\nAnonymous Proxy: Hides the user’s IP address but informs the server that a proxy is being used.\n\nElite or High-Anonymous Proxy: Provides the highest level of anonymity by not disclosing the use of a proxy.\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/Proxy_server\n\nhttps://en.wikipedia.org/wiki/Tor_(network)\n\nInstructor Note\n\nInstructor Notes\n\n3.2.2.1 Examine SOCKS protocol\n\nSocks 4/5 (TCP 1080)\n\nSOCKS (Socket Secure) is a protocol that facilitates communication between clients and servers through a proxy server.\n\nInitiates connections through a proxy\n\nUses various Client / Server exchange messages\n\nClient can provide authentication to server\n\nClient can request connections from server\n\nDefined in RFC 1928\n\nVersions:\n\nSOCKS4\n\nInitial version of the SOCKS protocol, introduced in the early 1990s.\n\nNo Authentication, meaning that it does not require clients to authenticate themselves before connecting to the proxy server.\n\nOnly IPv4\n\nOnly TCP support. No UDP support.\n\nNo Proxy binding. Client’s IP is not relayed to destination.\n\nSOCKS5\n\nSupport for Authentication, allowing clients to authenticate themselves using various methods, such as username/password, GSS-API (Generic Security Services Application Program Interface), or digital certificates.\n\nIPv4 and IPv6 support\n\nTCP and UDP support\n\nSupports Proxy binding. Client’s IP is relayed to destination.\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/SOCKS\n\nhttps://datatracker.ietf.org/doc/html/rfc1928\n\nInstructor Note\n\nInstructor Notes\n\n3.2.3 Examine Network Basic Input Output System (NetBIOS) protocol\n\nNetBIOS, an acronym for Network Basic Input/Output System, emerged as a protocol suite crafted by IBM during the early 1980s. This suite offers a collection of services along with an application programming interface (API), facilitating network communication across local area networks (LANs). Initially conceived for IBM’s PC Network, NetBIOS eventually evolved into a de facto standard for LAN communication within the Microsoft Windows ecosystem.\n\nNetBIOS provides services related to the session layer of the OSI model allowing applications on separate computers to communicate over a local area network. The outputs from NetBIOS can provide computer names, group assignments, and MAC addresses of nodes.\n\nNetBIOS vs. DNS: The Domain Name System (DNS) is a directory for communication between devices over the internet. An internet connection is required to use DNS, but NetBIOS is available to all machines on a local area network. If a windows system is unable to resolve a name via DNS, then it will look for a WINS server, then finally uses NetBIOS.\n\nFor more indepth information NetBIOS\n\nWindows:\n\nnbtstat -A <IP Address>\n\nOutput will provide the NetBIOS Remote Machine Name Table which has Name, Type(group), and MAC Address.\n\nLinux:\n\nnbtscan -r <IP Address>\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/NetBIOS\n\nhttps://isc.sans.edu/forums/diary/Is+it+time+to+get+rid+of+NetBIOS/12454/\n\nInstructor Note\n\nInstructor Notes\n\n3.2.3.1 Recognize well-known NetBIOS suffixes (services) and their potential for operational impact\n\nNetBIOS names typically consist of two parts: a 15-character computer name and a 16th character, known as the NetBIOS suffix. The NetBIOS suffix helps identify the type or purpose of the resource. While any 16-bit value can be used as a NetBIOS suffix, some suffixes have become well-known and are commonly associated with specific services.\n\nHere are a few well-known NetBIOS suffixes:\n\n00 (Hex): The \"00\" suffix is often associated with the workstation service. It identifies the primary computer name for a device.\n\n03 (Hex): The \"03\" suffix is commonly used for the Messenger service. This service enables users to send pop-up messages to each other on a Windows network.\n\n06 (Hex): The \"06\" suffix is often linked to the Remote Access Service (RAS) server. RAS allows users to connect to a network remotely.\n\n1B (Hex): The \"1B\" suffix is used for the domain master browser. It helps in maintaining a list of available resources in a Windows workgroup or domain.\n\n1C (Hex): The \"1C\" suffix is associated with the domain controller. It indicates the presence of a Windows domain controller on the network.\n\n1D (Hex): The \"1D\" suffix is related to the Master Browser service. It helps in maintaining a list of available resources in a Windows workgroup or domain.\n\n20 (Hex): The \"20\" suffix is often used for the File Service, indicating that the resource is a file server.\n\n21 (Hex): The \"21\" suffix is associated with the Remote Access Service (RAS) client. It identifies a RAS client on the network.\n\n2F (Hex): The \"2F\" suffix is commonly linked to the Windows Internet Naming Service (WINS).\n\nNetBIOS provides three distinct services:\n\nName service (NetBIOS-NS) for name registration and resolution. (UDP/137)\n\nDatagram distribution service (NetBIOS-DGM) for connectionless communication. (UDP/138)\n\nSession service (NetBIOS-SSN) for connection-oriented communication. (TCP/139)\n\nReferences:\n\nhttps://miloserdov.org/?p=4261\n\nInstructor Note\n\nInstructor Notes\n\n3.2.4 Examine Server Message Block (SMB) protocol\n\nSMB/CIFS (TCP 139/445 AND UDP 137/138)\n\nThe Server Message Block (SMB) protocol serves as a communication protocol predominantly utilized by Microsoft Windows-equipped computers. Its primary function is to facilitate the sharing of files, printers, serial ports, and various communications among network nodes. For user authentication, SMB employs either the NTLM or Kerberos protocols.\n\nAdditionally, SMB offers an authenticated inter-process communication (IPC) mechanism. Originally conceived in 1983 by Barry A. Feigenbaum at IBM, SMB aimed to provide shared access to files and printers within a network of systems running IBM’s OS/2.\n\nSubsequently, in 1987, Microsoft and 3Com implemented SMB in LAN Manager for OS/2. During this period, SMB utilized the NetBIOS service atop the NetBIOS Frames protocol as its foundational transport. Over time, Microsoft integrated SMB into Windows NT 3.1, continuously updating it to function with newer underlying transports, such as TCP/IP and NetBT. A notable development is the introduction of SMB over QUIC, which made its debut in Windows Server 2022.\n\nsmbclient -L <IP Address>\n\nAllowed devices to establish connections to other devices on network to share files, printers and other things.\n\nSeveral versions since its release in 1984:\n\nSMBv1 was released in 1984 by IBM for file sharing in DOS. Modified by Microsoft in 1990 for integration into Windows GUI.\n\nCIFS was released in 1996. Microsoft launched an initiative to rename SMB to Common Internet File System (CIFS). Included more features and support for symbolic links, hard links, larger file sizes. Rolled out with Windows 95.\n\nSMBv2.0 debuted in 2006 for Windows Vista. It featured a notable boost in performance because of increased efficiency — fewer commands and subcommands meant better speeds.\n\nSMBv2.1 released with Windows 7, bringing improved performance.\n\nSMBv3.0 released with Windows 8 with many updates. Most notable of which is enhanced security — the protocol started supporting end-to-end encryption.\n\nSMBv3.0.2 released with Windows 8.1. It offered the ability to increase security and performance by completely disabling SMBv1.\n\nSMBv3.1.1 was released in 2015 with Windows 10. It added more security elements to the protocol, like AES-128 encryption, protection from man-in-the-middle attacks, and session verification.\n\nSMB Rides over Netbios - allows applications to communicate over a LAN using a NetBIOS name. Depricated due to DNS. Netbios Wiki\n\nNetbios Dgram Service - UDP 138\n\nNetbios Session Service - TCP 139\n\nThird-Party SMB Implementations:\n\nSAMBA\n\n(Samba Wiki)\n\nDeveloped to offer file and print services for Windows clients on Unix-based systems, including Linux and other Unix variants.\n\nFacilitates seamless interaction between Unix-based systems and Windows networks, providing features like file sharing, printer services, and authentication.\n\nEnables Unix-based servers to function as file and print servers within a Windows network, ensuring compatibility and interoperability.\n\nSamba is compatible with a wide range of Unix-based operating systems, encompassing Linux, Solaris, AIX, and various BSD variants, including Apple’s macOS Server and macOS client (Mac OS X 10.2 and later).\n\nSupports various versions of the SMB protocol, allowing non-Windows systems to actively participate in Windows networking environments.\n\nNetsmb\n\nNSMB, which encompasses Netsmb and SMBFS, constitutes a group of in-kernel SMB client implementations within BSD operating systems. * Originally introduced by Boris Popov in FreeBSD 4.4, this family of implementations has proliferated across various BSD systems, including NetBSD and macOS.\n\nOver time, these implementations have undergone significant divergence.\n\nNQ\n\nNQ stands as a suite of portable SMB client and server implementations crafted by Visuality Systems, an Israel-based company founded in 1998 by Sam Widerman, who previously served as the CEO of Siemens Data Communications.\n\nMoSMB\n\nMoSMB is a proprietary SMB implementation designed for Linux and other Unix-like systems, created by Ryussi Technologies. It exclusively supports SMB versions 2.x and 3.x.\n\nSMB Wiki Reference\n\nSMB Example PCAP from Cloudshark\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/NetBIOS\n\nhttps://en.wikipedia.org/wiki/Samba_(software)\n\nhttps://en.wikipedia.org/wiki/Server_Message_Block\n\nhttps://www.cloudshark.org/captures/3ad3ce05a027\n\nInstructor Note\n\nInstructor Notes\n\n3.2.4.1 Examine Server Message Block (SMB) protocol Vulnerabilities\n\nMany vulnerabilities to SMB have been discovered since it was developed in 1984. Over the years, several vulnerabilities have been discovered in the SMB protocol that could potentially be exploited by attackers. Here are a few notable SMB protocol vulnerabilities:\n\nEternalBlue (CVE-2017-0144): EternalBlue is a vulnerability in the SMBv1 protocol that gained significant attention following its use in the WannaCry ransomware attack of 2017. It enabled remote code execution on Windows systems vulnerable to the exploit and quickly propagated through networks.\n\nVulnerabilities in SMBv1: The SMBv1 protocol has been found to have multiple vulnerabilities, including flaws that allow remote code execution. It is recommended to disable SMBv1 due to its inherent security weaknesses.\n\nSMB Signing Downgrade (CVE-2017-0290): This vulnerability enables an attacker to downgrade the SMB signing negotiation process, potentially facilitating the interception and modification of SMB communications.\n\nSMB Relay Attack: SMB relay attacks exploit the authentication mechanism of SMB, allowing an attacker to relay user credentials and gain unauthorized access to network resources. This attack is particularly effective when SMB signing is disabled or weak.\n\nDenial of Service (DoS) Attacks: Various vulnerabilities in the SMB protocol have been discovered that could lead to denial of service attacks. By sending specially crafted requests, an attacker can overwhelm an SMB server, causing it to become unresponsive or crash.\n\nMan-in-the-Middle Attacks: In certain scenarios, attackers can intercept SMB traffic using a man-in-the-middle (MITM) position. This allows them to capture and manipulate sensitive data transmitted over the SMB protocol.\n\nTo mitigate these vulnerabilities, it is crucial to maintain up-to-date SMB implementations, disable older versions like SMBv1, enforce secure configurations (such as enabling SMB signing), and regularly apply security patches provided by vendors. Additionally, implementing network segmentation, strong authentication mechanisms, and monitoring systems can aid in detecting and preventing potential attacks targeting the SMB protocol.\n\nMany organizations are moving away from SMB file and printer sharing and moving to cloud or enterprise based solutions.\n\nSome alternatives to file storage:\n\nEnterprise Content Management (ECM) Systems\n\nMicrosoft Sharepoint\n\nOpenText Content Suite\n\nIBM FileNet\n\nCloud Storage Services\n\nOnedrive\n\nGoogle Drive\n\nAmazon S3\n\nMicrosoft Azure Blob Storage\n\nSome alternatives to printer sharing are:\n\nPrinting directly to the printer\n\nPrint Management Software\n\nPaperCut\n\nEquitrac\n\nPharos\n\nManaged Print Services (MPS)\n\nXerox\n\nHP\n\nLexmark\n\nRicoh\n\nEnterprise Output Management (EOM)\n\nHP Exstream\n\nOpenText Output Management\n\nISIS Papyrus.\n\nCloud-Based Printing Solutions\n\nGoogle Cloud Print\n\nPrinterLogic\n\nMobile Printing Solutions ..HP ePrint\n\nApple AirPrint\n\nReferences:\n\nhttps://www.malwarebytes.com/blog/news/2018/12/how-threat-actors-are-using-smb-vulnerabilities\n\nInstructor Note\n\nInstructor Notes\n\n3.2.5 Examine Remote Procedure Call (RPC) Protocol\n\nRPC (Any Port)\n\nRemote Procedure Call (RPC) is a protocol that allows a program to request a service from another program located on the same system or on remote computer. It allows these programs to request services without having to understand details of the program. In essence, it standardizes the inter-communication with formalized requests for information. A procedure call is also sometimes known as a function call or a subroutine call.\n\nIn essence, Remote Procedure Call (RPC) serves as a method for computer programs to communicate across a network as if they were in close proximity. This enables one program to ask another program on a different computer to perform a service or function. Picture it as requesting a favor from a friend, but in the realm of computers where programs work together to accomplish tasks. RPC simplifies the intricacies of communication, creating the illusion that the distant program is actually a local one. This approach finds extensive use in activities such as distributed computing and networked applications.\n\nRPC is a request/response protocol.\n\nRPC Wiki Reference\n\nUser application will:\n\nSends a request for information to a external server\n\nReceives the information from the external server\n\nDisplay collected data to User\n\nExamples of RPC are:\n\nSOAP - SOAP Example PCAP from Cloudshark\n\nXML\n\nJSON\n\nNFS\n\nUse the netstat command (Linux/Windows) to show established connections and sockets.\n\nSome examples of RPCs are:\n\nXML-RPC: Uses XML for data encoding, HTTP as the transport protocol.\n\nXML-RPC.NET: An RPC protocol based on XML-RPC but specifically designed for use with the .NET framework.\n\nJSON-RPC: Uses JSON for data encoding, typically over HTTP.\n\nJSON-WSP (JSON Web Service Protocol): Similar to JSON-RPC, JSON-WSP is an RPC protocol that uses JSON for data encoding and typically operates over HTTP.\n\ngRPC: Developed by Google, uses Protocol Buffers, supports HTTP/2.\n\nThrift: Open-source framework by Facebook, supports multiple languages, uses a binary protocol.\n\nDCOM (Distributed Component Object Model): Developed by Microsoft, supports various transport protocols.\n\nONC RPC (Open Network Computing RPC): Used in UNIX/Linux environments, based on RPC/XDR standards.\n\nSOAP (Simple Object Access Protocol): A widely used RPC protocol that uses XML for data encoding and typically operates over HTTP or other transport protocols.\n\nREST (Representational State Transfer): Although not a traditional RPC protocol, RESTful APIs can be considered a form of RPC where remote resources are accessed and manipulated using HTTP methods such as GET, POST, PUT, and DELETE. RESTful APIs follow the principles of resource-oriented architecture.\n\nAvro RPC: Developed as part of the Apache Avro project, Avro RPC is a fast and efficient RPC protocol that uses Avro’s binary serialization format.\n\nMQTT (Message Queuing Telemetry Transport): Although primarily a messaging protocol, MQTT can also be used for RPC-like communication patterns.\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/Remote_procedure_call\n\nhttps://en.wikipedia.org/wiki/SOAP\n\nhttps://www.cloudshark.org/captures/74a6deb7aa4e?\n\nhttps://en.wikipedia.org/wiki/XML-RPC\n\nhttps://en.wikipedia.org/wiki/JSON-RPC\n\nhttps://en.wikipedia.org/wiki/Network_File_System\n\nInstructor Note\n\nInstructor Notes\n\n3.2.6 Application Programming Interface (API)\n\nAn Application Programming Interface (API) is a set of rules and tools that allows different software applications to communicate with each other. It defines the methods and data formats that applications can use to request and exchange information. APIs are used to enable the integration of different software systems, making it easier for developers to build on top of existing functionalities without needing to understand the internal workings of the underlying software.\n\nApplication Programming Interface, acts as a mediator between different software applications, facilitating their communication and interaction. It consists of a set of regulations, protocols, and tools that govern how software components should interact. By defining methods and data formats, an API enables the exchange of information between applications.\n\nAPIs play a crucial role in enabling diverse software systems, services, or platforms to seamlessly interact and share data. They establish a standardized approach for developers to access and leverage the functionality and resources of a specific software system or service, eliminating the need to delve into the intricate details of its internal implementation.\n\nSome examples of APIs are:\n\nSocial Media APIs: (Facebook Graph API, Twitter API, Instagram API, LinkedIn API)\n\nPayment Gateway APIs: (PayPal API, Stripe API, Braintree API, Square API)\n\nMaps and Geolocation APIs: (Google Maps API, Mapbox API, OpenStreetMap API, Bing Maps API)\n\nWeather APIs: (OpenWeatherMap API, Weatherbit API, AccuWeather API, Dark Sky API)\n\nCloud Services APIs: (Amazon Web Services (AWS) API, Microsoft Azure API, Google Cloud Platform (GCP) API, IBM Cloud API)\n\nE-commerce APIs: (Shopify API, WooCommerce API, BigCommerce API, Magento API)\n\nEmail and Messaging APIs: (SendGrid API, Twilio API, Mailchimp API, Nexmo API)\n\nPayment Processor APIs: (Visa Developer API, Mastercard Developers API, American Express API, Discover Developer API)\n\nNews and Content APIs: (NewsAPI, New York Times API, Guardian API, Giphy API)\n\nMusic and Media APIs: (Spotify API, YouTube API, SoundCloud API, Last.fm API)\n\nTravel and Transportation APIs: (Amadeus API, Skyscanner API, Uber API, FlightAware API)\n\nFinancial Data APIs: (Alpha Vantage API, Yahoo Finance API, Xignite API, Intrinio API)\n\nGovernment APIs: (NASA API, OpenFDA API, Census Bureau API, OpenWeatherMap API)\n\nMachine Learning and AI APIs: (TensorFlow API, Microsoft Azure Cognitive Services API, IBM Watson API, Google Cloud Machine Learning API)\n\nCryptocurrency APIs: (CoinGecko API, CoinMarketCap API, Binance API, Kraken API)\n\nAPIs and RPC are mechanisms for communication and interaction between software components.\n\nAPIs provide a standardized interface for developers to access and use functionalities of a system or service, often language-agnostic and implemented using various protocols. They focus on exposing functions, operations, or endpoints for clients to interact with the system or service. APIs are versatile and widely used in web development, mobile apps, and third-party service integration.\n\nRPC, on the other hand, is a specific approach for remote procedure calls within a distributed system, treating remote components as local. They are esentially how the communication happens.\n\nBoth APIs and RPC involve communication and interaction between software components. API is a set of rules enabling communication between software applications, while RPC is a protocol facilitating the execution of procedures on remote systems.\n\nReferences:\n\nInstructor Note\n\nInstructor Notes\n\n3.2.6.1 RPC vs API\n\nWhile Remote Procedure Call (RPC) and Application Programming Interface (API) are related concepts and are often used together in the context of distributed systems and software development, they are not the same thing.\n\nRemote Procedure Call (RPC):\n\nRPC is a communication protocol that allows a program to execute procedures or functions on a remote server or service as if they were local. It enables distributed applications to communicate and work together seamlessly across network boundaries. RPC abstracts the details of network communication, allowing clients to invoke remote procedures on servers and receive results as if the procedures were executed locally.\n\nApplication Programming Interface (API):\n\nAPI refers to a set of rules and protocols that define how software components or services interact with each other. APIs define the methods, data structures, and protocols that developers can use to interact with a software component, service, or system. APIs can be used to access functionality provided by libraries, frameworks, operating systems, web services, or other software components. APIs can be local (e.g., library APIs) or remote (e.g., web service APIs), and they define the contract between the client and the provider of the service.\n\nWhile RPC can be used to implement APIs for remote procedure invocation, not all APIs are implemented using RPC. APIs can be implemented using various technologies and communication protocols, including RESTful HTTP, SOAP, GraphQL, messaging protocols (e.g., MQTT, AMQP), and others. RPC is just one of many possible approaches for implementing APIs for remote communication.\n\nReferences:\n\nInstructor Note\n\nInstructor Notes\n\n3.3 Explain OSI Layer 6 functions and responsibilities\n\nLayer 6 of the OSI (Open Systems Interconnection) model is the Presentation Layer. The Presentation Layer is responsible for the syntax and semantics of the data exchanged between two systems. It ensures that the data presented to the application layer is in a format that the application layer can understand.\n\nReferences:\n\nInstructor Note\n\nInstructor Notes\n\n3.3.1 Explain the presentation layer functions and responsibilities\n\nPresentation Layer - This layer deals with the Translating, Formatting, Encryption, and Compression of data.\n\nData Translation and Transformation:\n\nThe Presentation Layer can translate data between different character encoding schemes, such as ASCII, Unicode, EBCDIC, etc., ensuring compatibility between systems with different encoding requirements.\n\nASCII Encoding: American Standard Code for Information Interchange represents text characters using 7 or 8 bits, mapping each character to a numeric value.\n\nUnicode Encoding: A character encoding standard that encompasses most of the world’s writing systems, assigning unique numerical values to characters, emojis, and symbols.\n\nUTF-8 Encoding: A variable-width character encoding capable of encoding all Unicode characters using one to four bytes, commonly used in web pages and email.\n\nUTF-16 Encoding: A character encoding capable of encoding all Unicode characters using two or four bytes, often used in programming languages like Java and JavaScript.\n\nUTF-32 Encoding: A fixed-width encoding scheme that represents each Unicode code point with four bytes, ensuring straightforward indexing but resulting in larger file sizes compared to UTF-8 and UTF-16.\n\nBase64 Encoding: Converts binary data into ASCII characters, useful for encoding binary data such as images or attachments in emails or transmitting binary data over text-based protocols.\n\nURL Encoding: Converts special characters into a format that can be transmitted over the Internet, replacing reserved characters with percent-encoded representations.\n\nData Formatting and Syntax Parsing:\n\nThe Presentation Layer can format data according to predefined standards or protocols, ensuring that the data conforms to the expected syntax and structure. It parses the incoming data to extract relevant information and present it to the application layer in a meaningful way.\n\nText-Based Formats:\n\nPlain Text (.txt): Simplest format containing unformatted text without any styling or formatting.\n\nComma-Separated Values (.csv): Tabular format where data values are separated by commas, commonly used for storing and exchanging spreadsheet or database data.\n\nExtensible Markup Language (.xml): Markup language for encoding structured data in a human-readable format, widely used in web services, configuration files, and data exchange.\n\nJavaScript Object Notation (.json): Lightweight data interchange format commonly used for transmitting data between a server and a web application, as well as storing configuration data.\n\nDocument Formats:\n\nPortable Document Format (.pdf): A format developed by Adobe that preserves document formatting and layout across different platforms, widely used for sharing and distributing documents.\n\nMicrosoft Word Document (.docx): Word processing format developed by Microsoft, used for creating and editing text-based documents with rich formatting, images, and other multimedia elements.\n\nRich Text Format (.rtf): Cross-platform document format that supports text formatting, images, and other media, compatible with various word processors.\n\nImage Formats:\n\nJoint Photographic Experts Group (.jpg/.jpeg): Commonly used format for storing compressed digital images, suitable for photographs and complex images with many colors.\n\nGraphics Interchange Format (.gif): Format supporting animated images and short video clips, widely used for web animations and memes.\n\nPortable Network Graphics (.png): Lossless image format that supports transparency and compression, commonly used for web graphics and digital images.\n\nAudio Formats:\n\nMP3 (.mp3): Compressed audio format that reduces file size while preserving audio quality, widely used for storing and sharing music and audio files.\n\nWaveform Audio File Format (.wav): Uncompressed audio format that preserves original audio data without loss of quality, commonly used for professional audio editing and recording.\n\nAdvanced Audio Coding (.aac): Format for encoding digital audio data, known for its high compression efficiency and widespread support in multimedia applications.\n\nVideo Formats:\n\nMoving Picture Experts Group-4 (.mp4): Standard format for storing digital video and multimedia content, widely supported by video playback software and devices.\n\nAudio Video Interleave (.avi): Multimedia container format developed by Microsoft, capable of storing audio and video data in a single file, commonly used for video editing and playback.\n\nFlash Video (.flv): Format developed by Adobe for streaming video content over the internet, commonly used for web-based video players and online streaming platforms.\n\nData Encryption and Decryption:\n\nThe Presentation Layer can perform encryption and decryption of data to ensure its confidentiality and integrity during transmission. It encrypts data before transmission and decrypts it upon receipt, allowing secure communication between systems.\n\nSymetric: AES, Blowfish, Twofish, DES, and RC4\n\nAsymetric: PKI, Diffie-Hellman, DSS, RSA, Elliptic curve\n\nTLS (Transport Layer Security):\n\nTLS is primarily a transport layer protocol that provides secure communication over a network. However, cryptographic algorithms used in TLS (such as RSA, Diffie-Hellman, and AES) may be invoked at the presentation layer for encrypting data before presentation to the user.\n\nIn web browsers, TLS encryption ensures secure communication between the client and server, protecting sensitive data such as login credentials, payment information, and personal details during transmission.\n\nSSL (Secure Sockets Layer):\n\nSSL is the predecessor to TLS and operates similarly to TLS in providing secure communication over a network. Like TLS, SSL may involve cryptographic operations at the presentation layer to encrypt data before rendering.\n\nAlthough SSL has been largely deprecated in favor of TLS, some legacy systems and applications may still use SSL for securing data.\n\nPGP (Pretty Good Privacy):\n\nPGP is an encryption program that provides cryptographic privacy and authentication for data communication. It can be used for encrypting and decrypting emails, files, and other forms of data.\n\nWhile PGP is commonly associated with email encryption (which operates at the application layer), it may also involve cryptographic operations at the presentation layer for rendering encrypted messages in email clients.\n\nS/MIME (Secure/Multipurpose Internet Mail Extensions):\n\nS/MIME is a standard for secure email messaging that provides encryption and digital signature functionality. It enables users to send encrypted and digitally signed emails using cryptographic algorithms such as RSA and AES.\n\nS/MIME operations may involve cryptographic processing at the presentation layer for rendering encrypted email messages and verifying digital signatures.\n\nOpenPGP (Open Pretty Good Privacy):\n\nOpenPGP is an open-source standard that builds upon PGP for secure communication. It defines formats for encrypted messages, digital signatures, and key management.\n\nOpenPGP implementations may involve cryptographic operations at the presentation layer for rendering encrypted messages and verifying digital signatures.\n\nEnd-to-End Encryption (E2EE):\n\nE2EE is a method of secure communication that ensures only the communicating users can read the messages. Encryption and decryption occur exclusively at the endpoints, providing strong confidentiality guarantees.\n\nWhile E2EE is typically implemented at the application layer, cryptographic techniques used for encryption and decryption may involve operations at the presentation layer for data rendering.\n\nData Compression and Decompression:\n\nThe Presentation Layer can compress data to reduce its size before transmission, optimizing network bandwidth and speeding up data transfer. It decompresses the data upon receipt, restoring it to its original format.\n\nSometimes data gets to big to transmit over the network so the Presentation layer handles compression.The primary role of Data compression is to reduce the number of bits to be transmitted. It is important in transmitting multimedia such as audio, video, text etc.\n\nZip, TAR, RAR, 7zip, CAB\n\nLossless Compression:\n\nLempel-Ziv (LZ) Compression: This family of algorithms, including LZ77 and LZ78, identifies repeated patterns in the data and replaces them with shorter codes, achieving compression without loss of information.\n\nDEFLATE Compression: DEFLATE combines LZ77 with Huffman coding and is used in popular formats like ZIP, gzip, and PNG for lossless compression.\n\nRun-Length Encoding (RLE): RLE replaces sequences of repeated data with a single value and a count, making it effective for compressing data with long runs of identical values.\n\nBurrows-Wheeler Transform (BWT): BWT rearranges the characters in the input data to facilitate compression. It’s often used in conjunction with other techniques like Move-to-Front (MTF) and Huffman coding.\n\nHuffman Coding: Huffman coding generates variable-length codes for characters based on their frequencies in the input data, achieving efficient compression without loss of information.\n\nArithmetic Coding: Arithmetic coding encodes a sequence of symbols into a single floating-point number within a specified range, offering high compression ratios for lossless data.\n\nBzip2 Compression: Bzip2 uses the Burrows-Wheeler Transform (BWT) and Huffman coding to achieve high compression ratios, particularly effective for compressing text files.\n\nDelta Encoding: Delta encoding compresses data by encoding the differences between consecutive values in a sequence, suitable for compressing data with predictable patterns or incremental updates.\n\nPPM (Prediction by Partial Matching): PPM predicts the next symbol in a sequence based on its context, achieving high compression ratios for text and structured data.\n\nLZMA (Lempel-Ziv-Markov chain Algorithm): LZMA combines LZ77 with additional modeling techniques like Markov chains for high compression ratios, commonly used in formats like 7z and XZ.\n\nLZ77 and LZ78: These are foundational algorithms in the LZ family, used for identifying and encoding repeated patterns in data for compression.\n\nShannon-Fano Coding: Similar to Huffman coding, Shannon-Fano coding generates prefix codes based on symbol probabilities to achieve lossless compression.\n\nGzip Compression: Gzip uses DEFLATE compression and is commonly used for compressing files on Unix-based systems.\n\nZstandard (Zstd): Zstd is a modern compression algorithm that offers a good balance between compression speed and ratio, suitable for various types of data.\n\nLZW (Lempel-Ziv-Welch) Compression: LZW is used in formats like GIF and compresses data by replacing repeating patterns with codes from a dictionary.\n\nCAB (Cabinet File Format): CAB is a Microsoft-developed file archive format commonly used for software installation packages and system files, often employing the LZX compression algorithm.\n\nLossy Compression:\n\nJPEG Compression: JPEG (Joint Photographic Experts Group) is widely used for compressing digital images. It achieves compression by discarding high-frequency information and optimizing color representation, resulting in smaller file sizes but some loss of image quality.\n\nGIF Compression: Although GIF (Graphics Interchange Format) primarily supports lossless compression, it can also be used in a lossy mode by reducing the color palette or by discarding color information. This can result in smaller file sizes but may degrade image quality, particularly for complex images.\n\nMPEG Compression: MPEG (Moving Picture Experts Group) is a suite of standards for compressing audio and video data. It typically uses lossy compression techniques such as motion compensation, discrete cosine transform (DCT), and quantization to achieve compression while maintaining perceptual quality.\n\nMP3 Compression: MP3 is a popular lossy compression algorithm for audio data. It achieves compression by removing parts of the audio signal that are less audible to humans, such as frequencies outside the normal hearing range and quiet sounds masked by louder ones.\n\nAAC (Advanced Audio Coding): AAC is a more advanced audio compression format compared to MP3. It offers better sound quality at lower bit rates and is commonly used for streaming audio and digital music distribution.\n\nOGG Compression: OGG is a container format that typically uses lossy compression for audio data. It’s often associated with the Vorbis codec, which offers high-quality audio compression at lower bit rates compared to formats like MP3.\n\nWebP Compression: WebP is an image format developed by Google that uses both lossy and lossless compression techniques. It’s designed to offer smaller file sizes and faster loading times for web images compared to formats like JPEG and PNG.\n\nHEVC (High-Efficiency Video Coding): HEVC, also known as H.265, is a video compression standard that offers better compression efficiency compared to previous standards like H.264. It’s widely used for streaming video and digital television.\n\nFLAC (Free Lossless Audio Codec): Although FLAC is primarily a lossless compression format, it can also be used in a lossy mode where certain non-essential audio data is discarded to achieve smaller file sizes while still retaining high audio quality.\n\nWAVPACK: WAVPACK is a hybrid audio compression format that offers both lossy and lossless compression modes. It’s capable of achieving high compression ratios while preserving audio quality through its lossy mode.\n\nDCT (Discrete Cosine Transform) Compression: DCT is commonly used in lossy compression algorithms for images and video, such as JPEG and MPEG. It transforms spatial data into frequency domain coefficients, allowing for efficient compression while sacrificing some image or video quality.\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/Presentation_layer\n\nInstructor Note\n\nInstructor Notes\n\n3.4 Explain OSI Layer 7 protocols and headers\n\nLayer 7 of the OSI (Open Systems Interconnection) model is the Application Layer. It is the topmost layer of the OSI model and is responsible for providing network services directly to end-users or applications. Layer 7 protocols operate at the highest level of abstraction, dealing with the actual data that users work with.\n\nWithin this layer, protocols such as HTTP (Hypertext Transfer Protocol), SMTP (Simple Mail Transfer Protocol), and FTP (File Transfer Protocol) govern the intricate communication between software applications and the network. These protocols are intricately linked with application-level headers, meticulously managing metadata and control information, thereby fostering highly efficient communication between the application and the underlying network infrastructure.\n\nReferences:\n\nInstructor Note\n\nInstructor Notes\n\n3.4.1 Analyze Telnet protocol\n\nTelnet (TCP 23)\n\nDeveloped in 1969, Telnet is a protocol used for remotely accessing and managing network devices, servers, and computers over a TCP/IP network. It allows a user to establish a terminal session on a remote host, providing command-line access to the remote system as if the user were physically present at the console. It has fallen out of favor with the development of packet sniffers being able to capture the usernames and passwords of systems. Newer (more secure) protocols like SSH are preferred.\n\nTelnet Commands and options from networksorcery.com\n\nTelnet options from iana.org\n\nTelnet pcap from www.cloudshark.org\n\nReferences:\n\nhttp://www.networksorcery.com/enp/protocol/telnet.htm\n\nhttps://www.iana.org/assignments/telnet-options/telnet-options.xhtml\n\nhttps://www.cloudshark.org/captures/000809f1a9d5\n\nInstructor Note\n\nInstructor Notes\n\n3.4.2 Analyze Secure Shell Protocol (SSH)\n\nSSH (TCP 22)\n\nThe Secure Shell (SSH) protocol is a cryptographic network protocol used for secure remote login and command execution over an unsecured network. SSH provides strong encryption, authentication, and integrity protection, making it a widely used and trusted method for remote access and secure communication.\n\nDelveloped by Tatu Ylönen in Finland 1995 who was a researcher for Finland’s Helsinki University of Technology. Due to packet sniffing attacks of protocols like telnet, rlogin, and FTP, a more secure protocol was needed.\n\nSSH reference from networksorcery.com\n\nSSH reference from wikipedia\n\nList of SSH RFC’s\n\nSSH pcap from www.cloudshark.org\n\nSSH Protocol\n\nSSH is an open protocol with many different implementations. Examples include PuTTy, Solaris Secure Shell, Bitvise, and OpenSSH. OpenSSH is the open source implementation that is most common and the focus of this course as it is widely found in Linux and Unix. Support for Windows was introduced when OpenSSH was ported to run in Windows Power Shell in 2015. It is included in Windows 10 as of 2018, though it must be enabled in settings.\n\nHistory of the protocol and implementations:\n\nDue to the way SSH was created it has many implementations and therefore is open to vulnerabilities across those different implementations. This course will focus mainly on the OpenSSH implementation.\n\nSSH was developed in 1995 after a password sniffing attack occurred at the University of Technology in Finland. A researcher at the university created SSH1 for himself, which rapidly gained popularity with over 20,000 users by the end of 1995. The creator also founded the SSH Communications Security Corp (SCS) to maintain and develop SSH. That same year, an IETF was drafted describing operation of the SSH1 software and assigned a working group (SECSH). The group submitted a draft for SSH-2.0 in February 1997 which was then released by SCS as a software product with a restrictive license. Due to restrictions many people continued to use SSH1 until OpenSSH was released. OpenSSH came from the OpenBSD project and is based on the last free release of SSH, 1.2.12, but due to the open source community it has been updated regularly and ported to many platforms.\n\nVersions\n\nSSH-1: SSH-1 was the original version developed by Tatu Ylönen in 1995. It used the RSA algorithm for key exchange and authentication. Vulnerabilities in SSH-1, such as weak cryptography and potential man-in-the-middle attacks, led to its replacement by SSH-2.\n\nSSH-2: SSH-2 was developed to address the weaknesses of SSH-1. Introduced stronger encryption algorithms, including Diffie-Hellman key exchange, AES, and 3DES for encryption. Enhanced security features such as integrity checking, improved authentication methods (including public-key cryptography with DSA and RSA), and support for X.509 certificates. SSH-2 also standardized the protocol format and message exchange for interoperability across different implementations.\n\nOpenSSH: OpenSSH is the most widely used implementation of SSH. It was developed as a free and open-source alternative to the original SSH software suite. OpenSSH includes the core components of SSH-2, providing secure remote access (SSH), secure file transfer (SFTP), and secure tunneling (SSH tunneling). OpenSSH is integrated into many Unix-like operating systems, including Linux, BSD variants, and macOS, making it a standard tool for system administration and secure communications.\n\nSSH-1.99: Some implementations and tools identify themselves as SSH-1.99 to indicate compatibility with both SSH-1 and SSH-2 protocols. This allowed for a transition period where systems could support both versions of SSH during the migration from SSH-1 to SSH-2.\n\nPuTTY: A free SSH connection tool for Windows that’s often used to remotely log in to a device using SSH.\n\nTectia SSH: A commercial implementation of the Secure Shell (SSH) protocol suite, developed by a company formerly known as SSH Communications Security and now operating under the name Tectia Corporation.\n\nUsage and features:\n\nSSH was initially created to replace insecure rsh suite of Unix programs; the syntax and user interface is identical. These services included the following:\n\nrsh Suite SSH replacement Description\n\nrsh\n\nssh\n\nProvides a channel for running a shell on a remote computer\n\nrlogin\n\nslogin\n\nProvides remote login capability\n\nrcp\n\nscp\n\nLogin programs such as telnet, remote login (rlogin), and rsh (remote shell). Though the initial use was logging into and running remote terminal sessions, capabilities were expanded to replace FTP (file transfer protocol) and RCP (remote copy protocol) with SFTP and SCP respectively.\n\nSSH uses these encryption techniques:\n\nAsymmetric Encryption:\n\nKey Exchange: When an SSH connection is initiated, the client and server perform a key exchange protocol (such as Diffie-Hellman key exchange). This protocol allows them to securely establish a shared secret key over an insecure network. Asymmetric encryption algorithms (such as RSA or Elliptic Curve Cryptography) are used during this process.\n\nKey Exchange Algorithms:\n\nDiffie-Hellman (DH): A key exchange algorithm used to establish a shared secret key between the client and server during the initial connection setup.\n\nElliptic Curve Diffie-Hellman (ECDH): A variant of Diffie-Hellman that uses elliptic curve cryptography for key exchange, offering strong security with smaller key sizes compared to traditional DH.\n\nCurve25519: A specific elliptic curve algorithm designed for efficient and secure key exchange.\n\nAuthentication: SSH also employs asymmetric encryption for user authentication. The client and server exchange public keys during the key exchange phase, and the client uses its private key to sign a challenge provided by the server. The server verifies the client’s identity by checking the signature against the client’s public key.\n\nPublic Key Algorithms:\n\nRSA (Rivest-Shamir-Adleman): A widely used public key algorithm for digital signatures and encryption. SSH uses RSA for key authentication and digital signatures.\n\nDSA (Digital Signature Algorithm): An older public key algorithm, less commonly used in SSH compared to RSA.\n\nECDSA (Elliptic Curve Digital Signature Algorithm): A variant of DSA that uses elliptic curve cryptography for digital signatures, offering strong security with smaller key sizes.\n\nUser Keys:\n\nUser keys are associated with individual users and are used for user authentication. They are typically generated by the client (user) and stored on the client-side.\n\nUser keys are asymmetric, consisting of a public key and a private key pair.\n\nThe user’s private key is kept securely on the client’s machine, while the public key is uploaded to the remote server.\n\nClents send their asymmetric public keys to the server to identify themselves to the server.\n\nHost Keys:\n\nHost keys, also known as server keys, are associated with SSH servers.\n\nThey serve as an identifier and ensure the integrity of the server during the initial connection.\n\nHost keys are generated on the server-side and are used to verify the server’s identity and protect against man-in-the-middle attacks.\n\nServers send their asymmetric public keys to the client to identify themselves to the client.\n\nThese host keys are saved by the Linux client into the /home/<user>/.ssh/know_hosts file.\n\ncat .ssh/known_hosts |1|voaTVh+n/cFF1kCHeGOIvYJyzZI=|OHW8MvjJKbXtz4206XKMhOu7Z/E= ecdsa-sha2-nistp256 AAAE2V"
    }
}