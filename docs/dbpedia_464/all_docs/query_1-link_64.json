{
    "id": "dbpedia_464_1",
    "rank": 64,
    "data": {
        "url": "https://www.linkedin.com/pulse/extending-java-programming-language-ben-crowhurst",
        "read_more_link": "",
        "language": "en",
        "title": "Extending the Java Programming Language",
        "top_image": "https://media.licdn.com/dms/image/v2/C5612AQHT2B2qr3OlYw/article-cover_image-shrink_600_2000/article-cover_image-shrink_600_2000/0/1574573923903?e=2147483647&v=beta&t=tDCoao1O2m6A9PwZWJdsOfGpgkt4uVOKwgIJDEPmepI",
        "meta_img": "https://media.licdn.com/dms/image/v2/C5612AQHT2B2qr3OlYw/article-cover_image-shrink_600_2000/article-cover_image-shrink_600_2000/0/1574573923903?e=2147483647&v=beta&t=tDCoao1O2m6A9PwZWJdsOfGpgkt4uVOKwgIJDEPmepI",
        "images": [
            "https://media.licdn.com/dms/image/v2/C5612AQHT2B2qr3OlYw/article-cover_image-shrink_600_2000/article-cover_image-shrink_600_2000/0/1574573923903?e=2147483647&v=beta&t=tDCoao1O2m6A9PwZWJdsOfGpgkt4uVOKwgIJDEPmepI",
            "https://media.licdn.com/dms/image/v2/C5612AQH8H5-u2LVw9g/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574574140283?e=1729728000&v=beta&t=0wYwuYFYuaIoWelNysnSvwU9x73TKDcNlZpyXpVF1i0",
            "https://media.licdn.com/dms/image/v2/C5612AQE9oq0C2S3T3g/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574575695308?e=1729728000&v=beta&t=JbE7yIv4l2KpsMmA10nYSdb-B1HOekHzlVrks1Ol-3o",
            "https://media.licdn.com/dms/image/v2/C5612AQGVQkOlVsRSRA/article-inline_image-shrink_400_744/article-inline_image-shrink_400_744/0/1574574603560?e=1729728000&v=beta&t=8SddqcOhfnabtYer1a0H1oNdeAgilw_ZKzVvdESiTBc",
            "https://media.licdn.com/dms/image/v2/C5612AQHp7haRJVNeKg/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574574880153?e=1729728000&v=beta&t=EjtjUgQinPTv-q3yN8zHdaAuHfh7Jdq9ClDtO89Hlgw",
            "https://media.licdn.com/dms/image/v2/C5612AQEUlRj-ivLktA/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574574946322?e=1729728000&v=beta&t=26uFJZn6CB_hY5dwGLPfpprYbm4jyCuKHWoU9ulH8JU",
            "https://media.licdn.com/dms/image/v2/C5612AQFEg0uc6rEqWA/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574575000081?e=1729728000&v=beta&t=S61zAyxWjgS2pyiA0zkR7U06xzLQ7QoYKFz0CXa59MU",
            "https://media.licdn.com/dms/image/v2/C5612AQFhuA3u3ZSYtg/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574575128986?e=1729728000&v=beta&t=7yseG9vZ8uxkBYePOkxP6Dozx1_wIF2CbafugSWye3o",
            "https://media.licdn.com/dms/image/v2/C5612AQF-LfxBbaYFww/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574575179737?e=1729728000&v=beta&t=_RO5w-9XpmAY6Onvp10B-IYlW4K1lKJRPLqf3QjY7v4",
            "https://media.licdn.com/dms/image/v2/C5612AQHxSw9oxAfg3A/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574575226050?e=1729728000&v=beta&t=-ov9OoIxbDs-88i1DeIxKVq9pnOb_6OMfvLVTopNQQs",
            "https://media.licdn.com/dms/image/v2/C5612AQG8a4M3K7Imlg/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574575276982?e=1729728000&v=beta&t=beNj76ZzAhvYloV6Rs_CIaqQ4Pxe25P2wdtsnfqXxrU",
            "https://media.licdn.com/dms/image/v2/C5612AQGSLoOzrPVn6g/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574575390621?e=1729728000&v=beta&t=EOURzunkT7C0bgALyH5tfLLXjDa7JI7YJo5UEAt2zFk",
            "https://media.licdn.com/dms/image/v2/C5612AQH2UgyVfILNag/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574575443306?e=1729728000&v=beta&t=EMWQ-gEQ2cfrhYKii9QPg4MgdIsXclCSX7mqyOsyCpA",
            "https://media.licdn.com/dms/image/v2/C5612AQH1nIXw_Wa5Aw/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574575488809?e=1729728000&v=beta&t=mpRtEJWbk2ZUitg9m08Niwc25BoI5jPFxK5TT8ijofY",
            "https://media.licdn.com/dms/image/v2/C5612AQEnUe2FG1QaIw/article-inline_image-shrink_1500_2232/article-inline_image-shrink_1500_2232/0/1574575580037?e=1729728000&v=beta&t=FuqT_o5ZiYjSJM1kiNh6UAPk7Ygt0mEBiBM6T2Ehgq4"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Ben Crowhurst"
        ],
        "publish_date": "2019-11-24T06:54:01+00:00",
        "summary": "",
        "meta_description": "Java similar to many other languages that have evolved from previous dialects, C++ in this scenario, lacks core benefits of its ancestors. Modern takes on Java such as Kotlin have already half-inched the following feature from C++.",
        "meta_lang": "en",
        "meta_favicon": "https://static.licdn.com/aero-v1/sc/h/al2o9zrvru7aqj8e1x2rzsrca",
        "meta_site_name": "",
        "canonical_link": "https://www.linkedin.com/pulse/extending-java-programming-language-ben-crowhurst",
        "text": "Java similar to many other languages that have evolved from previous dialects, C++ in this scenario, lacks core benefits of its ancestors. Modern takes on Java such as Kotlin have already half-inched the following feature from C++.\n\nTo begin will review some syntactic xylitol.\n\nProgrammers interpreting this functions core logic have to contend with the cognitive load associated with the exception handling with which it is entombed. This becomes a major distraction when following the intention and implementation principle concerning the size of logic blocks.\n\nWhat if we could reduce the previous recipe by leveraging a pinch of C++ syntactic sugar, the function-try-block.\n\nWhat follows is my journey porting the function-try-block syntax to the JDK version 13.\n\nPrerequisites\n\nThe tools listed below are required to follow along. I've included the version number of each in my development environment. No strict compliance must be adhered to; unless you have a dated setup.\n\nBe aware pathnames WILL vary between operating systems.\n\n$ uname -a Darwin development.local 18.7.0 Darwin Kernel Version 18.7.0: Tue Aug 20 16:57:14 PDT 2019; root:xnu-4903.271.2~2/RELEASE_X86_64 x86_64\n\nGit (2.21.0)\n\nEmacs (26.3)\n\nJDK-13\n\nC/C++ Compiler (11.0.0)\n\nAutomake Toolchain (3.81)\n\nJDK Build Process\n\nStep 0\n\nFetch the most recent source code from the OpenJDK Github mirror and then checkout JDK-13.\n\n$ git clone https://github.com/openjdk/jdk Cloning into 'jdk'... remote: Enumerating objects: 49, done. remote: Counting objects: 100% (49/49), done. remote: Compressing objects: 100% (41/41), done. remote: Total 998165 (delta 8), reused 18 (delta 5), pack-reused 998116 Receiving objects: 100% (998165/998165), 354.48 MiB | 361.00 KiB/s, done. Resolving deltas: 100% (745582/745582), done. Checking out files: 100% (67991/67991), done. $ cd jdk $ git checkout jdk-13+33\n\nStep 1\n\nConfigure the build.\n\n$ chmod +x configure $ ./configure configure: Configuration created at Thu Nov 21 19:56:00 AEDT 2019. checking for basename... /usr/bin/basename checking for bash... /bin/bash checking for cat... /bin/cat checking for chmod... /bin/chmod checking for cmp... /usr/bin/cmp checking for comm... /usr/bin/comm checking for cp... /bin/cp checking for cut... /usr/bin/cut checking for date... /bin/date checking for gdiff... no checking for diff... /usr/bin/diff ... ==================================================== The existing configuration has been successfully updated in /Users/Crowhurst/Development/jdk/build/macosx-x86_64-server-release using default settings. Configuration summary: * Debug level: release * HS debug level: product * JVM variants: server * JVM features: server: 'aot cds cmsgc compiler1 compiler2 dtrace epsilongc g1gc graal jfr jni-check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm-structs' * OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64 * Version string: 13-internal+0-adhoc.Crowhurst.jdk (13-internal) Tools summary: * Boot JDK: java version \"13.0.1\" 2019-10-15 Java(TM) SE Runtime Environment (build 13.0.1+9) Java HotSpot(TM) 64-Bit Server VM (build 13.0.1+9, mixed mode, sharing) (at /Library/Java/JavaVirtualMachines/jdk-13.0.1.jdk/Contents/Home) * Toolchain: clang (clang/LLVM from Xcode 11.2.1) * C Compiler: Version 11.0.0 (at /usr/bin/clang) * C++ Compiler: Version 11.0.0 (at /usr/bin/clang++) Build performance summary: * Cores to use: 4 * Memory limit: 8192 MB\n\nStep 2\n\nBuild a clean source tree before any alterations.\n\n$ make Building target 'default (exploded-image)' in configuration 'macosx-x86_64-server-release' Compiling 8 files for BUILD_TOOLS_LANGTOOLS Parsing 2 properties into enum-like class for jdk.compiler Compiling 10 properties into resource bundles for jdk.javadoc Compiling 12 properties into resource bundles for jdk.jdeps Compiling 7 properties into resource bundles for jdk.jshell Compiling 19 properties into resource bundles for jdk.compiler Compiling 1 files for BUILD_JFR_TOOLS Creating hotspot/variant-server/tools/adlc/adlc from 13 file(s) Compiling 2 files for BUILD_JVMTI_TOOLS Compiling 117 files for BUILD_java.compiler.interim Compiling 401 files for BUILD_jdk.compiler.interim Creating support/modules_libs/java.base/server/libjvm.dylib from 930 file(s) Creating hotspot/variant-server/libjvm/gtest/libjvm.dylib from 115 file(s) Creating hotspot/variant-server/libjvm/gtest/gtestLauncher from 1 file(s) Compiling 218 files for BUILD_jdk.javadoc.interim Compiling 167 files for BUILD_TOOLS_JDK Compiling 3 files for BUILD_VM_COMPILER_MATCH_PROCESSOR Compiling 188 files for BUILD_jdk.rmic.interim Compiling 5 files for BUILD_VM_COMPILER_NODEINFO_PROCESSOR Compiling 3 files for BUILD_VM_COMPILER_OPTIONS_PROCESSOR Compiling 14 files for BUILD_VM_COMPILER_REPLACEMENTS_PROCESSOR Note: Some input files use or override a deprecated API. ... Creating support/modules_cmds/jdk.jlink/jlink from 1 file(s)Creating support/modules_cmds/jdk.jlink/jmod from 1 file(s)Creating support/modules_cmds/jdk.jshell/jshell from 1 file(s)Creating support/modules_cmds/jdk.jstatd/jstatd from 1 file(s)Creating support/modules_libs/jdk.management/libmanagement_ext.dylib from 8 file(s)Creating support/modules_libs/jdk.management.agent/libmanagement_agent.dylib from 1 file(s)Creating support/modules_libs/jdk.net/libextnet.dylib from 1 file(s)Creating support/modules_libs/jdk.pack/libunpack.dylib from 7 file(s)Creating support/modules_cmds/jdk.pack/pack200 from 1 file(s)Creating support/modules_cmds/jdk.rmic/rmic from 1 file(s)Creating support/modules_cmds/jdk.pack/unpack200 from 7 file(s)Creating support/modules_cmds/jdk.scripting.nashorn.shell/jjs from 1 file(s)Creating support/modules_libs/jdk.security.auth/libjaas.dylib from 1 file(s)Compiling 4 files for BUILD_JIGSAW_TOOLSOptimizing the exploded imageStopping sjavac server Finished building target 'default (exploded-image)' in configuration 'macosx-x86_64-server-release'\n\nStep 3\n\nValidate the build was successful by running all available tests to confirm we have a working copy.\n\n$ make test-tier1 Building target 'test' in configuration 'macosx-x86_64-server-release' Compiling 31 files for BUILD_JRTFS Creating support/modules_libs/java.base/jrt-fs.jar Creating support/test/jdk/jtreg/native/lib/libTestMainKeyWindow.dylib from 1 file(s) Creating support/test/jdk/jtreg/native/lib/libnativeLibraryTest.dylib from 1 file(s) Creating support/test/jdk/jtreg/native/lib/libstringPlatformChars.dylib from 1 file(s) Creating support/test/jdk/jtreg/native/lib/libDirectIO.dylib from 1 file(s) Creating support/test/jdk/jtreg/native/lib/libInheritedChannel.dylib from 1 file(s) Creating support/test/jdk/jtreg/native/lib/libTestNative.dylib from 1 file(s) Creating support/test/jdk/jtreg/native/lib/libsanity_SimpleNativeLib.dylib from 1 file(s) Creating support/test/jdk/jtreg/native/lib/libsanity_SimpleNativeLib2.dylib from 1 file(s) Creating support/test/jdk/jtreg/native/lib/libFib.dylib from 1 file(s) Creating support/test/jdk/jtreg/native/bin/CallerAccessTest from 1 file(s) Creating support/test/jdk/jtreg/native/bin/sanity_SimpleNativeLauncher from 1 file(s) Creating support/test/jdk/jtreg/native/bin/JliLaunchTest from 1 file(s) Creating support/test/jdk/jtreg/native/bin/JniInvocationTest from 1 file(s) Creating interim java.base.jmod Creating interim java.logging.jmod Creating java.compiler.jmod Creating java.datatransfer.jmod Updating support/src.zip Creating java.desktop.jmod ...\n\nAt this stage, we've cloned, built and validated a fresh working copy of the JDK setting a solid foundation for what's to come.\n\nCompiler Architecture\n\nThis section will arm you with a high-level understanding of how a compiler is structured. The primary phase we're interested in is the Syntax Analyser, commonly know as a Parser.\n\nLexical Analyser\n\nSyntax Analyser\n\nSemantic Analyser\n\nIntermediate Generation\n\nOptimisation\n\nCode Generation\n\nByte Code\n\nExploration\n\nNow we have an overview of compiler architecture. The next step is to compile our desired new syntax and review the output from the unmodified Java compiler.\n\n$ cat <<\\EOF >Main.java > public class Main { > > public static void main(String[] arguments) { > throw new RuntimeException(\"Catch me, if you can!\"); > } catch (RuntimeException re) { > System.out.println(\"Caught runtime exception!\"); > } > } > EOF $ ./build/macosx-x86_64-server-release/jdk/bin/javac Main.java Main.java:5: error: illegal start of type } catch (RuntimeException re) { ^ Main.java:5: error: ';' expected } catch (RuntimeException re) { ^ 2 errors\n\nHmmm, 'error: illegal start of type' looks interesting. Let's search the source tree and see if we can discover where this might be originating.\n\n$ grep --recursive \"illegal start of type\" ./src ./src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties: illegal start of type $ grep --before-context=4 --after-context=4 \"illegal start of type\" ./src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties compiler.err.illegal.start.of.stmt=\\ illegal start of statement compiler.err.illegal.start.of.type=\\ illegal start of type compiler.err.illegal.parenthesized.expression=\\ illegal parenthesized expression\n\nSo we have a properties file detailing various strings for use within the code base, perhaps used for localisation. Widening our search space to capture any auto-generated artefacts from the compiler.properties file, we can hunt down any use of the marker 'compiler.err.illegal.start.of.type'.\n\n$ grep --recursive \"compiler.err.illegal.start.of.type\" . ... ./build/macosx-x86_64-server-release/support/src/build/macosx-x86_64-server-release/support/gensrc/jdk.compiler/jdk.compiler/com/sun/tools/javac/resources/CompilerProperties.java: * compiler.err.illegal.start.of.type=\\ ...\n\nLots of interesting output here, but the important result is CompilerProperties.java located within our build folder. Peeking inside the class we can see a 'public static final Error IllegalStartOfType' instance.\n\n$ grep --recursive \"IllegalStartOfType\" ./src ./src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java: log.error(pos, Errors.IllegalStartOfType); ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java: return syntaxError(pos, Errors.IllegalStartOfType); ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java: reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType); ./src/jdk.jshell/share/classes/jdk/jshell/ReplParser.java: return List.<JCTree>of(syntaxError(token.pos, Errors.IllegalStartOfType));\n\nThe instance is in use in JavacParser.java. This seems like a good source of the error given our understanding of compiler design. If we take some time to explorer the class we see two references, with the second being of particular interest.\n\nPlacing some stack tracing into this method, rebuilding the JDK and attempting to run our code again will produce further insight.\n\n$ make Building target 'default (exploded-image)' in configuration 'macosx-x86_64-server-release' Compiling 401 files for BUILD_jdk.compiler.interim Compiling 218 files for BUILD_jdk.javadoc.interim Compiling 405 files for jdk.compiler Optimizing the exploded image Stopping sjavac server Finished building target 'default (exploded-image)' in configuration 'macosx-x86_64-server-release' $ ./build/macosx-x86_64-server-release/jdk/bin/javac Main.java at com.sun.tools.javac.parser.JavacParser.illegal(JavacParser.java:466) at com.sun.tools.javac.parser.JavacParser.illegal(JavacParser.java:483) at com.sun.tools.javac.parser.JavacParser.term3(JavacParser.java:1418) at com.sun.tools.javac.parser.JavacParser.term2(JavacParser.java:891) at com.sun.tools.javac.parser.JavacParser.term1(JavacParser.java:862) at com.sun.tools.javac.parser.JavacParser.term(JavacParser.java:818) at com.sun.tools.javac.parser.JavacParser.term(JavacParser.java:798) at com.sun.tools.javac.parser.JavacParser.unannotatedType(JavacParser.java:783) at com.sun.tools.javac.parser.JavacParser.classOrInterfaceBodyDeclaration(JavacParser.java:3939) at com.sun.tools.javac.parser.JavacParser.classOrInterfaceBody(JavacParser.java:3854) at com.sun.tools.javac.parser.JavacParser.classDeclaration(JavacParser.java:3693) at com.sun.tools.javac.parser.JavacParser.classOrInterfaceOrEnumDeclaration(JavacParser.java:3647) at com.sun.tools.javac.parser.JavacParser.typeDeclaration(JavacParser.java:3636) at com.sun.tools.javac.parser.JavacParser.parseCompilationUnit(JavacParser.java:3480) at com.sun.tools.javac.main.JavaCompiler.parse(JavaCompiler.java:639) at com.sun.tools.javac.main.JavaCompiler.parse(JavaCompiler.java:676) at com.sun.tools.javac.main.JavaCompiler.parseFiles(JavaCompiler.java:1031) at com.sun.tools.javac.main.JavaCompiler.parseFiles(JavaCompiler.java:1018) at com.sun.tools.javac.main.JavaCompiler.compile(JavaCompiler.java:938) at com.sun.tools.javac.main.Main.compile(Main.java:318) at com.sun.tools.javac.main.Main.compile(Main.java:176) at com.sun.tools.javac.Main.compile(Main.java:57) at com.sun.tools.javac.Main.main(Main.java:43) Main.java:5: error: illegal start of type } catch (RunetimeException ex) { ^ Main.java:5: error: ';' expected } catch (RunetimeException ex) { ^ 2 errors\n\nThere we have it, a complete stack trace to the source of the 'illegal start of type' error message.\n\nStarting from the bottom-up, attempt to discover anything interesting that might lead us to the parsing of a method/function body i.e 'com.sun.tools.javac.parser.JavacParser.classOrInterfaceBodyDeclaration(JavacParser.java:3939)'\n\nWe see the parser methods are well documented, with comments detailing the syntax it is responsible for parsing and generating abstract syntax tree (AST) entries. At the top of the method 'classOrInterfaceBodyDeclaration' we see MethodDeclarationRest mentioned.\n\nThis looks like a very interesting target for further study.\n\nAt lines 3946 and 3953 we can see call-sites of 'methodDeclarationRest'. Following the program flow, we see the logic responsible for generating JCTree entries for the method body.\n\nIf we want to wrap our methods in try-catch blocks this look to be the perfect location to emit the relevant entries into the AST.\n\nThe question that remains is how? ¯\\_(ツ)_/¯\n\nImplementation\n\nGenerating the necessary AST entries shouldn't be too complicated given that Java already contains try-catch statements. The task is to uncover the existing logic and repurpose it to our needs. If we open Tokens.java we can see all of the entries used by the lexer.\n\nSearching for the string 'TRY' should reveal the sought-after logic.\n\n$ grep \"TRY\" ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/* ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/#JavacParser.java#: case TRY: ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/#JavacParser.java#: case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY: ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/#JavacParser.java#: * | TRY Block ( Catches | [Catches] FinallyPart ) ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/#JavacParser.java#: * | TRY \"(\" ResourceSpecification \";\"opt \")\" Block [Catches] [FinallyPart] ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/#JavacParser.java#: case TRY: { ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/#JavacParser.java#: checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES); ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java: case TRY: ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java: case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY: ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java: * | TRY Block ( Catches | [Catches] FinallyPart ) ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java: * | TRY \"(\" ResourceSpecification \";\"opt \")\" Block [Catches] [FinallyPart] ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java: case TRY: { ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java: checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES); ./src/jdk.compiler/share/classes/com/sun/tools/javac/parser/Tokens.java: TRY(\"try\"),\n\nBy localising our search to JavacParser.java and looking at any case-statements containing 'case TRY:' we will hopefully reveal the required code.\n\nThis is exactly what we are looking for! Lines 2731-2736 don't hold any relevance for us as we are not intending to support the try-resources syntax. However, lines 2737-2751 are of great importance.\n\n'JCBlock body = block()' at line 2737 is the content between the try { } and we are going to want to initialise this to our method body. The lines that follow 2737 cover the generation of multiple catches and the optional finaliser clause.\n\nBy revisiting 'methodDeclaratorRest' we can port this newly discovered logic.\n\nCode Break Down\n\nLine 4017: The if-statement indicates we are at the start of a method body LBRACE.\n\nLine 4018: Sets up and parses the body of the method into a JCBlock. If we take a look inside the function we see it places the token pointer to the end of the logic block 'accept(RBRACE)'.\n\nLine 4021: Armed with this knowledge we must compare the next token to a catch clause to determine if we need to wrap this method in a try-catch statement.\n\nLines 4022-4030: Iterates over all of the available catch handlers storing them in a ListBuffer and establishing a finaliser clause if required.\n\nLine 4031: Now we have all the puzzle pieces (method body, catchers, finaliser) to generate a JCTry statement.\n\nLines 4033-4037: Converts our JCTry statement into a list of JCStatements and then wraps them in a new JCBlock which we can use as the logic body during method declaration.\n\nLines 4039-4044: Generates a JCMethodDecl and returns the result.\n\nRebuilding the JDK and attempting to compile Main.java will hopefully result in our new functionality.\n\n$ make Building target 'default (exploded-image)' in configuration 'macosx-x86_64-server-release' Compiling 401 files for BUILD_jdk.compiler.interim Compiling 218 files for BUILD_jdk.javadoc.interim Compiling 405 files for jdk.compiler Optimizing the exploded image Stopping sjavac server Finished building target 'default (exploded-image)' in configuration 'macosx-x86_64-server-release' $ ./build/macosx-x86_64-server-release/jdk/bin/javac Main.java $ ./build/macosx-x86_64-server-release/jdk/bin/java Main Caught runtime exception!\n\nSuccess! We've now implemented the function-try-block with all of the familiar features of Java exception handling.\n\nBelow is a patch of all the changes we've made. You can also find a working version under the branch 'extending-jdk-with-functional-try-catch' at https://gitlab.com/ben-crowhurst/extending-jdk-with-functional-try-catch\n\nPatch\n\ndiff --git a/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java index 9c76230344..dba283be11 100644 --- a/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java +++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java @@ -463,7 +463,13 @@ public class JavacParser implements Parser { /** Report an illegal start of expression/type error at given position. */ JCExpression illegal(int pos) { - setErrorEndPos(pos); + StackTraceElement[] elements = Thread.currentThread().getStackTrace(); + for (int i = 1; i < elements.length; i++) { + StackTraceElement s = elements[i]; + System.out.println(\"\\tat \" + s.getClassName() + \".\" + s.getMethodName() + \"(\" + s.getFileName() + \":\" + s.getLineNumber() + \")\"); + } + + setErrorEndPos(pos); if ((mode & EXPR) != 0) return syntaxError(pos, Errors.IllegalStartOfExpr); else @@ -4011,6 +4017,32 @@ public class JavacParser implements Parser { if (token.kind == LBRACE) { body = block(); defaultValue = null; + + if (token.kind == CATCH) { + ListBuffer<JCCatch> catchers = new ListBuffer<>(); + JCBlock finalizer = null; + if (token.kind == CATCH || token.kind == FINALLY) { + while (token.kind == CATCH) catchers.append(catchClause()); + if (token.kind == FINALLY) { + nextToken(); + finalizer = block(); + } + } + JCTry tryStatement = F.at(pos).Try(body, catchers.toList(), finalizer); + + ListBuffer<JCStatement> statements = new ListBuffer<>(); + statements.addAll(List.of(tryStatement)); + + JCBlock tryBody = F.at(pos).Block(0, statements.toList()); + tryBody.endpos = token.pos; + + JCMethodDecl result = + toP(F.at(pos).MethodDef(mods, name, type, typarams, + receiverParam, params, thrown, + tryBody, defaultValue)); + attach(result, dc); + return result; + } } else { if (token.kind == DEFAULT) { accept(DEFAULT);"
    }
}