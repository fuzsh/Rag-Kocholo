{
    "id": "dbpedia_464_1",
    "rank": 48,
    "data": {
        "url": "https://isocpp.org/blog/2018/03/P10",
        "read_more_link": "",
        "language": "en",
        "title": "March 2018 : Standard C++",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://isocpp.org/assets/images/cpp_logo.png",
            "https://isocpp.org/files/img/stellar_logo.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Adrien Hamelin",
            "Tags: community",
            "Andrey Karpov",
            "Tags: None",
            "Hartmut Kaiser",
            "Marco Arena",
            "Tags: visual studio",
            "Hans Klabbers",
            "Vittorio Romeo",
            "Tags: experimental community"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "One of the greatest advantages of lambda expressions is their locality. It is really comfortable to reason about the code if the most of its parts are in the \"near\" scope, and the inversion of control is limited. On the other hand, optimiser's life is much easier with lambdas (they are just syntactic sugar, thus their actual structure is defined by the compiler). Moreover, lambdas' opaque mangled names can drastically reduce compile times. Parametrically polymorphic (generic) lambda expressions introduce additional flexibility in algorithm implementation and minimise maintenance work.\n\nParadoxically, generic lambda expressions in C++17 are somewhat too generic. That characteristic announces itself in inability to fix the lambda parameters in advance. Unlike in function templates, we cannot specify the parameter types explicitly to effectively disable template argument deduction from the passed function arguments.\n\nSome steps towards templated generic lambdas are going to be taken in C++20. For the time being, a simple technique that emulates templated generic lambdas proposed in this article may be reused.\n\nPatrice Roy has been playing with C++, either professionally, for pleasure or (most of the time) both for over 20 years. After a few years doing R&D and working on military flight simulators, he moved on to academics and has been teaching computer science since 1998. Since 2005, he’s been involved more specifically in helping graduate students and professionals from the fields of real-time systems and game programming develop the skills they need to face today’s challenges. The rapid evolution of C++ in recent years has made his job even more enjoyable.\n\nHe’s been a participating member in the ISO C++ Standards Committee since late 2014 and has been involved with the ISO Programming Language Vulnerabilities since late 2015. He has five kids, and his wife ensures their house is home to a continuously changing number of cats, dogs and other animals.\n\nI'm back in London from Jacksonville, where I attended my first ISO C++ meeting. Apart from the long flights and long working hours, it has been a very enjoyable experience for multiple reasons: [...]\n\n[...] almost every interaction when debating a paper was very well motivated, and I found myself thinking \"that's a very good point\" very often, even when two conflicting opinions were being stated one right after the other [...]\n\nRight now, both library groups are processing fewer papers than they receive. There are 19 sessions of about two hours during each meeting, and LWG spent the first five sessions on P0214, Data-Parallel Vector Types & Operations (for the Parallelism TS), which defines some SIMD types. I was delighted to be in on this, and even offered to scribe but found it impossibly hard, unlike my stint in LEWG at Toronto. However, it was during the fourth of these sessions that I started to feel distinctly unwell.\n\nThis week I attended the ISO C++ standards committee meeting to present the second revision of my paper P0645R1 Text Formatting, based on the {fmt} formatting library. The first revision was reviewed by Library Evolution Working Group (LEWG) in June 2017 in Toronto and there was a lot of feedback, particularly I’ve been asked to\n\ninvestigate compile-time format string processing,\n\nlook at using or explain why not to use an output iterator,\n\nuse string_view,\n\nallow pre-computation of output size,\n\nadd benchmarks.\n\nIt took me a while to address all the feedback, especially the first two items which required substantial API and implementation changes, so I had to skip the meeting in Albuquerque. However, this ultimately resulted in a much better API so I’m grateful to LEWG for the helpful guidance. Despite all the negative press covfefe “design by committee” sometimes works surprisingly well..."
    }
}