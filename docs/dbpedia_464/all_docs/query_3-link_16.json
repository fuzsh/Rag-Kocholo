{
    "id": "dbpedia_464_3",
    "rank": 16,
    "data": {
        "url": "https://forums.swift.org/t/swiftos-a-proposal/72048",
        "read_more_link": "",
        "language": "en",
        "title": "SwiftOS, a proposal",
        "top_image": "https://global.discourse-cdn.com/swift/original/1X/0a90dde98a223f5841eeca49d89dc9f57592e8d6.png",
        "meta_img": "https://global.discourse-cdn.com/swift/original/1X/0a90dde98a223f5841eeca49d89dc9f57592e8d6.png",
        "images": [
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/madebydouglas/48/29588_2.png",
            "https://global.discourse-cdn.com/swift/original/2X/b/bad3e5f9ad67c1ddf145107ce7032ac1d7b22563.svg",
            "https://global.discourse-cdn.com/swift/optimized/3X/6/6/66a8f0b444b1b8b11fa5216f36fca9acb8230d82_2_690x345.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/madebydouglas/48/29588_2.png",
            "https://emoji.discourse-cdn.com/apple/grinning.png?v=12",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/codafi/48/791_2.png",
            "https://avatars.discourse-cdn.com/v4/letter/c/6f9a4e/48.png",
            "https://emoji.discourse-cdn.com/apple/+1.png?v=12",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/hassila/48/22647_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/codafi/48/791_2.png",
            "https://sea2.discourse-cdn.com/swift/user_avatar/forums.swift.org/madebydouglas/48/29588_2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "off-topic",
            "swift",
            "swiftui",
            "darwin"
        ],
        "tags": null,
        "authors": [
            "maartene (Maarten Engels)",
            "corbeling (Tom)",
            "dima_kozhinov (Dmitry Kozhinov)",
            "Jean-Daniel (Jean-Daniel)",
            "hassila (Joakim Hassila)",
            "Slava_Pestov (Slava Pestov)",
            "MadeByDouglas (Douglas Hewitt)",
            "sveinhal (Svein Halvor Halvorsen)",
            "Philippe_Hausler (Philippe Hausler)",
            "codafi (Robert Widmann)"
        ],
        "publish_date": "2024-05-24T08:40:03+00:00",
        "summary": "",
        "meta_description": "SwiftOS \nIn support of an open source, opinionated, entirely Swift based OS \nThe community should build an open source SwiftOS inspired by the XNU kernel and Darwin OS open source Apple projects GitHub - apple-oss-distri&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://global.discourse-cdn.com/swift/optimized/2X/6/610ef4c64700c53fad713dda8c9563c461d82e41_2_32x32.ico",
        "meta_site_name": "Swift Forums",
        "canonical_link": "https://forums.swift.org/t/swiftos-a-proposal/72048",
        "text": "SwiftOS\n\nIn support of an open source, opinionated, entirely Swift based OS\n\nThe community should build an open source SwiftOS inspired by the XNU kernel and Darwin OS open source Apple projects GitHub - apple-oss-distributions/xnu\n\nThe Problem\n\nIndependent device makers trying to do something novel generally use Android for ease of use and its open nature, however Android has a number of disadvantages in performance and memory management compared to Apple technologies present in Darwin and Swift, such as ARC, among others. The world should benefit from the efficiencies of Apple’s OS and Swift related technologies.\n\nA company like Daylight should build their innovations on SwiftOS, not Android Daylight DC1: a new tablet with a better screen and no blue backlight - The Verge\n\nThe Solution\n\nSwiftOS would have the following main goal and differentiated from other open source OS attempts in both the FreeBSD (PureDarwin, DarwinBSD, etc.) and Linux community (elementaryOS etc.) which are not XNU based, and other attempts try to have AppKit compatibility or reproduce macOS from 20 years ago (helloSystem, ravynOS https://ravynos.com). Instead, the goal is to go where the hockey puck is going, not where it has been.\n\nAs such, we should embrace SwiftUI and have a new target, SwiftOS, alongside Apple commercial platforms. SwiftOS should be a common standard layer that can run on small microcontrollers or large multi-core ARM servers. It should support ARM and RISC-V, but not bother with x86/amd64. It should run on Apple Silicon and Snapdragon X SoCs. It should embrace the modern, decentralized web and webAssembly. Of course it should be designed with local LLM / AI processing in its bones as is appropriate.\n\nThe Dream\n\nThe idea would be someone can build an app for Apple devices in SwiftUI, and have it also run on SwiftOS on an ARM device seamlessly. These non-Apple SwiftOS devices could be smartphones, tablets, computers, micro controllers, XR headsets, cars, robots, whatever. It should focus on a compelling OS alternative for the future, not try to replicate past desktop experiences.\n\nThis should be the next generation NEXTstep OS, and if done right, Apple should incorporate it into their own commercial products. (e.g. the community is helping them port Darwin to Swift) Of course they can have proprietary code and services embedded on their devices, so a Mac is still a Mac and different from someone’s SwiftOS pc, but the SwiftOS PC could still run all SwiftUI built software.\n\nIt should enforce the latest Swift 6 concurrency requirements. Things like Swift Charts and Swift Data should work as well (mapped to a different db and ORM than CoreData as necessary). The community would have to build the UI layer in lieu of UIKit / AppKit that SwiftUI hooks into. Of course, SwiftUI should also be open sourced. All of this should emphasize the SwiftUI maxim, learn once, apply anywhere.\n\nConclusion\n\nI am not an OS engineer, I’m sure there’s a million technical problems with this idea, not to mention business problems. However, I still want this to exist, I think it would be better for the world. The world should not run on Linux, Dart and Flutter, JavaScript and React, it should run on Darwin, Swift and SwiftUI.\n\nTell me why it won’t work, why I don’t know what I’m talking about, I want to understand this problem better.\n\nIt might be an interesting start to build a kernel in Swift as a starting point; with embedded Swift that is definitely possible. In some of the bring-up and testing for it I did write some very rudimentary prototypes of a start to a kernel that runs on RPi4 so I am sure it is possible. There currently will be a few places you may need some assembly (even C/C++ need that to get a kernel bootstrapped).\n\nThe user land is definitely achievable - iOS and macOS have a considerable amount of their libraries written in Swift, and with the latest features one could even write stuff down to libc in Swift! This also would be useful since that could be reused by Swift on server projects.\n\nThere are a number of really good tutorials on YouTube & Github that step through the C implementations of what a kernel bringup would be like and Swift isn't that much different.\n\nIf you have the time to devote to it - this seems like a really cool idea/project that parts of it could have distinct community benefit; and even if you don't immediately get to that lofty dream you have it might be enticing enough for folks to contribute to it (provided they have time and the ability to contribute).\n\nI agree with Philippe - writing your own OS is an incredible way to discover so many parts of software engineering that are often abstracted miles away from us by modern machines you can buy off the shelf. I'll note that it's taking the documentation, blog, and textbook industry a long time to catch up to the reality that the world is becoming increasingly powered by embedded arm chips and not x86. But that just means you'll have to pull out your trusty copy of the ARM ARM and get cracking.\n\nThis is also an excellent opportunity to push pure Swift to its absolute limits, and even its breaking points. I can think of one simple example: managing interrupts and interrupt safety. This is an absolutely foundational problem to solve, and one that often involves dropping to inline assembly and papering over the conventions with macros in C-like languages. What does this look like in Swift? Are there sufficient language features to express what you're after, and if not you've got some proposals to write!\n\nAnother area I can definitely say we're lacking is custom allocator support. In theory, one would have a general-purpose kernel heap allocator backing allocations the Swift runtime and standard library make. In practice, many parts of the compiler and runtime assume any reasonable system ought to have malloc or a malloc-ish system. Custom allocator support has made its way into a number of different languages, maybe it's Swift's time.\n\nI'd also like to offer a separate viewpoint here on OS lineage: consider thinking outside of the box that XNU and the BSDs have built for themselves over the intervening decades. OS development isn't exactly radical rocket science these days - it's been said that the most complicated data structure in XNU is the linked list - but there are still other OSes we can learn a great deal from. For example, for file systems, I fell in love with beOS and its BFS file system that elevates file metadata to the level of file data and is designed to hold live \"queries\" open against the file system. (Be demoed their \"address book\" app which was quite literally a live file system query for files with contact info associated with them). Also consider whether or not you'd like to shoot for POSIX compatibility. Therein lies an enormous amount of baggage and... well let's be frank, technical decisions that have not aged well. How much can you get away with by e.g. writing POSIX compatibility as a library as Windows does? What do you want your portability story to be, and not be? Also consider whether you want to replicate the Mach VM. The overhead of virtual memory systems can be substantial, and is arguably chiefly for a world where memory unsafe languages can't be trusted to play nicely with the resources they're given. Does Swift at the core change that calculus?\n\nI'll also say that the Solaris and Sun folks that make up Oxide's leadership also have an admirable philosophy on OS subsystem development where they build tools and debuggers alongside the components they bring up. Not surprising to hear that the dtrace folks are running the show there when you hear that. But it's an excellent way to build robust, introspectable, and even tunable systems when you engineer an OS with that philosophy in mind.\n\nI'll offer some references that I found particularly great on my journey through this end of computer science:\n\nImproving IPC by Kernel Design (and honestly everything else Liedtke has written about L3/L4)\n\nDynamic Storage Allocation\n\nPractical File System Design\n\nLinkers and Loaders\n\nManagarm, a fully asynchronous operating system\n\nTalk: Inside the Mac OS X Kernel\n\nWindows 95 System Programming Secrets\n\nSolaris Internals\n\nI'd say that depends on the person(s) involved. Multiple hobby OSs have been built that were done purely for the heck of it, not to mention any number of other projects people have worked on for years just because they enjoyed it, even though what they were building wasn't necessarily \"useful\" in some more absolute sense.\n\nSure, building a \"proper\" OS that could actually be used by a wider audience would be a massive undertaking and take years, but I guess my question is \"so what?\" If someone wants to give it a go, or even just build a hobby OS in Swift that they dream might some day \"make it big\", I don't see much harm in it. Worst case scenario, the project withers away and dies at some point but the people involved will still probably have learned new things and had fun in the process. Maybe someone ends up with a niche hobby OS that exactly 37 peope have even heard of, but which lives on for years with folks working on it occasionall. And there's still a nonzero chance that it'd lead into something more interesting or even actually useful in some way – even if it's just eg. stdlib or framework development around some feature that'll be useful for embedded code."
    }
}