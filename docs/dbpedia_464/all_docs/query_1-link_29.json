{
    "id": "dbpedia_464_1",
    "rank": 29,
    "data": {
        "url": "https://en.wikipedia.org/wiki/Cocoa_(API)",
        "read_more_link": "",
        "language": "en",
        "title": "Cocoa (API)",
        "top_image": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "meta_img": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/96/Symbol_category_class.svg/16px-Symbol_category_class.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2002-06-10T03:13:33+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/Cocoa_(API)",
        "text": "MacOS framework\n\nCocoaDeveloper(s)Apple Inc.Written inC, C++, Objective-C, SwiftOperating systemmacOSTypeSoftware frameworkLicenseProprietary\n\nwith some open source components[citation needed]WebsiteApple Developer\n\nCocoa is Apple's native object-oriented application programming interface (API) for its desktop operating system macOS.\n\nCocoa consists of the Foundation Kit, Application Kit, and Core Data frameworks, as included by the Cocoa.h header file, and the libraries and frameworks included by those, such as the C standard library and the Objective-C runtime.[1]\n\nCocoa applications are typically developed using the development tools provided by Apple, specifically Xcode (formerly Project Builder) and Interface Builder (now part of Xcode), using the programming languages Objective-C or Swift. However, the Cocoa programming environment can be accessed using other tools. It is also possible to write Objective-C Cocoa programs in a simple text editor and build it manually with GNU Compiler Collection (GCC) or Clang from the command line or from a makefile.\n\nFor end users, Cocoa applications are those written using the Cocoa programming environment. Such applications usually have a familiar look and feel, since the Cocoa programming environment provides a lot of common UI elements (such as buttons, scroll bars, etc.), and automates many aspects of an application to comply with Apple's human interface guidelines.\n\nFor iOS, iPadOS, tvOS, and watchOS, a similar API exists, named Cocoa Touch, which includes gesture recognition, animation, and a different set of graphical control elements. It is used in applications for Apple devices such as the iPhone, the iPod Touch, the iPad, the Apple TV, and the Apple Watch.\n\nHistory\n\n[edit]\n\nFurther information: History of macOS\n\nCocoa continues the lineage of several software frameworks (mainly the App Kit and Foundation Kit) from the NeXTSTEP and OpenStep programming environments developed by NeXT in the 1980s and 1990s. Apple acquired NeXT in December 1996, and subsequently went to work on the Rhapsody operating system that was to be the direct successor of OpenStep. It was to have had an emulation base for classic Mac OS applications, named Blue Box. The OpenStep base of libraries and binary support was termed Yellow Box. Rhapsody evolved into Mac OS X, and the Yellow Box became Cocoa. Thus, Cocoa classes begin with the letters NS, such as NSString or NSArray. These stand for the original proprietary term for the OpenStep framework, NeXTSTEP.[2]\n\nMuch of the work that went into developing OpenStep was applied to developing Mac OS X, Cocoa being the most visible part. However, differences exist. For example, NeXTSTEP and OpenStep used Display PostScript for on-screen display of text and graphics, while Cocoa depends on Apple's Quartz (which uses the Portable Document Format (PDF) imaging model, but not its underlying technology). Cocoa also has a level of Internet support, including the NSURL and WebKit HTML classes, and others, while OpenStep had only rudimentary support for managed network connections via NSFileHandle classes and Berkeley sockets.\n\nThe API toolbox was originally called “Yellow Box” and was renamed to Cocoa - a name that had been already trademarked by Apple. Apple's Cocoa trademark had originated as the name of a multimedia project design application for children. The name was intended to evoke \"Java for kids\", as it ran embedded in web pages.[3] The original \"Cocoa\" program was discontinued following the return of Steve Jobs to Apple. At the time, Java was a big focus area for the company, so “Cocoa” was used as the new name for “Yellow Box” because, in addition to the native Objective-C usage, it could also be accessed from Java via a bridging layer.[4] Even though Apple discontinued support for the Cocoa Java bridge, the name continued and was even used for the Cocoa Touch API.\n\nMemory management\n\n[edit]\n\nOne feature of the Cocoa environment is its facility for managing dynamically allocated memory. Foundation Kit's NSObject class, from which most classes, both vendor and user, are derived, implements a reference counting scheme for memory management. Objects that derive from the NSObject root class respond to a retain and a release message, and keep a retain count. A method titled retainCount exists, but contrary to its name, will usually not return the exact retain count of an object. It is mainly used for system-level purposes. Invoking it manually is not recommended by Apple.\n\nA newly allocated object created with alloc or copy has a retain count of one. Sending that object a retain message increments the retain count, while sending it a release message decrements the retain count. When an object's retain count reaches zero, it is deallocated by a procedure similar to a C++ destructor. dealloc is not guaranteed to be invoked.\n\nStarting with Objective-C 2.0, the Objective-C runtime implemented an optional garbage collector, which is now obsolete and deprecated in favor of Automatic Reference Counting (ARC). In this model, the runtime turned Cocoa reference counting operations such as \"retain\" and \"release\" into no-ops. The garbage collector does not exist on the iOS implementation of Objective-C 2.0. Garbage collection in Objective-C ran on a low-priority background thread, and can halt on Cocoa's user events, with the intention of keeping the user experience responsive. The legacy garbage collector is still available on Mac OS X version 10.13, but no Apple-provided applications use it.\n\nIn 2011, the LLVM compiler introduced Automatic Reference Counting (ARC), which replaces the conventional garbage collector by performing static analysis of Objective-C source code and inserting retain and release messages as necessary.\n\nMain frameworks\n\n[edit]\n\nCocoa consists of three Objective-C object libraries called frameworks. Frameworks are functionally similar to shared libraries, a compiled object that can be dynamically loaded into a program's address space at runtime, but frameworks add associated resources, header files, and documentation. The Cocoa frameworks are implemented as a type of bundle, containing the aforementioned items in standard locations.\n\nFoundation Kit (Foundation), first appeared in Enterprise Objects Framework on NeXTSTEP 3.[5] It was developed as part of the OpenStep work, and subsequently became the basis for OpenStep's AppKit when that system was released in 1994. On macOS, Foundation is based on Core Foundation. Foundation is a generic object-oriented library providing string and value manipulation, containers and iteration, distributed computing, event loops (run loops), and other functions that are not directly tied to the graphical user interface. The \"NS\" prefix, used for all classes and constants in the framework, comes from Cocoa's OPENSTEP heritage, which was jointly developed by NeXT and Sun Microsystems.\n\nApplication Kit (AppKit) is directly descended from the original NeXTSTEP Application Kit. It contains code programs can use to create and interact with graphical user interfaces. AppKit is built on top of Foundation, and uses the same NS prefix.\n\nCore Data is the object persistence framework included with Foundation and Cocoa and found in Cocoa.h.[1]\n\nA key part of the Cocoa architecture is its comprehensive views model. This is organized along conventional lines for an application framework, but is based on the Portable Document Format (PDF) drawing model provided by Quartz. This allows creating custom drawing content using PostScript-like drawing commands, which also allows automatic printer support and so forth. Since the Cocoa framework manages all the clipping, scrolling, scaling and other chores of drawing graphics, the programmer is freed from implementing basic infrastructure and can concentrate on the unique aspects of an application's content.\n\nModel–view–controller\n\n[edit]\n\nMain article: Model–view–controller\n\nThe Smalltalk teams at Xerox PARC eventually settled on a design philosophy that led to easy development and high code reuse. Named model–view–controller (MVC), the concept breaks an application into three sets of interacting object classes:\n\nModel classes represent problem domain data and operations (such as lists of people/departments/budgets; documents containing sections/paragraphs/footnotes of stylized text).\n\nView classes implement visual representations and affordances for human-computer interaction (such as scrollable grids of captioned icons and pop-up menus of possible operations).\n\nController classes contain logic that surfaces model data as view representations, maps affordance-initiated user actions to model operations, and maintains state to keep the two synchronized.\n\nCocoa's design is a fairly, but not absolutely strict application of MVC principles. Under OpenStep, most of the classes provided were either high-level View classes (in AppKit) or one of a number of relatively low-level model classes like NSString. Compared to similar MVC systems, OpenStep lacked a strong model layer. No stock class represented a \"document,\" for instance. During the transition to Cocoa, the model layer was expanded greatly, introducing a number of pre-rolled classes to provide functionality common to desktop applications.\n\nIn Mac OS X 10.3, Apple introduced the NSController family of classes, which provide predefined behavior for the controller layer. These classes are considered part of the Cocoa Bindings system, which also makes extensive use of protocols such as Key-Value Observing and Key-Value Binding. The term 'binding' refers to a relationship between two objects, often between a view and a controller. Bindings allow the developer to focus more on declarative relationships rather than orchestrating fine-grained behavior.\n\nWith the arrival of Mac OS X 10.4, Apple extended this foundation further by introducing the Core Data framework, which standardizes change tracking and persistence in the model layer. In effect, the framework greatly simplifies the process of making changes to application data, undoing changes when necessary, saving data to disk, and reading it back in.\n\nIn providing framework support for all three MVC domains, Apple's goal is to reduce the amount of boilerplate or \"glue\" code that developers have to write, freeing up resources to spend time on application-specific features.\n\nLate binding\n\n[edit]\n\nIn most object-oriented languages, calls to methods are represented physically by a pointer to the code in memory. This restricts the design of an application since specific command handling classes are needed, usually organized according to the chain-of-responsibility pattern. While Cocoa retains this approach for the most part, Objective-C's late binding opens up more flexibility.\n\nUnder Objective-C, methods are represented by a selector, a string describing the method to call. When a message is sent, the selector is sent into the Objective-C runtime, matched against a list of available methods, and the method's implementation is called. Since the selector is text data, this lets it be saved to a file, transmitted over a network or between processes, or manipulated in other ways. The implementation of the method is looked up at runtime, not compile time. There is a small performance penalty for this,[6] but late binding allows the same selector to reference different implementations.\n\nBy a similar token, Cocoa provides a pervasive data manipulation method called key-value coding (KVC).[7] This allows a piece of data or property of an object to be looked up or changed at runtime by name. The property name acts as a key to the value. In traditional languages, this late binding is impossible. KVC leads to great design flexibility. An object's type need not be known, yet any property of that object can be discovered using KVC. Also, by extending this system using something Cocoa terms key-value observing (KVO), automatic support for undo-redo is provided.\n\nLate static binding is a variant of binding somewhere between static and dynamic binding. The binding of names before the program is run is called static (early); bindings performed as the program runs are dynamic (late or virtual).\n\nRich objects\n\n[edit]\n\nOne of the most useful features of Cocoa is the powerful base objects the system supplies. As an example, consider the Foundation classes NSString and NSAttributedString, which provide Unicode strings, and the NSText system in AppKit, which allows the programmer to place string objects in the GUI.\n\nNSText and its related classes are used to display and edit strings. The collection of objects involved permit an application to implement anything from a simple single-line text entry field to a complete multi-page, multi-column text layout schema, with full professional typography features such as kerning, ligatures, running text around arbitrary shapes, rotation, full Unicode support, and anti-aliased glyph rendering. Paragraph layout can be controlled automatically or by the user, using a built-in \"ruler\" object that can be attached to any text view. Spell checking is automatic, using a system-wide set of language dictionaries. Unlimited undo/redo support is built in. Using only the built-in features, one can write a text editor application in as few as 10 lines of code. With new controller objects, this may fall towards zero. When extensions are needed, Cocoa's use of Objective-C makes this a straightforward task. Objective-C includes the concept of \"categories,\" which allows modifying existing class \"in-place\". Functionality can be accomplished in a category without any changes to the original classes in the framework, or even access to its source. In other common languages, this same task requires deriving a new subclass supporting the added features, and then replacing all instances of the original class with instances of the new subclass.\n\nImplementations and bindings\n\n[edit]\n\nThe Cocoa frameworks are written in Objective-C. Java bindings for the Cocoa frameworks (termed the Java bridge) were also made available with the aim of replacing Objective-C with a more popular language[8] but these bindings were unpopular among Cocoa developers and Cocoa's message passing semantics did not translate well to a statically-typed language such as Java.[9] Cocoa's need for runtime binding means many of Cocoa's key features are not available with Java. In 2005, Apple announced that the Java bridge was to be deprecated, meaning that features added to Cocoa in macOS versions later than 10.4 would not be added to the Cocoa-Java programming interface.\n\nAt Apple Worldwide Developers Conference (WWDC) 2014, Apple introduced a new programming language named Swift, which is intended to replace Objective-C.[10]\n\nAppleScriptObjC\n\n[edit]\n\nOriginally, AppleScript Studio could be used to develop simpler Cocoa applications.[11] However, as of Snow Leopard, it has been deprecated. It was replaced with AppleScriptObjC, which allows programming in AppleScript, while using Cocoa frameworks.[12]\n\nOther bindings\n\n[edit]\n\nThe Cocoa programming environment can be accessed using other tools with the aid of bridge mechanisms such as PasCocoa, PyObjC, CamelBones, RubyCocoa, and a D/Objective-C Bridge.\n\nThird-party bindings available for other languages include AppleScript, Clozure CL, Monobjc and NObjective (C#), Cocoa# (CLI), Cocodao and D/Objective-C Bridge,[13][14] LispWorks, Object Pascal, CamelBones (Perl), PyObjC (Python), FPC PasCocoa (Lazarus and Free Pascal), RubyCocoa (Ruby).[15]\n\nA Ruby language implementation named MacRuby, which removes the need for a bridge mechanism, was formerly developed by Apple, while Nu is a Lisp-like language that uses the Objective-C object model directly, and thus can use the Cocoa frameworks without needing a binding.\n\nOther implementations\n\n[edit]\n\nThere are also open source implementations of major parts of the Cocoa framework, such as GNUstep and Cocotron,[16] which allow cross-platform Cocoa application development to target other operating systems, such as Microsoft Windows and Linux.\n\nSee also\n\n[edit]\n\nReferences\n\n[edit]\n\nBibliography\n\n[edit]\n\nAaron Hillegass: Cocoa Programming for Mac OS X, Addison-Wesley, 3rd Edition 2008, Paperback, ISBN 0-321-50361-9.\n\nStephen Kochan: Programming in Objective-C, Sams, 1st Edition 2003, Paperback, ISBN 0-672-32586-1.\n\nMichael Beam, James Duncan Davidson: Cocoa in a Nutshell, O'Reilly, 1st Edition 2003, Paperback, ISBN 0-596-00462-1.\n\nErick Tejkowski: Cocoa Programming for Dummies, 1st Edition 2003, Paperback, ISBN 0-7645-2613-8.\n\nGarfinkel, Simson; Mahoney, Michael K. (2002). Building Cocoa Applications: A Step by Step Guide (1st ed.). O'Reilly Media. CiteSeerX 10.1.1.394.3248. ISBN 0-596-00235-1.\n\nParis Buttfield-Addison, Jon Manning: Learning Cocoa with Objective-C, O'Reilly, 3rd Edition 2012, Paperback, ISBN 978-1-4493-1849-9.\n\nScott Anguish, Erik M. Buck, Donald A. Yacktman: Cocoa Programming, Sams, 1st Edition 2002, Paperback, ISBN 0-672-32230-7.\n\nErik M. Buck, Donald A. Yacktman: Cocoa Design Patterns, Addison-Wesley Professional, 1st Edition 2009, Paperback, ISBN 978-0321535023\n\nBill Cheeseman: Cocoa Recipes for Mac OS X, Peachpit Press, 1st Edition 2002, Paperback, ISBN 0-201-87801-1.\n\nAndrew Duncan: Objective-C Pocket Reference, O'Reilly, 1st Edition 2002, Paperback, ISBN 0-596-00423-0."
    }
}