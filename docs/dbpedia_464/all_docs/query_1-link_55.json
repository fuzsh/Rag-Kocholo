{
    "id": "dbpedia_464_1",
    "rank": 55,
    "data": {
        "url": "https://www.offensivecon.org/trainings/2024/os-security-and-insecurity-workshop-offensivecon-edition.html",
        "read_more_link": "",
        "language": "en",
        "title": "*OS - Security & Insecurity Workshop - OffensiveCon Edition",
        "top_image": "https://www.offensivecon.org/android-icon-192x192.png",
        "meta_img": "https://www.offensivecon.org/android-icon-192x192.png",
        "images": [
            "https://www.offensivecon.org/img/offensive-convention-by-bluefrostsecurity.png",
            "https://www.offensivecon.org/img/bfs-logo_darkbg.png",
            "https://www.offensivecon.org/img/fingerprint.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Synopsis\n\nThis course, modeled after Jonathan Levin's \"*OS Internals: Volume III\", takes a practical approach to explaining the security of Apple's operating systems, by explaining the various mechanisms employed by Apple to secure the system - and yet demonstrating how they fail, time and time again. Through case studies of jailbreaks and Pegasus (the only weapons-grade malware caught in the wild), the techniques for protecting the OS integrity - as well as measures used to bypass them - are detailed.\n\nCode samples detailing usage of each mechanism are provided as actual examples for discussion in class. Actual jailbreak code, including the latest KFD family of jailbreaks, is presented. Advanced tools - such as Xn00p, our live kernel inspection/debugging tool - allow unprecedented visualization of what happens behind the scenes in every step of the jailbreak process. This course is updated to the latest Darwin 23 releases (iOS17, macOS 10.19)!\n\nImportant: This course is an advanced course, and requires a priori familiarity with MacOS or iOS, as per Jonathan's Levin or Amit Singh's \"Mac OS [and iOS] Internals\" books. It does not discuss basic internals, but rather builds on them so as to focus on security. Participants are highly encouraged to read the books (see below, \"Required Reading\") throughly.\n\nWe would also suggest participants consider the basic MacOS/iOS Internals course prior to this one. This special edition training takes portions of that training (notably, mach-O and debugging techniques) and includes them here.\n\n2.The Boot Sequence\n\nThe boot sequence - aside from starting up the system - is responsible for establishing and securing the chain of trust, which ensures component integrity. MacOS boot is (still) fairly lax, but that of the *OS variants is rigorously designed to be as bulletproof as possible.\n\nThis module takes a close look at the stages of boot, focusing in particular on iBoot. Focusing on a purely reverse engineering approach, this module takes apart iBoot - from BootROM to kernelcache loading:\n\nBoot sequence components: BootROM, iLLB, iBoot and friends\n\nSHSH blobs and APTickets\n\nAttack surface and potential vulnerability discussion\n\nReversing iBoot (once decrypted)\n\nReversing the Secure Enclave Processor (SEP) image (once decrypted)\n\n3.Code Signing\n\nCode Signing in Darwin not only secures code by authenticating and tamper proofing it - but also provides the substrate for all of its security features. Entitlements, Code Signature Requirements, and (more recently) Launch Constraints are all based on this important facility, which we discuss in unprecdented detail.\n\nThe Security Framework (participants will need the open sources)\n\nRefreshing Mach-O principles\n\nLC_CODE_SIGNATURE\n\nThe Code Signature SuperBlob\n\nThe Code Directory\n\nSpecial Blobs\n\nSelf-Signing and Ad-Hoc Code Signatures\n\n4.The Mandatory Access Control Framework\n\nThe Mandatory Access Control Framework (MACF) is the de-facto standard for all of Apple's security mitigation techniques - from code signing, through sandboxing. A legacy of TrustedBSD, although it is a \"private\" KPI, it is remarkably simple and, at the same time, powerful.\n\nPrecursor: KAuth\n\nIntroducing: MACF\n\nThe MACF KPIs\n\nMAC Policies\n\nCreating a simple MACF policy\n\nCase study: MacOS Quarantine\n\nCase Study: MacOS 10.15 EndpointSecurity\n\n9.Let's Get Physical\n\nApple is one of the only vendors to adopt proprietary protections for physical memory. Starting with the simple \"WatchTower\" KPP, Apple moved to introduce KTRR in the A10, followed by APRR (A11), GXF (A12) and applications such as PPL and, most recently (in iOS 17.0), SPTM & TXM. But what do all these acronyms mean? And what is their impact on exploitation?\n\nA6-A9, iOS9+: KPP\n\nA10+: KTRR\n\nA11+: APRR\n\nA12+: PPL\n\nA12+: GXF\n\nA12+ (iOS17+): SPTM/PPL\n\n10.Aie, Aie, IOKit\n\nIOKit is the most advanced and powerful feature of XNU, allowing C++ code in kernel with all its might - Object orientation and inheritance - and all its weaknesses. IOKit objects have become crucial for many an exploit, both as a vector for vulnerabilities, and as a mechanism for kernel code execution.\n\nIOKit objects: Services and user clients\n\nEnumerating and identifying IOKit objects in *OS kernels\n\nObject corruption and fake objects\n\nKernel code execution primitives (and how to survive without them)"
    }
}