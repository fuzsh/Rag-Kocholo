{
    "id": "dbpedia_464_1",
    "rank": 19,
    "data": {
        "url": "https://community.osr.com/t/modern-c-features-in-kernel-mode-drivers/55042",
        "read_more_link": "",
        "language": "en",
        "title": "Modern C++ Features in Kernel Mode Drivers",
        "top_image": "https://community.osr.com/uploads/db2714/original/1X/0befd30ca1182323c6ea57d37bdcd71870c90d35.png",
        "meta_img": "https://community.osr.com/uploads/db2714/original/1X/0befd30ca1182323c6ea57d37bdcd71870c90d35.png",
        "images": [
            "https://community.osr.com/images/emoji/twitter/slight_smile.png?v=12",
            "https://community.osr.com/images/emoji/twitter/slight_smile.png?v=12"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2018-07-06T17:07:00+00:00",
        "summary": "",
        "meta_description": "Hi All… \nThis is my annual lamentation, or pursuit of my personal holy grail if you will, about the chances of our seeing anything like modern C++ in the Kernel during my lifetime. \nBack last year, we had SOME glimmer of&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://community.osr.com/uploads/db2714/optimized/1X/0befd30ca1182323c6ea57d37bdcd71870c90d35_2_32x32.png",
        "meta_site_name": "OSR Developer Community",
        "canonical_link": "https://community.osr.com/t/modern-c-features-in-kernel-mode-drivers/55042",
        "text": "It is tempting to think C++ can provide you some advantage in the kernel,\n\nand I have tried to use it. It ends up being a total mess. I’ve come to the\n\nconclusion that if you think yo need C++ in your driver, maybe you need to\n\nrethink your design. Maybe one exception would be a file system, but I\n\ndoubt it. In fact, I end up turning off some of the more nagging defaults\n\nin Visual C++ when doing kernel work because I like being able to\n\ninitialize a structure when it is instantiated:\n\nLARGE_INTEGER x = { .QuadPart = 1000000 };\n\nto me is better than\n\nLARGE_INTEGER x;\n\nx.QuadPart = 1000000;\n\nThe former is not allowed in C++\n\nOn Fri, Jul 6, 2018 at 5:27 PM prvs=67257ae4b8=ben.craig@ni.com <\n\nxxxxx@lists.osr.com> wrote:\n\nFreestanding proposal: http://wg21.link/p0829\n\nLeaving no room for a lower-level language: A C++ Subset:\n\nhttp://wg21.link/p1105\n\n> Why CAN’T we use std::unique_ptr, for example?\n\nIf my paper gets accepted, you will always be able to use unique_ptr with\n\na custom delete, and likely be able to use it if you define your own new\n\nand delete (as you currently need to do with /KERNEL turned on)\n\n> Will static initializers ever get called?\n\nMy papers make no guarantee of that. The trick is figuring out when the\n\nright time is for that. I’d love to be able to (portably) invoke them at a\n\ntime of my choosing. It is possible to do so non-portably right now though.\n\n> Will my dreams of using std::vector in my driver ever be fulfilled?\n\nMaybe if we get zero-overhead deterministic exceptions.\n\nhttp://wg21.link/p0709\n\nSeems more like a C++23 or 26 thing though.\n\n> -----Original Message-----\n\n> From: xxxxx@lists.osr.com > > xxxxx@lists.osr.com> On Behalf Of xxxxx@osr.com\n\n> > Sent: Friday, July 6, 2018 4:07 PM\n\n> > To: Windows System Software Devs Interest List\n\n> > Subject: [ntdev] Modern C++ Features in Kernel Mode Drivers\n\n> >\n\n> > Hi All…\n\n> >\n\n> > This is my annual lamentation, or pursuit of my personal holy grail if\n\n> you will,\n\n> > about the chances of our seeing anything like modern C++ in the Kernel\n\n> > during my lifetime.\n\n> >\n\n> > Back last year, we had SOME glimmer of sunshine from Mr. Tippett:\n\n> >\n\n> > https:> > 3A__www.osronline.com_showThread.CFM-3Flink-\n\n> > 3D284723&d=DwICAg&c=I_0YwoKy7z5LMTVdyO6YCiE2uzI1jjZZuIPelcSjixA&r\n\n> > =y8mub81SfUi-UCZRX0Vl1g&m=CiCi_lxTApD0ahGZg55NzULDFJlosN7We-\n\n> > OmYOXy_ZA&s=UlBAtlq8sZ1_pg8Pc7DaXsKhQqjTm930YElQi37ClE0&e=>\n\n> >\n\n> > And since then, well… the Visual Studio C++ compiler has gotten better\n\n> (it’s\n\n> > C++ 17 compliant now) and C++ 20 has promised us even more cool shit like\n\n> > contracts (see Herb Sutter’s recent blog post on this topic).\n\n> >\n\n> > But I still don’t see much hope for us on the kernel-mode front.\n\n> >\n\n> > Why CAN’T we use std::unique_ptr, for example? Will static initializers\n\n> ever\n\n> > get called? Will my dreams of using std::vector in my driver ever be\n\n> fulfilled?\n\n> >\n\n> > Anybody have any new insight/experience/whining to share?\n\n> >\n\n> > Oh… It’s hardly thrilling, but… you can use C++ 17 attribute\n\n> specifiers. So…\n\n> > you can now officially thrill yourself and put [[fallthrough]] in your\n\n> case\n\n> > statements.\n\n> >\n\n> > Sigh…\n\n> >\n\n> > Peter\n\n> > OSR\n\n> > @OSRDrivers\n\n> >\n\n> >\n\n> > —\n\n> > NTDEV is sponsored by OSR\n\n> >\n\n> > Visit the list online at: <\n\n> https://urldefense.proofpoint.com/v2/url?u=http-\n\n> > 3A__www.osronline.com_showlists.cfm-3Flist-\n\n> > 3Dntdev&d=DwICAg&c=I_0YwoKy7z5LMTVdyO6YCiE2uzI1jjZZuIPelcSjixA&r=\n\n> > y8mub81SfUi-UCZRX0Vl1g&m=CiCi_lxTApD0ahGZg55NzULDFJlosN7We-\n\n> > OmYOXy_ZA&s=um2qqAKQ0CO2IeGu6eP_fhT2hCxMMr0kkcYZCfTlxIY&e=>\n\n> >\n\n> > MONTHLY seminars on crash dump analysis, WDF, Windows internals and\n\n> > software drivers!\n\n> > Details at https:> > 3A www.osr.com_seminars&d=DwICAg&c=I_0YwoKy7z5LMTVdyO6YCiE2u\n\n> > zI1jjZZuIPelcSjixA&r=y8mub81SfUi-\n\n> > UCZRX0Vl1g&m=CiCi_lxTApD0ahGZg55NzULDFJlosN7We-\n\n> > OmYOXy_ZA&s=tcCkJt6CRop9GcslH_0gyb8CRVwpQQml1BVUvTY91LY&e=>\n\n> >\n\n> > To unsubscribe, visit the List Server section of OSR Online at\n\n> > https:> > 3A www.osronline.com_page.cfm-3Fname-\n\n> > 3DListServer&d=DwICAg&c=I_0YwoKy7z5LMTVdyO6YCiE2uzI1jjZZuIPelcSjixA\n\n> > &r=y8mub81SfUi-UCZRX0Vl1g&m=CiCi_lxTApD0ahGZg55NzULDFJlosN7We-\n\n> > OmYOXy_ZA&s=4suR06mhclSP1KXWNdKDvzwg-\n\n> > DbNcZXkhC4daaPe2bU&e=>\n\n>\n\n> —\n\n> NTDEV is sponsored by OSR\n\n>\n\n> Visit the list online at: <\n\n> http://www.osronline.com/showlists.cfm?list=ntdev&gt;\n\n>\n\n> MONTHLY seminars on crash dump analysis, WDF, Windows internals and\n\n> software drivers!\n\n> Details at http:\n\n>\n\n> To unsubscribe, visit the List Server section of OSR Online at <\n\n> http://www.osronline.com/page.cfm?name=ListServer&gt;\n\n>\n\n–\n\nJamey Kirby\n\nDisrupting the establishment since 1964\n\nThis is a personal email account and as such, emails are not subject to\n\narchiving. Nothing else really matters.</http:></https:></https:></https:>\n\nI’ve used C++ mainly in user mode, like daemon, NT services etc. Used (pure) virtual, etc mostly on C99++, only used some lambda, unique_pointer/shared_pointer etc. So I’m not like expert on this language. Most of the time, I look at design patterns, try to map a problem at hand to it. In fact I used few patterns to achieve complex design ( which is bit far from language bloating - like seeing 10 + levels of lambdas ). Also I read, whenever needed Mr Herb, and others book to understand what I need at time….\n\nNow my take is for kernel mode components — What are the likely ADTs ( stack, Q/Deque, list, string etc) needed for kernel side ? Long back I read exceptional C++. Yes if any code has littered with try/catch, most likely an easy path to suppress some bugs (either not fully understood, or corner cases, once in a blue moon — these are good terms to convince managers ). And also the book says — It is difficult to write exception safe C++ code, and that was then, time is now. I don’t know if situation changed on this exception front.\n\nBut KPI/DDK, etc are coming up with fairly ready made ADTs etc. So one can use C, with those added library.\n\nGCC/LLVM now have so many attributes and VS has SAL etc. So there is an ongoing refinements language level helps, but using the appropriate combination is not.\n\nMany a time, I’ve seen or was told by others about C++ experts in the team. When I see the code, well of course much later, I get displeasure.\n\nIt’s perhaps me…\n\nOnce there is a comprehensive book about how to write kernel code in C++ comes out I will surely read, and read again.\n\n-Pro\n\nOn Jul 6, 2018, at 3:15 PM, xxxxx@gmail.com wrote:\n\n>\n\n> It is tempting to think C++ can provide you some advantage in the kernel, and I have tried to use it. It ends up being a total mess. I’ve come to the conclusion that if you think yo need C++ in your driver, maybe you need to rethink your design. Maybe one exception would be a file system, but I doubt it. In fact, I end up turning off some of the more nagging defaults in Visual C++ when doing kernel work because I like being able to initialize a structure when it is instantiated:\n\n>\n\n> LARGE_INTEGER x = { .QuadPart = 1000000 };\n\n>\n\n> to me is better than\n\n>\n\n> LARGE_INTEGER x;\n\n> x.QuadPart = 1000000;\n\n>\n\n> The former is not allowed in C++\n\n>\n\n>\n\n>\n\n>\n\n>\n\n> On Fri, Jul 6, 2018 at 5:27 PM prvs=67257ae4b8=ben.craig@ni.com mailto:ben.craig > wrote:\n\n> Freestanding proposal: http://wg21.link/p0829 http:\n\n> Leaving no room for a lower-level language: A C++ Subset: http://wg21.link/p1105 http:\n\n>\n\n> > Why CAN’T we use std::unique_ptr, for example?\n\n> If my paper gets accepted, you will always be able to use unique_ptr with a custom delete, and likely be able to use it if you define your own new and delete (as you currently need to do with /KERNEL turned on)\n\n>\n\n> > Will static initializers ever get called?\n\n> My papers make no guarantee of that. The trick is figuring out when the right time is for that. I’d love to be able to (portably) invoke them at a time of my choosing. It is possible to do so non-portably right now though.\n\n>\n\n> > Will my dreams of using std::vector in my driver ever be fulfilled?\n\n> Maybe if we get zero-overhead deterministic exceptions. http://wg21.link/p0709 http:\n\n> Seems more like a C++23 or 26 thing though.\n\n>\n\n>\n\n>\n\n> > -----Original Message-----\n\n> > From: xxxxx@lists.osr.com mailto:xxxxx > > xxxxx@lists.osr.com mailto:xxxxx> On Behalf Of xxxxx@osr.com mailto:xxxxx\n\n> > Sent: Friday, July 6, 2018 4:07 PM\n\n> > To: Windows System Software Devs Interest List >\n\n> > Subject: [ntdev] Modern C++ Features in Kernel Mode Drivers\n\n> >\n\n> > Hi All…\n\n> >\n\n> > This is my annual lamentation, or pursuit of my personal holy grail if you will,\n\n> > about the chances of our seeing anything like modern C++ in the Kernel\n\n> > during my lifetime.\n\n> >\n\n> > Back last year, we had SOME glimmer of sunshine from Mr. Tippett:\n\n> >\n\n> > https:\n\n> > 3A__www.osronline.com_showThread.CFM-3Flink-\n\n> > 3D284723&d=DwICAg&c=I_0YwoKy7z5LMTVdyO6YCiE2uzI1jjZZuIPelcSjixA&r\n\n> > =y8mub81SfUi-UCZRX0Vl1g&m=CiCi_lxTApD0ahGZg55NzULDFJlosN7We-\n\n> > OmYOXy_ZA&s=UlBAtlq8sZ1_pg8Pc7DaXsKhQqjTm930YElQi37ClE0&e=>\n\n> >\n\n> > And since then, well… the Visual Studio C++ compiler has gotten better (it’s\n\n> > C++ 17 compliant now) and C++ 20 has promised us even more cool shit like\n\n> > contracts (see Herb Sutter’s recent blog post on this topic).\n\n> >\n\n> > But I still don’t see much hope for us on the kernel-mode front.\n\n> >\n\n> > Why CAN’T we use std::unique_ptr, for example? Will static initializers ever\n\n> > get called? Will my dreams of using std::vector in my driver ever be fulfilled?\n\n> >\n\n> > Anybody have any new insight/experience/whining to share?\n\n> >\n\n> > Oh… It’s hardly thrilling, but… you can use C++ 17 attribute specifiers. So…\n\n> > you can now officially thrill yourself and put [[fallthrough]] in your case\n\n> > statements.\n\n> >\n\n> > Sigh…\n\n> >\n\n> > Peter\n\n> > OSR\n\n> > @OSRDrivers\n\n> >\n\n> >\n\n> > —\n\n> > NTDEV is sponsored by OSR\n\n> >\n\n> > Visit the list online at: https:\n\n> > 3A__www.osronline.com_showlists.cfm-3Flist-\n\n> > 3Dntdev&d=DwICAg&c=I_0YwoKy7z5LMTVdyO6YCiE2uzI1jjZZuIPelcSjixA&r=\n\n> > y8mub81SfUi-UCZRX0Vl1g&m=CiCi_lxTApD0ahGZg55NzULDFJlosN7We-\n\n> > OmYOXy_ZA&s=um2qqAKQ0CO2IeGu6eP_fhT2hCxMMr0kkcYZCfTlxIY&e=>\n\n> >\n\n> > MONTHLY seminars on crash dump analysis, WDF, Windows internals and\n\n> > software drivers!\n\n> > Details at https:\n\n> > 3A www.osr.com_seminars&d=DwICAg&c=I_0YwoKy7z5LMTVdyO6YCiE2u\n\n> > zI1jjZZuIPelcSjixA&r=y8mub81SfUi-\n\n> > UCZRX0Vl1g&m=CiCi_lxTApD0ahGZg55NzULDFJlosN7We-\n\n> > OmYOXy_ZA&s=tcCkJt6CRop9GcslH_0gyb8CRVwpQQml1BVUvTY91LY&e=>\n\n> >\n\n> > To unsubscribe, visit the List Server section of OSR Online at\n\n> > https:\n\n> > 3A www.osronline.com_page.cfm-3Fname-\n\n> > 3DListServer&d=DwICAg&c=I_0YwoKy7z5LMTVdyO6YCiE2uzI1jjZZuIPelcSjixA\n\n> > &r=y8mub81SfUi-UCZRX0Vl1g&m=CiCi_lxTApD0ahGZg55NzULDFJlosN7We-\n\n> > OmYOXy_ZA&s=4suR06mhclSP1KXWNdKDvzwg-\n\n> > DbNcZXkhC4daaPe2bU&e=>\n\n>\n\n> —\n\n> NTDEV is sponsored by OSR\n\n>\n\n> Visit the list online at: http:>\n\n>\n\n> MONTHLY seminars on crash dump analysis, WDF, Windows internals and software drivers!\n\n> Details at http:>\n\n>\n\n> To unsubscribe, visit the List Server section of OSR Online at http:>\n\n>\n\n>\n\n> –\n\n> Jamey Kirby\n\n> Disrupting the establishment since 1964\n\n>\n\n> This is a personal email account and as such, emails are not subject to archiving. Nothing else really matters.\n\n> — NTDEV is sponsored by OSR Visit the list online at: MONTHLY seminars on crash dump analysis, WDF, Windows internals and software drivers! Details at To unsubscribe, visit the List Server section of OSR Online at</http:></http:></http:></https:></https:></https:></https:></mailto:xxxxx></mailto:xxxxx></mailto:xxxxx></http:></http:></http:></mailto:ben.craig>\n\nAnd I?ll give my usual refrain in reply ? why would you want it\n\nI am old and full of vitriol, but I have worked on a vast array or projects across different disciplines over the years. Earlier today I had to explain to a new hire that yes, x86 (although numerically superior) is actually older than x64 and I have been conscripted to fix and ASP.NET API. Last month I was working on a Cobol extract in EBCIDIC from AS 400. I?m sure I forget half of the stuff, but in addition to KM programming in Windows and Linux, I?ve worked with at least two dozen languages over the years solving all sorts of problems.\n\nOne starts to see patterns after a time.\n\nAssuming that one has a goal oriented view of the world, then which is the better goal to have:\n\nMy life as a developer is easier; or\n\nThe quality of the work produced by my efforts is higher\n\nOne might argue that #2 is achieved by default by satisfying #1 (as Peter has done in his other thread RE MSFT engagement) , but which one is the higher goal? The goal of sloth or of achievement?\n\nAssuming then that we want to achieve things, we are looking for tools that will help us achieve.\n\nA ?high level? language like C helps us to achieve versus writing in assembly language because there is an obvious transmutation ? we change the whole paradigm of how we work from registers and addresses into variables and structures. Yes there are some kinds of algorithms which cannot be as effectively written in C as in ASM, but they are few.\n\nAn even higher level language like C# helps us achieve versus writing in C (or assembly language) because there another obvious transmutation ? again we change the whole paradigm of how we work. In this case it is all about memory management in the error cases\n\nAn event higher level language like TSQL helps us achieve by allowing us to express the DDL or DML operations of interest without having to specify how those operations will be carried our (lots of this has come to C# to via LINQ)\n\nAnd then we go into the goofy land of Excel MACRO?s, power shell scripts, and the plethora of web service techniques. Not that they are bad per se, just that they are the top of the pyramid.\n\nOn this pyramid there are many ugly duckling steps and C++ is the most notable of them all. It is a neither nor language and has all of the faults of the step below without all of the benefits of the step above. There are many others with the same problem and it is not a knock on C++ just because it is more famous.\n\nIn point of fact I am presently engaged in a support incident with MSFT that stems from their use of C++ in an ODBC driver. We call the C API on the upper edge (as per the ODBC standard) and they call the C win32 API on the lower edge, but in the middle, their code does not handle all possible errors correctly and C++ exceptions ?leak? out of the top edge back into my code. The support lead has reviewed the source code and confirmed a bug in the MSFT code, but they presently don?t plan to fix it because the cost of testing the change would be too high unless I can demonstrate this is in fact not the ?one in a million? that they think it is by producing a pattern of crash dumps from our real world application failing.\n\nAt this point, I might need my own pontification, but if anyone is still reading, a further important consideration not often discussed, is the quality of run time library support. The CRT is a very poor library overall versus the stock code available for C++. That does not make C++ as a language better, but it can reduce the work that someone needs to do to write a particular program. Similarly, C# has as extensive runtime library that finally supports (with LINQ and the concurrent generics) a proper decent set of data structures and algorithms. Exactly the same kind of support can (and has at least by me) be written in C. As an aside, looking at the .NET reference source is an eye opening activity ? many of the implementations are shockingly bad\n\nI am old and my vitriol is ebbing with this much venting. Hopefully it will be of some help to some one to read this\n\nSent from Mailhttps: for Windows 10\n\n________________________________\n\nFrom: xxxxx@lists.osr.com on behalf of xxxxx@osr.com\n\nSent: Friday, July 6, 2018 5:06:41 PM\n\nTo: Windows System Software Devs Interest List\n\nSubject: [ntdev] Modern C++ Features in Kernel Mode Drivers\n\nHi All…\n\nThis is my annual lamentation, or pursuit of my personal holy grail if you will, about the chances of our seeing anything like modern C++ in the Kernel during my lifetime.\n\nBack last year, we had SOME glimmer of sunshine from Mr. Tippett:\n\nhttp:\n\nAnd since then, well… the Visual Studio C++ compiler has gotten better (it’s C++ 17 compliant now) and C++ 20 has promised us even more cool shit like contracts (see Herb Sutter’s recent blog post on this topic).\n\nBut I still don’t see much hope for us on the kernel-mode front.\n\nWhy CAN’T we use std::unique_ptr, for example? Will static initializers ever get called? Will my dreams of using std::vector in my driver ever be fulfilled?\n\nAnybody have any new insight/experience/whining to share?\n\nOh… It’s hardly thrilling, but… you can use C++ 17 attribute specifiers. So… you can now officially thrill yourself and put [[fallthrough]] in your case statements.\n\nSigh…\n\nPeter\n\nOSR\n\n@OSRDrivers\n\n—\n\nNTDEV is sponsored by OSR\n\nVisit the list online at: http:\n\nMONTHLY seminars on crash dump analysis, WDF, Windows internals and software drivers!\n\nDetails at http:\n\nTo unsubscribe, visit the List Server section of OSR Online at http:</http:></http:></http:></http:></https:>\n\nNo, not really …\n\nAbstraction has levels. From ASM to C was a clear indicator. One can feel, smell, see, observe, once someone spend at least 5 years just dribbling with ASM. From C++ to C ( in the kernel ), with specification or order ( don’t use this, don’t use that, have your new(), delete() etc ), with FAT follower of BOOST so that we can have say included or some such.\n\nExactly how many years went by, after C kernel came, and how many major platforms’ kernel are still in C ??? To be exact first incarnation was in Mid 70s. Almost 50 years — I guess those kernel guys are lousy and worthless, right?\n\nIf some one does foul up left and right getting some ADTs right because of pointers etc., they would be called poindexter, as I was named.\n\nPlease be happy with what you use - just don’t preach, it does not work.\n\nThere has to be comprehensive set of books that would clearly spell out the advantages ( not just using std:: ). Ease of use, easy to learn, image footprint, performances etc.\n\nThe machine abstraction(s) are right there at C level ( no more / no less ). Those who have passion for work, almost never write bloated / convoluted code - Be it asm, C, C++ or any languages.\n\nThe first principle —- short, simple, clear. Language would not matter ( when it comes to C or C++ ).\n\n-Pro\n\n> On Jul 6, 2018, at 5:02 PM, xxxxx@gmail.com wrote:\n\n>\n\n> Never fails does it? Every time this discussion comes up instead of talking about c++ people talk about their own deficiencies and shortcomings. It would be like opening a topic on C and the naysayers come out of the woodwork whining about how they made spaghetti code, tried to pass arguments that took too much stack space or how a runtime library function didn’t work and their code is always complete garbage. Then they tell us how interpretive BASIC is such a superior language and C should be banned. Meanwhile the rest are happily using C and “just don’t get it” with these people who hate C.\n\n>\n\n> Same thing here. For the benefit of the reader I would like to provide some balance to say there absolutely are plenty of us who use c++ happily in the kernel as our greatest asset. It makes for simpler, cleaner, more elegant code, quicker product cycles, higher quality. Yes the grass really is greener for us. It’s actually a good thing there are all these people that can’t use it right and advertise their deficiencies here. It gives the others a competitive edge to lock in more customers and higher margins.\n\n>\n\n> And I would wager the people that hate c++ haven’t the slightest idea what is in c++17 or c++20 but they still hate it anyway, every single bit of it. Weird people who the rest of us can easily see are painting with too wide a brush.\n\n>\n\n>\n\n> —\n\n> NTDEV is sponsored by OSR\n\n>\n\n> Visit the list online at: http:\n\n>\n\n> MONTHLY seminars on crash dump analysis, WDF, Windows internals and software drivers!\n\n> Details at http:\n\n>\n\n> To unsubscribe, visit the List Server section of OSR Online at http:</http:></http:></http:>\n\n?natural? to whom? To you?\n\nLet me know what you think can be better done in C++ than any other language and I?ll give you an immediate counter example. I guarantee it.\n\nIts isn?t that C++ is bad, it is just that it is a neither nor language and the runtime support which would seem to be a good reason to choose the language is not even specific to the language itself ? but happens to be written in it\n\nSent from Mailhttps: for Windows 10\n\n________________________________\n\nFrom: xxxxx@lists.osr.com on behalf of xxxxx@probo.com\n\nSent: Friday, July 6, 2018 9:06:16 PM\n\nTo: Windows System Software Devs Interest List\n\nSubject: Re: [ntdev] Modern C++ Features in Kernel Mode Drivers\n\nxxxxx@gmail.com wrote:\n\n>\n\n> It is tempting to think C++ can provide you some advantage in the\n\n> kernel, and I have tried to use it. It ends up being a total mess.\n\n> I’ve come to the conclusion that if you think yo need C++ in your\n\n> driver, maybe you need to rethink your design.\n\nThat’s just religious nonsense. If you’re not a C++ coder most of the\n\ntime, then of course you’re going to fail when you try to wedge it into\n\na kernel driver.\n\nC++ just lets one express many concepts in a simpler, more natural, and\n\nless error-prone way than C does. It’s not about “needing” C++. It’s\n\nabout using a language that allows me to express myself more naturally.\n\n> In fact, I end up turning off some of the more nagging defaults in\n\n> Visual C++ when doing kernel work because I like being able to\n\n> initialize a structure when it is instantiated:\n\n>\n\n> LARGE_INTEGER x = { .QuadPart = 1000000 };\n\n>\n\n> to me is better than\n\n>\n\n> LARGE_INTEGER x;\n\n> x.QuadPart = 1000000;\n\n>\n\n> The former is not allowed in C++\n\nWell, with Visual C++, it hasn’t been allowed in C for very long. This\n\ngcc extension was adopted into the C99 standard, but Visual C++ still\n\nonly implements a few parts of C99. Designated initializers only\n\narrived in VS 2013.\n\n–\n\nTim Roberts, xxxxx@probo.com\n\nProvidenza & Boekelheide, Inc.\n\n—\n\nNTDEV is sponsored by OSR\n\nVisit the list online at: http:\n\nMONTHLY seminars on crash dump analysis, WDF, Windows internals and software drivers!\n\nDetails at http:\n\nTo unsubscribe, visit the List Server section of OSR Online at http:</http:></http:></http:></https:>\n\n>> That’s just religious nonsense.\n\nNo it is not.\n\nI started writing C++ code back in Borland C++ under DOS, so it has nothing\n\nto do with knowing C++, the standards, or how the language works, and I’ve\n\ndone my share of Windows C++ in user-mode. C++ is OK for large projects\n\nwhere abstraction can shine. In the kernel, not so much.\n\nIt’s about the right tool for the job, and i’ve found using C++ in the\n\nkernel much like watchmaking with a sledgehammer. Maybe when Microsoft\n\nships a WDK with classes around the common kernel features like lists,\n\ngeneric tables, &c., i’ll have another look, but until then, i’ll stick to\n\nC in the kernel.\n\nOn Fri, Jul 6, 2018 at 9:19 PM xxxxx@hotmail.com\n\nwrote:\n\n> ‘natural’ to whom? To you?\n\n>\n\n>\n\n>\n\n> Let me know what you think can be better done in C++ than any other\n\n> language and I’ll give you an immediate counter example. I guarantee it.\n\n>\n\n>\n\n>\n\n> Its isn’t that C++ is bad, it is just that it is a neither nor language\n\n> and the runtime support which would seem to be a good reason to choose the\n\n> language is not even specific to the language itself – but happens to be\n\n> written in it\n\n>\n\n>\n\n>\n\n> Sent from Mail https: for\n\n> Windows 10\n\n>\n\n>\n\n> ------------------------------\n\n> From: xxxxx@lists.osr.com <\n\n> xxxxx@lists.osr.com> on behalf of xxxxx@probo.com <\n\n> xxxxx@lists.osr.com>\n\n> Sent: Friday, July 6, 2018 9:06:16 PM\n\n> To: Windows System Software Devs Interest List\n\n> Subject: Re: [ntdev] Modern C++ Features in Kernel Mode Drivers\n\n>\n\n> xxxxx@gmail.com wrote:\n\n> >\n\n> > It is tempting to think C++ can provide you some advantage in the\n\n> > kernel, and I have tried to use it. It ends up being a total mess.\n\n> > I’ve come to the conclusion that if you think yo need C++ in your\n\n> > driver, maybe you need to rethink your design.\n\n>\n\n> That’s just religious nonsense. If you’re not a C++ coder most of the\n\n> time, then of course you’re going to fail when you try to wedge it into\n\n> a kernel driver.\n\n>\n\n> C++ just lets one express many concepts in a simpler, more natural, and\n\n> less error-prone way than C does. It’s not about “needing” C++. It’s\n\n> about using a language that allows me to express myself more naturally.\n\n>\n\n>\n\n> > In fact, I end up turning off some of the more nagging defaults in\n\n> > Visual C++ when doing kernel work because I like being able to\n\n> > initialize a structure when it is instantiated:\n\n> >\n\n> > LARGE_INTEGER x = { .QuadPart = 1000000 };\n\n> >\n\n> > to me is better than\n\n> >\n\n> > LARGE_INTEGER x;\n\n> > x.QuadPart = 1000000;\n\n> >\n\n> > The former is not allowed in C++\n\n>\n\n> Well, with Visual C++, it hasn’t been allowed in C for very long. This\n\n> gcc extension was adopted into the C99 standard, but Visual C++ still\n\n> only implements a few parts of C99. Designated initializers only\n\n> arrived in VS 2013.\n\n>\n\n> –\n\n> Tim Roberts, xxxxx@probo.com\n\n> Providenza & Boekelheide, Inc.\n\n>\n\n>\n\n> —\n\n> NTDEV is sponsored by OSR\n\n>\n\n> Visit the list online at: <\n\n> http://www.osronline.com/showlists.cfm?list=ntdev&gt;\n\n>\n\n> MONTHLY seminars on crash dump analysis, WDF, Windows internals and\n\n> software drivers!\n\n> Details at http:\n\n>\n\n> To unsubscribe, visit the List Server section of OSR Online at <\n\n> http://www.osronline.com/page.cfm?name=ListServer&gt;\n\n>\n\n> —\n\n> NTDEV is sponsored by OSR\n\n>\n\n> Visit the list online at: <\n\n> http://www.osronline.com/showlists.cfm?list=ntdev&gt;\n\n>\n\n> MONTHLY seminars on crash dump analysis, WDF, Windows internals and\n\n> software drivers!\n\n> Details at http:\n\n>\n\n> To unsubscribe, visit the List Server section of OSR Online at <\n\n> http://www.osronline.com/page.cfm?name=ListServer&gt;\n\n>\n\n–\n\nJamey Kirby\n\nDisrupting the establishment since 1964\n\nThis is a personal email account and as such, emails are not subject to\n\narchiving. Nothing else really matters.</http:></http:></https:>\n\nOn Fri, Jul 6, 2018 at 5:15 PM, xxxxx@gmail.com\n\nwrote:\n\n> It is tempting to think C++ can provide you some advantage in the kernel,\n\n> and I have tried to use it. It ends up being a total mess. I’ve come to the\n\n> conclusion that if you think yo need C++ in your driver, maybe you need to\n\n> rethink your design. Maybe one exception would be a file system, but I doubt\n\n> it. In fact, I end up turning off some of the more nagging defaults in\n\n> Visual C++ when doing kernel work because I like being able to initialize a\n\n> structure when it is instantiated:\n\n>\n\nI originally did not like C++. I am not sure I do yet, but I realize\n\nmore its purpose. Too many people attempt to immediately use, almost\n\nexclusively, heap memory. Modern language extensions make this a lot\n\nsafer but C++ is not Java or C#.\n\nTo me, it seems like C++ is best used as a language of “managed\n\nstructures.” You really want your class instances to be on the stack.\n\nYou can have all of the syntactic features of C++ with none of the\n\nmemory issues most people experience.\n\nIn this way C++ can be a very nice language, but admittedly a lot of\n\nthat is simply from the existence of namespaces and the ease of\n\nassociating code and data. Newer features like lambdas make C++\n\nelegant in the same way as scripting languages without the runtime\n\npenalty. The standard containers are also extremely useful.\n\nThere was a period of time where C++ developers were relying heavily\n\non C code and consequently wrote “C compiled with a C++ compiler.”\n\nThere was mostly no merit to this code using a C++ compiler, and when\n\nfeatures were used they tended to be used poorly. Now we are past that\n\npoint. Many C libraries have C++ bindings that provide class based\n\ninterfaces, etc.\n\n> LARGE_INTEGER x = { .QuadPart = 1000000 };\n\n>\n\n> to me is better than\n\n>\n\n> LARGE_INTEGER x;\n\n> x.QuadPart = 1000000;\n\n>\n\n> The former is not allowed in C++\n\n>\n\nThe only real C++ standard is GNU C++. Microsoft would do well to\n\nadopt most of its features.\n\nCheers,\n\nR0b0t1\n\nWe’re back to religious wars about C++ again, regardless of what Mr. Kirby wants to admit. It’s not about NEEDING C++… we COULD all write our operating systems and drivers in assembly language like Cutler did back in the 1970s. But it’s cumbersome, its difficult, and only a select few can do it with excellence and clarity.\n\nThe same is true about writing code in C in the 21st Century.\n\nLet’s start out with some established, unassailable, facts:\n\nAs an overall language, C++ is a massive, steaming, pile of shit. There were huge mistakes made when it was initially designed as “a better C” – The language as a whole is hideously complex and is famous for producing unreadable, unmaintainable, monstrosities.\n\n“Within C++ is a smaller, simpler, safer language struggling to get out” as Bjarne what’s-his-name has famously said. This is described by the emerging CPP Core Guidelines.\n\n(As an aside, I personally don’t give two shits about “performance” in a language so long as it’s “good enough”… I stopped caring about this, at least relative to my other two points above, some time around the turn of the century. No, I don’t want to debate this.)\n\nFor the hundredth time on this list I’ll point you to the CPP Core Guidelines document: http:\n\nThis is some really good work and if you haven’t read it, you should. Now. Go read it. Now. Do it.\n\nI’m primarily interested in are two things:\n\n1) Making kernel-mode programming “safer” – less prone to bugs and errors, such as buffer overruns, use after free, and bad pointer arithmetic.\n\n2) Making kernel-mode programmer “easier” and “more clearly expressive of intent”\n\nThe Core Guidelines and the new features already in and coming to C++ make it a much better and safer language in which to program than C. They also make it a more EXPRESSIVE language in which to program.\n\nStrong type checking is an undeniably good thing. std::span and std::unique_ptr are undeniably good things.\n\nContracts, coming in C++ 20, are undeniably a good thing.\n\nenum classes, const, constexpr, are undeniably good things.\n\nAnd I just don’t see how you can be against the std:: library – As it says in the Core Guidelines “Using only the bare language, every task is tedious (in any language). Using a suitable library any task can be reasonably simple.”\n\nI don’t care if you love, hate, or even use an OO design pattern. What I care about are SAFETY and EXPRESSIVENESS.\n\nWe do NOT have to keep writing code like we were writing code in 1988, when they started work on Windows NT. We don’t write DRIVERS that way, right? We have WDF, right??\n\nSure… I’d love to see an entirely different language paradigm for driver development. Having actually WRITTEN multiple device drivers (and part of an I/O Subsystem) in C#, I would love to be able to use C# to write Windows drivers (as I’ve said before).\n\nBut that is NOT going to happen. We CAN use C++… or parts of it… because it’s inherently intertwined with our C-language heritage.\n\nWhat I’m arguing for is a more directed, purposeful, adoption of C++ as a kernel development language for Windows to get us all to writing safer drivers more easily.\n\nPeter\n\nOSR\n\n@OSRDrivers</http:>"
    }
}