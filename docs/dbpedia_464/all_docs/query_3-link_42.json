{
    "id": "dbpedia_464_3",
    "rank": 42,
    "data": {
        "url": "https://arstechnica.com/civis/threads/the-merits-of-mach-xnu.64335/",
        "read_more_link": "",
        "language": "en",
        "title": "The Merits of Mach/XNU",
        "top_image": "https://cdn.arstechnica.net/civis/styles/ars/ars/ars-icon.png",
        "meta_img": "https://cdn.arstechnica.net/civis/styles/ars/ars/ars-icon.png",
        "images": [
            "https://cdn.arstechnica.net/civis/styles/ars/ars/ars-open-forum.svg",
            "https://cdn.arstechnica.net/civis/styles/ars/ars/ars-open-forum.svg",
            "https://cdn.arstechnica.net/civis/data/avatars/s/18/18158.jpg?1668056570",
            "https://cdn.arstechnica.net/civis/data/avatars/s/18/18158.jpg?1668056570",
            "https://cdn.arstechnica.net/civis/data/avatars/s/18/18158.jpg?1668056570",
            "https://cdn.arstechnica.net/civis/data/avatars/s/18/18158.jpg?1668056570"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "HobbesianTiger"
        ],
        "publish_date": "2009-02-13T15:53:15+00:00",
        "summary": "",
        "meta_description": "Hi All,I was reading a post on rixstep a couple of days ago, and the gist of it was the following:\"Why is Apple insisting on using a hybrid kernel of it's...",
        "meta_lang": "",
        "meta_favicon": "https://cdn.arstechnica.net/civis/styles/ars/ars/ars-icon.png",
        "meta_site_name": "Ars OpenForum",
        "canonical_link": "https://arstechnica.com/civis/threads/the-merits-of-mach-xnu.64335/",
        "text": "Hi All,<BR><BR>I was reading a post on rixstep a couple of days ago, and the gist of it was the following:<BR>\"Why is Apple insisting on using a hybrid kernel of it's own design by mushing together Mach and FreeBSD, instead of using the FreeBSD kernel directly?\"<BR><BR>His essential argument is that the FreeBSD kernel already rocks, is fast, keeps getting faster, is well maintained by a group of dedicated specialists. Why keep the FreeBSD userland, but not the kernel? Apple should simply focus on the Cocoa frameworks and application environments and build them atop of FreeBSD and have their kernel team become dedicated FreeBSD contributors.<BR><BR>So my question is - what are the technical merits of using the XNU kernel vs FreeBSD?<BR><BR>P.S - I am aware of the arguments on the monolithic vs micro-kernel front - and am in general a supporter of the micro kernel design. XNU is not a true micro kernel so this seems to be a moot point.\n\nThe FreeBSD people would likely give a list of technical arguments. I am not interested in convincing or asking Apple to switch to pure FreeBSD, what I am interested in is determining what the <B>technical</B> merits of XNU are as opposed to FreeBSD.<BR><BR>It is possible that they chose to use XNU simply to carry over as much code from NeXT as possible, but I suspect this is not the only reason.<BR><BR>So feel free to be facetious, but I am hoping to get some serious answers.\n\n<BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">Originally posted by HobbesianTiger:<BR>P.S - I am aware of the arguments on the monolithic vs micro-kernel front - and am in general a supporter of the micro kernel design. XNU is not a true micro kernel so this seems to be a moot point. </div></BLOCKQUOTE><BR><BR>Microkernels are a dead-end for general-purpose operating systems.<BR><BR>There's a very good reason why every successful general-purpose operating system in the 21st century is built on a hybrid or monolithic design. It isn't because Culter, Tevanian, de Raadt, Torvalds and the rest are retards that are too blind to see the heavenly light of the microkernel. It's because \"all-inclusive\" is the only kernel design that works on a scale that's needed for modern desktop and server operating systems.<BR><BR>Not that this really matters, anyhow... FreeBSD is as monolithic as XNU.\n\n<BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">Originally posted by HobbesianTiger:<BR>So my question is - what are the technical merits of using the XNU kernel vs FreeBSD? </div></BLOCKQUOTE>They have nothing to do with Mach, let's leave it at that. <BR><BR>OS X is a Mach-hybrid because OS X is NeXTStep, and NEXTStep has always? used Mach. That's really all there is to it: technology really has passingly little to do with it at the end of the day. At this point, XNU is functional in its own right, and simple investment + inertia is enough to keep it there. When the decision was first made, I'm sure you could come up with technical arguments, but you could easily make strong ones either way. <BR><BR>As I've said before, really, when you get right down to it, Mach was a stunning failure in OS design, it really did nothing new, and it never succeeded at doing anything interesting. People get offended by this for reasons I've never fully understood, but that's really reality.<BR><BR>Some much more recent offshoots of Mach have done some interesting stuff, but that stuff isn't enough to make them useful for a general-purpose operating system.\n\n<blockquote class=\"ip-ubbcode-quote\">\n\n<div class=\"ip-ubbcode-quote-title\">quote:</div>\n\n<div class=\"ip-ubbcode-quote-content\">Originally posted by Graham Perks:<br>Why don't the FreeBSD guys adopt Mach and start contributing to Darwin? </div>\n\n</blockquote> They considered it, but when they asked to be educated about the merits, all they got was guff. -- View image here: http://episteme.arstechnica.com/groupee_common/emoticons/icon_razz.gif -- <br><blockquote class=\"ip-ubbcode-quote\">\n\n<div class=\"ip-ubbcode-quote-title\">quote:</div>\n\n<div class=\"ip-ubbcode-quote-content\">Apple bought next for $400M+, so they'd better have got some use out of it. </div>\n\n</blockquote> XNU is architecturally similar to the NeXT kernel, but all the parts were replaced.<br><blockquote class=\"ip-ubbcode-quote\">\n\n<div class=\"ip-ubbcode-quote-title\">quote:</div>\n\n<div class=\"ip-ubbcode-quote-content\">So... my question would be, why did Apple include *anything* from FreeBSD at all? </div>\n\n</blockquote> Modernizing NeXT's version of 4.3BSD would have been more work than adapting another kernel. Apple is allergic to copyleft. None of the other BSDs have priorities similar to Apple's.<br><br><br><br><blockquote class=\"ip-ubbcode-quote\">\n\n<div class=\"ip-ubbcode-quote-title\">quote:</div>\n\n<div class=\"ip-ubbcode-quote-content\">Originally posted by orbadelic:<br>As a cursory insight, Jordan Hubbard was a core member of the FreeBSD Project and he was hired by Apple to be the engineering director of UNIX technologies when the whole OS X thing was starting... </div>\n\n</blockquote> Hubbard joined Apple after 10.0. He wasn't responsible for the use of Mach or FreeBSD.\n\n<BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">Originally posted by LordHunter317:<BR>OS X is a Mach-hybrid because OS X is NeXTStep, and NEXTStep has always? used Mach. That's really all there is to it: technology really has passingly little to do with it at the end of the day. </div></BLOCKQUOTE><BR><BR>Over the years I've picked up hints here and there that the Window Server (either NeXT or OS X version, take your pick) is designed around Mach VM. It apparently uses Mach memory objects to map graphics buffers and move them between processes and the kernel with low overhead. (And furthermore, Apple's Mach VM and Window Server have been extensively performance tuned for each other.)<BR><BR>Could they port their Window Server to some other kernel's VM? No doubt it's technically possible, but as you mentioned, there's inertia, and I just wanted to point out what might be a key part of that inertia for Apple.\n\n<BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">Originally posted by tim_s:<BR>Over the years I've picked up hints here and there that the Window Server (either NeXT or OS X version, take your pick) is designed around Mach VM. It apparently uses Mach memory objects to map graphics buffers and move them between processes and the kernel with low overhead. (And furthermore, Apple's Mach VM and Window Server have been extensively performance tuned for each other.) </div></BLOCKQUOTE>This may be true, I really know very little about the NextSTEP end of things, because well, I just don't care. If so, it's an obvious technical justification. <BR><BR>However, even if that weren't true, I suspect things would still be the way they are, simply because rebirthing NExtSTEP is clearly what was desired.\n\nI doubt there was any real technical merit to picking mach. It was there, it worked, and Apple had to get OSX off the ground quickly. I'm not sure there was any other choice. I think overall the choice has turned out well. Eventually mach may get replaced but for the time being it's very stable and flexible for different types of devices. Performance is less of an issue these days when the average computer is dual & quad core now with a boat load of memory.\n\nmach is from '85.<BR><BR><BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">the L4 kernel includes only seven functions and uses 12k of memory, whereas Mach 3 includes about 140 functions and uses about 330k of memory. IPC calls under L4 on a 486DX-50 take only 5 Î¼s, faster than a UNIX syscall on the same system, and over 20 times as fast as Mach. Of course this ignores the fact that L4 is not handling permissioning or security, but by leaving this to the user-space programs, they can select as much or as little overhead as they require.<BR><BR>The potential performance gains of L4 are tempered by the fact that the user-space applications will often have to provide many of the functions formerly supported by the kernel. In order to test the end-to-end performance, MkLinux in co-located mode was compared with an L4 port running in user-space. L4 added about 5%-10% overhead, compared to Mach's 15%, all the more interesting considering the double context switches needed[citation needed]. </div></BLOCKQUOTE>\n\nCould someone tell me where the OSX kernel still falls flat? I thought with Leopard and then Snow Leopard Apple was doing some serious fixing of it and optimizations.<BR><BR>I knew that under Tiger some threading situations were less than ideal. (Although I also heard that some of the benchmarks weren't telling folks what they thought it was) But I've also heard that for some real time applications the kernel is very nice.<BR><BR>For those of us not up on kernel development why does this matter?\n\n<BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">HobbesianTiger<BR><BR>\n\nI was reading a post on rixstep a couple of days ago, and the gist of it was the following:<BR>\"Why is Apple insisting on using a hybrid kernel of it's own design by mushing together Mach and FreeBSD, instead of using the FreeBSD kernel directly?\" </div></BLOCKQUOTE><BR><BR>An interesting madman. I'm convinced he sometimes even writes stuff he knows can't be true because he can't keep his temper.<BR><BR>I'm not qualified to comment myself. All I can add to what's been said already is that I think the site-owner in question has said before that the combination of bits from here and there makes the OS more vulnerable. I think he's also said it means Apple can't always roll in a security patch when FreeBSD has one, so that sometimes it's a longer window of opportunity while Apple re-write what they did, besides wasted effort.<BR><BR>I recall Rixstep's citing what the ex-NSA hacker Charlie Miller had said about OS X in that regard, too. I don't know whether Miller has said much on that, and if he has, again I couldn't comment myself let alone disentangle whether he'd said what anyone else thought he'd said. But I just tried googling:<BR><BR>\"charlie miller\" \"os x\" freebsd<BR><BR>in case it found anything. I did get a link to a PDF from a talk Miller gave. There's a section called \"Mach Abuse\":<BR><BR>http://event.on24.com/event/12...f/128064_pres_v3.pdf<BR><BR>There may be some connection there.<BR><BR>Be that as it may, I'd guess that Lord Hunter is right \"investment + inertia is enough to keep it there\".\n\n<BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">Originally posted by ClarkGoble:<BR>Could someone tell me where the OSX kernel still falls flat? </div></BLOCKQUOTE>This often requires a long thread to get hammered out, but if you want the conclusion without the flames, the answer is \"performance suffers in areas Apple doesn't regard as a high priority\".<BR><BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">Originally posted by ClarkGoble:<BR>I thought with Leopard and then Snow Leopard Apple was doing some serious fixing of it and optimizations. </div></BLOCKQUOTE>There are for the purposes of this discussion two distinct classes of workload:<BR><BR>1. workloads where a number of cores need to go off and munch on something by themselves for a long time<BR><BR>2. workloads where threads and processes need to collaborate frequently, get created/destroyed frequently, do small I/O frequently, etc<BR><BR>OS X isn't very good at #2 compared to Windows/FreeBSD/Linux, but OS X's typical workloads don't suffer much from #2.<BR><BR>From information released about SL's improvements, they seem to be much more about making things easier for the developer trying to do #1 than they are about mitigating the issues related to #2.<BR><BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">Originally posted by ClarkGoble:<BR>For those of us not up on kernel development why does this matter? </div></BLOCKQUOTE>There's a good chance it doesn't. #2 can be broadly classed as \"system heavy applications\", which is primarily a server thing.\n\n<BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">Originally posted by cp5184:<BR>anandtech did some sql benchmarks right before the intel transition. I always thought it would be interesting to see how the same tests would work on intel hardware. </div></BLOCKQUOTE>There was a great deal of quibbling over exactly what those benchmarks meant, but I find the individual microbenchmarks for fork() and so forth more interesting since there's less room for disk syncing semantics or whatever to creep in. Moreover, Linux won those on PowerPC-vs-PowerPC, and the 4/4 address space used by OS X on x86 isn't helpful on that platform so it's not a good start.<BR><BR>There seems to be less interest on driving this point lately. I think a lot of this has to do with the state of virtualization for other OSes, which can be summed up as \"very good, very widespread, and getting cheaper fast\". Conversely, if you've got a Mac server in an office full of Macs, you get benefits that have nothing to do with raw performance, and the performance for stuff like file serving never seemed particularly bad in the first place.<BR><BR>The case of an XServe doing the sorts of tasks that are seriously disadvantaged seems like it's a use case that would actually come about less and less these days.\n\nTwo small things to add to the general information in this thread.<BR><BR>Hubbard was a bit more than a core contributor to the FreeBSD project before leaving for Apple. Hubbard kept FreeBSD from languishing away and fading off into NetBSD numbers of platform installs by bringing an out of focus distro under control and getting people to trust the stability/consistency of the distrubution. Personally I never felt he got his due here for all the work he did back then because of the \"sexy lunix!\"<BR><BR>Mach *was* a good idea back when people were still having shouting matches over who would win, \"RISC or CISC\". People might not see it but I tend to think we can thank Mach and the general microkernel mindset for giving us things like LKMs and such. Before then portions of many OS kernels were not very compartmentalized at all.<BR><BR>(Side note, anyone know what ever became of VSTa?)\n\n<BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">Originally posted by katorga:<BR>Mach/XNU is a micro-kernel; compare it to Java. It adds a layer of abstraction between the BSD kernel and the hardware. </div></BLOCKQUOTE>No, this isn't what a microkernel like Mach does.<BR><BR>The goal of a microkernel is to reduce what ran in the lowest protection ring, where software is subject to the least amount of restrictions. To that end, microkernels forces drivers to use message-passing or some other form of IPC for communication with other drivers and the kernel.<BR><BR>This isn't an adding a layer of abstraction <I>per se</I> any more than the USB or PCI stacks in the Linux kernel added a layer of abstraction: it simply has a different form.<BR><BR>The problematic part is that switching between protection rings is slow on any CPU, and passing data between protection rings is slow. As such, most hybrids preserve the message-passing nature but run everything in the lowest protection ring.<BR><BR><BLOCKQUOTE class=\"ip-ubbcode-quote\"><div class=\"ip-ubbcode-quote-title\">quote:</div><div class=\"ip-ubbcode-quote-content\">Windows NT started out as a micro-kernel OS, as did NeXTstep. </div></BLOCKQUOTE>No, it was always a hybrid design, as is every just about every other mainstream \"microkernel\" OS that's ever existed. This includes everything that included Mach, because you can't make a meaningful OS out of Mach alone."
    }
}