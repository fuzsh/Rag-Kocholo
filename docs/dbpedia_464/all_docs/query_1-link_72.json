{
    "id": "dbpedia_464_1",
    "rank": 72,
    "data": {
        "url": "https://arstechnica.com/civis/threads/google-is-now-writing-low-level-android-code-in-rust.1475613/",
        "read_more_link": "",
        "language": "en",
        "title": "Google is now writing low-level Android code in Rust",
        "top_image": "https://cdn.arstechnica.net/civis/styles/ars/ars/ars-icon.png",
        "meta_img": "https://cdn.arstechnica.net/civis/styles/ars/ars/ars-icon.png",
        "images": [
            "https://cdn.arstechnica.net/civis/styles/ars/ars/ars-open-forum.svg",
            "https://cdn.arstechnica.net/civis/styles/ars/ars/ars-open-forum.svg",
            "https://cdn.arstechnica.net/civis/data/avatars/m/159/159028.jpg?1668194844",
            "https://cdn.arstechnica.net/civis/data/avatars/s/368/368871.jpg?1668451788",
            "https://cdn.arstechnica.net/civis/data/avatars/s/286/286363.jpg?1668879917",
            "https://cdn.arstechnica.net/civis/data/avatars/s/286/286363.jpg?1668879917",
            "https://cdn.arstechnica.net/civis/data/avatars/s/368/368871.jpg?1668451788",
            "https://cdn.arstechnica.net/civis/data/avatars/s/267/267250.jpg?1673465080",
            "https://cdn.arstechnica.net/civis/data/avatars/s/286/286363.jpg?1668879917",
            "https://cdn.arstechnica.net/civis/data/avatars/s/267/267250.jpg?1673465080",
            "https://cdn.arstechnica.net/civis/data/avatars/s/286/286363.jpg?1668879917"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "JournalBot"
        ],
        "publish_date": "2021-04-07T17:14:03+00:00",
        "summary": "",
        "meta_description": "Google's promotion of Rust over C and C++ should lead to fewer memory security bugs. \n\nRead the whole story",
        "meta_lang": "",
        "meta_favicon": "https://cdn.arstechnica.net/civis/styles/ars/ars/ars-icon.png",
        "meta_site_name": "Ars OpenForum",
        "canonical_link": "https://arstechnica.com/civis/threads/google-is-now-writing-low-level-android-code-in-rust.1475613/",
        "text": "Apr 7, 2021\n\nAdd bookmark\n\n#2\n\nThis is an exciting development being a former C++ coder. No more memory leaks or buffer overflows just sounds amazing. My biggest question is does C++ hold any advantages over Rust or does Rust simply maintain the same speed of execution with the added benefit of the memory protection?\n\nUpvote\n\n141 (148 / -7)\n\nPost content hidden for low score. Show…\n\nApr 7, 2021\n\nAdd bookmark\n\n#4\n\nWhat is the general consensus on rewriting time proven code? Doesn’t seem like a great idea to rewrite & inevitably introduce new vulnerabilities...\n\nUpvote\n\n69 (86 / -17)\n\nApr 7, 2021\n\nAdd bookmark\n\n#5\n\nThis is an exciting development being a former C++ coder. No more memory leaks or buffer overflows just sounds amazing. My biggest question is does C++ hold any advantages over Rust or does Rust simply maintain the same speed of execution with the added benefit of the memory protection?\n\nOption #2.\n\nThe way I've had it described to me is thus: If you're an average tennis player, you can serve a ball at 100 mph - given current racket technology, that's actually not difficult. However, most pros, using similar rackets, can serve at 130 mph.\n\nWhy? Pro practice, a lot, and as a result are more confident in being able to serve in the box. The confidence is the difference.\n\nThat's also the difference between Rust and C++. Rust's language features - while still very imperfect - allow even an average Rust user to use more performant techniques, that allow you to compete with the execution speed of C or C++, if not exceed them in certain cases. In C++ (as you well know), it's possible to crash your app and/or system in a few creative ways. In C, it's possible to brick your system outright.\n\nUpvote\n\n18 (64 / -46)\n\nApr 7, 2021\n\nAdd bookmark\n\n#6\n\nWhat is the general consensus on rewriting time proven code? Doesn’t seem like a great idea to rewrite & inevitably introduce new vulnerabilities...\n\nBetter use the resource to make formal proofs of those old libraries instead of refactoring.\n\nEdit: Formal proof also squash bugs and incorrect algorithm logic.\n\nUpvote\n\n20 (28 / -8)\n\nApr 7, 2021\n\nAdd bookmark\n\n#7\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nUpvote\n\n62 (65 / -3)\n\nApr 7, 2021\n\nAdd bookmark\n\n#8\n\nMy biggest question is does C++ hold any advantages over Rust or does Rust simply maintain the same speed of execution with the added benefit of the memory protection?\n\nThe catch is that it is considerable more difficult to write compilable rust code. The upside is that if it compiles, there are guarantees that you are safe from a lot of memory errors (because of the borrow checker).\n\nBut the borrow checker sometimes makes some low level operations very difficult to express in idiomatic rust. For that you can drop into unsafe rust, but that somewhat defeats the rationale of writing rust.\n\nDisclaimer: although I've studied the language, have very little experience with it.\n\nUpvote\n\n139 (142 / -3)\n\nApr 7, 2021\n\nAdd bookmark\n\n#9\n\nWhat is the general consensus on rewriting time proven code? Doesn’t seem like a great idea to rewrite & inevitably introduce new vulnerabilities...\n\nI hesitate to say anything about work at the level the article describes because I have no experience, but rewriting your code to gain incremental improvements/create new opportunities downstream is pretty normal for any office involved in it. Which includes many scientists now, particularly ones that are looking for data result repeatability across models of experimentation.\n\nAs long as your process doesn't involve everyone just pushing code to the live instance of your software it's relatively safe. Good QC (and even bad QC) is going to catch a lot of the problems before they can hit git, and even after that someone perusing the commits might notice (and correct) an issue.\n\nMy understanding, again I don't work at this level of dev, is that Rust provides significant -- frankly enormous -- advantages relative to C/C++ that major software development projects are looking to take advantage of. If spending a hundred hours converting from C++ to Rust saves you two hundred hours of addressing a memory leak, aren't you benefiting?\n\nUpvote\n\n30 (40 / -10)\n\nApr 7, 2021\n\nAdd bookmark\n\n#10\n\nI wonder if they are going to do the same with Fuschia, since the rumors seems to point that it will eventually replace Android and ChromeOS.\n\nUpvote\n\n25 (25 / 0)\n\nApr 7, 2021\n\nAdd bookmark\n\n#11\n\nWhat is the general consensus on rewriting time proven code? Doesn’t seem like a great idea to rewrite & inevitably introduce new vulnerabilities...\n\nThe code they've started rewriting is things like the bluetooth stack. This is not \"time proven code\". Unless by that you mean time has proven bluetooth to be a complete mess (especially on Android where, unlike Apple, Google do not control the hardware). Tbf that can in part be blamed on the spec and firmware (and hardware vendors whose open source contributions aren't great) but Android has to be able to abstract over that mess and provide something useable. Doing so in a memory safe language helps to ensure this mess is less likely to be vulnerable.\n\nIt of course doesn't solve all potential vulnerabilities but if you need to sort out the code anyway you may as well lower the attack surface area at the same time.\n\nUpvote\n\n89 (91 / -2)\n\nApr 7, 2021\n\nAdd bookmark\n\n#12\n\nWhat is the general consensus on rewriting time proven code? Doesn’t seem like a great idea to rewrite & inevitably introduce new vulnerabilities...\n\nDepends on the context.\n\nRewrites aren't necessarily a dirty word. As a program ages, it accumulates technical debt for a wide variety of human reasons. Bear in mind that the Android system is now roughly a decade old - in computer terms, that basically qualifies a reading of Android code as an archaeology project.\n\nSo, let's reframe your question a bit. \"What are the conditions where a rewrite becomes more beneficial than periodic maintenance?\"\n\nLanguage evolution. As programming languages evolve, they become able to do things in more human-readable ways. Remember: We write code for humans, not computers! Humans have to be capable of maintaining code.\n\nLack of updates. Ideally, code should remain stable. However, there's a fundamental mismatch - the world our code exists in is constantly evolving in its own right. Code that doesn't get updated gets harder and harder to reconcile with reality with each passing day. This does kind of feed into the first point, but is also tied to the realities of software development - my bosses constantly pull me and my team to new projects, or new retrofits, or whatever. We don't always have time or money to go back and upgrade this framework or that codebase.\n\nGame-changing paradigms. I'd argue this is what Rust falls into. Rust is basically built on the idea of undoing the \"Billion-dollar Mistake\", which is basically the existence of the null pointer, which has provably caused much more trouble than it was worth. Once again, this also feeds into the first point - by changing the perspective of how you code, you discover better, more holistic expressions of the solutions to the problem domain you're coding against.\n\nThat's not an exhaustive list, and our field is very much a young field. That's merely what I'm going with for the moment. My mind can be changed.\n\nUpvote\n\n120 (126 / -6)\n\nApr 7, 2021\n\nAdd bookmark\n\n#13\n\nThis is an exciting development being a former C++ coder. No more memory leaks or buffer overflows just sounds amazing. My biggest question is does C++ hold any advantages over Rust or does Rust simply maintain the same speed of execution with the added benefit of the memory protection?\n\nRust is on par with C and C++ when it comes to performance. Memory is \"managed\" at compile time by the compiler and the program is provably memory safe when it compiles successfully.\n\nThis removes the need for overhead such as garbage collection or reference counting (though Rust has the option to use ref-counting when necessary - you can't always know when something should be dropped beforehand)\n\nUpvote\n\n70 (73 / -3)\n\nPost content hidden for low score. Show…\n\nApr 7, 2021\n\nAdd bookmark\n\n#15\n\nWhat is the general consensus on rewriting time proven code? Doesn’t seem like a great idea to rewrite & inevitably introduce new vulnerabilities...\n\nAlso, right now, as the article states, they are using rust for new code, not actively rewriting what is older code, that has already been looked at by many attackers eyes and fixed.\n\nUpvote\n\n53 (53 / 0)\n\nApr 7, 2021\n\nAdd bookmark\n\n#16\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nGoogle has Go, but it has a different memory-safe model than Rust. Rust is more about proving you're using allocations and pointers safely, Go is about making it so you don't have to care.... but that has different run-time characteristics. Go is already heavily used at Google but you'd never know it, because you don't see the man behind the curtain.\n\nUpvote\n\n90 (91 / -1)\n\nApr 7, 2021\n\nAdd bookmark\n\n#17\n\nWhat is the general consensus on rewriting time proven code? Doesn’t seem like a great idea to rewrite & inevitably introduce new vulnerabilities...\n\nI hesitate to say anything about work at the level the article describes because I have no experience, but rewriting your code to gain incremental improvements/create new opportunities downstream is pretty normal for any office involved in it. Which includes many scientists now, particularly ones that are looking for data result repeatability across models of experimentation.\n\nAs long as your process doesn't involve everyone just pushing code to the live instance of your software it's relatively safe. Good QC (and even bad QC) is going to catch a lot of the problems before they can hit git, and even after that someone perusing the commits might notice (and correct) an issue.\n\nMy understanding, again I don't work at this level of dev, is that Rust provides significant -- frankly enormous -- advantages relative to C/C++ that major software development projects are looking to take advantage of. If spending a hundred hours converting from C++ to Rust saves you two hundred hours of addressing a memory leak, aren't you benefiting?\n\nGoogle wouldn't know anything about re-writing code. They just dump one codebase and launch a whole new initiative every couple years.\n\nThat's a pretty funny joke generally, but even funnier in the context of a project they've been maintaining for 10+ years.\n\nUpvote\n\n70 (71 / -1)\n\nApr 7, 2021\n\nAdd bookmark\n\n#18\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nGoogle has Go, but it has a different memory-safe model than Rust. Rust is more about proving you're using allocations and pointers safely, Go is about making it so you don't have to care.... but that has different run-time characteristics. Go is already heavily used at Google but you'd never know it, because you don't see the man behind the curtain.\n\nI knew that Go had plenty of uptake in the broader Googleplex. I'd be curious to hear the Android team's justification re: Rust vs. Go. I know there are certain limitations with Go that could preclude replication of the functions that exist in Android currently, but...again, way out of my depth.\n\nUpvote\n\n21 (23 / -2)\n\nApr 7, 2021\n\nAdd bookmark\n\n#19\n\nMy biggest question is does C++ hold any advantages over Rust or does Rust simply maintain the same speed of execution with the added benefit of the memory protection?\n\nThe catch is that it is considerable more difficult to write compilable rust code. The upside is that if it compiles, there are guarantees that you are safe from a lot of memory errors (because of the borrow checker).\n\nBut the borrow checker sometimes makes some low level operations very difficult to express in idiomatic rust. For that you can drop into unsafe rust, but that somewhat defeats the rationale of writing rust.\n\nDisclaimer: although I've studied the language, have very little experience with it.\n\nYou get used to the borrow checker fairly quickly. I rarely butt heads with it anymore and while it's true that some things that are really simple in other languages can be nigh on impossible in Rust (like a self-referencing struct or a tree with back-references) there almost always exists a workaround (like typed_arena).\n\nUpvote\n\n45 (46 / -1)\n\nApr 7, 2021\n\nAdd bookmark\n\n#20\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nGoogle has Go, but it has a different memory-safe model than Rust. Rust is more about proving you're using allocations and pointers safely, Go is about making it so you don't have to care.... but that has different run-time characteristics. Go is already heavily used at Google but you'd never know it, because you don't see the man behind the curtain.\n\nI used Go for a bit at my previous job...I hated it. It feels like a language designed to make it easier to write compilers without much concern for how that impacts writing code with the language.\n\nUpvote\n\n24 (32 / -8)\n\nApr 7, 2021\n\nAdd bookmark\n\n#21\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nGoogle has Go, but it has a different memory-safe model than Rust. Rust is more about proving you're using allocations and pointers safely, Go is about making it so you don't have to care.... but that has different run-time characteristics. Go is already heavily used at Google but you'd never know it, because you don't see the man behind the curtain.\n\nI knew that Go had plenty of uptake in the broader Googleplex. I'd be curious to hear the Android team's justification re: Rust vs. Go. I know there are certain limitations with Go that could preclude replication of the functions that exist in Android currently, but...again, way out of my depth.\n\nIf you're putting Go in a kernel, you're going to have to support go-routines, channels, garbage collection etc. All of those have their own runtime cost, and some of them can't be run in places where a kernel can be required (few resources - no ability to allocate memory, limited stack....), so you're limiting the scope of where Go can apply. Rust doesn't really change the memory model per se; it forces all the checking done up front where it can before anything is run.\n\nUpvote\n\n84 (84 / 0)\n\nApr 7, 2021\n\nAdd bookmark\n\n#22\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nGoogle has Go, but it has a different memory-safe model than Rust. Rust is more about proving you're using allocations and pointers safely, Go is about making it so you don't have to care.... but that has different run-time characteristics. Go is already heavily used at Google but you'd never know it, because you don't see the man behind the curtain.\n\nI knew that Go had plenty of uptake in the broader Googleplex. I'd be curious to hear the Android team's justification re: Rust vs. Go. I know there are certain limitations with Go that could preclude replication of the functions that exist in Android currently, but...again, way out of my depth.\n\nIf I were to make a gross caricature :\n\nGo is made so that the average programmer writes decent application / high level system code.\n\nRust is a different beast, a modern C++ that is quite exacting on the programmer but that, thanks to its zero costs abstractions and unsafe escape hatch, is suitable even for low level system and embedded software, in addition to fearless concurrent code.\n\nUpvote\n\n74 (77 / -3)\n\nApr 7, 2021\n\nAdd bookmark\n\n#23\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nGoogle has Go, but it has a different memory-safe model than Rust. Rust is more about proving you're using allocations and pointers safely, Go is about making it so you don't have to care.... but that has different run-time characteristics. Go is already heavily used at Google but you'd never know it, because you don't see the man behind the curtain.\n\nI knew that Go had plenty of uptake in the broader Googleplex. I'd be curious to hear the Android team's justification re: Rust vs. Go. I know there are certain limitations with Go that could preclude replication of the functions that exist in Android currently, but...again, way out of my depth.\n\nIf you're putting Go in a kernel, you're going to have to support go-routines, channels, garbage collection etc. All of those have their own runtime cost, and some of them can't be run in places where a kernel can be required (few resources - no ability to allocate memory, limited stack....), so you're limiting the scope of where Go can apply. Rust doesn't really change the memory model per se; it forces all the checking done up front where it can before anything is run.\n\nThanks. That makes sense. I'm sure their calculus was similarly justified.\n\nUpvote\n\n18 (19 / -1)\n\nApr 7, 2021\n\nAdd bookmark\n\n#24\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nAs others have mentioned Google's language is Go. From what I have heard Google tends to use go to write network applications and web services. Google likely would not use Go in this context because of the overhead imposed by its runtime, particularly the garbage collector.\n\nUpvote\n\n39 (40 / -1)\n\nApr 7, 2021\n\nAdd bookmark\n\n#25\n\nMy biggest question is does C++ hold any advantages over Rust or does Rust simply maintain the same speed of execution with the added benefit of the memory protection?\n\nThe catch is that it is considerable more difficult to write compilable rust code. The upside is that if it compiles, there are guarantees that you are safe from a lot of memory errors (because of the borrow checker).\n\nBut the borrow checker sometimes makes some low level operations very difficult to express in idiomatic rust. For that you can drop into unsafe rust, but that somewhat defeats the rationale of writing rust.\n\nDisclaimer: although I've studied the language, have very little experience with it.\n\nI've not used rust, but I'd hope that only very little code genuinely needs to be 'unsafe', and that unsafe code in rust has some explicit syntax calling it out as such, so it is very easily spotted in code reviews and pull requests, and so both has to be justified and gets a lot more scrutiny.\n\nUpvote\n\n20 (22 / -2)\n\nApr 7, 2021\n\nAdd bookmark\n\n#26\n\nWhile I see the benefit in many Rust features, as a C++ developer on a complex state-of-art AR-map project I must say that with modern C++ (17 in our case) it is not hard to write very stable applications anymore on memory management front. Using smart pointers and reference counting fixes most issues. The remaining null pointer issues are not unique to C++, and in same cases they cannot be eliminated (I mean if something does not exist all the time it must be null, or empty whatever).\n\nThat does not mean Rust is of no use for other things. But in general I feel there is a factor of bad memories about badly written old C++ codebases in Rust's success. These old projects tended to use raw pointers a lot and had issues quite frequently as memory was not allocated / deallocated properly. Smart pointers, STL containers and other new features eliminated the need to use new and delete in normal code. These features eliminated most of the mistakes a programmer can make, they ensure freeing up members when destroying objects and even free memory during exception handling properly.\n\nNow if someone could make a language which prevents writing spaghetti code and enforce proper architecture practices that would be great. AI tools might help that in the future.\n\nUpvote\n\n55 (63 / -8)\n\nApr 7, 2021\n\nAdd bookmark\n\n#27\n\nMy biggest question is does C++ hold any advantages over Rust or does Rust simply maintain the same speed of execution with the added benefit of the memory protection?\n\nThe catch is that it is considerable more difficult to write compilable rust code. The upside is that if it compiles, there are guarantees that you are safe from a lot of memory errors (because of the borrow checker).\n\nBut the borrow checker sometimes makes some low level operations very difficult to express in idiomatic rust. For that you can drop into unsafe rust, but that somewhat defeats the rationale of writing rust.\n\nDisclaimer: although I've studied the language, have very little experience with it.\n\nYou get used to the borrow checker fairly quickly. I rarely butt heads with it anymore and while it's true that some things that are really simple in other languages can be nigh on impossible in Rust (like a self-referencing struct or a tree with back-references) there almost always exists a workaround (like typed_arena).\n\nOr linked lists.\n\nUpvote\n\n19 (19 / 0)\n\nApr 7, 2021\n\nAdd bookmark\n\n#28\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nGoogle has Go, but it has a different memory-safe model than Rust. Rust is more about proving you're using allocations and pointers safely, Go is about making it so you don't have to care.... but that has different run-time characteristics. Go is already heavily used at Google but you'd never know it, because you don't see the man behind the curtain.\n\nI knew that Go had plenty of uptake in the broader Googleplex. I'd be curious to hear the Android team's justification re: Rust vs. Go. I know there are certain limitations with Go that could preclude replication of the functions that exist in Android currently, but...again, way out of my depth.\n\nGo is still a automatic memory-managed language, meaning it has a garbage collector, so it can't be \"at the bottom of the stack\" running on the bare hardware memory model. Rust doesn't need that, so it can be \"at the bottom of the implementation stack\", and you need some language at the base like that to write everything else in. For example, you could write the Go garbage collector or the Java VM in Rust, but you couldn't write them in Java or Go without causing infinite regress; you need some language without a garbage collector at the bottom to prevent that. edit: So Rust is considered a true \"systems programming\" language, whereas Java is not and Go occupies a kind of intermediate spot where it is \"more like\" a systems programming language but still needs a garbage collector.\n\nUpvote\n\n29 (33 / -4)\n\nApr 7, 2021\n\nAdd bookmark\n\n#29\n\nWhile I see the benefit, as a C++ developer on a complex state-of-art AR-map project I must say that with modern C++ (17 in our case) it is not hard to write very stable applications anymore. Using smart pointers and reference counting fixes most issues. The remaining null pointer issues are not unique to C++, and in same cases they cannot be eliminated (I mean if something does not exist all the time it must be null, or empty whatever).\n\nThat does not mean Rust is of no use. But in general I feel there is a factor of bad memories about badly written old C++ codebases in Rust's success. These old projects tended to use raw pointers a lot and had issues quite frequently as memory was not allocated / deallocated properly. Smart pointers, STL containers and other new features eliminated the need to use new and delete in normal code. These features eliminated most of the mistakes a programmer can make, they ensure freeing up members, and even free memory during exception handling properly.\n\nNow if someone could make a language which prevents writing spaghetti code and enforce proper architecture practices that would be great. AI tools might help that in the future.\n\nAll those C++ library features that provide improved safety have to go out the window in the kernel for the same reasons Go in a kernel has problems - they have runtime requirements. Any time a kernel allows C++ such as Apple's XNU/Darwin kernel allows, it's a very carefully managed subset for that reason.\n\nUpvote\n\n8 (25 / -17)\n\nApr 7, 2021\n\nAdd bookmark\n\n#30\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nGoogle has Go, but it has a different memory-safe model than Rust. Rust is more about proving you're using allocations and pointers safely, Go is about making it so you don't have to care.... but that has different run-time characteristics. Go is already heavily used at Google but you'd never know it, because you don't see the man behind the curtain.\n\nI used Go for a bit at my previous job...I hated it. It feels like a language designed to make it easier to write compilers without much concern for how that impacts writing code with the language.\n\nThat's fair. For a different perspective, I use c++ at my current job and would absolutely jump at the opportunity to pull in rust instead. I write it at home and it's just something I vastly prefer. The build system is great, the performance is amazing, and I have yet to have a segfault.\n\nUpvote\n\n16 (20 / -4)\n\nApr 7, 2021\n\nAdd bookmark\n\n#31\n\nMy biggest question is does C++ hold any advantages over Rust or does Rust simply maintain the same speed of execution with the added benefit of the memory protection?\n\nThe catch is that it is considerable more difficult to write compilable rust code. The upside is that if it compiles, there are guarantees that you are safe from a lot of memory errors (because of the borrow checker).\n\nBut the borrow checker sometimes makes some low level operations very difficult to express in idiomatic rust. For that you can drop into unsafe rust, but that somewhat defeats the rationale of writing rust.\n\nDisclaimer: although I've studied the language, have very little experience with it.\n\nI've not used rust, but I'd hope that only very little code genuinely needs to be 'unsafe', and that unsafe code in rust has some explicit syntax calling it out as such, so it is very easily spotted in code reviews and pull requests, and so both has to be justified and gets a lot more scrutiny.\n\nUnsafe rust requires using the keyword unsafe, and its use is usually limited to the bare minimum. However be aware that usually for a module including unsafe to be sound, it often requires correctness on the algorithmic level of the remainder of the module (that hopefully is designed so as to expose a safe primitive).\n\nUpvote\n\n21 (21 / 0)\n\nApr 7, 2021\n\nAdd bookmark\n\n#32\n\nSo...I get that Rust is a pretty ideal language/compiler for this kind of work. Designed as such from the ground up.\n\nBut didn't Google have a project to create their own similarly robust language/compiler for this kind of work?\n\nGoogle has Go, but it has a different memory-safe model than Rust. Rust is more about proving you're using allocations and pointers safely, Go is about making it so you don't have to care.... but that has different run-time characteristics. Go is already heavily used at Google but you'd never know it, because you don't see the man behind the curtain.\n\nI knew that Go had plenty of uptake in the broader Googleplex. I'd be curious to hear the Android team's justification re: Rust vs. Go. I know there are certain limitations with Go that could preclude replication of the functions that exist in Android currently, but...again, way out of my depth.\n\nGo is still a automatic memory-managed language, meaning it has a garbage collector, so it can't be \"at the bottom of the stack\" running on the bare hardware memory model. Rust doesn't need that, so it can be \"at the bottom of the implementation stack\", and you need some language at the base like that to write everything else in. For example, you could write the Go garbage collector or the Java VM in Rust, but you couldn't write them in Java or Go without causing infinite regress; you need some language without a garbage collector at the bottom to prevent that. edit: So Rust is considered a true \"systems programming\" language, whereas Java is not and Go occupies a kind of intermediate spot where it is \"more like\" a systems programming language but still needs a garbage collector.\n\nI might be wrong but I don't think there's any reason you can't write a fully self-hosted Java runtime in Java, or a fully self-hosted Go implementation in Go, including implementing their respective garbage collectors.\n\nThe reasons not to are mainly performance and that there's no reason to re-invent the wheel.\n\nI'm very willing to accept I'm wrong though! Is there an article I can read about it?\n\nUpvote\n\n0 (8 / -8)\n\nApr 7, 2021\n\nAdd bookmark\n\n#33\n\nThe remaining null pointer issues are not unique to C++, and in same cases they cannot be eliminated (I mean if something does not exist all the time it must be null, or empty whatever).\n\nIt can be a `Maybe` type (or whatever your language wants to call it). That is, you can say a variable is either a pointer or it is `null` but never both. This makes it impossible to use a null pointer as a pointer. You can't deference it, you can't use it as an array, you can't do pointer arithmetic with it, etc.\n\nEssentially the language forces you to do a null pointer check, but once you've done that check, it can let freely use this pointer without checking again (until it changes of course). This can all be checked at compile time with no unneeded runtime overhead. This is different to C in which functions often have to recheck for null because they can't know what checks have already been done.\n\nUpvote\n\n13 (17 / -4)\n\nApr 7, 2021\n\nAdd bookmark\n\n#34\n\nthe memory-managed Rust programming language into the Linux kernel\n\nWe can quibble about what's a memory-managed language, but Rust doesn't do any conventional memory management (e.g., ref-counting or garbage collection), and I think it's misleading to phrase it like this.\n\nUpvote\n\n45 (45 / 0)\n\nPost content hidden for low score. Show…\n\nApr 7, 2021\n\nAdd bookmark\n\n#37\n\nthe memory-managed Rust programming language into the Linux kernel\n\nWe can quibble about what's a memory-managed language, but Rust doesn't do any conventional memory management (e.g., ref-counting or garbage collection), and I think it's misleading to phrase it like this.\n\nI'd say if a language goes to reasonable lengths to provide constructs that help/ensure you don't leak memory, it's memory-managed, so I'd say rust qualifies.\n\nhttps://doc.rust-lang.org/std/boxed/str ... ethod.leak\n\nUpvote\n\n8 (10 / -2)\n\nApr 7, 2021\n\nAdd bookmark\n\n#39\n\nWhile I see the benefit in many Rust features, as a C++ developer on a complex state-of-art AR-map project I must say that with modern C++ (17 in our case) it is not hard to write very stable applications anymore on memory management front. Using smart pointers and reference counting fixes most issues. The remaining null pointer issues are not unique to C++, and in same cases they cannot be eliminated (I mean if something does not exist all the time it must be null, or empty whatever).\n\nThat does not mean Rust is of no use for other things. But in general I feel there is a factor of bad memories about badly written old C++ codebases in Rust's success. These old projects tended to use raw pointers a lot and had issues quite frequently as memory was not allocated / deallocated properly. Smart pointers, STL containers and other new features eliminated the need to use new and delete in normal code. These features eliminated most of the mistakes a programmer can make, they ensure freeing up members when destroying objects and even free memory during exception handling properly.\n\nNow if someone could make a language which prevents writing spaghetti code and enforce proper architecture practices that would be great. AI tools might help that in the future.\n\nThere are some major problems I have with C++ compared to Rust:\n\n* C++ has a mountain of syntax, and related to this, the syntax is quite awkward for many constructs\n\n* C++ does not have a definitive build tool or package manager\n\n* For any exported code you have to write the interfaces twice (header files)\n\nUpvote\n\n21 (30 / -9)"
    }
}