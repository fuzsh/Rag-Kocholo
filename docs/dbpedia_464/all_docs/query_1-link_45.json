{
    "id": "dbpedia_464_1",
    "rank": 45,
    "data": {
        "url": "https://dede.dev/posts/mastering-shellcodes-techniques-and-examples/",
        "read_more_link": "",
        "language": "en",
        "title": "Mastering MacOS Shellcodes - Techniques, Resources, and Examples [Draft]",
        "top_image": "https://ik.imagekit.io/dclnpmnjj2/macos-researcher.png",
        "meta_img": "https://ik.imagekit.io/dclnpmnjj2/macos-researcher.png",
        "images": [
            "https://avatars.githubusercontent.com/u/20543154?v=4",
            "https://ik.imagekit.io/dclnpmnjj2/macos-researcher.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-11-06T22:33:00-05:00",
        "summary": "",
        "meta_description": "⚠️ This document is still a draft. Please note that there might be mistakes or inaccuracies.",
        "meta_lang": "en",
        "meta_favicon": "/assets/img/favicons/apple-touch-icon.png",
        "meta_site_name": "Wilfrantz Dede",
        "canonical_link": "https://dede.dev/posts/mastering-shellcodes-techniques-and-examples/",
        "text": "⚠️ This document is still a draft. Please note that there might be mistakes or inaccuracies.\n\nIntroduction\n\nThis document serves as a valuable resource for the Offsec ’s OSMR: EXP-312 MacOS Control Bypass course. It offers a wide range of techniques, examples, and valuable resources to elevate MacOS Shellcode development.\n\nShellcode is a crucial element in the field of cybersecurity, enabling attackers to execute malicious actions on targeted systems. This technical document provides comprehensive insights into mastering shellcodes, covering various techniques and offering practical examples.\n\nTable of contents\n\nIntroduction\n\nShellcode Overview\n\nAdvantages of Writing Custom Shellcode\n\nChoosing Between Assembly and C\n\nWriting Pure Assembly Shellcode\n\nCalling Conventions and Registers\n\nSystem Call Numbering\n\nWorking with BSD Type System Calls\n\nWriting Shellcode in C\n\nExecuting Arbitrary Commands\n\nCreating a Bind Shell\n\nUsing C Code to Call Arbitrary Functions\n\nReferencing XNU Source Code\n\nConclusion\n\nResource\n\nFootnote\n\nShellcode Overview\n\nShellcode refers to a set of assembly instructions that an attacker deploys to perform malicious actions on a targeted system. These actions commonly include opening a reverse or bind shell, but they can also involve more complex operations. Understanding shellcodes is essential for both offensive and defensive security practitioners.\n\nAdvantages of Writing Custom Shellcode\n\nWriting custom shellcode offers several benefits compared to using auto-generated shellcodes. By crafting our own shellcode, we can tailor it to meet specific requirements, ensuring optimal functionality and stealthiness. Additionally, custom shellcode is often less detectable by antivirus software, providing an advantage in evading security measures.\n\nChoosing Between Assembly and C\n\nShellcode can be written in two primary languages: assembly (ASM) and C. Assembly is commonly preferred in binary exploitation due to its precise control over the code, enabling optimization for size and the elimination of NULL bytes. However, assembly coding is time-consuming and prone to errors.\n\nOn the other hand, writing shellcode in C can be faster, less error-prone (especially for longer code), and benefits from the assembly generated by the compiler. However, reliance on the compiler-generated assembly might introduce challenges in certain scenarios.\n\nWriting Pure Assembly Shellcode\n\nThis section focuses on the process of crafting pure assembly shellcode using system calls. The control offered by assembly language allows for optimized code, free from NULL bytes, while achieving the desired outcome.\n\nIt is important to have an understanding of the Basic Syntax of Assembly Language. Start with this assembly programming tutorial, or if you prefer video, this Introduction to Assembly Language is also great.\n\nOn macOS we can use system calls to create a working shellcode. It’s possible to run shell commands and open a reverse shell with only system calls.\n\nSystem calls (or syscalls) are various functions or services offered by the kernel to user mode. To run syscalls, we must know the system call number, and the parameter(s) it expects.\n\nCalling Conventions and Registers\n\nJust like Linux, macOS uses the AMD64 calling convention on X86_64 CPUs to pass arguments to the function being called. To do this, it uses some general purpose registers as function arguments.\n\nThe other important registers are as follow.\n\nSystem Call Numbering\n\nEach system call has a given number that needs to be stored in the RAX register before the syscall assembly instruction. This number will be used by the kernel to decide which function to call.\n\nThe Berkeley Software Distribution (BSD) system call numbers can be found in the file xnu-7195.50.7.100.1/bsd/kern/syscalls.master.\n\nWe focus on two key categories: shell commands execution and bind or reverse shells creation.\n\nWe will use execve (59) to run arbitrary commands, to work with sockets when we create a bind or reverse shell we will use the followings: accept (30)\n\ndup2 (90)\n\nsocket (97)\n\nconnect (98)\n\nbind (104)\n\nlisten (106)\n\nmacOS supports multiple classes of system calls, not just BSD . These classes are defined in the xnu-7195.50.7.100.1/osfmk/mach/i386/syscall_sw.h file.\n\nWorking with BSD Type System Calls\n\nWhen dealing with traditional BSD type system calls, it is important to understand how to declare the desired class and system call number. The SYSCALL_CLASS_UNIX class, represented by the number 2, is used for BSD type calls.\n\nTo specify the class, we set the class number in the syscall value, positioning it at 24 on the bitmask using the SYSCALL_CLASS_SHIFT definition. For BSD type calls, this results in 0x2000000, obtained by shifting the value 2 left by 24 bits.\n\nAfter setting the class, we add the specific system call number to 0x2000000. For instance, if we want to use the execve system call with the number 59 (0x3b in hexadecimal), we combine it with the bitmask. The resulting number becomes 0x200003b, with the system call number occupying the first two positions on the bitmask.\n\nTo perform the actual system call, we need to pass this number to the syscall assembly instruction. This instruction will execute the desired system call based on the provided class and system call number.\n\nWriting Shellcode in C\n\nWith C, developers can leverage the power and flexibility of the language to create efficient and reliable shellcode. The use of C allows for faster development, reduced chances of errors (especially for longer code), and the ability to leverage the assembly generated by the compiler. However, it is important to be cautious of potential issues such as the presence of NULL bytes in the generated assembly, which may introduce challenges in certain exploitation scenarios.\n\nExecuting Arbitrary Commands\n\nOne fundamental capability of shellcode is executing arbitrary commands on the targeted system. This section explores techniques for implementing shellcode that enables the execution of desired commands. bts instruction. The bts (bit test and set) instruction sets the n-th bit in a bit string to 1.\n\nFor executing custom commands we will only need one system call, execve. The function prototype is defined in xnu-7195.50.7.100.1/bsd/kern/syscalls.master.\n\nCreating a Bind Shell\n\nIn addition to executing arbitrary commands, shellcode can be designed to create a bind shell. This allows the attacker to establish a persistent remote connection to the compromised system.\n\nUsing C Code to Call Arbitrary Functions\n\nAnother approach to shellcode development involves using C code to call arbitrary functions. This method offers faster development and reduced chances of errors, especially for longer shellcode. Though, it comes with the trade-off of relying on the assembly generated by the compiler. The potential issues, such as the presence of NULL bytes, are discussed in this section.\n\nReferencing XNU Source Code\n\nThroughout the document, the source code of XNU version 7195.50.7.100.1 is utilized for function prototypes and constants. The XNU source code can be accessed online or downloaded and viewed locally. The document provides instructions on locating the source code, enabling readers to consult it as a valuable resource.\n\nConclusion\n\nMastering shellcodes is essential for both offensive and defensive cybersecurity professionals. This technical document has provided an in-depth exploration of various shellcode techniques and examples, empowering readers to understand the intricacies of crafting custom shellcodes.\n\nBy leveraging this knowledge, security practitioners can fortify their systems against malicious attacks and effectively respond to cybersecurity incidents.\n\nResource"
    }
}