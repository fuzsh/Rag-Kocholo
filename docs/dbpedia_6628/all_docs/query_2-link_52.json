{
    "id": "dbpedia_6628_2",
    "rank": 52,
    "data": {
        "url": "https://retrocomputing.stackexchange.com/questions/21673/why-did-some-old-ms-dos-games-lack-the-ability-to-exit-them",
        "read_more_link": "",
        "language": "en",
        "title": "Why did some old MS-DOS games lack the ability to exit them?",
        "top_image": "https://cdn.sstatic.net/Sites/retrocomputing/Img/apple-touch-icon@2.png?v=6b27f39a6023",
        "meta_img": "https://cdn.sstatic.net/Sites/retrocomputing/Img/apple-touch-icon@2.png?v=6b27f39a6023",
        "images": [
            "https://i.sstatic.net/L9NB3.png?s=64",
            "https://www.gravatar.com/avatar/3e3eb71533804c03c25717c405f1c129?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a935dafe246dd0e2c216542f50073cbe?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/135a97c4150691234931a93f3a27a52f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/7e423aa6f9658ca1a766d9b841fea8d3?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/4xczZ.jpg?s=64",
            "https://i.sstatic.net/pDGmO.jpg?s=64",
            "https://i.sstatic.net/I2Qz5.png?s=64",
            "https://i.sstatic.net/LxNU8.png?s=64",
            "https://retrocomputing.stackexchange.com/posts/21673/ivc/54cc?prg=5c52d88b-b974-4bf3-8e42-587819435e61"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-08-26T18:02:44",
        "summary": "",
        "meta_description": "While playing around in DOSBox-X, I'm reminded of some DOS games which appear to entirely lack the ability to exit/quit/close them.\nOne prime example of that is &quot;Paratrooper&quot; from 1982. I...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/retrocomputing/Img/favicon.ico?v=9b6f1e4fd156",
        "meta_site_name": "Retrocomputing Stack Exchange",
        "canonical_link": "https://retrocomputing.stackexchange.com/questions/21673/why-did-some-old-ms-dos-games-lack-the-ability-to-exit-them",
        "text": "Paratrooper was originally a “PC booter”. All PC booters run without DOS or any other operating system¹ — to start them, you would insert the floppy into the drive, and switch the computer on (or reboot it). There was nothing for such a game to exit to — once you’d finished playing, you’d switch the computer off, or reboot it from a different floppy (or from the hard drive, if you had one). As pointed out by ssokolow, this is similar to how many other micros were used at the time, and continued for a long time on home computers such as the Atari ST.\n\nIn most cases, people converting PC booters to DOS executables wouldn’t add an exit feature — it would likely have been quite complex to do so. “Ripping” a booter to an executable already involves making a number of changes in many cases: some PC booters were copy-protected, so that has to be defeated, and many would write to their floppy, which also would have to be disabled (or re-implemented). As Jim Nelson explained in a comment, rebooting wasn’t at all unusual in DOS days², so adding an exit feature wouldn’t have been high on anyone’s to-do list!\n\nHowever, Paratrooper is well-behaved — it doesn’t overwrite anything it shouldn’t —, so you can add an exit feature to the game yourself: download HBREAK, and run it before you run the game. Pressing CtrlAltC (followed by Enter in some environments) will return you to the DOS prompt. This works fine in DOSBox and DOSBox-X.\n\nYou can also exit the game if you use an image of the original booter version, instead of the DOS conversion: there’s a piece of software, Flopper, which can “boot” booter games on top of DOS, and it allows you to exit back to DOS. If you’re interested in how it goes about this, it comes with extensive documentation and complete source code.\n\nThe reference for PC booters was Retrograde Station; the site disappeared long ago, but most of it is archived, including many images of games.\n\nAnother project to look at if you’re interested in booter games is Digger; this is a remaster of a booter game, and its documentation includes various titbits about booters in general.\n\nAs far as the executable extension (.COM or .EXE) goes, it doesn’t have any impact on whether the program can exit or not. The extension itself doesn’t distinguish between executable formats, but booters do tend to be ripped as binary images rather than MZ-type executables: whichever technique is used to dump the executable, it’s easier to store it as a headerless binary than work out the MZ header. Most booter games are small so they wouldn’t run into the size limits associated with the format either.\n\n¹ Games don’t need much in the way of operating system services, and everything needed by typical DOS games of the era, other than file access, was provided by the BIOS and easily re-implemented with direct hardware access anyway. File access wasn’t always necessary in the days of floppy disks — many booter games would “own” their disk, so they didn’t have to care about files, and any disk access they cared about (e.g. to store a high-score table) could be done through the BIOS or by directly programming the floppy-disk controller. Counter-examples include Sid Meier’s Pirates! which required a DOS-formatted floppy disk to save games to.\n\n² So much so that later versions of QEMM even implemented a “fast reboot” feature — it allowed DOS to be rebooted without actually resetting the computer and going through the system’s POST again.\n\nBack then, the operating system was much less powerful than you are used to today.\n\nMS-DOS was a disk operating system. It primarily took care of the disk (floppy disks, mostly), including reading, writing and executing files, and handling directory structures. Sure, it had a few other functions which would wrap around lower level features of the system, but not too many. It did provide the command line interface and a lot of individual small programs - e.g. to copy files and such - but those aspects are irrelevant for the question at hand as a game would use none of those.\n\nThe other important system component back then was the BIOS (basic input output system) which an application could use for, well, text input and output - if the application had no particular performance requirements and preferred an easier API instead of low level access to the devices. BIOS text processing incurred a very much noticeable performance overhead, and generally limited what you can do a lot.\n\nEspecially iIn the later days of the 286, 386, 486 and with the advent of more memory, when paging or memory virtualization became more frequently necessary, there were added subcomponents for memory handling, which could be started or configured separately (see Upper Memory Area or DOS Memory Management for nice overviews and links to more information).\n\nAside from these system components, many programs, and certainly most if not all graphically intensive games, talked to the hardware directly. They had direct control over all aspects of the screen (including intricate timings in the phases where the electron beam moved back between lines, or from the bottom to top border), and the keyboard. Sometimes even direct or low-level access to the floppy drive (bypassing DOS), for copyright protection purposes. There was no preemptive multitasking like in every general purpose OS today - there simply was no \"power\" in the system which could influence the running program that much.\n\nSpeaking of which, there was always one running program. It would even be far-fetched to call it \"process\" in our modern meaning; there were none of the features we associate with processes today (priority, time scheduling, ownership of particular resources, separate user/kernel-level permissions etc.), although DOS did keep track of some of the resources and could reserve them for programs loaded at the same time...\n\n... to be used, amongst others, for a type of application called TSR (\"terminate and stay resident programs\"), which meant that you could start small utilities which would stick around, and would usually intercept keyboard interrupts - so they could do some action on the press of a button, even if another program was currently active. This worked, mostly, but usually not very usefully while in a game which did fancy stuff with the screen. There was no way for a TSR to sanely take control, modify the screen, and restore everything to the previous setting. Of course one could try, but it was always a hack, nothing at all like today. There were no system-level video drivers which could do the state recovery, and so on.\n\nIf a program exited on ESC, that was purely a convention. Alt-F4 or other standard key combinations did not exist. Figuring out which keys a game used at all was always part of the fun, especially if you had a decentralized backup copy of a game without the manual..."
    }
}