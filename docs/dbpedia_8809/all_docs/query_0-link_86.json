{
    "id": "dbpedia_8809_0",
    "rank": 86,
    "data": {
        "url": "https://stackoverflow.com/questions/184071/when-if-ever-is-number-of-lines-of-code-a-useful-metric",
        "read_more_link": "",
        "language": "en",
        "title": "When, if ever, is \"number of lines of code\" a useful metric?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://cdn.sstatic.net/Img/survey-cta.svg?v=171e02557b0d",
            "https://stackoverflow.com/posts/184071/ivc/9e7b?prg=39592f49-24ae-4fa5-9f91-e56791bfc304"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2008-10-08T18:13:27",
        "summary": "",
        "meta_description": "Some people claim that code's worst enemy is its size, and I tend to agree. Yet every day you keep hearing things like\r\nI write blah lines of code in a day.\nI own x lines of code.\nWindows is x mill...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/184071/when-if-ever-is-number-of-lines-of-code-a-useful-metric",
        "text": "I'd say it's when you're removing code to make the project run better.\n\nSaying you removed \"X number of lines\" is impressive. And far more helpful than you added lines of code.\n\nI'm surprised nobody has mentioned Dijkstra's famous quote yet, so here goes:\n\nMy point today is that, if we wish to count lines of code, we should not regard them as \"lines produced\" but as \"lines spent\": the current conventional wisdom is so foolish as to book that count on the wrong side of the ledger.\n\nThe quote is from an article called \"On the cruelty of really teaching computing science\".\n\nIt's a terrible metric, but as other people have noted, it gives you a (very) rough idea of the overall complexity of a system. If you're comparing two projects, A and B, and A is 10,000 lines of code, and B is 20,000, that doesn't tell you much - project B could be excessively verbose, or A could be super-compressed.\n\nOn the other hand, if one project is 10,000 lines of code, and the other is 1,000,000 lines, the second project is significantly more complex, in general.\n\nThe problems with this metric come in when it's used to evaluate productivity or level of contribution to some project. If programmer \"X\" writes 2x the number of lines as programmer 'Y\", he might or might not be contributing more - maybe \"Y\" is working on a harder problem...\n\nThere is one particular case when I find it invaluable. When you are in an interview and they tell you that part of your job will be to maintain an existing C++/Perl/Java/etc. legacy project. Asking the interviewer how many KLOC (approx.) are involved in the legacy project will give you a better idea as to whether you want their job or not.\n\nlike most metrics, they mean very little without a context. So the short answer is: never (except for the line printer, that's funny! Who prints out programs these days?)\n\nAn example:\n\nImagine that you're unit-testing and refactoring legacy code. It starts out with 50,000 lines of code (50 KLOC) and 1,000 demonstrable bugs (failed unit tests). The ratio is 1K/50KLOC = 1 bug per 50 lines of code. Clearly this is terrible code!\n\nNow, several iterations later, you have reduced the known bugs by half (and the unknown bugs by more than that most likely) and the code base by a factor of five through exemplary refactoring. The ratio is now 500/10000 = 1 bug per 20 lines of code. Which is apparently even worse!\n\nDepending on what impression you want to make, this can be presented as one or more of the following:\n\n50% less bugs\n\nfive times less code\n\n80% less code\n\n60% worsening of the bugs-to-code ratio\n\nall of these are true (assuming i didn't screw up the math), and they all suck at summarizing the vast improvement that such a refactoring effort must have achieved.\n\nThere are a lot of different Software Metrics. Lines of code is the most used and is the easiest to understand.\n\nI am surprised how often the lines of code metric correlates with the other metrics. In stead of buying a tool that can calculate cyclomatic complexity to discover code smells, I just look for the methods with many lines, and they tend to have high complexity as well.\n\nA good example of use of lines of code is in the metric: Bugs per lines of code. It can give you a gut feel of how many bugs you should expect to find in your project. In my organization we are usually around 20 bugs per 1000 lines of code. This means that if we are ready to ship a product that has 100,000 lines of code, and our bug database shows that we have found 50 bugs, then we should probably do some more testing. If we have 20 bugs per 1000 lines of code, then we are probably approaching the quality that we usually are at.\n\nA bad example of use is to measure developer productivity. If you measure developer productivity by lines of code, then people tend to use more lines to deliver less.\n\nI'd agree that taking the total number of lines of code in a project is one way to measure complexity.\n\nIt's certainly not the only measure of complexity. For example debugging a 100 line obfuscated Perl script is much different from debugging a 5,000 line Java project with comment templates.\n\nBut without looking at the source, you'd usually think more lines of code is more complex, just as you might think a 10MB source tarball is more complex than a 15kb source tarball.\n\nIt is useful in many ways.\n\nI don't remember the exact # but Microsoft had a web cast that talked about for every X lines of code on average there are y number of bugs. You can take that statement and use it to give a baseline for several things.\n\nHow well a code reviewer is doing their job.\n\njudging skill level of 2 employees by comparing their bug ratio's over several projects.\n\nAnother thing we look at is, why is it so many lines? Often times when a new programmer is put in a jam they will just copy and paste chunks of code instead of creating functions and encapsulating.\n\nI think that the I wrote x lines of code in a day is a terrible measure. It take no account for difficulty of problem, language your writing in, and so on.\n\nIt seems to me that there's a finite limit of how many lines of code I can refer to off the top of my head from any given project. The limit is probably very similar for the average programmer. Therefore, if you know your project has 2 million lines of code, and your programmers can be expected to be able to understand whether or not a bug is related to the 5K lines of code they know well, then you know you need to hire 400 programmers for your code base to be well covered from someone's memory.\n\nThis will also make you think twice about growing your code base too fast and might get you thinking about refactoring it to make it more understandable.\n\nNote I made up these numbers.\n\nThe Software Engineering Institute's Process Maturity Profile of the Software Community: 1998 Year End Update (which I could not find a link to, unfortunately) discusses a survey of around 800 software development teams (or perhaps it was shops). The average defect density was 12 defects per 1000 LOC.\n\nIf you had an application with 0 defects (it doesn't exist in reality, but let's suppose) and wrote 1000 LOC, on average, you can assume that you just introduced 12 defects into the system. If QA finds 1 or 2 defects and that's it, then they need to do more testing as there are probably 10+ more defects.\n\nIt's a metric of productivity, as well as complexity. Like all metrics, it needs to be evaluated with care. A single metric usually is not sufficient for a complete answer.\n\nIE, a 500 line program is not nearly as complex as a 5000 line. Now you have to ask other questions to get a better view of the program...but now you have a metric.\n\nI wrote 2 blog post detailling the pro and cons of counting Lines of Code (LoC):\n\nHow do you count your number of Lines Of Code (LOC) ? : The idea is to explain that you need to count the logical number of lines of code instead of a physical count. To do so you can use tools like NDepend for example.\n\nWhy is it useful to count the number of Lines Of Code (LOC) ?: The idea is that LoC should never be used to measure productivity, but more to do test coverage estimation and software deadline estimation.\n\nAlways. Bunch o'rookies on this question. Masters write code prolifically and densely. Good grads write lots of lines but too much fluff. Crappers copy lines of code. So, first do a Tiles analysis or gate, of course.\n\nLoC must be used if your org doesn't do any complexity points, feature points/function points, commits, or other analysis.\n\nAny developer who tells you not to measure him or her by LoC is shite. Any master cranks code our like you would not believe. I've worked with a handful who are 20x to 200x as productive as the average programmer. And their code is very, very, very compact and efficient. Yes, like Dijkstra, they have enormous mental models.\n\nFinally, in any undertaking, most people are not good at it and most doing it are not great. Programming is no different.\n\nYes, do a hit analysis on any large project and find out 20% plus is dead code. Again, master programmers regularly annihilate dead code and crapcode.\n\nLines of code isn't so useful really, and if it is used as a metric by management it leads to programmers doing a lot of refactoring to boost their scores. In addition poor algorithms aren't replaced by neat short algorithms because that leads to negative LOC count which counts against you. To be honest, just don't work for a company that uses LOC/d as a productivity metric, because the management clearly doesn't have any clue about software development and thus you'll always be on the back foot from day one.\n\nIt is a very usefull idea when it is associated with the number of defects. \"Defects\" gives you a measure of code quality. The least \"defects\" the better the software; It is nearly impossible to remove all defects. In many occasions, a single defect could be harmfull and fatal.\n\nHowever, it does not seem that nondefective software exists."
    }
}