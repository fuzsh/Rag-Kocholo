{
    "id": "dbpedia_5484_1",
    "rank": 60,
    "data": {
        "url": "https://davidwarburton.wordpress.com/2010/05/04/netbackup-script-to-report-scratch-tapes/",
        "read_more_link": "",
        "language": "en",
        "title": "Netbackup script to report scratch tapes",
        "top_image": "https://davidwarburton.wordpress.com/wp-content/uploads/2017/09/cropped-coe.jpg?w=200",
        "meta_img": "https://davidwarburton.wordpress.com/wp-content/uploads/2017/09/cropped-coe.jpg?w=200",
        "images": [
            "https://0.gravatar.com/avatar/626f8b10162bd7cdaae0e1aba04abdbd870b18da86fe1681f66df67eef115e31?s=50&d=identicon&r=G",
            "https://davidwarburton.wordpress.com/wp-content/uploads/2018/01/warburton_david.jpg?w=2765",
            "https://davidwarburton.wordpress.com/wp-content/uploads/2017/09/cropped-coe.jpg?w=50",
            "https://davidwarburton.wordpress.com/wp-content/uploads/2017/09/cropped-coe.jpg?w=50",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2010-05-04T00:00:00",
        "summary": "",
        "meta_description": "I've seen Netbackup used in two completely different ways now. In my last environment all tapes rotas, movements and scratch tapes were handled manually. We had a spreadsheet showing tape sets (see below for an example), when these tapes were collected by Iron Mountain, which days of the months we defined as Monthly/Quarterly backups and…",
        "meta_lang": "en",
        "meta_favicon": "https://davidwarburton.wordpress.com/wp-content/uploads/2017/09/cropped-coe.jpg?w=32",
        "meta_site_name": "David Warburton",
        "canonical_link": "https://davidwarburton.wordpress.com/2010/05/04/netbackup-script-to-report-scratch-tapes/",
        "text": "I’ve seen Netbackup used in two completely different ways now. In my last environment all tapes rotas, movements and scratch tapes were handled manually. We had a spreadsheet showing tape sets (see below for an example), when these tapes were collected by Iron Mountain, which days of the months we defined as Monthly/Quarterly backups and so on. In this scenario each set of tapes is a number of tapes – on some days you may use less, on some days you may not have enough loaded.\n\nIn the new environment we let Netbackup dictate which tapes are in the scratch pool and free for re-use based on the expiration policy of the jobs written to those tapes. In theory this should mean that you only ever use as many tapes as you need for a given backup job. The problem with this set-up is that although it is, in theory, more efficient, you don’t always know which tapes you will need each night and how many you have free.\n\nEach day guys were running NBU command lines to show which tapes were in the scratch pool, but having to manually sift through them to see which tapes were currently sat in drives/libraries and of the ones held off-site, which tapes were of which format (LTO2, 3 or 4).\n\nThe following script can be scheduled to email out a list of tapes in the scratch pool, which are in what library and also groups the offsite tapes by format. It was knocked up in a hurry so isn’t as parameterised or dynamic as it should be, but the comments should help you fix it for your needs…\n\nHere’s the script and HTML header & footer…\n\nscratch_list.ps1\n\n$debugpreference = \"continue\" #This \"output\" variable runs and stores the output of the NBU command line #Be sure that this .exe is in your path, otherwise change the below to include the full path to the executable. $output = vmquery.exe -b -pn Scratch $htmlfile = \".\\output.txt\" $today = Get-Date #Arrays to hold and sort info about our tapes. #NOTE: this script is hard-coded to work for LTO2 (HCART2), LTO3 (HCART3) and LTO4 (HCART) tape drives/libraries [array]$aTapes = @() [array]$aHOffsite = @() [array]$aH2Offsite = @() [array]$aH3Offsite = @() #NOTE: this script is hard coded to include the specific names of tape drives attached (via various media servers) to the master server $aRobots = @{\"TLD0\" = 0; \"TLD1\" = 0; \"TLD2\" = 0; \"TLD3\" = 0; \"TLD4\" = 0; \"TLD5\" = 0; \"TLD6\" = 0; \"TLD7\" = 0; \"TLD8\" = 0; \"TLD9\" = 0; \"TLD10\" = 0; \"TLD11\" = 0; \"TLD12\" = 0; \"TLD13\" = 0; \"TLD14\" = 0} $emailBody = Get-Content \"header.html\" $aOffsite = 0 #Function to send mail (currently configured to send via Exchange) function sendEmail() { $eServer = New-Object system.net.mail.smtpClient(\"exchange_server01\") $From = \"netbackup@yourcompany.com\" $To = \"nbu_reports@yourcompany.com\" $todayDate = [string] $today.day + \"/\" + [string] $today.month + \"/\" + [string] $today.year $title = \"Scratch tape list for $todayDate\" $Body = $emailBody $eMsg = New-Object System.Net.Mail.MailMessage($From,$To,$title,$body) $eMsg.IsBodyHTML = $True $eServer.send($eMsg) } #Take output of NBU command line util, and for each line pick out bits of the string #Chuck everything in to a new array called $aTapes foreach ($line in $output){ if (($line.contains(\"HCART\")) -and (-not $line.contains(\"A00\"))) { $tName = ($line.substring(0, 6)).trim() $tType = ($line.substring(8, 6)).trim() $tRobot = $line.substring(23, 5).trim() #this captures a wide area with some white space that needs trimming $tRobot = $tRobot.replace(\" \", \"\") $aTapes += ,($tName, $tRobot, $tType) } } #Go through the array we just created and then put the contents in to seperate arrays #dependant on whether they are LTO, LTO2 or LTO3 tapes... for ($j = 0; $j -lt $aTapes.length; $j++) { $tapeID = $aTapes[$j][0] $robot = $aTapes[$j][1] $type = $aTapes[$j][2] if ($robot.contains(\"-\")) { switch ($type ) { \"HCART\" {$aHOffsite += ,($tapeID)} \"HCART2\" {$aH2Offsite += ,($tapeID)} \"HCART3\" {$aH3Offsite += ,($tapeID)} } } else {#If a library type does not contain HCART, HCART2 or HCART3 we must assume it's offsite (or in a safe)) $temp = \"TLD$robot\" $aRobots[$temp] = $aRobots[$temp] + 1 } } #Take the contents of $aRobots (offsite tapes) and put it in to a variables ready to be dumped in to our html output foreach ($element in $aRobots) { $element > $htmlfile } #Start pipping everything out to the $emailBody variable which will make the body of our email $emailBody += '<table><tr><td>Tape drive</td><td># scratch tapes</td></tr>' foreach ($line in Get-Content $htmlfile) { if ($line.contains(\"TLD\")) { $emailBody += \"<tr>\" $robot = $line.substring(0, 5) $count = $line.substring(31, 3) $emailBody += \"<td>$robot</td><td>$count</td>\" $emailBody += \"</tr>\" } } $emailBody += '</table><br/><br/>' $emailBody += \"<b>Offsite tapes...</b><br/>\" $emailBody += \"<b>HCART</b><br>\" foreach($element in $aHOffsite) { $emailBody += \"$element<br/>\" } $emailBody += \"<br/><b>HCART2</b><br>\" foreach($element in $aH2Offsite) { $emailBody += \"$element<br/>\" } $emailBody += \"<br/><b>HCART3</b><br>\" foreach($element in $aH3Offsite) { $emailBody += \"$element<br/>\" } $emailBody += Get-Content \"footer.html\" sendEmail\n\nAs per my other NBU scripts I use HTML files to store the CSS and opening HTML in order to easily format nice looking emails. See below for examples…\n\nheader.html\n\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"> <html> <head> <title>Scratch tape list</title> <style type=\"text/css\"> body { font-family: Calibri, Arial, Helvetica; color: black; font-size: small; background-color: #FFFFFF } p { font-size: small } .big { font-size: small } table { font-size: small; padding: 0px ; border-spacing: 2px ; empty-cells: hide ; border: 1px solid #AAAAAA } td { background-color: #EEEEEE; vertical-align: top } th { background-color: #EEEEEE; vertical-align: top ; text-align: left} </style> </head> <body> <p>*** This email is now automatically generated ***<br></p>\n\nfooter.html\n\n<br/> <p>Regards,<br/><br/> </p> </body> </html>\n\nLet me know if this helps you out at all or if you can suggest any improvements…"
    }
}