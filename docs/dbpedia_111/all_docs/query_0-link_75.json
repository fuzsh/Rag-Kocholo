{
    "id": "dbpedia_111_0",
    "rank": 75,
    "data": {
        "url": "https://en.wikipedia.org/wiki/Newline",
        "read_more_link": "",
        "language": "en",
        "title": "Wikipedia",
        "top_image": "https://upload.wikimedia.org/wikipedia/commons/b/b3/Illustration_of_a_newline.png",
        "meta_img": "https://upload.wikimedia.org/wikipedia/commons/b/b3/Illustration_of_a_newline.png",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b3/Illustration_of_a_newline.png/220px-Illustration_of_a_newline.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/2/27/Newline_hex_0A.png/300px-Newline_hex_0A.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2003-06-02T04:26:08+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/Newline",
        "text": "Special characters in computing signifying the end of a line of text\n\nFor other uses, see New Line (disambiguation).\n\n\"Endl\" redirects here. For the botanist, see Stephan Endlicher.\n\nA newline (frequently called line ending, end of line (EOL), next line (NEL) or line break) is a control character or sequence of control characters in character encoding specifications such as ASCII, EBCDIC, Unicode, etc. This character, or a sequence of characters, is used to signify the end of a line of text and the start of a new one.[1]\n\nIn the mid-1800s, long before the advent of teleprinters and teletype machines, Morse code operators or telegraphists invented and used Morse code prosigns to encode white space text formatting in formal written text messages. In particular the Morse prosign BT (mnemonic break text) represented by the concatenation of literal textual Morse codes \"B\" and \"T\" characters sent without the normal inter-character spacing is used in Morse code to encode and indicate a new line or new section in a formal text message.\n\nLater, in the age of modern teleprinters, standardized character set control codes were developed to aid in white space text formatting. ASCII was developed simultaneously by the International Organization for Standardization (ISO) and the American Standards Association (ASA), the latter being the predecessor organization to American National Standards Institute (ANSI). During the period of 1963 to 1968, the ISO draft standards supported the use of either CR+LF or LF alone as a newline, while the ASA drafts supported only CR+ LF.\n\nThe sequence CR+ LF was commonly used on many early computer systems that had adopted Teletype machines—typically a Teletype Model 33 ASR—as a console device, because this sequence was required to position those printers at the start of a new line. The separation of newline into two functions concealed the fact that the print head could not return from the far right to the beginning of the next line in time to print the next character. Any character printed after a CR would often print as a smudge in the middle of the page while the print head was still moving the carriage back to the first position. \"The solution was to make the newline two characters: CR to move the carriage to column one, and LF to move the paper up.\"[2] In fact, it was often necessary to send extra padding characters—extraneous CRs or NULs—which are ignored but give the print head time to move to the left margin. Many early video displays also required multiple character times to scroll the display.\n\nOn such systems, applications had to talk directly to the Teletype machine and follow its conventions since the concept of device drivers hiding such hardware details from the application was not yet well developed. Therefore, text was routinely composed to satisfy the needs of Teletype machines. Most minicomputer systems from DEC used this convention. CP/M also used it in order to print on the same terminals that minicomputers used. From there MS-DOS (1981) adopted CP/M's CR+ LF in order to be compatible, and this convention was inherited by Microsoft's later Windows operating system.\n\nThe Multics operating system began development in 1964 and used LF alone as its newline. Multics used a device driver to translate this character to whatever sequence a printer needed (including extra padding characters), and the single byte was more convenient for programming. What seems like a more obvious choice— CR—was not used, as CR provided the useful function of overprinting one line with another to create boldface, underscore and strikethrough effects. Perhaps more importantly, the use of LF alone as a line terminator had already been incorporated into drafts of the eventual ISO/IEC 646 standard. Unix followed the Multics practice, and later Unix-like systems followed Unix. This created conflicts between Windows and Unix-like operating systems, whereby files composed on one operating system could not be properly formatted or interpreted by another operating system (for example a UNIX shell script written in a Windows text editor like Notepad[3][4]).\n\nThe concepts of carriage return (CR) and line feed (LF) are closely associated and can be considered either separately or together. In the physical media of typewriters and printers, two axes of motion, \"down\" and \"across\", are needed to create a new line on the page. Although the design of a machine (typewriter or printer) must consider them separately, the abstract logic of software can combine them together as one event. This is why a newline in character encoding can be defined as CR and LF combined into one (commonly called CR+LF or CRLF).\n\nSome character sets provide a separate newline character code. EBCDIC, for example, provides an NL character code in addition to the CR and LF codes. Unicode, in addition to providing the ASCII CR and LF control codes, also provides a \"next line\" ( NEL) control code, as well as control codes for \"line separator\" and \"paragraph separator\" markers.\n\nSoftware applications and operating system representation of a newline with one or two control characters Operating system Character encoding Abbreviation hex value dec value Escape sequence POSIX standard oriented systems:\n\nUnix and Unix-like systems (Linux, macOS, *BSD, AIX, Xenix, etc.), QNX 4+, Multics, BeOS, Amiga, RISC OS, and others[5] ASCII LF 0A 10 \\n Windows, MS-DOS compatibles, Atari TOS, DEC TOPS-10, RT-11, CP/M, MP/M, OS/2, Symbian OS, Palm OS, Amstrad CPC, and most other early non-Unix and non-IBM operating systems CR LF 0D 0A 13 10 \\r\\n Commodore 64, Commodore 128, Acorn BBC, ZX Spectrum, TRS-80, Apple II, Oberon, classic Mac OS, HP Series 80, MIT Lisp Machine, and OS-9 CR 0D 13 \\r Acorn BBC[6] and RISC OS spooled text output[7] LF CR 0A 0D 10 13 \\n\\r QNX pre-POSIX implementation (version < 4) RS 1E 30 \\036 Atari 8-bit computers ATASCII EOL 9B 155 IBM mainframe systems, including z/OS (OS/390) and IBM i (OS/400) EBCDIC NL 15 21 \\025 ZX80 and ZX81 (home computers from Sinclair Research Ltd) ZX80/ZX81 proprietary encoding 76 118\n\nEBCDIC systems—mainly IBM mainframe systems, including z/OS (OS/390) and IBM i (OS/400)—use NL (New Line, 0x15)[8] as the character combining the functions of line feed and carriage return. The equivalent Unicode character (0x85) is called NEL (Next Line). EBCDIC also has control characters called CR and LF, but the numerical value of LF (0x25) differs from the one used by ASCII (0x0A). Additionally, some EBCDIC variants also use NL but assign a different numeric code to the character. However, those operating systems use a record-based file system, which stores text files as one record per line. In most file formats, no line terminators are actually stored.\n\nOperating systems for the CDC 6000 series defined a newline as two or more zero-valued six-bit characters at the end of a 60-bit word. Some configurations also defined a zero-valued character as a colon character, with the result that multiple colons could be interpreted as a newline depending on position.\n\nRSX-11 and OpenVMS also use a record-based file system, which stores text files as one record per line. In most file formats, no line terminators are actually stored, but the Record Management Services facility can transparently add a terminator to each line when it is retrieved by an application. The records themselves can contain the same line terminator characters, which can either be considered a feature or a nuisance depending on the application. RMS not only stores records, but also stores metadata about the record separators in different bits for the file to complicate matters even more (since files can have fixed length records, records that are prefixed by a count or records that are terminated by a specific character). The bits are not generic, so while they can specify that CRLF or LF or even CR is the line terminator, they can not substitute some other code.\n\nFixed line length was used by some early mainframe operating systems. In such a system, an implicit end-of-line was assumed every 72 or 80 characters, for example. No newline character was stored. If a file was imported from the outside world, lines shorter than the line length had to be padded with spaces, while lines longer than the line length had to be truncated. This mimicked the use of punched cards, on which each line was stored on a separate card, usually with 80 columns on each card, often with sequence numbers in columns 73–80. Many of these systems added a carriage control character to the start of the next record; this could indicate whether the next record was a continuation of the line started by the previous record, or a new line, or should overprint the previous line (similar to a CR). Often this was a normal printing character such as # that thus could not be used as the first character in a line. Some early line printers interpreted these characters directly in the records sent to them.\n\nMany communications protocols have some sort of new line convention. In particular, protocols published by the Internet Engineering Task Force (IETF) typically use the ASCII CRLF sequence.\n\nIn some older protocols, the new line may be followed by a checksum or parity character.\n\n\"Paragraph separator\" redirects here. For the symbol also known as a \"paragraph sign\", see Pilcrow.\n\nThe Unicode standard defines a number of characters that conforming applications should recognize as line terminators:[9]\n\nLF: Line Feed, U+000A\n\nVT: Vertical Tab, U+000B\n\nFF: Form Feed, U+000C\n\nCR: Carriage Return, U+000D\n\nCR+LF: CR (U+000D) followed by LF (U+000A)\n\nNEL: Next Line, U+0085\n\nLS: Line Separator, U+2028\n\nPS: Paragraph Separator, U+2029\n\nWhile it may seem overly complicated compared to an approach such as converting all line terminators to a single character (e.g. LF), because Unicode is designed to preserve all information when converting a text file from any existing encoding to Unicode and back (round-trip integrity), Unicode needs to make the same distinctions between line breaks made by other encodings.\n\nFor example: NL is part of EBCDIC, which uses code 0x15; it is normally mapped to Unicode NEL, 0x85, which is a control character in the C1 control set.[10] As such, it is defined by ECMA 48,[11] and recognized by encodings compliant with ISO/IEC 2022 (which is equivalent to ECMA 35).[12] C1 control set is also compatible with ISO-8859-1.[citation needed] The approach taken in the Unicode standard allows round-trip transformation to be information-preserving while still enabling applications to recognize all possible types of line terminators.\n\nRecognizing and using the newline codes greater than 0x7F ( NEL, LS and PS) is not often done. They are multiple bytes in UTF-8, and the code for NEL has been used as the ellipsis (…) character in Windows-1252. For instance:\n\nECMAScript accepts LS and PS as line breaks,[13] but considers U+0085 (NEL) whitespace instead of a line break.[14]\n\nJSON[15] allows LS and PS characters within strings, while ECMAScript prior to ES2019[16][17] treated them as newlines, and therefore illegal syntax.[18]\n\nYAML[19] no longer recognizes them as line breaks as of version 1.2, in order to be compatible with JSON.\n\nWindows Notepad, the default text editor of Microsoft Windows, does not treat any of NEL, LS, or PS as line breaks.\n\ngedit, the default text editor of the GNOME desktop environment, treats LS and PS, but not NEL, as line breaks.\n\nThe Unicode special characters U+2424 (SYMBOL FOR NEWLINE, ␤), U+23CE ( RETURN SYMBOL, ⏎), U+240D ( SYMBOL FOR CARRIAGE RETURN, ␍) and U+240A ( SYMBOL FOR LINE FEED, ␊) are glyphs intended for presenting a user-visible character to the reader of the document, and are thus not recognized themselves as a newline.\n\n\"\\n\" redirects here. For the similar number notation, see \\nnn (disambiguation).\n\nTo facilitate the creation of portable programs, programming languages provide some abstractions to deal with the different types of newline sequences used in different environments.\n\nThe C programming language provides the escape sequences '\\n' (newline) and '\\r' (carriage return). However, these are not required to be equivalent to the ASCII LF and CR control characters. The C standard only guarantees two things:\n\nEach of these escape sequences maps to a unique implementation-defined number that can be stored in a single char value.\n\nWhen writing to a file, device node, or socket/fifo in text mode, '\\n' is transparently translated to the native newline sequence used by the system, which may be longer than one character. When reading in text mode, the native newline sequence is translated back to '\\n'. In binary mode, no translation is performed, and the internal representation produced by '\\n' is output directly.\n\nOn Unix platforms, where C originated, the native newline sequence is ASCII LF ( 0x0A), so '\\n' was simply defined to be that value. With the internal and external representation being identical, the translation performed in text mode is a no-op, and Unix has no notion of text mode or binary mode. This has caused many programmers who developed their software on Unix systems simply to ignore the distinction completely, resulting in code that is not portable to different platforms.\n\nThe C library function fgets() is best avoided in binary mode because any file not written with the Unix newline convention will be misread. Also, in text mode, any file not written with the system's native newline sequence (such as a file created on a Unix system, then copied to a Windows system) will be misread as well.\n\nAnother common problem is the use of '\\n' when communicating using an Internet protocol that mandates the use of ASCII CR+ LF for ending lines. Writing '\\n' to a text mode stream works correctly on Windows systems, but produces only LF on Unix, and something completely different on more exotic systems. Using \"\\r\\n\" in binary mode is slightly better.\n\nMany languages, such as C++, Perl,[20] and Haskell provide the same interpretation of '\\n' as C. C++ has an alternative I/O model where the manipulator std::endl can be used to output a newline (and flushes the stream buffer).\n\nJava, PHP,[21] and Python[22] provide the '\\r\\n' sequence (for ASCII CR+ LF). In contrast to C, these are guaranteed to represent the values U+000D and U+000A, respectively.\n\nThe Java I/O libraries do not transparently translate these into platform-dependent newline sequences on input or output. Instead, they provide functions for writing a full line that automatically add the native newline sequence, and functions for reading lines that accept any of CR, LF, or CR+ LF as a line terminator (see BufferedReader.readLine()). The System.lineSeparator() method can be used to retrieve the underlying line separator.\n\nExample:\n\nStringeol=System.lineSeparator(); StringlineColor=\"Color: Red\"+eol;\n\nPython permits \"Universal Newline Support\" when opening a file for reading, when importing modules, and when executing a file.[23]\n\nSome languages have created special variables, constants, and subroutines to facilitate newlines during program execution. In some languages such as PHP and Perl, double quotes are required to perform escape substitution for all escape sequences, including '\\n' and '\\r'. In PHP, to avoid portability problems, newline sequences should be issued using the PHP_EOL constant.[24]\n\nExample in C#:\n\nstringeol=Environment.NewLine; stringlineColor=\"Color: Red\"+eol; stringeol2=\"\\n\"; stringlineColor2=\"Color: Blue\"+eol2;\n\nThe different newline conventions cause text files that have been transferred between systems of different types to be displayed incorrectly.\n\nText in files created with programs which are common on Unix-like or classic Mac OS, appear as a single long line on most programs common to MS-DOS and Microsoft Windows because these do not display a single line feed or a single carriage return as a line break.\n\nConversely, when viewing a file originating from a Windows computer on a Unix-like system, the extra CR may be displayed as a second line break, as ^M, or as <cr> at the end of each line.\n\nFurthermore, programs other than text editors may not accept a file, e.g. some configuration file, encoded using the foreign newline convention, as a valid file.\n\nThe problem can be hard to spot because some programs handle the foreign newlines properly while others do not. For example, a compiler may fail with obscure syntax errors even though the source file looks correct when displayed on the console or in an editor. Modern text editors generally recognize all flavours of CR+ LF newlines and allow users to convert between the different standards. Web browsers are usually also capable of displaying text files and websites which use different types of newlines.\n\nEven if a program supports different newline conventions, these features are often not sufficiently labeled, described, or documented. Typically a menu or combo-box enumerating different newline conventions will be displayed to users without an indication if the selection will re-interpret, temporarily convert, or permanently convert the newlines. Some programs will implicitly convert on open, copy, paste, or save—often inconsistently.\n\nMost textual Internet protocols (including HTTP, SMTP, FTP, IRC, and many others) mandate the use of ASCII CR+ LF ( '\\r\\n', 0x0D 0x0A) on the protocol level, but recommend that tolerant applications recognize lone LF ( '\\n', 0x0A) as well. Despite the dictated standard, many applications erroneously use the C newline escape sequence '\\n' ( LF) instead of the correct combination of carriage return escape and newline escape sequences '\\r\\n' ( CR+ LF) (see section Newline in programming languages above). This accidental use of the wrong escape sequences leads to problems when trying to communicate with systems adhering to the stricter interpretation of the standards instead of the suggested tolerant interpretation. One such intolerant system is the qmail mail transfer agent that actively refuses to accept messages from systems that send bare LF instead of the required CR+ LF.[25]\n\nThe standard Internet Message Format[26] for email states: \"CR and LF MUST only occur together as CRLF; they MUST NOT appear independently in the body\". Differences between SMTP implementations in how they treat bare LF and/or bare CR characters have led to SMTP spoofing attacks referred to as \"SMTP smuggling\".[27]\n\nThe File Transfer Protocol can automatically convert newlines in files being transferred between systems with different newline representations when the transfer is done in \"ASCII mode\". However, transferring binary files in this mode usually has disastrous results: any occurrence of the newline byte sequence—which does not have line terminator semantics in this context, but is just part of a normal sequence of bytes—will be translated to whatever newline representation the other system uses, effectively corrupting the file. FTP clients often employ some heuristics (for example, inspection of filename extensions) to automatically select either binary or ASCII mode, but in the end it is up to users to make sure their files are transferred in the correct mode. If there is any doubt as to the correct mode, binary mode should be used, as then no files will be altered by FTP, though they may display incorrectly.[28]\n\nText editors are often used for converting a text file between different newline formats; most modern editors can read and write files using at least the different ASCII CR/ LF conventions.\n\nFor example, the editor Vim can make a file compatible with the Windows Notepad text editor. Within vim\n\n:set fileformat=dos :wq\n\nEditors can be unsuitable for converting larger files or bulk conversion of many files. For larger files (on Windows NT) the following command is often used:\n\nD:\\>TYPE unix_file | FIND /V \"\" > dos_file\n\nSpecial purpose programs to convert files between different newline conventions include unix2dos and dos2unix, mac2unix and unix2mac, mac2dos and dos2mac, and flip.[29] The tr command is available on virtually every Unix-like system and can be used to perform arbitrary replacement operations on single characters. A DOS/Windows text file can be converted to Unix format by simply removing all ASCII CR characters with\n\n$ tr -d '\\r' < inputfile > outputfile\n\nor, if the text has only CR newlines, by converting all CR newlines to LF with\n\n$ tr '\\r' '\\n' < inputfile > outputfile\n\nThe same tasks are sometimes performed with awk, sed, or in Perl if the platform has a Perl interpreter:\n\n$ awk'{sub(\"$\",\"\\r\\n\"); printf(\"%s\",$0);}' inputfile > outputfile# UNIX to DOS (adding CRs on Linux and BSD based OS that haven't GNU extensions) $ awk'{gsub(\"\\r\",\"\"); print;}' inputfile > outputfile# DOS to UNIX (removing CRs on Linux and BSD based OS that haven't GNU extensions) $ sed -e's/$/\\r/' inputfile > outputfile# UNIX to DOS (adding CRs on Linux based OS that use GNU extensions) $ sed -e's/\\r$//' inputfile > outputfile# DOS to UNIX (removing CRs on Linux based OS that use GNU extensions) $ perl -pe's/\\r?\\n|\\r/\\r\\n/g' inputfile > outputfile# Convert to DOS $ perl -pe's/\\r?\\n|\\r/\\n/g' inputfile > outputfile# Convert to UNIX $ perl -pe's/\\r?\\n|\\r/\\r/g' inputfile > outputfile# Convert to old Mac\n\nThe file command can identify the type of line endings:\n\n$ file myfile.txt myfile.txt: ASCII English text, with CRLF line terminators\n\nThe Unix egrep (extended grep) command can be used to print filenames of Unix or DOS files (assuming Unix and DOS-style files only, no classic Mac OS-style files):\n\n$ egrep -L'\\r\\n' myfile.txt# show UNIX style file (LF terminated) $ egrep -l'\\r\\n' myfile.txt# show DOS style file (CRLF terminated)\n\nOther tools permit the user to visualise the EOL characters:\n\n$ od -a myfile.txt $ cat -e myfile.txt $ cat -v myfile.txt $ hexdump -c myfile.txt\n\nTwo ways to view newlines, both of which are self-consistent, are that newlines either separate lines or that they terminate lines. If a newline is considered a separator, there will be no newline after the last line of a file. Some programs have problems processing the last line of a file if it is not terminated by a newline. On the other hand, programs that expect newline to be used as a separator will interpret a final newline as starting a new (empty) line. Conversely, if a newline is considered a terminator, all text lines including the last are expected to be terminated by a newline. If the final character sequence in a text file is not a newline, the final line of the file may be considered to be an improper or incomplete text line, or the file may be considered to be improperly truncated.\n\nIn text intended primarily to be read by humans using software which implements the word wrap feature, a newline character typically only needs to be stored if a line break is required independent of whether the next word would fit on the same line, such as between paragraphs and in vertical lists. Therefore, in the logic of word processing and most text editors, newline is used as a paragraph break and is known as a \"hard return\", in contrast to \"soft returns\" which are dynamically created to implement word wrapping and are changeable with each display instance. In many applications a separate control character called \"manual line break\" exists for forcing line breaks inside a single paragraph. The glyph for the control character for a hard return is usually a pilcrow (¶), and for the manual line break is usually a carriage return arrow (↵).\n\nRI (U+008D REVERSE LINE FEED,[30] ISO/IEC 6429 8D, decimal 141) is used to move the printing position back one line (by reverse feeding the paper, or by moving a display cursor up one line) so that other characters may be printed over existing text. This may be done to make them bolder, or to add underlines, strike-throughs or other characters such as diacritics.\n\nSimilarly, PLD (U+008B PARTIAL LINE FORWARD, decimal 139) and PLU (U+008C PARTIAL LINE BACKWARD, decimal 140) can be used to advance or reverse the text printing position by some fraction of the vertical line spacing (typically, half). These can be used in combination for subscripts (by advancing and then reversing) and superscripts (by reversing and then advancing), and may also be useful for printing diacritics.\n\nEnd-of-file\n\nEnter key\n\nPage break"
    }
}