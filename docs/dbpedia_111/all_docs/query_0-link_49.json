{
    "id": "dbpedia_111_0",
    "rank": 49,
    "data": {
        "url": "https://en.wikipedia.org/wiki/Filename",
        "read_more_link": "",
        "language": "en",
        "title": "Wikipedia",
        "top_image": "https://upload.wikimedia.org/wikipedia/commons/1/10/Dir_command_in_Windows_Command_Prompt.png",
        "meta_img": "https://upload.wikimedia.org/wikipedia/commons/1/10/Dir_command_in_Windows_Command_Prompt.png",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/10/Dir_command_in_Windows_Command_Prompt.png/220px-Dir_command_in_Windows_Command_Prompt.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/EMule_v.049b.JPG/220px-EMule_v.049b.JPG",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Wiktionary-logo-en-v2.svg/40px-Wiktionary-logo-en-v2.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2003-10-28T10:49:05+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/Filename",
        "text": "Text string used to uniquely identify a computer file\n\nA filename or file name is a name used to uniquely identify a computer file in a file system. Different file systems impose different restrictions on filename lengths.\n\nA filename may (depending on the file system) include:\n\nname – base name of the file\n\nextension – may indicate the format of the file (e.g. .txt for plain text, .pdf for Portable Document Format, .dat for unspecified binary data, etc.)\n\nThe components required to identify a file by utilities and applications varies across operating systems, as does the syntax and format for a valid filename.\n\nThe characters allowed in filenames depend on the file system. The letters A–Z and digits 0–9 are allowed by most file systems; many file systems support additional characters, such as the letters a–z, special characters, and other printable characters such as accented letters, symbols in non-Roman alphabets, and symbols in non-alphabetic scripts. Some file systems allow even unprintable characters, including Bell, Null, Return and Linefeed, to be part of a filename,[1] although most utilities do not handle them well.\n\nFilenames may include things like a revision or generation number of the file such as computer code, a numerical sequence number (widely used by digital cameras through the DCF standard), a date and time (widely used by smartphone camera software and for screenshots), or a comment such as the name of a subject or a location or any other text to help identify the file.\n\nSome people use the term filename when referring to a complete specification of device, subdirectories and filename such as the Windows C:\\Program Files\\Microsoft Games\\Chess\\Chess.exe. The filename in this case is Chess.exe. Some utilities have settings to suppress the extension as with MS Windows Explorer.[not verified in body]\n\nHistory\n\n[edit]\n\nDuring the 1970s, some mainframe and minicomputers had operating systems where files on the system were identified by a user name, or account number.\n\nFor example, on the TOPS-10 and RSTS/E operating systems from Digital Equipment Corporation, files were identified by\n\noptional device name (one or two characters) followed by an optional unit number, and a colon \":\". If not present, it was presumed to be SY:\n\nthe account number, consisting of a bracket \"[\", a pair of numbers separated by a comma, and followed by a close bracket \"]\". If omitted, it was presumed to be yours.\n\nmandatory file name, consisting of 1 to 6 characters (upper-case letters or digits)\n\noptional 3-character extension.\n\nOn the OS/VS1, MVS, and OS/390 operating systems from IBM, a file name was up to 44 characters, consisting of upper case letters, digits, and the period. A file name must start with a letter or number, a period must occur at least once each 8 characters, two consecutive periods could not appear in the name, and must end with a letter or digit.[2] By convention, the letters and numbers before the first period was the account number of the owner or the project it belonged to, but there was no requirement to use this convention.[3]\n\nOn the McGill University MUSIC/SP system, file names consisted of\n\nOptional account number, which was one to four characters followed by a colon.If the account number was missing, it was presumed to be in your account, but if it was not, it was presumed to be in the *COM: pseudo-account, which is where all files marked as public were catalogued.\n\n1–17 character file name, which could be upper case letters or digits, and the period, with the requirement it not begin or end with a period, or have two consecutive periods.\n\nThe Univac VS/9 operating system had file names consisting of\n\nAccount name, consisting of a dollar sign \"$\", a 1-7 character (letter or digit) username, and a period (\".\"). If not present it was presumed to be in your account, but if it was not, the operating system would look in the system manager's account $TSOS. If you typed in a dollar sign only as the account, this would indicate the file was in the $TSOS account unless the first 1–7 character of the file name before the first period matched an actual account name, then that account was used, e.g. ABLE.BAKER is a file in your account, but if not there the system would search for $TSOS.ABLE.BAKER, but if $ABLE.BAKER was specified, the file $TSOS.ABLE.BAKER would be used unless $ABLE was a valid account, then it would look for a file named BAKER in that account.\n\nFile name, 1–56 characters (letters and digits) separated by periods. File names cannot start or end with a period, nor can two consecutive periods appear.\n\nIn 1985, RFC 959 officially defined a pathname to be the character string that must be entered into a file system by a user in order to identify a file.[4]\n\nOn early personal computers using the CP/M operating system, filenames were always 11 characters. This was referred to as the 8.3 filename with a maximum of an 8 byte name and a maximum of a 3 byte extension. Utilities and applications allowed users to specify filenames without trailing spaces and include a dot before the extension. The dot was not actually stored in the directory. Using only 7 bit characters allowed several file attributes to be included in the actual filename by using the high-order-bit; these attributes included Readonly, Archive, and System.[5] Eventually this was too restrictive and the number of characters allowed increased. The attribute bits were moved to a special block of the file including additional information.[citation needed]\n\nThe original File Allocation Table (FAT) file system, used by Standalone Disk BASIC-80, had a 6.3 file name, with a maximum of 6 bytes in the name and a maximum of 3 bytes in the extension. The FAT12 and FAT16 file systems in IBM PC DOS/MS-DOS and Microsoft Windows prior to Windows 95 used the same 8.3 convention as the CP/M file system. The FAT file systems supported 8-bit characters, allowing them to support non-ASCII characters in file names, and stored the attributes separately from the file name.\n\nAround 1995, VFAT, an extension to the MS-DOS FAT filesystem, was introduced in Windows 95 and Windows NT. It allowed mixed-case long filenames (LFNs), using Unicode characters, in addition to classic \"8.3\" names.\n\nReferences: absolute vs relative\n\n[edit]\n\nMain article: Path (computing)\n\nAn absolute reference includes all directory levels. In some systems, a filename reference that does not include the complete directory path defaults to the current working directory. This is a relative reference. One advantage of using a relative reference in program configuration files or scripts is that different instances of the script or program can use different files.\n\nThis makes an absolute or relative path composed of a sequence of filenames.\n\nNumber of names per file\n\n[edit]\n\nUnix-like file systems allow a file to have more than one name; in traditional Unix-style file systems, the names are hard links to the file's inode or equivalent. Windows supports hard links on NTFS file systems, and provides the command fsutil in Windows XP, and mklink in later versions, for creating them.[6][7] Hard links are different from Windows shortcuts, classic Mac OS/macOS aliases, or symbolic links. The introduction of LFNs with VFAT allowed filename aliases. For example, longfi~1.??? with a maximum of eight plus three characters was a filename alias of \"long file name.???\" as a way to conform to 8.3 limitations for older programs.\n\nThis property was used by the move command algorithm that first creates a second filename and then only removes the first filename.\n\nOther filesystems, by design, provide only one filename per file, which guarantees that alteration of one filename's file does not alter the other filename's file.\n\nLength restrictions\n\n[edit]\n\nSome filesystems restrict the length of filenames. In some cases, these lengths apply to the entire file name, as in 44 characters in IBM z/OS.[2] In other cases, the length limits may apply to particular portions of the filename, such as the name of a file in a directory, or a directory name. For example, 9 (e.g., 8-bit FAT in Standalone Disk BASIC), 11 (e.g. FAT12, FAT16, FAT32 in DOS), 14 (e.g. early Unix), 21 (Human68K), 31, 30 (e.g. Apple DOS 3.2 and 3.3), 15 (e.g. Apple ProDOS), 44 (e.g. IBM S/370),[2] or 255 (e.g. early Berkeley Unix) characters or bytes. Length limits often result from assigning fixed space in a filesystem to storing components of names, so increasing limits often requires an incompatible change, as well as reserving more space.\n\nA particular issue with filesystems that store information in nested directories is that it may be possible to create a file with a complete pathname that exceeds implementation limits, since length checking may apply only to individual parts of the name rather than the entire name. Many Windows applications are limited to a MAX_PATH value of 260, but Windows file names can easily exceed this limit.[8] From Windows 10, version 1607, MAX_PATH limitations have been removed.[9]\n\nFilename extensions\n\n[edit]\n\nMain article: Filename extension\n\nFilenames in some file systems, such as FAT and the ODS-1 and ODS-2 levels of Files-11, are composed of two parts: a base name or stem and an extension or suffix used by some applications to indicate the file type. Some other file systems, such as Unix file systems, VFAT, and NTFS, treat a filename as a single string; a convention often used on those file systems is to treat the characters following the last period in the filename, in a filename containing periods, as the extension part of the filename.\n\nMultiple output files created by an application may use the same basename and various extensions. For example, a Fortran compiler might use the extension FOR for source input file, OBJ for the object output and LST for the listing. Although there are some common extensions, they are arbitrary and a different application might use REL and RPT. Extensions have been restricted, at least historically on some systems, to a length of 3 characters, but in general can have any length, e.g., html.\n\nEncoding interoperability\n\n[edit]\n\nThere is no general encoding standard for filenames.\n\nFile names have to be exchanged between software environments for network file transfer, file system storage, backup and file synchronization software, configuration management, data compression and archiving, etc. It is thus very important not to lose file name information between applications. This led to wide adoption of Unicode as a standard for encoding file names, although legacy software might not be Unicode-aware.\n\nEncoding indication interoperability\n\n[edit]\n\nTraditionally, filenames allowed any character in their filenames as long as they were file system safe.[10] Although this permitted the use of any encoding, and thus allowed the representation of any local text on any local system, it caused many interoperability issues.\n\nA filename could be stored using different byte strings in distinct systems within a single country, such as if one used Japanese Shift JIS encoding and another Japanese EUC encoding. Conversion was not possible as most systems did not expose a description of the encoding used for a filename as part of the extended file information. This forced costly filename encoding guessing with each file access.[10]\n\nA solution was to adopt Unicode as the encoding for filenames.\n\nIn the classic Mac OS, however, encoding of the filename was stored with the filename attributes.[10]\n\nUnicode interoperability\n\n[edit]\n\nThe Unicode standard solves the encoding determination issue.\n\nNonetheless, some limited interoperability issues remain, such as normalization (equivalence), or the Unicode version in use. For instance, UDF is limited to Unicode 2.0; macOS's HFS+ file system applies NFD Unicode normalization and is optionally case-sensitive (case-insensitive by default.) Filename maximum length is not standard and might depend on the code unit size. Although it is a serious issue, in most cases this is a limited one.[10]\n\nOn Linux, this means the filename is not enough to open a file: additionally, the exact byte representation of the filename on the storage device is needed. This can be solved at the application level, with some tricky normalization calls.[11]\n\nThe issue of Unicode equivalence is known as \"normalized-name collision\". A solution is the Non-normalizing Unicode Composition Awareness used in the Subversion and Apache technical communities.[12] This solution does not normalize paths in the repository. Paths are only normalized for the purpose of comparisons. Nonetheless, some communities have patented this strategy, forbidding its use by other communities.[clarification needed]\n\nPerspectives\n\n[edit]\n\nTo limit interoperability issues, some ideas described by Sun are to:\n\nuse one Unicode encoding (such as UTF-8)\n\ndo transparent code conversions on filenames\n\nstore no normalized filenames\n\ncheck for canonical equivalence among filenames, to avoid two canonically equivalent filenames in the same directory.[10]\n\nThose considerations create a limitation not allowing a switch to a future encoding different from UTF-8.\n\nUnicode migration\n\n[edit]\n\nOne issue was migration to Unicode. For this purpose, several software companies provided software for migrating filenames to the new Unicode encoding.\n\nMicrosoft provided migration transparent for the user throughout the VFAT technology\n\nApple provided \"File Name Encoding Repair Utility v1.0\".[13]\n\nThe Linux community provided \"convmv\".[14]\n\nMac OS X 10.3 marked Apple's adoption of Unicode 3.2 character decomposition, superseding the Unicode 2.1 decomposition used previously. This change caused problems for developers writing software for Mac OS X.[15]\n\nUniqueness\n\n[edit]\n\nWithin a single directory, filenames must be unique. Since the filename syntax also applies for directories, it is not possible to create a file and directory entries with the same name in a single directory. Multiple files in different directories may have the same name.\n\nUniqueness approach may differ both on the case sensitivity and on the Unicode normalization form such as NFC, NFD. This means two separate files might be created with the same text filename and a different byte implementation of the filename, such as L\"\\x00C0.txt\" (UTF-16, NFC) (Latin capital A with grave) and L\"\\x0041\\x0300.txt\" (UTF-16, NFD) (Latin capital A, grave combining).[16]\n\nLetter case preservation\n\n[edit]\n\nSome filesystems, such as FAT, store filenames as upper-case regardless of the letter case used to create them. For example, a file created with the name \"MyName.Txt\" or \"myname.txt\" would be stored with the filename \"MYNAME.TXT\". Any variation of upper and lower case can be used to refer to the same file. These kinds of file systems are called case-insensitive and are not case-preserving. Some filesystems prohibit the use of lower case letters in filenames altogether.\n\nSome file systems store filenames in the form that they were originally created; these are referred to as case-retentive or case-preserving. Such a file system can be case-sensitive or case-insensitive. If case-sensitive, then \"MyName.Txt\" and \"myname.txt\" may refer to two different files in the same directory, and each file must be referenced by the exact capitalization by which it is named. On a case-insensitive, case-preserving file system, on the other hand, only one of \"MyName.Txt\", \"myname.txt\" and \"Myname.TXT\" can be the name of a file in a given directory at a given time, and a file with one of these names can be referenced by any capitalization of the name.\n\nFrom its original inception, Unix and its derivative systems were case-preserving. However, not all Unix-like file systems are case-sensitive; by default, HFS+ in macOS is case-insensitive, and SMB servers usually provide case-insensitive behavior (even when the underlying file system is case-sensitive, e.g. Samba on most Unix-like systems), and SMB client file systems provide case-insensitive behavior. File system case sensitivity is a considerable challenge for software such as Samba and Wine, which must interoperate efficiently with both systems that treat uppercase and lowercase files as different and with systems that treat them the same.[17]\n\nReserved characters and words\n\n[edit]\n\n\"Reserved characters\" redirects here. For characters that cannot be used in page titles on Wikipedia, see Wikipedia:Naming conventions (technical restrictions) § Forbidden characters.\n\nFile systems have not always provided the same character set for composing a filename. Before Unicode became a de facto standard, file systems mostly used a locale-dependent character set. By contrast, some new systems permit a filename to be composed of almost any character of the Unicode repertoire, and even some non-Unicode byte sequences. Limitations may be imposed by the file system, operating system, application, or requirements for interoperability with other systems.\n\nMany file system utilities prohibit control characters from appearing in filenames. In Unix-like file systems, the null character[18] and the path separator / are prohibited.\n\nProblematic characters\n\n[edit]\n\nFile system utilities and naming conventions on various systems prohibit particular characters from appearing in filenames or make them problematic:[8] Except as otherwise stated, the symbols in the Character column, \" and < for example, cannot be used in Windows filenames.\n\nCharacter Name Reason for prohibition / slash Used as a path name component separator in Unix-like, Windows, and Amiga systems. (For as long as the SwitChar setting is set to /, the DOS COMMAND.COM shell would consume it as a switch character, but DOS and Windows themselves always accept it as a separator on API level.)\n\nThe big solidus ⧸ (Unicode code point U+29F8) is permitted in Windows filenames. \\ backslash Used as the default path name component separator in DOS, OS/2 and Windows (even if the SwitChar is set to '-'; allowed in Unix filenames, see Note 1).\n\nThe big reverse solidus ⧹ (U+29F9) is permitted in Windows filenames. ? question mark Used as a wildcard in Unix, Windows and AmigaOS; marks a single character. Allowed in Unix filenames, see Note 1.\n\nThe glottal stop ʔ (U+0294), the interrobang ‽ (U+203D), the inverted question mark ¿ (U+00BF), the double question mark ⁇ (U+2047), and the black question mark ornament❓(U+2753) are allowed in all filenames. % percent Used as a wildcard in RT-11; marks a single character. Not special on Windows. * asterisk\n\nor star Used as a wildcard in Unix, DOS, RT-11, VMS and Windows. Marks any sequence of characters (Unix, Windows, DOS) or any sequence of characters in either the basename or extension (thus *.* in DOS means \"all files\"). Allowed in Unix filenames, see Note 1.\n\nSee Star (glyph) for many asterisk-like characters allowed in filenames. : colon Used to determine the mount point / drive on Windows; used to determine the virtual device or physical device such as a drive on AmigaOS, RT-11 and VMS; used as a pathname separator in classic Mac OS. Doubled after a name on VMS, indicates the DECnet nodename (equivalent to a NetBIOS [Windows networking] hostname preceded by \\\\.) Colon is also used in Windows to separate an alternative data stream from the main file.\n\nThe letter colon ꞉ (U+A789) and the ratio symbol ∶ (U+2236) are permitted in Windows filenames. In the Segoe UI font, used in Windows Explorer, the glyphs for the colon and the letter colon are identical. | vertical bar\n\nor pipe Designates software pipelining in Unix, DOS and Windows; allowed in Unix filenames, see Note 1. The mathematical operator divides ∣ (U+2223) is permitted in Windows filenames. \" straight double quote A legacy restriction carried over from DOS. The single quotes ' (U+0027), ‘ (U+2018), and ’ (U+2019) and the curved double quotes left double quotation mark “ (U+201C) and right double quotation mark ” (U+201D) are permitted anywhere in filenames. See Note 1. < less than Used to redirect input, allowed in Unix filenames, see Note 1. The spacing modifier letter left arrowhead ˂ (U+02C2) is permitted in Windows filenames. > greater than Used to redirect output, allowed in Unix filenames, see Note 1. The spacing modifier letter right arrowhead ˃ (U+02C3) is permitted in Windows filenames. . period\n\nor dot Folder names cannot end with a period in Windows, though the name can end with a period followed by a whitespace character such as a non-breaking space. Elsewhere, the period is allowed, but the last occurrence will be interpreted to be the extension separator in VMS, DOS, and Windows. In other OSes, usually considered as part of the filename, and more than one period (full stop) may be allowed. In Unix, a leading period means the file or folder is normally hidden. , comma Allowed, but treated as separator by the command line interpreters COMMAND.COM and CMD.EXE on DOS and Windows. ; semicolon Allowed, but treated as separator by the command line interpreters Bourne shell (and compatibles) and C shell (and compatibles) on Unix-like systems, and COMMAND.COM and CMD.EXE on DOS and Windows. See Note 1. = equals sign Allowed, but treated as separator by the command line interpreters COMMAND.COM and CMD.EXE on DOS and Windows. space\n\nAllowed, but the space is also used as a parameter separator in command line applications; see Note 1.\n\nNote 1: While they are allowed in Unix file and folder names, most Unix shells require specific characters such as spaces, <, >, |, \\, and sometimes :, (, ), &, ;, #, as well as wildcards such as ? and *, to be quoted or escaped:\n\nfive\\ and\\ six\\<seven (example of escaping)\n\n'five and six<seven' or \"five and six<seven\" (examples of quoting)\n\nThe character å (0xE5) was not allowed as the first letter in a filename under 86-DOS and MS-DOS/PC DOS 1.x-2.x, but can be used in later versions.\n\nIn Windows utilities, the space and the period are not allowed as the final character of a filename.[19] The period is allowed as the first character, but some Windows applications, such as Windows Explorer, forbid creating or renaming such files (despite this convention being used in Unix-like systems to describe hidden files and directories). Workarounds include appending a dot when renaming the file (that is then automatically removed afterwards), using alternative file managers, creating the file using the command line, or saving a file with the desired filename from within an application.[20]\n\nSome file systems on a given operating system (especially file systems originally implemented on other operating systems), and particular applications on that operating system, may apply further restrictions and interpretations. See comparison of file systems for more details on restrictions.\n\nIn Unix-like systems, DOS, and Windows, the filenames \".\" and \"..\" have special meanings (current and parent directory respectively). Windows 95/98/ME also uses names like \"...\", \"....\" and so on to denote grandparent or great-grandparent directories.[21] All Windows versions forbid creation of filenames that consist of only dots, although names consisting of three dots (\"...\") or more are legal in Unix.\n\nIn addition, in Windows and DOS utilities, some words are also reserved and cannot be used as filenames.[20] For example, DOS device files:[22]\n\nCON, CONIN$, CONOUT$, PRN, AUX, CLOCK$, NUL COM0, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9[8] LPT0, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, LPT9[8] LST (only in 86-DOS and DOS 1.xx) KEYBD$, SCREEN$ (only in multitasking MS-DOS 4.0) $IDLE$ (only in Concurrent DOS 386, Multiuser DOS and DR DOS 5.0 and higher) CONFIG$ (only in MS-DOS 7.0-8.0)\n\nSystems that have these restrictions cause incompatibilities with some other filesystems. For example, Windows will fail to handle, or raise error reports for, these legal UNIX filenames: aux.c,[23] q\"uote\"s.txt, or NUL.txt.\n\nNTFS filenames that are used internally include:\n\n$Mft, $MftMirr, $LogFile, $Volume, $AttrDef, $Bitmap, $Boot, $BadClus, $Secure, $Upcase, $Extend, $Quota, $ObjId and $Reparse\n\nComparison of filename limitations\n\n[edit]\n\nMain article: Comparison of file systems\n\nSystem Case\n\nsensitive Case\n\npreserving Allowed character set Reserved characters Reserved words Maximum length (characters) Comments 8-bit FAT ? ? 7-bit ASCII (but stored as bytes) first character not allowed to be 0x00 or 0xFF 9 Maximum 9 character base name limit for sequential files (without extension), or maximum 6 and 3 character extension for binary files; see 6.3 filename FAT12, FAT16, FAT32 No No any SBCS/DBCS OEM codepage 0x00–0x1F 0x7F \" * / : < > ? \\ | + , . ; = [ ] (in some environments also: ! @; DOS 1/2 did not allow 0xE5 as first character) Device names including: $IDLE$ AUX COM1...COM4 CON CONFIG$ CLOCK$ KEYBD$ LPT1...LPT4 LST NUL PRN SCREEN$ (depending on AVAILDEV status everywhere or only in virtual \\DEV\\ directory) 11 Maximum 8 character base name limit and 3 character extension; see 8.3 filename VFAT No Yes Unicode, using UCS-2 encoding 0x00–0x1F 0x7F \" * / : < > ? \\ | 255 exFAT No Yes Unicode, using UTF-16 encoding 0x00–0x1F 0x7F \" * / : < > ? \\ | 255 NTFS Optional Yes Unicode, using UTF-16 encoding 0x00–0x1F 0x7F \" * / : < > ? \\ | Only in root directory: $AttrDef $BadClus $Bitmap $Boot $LogFile $MFT $MFTMirr pagefile.sys $Secure $UpCase $Volume $Extend $Extend\\$ObjId $Extend\\$Quota $Extend\\$Reparse ($Extend is a directory) 255 Paths can be up to 32,000 characters.\n\nForbids the use of characters in range 1–31 (0x01–0x1F) and characters \" * / : < > ? \\ | unless the name is flagged as being in the Posix namespace. NTFS allows each path component (directory or filename) to be 255 characters long [dubious – discuss].\n\nWindows forbids the use of the MS-DOS device names AUX, COM0, ..., COM9, COM¹, ..., COM³, CON, LPT0, ..., LPT9, LPT¹, ..., LPT³, NUL and PRN. These names with an extension (for example, AUX.txt), are allowed but not recommended.[24] The Win32 API strips trailing period (full-stop), and leading and trailing space characters from filenames, except when UNC paths are used. These restrictions only apply to Windows; in Linux distributions that support NTFS, filenames are written using NTFS's Posix namespace, which allows any Unicode character except / and NUL.\n\nOS/2 HPFS No Yes any 8-bit set |\\?*<\":>/ 254 Mac OS HFS No Yes any 8-bit set : 255 old versions of Finder are limited to 31 characters HFS+ Optional Yes Unicode, using UTF-16 encoding : on disk, in classic Mac OS, and at the Carbon layer in macOS; / at the Unix layer in macOS 255 Mac OS 8.1 - macOS APFS Optional Yes Unicode, using UTF-8 encoding[25] In the Finder, filenames containing / can be created, but / is stored as a colon (:) in the filesystem, and is shown as such on the command line. Filenames containing : created from the command line are shown with / instead of : in the Finder, so that it is impossible to create a file that the Finder shows as having a : in its filename. 255 macOS Sierra (10.12.4) and later, iOS 10.3 and later, tvOS 10.2 and later, watchOS 3.2 and later, iPadOS most UNIX file systems Yes Yes any 8-bit set / null 255 a leading . indicates that ls and file managers will not show the file by default z/OS classic MVS filesystem (datasets) No No EBCDIC code pages other than $ # @ - x'C0' 44 first character must be alphabetic or national ($, #, @)\n\n\"Qualified\" contains . after every 8 characters or fewer.[2] Partitioned data sets (PDS or PDSE) are divided into members with names of up to 8 characters; the member name is placed in parenthesises after the name of the PDS, e.g. PAYROLL.DEV.CBL(PROG001)\n\nCMS file system No No EBCDIC code pages 8 + 8 Single-level directory structure with disk letters (A–Z). Maximum of 8 character file name with maximum 8 character file type, separated by whitespace. For example, a TEXT file called MEMO on disk A would be accessed as \"MEMO TEXT A\". (Later versions of VM introduced hierarchical filesystem structures, SFS and BFS, but the original flat directory \"minidisk\" structure is still widely used.) early UNIX (AT&T Corporation) Yes Yes any 8-bit set / 14 a leading . indicates a \"hidden\" file POSIX \"Fully portable filenames\"[26] Yes Yes A–Z a–z 0–9 . _ - / null 14 hyphen must not be first character. A command line utility checking for conformance, \"pathchk\", is part of the IEEE 1003.1 standard and of The Open Group Base Specifications[27] ISO 9660 No ? A–Z 0–9 _ . \"close to 180\"(Level 2) or 200(Level 3) Used on CDs; 8 directory levels max (for Level 1, not level 2,3) Amiga OFS No Yes any 8-bit set : / null 30 Original File System 1985 Amiga FFS No Yes any 8-bit set : / null 30 Fast File System 1988 Amiga PFS No Yes any 8-bit set : / null 107 Professional File System 1993 Amiga SFS No Yes any 8-bit set : / null 107 Smart File System 1998 Amiga FFS2 No Yes any 8-bit set : / null 107 Fast File System 2 2002 BeOS BFS Yes Yes Unicode, using UTF-8 encoding / 255 DEC PDP-11 RT-11 No No RADIX-50 6 + 3 Flat filesystem with no subdirs. A full \"file specification\" includes device, filename and extension (file type) in the format: dev:filnam.ext. DEC VAX VMS No From\n\nv7.2 A–Z 0–9 $ - _ 32 per component; earlier 9 per component; latterly, 255 for a filename and 32 for an extension. a full \"file specification\" includes nodename, diskname, directory/ies, filename, extension and version in the format: OURNODE::MYDISK:[THISDIR.THATDIR]FILENAME.EXTENSION;2 Directories can only go 8 levels deep. Commodore DOS Yes Yes any 8-bit set :, = $ 16 length depends on the drive, usually 16 HP 250 Yes Yes any 8-bit set SPACE \", : NULL CHR$(255) 6 Disks and tape drives are addressed either using a label (up to 8 characters) or a unit specification. The HP 250 file system does not use directories, nor does it use extensions to indicate file type. Instead the type is an attribute (e.g. DATA, PROG, BKUP or SYST for data files, program files, backups and the OS itself).[28]\n\nSee also\n\n[edit]\n\nFile system\n\nFully qualified file name\n\nLong filename\n\nPath (computing)\n\nSlug (Web publishing)\n\nSymbolic link\n\nUniform Resource Identifier (URI)\n\nUniform Resource Locator (URL) and Internationalized resource identifier\n\nWindows (Win32) File Naming Conventions (Filesystem Agnostic)\n\nReferences\n\n[edit]"
    }
}