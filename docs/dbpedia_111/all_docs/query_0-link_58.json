{
    "id": "dbpedia_111_0",
    "rank": 58,
    "data": {
        "url": "https://en.wikipedia.org/wiki/ANSI_escape_code",
        "read_more_link": "",
        "language": "en",
        "title": "ANSI escape code",
        "top_image": "https://upload.wikimedia.org/wikipedia/commons/b/b1/Htop.png",
        "meta_img": "https://upload.wikimedia.org/wikipedia/commons/b/b1/Htop.png",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Htop.png/250px-Htop.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/DEC_VT100_terminal.jpg/220px-DEC_VT100_terminal.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/XtermMenus.png/220px-XtermMenus.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/34/ANSI_sample_program_output.png/220px-ANSI_sample_program_output.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/96/Symbol_category_class.svg/16px-Symbol_category_class.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/0/04/Ecma_International_Logo.svg/100px-Ecma_International_Logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/96/Symbol_category_class.svg/16px-Symbol_category_class.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2002-07-30T05:24:56+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/ANSI_escape_code",
        "text": "Method used for display options on video text terminals\n\n\"ANSI code\" redirects here. For other uses, see ANSI (disambiguation).\n\nANSI X3.64 (ISO/IEC 6429)StandardClassificationISO/IEC 2022 based control code and control sequence setOther related encoding(s)\n\nITU T.61\n\nISO/IEC 8613-6 / ITU T.416\n\nOther control function standards:\n\nANSI escape sequences are a standard for in-band signaling to control cursor location, color, font styling, and other options on video text terminals and terminal emulators. Certain sequences of bytes, most starting with an ASCII escape character and a bracket character, are embedded into text. The terminal interprets these sequences as commands, rather than text to display verbatim.\n\nANSI sequences were introduced in the 1970s to replace vendor-specific sequences and became widespread in the computer equipment market by the early 1980s. They are used in development, scientific, commercial text-based applications as well as bulletin board systems to offer standardized functionality.\n\nAlthough hardware text terminals have become increasingly rare in the 21st century, the relevance of the ANSI standard persists because a great majority of terminal emulators and command consoles interpret at least a portion of the ANSI standard.\n\nHistory\n\n[edit]\n\nAlmost all manufacturers of video terminals added vendor-specific escape sequences to perform operations such as placing the cursor at arbitrary positions on the screen. One example is the VT52 terminal, which allowed the cursor to be placed at an x,y location on the screen by sending the ESC character, a Y character, and then two characters representing numerical values equal to the x,y location plus 32 (thus starting at the ASCII space character and avoiding the control characters). The Hazeltine 1500 had a similar feature, invoked using ~, DC1 and then the X and Y positions separated with a comma. While the two terminals had identical functionality in this regard, different control sequences had to be used to invoke them.\n\nAs these sequences were different for different terminals, elaborate libraries such as termcap (\"terminal capabilities\") and utilities such as tput had to be created so programs could use the same API to work with any terminal. In addition, many of these terminals required sending numbers (such as row and column) as the binary values of the characters; for some programming languages, and for systems that did not use ASCII internally, it was often difficult to turn a number into the correct character.\n\nThe ANSI standard attempted to address these problems by making a command set that all terminals would use and requiring all numeric information to be transmitted as ASCII numbers. The first standard in the series was ECMA-48, adopted in 1976.[1] It was a continuation of a series of character coding standards, the first one being ECMA-6 from 1965, a 7-bit standard from which ISO 646 originates. The name \"ANSI escape sequence\" dates from 1979 when ANSI adopted ANSI X3.64. The ANSI X3L2 committee collaborated with the ECMA committee TC 1 to produce nearly identical standards. These two standards were merged into an international standard, ISO 6429.[1] In 1994, ANSI withdrew its standard in favor of the international standard.\n\nThe first popular video terminal to support these sequences was the Digital VT100, introduced in 1978.[2] This model was very successful in the market, which sparked a variety of VT100 clones, among the earliest and most popular of which was the much more affordable Zenith Z-19 in 1979.[3] Others included the Qume QVT-108, Televideo TVI-970, Wyse WY-99GT as well as optional \"VT100\" or \"VT103\" or \"ANSI\" modes with varying degrees of compatibility on many other brands. The popularity of these gradually led to more and more software (especially bulletin board systems and other online services) assuming the escape sequences worked, leading to almost all new terminals and emulator programs supporting them.\n\nIn 1981, ANSI X3.64 was adopted for use in the US government by FIPS publication 86. Later, the US government stopped duplicating industry standards, so FIPS pub. 86 was withdrawn.[4]\n\nECMA-48 has been updated several times and is currently at its 5th edition, from 1991. It is also adopted by ISO and IEC as standard ISO/IEC 6429.[5] A version is adopted as a Japanese Industrial Standard, as JIS X 0211.\n\nRelated standards include ITU T.61, the Teletex standard, and the ISO/IEC 8613, the Open Document Architecture standard (mainly ISO/IEC 8613-6 or ITU T.416). The two systems share many escape codes with the ANSI system, with extensions that are not necessarily meaningful to computer terminals. Both systems quickly fell into disuse, but ECMA-48 does mark the extensions used in them as reserved.\n\nPlatform support\n\n[edit]\n\nIn the early 1980s, large amounts of software directly used these sequences to update screen displays. This included everything on VMS (which assumed Dec terminals), most software designed to be portable on CP/M home computers, and even lots of Unix software as it was easier to use than the termcap libraries, such as the shell script examples below in this article.\n\nTerminal emulators for communicating with remote machines almost always implement ANSI escape codes. This includes anything written to communicate with bulletin-board systems on home and personal computers. On Unix terminal emulators such as xterm also can communicate with software running on the same machine, and thus software running in X11 under a terminal emulator could assume the ability to write these sequences.\n\nAs computers got more powerful even built-in displays started supporting them, allowing software to be portable between CP/M systems. There were attempts to extend the escape sequences to support printers[6] and as an early PDF-like document storage format, the Open Document Architecture.[citation needed]\n\nDOS and Windows\n\n[edit]\n\nThe IBM PC, introduced in 1983, did not support these or any other escape sequences for updating the screen. Only a few control characters (BEL, CR, LF, BS) were interpreted by the underlying BIOS. Any display effects had to be done with BIOS calls, which were notoriously slow, or by directly manipulating the IBM PC hardware. This made any interesting software non-portable and led to the need to duplicate details of the display hardware in PC Clones.\n\nDOS version 2.0 included optional support with a device driver named ANSI.SYS. Poor performance, and the fact that it was not installed by default, meant software rarely took advantage of it. Some other systems did try to address the need for these sequences, many clones of DOS handled them without a driver, and OS/2 had an ANSI command that enabled the sequences.\n\nThe Windows Console did not support ANSI escape sequences, nor did Microsoft provide any method to enable them. Some replacements or additions for the console window such as JP Software's TCC (formerly 4NT), Michael J. Mefford's ANSI.COM, Jason Hood's ANSICON[7] and Maximus5's ConEmu interpreted ANSI escape sequences printed by programs. A Python package named colorama[8] internally interprets ANSI escape sequences in text being printed, translating them to win32 calls to modify the state of the terminal, to make it easier to port Python code using ANSI to Windows. Cygwin performs similar translation to all output written to the console using Cygwin file descriptors, the filtering is done by the output functions of cygwin1.dll, to allow porting of POSIX C code to Windows.\n\nIn 2016, Microsoft released the Windows 10 version 1511 update which unexpectedly implemented support for ANSI escape sequences, over two decades after the debut of Windows NT.[9] This was done alongside Windows Subsystem for Linux, apparently to allow Unix-like terminal-based software to use the Windows Console. Windows PowerShell 5.1 enabled this by default, and PowerShell 6 made it possible to embed the necessary ESC character into a string with `e.[10]\n\nWindows Terminal, introduced in 2019, supports the sequences by default, and Microsoft intends to replace the Windows Console with Windows Terminal.[11]\n\nDescription\n\n[edit]\n\nC0 control codes\n\n[edit]\n\nAlmost all users assume some functions of some single-byte characters. Initially defined as part of ASCII, the default C0 control code set is now defined in ISO 6429 (ECMA-48), making it part of the same standard as the C1 set invoked by the ANSI escape sequences (although ISO 2022 allows the ISO 6429 C0 set to be used without the ISO 6429 C1 set, and vice versa, provided that 0x1B is always ESC). This is used to shorten the amount of data transmitted, or to perform some functions that are unavailable from escape sequences:\n\nPopular C0 control codes (not an exhaustive list) ^ C0 Abbr Name Effect ^G 0x07 BEL Bell Makes an audible noise. ^H 0x08 BS Backspace Moves the cursor left (but may \"backwards wrap\" if cursor is at start of line). ^I 0x09 HT Tab Moves the cursor right to next multiple of 8. ^J 0x0A LF Line Feed Moves to next line, scrolls the display up if at bottom of the screen. Usually does not move horizontally, though programs should not rely on this. ^L 0x0C FF Form Feed Move a printer to top of next page. Usually does not move horizontally, though programs should not rely on this. Effect on video terminals varies. ^M 0x0D CR Carriage Return Moves the cursor to column zero. ^[ 0x1B ESC Escape Starts all the escape sequences\n\nEscape sequences vary in length. The general format for an ANSI-compliant escape sequence is defined by ANSI X3.41 (equivalent to ECMA-35 or ISO/IEC 2022).[12]: 13.1 The escape sequences consist only of bytes in the range 0x20—0x7F (all the non-control ASCII characters), and can be parsed without looking ahead. The behavior when a control character, a byte with the high bit set, or a byte that is not part of any valid sequence, is encountered before the end is undefined.\n\nFe Escape sequences\n\n[edit]\n\nIf the ESC is followed by a byte in the range 0x40 to 0x5F, the escape sequence is of type Fe. Its interpretation is delegated to the applicable C1 control code standard.[12]: 13.2.1 Accordingly, all escape sequences corresponding to C1 control codes from ANSI X3.64 / ECMA-48 follow this format.[5]: 5.3.a\n\nThe standard says that, in 8-bit environments, the control functions corresponding to type Fe escape sequences (those from the set of C1 control codes) can be represented as single bytes in the 0x80–0x9F range.[5]: 5.3.b This is possible in character encodings conforming to the provisions for an 8-bit code made in ISO 2022, such as the ISO 8859 series. However, in character encodings used on modern devices such as UTF-8 or CP-1252, those codes are often used for other purposes, so only the 2-byte sequence is typically used. In the case of UTF-8, representing a C1 control code via the C1 Controls and Latin-1 Supplement block results in a different two-byte code (e.g. 0xC2,0x8E for U+008E), but no space is saved this way.\n\nSome type Fe (C1 set element) ANSI escape sequences (not an exhaustive list) Code C1 Abbr Name Effect ESC N 0x8E SS2 Single Shift Two Select a single character from one of the alternative character sets. SS2 selects the G2 character set, and SS3 selects the G3 character set.[13] In a 7-bit environment, this is followed by one or more GL bytes (0x20–0x7F) specifying a character from that set.[12]: 9.4 In an 8-bit environment, these may instead be GR bytes (0xA0–0xFF).[12]: 8.4 ESC O 0x8F SS3 Single Shift Three ESC P 0x90 DCS Device Control String Terminated by ST.[5]: 5.6 Xterm's uses of this sequence include defining User-Defined Keys, and requesting or setting Termcap/Terminfo data.[13] ESC [ 0x9B CSI Control Sequence Introducer Starts most of the useful sequences, terminated by a byte in the range 0x40 through 0x7E.[5]: 5.4 ESC \\ 0x9C ST String Terminator Terminates strings in other controls.[5]: 8.3.143 ESC ] 0x9D OSC Operating System Command Starts a control string for the operating system to use, terminated by ST.[5]: 8.3.89 ESC X 0x98 SOS Start of String Takes an argument of a string of text, terminated by ST.[5]: 5.6 The uses for these string control sequences are defined by the application[5]: 8.3.2, 8.3.128 or privacy discipline.[5]: 8.3.94 These functions are rarely implemented and the arguments are ignored by xterm.[13] Some Kermit clients allow the server to automatically execute Kermit commands on the client by embedding them in APC sequences; this is a potential security risk if the server is untrusted.[14] ESC ^ 0x9E PM Privacy Message ESC _ 0x9F APC Application Program Command\n\nCSI (Control Sequence Introducer) sequences\n\n[edit]\n\nFor Control Sequence Introducer, or CSI, commands, the ESC [ (written as \\e[ or \\033[ in several programming languages) is followed by any number (including none) of \"parameter bytes\" in the range 0x30–0x3F (ASCII 0–9:;<=>?), then by any number of \"intermediate bytes\" in the range 0x20–0x2F (ASCII space and !\"#$%&'()*+,-./), then finally by a single \"final byte\" in the range 0x40–0x7E (ASCII @A–Z[\\]^_`a–z{|}~).[5]: 5.4\n\nAll common sequences just use the parameters as a series of semicolon-separated numbers such as 1;2;3. Missing numbers are treated as 0 (1;;3 acts like the middle number is 0, and no parameters at all in ESC[m acts like a 0 reset code). Some sequences (such as CUU) treat 0 as 1 in order to make missing parameters useful.[5]: F.4.2\n\nA subset of arrangements was declared \"private\" so that terminal manufacturers could insert their own sequences without conflicting with the standard. Sequences containing the parameter bytes <=>? or the final bytes 0x70–0x7E (p–z{|}~) are private.\n\nThe behavior of the terminal is undefined in the case where a CSI sequence contains any character outside of the range 0x20–0x7E. These illegal characters are either C0 control characters (the range 0–0x1F), DEL (0x7F), or bytes with the high bit set. Possible responses are to ignore the byte, to process it immediately, and furthermore whether to continue with the CSI sequence, to abort it immediately, or to ignore the rest of it.[citation needed]\n\nSome ANSI control sequences (not an exhaustive list) Code Abbr Name Effect CSI n A CUU Cursor Up Moves the cursor n (default 1) cells in the given direction. If the cursor is already at the edge of the screen, this has no effect. CSI n B CUD Cursor Down CSI n C CUF Cursor Forward CSI n D CUB Cursor Back CSI n E CNL Cursor Next Line Moves cursor to beginning of the line n (default 1) lines down. (not ANSI.SYS) CSI n F CPL Cursor Previous Line Moves cursor to beginning of the line n (default 1) lines up. (not ANSI.SYS) CSI n G CHA Cursor Horizontal Absolute Moves the cursor to column n (default 1). (not ANSI.SYS) CSI n ; m H CUP Cursor Position Moves the cursor to row n, column m. The values are 1-based, and default to 1 (top left corner) if omitted. A sequence such as CSI ;5H is a synonym for CSI 1;5H as well as CSI 17;H is the same as CSI 17H and CSI 17;1H CSI n J ED Erase in Display Clears part of the screen. If n is 0 (or missing), clear from cursor to end of screen. If n is 1, clear from cursor to beginning of the screen. If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS). If n is 3, clear entire screen and delete all lines saved in the scrollback buffer (this feature was added for xterm and is supported by other terminal applications). CSI n K EL Erase in Line Erases part of the line. If n is 0 (or missing), clear from cursor to the end of the line. If n is 1, clear from cursor to beginning of the line. If n is 2, clear entire line. Cursor position does not change. CSI n S SU Scroll Up Scroll whole page up by n (default 1) lines. New lines are added at the bottom. (not ANSI.SYS) CSI n T SD Scroll Down Scroll whole page down by n (default 1) lines. New lines are added at the top. (not ANSI.SYS) CSI n ; m f HVP Horizontal Vertical Position Same as CUP, but counts as a format effector function (like CR or LF) rather than an editor function (like CUD or CNL). This can lead to different handling in certain terminal modes.[5]: Annex A CSI n m SGR Select Graphic Rendition Sets colors and style of the characters following this code CSI 5i AUX Port On Enable aux serial port usually for local serial printer CSI 4i AUX Port Off Disable aux serial port usually for local serial printer CSI 6n DSR Device Status Report Reports the cursor position (CPR) by transmitting ESC[n;mR, where n is the row and m is the column.\n\nSome popular private sequences Code Abbr Name Effect CSI s SCP, SCOSC Save Current Cursor Position Saves the cursor position/state in SCO console mode.[15] In vertical split screen mode, instead used to set (as CSI n ; n s) or reset left and right margins.[16] CSI u RCP, SCORC Restore Saved Cursor Position Restores the cursor position/state in SCO console mode.[17] CSI ? 25 h DECTCEM Shows the cursor, from the VT220. CSI ? 25 l DECTCEM Hides the cursor. CSI ? 1004 h Enable reporting focus. Reports whenever terminal emulator enters or exits focus as ESC [I and ESC [O, respectively. CSI ? 1004 l Disable reporting focus. CSI ? 1049 h Enable alternative screen buffer, from xterm CSI ? 1049 l Disable alternative screen buffer, from xterm CSI ? 2004 h Turn on bracketed paste mode.[18] In bracketed paste mode, text pasted into the terminal will be surrounded by ESC [200~ and ESC [201~; programs running in the terminal should not treat characters bracketed by those sequences as commands (Vim, for example, does not treat them as commands).[19] From xterm[20] CSI ? 2004 l Turn off bracketed paste mode.\n\nSGR (Select Graphic Rendition) parameters\n\n[edit]\n\nThe control sequence CSI n m, named Select Graphic Rendition (SGR), sets display attributes. Several attributes can be set in the same sequence, separated by semicolons.[21] Each display attribute remains in effect until a following occurrence of SGR resets it.[5] If no codes are given, CSI m is treated as CSI 0 m (reset / normal).\n\nn Name Note 0 Reset or normal All attributes become turned off 1 Bold or increased intensity As with faint, the color change is a PC (SCO / CGA) invention.[22][better source needed] 2 Faint, decreased intensity, or dim May be implemented as a light font weight like bold.[23] 3 Italic Not widely supported. Sometimes treated as inverse or blink.[22] 4 Underline Style extensions exist for Kitty, VTE, mintty, iTerm2 and Konsole.[24][25][26] 5 Slow blink Sets blinking to less than 150 times per minute 6 Rapid blink MS-DOS ANSI.SYS, 150+ per minute; not widely supported 7 Reverse video or invert Swap foreground and background colors; inconsistent emulation[27][dubious – discuss] 8 Conceal or hide Not widely supported. 9 Crossed-out, or strike Characters legible but marked as if for deletion. Not supported in Terminal.app. 10 Primary (default) font 11–19 Alternative font Select alternative font n − 10 20 Fraktur (Gothic) Rarely supported 21 Doubly underlined; or: not bold Double-underline per ECMA-48,[5]: 8.3.117 but instead disables bold intensity on several terminals, including in the Linux kernel's console before version 4.17.[28] 22 Normal intensity Neither bold nor faint; color changes where intensity is implemented as such. 23 Neither italic, nor blackletter 24 Not underlined Neither singly nor doubly underlined 25 Not blinking Turn blinking off 26 Proportional spacing ITU T.61 and T.416, not known to be used on terminals 27 Not reversed 28 Reveal Not concealed 29 Not crossed out 30–37 Set foreground color 38 Set foreground color Next arguments are 5;n or 2;r;g;b 39 Default foreground color Implementation defined (according to standard) 40–47 Set background color 48 Set background color Next arguments are 5;n or 2;r;g;b 49 Default background color Implementation defined (according to standard) 50 Disable proportional spacing T.61 and T.416 51 Framed Implemented as \"emoji variation selector\" in mintty.[29] 52 Encircled 53 Overlined Not supported in Terminal.app 54 Neither framed nor encircled 55 Not overlined 58 Set underline color Not in standard; implemented in Kitty, VTE, mintty, and iTerm2.[24][25] Next arguments are 5;n or 2;r;g;b. 59 Default underline color Not in standard; implemented in Kitty, VTE, mintty, and iTerm2.[24][25] 60 Ideogram underline or right side line Rarely supported 61 Ideogram double underline, or double line on the right side 62 Ideogram overline or left side line 63 Ideogram double overline, or double line on the left side 64 Ideogram stress marking 65 No ideogram attributes Reset the effects of all of 60–64 73 Superscript Implemented only in mintty[29] 74 Subscript 75 Neither superscript nor subscript 90–97 Set bright foreground color Not in standard; originally implemented by aixterm[13] 100–107 Set bright background color\n\nColors\n\n[edit]\n\n3-bit and 4-bit\n\n[edit]\n\nThe original specification only had 8 colors, and just gave them names. The SGR parameters 30–37 selected the foreground color, while 40–47 selected the background. Quite a few terminals implemented \"bold\" (SGR code 1) as a brighter color rather than a different font, thus providing 8 additional foreground colors. Usually you could not get these as background colors, though sometimes inverse video (SGR code 7) would allow that. Examples: to get black letters on white background use ESC[30;47m, to get red use ESC[31m, to get bright red use ESC[1;31m. To reset colors to their defaults, use ESC[39;49m (not supported on some terminals), or reset all attributes with ESC[0m. Later terminals added the ability to directly specify the \"bright\" colors with 90–97 and 100–107.\n\nThe chart below shows a few examples of how VGA standard and modern terminal emulators translate the 4-bit color codes into 24-bit color codes.\n\n8-bit\n\n[edit]\n\nAs 256-color lookup tables became common on graphic cards, escape sequences were added to select from a pre-defined set of 256 colors:[citation needed]\n\nESC[38;5;⟨n⟩m Select foreground color where n is a number from the table below ESC[48;5;⟨n⟩m Select background color 0- 7: standard colors (as in ESC [ 30–37 m) 8- 15: high intensity colors (as in ESC [ 90–97 m) 16-231: 6 × 6 × 6 cube (216 colors): 16 + 36 × r + 6 × g + b (0 ≤ r, g, b ≤ 5) 232-255: grayscale from dark to light in 24 steps\n\nThe ITU's T.416 Information technology - Open Document Architecture (ODA) and interchange format: Character content architectures[34] uses \":\" as separator characters instead:\n\nESC[38:5:⟨n⟩m Select foreground color where n is a number from the table below ESC[48:5:⟨n⟩m Select background color\n\nThere has also been a similar but incompatible 88-color encoding using the same escape sequence, seen in rxvt and xterm-88color. Not much is known about the scheme besides the color codes. It uses a 4×4×4 color cube.\n\n24-bit\n\n[edit]\n\nAs \"true color\" graphic cards with 16 to 24 bits of color became common, applications began to support 24-bit colors. Terminal emulators supporting setting 24-bit foreground and background colors with escape sequences include Xterm,[13] KDE's Konsole,[35][36] and iTerm, as well as all libvte based terminals,[37] including GNOME Terminal.[38]\n\nESC[38;2;⟨r⟩;⟨g⟩;⟨b⟩ m Select RGB foreground color ESC[48;2;⟨r⟩;⟨g⟩;⟨b⟩ m Select RGB background color\n\nThe syntax is likely based on the ITU's T.416 Open Document Architecture (ODA) and interchange format: Character content architectures,[34] which was adopted as ISO/IEC 8613-6 but ended up as a commercial failure.[citation needed] The ODA version is more elaborate and thus incompatible:\n\nThe parameters after the '2' (r, g, and b) are optional and can be left empty.\n\nSemicolons are replaced by colons, as above.\n\nThere is a leading \"colorspace ID\".[13] The definition of the colorspace ID is not included in that specification, so it may be blank to represent the unspecified default. For CMYK color specifications, mintty interprets the colorspace ID parameter as specifying the maximum value which the channel values are given out of (e.g. 100 or 255).[29]\n\nIn addition to the '2' value after 48 to specify a Red-Green-Blue format (and the '5' above for a 0-255 indexed color), there are alternatives of '0' for implementation-defined and '1' for transparent - neither of which have any further parameters; '3' specifies colors using a Cyan-Magenta-Yellow scheme, and '4' for a Cyan-Magenta-Yellow-Black one, the latter using the position marked as \"unused\" for the Black component:[34]\n\nESC[38:2:⟨Color-Space-ID⟩:⟨r⟩:⟨g⟩:⟨b⟩:⟨unused⟩:⟨CS tolerance⟩:⟨Color-Space associated with tolerance: 0 for \"CIELUV\"; 1 for \"CIELAB\"⟩ m Select RGB foreground color ESC[48:2:⟨Color-Space-ID⟩:⟨r⟩:⟨g⟩:⟨b⟩:⟨unused⟩:⟨CS tolerance⟩:⟨Color-Space associated with tolerance: 0 for \"CIELUV\"; 1 for \"CIELAB\"⟩ m Select RGB background color\n\nThe ITU-RGB variation is supported by xterm, with the colorspace ID and tolerance parameters ignored. The simpler scheme using semicolons is initially found in Konsole.[13]: Can I set a color by its number?\n\nUnix environment variables relating to color support\n\n[edit]\n\nRather than using the color support in termcap and terminfo introduced in SVr3.2 (1987),[39] the S-Lang library (version 0.99-32, June 1996) used a separate environment variable $COLORTERM to indicate whether a terminal emulator could use colors at all, and later added values to indicate if it supported 24-bit color.[40][41] This system, although poorly documented, became widespread enough for Fedora and RHEL to consider using it as a simpler and more universal detection mechanism compared to querying the now-updated libraries.[42]\n\nSome terminal emulators (urxvt, konsole) set $COLORFGBG to report the color scheme of the terminal (mainly light vs. dark background). This behavior originated in S-Lang[41] and is used by vim. Gnome-terminal refuses to add this behavior, as the syntax for the value is not agreed upon, the value cannot be changed upon a runtime change of the palette, and more \"proper\" xterm OSC 4/10/11 sequences already exist.[43]\n\nOSC (Operating System Command) sequences\n\n[edit]\n\nMost Operating System Command sequences were defined by Xterm, but many are also supported by other terminal emulators. For historical reasons, Xterm can end the command with BEL (0x07) as well as the standard ST (0x9C or 0x1B 0x5C).[13] For example, Xterm allows the window title to be set by ESC ]0;this is the window title BEL.\n\nA non-xterm extension is the hyperlink, ESC ]8;;link ST from 2017, used by VTE,[44][discuss] iTerm2,[44] and mintty,[45] among others.[46]\n\nThe Linux console uses ESC ] P n rr gg bb to change the palette, which, if hard-coded into an application, may hang other terminals.[47] However, appending ST will be ignored by Linux and form a proper, ignorable sequence for other terminals.[citation needed]\n\nFs Escape sequences\n\n[edit]\n\nIf the ESC is followed by a byte in the range 0x60—0x7E, the escape sequence is of type Fs. This type is used for control functions individually registered with the ISO-IR registry.[48] A table of these is listed under ISO/IEC 2022.\n\nFp Escape sequences\n\n[edit]\n\nIf the ESC is followed by a byte in the range 0x30—0x3F, the escape sequence is of type Fp, which is set apart for up to sixteen private-use control functions.[12]: 6.5.3\n\nSome type Fp (private-use) escape sequences recognised by the VT100 Abbr Name Effect ESC 7 DECSC DEC Save Cursor Saves the cursor position, encoding shift state and formatting attributes.[49][13] ESC 8 DECRC DEC Restore Cursor Restores the cursor position, encoding shift state and formatting attributes from the previous DECSC if any, otherwise resets these all to their defaults.[49][13]\n\nnF Escape sequences\n\n[edit]\n\nIf the ESC is followed by a byte in the range 0x20—0x2F, the escape sequence is of type nF. Said byte is followed by any number of additional bytes in this range, and then a byte in the range 0x30-0x7E. These escape sequences are further subcategorised by the low two bits of the first byte, e.g. \"type 2F\" for sequences where the first byte is 0x22; and by whether the final byte is in the range 0x30—0x3F indicating private use (e.g. \"type 2Fp\") or not (e.g. \"type 2Ft\").[12]: 13.2.1\n\nMost of the nFt sequences are for changing the current character set, and are listed in ISO/IEC 2022. Some others:\n\nSome type 0Ft (announcement) ANSI escape sequences[13][12]: 15.2 Abbr Name Effect ESC SP F\n\nACS6\n\nS7C1T\n\nAnnounce Code Structure 6\n\nSend 7-bit C1 Control Character to the Host\n\nMakes the function keys send ESC + letter instead of 8-bit C1 codes. ESC SP G\n\nACS7\n\nS8C1T\n\nAnnounce Code Structure 7\n\nSend 8-bit C1 Control Character to the Host\n\nMakes the function keys send 8-bit C1 codes.\n\nIf the first byte is '#' the public sequences are reserved for additional ISO-IR registered individual control functions.[12]: 6.5.2 No such sequences are presently registered.[48] Type 3Fp sequences (which includes ones starting with '#') are available for private-use control functions.[12]: 6.5.3\n\nSome type 3Fp (private-use) escape sequences recognised by the VT100 Abbr Name Effect ESC # 3 DECDHL DEC Double-Height Letters, Top Half Makes the current line use characters twice as tall. This code is for the top half.[50] ESC # 4 DECDHL DEC Double-Height Letters, Bottom Half Makes the current line use characters twice as tall. This code is for the bottom half.[50] ESC # 5 DECSWL DEC Single-Width Line Makes the current line use single-width characters, per the default behaviour.[51][13] ESC # 6 DECDWL DEC Double-Width Line Makes the current line use double-width characters, discarding any characters in the second half of the line.[52][13]\n\nExamples\n\n[edit]\n\nCSI 2 J — This clears the screen and, on some devices, locates the cursor to the y,x position 1,1 (upper left corner).\n\nCSI 32 m — This makes text green. The green may be a dark, dull green, so you may wish to enable Bold with the sequence CSI 1 m which would make it bright green, or combined as CSI 32 ; 1 m. Some implementations use the Bold state to make the character Bright.\n\nCSI 0 ; 6 8 ; \"DIR\" ; 13 p — This reassigns the key F10 to send to the keyboard buffer the string \"DIR\" and ENTER, which in the DOS command line would display the contents of the current directory. (MS-DOS ANSI.SYS only) This was sometimes used for ANSI bombs. This is a private-use code (as indicated by the letter p), using a non-standard extension to include a string-valued parameter. Following the letter of the standard would consider the sequence to end at the letter D.\n\nCSI s — This saves the cursor position. Using the sequence CSI u will restore it to the position. Say the current cursor position is 7(y) and 10(x). The sequence CSI s will save those two numbers. Now you can move to a different cursor position, such as 20(y) and 3(x), using the sequence CSI 20 ; 3 H or CSI 20 ; 3 f. Now if you use the sequence CSI u the cursor position will return to 7(y) and 10(x). Some terminals require the DEC sequences ESC 7 / ESC 8 instead which is more widely supported.\n\nIn shell scripting\n\n[edit]\n\nANSI escape codes are often used in UNIX and UNIX-like terminals to provide syntax highlighting. For example, on compatible terminals, the following list command color-codes file and directory names by type.\n\nls --color\n\nUsers can employ escape codes in their scripts by including them as part of standard output or standard error. For example, the following GNU sed command embellishes the output of the make command by displaying lines containing words starting with \"WARN\" in reverse video and words starting with \"ERR\" in bright yellow on a dark red background (letter case is ignored). The representations of the codes are highlighted.[53]\n\nmake 2>&1 | sed -e 's/.*\\bWARN.*/\\x1b[7m&\\x1b[0m/i' -e 's/.*\\bERR.*/\\x1b[93;41m&\\x1b[0m/i'\n\nThe following Bash function flashes the terminal (by alternately sending reverse and normal video mode codes) until the user presses a key.[54]\n\nflasher(){while true;doprintf \\\\e[?5h; sleep0.1;printf \\\\e[?5l;read -s -n1 -t1&&break;done;}\n\nThis can be used to alert a programmer when a lengthy command terminates, such as with make ; flasher .[55]\n\nprintf\\\\033c\n\nThis will reset the console, similar to the command reset on modern Linux systems; however it should work even on older Linux systems and on other (non-Linux) UNIX variants.\n\nIn C\n\n[edit]\n\n#include<stdio.h> intmain(void) { inti,j,n; for(i=0;i<11;i++){ for(j=0;j<10;j++){ n=10*i+j; if(n>108)break; printf(\"\\033[%dm %3d\\033[m\",n,n); } printf(\"\\n\"); } return0; }\n\nTerminal input sequences\n\n[edit]\n\nPressing special keys on the keyboard, as well as outputting many xterm CSI, DCS, or OSC sequences, often produces a CSI, DCS, or OSC sequence, sent from the terminal to the computer as though the user typed it.\n\nWhen typing input on a terminal keypresses outside the normal main alphanumeric keyboard area can be sent to the host as ANSI sequences. For keys that have an equivalent output function, such as the cursor keys, these often mirror the output sequences. However, for most keypresses there isn't an equivalent output sequence to use.\n\nThere are several encoding schemes, and unfortunately most terminals mix sequences from different schemes, so host software has to be able to deal with input sequences using any scheme. To complicate the matter, the VT terminals themselves have two schemes of input, normal mode and application mode that can be switched by the application.\n\n(draft section)\n\n<char> -> char <esc> <nochar> -> esc <esc> <esc> -> esc <esc> <char> -> Alt-keypress or keycode sequence <esc> '[' <nochar> -> Alt-[ <esc> '[' (<modifier>) <char> -> keycode sequence, <modifier> is a decimal number and defaults to 1 (xterm) <esc> '[' (<keycode>) (';'<modifier>) '~' -> keycode sequence, <keycode> and <modifier> are decimal numbers and default to 1 (vt)\n\nIf the terminating character is '~', the first number must be present and is a keycode number, the second number is an optional modifier value. If the terminating character is a letter, the letter is the keycode value, and the optional number is the modifier value.\n\nThe modifier value defaults to 1, and after subtracting 1 is a bitmap of modifier keys being pressed: Meta+Ctrl+Alt+⇧ Shift. So, for example, <esc>[4;2~ is ⇧ Shift+End, <esc>[20~ is function key F9, <esc>[5C is Ctrl+→.\n\nIn other words, the modifier is the sum of the following numbers:\n\nKey pressed Number Comment 1 always added, the rest are optional Shift 1 (Left) Alt 2 Control 4 Meta 8\n\nvt sequences: <esc>[1~ - Home <esc>[16~ - <esc>[31~ - F17 <esc>[2~ - Insert <esc>[17~ - F6 <esc>[32~ - F18 <esc>[3~ - Delete <esc>[18~ - F7 <esc>[33~ - F19 <esc>[4~ - End <esc>[19~ - F8 <esc>[34~ - F20 <esc>[5~ - PgUp <esc>[20~ - F9 <esc>[35~ - <esc>[6~ - PgDn <esc>[21~ - F10 <esc>[7~ - Home <esc>[22~ - <esc>[8~ - End <esc>[23~ - F11 <esc>[9~ - <esc>[24~ - F12 <esc>[10~ - F0 <esc>[25~ - F13 <esc>[11~ - F1 <esc>[26~ - F14 <esc>[12~ - F2 <esc>[27~ - <esc>[13~ - F3 <esc>[28~ - F15 <esc>[14~ - F4 <esc>[29~ - F16 <esc>[15~ - F5 <esc>[30~ - xterm sequences: <esc>[A - Up <esc>[K - <esc>[U - <esc>[B - Down <esc>[L - <esc>[V - <esc>[C - Right <esc>[M - <esc>[W - <esc>[D - Left <esc>[N - <esc>[X - <esc>[E - <esc>[O - <esc>[Y - <esc>[F - End <esc>[1P - F1 <esc>[Z - <esc>[G - Keypad 5 <esc>[1Q - F2 <esc>[H - Home <esc>[1R - F3 <esc>[I - <esc>[1S - F4 <esc>[J - <esc>[T -\n\n<esc>[A to <esc>[D are the same as the ANSI output sequences. The <modifier> is normally omitted if no modifier keys are pressed, but most implementations always emit the <modifier> for F1–F4. (draft section)\n\nXterm has a comprehensive documentation page on the various function-key and mouse input sequence schemes from DEC's VT terminals and various other terminals it emulates.[13] Thomas Dickey has added a lot of support to it over time;[56] he also maintains a list of default keys used by other terminal emulators for comparison.[57]\n\nOn the Linux console, certain function keys generate sequences of the form CSI [ char. The CSI sequence should terminate on the [.\n\nOld versions of Terminator generate SS3 1; modifiers char when F1 – F4 are pressed with modifiers. The faulty behavior was copied from GNOME Terminal.[citation needed]\n\nxterm replies CSI row ; column R if asked for cursor position and CSI 1 ; modifiers R if the F3 key is pressed with modifiers, which collide in the case of row == 1. This can be avoided by using the ? private modifier as CSI ? 6 n, which will be reflected in the response as CSI ? row ; column R.\n\nmany terminals prepend ESC to any character that is typed with the alt key down. This creates ambiguity for uppercase letters and symbols @[\\]^_, which would form C1 codes.[clarification needed]\n\nKonsole generates SS3 modifiers char when F1 – F4 are pressed with modifiers.[clarification needed]\n\niTerm2 supports reporting additional keys via an enhanced CSI u mode.[58]\n\nSee also\n\n[edit]\n\nANSI art\n\nControl character\n\nAdvanced Video Attribute Terminal Assembler and Recreator (AVATAR)\n\nISO/IEC JTC 1/SC 2\n\nC0 and C1 control codes\n\nNotes\n\n[edit]\n\nReferences\n\n[edit]"
    }
}